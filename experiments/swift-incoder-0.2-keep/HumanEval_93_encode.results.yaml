language: swift
name: HumanEval_93_encode
results:
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n            result\
    \ = \"t\"\n        case \"e\":\n            result = \"h\"\n        case \"i\"\
    :\n            result = \"k\"\n        case \"o\":\n            result = \"g\"\
    \n        case \"u\":\n            result = \"s\"\n        case \"A\":\n     \
    \       result = \"T\"\n        case \"E\":\n            result = \"H\"\n    \
    \    case \"I\":\n            result = \"K\"\n        case \"O\":\n          \
    \  result = \"G\"\n        case \"U\":\n            result = \"S\"\n        default:\n\
    \            result = letter\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp4wx_b_bh.swift:37:22: error: cannot assign value of type 'Character'\
    \ to type 'String'\n            result = letter\n                     ^~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += letter.lowercased()\n\
    \        } else {\n            result += letter.uppercased()\n        }\n    }\n\
    \    for letter in result {\n        if letter.isUpper() {\n            result\
    \ += letter.lowercased()\n        } else {\n            result += letter.uppercased()\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpo9ucstmd.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmpo9ucstmd.swift:22:19:\
    \ error: value of type 'Character' has no member 'isUpper'\n        if letter.isUpper()\
    \ {\n           ~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)!\n        let replacement\
    \ = alphabet[index + 2]\n        result += String(letter).replacingOccurrences(of:\
    \ vowel, with: replacement)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmphl1lkr80.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)!\n                    ^~~~~~~~\n\
    /tmp/tmphl1lkr80.swift:16:27: error: cannot find 'alphabet' in scope\n       \
    \ let replacement = alphabet[index + 2]\n                          ^~~~~~~~\n\
    /tmp/tmphl1lkr80.swift:17:59: error: cannot find 'vowel' in scope\n        result\
    \ += String(letter).replacingOccurrences(of: vowel, with: replacement)\n     \
    \                                                     ^~~~~\n/tmp/tmphl1lkr80.swift:17:34:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ result += String(letter).replacingOccurrences(of: vowel, with: replacement)\n\
    \                  ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for char in\
    \ message {\n        let index = english.index(of: char)\n        let replacement\
    \ = english[(index! + 2)%26]\n        result += String(char).replacingOccurrences(of:\
    \ char, with: replacement)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpfq4q1vkw.swift:15:21: error: cannot find 'english' in scope\n \
    \       let index = english.index(of: char)\n                    ^~~~~~~\n/tmp/tmpfq4q1vkw.swift:16:27:\
    \ error: cannot find 'english' in scope\n        let replacement = english[(index!\
    \ + 2)%26]\n                          ^~~~~~~\n/tmp/tmpfq4q1vkw.swift:17:32: error:\
    \ value of type 'String' has no member 'replacingOccurrences'\n        result\
    \ += String(char).replacingOccurrences(of: char, with: replacement)\n        \
    \          ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n        case \"e\"\
    :\n        case \"i\":\n        case \"o\":\n        case \"u\":\n           \
    \ result += letter\n        default:\n            result += letter\n         \
    \   result += letter.lowercased\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp8jwz106w.swift:16:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"a\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmp8jwz106w.swift:17:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"e\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmp8jwz106w.swift:18:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"i\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp8jwz106w.swift:19:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"o\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp8jwz106w.swift:21:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n/tmp/tmp8jwz106w.swift:23:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n/tmp/tmp8jwz106w.swift:24:30:\
    \ error: function produces expected type 'String'; did you mean to call it with\
    \ '()'?\n            result += letter.lowercased\n                      ~~~~~~~^~~~~~~~~~\n\
    \                                       ()\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)!\n        let replacement\
    \ = alphabet[index + 2]\n        result += String(letter).replacingOccurrences(of:\
    \ \"A\", with: replacement)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpfrbeb_za.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)!\n                    ^~~~~~~~\n\
    /tmp/tmpfrbeb_za.swift:16:27: error: cannot find 'alphabet' in scope\n       \
    \ let replacement = alphabet[index + 2]\n                          ^~~~~~~~\n\
    /tmp/tmpfrbeb_za.swift:17:34: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        result += String(letter).replacingOccurrences(of: \"A\", with: replacement)\n\
    \                  ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n            result\
    \ = \"t\"\n        case \"e\":\n            result = \"h\"\n        case \"i\"\
    :\n            result = \"k\"\n        case \"o\":\n            result = \"g\"\
    \n        case \"u\":\n            result = \"s\"\n        case \"A\":\n     \
    \       result = \"T\"\n        case \"E\":\n            result = \"H\"\n    \
    \    case \"I\":\n            result = \"K\"\n        case \"O\":\n          \
    \  result = \"G\"\n        case \"U\":\n            result = \"S\"\n        default:\n\
    \            result = letter\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp4wx_b_bh.swift:37:22: error: cannot assign value of type 'Character'\
    \ to type 'String'\n            result = letter\n                     ^~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)\n        if index\
    \ == nil {\n            return \"\"\n        }\n        let nextLetter = alphabet[index!\
    \ + 1]\n        let index = alphabet.index(of: nextLetter)\n        if index ==\
    \ nil {\n            return \"\"\n        }\n        let nextVowel = alphabet[index!\
    \ + 1]\n        let index = alphabet.index(of: nextVowel)\n        if index ==\
    \ nil {\n            return \"\"\n        }\n        let nextVowel = alphabet[index!\
    \ + 1]\n        let index = alphabet.index(of: nextVowel)\n        if index ==\
    \ nil {\n            return \"\"\n        }\n        let nextVowel = alphabet[index!\
    \ + 1]\n        let index = alphabet.index(of: nextVowel)\n        if index ==\
    \ nil {\n            return \"\"\n        }\n        let nextVowel = alphabet[index!\
    \ + 1]\n        let index = alphabet.index(of: nextVowel)\n        if index ==\
    \ nil {\n            return \"\"\n        }\n        let nextVowel = alphabet[index!\
    \ + 1]\n        let index = alphabet.index(of: nextVowel)\n        if index ==\
    \ nil {\n            return \"\"\n        }\n        let nextVowel = alphabet[index!\
    \ + 1]\n        let index = alphabet.index(of: nextVowel)\n        if index ==\
    \ nil {\n            return \"\"\n        }\n        let nextVowel = alphabet[index!\
    \ + 1]\n        let index = alphabet.index(of: nextVowel)\n        if index ==\
    \ nil {\n            return \"\"\n        }\n        let nextVowel = alphabet[index!\
    \ + 1]\n        let index = alphabet.index(of: nextVowel)\n        if index ==\
    \ nil {\n            return \"\"\n        }\n        let nextVowel = alphabet[index!\
    \ + 1]\n        let index = alphabet.index(of: nextVowel)\n        if index ==\
    \ nil {\n            return \"\"\n        }\n        let nextVowel = alphabet[index!\
    \ + 1]\n        let index = alphabet.index(of: nextVowel)\n        if index ==\
    \ nil {\n            return \"\"\n        }\n        let nextVowel = alphabet[index!\
    \ + 1]\n        let index = alphabet.index(of: nextVowel)\n        if index ==\
    \ nil {\n            return \"\"\n        }\n        let nextVowel = alphabet[index!\
    \ + 1]\n        let index = alphabet.index(of: nextVowel)\n        if index ==\
    \ nil {\n            return \"\"\n        }\n        let nextVowel = alphabet[index!\
    \ + 1]\n        let index = alphabet.index(of: nextVowel)\n        if index ==\
    \ nil {\n            return \"\"\n        }\n        let nextVowel = alphabet[index!\
    \ + 1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\"\
    ) == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpe_1sx8yw.swift:109:84: error: expected '}' at end of brace statement\n\
    assert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq\
    \ wRkTg\")\n                                                                 \
    \                  ^\n/tmp/tmpe_1sx8yw.swift:12:40: note: to match this opening\
    \ '{'\nfunc encode(message: String) -> String {\n                            \
    \           ^\n/tmp/tmpe_1sx8yw.swift:15:21: error: cannot find 'alphabet' in\
    \ scope\n        let index = alphabet.index(of: letter)\n                    ^~~~~~~~\n\
    /tmp/tmpe_1sx8yw.swift:19:26: error: cannot find 'alphabet' in scope\n       \
    \ let nextLetter = alphabet[index! + 1]\n                         ^~~~~~~~\n/tmp/tmpe_1sx8yw.swift:20:21:\
    \ error: cannot find 'alphabet' in scope\n        let index = alphabet.index(of:\
    \ nextLetter)\n                    ^~~~~~~~\n/tmp/tmpe_1sx8yw.swift:24:25: error:\
    \ cannot find 'alphabet' in scope\n        let nextVowel = alphabet[index! + 1]\n\
    \                        ^~~~~~~~\n/tmp/tmpe_1sx8yw.swift:25:21: error: cannot\
    \ find 'alphabet' in scope\n        let index = alphabet.index(of: nextVowel)\n\
    \                    ^~~~~~~~\n/tmp/tmpe_1sx8yw.swift:29:25: error: cannot find\
    \ 'alphabet' in scope\n        let nextVowel = alphabet[index! + 1]\n        \
    \                ^~~~~~~~\n/tmp/tmpe_1sx8yw.swift:30:21: error: cannot find 'alphabet'\
    \ in scope\n        let index = alphabet.index(of: nextVowel)\n              \
    \      ^~~~~~~~\n/tmp/tmpe_1sx8yw.swift:34:25: error: cannot find 'alphabet' in\
    \ scope\n        let nextVowel = alphabet[index! + 1]\n                      \
    \  ^~~~~~~~\n/tmp/tmpe_1sx8yw.swift:35:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: nextVowel)\n                    ^~~~~~~~\n\
    /tmp/tmpe_1sx8yw.swift:39:25: error: cannot find 'alphabet' in scope\n       \
    \ let nextVowel = alphabet[index! + 1]\n                        ^~~~~~~~\n/tmp/tmpe_1sx8yw.swift:40:21:\
    \ error: cannot find 'alphabet' in scope\n        let index = alphabet.index(of:\
    \ nextVowel)\n                    ^~~~~~~~\n/tmp/tmpe_1sx8yw.swift:44:25: error"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = english.index(of: letter)\n        let replacement\
    \ = english[index! + 2]\n        result += replacement\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpmve_hk14.swift:15:21: error: cannot find 'english' in scope\n \
    \       let index = english.index(of: letter)\n                    ^~~~~~~\n/tmp/tmpmve_hk14.swift:16:27:\
    \ error: cannot find 'english' in scope\n        let replacement = english[index!\
    \ + 2]\n                          ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)!\n        let nextLetter\
    \ = alphabet[index + 2]\n        let replacement = alphabet[index + 1]\n     \
    \   result += nextLetter + replacement\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpx5ihkqcj.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)!\n                    ^~~~~~~~\n\
    /tmp/tmpx5ihkqcj.swift:16:26: error: cannot find 'alphabet' in scope\n       \
    \ let nextLetter = alphabet[index + 2]\n                         ^~~~~~~~\n/tmp/tmpx5ihkqcj.swift:17:27:\
    \ error: cannot find 'alphabet' in scope\n        let replacement = alphabet[index\
    \ + 1]\n                          ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n        case \"e\"\
    :\n        case \"i\":\n        case \"o\":\n        case \"u\":\n           \
    \ result += letter\n        default:\n            result += letter + String(letter).characters.map\
    \ { String($0).lowercased().firstIndex(of: String(letter).lowercased()) ?? 0 }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpcwpa3siy.swift:16:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"a\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpcwpa3siy.swift:17:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"e\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmpcwpa3siy.swift:18:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"i\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpcwpa3siy.swift:19:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"o\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpcwpa3siy.swift:21:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n/tmp/tmpcwpa3siy.swift:23:13:\
    \ error: the compiler is unable to type-check this expression in reasonable time;\
    \ try breaking up the expression into distinct sub-expressions\n            result\
    \ += letter + String(letter).characters.map { String($0).lowercased().firstIndex(of:\
    \ String(letter).lowercased()) ?? 0 }\n            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824731
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for char in\
    \ message {\n        let index = english.index(of: char)\n        let replacement\
    \ = english[index! + 2]\n        result += String(char).replacingOccurrences(of:\
    \ char, with: replacement)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp2xh1j4yn.swift:15:21: error: cannot find 'english' in scope\n \
    \       let index = english.index(of: char)\n                    ^~~~~~~\n/tmp/tmp2xh1j4yn.swift:16:27:\
    \ error: cannot find 'english' in scope\n        let replacement = english[index!\
    \ + 2]\n                          ^~~~~~~\n/tmp/tmp2xh1j4yn.swift:17:32: error:\
    \ value of type 'String' has no member 'replacingOccurrences'\n        result\
    \ += String(char).replacingOccurrences(of: char, with: replacement)\n        \
    \          ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)\n        if index\
    \ == nil {\n            result += letter\n        } else {\n            let twoLettersBefore\
    \ = alphabet.index(of: alphabet[index!], offsetBy: 2)\n            if twoLettersBefore\
    \ == nil {\n                result += alphabet[index!]\n            } else {\n\
    \                result += alphabet[twoLettersBefore!]\n            }\n      \
    \  }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp97gxz944.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)\n                    ^~~~~~~~\n\
    /tmp/tmp97gxz944.swift:17:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += letter\n         \
    \             ^\n/tmp/tmp97gxz944.swift:19:36: error: cannot find 'alphabet' in\
    \ scope\n            let twoLettersBefore = alphabet.index(of: alphabet[index!],\
    \ offsetBy: 2)\n                                   ^~~~~~~~\n/tmp/tmp97gxz944.swift:19:55:\
    \ error: cannot find 'alphabet' in scope\n            let twoLettersBefore = alphabet.index(of:\
    \ alphabet[index!], offsetBy: 2)\n                                           \
    \           ^~~~~~~~\n/tmp/tmp97gxz944.swift:21:27: error: cannot find 'alphabet'\
    \ in scope\n                result += alphabet[index!]\n                     \
    \     ^~~~~~~~\n/tmp/tmp97gxz944.swift:23:27: error: cannot find 'alphabet' in\
    \ scope\n                result += alphabet[twoLettersBefore!]\n             \
    \             ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += letter.lowercased()\n\
    \        } else {\n            result += letter.uppercased()\n        }\n    }\n\
    \    for vowel in \"AEIOUaeiou\" {\n        let index = result.index(of: vowel)\n\
    \        if index != nil {\n            let two = result.index(before: index!)\n\
    \            let one = result.index(before: two!)\n            let replacement\
    \ = result.substring(from: one!)\n            result = result.substring(to: index!)\
    \ + replacement\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpdmhwt77_.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmpdmhwt77_.swift:22:28:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ index = result.index(of: vowel)\n                           ^\n/tmp/tmpdmhwt77_.swift:22:28:\
    \ note: use 'firstIndex(of:)' instead\n        let index = result.index(of: vowel)\n\
    \                           ^~~~~\n                           firstIndex\n/tmp/tmpdmhwt77_.swift:25:47:\
    \ error: cannot force unwrap value of non-optional type 'String.Index'\n     \
    \       let one = result.index(before: two!)\n                               \
    \            ~~~^\n                                              \n/tmp/tmpdmhwt77_.swift:26:38:\
    \ error: value of type 'String' has no member 'substring'\n            let replacement\
    \ = result.substring(from: one!)\n                              ~~~~~~ ^~~~~~~~~\n\
    /tmp/tmpdmhwt77_.swift:27:29: error: value of type 'String' has no member 'substring'\n\
    \            result = result.substring(to: index!) + replacement\n           \
    \          ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = english.index(of: letter)\n        let vowel\
    \ = vowels[index]\n        let replacement = english[vowel.next!.index]\n    \
    \    result += replacement\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp7dxd_3_v.swift:15:21: error: cannot find 'english' in scope\n \
    \       let index = english.index(of: letter)\n                    ^~~~~~~\n/tmp/tmp7dxd_3_v.swift:16:21:\
    \ error: cannot find 'vowels' in scope\n        let vowel = vowels[index]\n  \
    \                  ^~~~~~\n/tmp/tmp7dxd_3_v.swift:17:27: error: cannot find 'english'\
    \ in scope\n        let replacement = english[vowel.next!.index]\n           \
    \               ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)\n        let replacement\
    \ = alphabet[index! + 2]\n        result += replacement\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpdyrk0qg1.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)\n                    ^~~~~~~~\n\
    /tmp/tmpdyrk0qg1.swift:16:27: error: cannot find 'alphabet' in scope\n       \
    \ let replacement = alphabet[index! + 2]\n                          ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n        case \"e\"\
    :\n        case \"i\":\n        case \"o\":\n        case \"u\":\n           \
    \ result += letter\n        default:\n            result += letter.lowercased()\n\
    \        }\n    }\n    for letter in result {\n        switch letter {\n     \
    \   case \"a\":\n        case \"e\":\n        case \"i\":\n        case \"o\"\
    :\n        case \"u\":\n            result += letter.lowercased()\n        default:\n\
    \            result += letter\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpw6b3x6y1.swift:16:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"a\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpw6b3x6y1.swift:17:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"e\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmpw6b3x6y1.swift:18:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"i\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpw6b3x6y1.swift:19:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"o\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpw6b3x6y1.swift:28:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"a\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpw6b3x6y1.swift:29:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"e\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpw6b3x6y1.swift:30:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"i\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpw6b3x6y1.swift:31:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"o\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpw6b3x6y1.swift:21:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n/tmp/tmpw6b3x6y1.swift:35:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += String(letter)\n\
    \        } else {\n            result += String(letter).swapCase()\n        }\n\
    \    }\n    for letter in result {\n        if letter.isLetter() {\n         \
    \   result += String(letter)\n        } else {\n            result += String(letter).swapCase()\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp2o482ak5.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmp2o482ak5.swift:18:38:\
    \ error: value of type 'String' has no member 'swapCase'\n            result +=\
    \ String(letter).swapCase()\n                      ~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmp2o482ak5.swift:22:19:\
    \ error: cannot call value of non-function type 'Bool'\n        if letter.isLetter()\
    \ {\n                  ^       ~~\n                          \n/tmp/tmp2o482ak5.swift:25:38:\
    \ error: value of type 'String' has no member 'swapCase'\n            result +=\
    \ String(letter).swapCase()\n                      ~~~~~~~~~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += letter.lowercased()\n\
    \        } else {\n            result += letter.uppercased()\n        }\n    }\n\
    \    for vowel in \"AEIOUaeiou\" {\n        result = result.replacingOccurrences(of:\
    \ vowel, with: vowel.lowercased())\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp28mxbr40.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmp28mxbr40.swift:22:25:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ result = result.replacingOccurrences(of: vowel, with: vowel.lowercased())\n\
    \                 ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"A\":\n            result\
    \ += \"B\"\n        case \"B\":\n            result += \"A\"\n        case \"\
    C\":\n            result += \"D\"\n        case \"D\":\n            result +=\
    \ \"C\"\n        case \"E\":\n            result += \"F\"\n        case \"F\"\
    :\n            result += \"E\"\n        case \"G\":\n            result += \"\
    H\"\n        case \"H\":\n            result += \"G\"\n        case \"I\":\n \
    \           result += \"J\"\n        case \"J\":\n            result += \"I\"\n\
    \        case \"K\":\n            result += \"L\"\n        case \"L\":\n     \
    \       result += \"K\"\n        case \"M\":\n            result += \"N\"\n  \
    \      case \"N\":\n            result += \"M\"\n        case \"O\":\n       \
    \     result += \"P\"\n        case \"P\":\n            result += \"O\"\n    \
    \    case \"Q\":\n            result += \"R\"\n        case \"R\":\n         \
    \   result += \"Q\"\n        case \"S\":\n            result += \"T\"\n      \
    \  case \"T\":\n            result += \"S\"\n        case \"U\":\n           \
    \ result += \"V\"\n        case \"V\":\n            result += \"U\"\n        case\
    \ \"W\":\n            result += \"X\"\n        case \"X\":\n            result\
    \ += \"W\"\n        case \"Y\":\n            result += \"Z\"\n        case \"\
    Z\":\n            result += \"Y\"\n        default:\n            result += letter\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpuxwr7kk6.swift:69:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += letter\n         \
    \             ^\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n            result\
    \ += \"A\"\n        case \"b\":\n            result += \"B\"\n        case \"\
    c\":\n            result += \"C\"\n        case \"d\":\n            result +=\
    \ \"D\"\n        case \"e\":\n            result += \"E\"\n        case \"f\"\
    :\n            result += \"F\"\n        case \"g\":\n            result += \"\
    G\"\n        case \"h\":\n            result += \"H\"\n        case \"i\":\n \
    \           result += \"I\"\n        case \"j\":\n            result += \"J\"\n\
    \        case \"k\":\n            result += \"K\"\n        case \"l\":\n     \
    \       result += \"L\"\n        case \"m\":\n            result += \"M\"\n  \
    \      case \"n\":\n            result += \"N\"\n        case \"o\":\n       \
    \     result += \"O\"\n        case \"p\":\n            result += \"P\"\n    \
    \    case \"q\":\n            result += \"Q\"\n        case \"r\":\n         \
    \   result += \"R\"\n        case \"s\":\n            result += \"S\"\n      \
    \  case \"t\":\n            result += \"T\"\n        case \"u\":\n           \
    \ result += \"U\"\n        case \"v\":\n            result += \"V\"\n        case\
    \ \"w\":\n            result += \"W\"\n        case \"x\":\n            result\
    \ += \"X\"\n        case \"y\":\n            result += \"Y\"\n        case \"\
    z\":\n            result += \"Z\"\n        default:\n            result += letter\n\
    \        }\n    }\n    for vowel in \"aeiou\" {\n        if let index = result.characters.indexOf(vowel)\
    \ {\n            let nextVowel = result.characters.index(before: index)\n    \
    \        let nextLetter = result.characters.index(before: nextVowel)\n       \
    \     let nextLetter = result.characters.index(before: nextLetter)\n         \
    \   let nextLetter = result.characters.index(before: nextLetter)\n           \
    \ let nextLetter = result.characters.index(before: nextLetter)\n            let\
    \ nextLetter = result.characters.index(before: nextLetter)\n            let nextLetter\
    \ = result.characters.index(before: nextLetter)\n            let nextLetter =\
    \ result.characters.index(before: nextLetter)\n            let nextLetter = result.characters.index(before:\
    \ nextLetter)\n            let nextLetter = result.characters.index(before: nextLetter)\n\
    \            let nextLetter = result.characters.index(before: nextLetter)\n  \
    \          let nextLetter = result.characters.index(before: nextLetter)\n    \
    \        let nextLetter = result.characters.index(before: nextLetter)\n      \
    \      let nextLetter = result.characters.index(before: nextLetter)\n        \
    \    let nextLetter = \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpcrmmhum3.swift:88:29: error: expected initial value after '='\n\
    \            let nextLetter = \n                            ^\n/tmp/tmpcrmmhum3.swift:108:84:\
    \ error: expected '}' at end of brace statement\nassert(encode(message: \"I DoNt\
    \ KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")\n                  \
    \                                                                 ^\n/tmp/tmpcrmmhum3.swift:72:26:\
    \ note: to match this opening '{'\n    for vowel in \"aeiou\" {\n            \
    \             ^\n/tmp/tmpcrmmhum3.swift:108:84: error: expected '}' at end of\
    \ brace statement\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")\n                                               \
    \                                    ^\n/tmp/tmpcrmmhum3.swift:12:40: note: to\
    \ match this opening '{'\nfunc encode(message: String) -> String {\n         \
    \                              ^\n/tmp/tmpcrmmhum3.swift:69:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += letter\n                      ^\n/tmp/tmpcrmmhum3.swift:73:42:\
    \ error: value of type 'String' has no member 'indexOf'\n        if let index\
    \ = result.characters.indexOf(vowel) {\n                       ~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~\n/tmp/tmpcrmmhum3.swift:92:6: error: operator functions can only be\
    \ declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n            result\
    \ = \"t\"\n        case \"b\":\n            result = \"h\"\n        case \"c\"\
    :\n            result = \"k\"\n        case \"d\":\n            result = \"g\"\
    \n        case \"e\":\n            result = \"s\"\n        case \"f\":\n     \
    \       result = \"c\"\n        case \"g\":\n            result = \"g\"\n    \
    \    case \"h\":\n            result = \"h\"\n        case \"i\":\n          \
    \  result = \"k\"\n        case \"j\":\n            result = \"c\"\n        case\
    \ \"k\":\n            result = \"k\"\n        case \"l\":\n            result\
    \ = \"g\"\n        case \"m\":\n            result = \"s\"\n        case \"n\"\
    :\n            result = \"c\"\n        case \"o\":\n            result = \"m\"\
    \n        case \"p\":\n            result = \"g\"\n        case \"q\":\n     \
    \       result = \"k\"\n        case \"r\":\n            result = \"s\"\n    \
    \    case \"s\":\n            result = \"s\"\n        case \"t\":\n          \
    \  result = \"t\"\n        case \"u\":\n            result = \"k\"\n        case\
    \ \"v\":\n            result = \"c\"\n        case \"w\":\n            result\
    \ = \"g\"\n        case \"x\":\n            result = \"k\"\n        case \"y\"\
    :\n            result = \"c\"\n        case \"z\":\n            result = \"g\"\
    \n        default:\n            result = letter\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\"\
    ) == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpen10d8il.swift:69:22: error: cannot assign value of type 'Character'\
    \ to type 'String'\n            result = letter\n                     ^~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n            result\
    \ = \"t\"\n        case \"e\":\n            result = \"h\"\n        case \"i\"\
    :\n            result = \"k\"\n        case \"o\":\n            result = \"g\"\
    \n        case \"u\":\n            result = \"s\"\n        case \"A\":\n     \
    \       result = \"T\"\n        case \"E\":\n            result = \"H\"\n    \
    \    case \"I\":\n            result = \"K\"\n        case \"O\":\n          \
    \  result = \"G\"\n        case \"U\":\n            result = \"S\"\n        default:\n\
    \            result = letter\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp4wx_b_bh.swift:37:22: error: cannot assign value of type 'Character'\
    \ to type 'String'\n            result = letter\n                     ^~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n            result\
    \ += \"A\"\n        case \"b\":\n            result += \"B\"\n        case \"\
    c\":\n            result += \"C\"\n        case \"d\":\n            result +=\
    \ \"D\"\n        case \"e\":\n            result += \"E\"\n        case \"f\"\
    :\n            result += \"F\"\n        case \"g\":\n            result += \"\
    G\"\n        case \"h\":\n            result += \"H\"\n        case \"i\":\n \
    \           result += \"I\"\n        case \"j\":\n            result += \"J\"\n\
    \        case \"k\":\n            result += \"K\"\n        case \"l\":\n     \
    \       result += \"L\"\n        case \"m\":\n            result += \"M\"\n  \
    \      case \"n\":\n            result += \"N\"\n        case \"o\":\n       \
    \     result += \"O\"\n        case \"p\":\n            result += \"P\"\n    \
    \    case \"q\":\n            result += \"Q\"\n        case \"r\":\n         \
    \   result += \"R\"\n        case \"s\":\n            result += \"S\"\n      \
    \  case \"t\":\n            result += \"T\"\n        case \"u\":\n           \
    \ result += \"U\"\n        case \"v\":\n            result += \"V\"\n        case\
    \ \"w\":\n            result += \"W\"\n        case \"x\":\n            result\
    \ += \"X\"\n        case \"y\":\n            result += \"Y\"\n        case \"\
    z\":\n            result += \"Z\"\n        default:\n            result += letter\n\
    \        }\n    }\n    for vowel in \"aeiou\" {\n        result += vowel\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp4tle88ni.swift:69:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += letter\n         \
    \             ^\n/tmp/tmp4tle88ni.swift:73:19: error: cannot convert value of\
    \ type 'Character' to expected argument type 'String'\n        result += vowel\n\
    \                  ^\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n            result\
    \ = \"t\"\n        case \"e\":\n            result = \"h\"\n        case \"i\"\
    :\n            result = \"k\"\n        case \"o\":\n            result = \"g\"\
    \n        case \"u\":\n            result = \"s\"\n        case \"A\":\n     \
    \       result = \"T\"\n        case \"E\":\n            result = \"H\"\n    \
    \    case \"I\":\n            result = \"K\"\n        case \"O\":\n          \
    \  result = \"G\"\n        case \"U\":\n            result = \"S\"\n        default:\n\
    \            result = letter\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp4wx_b_bh.swift:37:22: error: cannot assign value of type 'Character'\
    \ to type 'String'\n            result = letter\n                     ^~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = english.index(of: letter)\n        let replacement\
    \ = english[index!.advanced(by: 2)!]\n        result += String(letter).replacingOccurrences(of:\
    \ \"AEIOUaeiou\", with: replacement)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpy06d2cih.swift:15:21: error: cannot find 'english' in scope\n \
    \       let index = english.index(of: letter)\n                    ^~~~~~~\n/tmp/tmpy06d2cih.swift:16:27:\
    \ error: cannot find 'english' in scope\n        let replacement = english[index!.advanced(by:\
    \ 2)!]\n                          ^~~~~~~\n/tmp/tmpy06d2cih.swift:17:34: error:\
    \ value of type 'String' has no member 'replacingOccurrences'\n        result\
    \ += String(letter).replacingOccurrences(of: \"AEIOUaeiou\", with: replacement)\n\
    \                  ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n            result\
    \ += \"A\"\n        case \"b\":\n            result += \"B\"\n        case \"\
    c\":\n            result += \"C\"\n        case \"d\":\n            result +=\
    \ \"D\"\n        case \"e\":\n            result += \"E\"\n        case \"f\"\
    :\n            result += \"F\"\n        case \"g\":\n            result += \"\
    G\"\n        case \"h\":\n            result += \"H\"\n        case \"i\":\n \
    \           result += \"I\"\n        case \"j\":\n            result += \"J\"\n\
    \        case \"k\":\n            result += \"K\"\n        case \"l\":\n     \
    \       result += \"L\"\n        case \"m\":\n            result += \"M\"\n  \
    \      case \"n\":\n            result += \"N\"\n        case \"o\":\n       \
    \     result += \"O\"\n        case \"p\":\n            result += \"P\"\n    \
    \    case \"q\":\n            result += \"Q\"\n        case \"r\":\n         \
    \   result += \"R\"\n        case \"s\":\n            result += \"S\"\n      \
    \  case \"t\":\n            result += \"T\"\n        case \"u\":\n           \
    \ result += \"U\"\n        case \"v\":\n            result += \"V\"\n        case\
    \ \"w\":\n            result += \"W\"\n        case \"x\":\n            result\
    \ += \"X\"\n        case \"y\":\n            result += \"Y\"\n        case \"\
    z\":\n            result += \"Z\"\n        case \"A\":\n            result +=\
    \ \"a\"\n        case \"B\":\n            result += \"b\"\n        case \"C\"\
    :\n            result += \"c\"\n        case \"D\":\n            result += \"\
    d\"\n        case \"E\":\n            result += \"e\"\n        case \"F\":\n \
    \           result += \"f\"\n        case \"G\":\n            result += \"g\"\n\
    \        case \"H\":\n            result += \"h\"\n        case \"I\":\n     \
    \       result += \"i\"\n        case \"J\":\n            result += \"j\"\n  \
    \      case \"K\":\n            result += \"k\"\n        case \"L\":\n       \
    \     result += \"l\"\n        case \"M\":\n            result += \"m\"\n    \
    \    case \"N\":\n            result += \"n\"\n        case \"O\":\n         \
    \   result += \"o\"\n        case \"P\":\n            result += \"p\"\n      \
    \  case \"Q\":\n            result += \"q\"\n        case \"R\":\n           \
    \ result += \"r\"\n        case \"S\":\n            result += \"s\"\n        case\
    \ \"T\":\n            result += \"t\"\n        case \"U\":\n            \n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp_dwjd4v7.swift:108:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"U\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmp_dwjd4v7.swift:129:84: error: expected '}' at\
    \ end of brace statement\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\"\
    ) == \"k dQnT kNqW wHcT Tq wRkTg\")\n                                        \
    \                                           ^\n/tmp/tmp_dwjd4v7.swift:14:27: note:\
    \ to match this opening '{'\n    for letter in message {\n                   \
    \       ^\n/tmp/tmp_dwjd4v7.swift:129:84: error: expected '}' at end of brace\
    \ statement\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT\
    \ kNqW wHcT Tq wRkTg\")\n                                                    \
    \                               ^\n/tmp/tmp_dwjd4v7.swift:12:40: note: to match\
    \ this opening '{'\nfunc encode(message: String) -> String {\n               \
    \                        ^\n/tmp/tmp_dwjd4v7.swift:15:9: error: switch must be\
    \ exhaustive\n        switch letter {\n        ^\n/tmp/tmp_dwjd4v7.swift:15:9:\
    \ note: do you want to add a default clause?\n        switch letter {\n      \
    \  ^\n/tmp/tmp_dwjd4v7.swift:113:6: error: operator functions can only be declared\
    \ at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += letter\n   \
    \     } else {\n            result += letter.swapCase()\n        }\n    }\n  \
    \  for vowel in \"aeiouAEIOU\" {\n        result = result.replace(vowel, vowel.swapCase())\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpe_59_eun.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmpe_59_eun.swift:16:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n/tmp/tmpe_59_eun.swift:18:30:\
    \ error: value of type 'Character' has no member 'swapCase'\n            result\
    \ += letter.swapCase()\n                      ~~~~~~ ^~~~~~~~\n/tmp/tmpe_59_eun.swift:22:25:\
    \ error: no exact matches in call to instance method 'replace'\n        result\
    \ = result.replace(vowel, vowel.swapCase())\n                        ^\n/tmp/tmpe_59_eun.swift:22:25:\
    \ note: found candidate with type '(Character, _, Int) -> ()'\n        result\
    \ = result.replace(vowel, vowel.swapCase())\n                        ^\n/tmp/tmpe_59_eun.swift:22:46:\
    \ error: value of type 'Character' has no member 'swapCase'\n        result =\
    \ result.replace(vowel, vowel.swapCase())\n                                  \
    \     ~~~~~ ^~~~~~~~\n/tmp/tmpe_59_eun.swift:22:25: error: cannot assign value\
    \ of type '()' to type 'String'\n        result = result.replace(vowel, vowel.swapCase())\n\
    \                 ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)\n        let replacement\
    \ = alphabet[(index! + 2) % alphabet.count]\n        result += replacement\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpegpzxi6z.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)\n                    ^~~~~~~~\n\
    /tmp/tmpegpzxi6z.swift:16:27: error: cannot find 'alphabet' in scope\n       \
    \ let replacement = alphabet[(index! + 2) % alphabet.count]\n                \
    \          ^~~~~~~~\n/tmp/tmpegpzxi6z.swift:16:51: error: cannot find 'alphabet'\
    \ in scope\n        let replacement = alphabet[(index! + 2) % alphabet.count]\n\
    \                                                  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += letter.lowercased()\n\
    \        } else {\n            result += letter.uppercased()\n        }\n    }\n\
    \    for vowel in \"AEIOUaeiou\" {\n        result = result.replacingOccurrences(of:\
    \ vowel, with: vowel.lowercased())\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp28mxbr40.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmp28mxbr40.swift:22:25:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ result = result.replacingOccurrences(of: vowel, with: vowel.lowercased())\n\
    \                 ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for char in\
    \ message {\n        switch char {\n        case 'a':\n            result += \"\
    A\"\n        case 'b':\n            result += \"B\"\n        case 'c':\n     \
    \       result += \"C\"\n        case 'd':\n            result += \"D\"\n    \
    \    case 'e':\n            result += \"E\"\n        case 'f':\n            result\
    \ += \"F\"\n        case 'g':\n            result += \"G\"\n        case 'h':\n\
    \            result += \"H\"\n        case 'i':\n            result += \"I\"\n\
    \        case 'j':\n            result += \"J\"\n        case 'k':\n         \
    \   result += \"K\"\n        case 'l':\n            result += \"L\"\n        case\
    \ 'm':\n            result += \"M\"\n        case 'n':\n            result +=\
    \ \"N\"\n        case 'o':\n            result += \"O\"\n        case 'p':\n \
    \           result += \"P\"\n        case 'q':\n            result += \"Q\"\n\
    \        case 'r':\n            result += \"R\"\n        case 's':\n         \
    \   result += \"S\"\n        case 't':\n            result += \"T\"\n        case\
    \ 'u':\n            result += \"U\"\n        case 'v':\n            result +=\
    \ \"V\"\n        case 'w':\n            result += \"W\"\n        case 'x':\n \
    \           result += \"X\"\n        case 'y':\n            result += \"Y\"\n\
    \        case 'z':\n            result += \"Z\"\n        case 'A':\n         \
    \   result += \"a\"\n        case 'B':\n            result += \"b\"\n        case\
    \ 'C':\n            result += \"c\"\n        case 'D':\n            result +=\
    \ \"d\"\n        case 'E':\n            result += \"e\"\n        case 'F':\n \
    \           result += \"f\"\n        case 'G':\n            result += \"g\"\n\
    \        case 'H':\n            result += \"h\"\n        case 'I':\n         \
    \   result += \"i\"\n        case 'J':\n            result += \"j\"\n        case\
    \ 'K':\n            result += \"k\"\n        case 'L':\n            result +=\
    \ \"l\"\n        case 'M':\n            result += \"m\"\n        case 'N':\n \
    \           result += \"n\"\n        case 'O':\n            result += \"o\"\n\
    \        case 'P':\n            result += \"p\"\n        case 'Q':\n         \
    \   result += \"q\"\n        case 'R':\n            result += \"r\"\n        case\
    \ 'S':\n            result += \"s\"\n        case 'T':\n            result +=\
    \ \"t\"\n        case 'U':\n            result += \"u\"\n        case 'V':\n \
    \           result += \"v\"\n        case 'W':\n            result += \"w\"\n\
    \        case 'X':\n            result += \"x\"\n        case 'Y':\n         \
    \   result += \"y\"\n        case '\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpgnt4e4ve.swift:16:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpgnt4e4ve.swift:18:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmpgnt4e4ve.swift:20:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmpgnt4e4ve.swift:22:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmpgnt4e4ve.swift:24:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpgnt4e4ve.swift:26:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmpgnt4e4ve.swift:28:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmpgnt4e4ve.swift:30:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmpgnt4e4ve.swift:32:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmpgnt4e4ve.swift:34:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmpgnt4e4ve.swift:36:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmpgnt4e4ve.swift:38:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmpgnt4e4ve.swift:40:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmpgnt4e4ve.swift:42:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmpgnt4e4ve.swift:44:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmpgnt4e4ve.swift:46:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n            result\
    \ += \"A\"\n        case \"b\":\n            result += \"B\"\n        case \"\
    c\":\n            result += \"C\"\n        case \"d\":\n            result +=\
    \ \"D\"\n        case \"e\":\n            result += \"E\"\n        case \"f\"\
    :\n            result += \"F\"\n        case \"g\":\n            result += \"\
    G\"\n        case \"h\":\n            result += \"H\"\n        case \"i\":\n \
    \           result += \"I\"\n        case \"j\":\n            result += \"J\"\n\
    \        case \"k\":\n            result += \"K\"\n        case \"l\":\n     \
    \       result += \"L\"\n        case \"m\":\n            result += \"M\"\n  \
    \      case \"n\":\n            result += \"N\"\n        case \"o\":\n       \
    \     result += \"O\"\n        case \"p\":\n            result += \"P\"\n    \
    \    case \"q\":\n            result += \"Q\"\n        case \"r\":\n         \
    \   result += \"R\"\n        case \"s\":\n            result += \"S\"\n      \
    \  case \"t\":\n            result += \"T\"\n        case \"u\":\n           \
    \ result += \"U\"\n        case \"v\":\n            result += \"V\"\n        case\
    \ \"w\":\n            result += \"W\"\n        case \"x\":\n            result\
    \ += \"X\"\n        case \"y\":\n            result += \"Y\"\n        case \"\
    z\":\n            result += \"Z\"\n        default:\n            result += letter\n\
    \        }\n    }\n    for vowel in \"aeiou\" {\n        switch vowel {\n    \
    \    case \"a\":\n            result += \"A\"\n        case \"e\":\n         \
    \   result += \"E\"\n        case \"i\":\n            result += \"I\"\n      \
    \  case \"o\":\n            result += \"O\"\n        case \"u\":\n           \
    \ result += \"U\"\n        default:\n            result += vowel\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpayzgov2r.swift:69:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += letter\n         \
    \             ^\n/tmp/tmpayzgov2r.swift:85:23: error: cannot convert value of\
    \ type 'Character' to expected argument type 'String'\n            result += vowel\n\
    \                      ^\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = english.index(of: letter)\n        let replacement\
    \ = english[(index! + 2) % english.count]\n        result += String(letter).replacingOccurrences(of:\
    \ \"A\", with: replacement)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpxcnoibxy.swift:15:21: error: cannot find 'english' in scope\n \
    \       let index = english.index(of: letter)\n                    ^~~~~~~\n/tmp/tmpxcnoibxy.swift:16:27:\
    \ error: cannot find 'english' in scope\n        let replacement = english[(index!\
    \ + 2) % english.count]\n                          ^~~~~~~\n/tmp/tmpxcnoibxy.swift:16:50:\
    \ error: cannot find 'english' in scope\n        let replacement = english[(index!\
    \ + 2) % english.count]\n                                                 ^~~~~~~\n\
    /tmp/tmpxcnoibxy.swift:17:34: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        result += String(letter).replacingOccurrences(of: \"A\", with: replacement)\n\
    \                  ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += String(letter).swapCase()\n\
    \        } else {\n            result += letter\n        }\n    }\n    for letter\
    \ in result {\n        if letter.isLetter() {\n            if let index = alphabet.index(of:\
    \ letter) {\n                let twoLettersBefore = alphabet.index(of: alphabet.prefix(upTo:\
    \ index))\n                let twoLettersAfter = alphabet.index(of: alphabet.suffix(from:\
    \ index))\n                let replacement = alphabet[twoLettersAfter!]\n    \
    \            result += replacement\n            }\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\"\
    ) == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpzkwsxcbz.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmpzkwsxcbz.swift:16:38:\
    \ error: value of type 'String' has no member 'swapCase'\n            result +=\
    \ String(letter).swapCase()\n                      ~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmpzkwsxcbz.swift:18:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n/tmp/tmpzkwsxcbz.swift:22:19:\
    \ error: cannot call value of non-function type 'Bool'\n        if letter.isLetter()\
    \ {\n                  ^       ~~\n                          \n/tmp/tmpzkwsxcbz.swift:23:28:\
    \ error: cannot find 'alphabet' in scope\n            if let index = alphabet.index(of:\
    \ letter) {\n                           ^~~~~~~~\n/tmp/tmpzkwsxcbz.swift:24:40:\
    \ error: cannot find 'alphabet' in scope\n                let twoLettersBefore\
    \ = alphabet.index(of: alphabet.prefix(upTo: index))\n                       \
    \                ^~~~~~~~\n/tmp/tmpzkwsxcbz.swift:24:59: error: cannot find 'alphabet'\
    \ in scope\n                let twoLettersBefore = alphabet.index(of: alphabet.prefix(upTo:\
    \ index))\n                                                          ^~~~~~~~\n\
    /tmp/tmpzkwsxcbz.swift:25:39: error: cannot find 'alphabet' in scope\n       \
    \         let twoLettersAfter = alphabet.index(of: alphabet.suffix(from: index))\n\
    \                                      ^~~~~~~~\n/tmp/tmpzkwsxcbz.swift:25:58:\
    \ error: cannot find 'alphabet' in scope\n                let twoLettersAfter\
    \ = alphabet.index(of: alphabet.suffix(from: index))\n                       \
    \                                  ^~~~~~~~\n/tmp/tmpzkwsxcbz.swift:26:35: error:\
    \ cannot find 'alphabet' in scope\n                let replacement = alphabet[twoLettersAfter!]\n\
    \                                  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += String(letter).swapCase()\n\
    \        } else {\n            result += String(letter)\n        }\n    }\n  \
    \  for vowel in \"AEIOUaeiou\" {\n        let index = result.index(of: vowel)\n\
    \        if index != nil {\n            let replacement = String(result[index!\
    \ + 1])\n            result = result.substring(to: index!)\n            result\
    \ += replacement\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmplmnume2g.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmplmnume2g.swift:16:38:\
    \ error: value of type 'String' has no member 'swapCase'\n            result +=\
    \ String(letter).swapCase()\n                      ~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmplmnume2g.swift:22:28:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ index = result.index(of: vowel)\n                           ^\n/tmp/tmplmnume2g.swift:22:28:\
    \ note: use 'firstIndex(of:)' instead\n        let index = result.index(of: vowel)\n\
    \                           ^~~~~\n                           firstIndex\n/tmp/tmplmnume2g.swift:24:50:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n            let replacement = String(result[index! + 1])\n          \
    \                                       ^\n/tmp/tmplmnume2g.swift:25:29: error:\
    \ value of type 'String' has no member 'substring'\n            result = result.substring(to:\
    \ index!)\n                     ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += letter.lowercased()\n\
    \        } else {\n            result += letter.uppercased()\n        }\n    }\n\
    \    for vowel in \"aeiouAEIOU\" {\n        let index = result.index(of: vowel)\n\
    \        if index != nil {\n            let replacement = result.index(before:\
    \ index!)\n            result += String(result[replacement!...])\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpkfr3qfn8.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmpkfr3qfn8.swift:22:28:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ index = result.index(of: vowel)\n                           ^\n/tmp/tmpkfr3qfn8.swift:22:28:\
    \ note: use 'firstIndex(of:)' instead\n        let index = result.index(of: vowel)\n\
    \                           ^~~~~\n                           firstIndex\n/tmp/tmpkfr3qfn8.swift:25:48:\
    \ error: cannot force unwrap value of non-optional type 'String.Index'\n     \
    \       result += String(result[replacement!...])\n                          \
    \          ~~~~~~~~~~~^\n                                               \n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += letter.lowercased()\n\
    \        } else {\n            result += letter.uppercased()\n        }\n    }\n\
    \    for letter in result {\n        if letter.isUpper() {\n            result\
    \ += letter.lowercased()\n        } else {\n            result += letter.uppercased()\n\
    \        }\n    }\n    for letter in result {\n        if letter.isUpper() {\n\
    \            result += letter.lowercased()\n        } else {\n            result\
    \ += letter.uppercased()\n        }\n    }\n    for letter in result {\n     \
    \   if letter.isUpper() {\n            result += letter.lowercased()\n       \
    \ } else {\n            result += letter.uppercased()\n        }\n    }\n    for\
    \ letter in result {\n        if letter.isUpper() {\n            result += letter.lowercased()\n\
    \        } else {\n            result += letter.uppercased()\n        }\n    }\n\
    \    for letter in result {\n        if letter.isUpper() {\n            result\
    \ += letter.lowercased()\n        } else {\n            result += letter.uppercased()\n\
    \        }\n    }\n    for letter in result {\n        if letter.isUpper() {\n\
    \            result += letter.lowercased()\n        } else {\n            result\
    \ += letter.uppercased()\n        }\n    }\n    for letter in result {\n     \
    \   if letter.isUpper() {\n            result += letter.lowercased()\n       \
    \ } else {\n            result += letter.uppercased()\n        }\n    }\n    for\
    \ letter in result {\n        if letter.isUpper() {\n            result += letter.lowercased()\n\
    \        } else {\n            result += letter.uppercased()\n        }\n    }\n\
    \    for letter in result {\n        if letter.isUpper() {\n            result\
    \ += letter.lowercased()\n        } else {\n            result += letter.uppercased()\n\
    \        }\n    }\n    for letter in result {\n        if letter.isUpper() {\n\
    \            result += letter.lowercased()\n        } else {\n            result\
    \ += letter.uppercased()\n        }\n    }\n    for letter in result {\n     \
    \   if letter.isUpper() {\n            result += letter.lowercased()\n       \
    \ } else {\n            result += letter.uppercased()\n        }\n    }\n    for\
    \ letter in result {\n        if letter.isUpper() {\n            result += letter.lowercased()\n\
    \        } else {\n            result += letter.uppercased()\n        }\n    }\n\
    \    for letter in result {\n        if letter.isUpper() {\n            result\
    \ += letter.lowercased()\n        } else {\n            result += letter.uppercased()\n\
    \        }\n    }\n    for letter in result {\n        if letter.isUpper() {\n\
    \            result += letter.lowercased()\n        } else {\n            result\
    \ += letter.uppercased()\n        }\n    }\n    for letter in result {\n     \
    \   if letter.isUpper() {\n            result += letter.lowercased()\n       \
    \ } else {\n            result += letter.uppercased()\n\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpbudwvzqt.swift:144:84: error: expected '}' at end of brace statement\n\
    assert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq\
    \ wRkTg\")\n                                                                 \
    \                  ^\n/tmp/tmpbudwvzqt.swift:119:26: note: to match this opening\
    \ '{'\n    for letter in result {\n                         ^\n/tmp/tmpbudwvzqt.swift:144:84:\
    \ error: expected '}' at end of brace statement\nassert(encode(message: \"I DoNt\
    \ KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")\n                  \
    \                                                                 ^\n/tmp/tmpbudwvzqt.swift:12:40:\
    \ note: to match this opening '{'\nfunc encode(message: String) -> String {\n\
    \                                       ^\n/tmp/tmpbudwvzqt.swift:15:19: error:\
    \ value of type 'Character' has no member 'isUpper'\n        if letter.isUpper()\
    \ {\n           ~~~~~~ ^~~~~~~\n/tmp/tmpbudwvzqt.swift:22:19: error: value of\
    \ type 'Character' has no member 'isUpper'\n        if letter.isUpper() {\n  \
    \         ~~~~~~ ^~~~~~~\n/tmp/tmpbudwvzqt.swift:29:19: error: value of type 'Character'\
    \ has no member 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n\
    /tmp/tmpbudwvzqt.swift:36:19: error: value of type 'Character' has no member 'isUpper'\n\
    \        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmpbudwvzqt.swift:43:19:\
    \ error: value of type 'Character' has no member 'isUpper'\n        if letter.isUpper()\
    \ {\n           ~~~~~~ ^~~~~~~\n/tmp/tmpbudwvzqt.swift:50:19: error: value of\
    \ type 'Character' has no member 'isUpper'\n        if letter.isUpper() {\n  \
    \         ~~~~~~ ^~~~~~~\n/tmp/tmpbudwvzqt.swift:57:19: error: value of type 'Character'\
    \ has no member 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n\
    /tmp/tmpbudwvzqt.swift:64:19: error: value of type 'Character' has no member 'isUpper'\n\
    \        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmpbudwvzqt.swift:71:19:\
    \ error: value of type 'Character' has no member 'isUpper'\n        if letter.isUpper()\
    \ {\n           ~~~~~~ ^~~~~~~\n/tmp/tmp"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += letter\n   \
    \     } else {\n            result += letter.lowercased()\n        }\n    }\n\
    \    for letter in result {\n        if letter.hasVowel() {\n            result\
    \ += letter.swapVowels()\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp8n3mp6is.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmp8n3mp6is.swift:16:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n/tmp/tmp8n3mp6is.swift:22:19:\
    \ error: value of type 'Character' has no member 'hasVowel'\n        if letter.hasVowel()\
    \ {\n           ~~~~~~ ^~~~~~~~\n/tmp/tmp8n3mp6is.swift:23:30: error: value of\
    \ type 'Character' has no member 'swapVowels'\n            result += letter.swapVowels()\n\
    \                      ~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += letter.lowercased()\n\
    \        } else {\n            result += letter.uppercased()\n        }\n    }\n\
    \    for vowel in \"AEIOUaeiou\" {\n        let index = result.index(of: vowel)\n\
    \        let replacement = result.index(index, offsetBy: 2)\n        if replacement\
    \ != nil {\n            result = result.replacingCharacters(in: index, with: result[replacement!])\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmphcku9uhs.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmphcku9uhs.swift:22:28:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ index = result.index(of: vowel)\n                           ^\n/tmp/tmphcku9uhs.swift:22:28:\
    \ note: use 'firstIndex(of:)' instead\n        let index = result.index(of: vowel)\n\
    \                           ^~~~~\n                           firstIndex\n/tmp/tmphcku9uhs.swift:23:40:\
    \ error: value of optional type 'String.Index?' must be unwrapped to a value of\
    \ type 'String.Index'\n        let replacement = result.index(index, offsetBy:\
    \ 2)\n                                       ^\n/tmp/tmphcku9uhs.swift:23:40:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        let replacement = result.index(index, offsetBy: 2)\n        \
    \                               ^\n                                          \
    \   ?? <#default value#>\n/tmp/tmphcku9uhs.swift:23:40: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n        let replacement\
    \ = result.index(index, offsetBy: 2)\n                                       ^\n\
    \                                            !\n/tmp/tmphcku9uhs.swift:25:29:\
    \ error: value of type 'String' has no member 'replacingCharacters'\n        \
    \    result = result.replacingCharacters(in: index, with: result[replacement!])\n\
    \                     ~~~~~~ ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n            result\
    \ += \"A\"\n        case \"b\":\n            result += \"B\"\n        case \"\
    c\":\n            result += \"C\"\n        case \"d\":\n            result +=\
    \ \"D\"\n        case \"e\":\n            result += \"E\"\n        case \"f\"\
    :\n            result += \"F\"\n        case \"g\":\n            result += \"\
    G\"\n        case \"h\":\n            result += \"H\"\n        case \"i\":\n \
    \           result += \"I\"\n        case \"j\":\n            result += \"J\"\n\
    \        case \"k\":\n            result += \"K\"\n        case \"l\":\n     \
    \       result += \"L\"\n        case \"m\":\n            result += \"M\"\n  \
    \      case \"n\":\n            result += \"N\"\n        case \"o\":\n       \
    \     result += \"O\"\n        case \"p\":\n            result += \"P\"\n    \
    \    case \"q\":\n            result += \"Q\"\n        case \"r\":\n         \
    \   result += \"R\"\n        case \"s\":\n            result += \"S\"\n      \
    \  case \"t\":\n            result += \"T\"\n        case \"u\":\n           \
    \ result += \"U\"\n        case \"v\":\n            result += \"V\"\n        case\
    \ \"w\":\n            result += \"W\"\n        case \"x\":\n            result\
    \ += \"X\"\n        case \"y\":\n            result += \"Y\"\n        case \"\
    z\":\n            result += \"Z\"\n        case \"A\":\n            result +=\
    \ \"a\"\n        case \"B\":\n            result += \"b\"\n        case \"C\"\
    :\n            result += \"c\"\n        case \"D\":\n            result += \"\
    d\"\n        case \"E\":\n            result += \"e\"\n        case \"F\":\n \
    \           result += \"f\"\n        case \"G\":\n            result += \"g\"\n\
    \        case \"H\":\n            result += \"h\"\n        case \"I\":\n     \
    \       result += \"i\"\n        case \"J\":\n            result += \"j\"\n  \
    \      case \"K\":\n            result += \"k\"\n        case \"L\":\n       \
    \     result += \"l\"\n        case \"M\":\n            result += \"m\"\n    \
    \    case \"N\":\n            result += \"n\"\n        case \"O\":\n         \
    \   result += \"o\"\n        case \"P\":\n            result += \"p\"\n      \
    \  case \"Q\":\n            result += \"q\"\n        case \"R\":\n           \
    \ result += \"r\"\n        case \"S\":\n            result += \"s\"\n        case\
    \ \"T\":\n            result += \"t\"\n        case \"U\":\n            \n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp_dwjd4v7.swift:108:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"U\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmp_dwjd4v7.swift:129:84: error: expected '}' at\
    \ end of brace statement\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\"\
    ) == \"k dQnT kNqW wHcT Tq wRkTg\")\n                                        \
    \                                           ^\n/tmp/tmp_dwjd4v7.swift:14:27: note:\
    \ to match this opening '{'\n    for letter in message {\n                   \
    \       ^\n/tmp/tmp_dwjd4v7.swift:129:84: error: expected '}' at end of brace\
    \ statement\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT\
    \ kNqW wHcT Tq wRkTg\")\n                                                    \
    \                               ^\n/tmp/tmp_dwjd4v7.swift:12:40: note: to match\
    \ this opening '{'\nfunc encode(message: String) -> String {\n               \
    \                        ^\n/tmp/tmp_dwjd4v7.swift:15:9: error: switch must be\
    \ exhaustive\n        switch letter {\n        ^\n/tmp/tmp_dwjd4v7.swift:15:9:\
    \ note: do you want to add a default clause?\n        switch letter {\n      \
    \  ^\n/tmp/tmp_dwjd4v7.swift:113:6: error: operator functions can only be declared\
    \ at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)!\n        let replacement\
    \ = alphabet[index + 2]\n        result += String(letter).replacingOccurrences(of:\
    \ \"A\", with: replacement)\n        result += String(letter).replacingOccurrences(of:\
    \ \"E\", with: replacement)\n        result += String(letter).replacingOccurrences(of:\
    \ \"I\", with: replacement)\n        result += String(letter).replacingOccurrences(of:\
    \ \"O\", with: replacement)\n        result += String(letter).replacingOccurrences(of:\
    \ \"U\", with: replacement)\n        result += String(letter).replacingOccurrences(of:\
    \ \"Y\", with: replacement)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpaqg64cvf.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)!\n                    ^~~~~~~~\n\
    /tmp/tmpaqg64cvf.swift:16:27: error: cannot find 'alphabet' in scope\n       \
    \ let replacement = alphabet[index + 2]\n                          ^~~~~~~~\n\
    /tmp/tmpaqg64cvf.swift:17:34: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        result += String(letter).replacingOccurrences(of: \"A\", with: replacement)\n\
    \                  ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpaqg64cvf.swift:18:34:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ result += String(letter).replacingOccurrences(of: \"E\", with: replacement)\n\
    \                  ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpaqg64cvf.swift:19:34:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ result += String(letter).replacingOccurrences(of: \"I\", with: replacement)\n\
    \                  ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpaqg64cvf.swift:20:34:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ result += String(letter).replacingOccurrences(of: \"O\", with: replacement)\n\
    \                  ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpaqg64cvf.swift:21:34:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ result += String(letter).replacingOccurrences(of: \"U\", with: replacement)\n\
    \                  ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpaqg64cvf.swift:22:34:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ result += String(letter).replacingOccurrences(of: \"Y\", with: replacement)\n\
    \                  ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n            result\
    \ += \"A\"\n        case \"b\":\n            result += \"B\"\n        case \"\
    c\":\n            result += \"C\"\n        case \"d\":\n            result +=\
    \ \"D\"\n        case \"e\":\n            result += \"E\"\n        case \"f\"\
    :\n            result += \"F\"\n        case \"g\":\n            result += \"\
    G\"\n        case \"h\":\n            result += \"H\"\n        case \"i\":\n \
    \           result += \"I\"\n        case \"j\":\n            result += \"J\"\n\
    \        case \"k\":\n            result += \"K\"\n        case \"l\":\n     \
    \       result += \"L\"\n        case \"m\":\n            result += \"M\"\n  \
    \      case \"n\":\n            result += \"N\"\n        case \"o\":\n       \
    \     result += \"O\"\n        case \"p\":\n            result += \"P\"\n    \
    \    case \"q\":\n            result += \"Q\"\n        case \"r\":\n         \
    \   result += \"R\"\n        case \"s\":\n            result += \"S\"\n      \
    \  case \"t\":\n            result += \"T\"\n        case \"u\":\n           \
    \ result += \"U\"\n        case \"v\":\n            result += \"V\"\n        case\
    \ \"w\":\n            result += \"W\"\n        case \"x\":\n            result\
    \ += \"X\"\n        case \"y\":\n            result += \"Y\"\n        case \"\
    z\":\n            result += \"Z\"\n        case \"A\":\n            result +=\
    \ \"a\"\n        case \"B\":\n            result += \"b\"\n        case \"C\"\
    :\n            result += \"c\"\n        case \"D\":\n            result += \"\
    d\"\n        case \"E\":\n            result += \"e\"\n        case \"F\":\n \
    \           result += \"f\"\n        case \"G\":\n            result += \"g\"\n\
    \        case \"H\":\n            result += \"h\"\n        case \"I\":\n     \
    \       result += \"i\"\n        case \"J\":\n            result += \"j\"\n  \
    \      case \"K\":\n            result += \"k\"\n        case \"L\":\n       \
    \     result += \"l\"\n        case \"M\":\n            result += \"m\"\n    \
    \    case \"N\":\n            result += \"n\"\n        case \"O\":\n         \
    \   result += \"o\"\n        case \"P\":\n            result += \"p\"\n      \
    \  case \"Q\":\n            result += \"q\"\n        case \"R\":\n           \
    \ result += \"r\"\n        case \"S\":\n            result += \"s\"\n        case\
    \ \"T\":\n            result += \"t\"\n        case \"U\":\n            \n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp_dwjd4v7.swift:108:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"U\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmp_dwjd4v7.swift:129:84: error: expected '}' at\
    \ end of brace statement\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\"\
    ) == \"k dQnT kNqW wHcT Tq wRkTg\")\n                                        \
    \                                           ^\n/tmp/tmp_dwjd4v7.swift:14:27: note:\
    \ to match this opening '{'\n    for letter in message {\n                   \
    \       ^\n/tmp/tmp_dwjd4v7.swift:129:84: error: expected '}' at end of brace\
    \ statement\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT\
    \ kNqW wHcT Tq wRkTg\")\n                                                    \
    \                               ^\n/tmp/tmp_dwjd4v7.swift:12:40: note: to match\
    \ this opening '{'\nfunc encode(message: String) -> String {\n               \
    \                        ^\n/tmp/tmp_dwjd4v7.swift:15:9: error: switch must be\
    \ exhaustive\n        switch letter {\n        ^\n/tmp/tmp_dwjd4v7.swift:15:9:\
    \ note: do you want to add a default clause?\n        switch letter {\n      \
    \  ^\n/tmp/tmp_dwjd4v7.swift:113:6: error: operator functions can only be declared\
    \ at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n            result\
    \ += \"A\"\n        case \"b\":\n            result += \"B\"\n        case \"\
    c\":\n            result += \"C\"\n        case \"d\":\n            result +=\
    \ \"D\"\n        case \"e\":\n            result += \"E\"\n        case \"f\"\
    :\n            result += \"F\"\n        case \"g\":\n            result += \"\
    G\"\n        case \"h\":\n            result += \"H\"\n        case \"i\":\n \
    \           result += \"I\"\n        case \"j\":\n            result += \"J\"\n\
    \        case \"k\":\n            result += \"K\"\n        case \"l\":\n     \
    \       result += \"L\"\n        case \"m\":\n            result += \"M\"\n  \
    \      case \"n\":\n            result += \"N\"\n        case \"o\":\n       \
    \     result += \"O\"\n        case \"p\":\n            result += \"P\"\n    \
    \    case \"q\":\n            result += \"Q\"\n        case \"r\":\n         \
    \   result += \"R\"\n        case \"s\":\n            result += \"S\"\n      \
    \  case \"t\":\n            result += \"T\"\n        case \"u\":\n           \
    \ result += \"U\"\n        case \"v\":\n            result += \"V\"\n        case\
    \ \"w\":\n            result += \"W\"\n        case \"x\":\n            result\
    \ += \"X\"\n        case \"y\":\n            result += \"Y\"\n        case \"\
    z\":\n            result += \"Z\"\n        case \"A\":\n            result +=\
    \ \"a\"\n        case \"B\":\n            result += \"b\"\n        case \"C\"\
    :\n            result += \"c\"\n        case \"D\":\n            result += \"\
    d\"\n        case \"E\":\n            result += \"e\"\n        case \"F\":\n \
    \           result += \"f\"\n        case \"G\":\n            result += \"g\"\n\
    \        case \"H\":\n            result += \"h\"\n        case \"I\":\n     \
    \       result += \"i\"\n        case \"J\":\n            result += \"j\"\n  \
    \      case \"K\":\n            result += \"k\"\n        case \"L\":\n       \
    \     result += \"l\"\n        case \"M\":\n            result += \"m\"\n    \
    \    case \"N\":\n            result += \"n\"\n        case \"O\":\n         \
    \   result += \"o\"\n        case \"P\":\n            result += \"p\"\n      \
    \  case \"Q\":\n            result += \"q\"\n        case \"R\":\n           \
    \ result += \"r\"\n        case \"S\":\n            result += \"s\"\n        case\
    \ \"T\":\n            result += \"t\"\n        case \"U\":\n            \n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp_dwjd4v7.swift:108:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"U\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmp_dwjd4v7.swift:129:84: error: expected '}' at\
    \ end of brace statement\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\"\
    ) == \"k dQnT kNqW wHcT Tq wRkTg\")\n                                        \
    \                                           ^\n/tmp/tmp_dwjd4v7.swift:14:27: note:\
    \ to match this opening '{'\n    for letter in message {\n                   \
    \       ^\n/tmp/tmp_dwjd4v7.swift:129:84: error: expected '}' at end of brace\
    \ statement\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT\
    \ kNqW wHcT Tq wRkTg\")\n                                                    \
    \                               ^\n/tmp/tmp_dwjd4v7.swift:12:40: note: to match\
    \ this opening '{'\nfunc encode(message: String) -> String {\n               \
    \                        ^\n/tmp/tmp_dwjd4v7.swift:15:9: error: switch must be\
    \ exhaustive\n        switch letter {\n        ^\n/tmp/tmp_dwjd4v7.swift:15:9:\
    \ note: do you want to add a default clause?\n        switch letter {\n      \
    \  ^\n/tmp/tmp_dwjd4v7.swift:113:6: error: operator functions can only be declared\
    \ at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for char in\
    \ message {\n        switch char {\n        case 'a':\n            result += \"\
    A\"\n        case 'b':\n            result += \"B\"\n        case 'c':\n     \
    \       result += \"C\"\n        case 'd':\n            result += \"D\"\n    \
    \    case 'e':\n            result += \"E\"\n        case 'f':\n            result\
    \ += \"F\"\n        case 'g':\n            result += \"G\"\n        case 'h':\n\
    \            result += \"H\"\n        case 'i':\n            result += \"I\"\n\
    \        case 'j':\n            result += \"J\"\n        case 'k':\n         \
    \   result += \"K\"\n        case 'l':\n            result += \"L\"\n        case\
    \ 'm':\n            result += \"M\"\n        case 'n':\n            result +=\
    \ \"N\"\n        case 'o':\n            result += \"O\"\n        case 'p':\n \
    \           result += \"P\"\n        case 'q':\n            result += \"Q\"\n\
    \        case 'r':\n            result += \"R\"\n        case 's':\n         \
    \   result += \"S\"\n        case 't':\n            result += \"T\"\n        case\
    \ 'u':\n            result += \"U\"\n        case 'v':\n            result +=\
    \ \"V\"\n        case 'w':\n            result += \"W\"\n        case 'x':\n \
    \           result += \"X\"\n        case 'y':\n            result += \"Y\"\n\
    \        case 'z':\n            result += \"Z\"\n        case 'A':\n         \
    \   result += \"a\"\n        case 'B':\n            result += \"b\"\n        case\
    \ 'C':\n            result += \"c\"\n        case 'D':\n            result +=\
    \ \"d\"\n        case 'E':\n            result += \"e\"\n        case 'F':\n \
    \           result += \"f\"\n        case 'G':\n            result += \"g\"\n\
    \        case 'H':\n            result += \"h\"\n        case 'I':\n         \
    \   result += \"i\"\n        case 'J':\n            result += \"j\"\n        case\
    \ 'K':\n            result += \"k\"\n        case 'L':\n            result +=\
    \ \"l\"\n        case 'M':\n            result += \"m\"\n        case 'N':\n \
    \           result += \"n\"\n        case 'O':\n            result += \"o\"\n\
    \        case 'P':\n            result += \"p\"\n        case 'Q':\n         \
    \   result += \"q\"\n        case 'R':\n            result += \"r\"\n        case\
    \ 'S':\n            result += \"s\"\n        case 'T':\n            result +=\
    \ \"t\"\n        case 'U':\n            result += \"u\"\n        case 'V':\n \
    \           result += \"v\"\n        case 'W':\n            result += \"w\"\n\
    \        case 'X':\n            result += \"x\"\n        case 'Y':\n         \
    \   result += \"y\"\n        case '\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpgnt4e4ve.swift:16:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpgnt4e4ve.swift:18:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmpgnt4e4ve.swift:20:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmpgnt4e4ve.swift:22:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmpgnt4e4ve.swift:24:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpgnt4e4ve.swift:26:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmpgnt4e4ve.swift:28:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmpgnt4e4ve.swift:30:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmpgnt4e4ve.swift:32:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmpgnt4e4ve.swift:34:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmpgnt4e4ve.swift:36:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmpgnt4e4ve.swift:38:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmpgnt4e4ve.swift:40:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmpgnt4e4ve.swift:42:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmpgnt4e4ve.swift:44:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmpgnt4e4ve.swift:46:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += letter.lowercased()\n\
    \        } else {\n            result += letter.uppercased()\n        }\n    }\n\
    \    for vowel in \"AEIOUaeiou\" {\n        let index = result.index(of: vowel)\n\
    \        if index != nil {\n            let replacement = String(result.index(before:\
    \ index!)!)\n            let replacementIndex = result.index(of: replacement)\n\
    \            if replacementIndex != nil {\n                let replacementBefore\
    \ = String(result.index(before: replacementIndex!)!)\n                let replacementAfter\
    \ = String(result.index(before: replacementIndex!)!)\n                let replacementAfterIndex\
    \ = result.index(of: replacementAfter)\n                if replacementAfterIndex\
    \ != nil {\n                    let replacementAfterBefore = String(result.index(before:\
    \ replacementAfterIndex!)!)\n                    result += replacementBefore\n\
    \                    result += replacement\n                    result += replacementAfter\n\
    \                    result += replacementAfterBefore\n                } else\
    \ {\n                    result += replacement\n                }\n          \
    \  } else {\n                result += vowel\n            }\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encode(message: \"\
    TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpao55fxod.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmpao55fxod.swift:22:28:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ index = result.index(of: vowel)\n                           ^\n/tmp/tmpao55fxod.swift:22:28:\
    \ note: use 'firstIndex(of:)' instead\n        let index = result.index(of: vowel)\n\
    \                           ^~~~~\n                           firstIndex\n/tmp/tmpao55fxod.swift:24:31:\
    \ error: no exact matches in call to initializer \n            let replacement\
    \ = String(result.index(before: index!)!)\n                              ^\n/tmp/tmpao55fxod.swift:24:31:\
    \ note: found candidate with type '(String.Index) -> String'\n            let\
    \ replacement = String(result.index(before: index!)!)\n                      \
    \        ^\n/tmp/tmpao55fxod.swift:24:31: note: found candidate with type '(String.Index,\
    \ Int, Bool) -> String'\n            let replacement = String(result.index(before:\
    \ index!)!)\n                              ^\n/tmp/tmpao55fxod.swift:24:31: note:\
    \ found candidate with type '(String.Index) -> String'\n            let replacement\
    \ = String(result.index(before: index!)!)\n                              ^\n/tmp/tmpao55fxod.swift:24:31:\
    \ note: found candidate with type '(String.Index) -> String'\n            let\
    \ replacement = String(result.index(before: index!)!)\n                      \
    \        ^\n/tmp/tmpao55fxod.swift:27:41: error: no exact matches in call to initializer\
    \ \n                let replacementBefore = String(result.index(before: replacementIndex!)!)\n\
    \                                        ^\n/tmp/tmpao55fxod.swift:27:41: note:\
    \ found candidate with type '(String.Index) -> String'\n                let replacementBefore\
    \ = String(result.index(before: replacementIndex!)!)\n                       \
    \                 ^\n/tmp/tmpao55fxod.swift:27:41: note: found candidate with\
    \ type '(String.Index, Int, Bool) -> String'\n                let replacementBefore\
    \ = String(result.index(before: replacementIn"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)!\n        let replacement\
    \ = alphabet[index + 2]\n        result += String(letter).replacingOccurrences(of:\
    \ \"A\", with: replacement)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpfrbeb_za.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)!\n                    ^~~~~~~~\n\
    /tmp/tmpfrbeb_za.swift:16:27: error: cannot find 'alphabet' in scope\n       \
    \ let replacement = alphabet[index + 2]\n                          ^~~~~~~~\n\
    /tmp/tmpfrbeb_za.swift:17:34: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        result += String(letter).replacingOccurrences(of: \"A\", with: replacement)\n\
    \                  ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)\n        let replacement\
    \ = alphabet[(index + 2) % 26]\n        result += replacement\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\"\
    ) == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp08cswh9i.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)\n                    ^~~~~~~~\n\
    /tmp/tmp08cswh9i.swift:16:27: error: cannot find 'alphabet' in scope\n       \
    \ let replacement = alphabet[(index + 2) % 26]\n                          ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += letter.swapCase()\n\
    \        } else {\n            result += letter\n        }\n    }\n    for letter\
    \ in result {\n        if letter.isLetter() {\n            result += letter.swapCase()\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp_rnfrb0_.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmp_rnfrb0_.swift:16:30:\
    \ error: value of type 'Character' has no member 'swapCase'\n            result\
    \ += letter.swapCase()\n                      ~~~~~~ ^~~~~~~~\n/tmp/tmp_rnfrb0_.swift:18:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n/tmp/tmp_rnfrb0_.swift:22:19:\
    \ error: cannot call value of non-function type 'Bool'\n        if letter.isLetter()\
    \ {\n                  ^       ~~\n                          \n/tmp/tmp_rnfrb0_.swift:23:30:\
    \ error: value of type 'Character' has no member 'swapCase'\n            result\
    \ += letter.swapCase()\n                      ~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        var newLetter = letter\n        var vowels = \"aeiouAEIOU\"\
    \n        for vowel in vowels {\n            if letter == vowel {\n          \
    \      newLetter = vowels[vowels.index(vowel)! + 1]\n            }\n        }\n\
    \        result += newLetter\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpcnm1lf_8.swift:19:49: error: missing argument label 'of:' in call\n\
    \                newLetter = vowels[vowels.index(vowel)! + 1]\n              \
    \                                  ^\n                                       \
    \         of: \n/tmp/tmpcnm1lf_8.swift:19:55: error: cannot convert value of type\
    \ 'String.Index' to expected argument type 'Int'\n                newLetter =\
    \ vowels[vowels.index(vowel)! + 1]\n                                         \
    \             ^\n/tmp/tmpcnm1lf_8.swift:22:19: error: cannot convert value of\
    \ type 'Character' to expected argument type 'String'\n        result += newLetter\n\
    \                  ^\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += String(letter).swapCase()\n\
    \        } else {\n            result += String(letter)\n        }\n    }\n  \
    \  for vowel in \"aeiouAEIOU\" {\n        let index = message.indexOf(vowel)\n\
    \        if index != nil {\n            let two = message.index(vowel, offsetBy:\
    \ index! + 2)\n            if two != nil {\n                result += String(message.substring(from:\
    \ index!, to: two!))\n            }\n        }\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmppgb9g3ol.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmppgb9g3ol.swift:16:38:\
    \ error: value of type 'String' has no member 'swapCase'\n            result +=\
    \ String(letter).swapCase()\n                      ~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmppgb9g3ol.swift:22:29:\
    \ error: value of type 'String' has no member 'indexOf'\n        let index = message.indexOf(vowel)\n\
    \                    ~~~~~~~ ^~~~~~~\n/tmp/tmppgb9g3ol.swift:24:37: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \            let two = message.index(vowel, offsetBy: index! + 2)\n          \
    \                          ^\n/tmp/tmppgb9g3ol.swift:26:42: error: value of type\
    \ 'String' has no member 'substring'\n                result += String(message.substring(from:\
    \ index!, to: two!))\n                                 ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n        case \"e\"\
    :\n        case \"i\":\n        case \"o\":\n        case \"u\":\n        case\
    \ \"A\":\n        case \"E\":\n        case \"I\":\n        case \"O\":\n    \
    \    case \"U\":\n            result += letter\n        default:\n           \
    \ result += letter\n        }\n    }\n    for letter in result {\n        switch\
    \ letter {\n        case \"A\":\n        case \"E\":\n        case \"I\":\n  \
    \      case \"O\":\n        case \"U\":\n            result += letter\n      \
    \  default:\n            result += letter\n        }\n    }\n    for letter in\
    \ result {\n        switch letter {\n        case \"a\":\n        case \"e\":\n\
    \        case \"i\":\n        case \"o\":\n        case \"u\":\n            result\
    \ += letter\n        default:\n            result += letter\n        }\n    }\n\
    \    for letter in result {\n        switch letter {\n        case \"A\":\n  \
    \      case \"E\":\n        case \"I\":\n        case \"O\":\n        case \"\
    U\":\n            result += letter\n        default:\n            result += letter\n\
    \        }\n    }\n    for letter in result {\n        switch letter {\n     \
    \   case \"a\":\n        case \"e\":\n        case \"i\":\n        case \"o\"\
    :\n        case \"u\":\n            result += letter\n        default:\n     \
    \       result += letter\n        }\n    }\n    for letter in result {\n     \
    \   switch letter {\n        case \"A\":\n        case \"E\":\n        case \"\
    I\":\n        case \"O\":\n        case \"U\":\n            result += letter\n\
    \        default:\n            result += letter\n        }\n    }\n    for letter\
    \ in result {\n        switch letter {\n        case \"a\":\n        case \"e\"\
    :\n        case \"i\":\n        case \"o\":\n        case \"u\":\n           \
    \ result += letter\n        default:\n            result += letter\n        }\n\
    \    }\n    for letter in result {\n        switch letter {\n        case \"A\"\
    :\n        case \"E\":\n        case \"I\":\n        case \"O\":\n        case\
    \ \"U\":\n            result += letter\n        default:\n            result +=\
    \ letter\n        }\n    }\n    for letter in result {\n        switch letter\
    \ {\n        case \"a\":\n        case \"e\":\n        case \"i\":\n        case\
    \ \"o\":\n        case \"u\":\n            result += letter\n        default:\n\
    \            result += letter\n        }\n    }\n    for letter in result {\n\
    \        switch letter {\n        case \"A\":\n        case \"E\":\n        case\
    \ \"I\":\n        case \"O\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpy6l7e37o.swift:16:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"a\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpy6l7e37o.swift:17:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"e\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmpy6l7e37o.swift:18:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"i\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpy6l7e37o.swift:19:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"o\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpy6l7e37o.swift:20:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"u\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpy6l7e37o.swift:21:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"A\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpy6l7e37o.swift:22:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"E\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpy6l7e37o.swift:23:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"I\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpy6l7e37o.swift:24:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"O\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpy6l7e37o.swift:33:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"A\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpy6l7e37o.swift:34:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"E\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpy6l7e37o.swift:35:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"I\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpy6l7e37o.swift:36:9:\
    \ error: 'case' l"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        var index = alphabet.index(letter)\n        if index == -1\
    \ {\n            index = alphabet.index(letter, 2)\n        }\n        result\
    \ += alphabet[index % alphabet.count] + letter\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpzytr3e3z.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        var index = alphabet.index(letter)\n                    ^~~~~~~~\n/tmp/tmpzytr3e3z.swift:17:21:\
    \ error: cannot find 'alphabet' in scope\n            index = alphabet.index(letter,\
    \ 2)\n                    ^~~~~~~~\n/tmp/tmpzytr3e3z.swift:19:19: error: cannot\
    \ find 'alphabet' in scope\n        result += alphabet[index % alphabet.count]\
    \ + letter\n                  ^~~~~~~~\n/tmp/tmpzytr3e3z.swift:19:36: error: cannot\
    \ find 'alphabet' in scope\n        result += alphabet[index % alphabet.count]\
    \ + letter\n                                   ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += letter\n   \
    \     } else {\n            result += letter.lowercased()\n        }\n    }\n\
    \    for vowel in \"aeiouAEIOU\" {\n        let index = result.index(of: vowel)\n\
    \        if index != nil {\n            let replacement = result.index(before:\
    \ index!)\n            result += String(result[replacement!])\n        }\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpnvv8iqiy.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmpnvv8iqiy.swift:16:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n/tmp/tmpnvv8iqiy.swift:22:28:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ index = result.index(of: vowel)\n                           ^\n/tmp/tmpnvv8iqiy.swift:22:28:\
    \ note: use 'firstIndex(of:)' instead\n        let index = result.index(of: vowel)\n\
    \                           ^~~~~\n                           firstIndex\n/tmp/tmpnvv8iqiy.swift:25:48:\
    \ error: cannot force unwrap value of non-optional type 'String.Index'\n     \
    \       result += String(result[replacement!])\n                             \
    \       ~~~~~~~~~~~^\n                                               \n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += String(letter).swapCase()\n\
    \        } else {\n            result += String(letter)\n        }\n    }\n  \
    \  for letter in result {\n        if letter.hasPrefix(\"A\") {\n            letter\
    \ = String(letter).swapCase()\n        }\n        if letter.hasPrefix(\"E\") {\n\
    \            letter = String(letter).swapCase()\n        }\n        if letter.hasPrefix(\"\
    I\") {\n            letter = String(letter).swapCase()\n        }\n        if\
    \ letter.hasPrefix(\"O\") {\n            letter = String(letter).swapCase()\n\
    \        }\n        if letter.hasPrefix(\"U\") {\n            letter = String(letter).swapCase()\n\
    \        }\n        if letter.hasPrefix(\"a\") {\n            letter = String(letter).swapCase()\n\
    \        }\n        if letter.hasPrefix(\"e\") {\n            letter = String(letter).swapCase()\n\
    \        }\n        if letter.hasPrefix(\"i\") {\n            letter = String(letter).swapCase()\n\
    \        }\n        if letter.hasPrefix(\"o\") {\n            letter = String(letter).swapCase()\n\
    \        }\n        if letter.hasPrefix(\"u\") {\n            letter = String(letter).swapCase()\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp1jbpmujm.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmp1jbpmujm.swift:16:38:\
    \ error: value of type 'String' has no member 'swapCase'\n            result +=\
    \ String(letter).swapCase()\n                      ~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmp1jbpmujm.swift:22:19:\
    \ error: value of type 'Character' has no member 'hasPrefix'\n        if letter.hasPrefix(\"\
    A\") {\n           ~~~~~~ ^~~~~~~~~\n/tmp/tmp1jbpmujm.swift:23:13: error: cannot\
    \ assign to value: 'letter' is a 'let' constant\n            letter = String(letter).swapCase()\n\
    \            ^~~~~~\n/tmp/tmp1jbpmujm.swift:23:37: error: value of type 'String'\
    \ has no member 'swapCase'\n            letter = String(letter).swapCase()\n \
    \                    ~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmp1jbpmujm.swift:25:19: error:\
    \ value of type 'Character' has no member 'hasPrefix'\n        if letter.hasPrefix(\"\
    E\") {\n           ~~~~~~ ^~~~~~~~~\n/tmp/tmp1jbpmujm.swift:26:13: error: cannot\
    \ assign to value: 'letter' is a 'let' constant\n            letter = String(letter).swapCase()\n\
    \            ^~~~~~\n/tmp/tmp1jbpmujm.swift:26:37: error: value of type 'String'\
    \ has no member 'swapCase'\n            letter = String(letter).swapCase()\n \
    \                    ~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmp1jbpmujm.swift:28:19: error:\
    \ value of type 'Character' has no member 'hasPrefix'\n        if letter.hasPrefix(\"\
    I\") {\n           ~~~~~~ ^~~~~~~~~\n/tmp/tmp1jbpmujm.swift:29:13: error: cannot\
    \ assign to value: 'letter' is a 'let' constant\n            letter = String(letter).swapCase()\n\
    \            ^~~~~~\n/tmp/tmp1jbpmujm.swift:29:37: error: value of type 'String'\
    \ has no member 'swapCase'\n            letter = String(letter).swapCase()\n \
    \                    ~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmp1jbpmujm.swift:31:19: error:\
    \ value of type 'Character' has no member 'hasPrefix'\n        if letter.hasPrefix(\"\
    O\") {\n           ~~~~~~ ^~~~~~~~~\n/tmp/tmp1jbpmujm.swift:32:13: error: cannot\
    \ assign to value: 'letter' is a 'let' constant\n            letter = String(l"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = english.index(of: letter)\n        let replacement\
    \ = english[index! + 2]\n        result += replacement\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpmve_hk14.swift:15:21: error: cannot find 'english' in scope\n \
    \       let index = english.index(of: letter)\n                    ^~~~~~~\n/tmp/tmpmve_hk14.swift:16:27:\
    \ error: cannot find 'english' in scope\n        let replacement = english[index!\
    \ + 2]\n                          ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)\n        let replacement\
    \ = alphabet[(index + 1) % alphabet.count]\n        result += String(letter).replacingOccurrences(of:\
    \ letter, with: replacement)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpmhidmc3y.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)\n                    ^~~~~~~~\n\
    /tmp/tmpmhidmc3y.swift:16:27: error: cannot find 'alphabet' in scope\n       \
    \ let replacement = alphabet[(index + 1) % alphabet.count]\n                 \
    \         ^~~~~~~~\n/tmp/tmpmhidmc3y.swift:16:50: error: cannot find 'alphabet'\
    \ in scope\n        let replacement = alphabet[(index + 1) % alphabet.count]\n\
    \                                                 ^~~~~~~~\n/tmp/tmpmhidmc3y.swift:17:34:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ result += String(letter).replacingOccurrences(of: letter, with: replacement)\n\
    \                  ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += String(letter).swapCase()\n\
    \        } else {\n            result += String(letter)\n        }\n    }\n  \
    \  for vowel in \"aeiouAEIOU\" {\n        let index = message.indexOf(vowel)\n\
    \        let letter = message.substringFromIndex(index).lowercaseString\n    \
    \    result += String(letter).swapCase()\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp5anfadqi.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmp5anfadqi.swift:16:38:\
    \ error: value of type 'String' has no member 'swapCase'\n            result +=\
    \ String(letter).swapCase()\n                      ~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmp5anfadqi.swift:22:29:\
    \ error: value of type 'String' has no member 'indexOf'\n        let index = message.indexOf(vowel)\n\
    \                    ~~~~~~~ ^~~~~~~\n/tmp/tmp5anfadqi.swift:23:30: error: value\
    \ of type 'String' has no member 'substringFromIndex'\n        let letter = message.substringFromIndex(index).lowercaseString\n\
    \                     ~~~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp5anfadqi.swift:24:34:\
    \ error: reference to member 'swapCase' cannot be resolved without a contextual\
    \ type\n        result += String(letter).swapCase()\n                        \
    \         ^\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += letter\n   \
    \     } else {\n            result += letter.lowercased()\n        }\n    }\n\
    \    for letter in result {\n        if letter.hasVowel() {\n            result\
    \ += letter.swapVowels()\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp8n3mp6is.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmp8n3mp6is.swift:16:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n/tmp/tmp8n3mp6is.swift:22:19:\
    \ error: value of type 'Character' has no member 'hasVowel'\n        if letter.hasVowel()\
    \ {\n           ~~~~~~ ^~~~~~~~\n/tmp/tmp8n3mp6is.swift:23:30: error: value of\
    \ type 'Character' has no member 'swapVowels'\n            result += letter.swapVowels()\n\
    \                      ~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n        case \"e\"\
    :\n        case \"i\":\n        case \"o\":\n        case \"u\":\n        case\
    \ \"A\":\n        case \"E\":\n        case \"I\":\n        case \"O\":\n    \
    \    case \"U\":\n            result += letter\n        default:\n           \
    \ result += letter + String(letter).substring(1)\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\"\
    ) == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpbjcgzbpt.swift:16:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"a\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpbjcgzbpt.swift:17:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"e\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmpbjcgzbpt.swift:18:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"i\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpbjcgzbpt.swift:19:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"o\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpbjcgzbpt.swift:20:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"u\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpbjcgzbpt.swift:21:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"A\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpbjcgzbpt.swift:22:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"E\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpbjcgzbpt.swift:23:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"I\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpbjcgzbpt.swift:24:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"O\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpbjcgzbpt.swift:26:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n/tmp/tmpbjcgzbpt.swift:28:47:\
    \ error: value of type 'String' has no member 'substring'\n            result\
    \ += letter + String(letter).substring(1)\n                               ~~~~~~~~~~~~~~\
    \ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n            result\
    \ += \"A\"\n        case \"b\":\n            result += \"B\"\n        case \"\
    c\":\n            result += \"C\"\n        case \"d\":\n            result +=\
    \ \"D\"\n        case \"e\":\n            result += \"E\"\n        case \"f\"\
    :\n            result += \"F\"\n        case \"g\":\n            result += \"\
    G\"\n        case \"h\":\n            result += \"H\"\n        case \"i\":\n \
    \           result += \"I\"\n        case \"j\":\n            result += \"J\"\n\
    \        case \"k\":\n            result += \"K\"\n        case \"l\":\n     \
    \       result += \"L\"\n        case \"m\":\n            result += \"M\"\n  \
    \      case \"n\":\n            result += \"N\"\n        case \"o\":\n       \
    \     result += \"O\"\n        case \"p\":\n            result += \"P\"\n    \
    \    case \"q\":\n            result += \"Q\"\n        case \"r\":\n         \
    \   result += \"R\"\n        case \"s\":\n            result += \"S\"\n      \
    \  case \"t\":\n            result += \"T\"\n        case \"u\":\n           \
    \ result += \"U\"\n        case \"v\":\n            result += \"V\"\n        case\
    \ \"w\":\n            result += \"W\"\n        case \"x\":\n            result\
    \ += \"X\"\n        case \"y\":\n            result += \"Y\"\n        case \"\
    z\":\n            result += \"Z\"\n        default:\n            result += letter\n\
    \        }\n    }\n    for letter in result {\n        if letter == \"A\" || letter\
    \ == \"B\" || letter == \"C\" || letter == \"D\" || letter == \"E\" || letter\
    \ == \"F\" || letter == \"G\" || letter == \"H\" || letter == \"I\" || letter\
    \ == \"J\" || letter == \"K\" || letter == \"L\" || letter == \"M\" || letter\
    \ == \"N\" || letter == \"O\" || letter == \"P\" || letter == \"Q\" || letter\
    \ == \"R\" || letter == \"S\" || letter == \"T\" || letter == \"U\" || letter\
    \ == \"V\" || letter == \"W\" || letter == \"X\" || letter == \"Y\" || letter\
    \ == \"Z\" {\n            continue\n        }\n        if letter == \"a\" || letter\
    \ == \"b\" || letter == \"c\" || letter == \"d\" || letter == \"e\" || letter\
    \ == \"f\" || letter == \"g\" || letter == \"h\" || letter == \"i\" || letter\
    \ == \"j\" || letter == \"k\" || letter == \"l\" || letter == \"m\" || letter\
    \ == \"n\" || letter == \"o\" || letter == \"p\" || letter == \"q\" || letter\
    \ == \"r\" || letter == \"s\" || letter == \"t\" || letter == \"u\" || letter\
    \ == \"v\" || \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encode(message: \"\
    TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpoa0hqayc.swift:77:1: error: expected expression after operator\n\
    }\n^\n/tmp/tmpoa0hqayc.swift:96:84: error: expected '}' at end of brace statement\n\
    assert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq\
    \ wRkTg\")\n                                                                 \
    \                  ^\n/tmp/tmpoa0hqayc.swift:12:40: note: to match this opening\
    \ '{'\nfunc encode(message: String) -> String {\n                            \
    \           ^\n/tmp/tmpoa0hqayc.swift:69:23: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n            result += letter\n\
    \                      ^\n/tmp/tmpoa0hqayc.swift:80:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = english.index(of: letter)\n        let replacement\
    \ = english[index! + 2]\n        result += english[letter]\n        result +=\
    \ replacement\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpjov_q0lg.swift:15:21: error: cannot find 'english' in scope\n \
    \       let index = english.index(of: letter)\n                    ^~~~~~~\n/tmp/tmpjov_q0lg.swift:16:27:\
    \ error: cannot find 'english' in scope\n        let replacement = english[index!\
    \ + 2]\n                          ^~~~~~~\n/tmp/tmpjov_q0lg.swift:17:19: error:\
    \ cannot find 'english' in scope\n        result += english[letter]\n        \
    \          ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n            result\
    \ += \"A\"\n        case \"b\":\n            result += \"B\"\n        case \"\
    c\":\n            result += \"C\"\n        case \"d\":\n            result +=\
    \ \"D\"\n        case \"e\":\n            result += \"E\"\n        case \"f\"\
    :\n            result += \"F\"\n        case \"g\":\n            result += \"\
    G\"\n        case \"h\":\n            result += \"H\"\n        case \"i\":\n \
    \           result += \"I\"\n        case \"j\":\n            result += \"J\"\n\
    \        case \"k\":\n            result += \"K\"\n        case \"l\":\n     \
    \       result += \"L\"\n        case \"m\":\n            result += \"M\"\n  \
    \      case \"n\":\n            result += \"N\"\n        case \"o\":\n       \
    \     result += \"O\"\n        case \"p\":\n            result += \"P\"\n    \
    \    case \"q\":\n            result += \"Q\"\n        case \"r\":\n         \
    \   result += \"R\"\n        case \"s\":\n            result += \"S\"\n      \
    \  case \"t\":\n            result += \"T\"\n        case \"u\":\n           \
    \ result += \"U\"\n        case \"v\":\n            result += \"V\"\n        case\
    \ \"w\":\n            result += \"W\"\n        case \"x\":\n            result\
    \ += \"X\"\n        case \"y\":\n            result += \"Y\"\n        case \"\
    z\":\n            result += \"Z\"\n        default:\n            result += letter\n\
    \        }\n    }\n    for letter in result {\n        switch letter {\n     \
    \   case \"A\":\n            result += \"a\"\n        case \"B\":\n          \
    \  result += \"b\"\n        case \"C\":\n            result += \"c\"\n       \
    \ case \"D\":\n            result += \"d\"\n        case \"E\":\n            result\
    \ += \"e\"\n        case \"F\":\n            result += \"f\"\n        case \"\
    G\":\n            result += \"g\"\n        case \"H\":\n            result +=\
    \ \"h\"\n        case \"I\":\n            result += \"i\"\n        case \"J\"\
    :\n            result += \"j\"\n        case \"K\":\n            result += \"\
    k\"\n        case \"L\":\n            result += \"l\"\n        case \"M\":\n \
    \           result += \"m\"\n        case \"N\":\n            result += \"n\"\n\
    \        case \"O\":\n            result += \"o\"\n        case \"P\":\n     \
    \       result += \"p\"\n        case \"Q\":\n            result += \"q\"\n  \
    \      case \"R\":\n            result += \"r\"\n        case \"S\":\n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpzzldxrd2.swift:110:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"S\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpzzldxrd2.swift:131:84: error: expected '}' at\
    \ end of brace statement\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\"\
    ) == \"k dQnT kNqW wHcT Tq wRkTg\")\n                                        \
    \                                           ^\n/tmp/tmpzzldxrd2.swift:72:26: note:\
    \ to match this opening '{'\n    for letter in result {\n                    \
    \     ^\n/tmp/tmpzzldxrd2.swift:131:84: error: expected '}' at end of brace statement\n\
    assert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq\
    \ wRkTg\")\n                                                                 \
    \                  ^\n/tmp/tmpzzldxrd2.swift:12:40: note: to match this opening\
    \ '{'\nfunc encode(message: String) -> String {\n                            \
    \           ^\n/tmp/tmpzzldxrd2.swift:69:23: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n            result += letter\n\
    \                      ^\n/tmp/tmpzzldxrd2.swift:73:9: error: switch must be exhaustive\n\
    \        switch letter {\n        ^\n/tmp/tmpzzldxrd2.swift:73:9: note: do you\
    \ want to add a default clause?\n        switch letter {\n        ^\n/tmp/tmpzzldxrd2.swift:115:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)\n        if index\
    \ == nil {\n            return \"\"\n        }\n        let replacement = alphabet[(index!.offset(by:\
    \ 2)+1)%26]\n        result += String(letter).replacingOccurrences(of: vowel,\
    \ with: replacement)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"\
    Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpmzjriy0z.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)\n                    ^~~~~~~~\n\
    /tmp/tmpmzjriy0z.swift:19:27: error: cannot find 'alphabet' in scope\n       \
    \ let replacement = alphabet[(index!.offset(by: 2)+1)%26]\n                  \
    \        ^~~~~~~~\n/tmp/tmpmzjriy0z.swift:20:59: error: cannot find 'vowel' in\
    \ scope\n        result += String(letter).replacingOccurrences(of: vowel, with:\
    \ replacement)\n                                                          ^~~~~\n\
    /tmp/tmpmzjriy0z.swift:20:34: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        result += String(letter).replacingOccurrences(of: vowel, with: replacement)\n\
    \                  ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        var newLetter = letter\n        for vowel in vowels {\n \
    \           newLetter = newLetter.replace(vowel, vowels[vowels.index(vowel)! +\
    \ 1])\n        }\n        result += newLetter\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpx2wnk2_g.swift:16:22: error: cannot find 'vowels' in scope\n  \
    \      for vowel in vowels {\n                     ^~~~~~\n/tmp/tmpx2wnk2_g.swift:19:19:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        result += newLetter\n                  ^\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)\n        let replacement\
    \ = alphabet[(index! + 2) % alphabet.count]\n        result += replacement\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpegpzxi6z.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)\n                    ^~~~~~~~\n\
    /tmp/tmpegpzxi6z.swift:16:27: error: cannot find 'alphabet' in scope\n       \
    \ let replacement = alphabet[(index! + 2) % alphabet.count]\n                \
    \          ^~~~~~~~\n/tmp/tmpegpzxi6z.swift:16:51: error: cannot find 'alphabet'\
    \ in scope\n        let replacement = alphabet[(index! + 2) % alphabet.count]\n\
    \                                                  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)\n        let replacement\
    \ = alphabet[(index + 1)..<alphabet.count]\n        result += replacement\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpt9cokxi2.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)\n                    ^~~~~~~~\n\
    /tmp/tmpt9cokxi2.swift:16:27: error: cannot find 'alphabet' in scope\n       \
    \ let replacement = alphabet[(index + 1)..<alphabet.count]\n                 \
    \         ^~~~~~~~\n/tmp/tmpt9cokxi2.swift:16:50: error: cannot find 'alphabet'\
    \ in scope\n        let replacement = alphabet[(index + 1)..<alphabet.count]\n\
    \                                                 ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n            result\
    \ = \"t\"\n        case \"e\":\n            result = \"h\"\n        case \"i\"\
    :\n            result = \"k\"\n        case \"o\":\n            result = \"g\"\
    \n        case \"u\":\n            result = \"s\"\n        case \"A\":\n     \
    \       result = \"T\"\n        case \"E\":\n            result = \"H\"\n    \
    \    case \"I\":\n            result = \"K\"\n        case \"O\":\n          \
    \  result = \"G\"\n        case \"U\":\n            result = \"S\"\n        default:\n\
    \            result = letter\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp4wx_b_bh.swift:37:22: error: cannot assign value of type 'Character'\
    \ to type 'String'\n            result = letter\n                     ^~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)\n        let replacement\
    \ = alphabet[index! + 1]\n        result += String(letter).replacingOccurrences(of:\
    \ \"A\", with: replacement)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp5i70eof0.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)\n                    ^~~~~~~~\n\
    /tmp/tmp5i70eof0.swift:16:27: error: cannot find 'alphabet' in scope\n       \
    \ let replacement = alphabet[index! + 1]\n                          ^~~~~~~~\n\
    /tmp/tmp5i70eof0.swift:17:34: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        result += String(letter).replacingOccurrences(of: \"A\", with: replacement)\n\
    \                  ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)\n        let replacement\
    \ = alphabet[(index + 2) % 26]\n        result += String(letter).replacingOccurrences(of:\
    \ letter, with: replacement)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpio4u698q.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)\n                    ^~~~~~~~\n\
    /tmp/tmpio4u698q.swift:16:27: error: cannot find 'alphabet' in scope\n       \
    \ let replacement = alphabet[(index + 2) % 26]\n                          ^~~~~~~~\n\
    /tmp/tmpio4u698q.swift:17:34: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        result += String(letter).replacingOccurrences(of: letter, with: replacement)\n\
    \                  ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += String(letter).swapCase()\n\
    \        } else {\n            result += letter\n        }\n    }\n    for vowel\
    \ in \"AEIOUaeiou\" {\n        let index = message.index(of: vowel)\n        if\
    \ index != nil {\n            let twoLettersBefore = message[index! - 2 : index!]\n\
    \            let index = twoLettersBefore.index(of: vowel)\n            if index\
    \ != nil {\n                let letter = twoLettersBefore[index!]\n          \
    \      result += String(letter).swapCase()\n            }\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encode(message: \"\
    TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp1ptcegux.swift:24:55: error: expected ',' separator\n         \
    \   let twoLettersBefore = message[index! - 2 : index!]\n                    \
    \                                  ^\n                                       \
    \              ,\n/tmp/tmp1ptcegux.swift:24:55: error: expected expression in\
    \ list of expressions\n            let twoLettersBefore = message[index! - 2 :\
    \ index!]\n                                                      ^\n/tmp/tmp1ptcegux.swift:15:19:\
    \ error: value of type 'Character' has no member 'isUpper'\n        if letter.isUpper()\
    \ {\n           ~~~~~~ ^~~~~~~\n/tmp/tmp1ptcegux.swift:16:38: error: value of\
    \ type 'String' has no member 'swapCase'\n            result += String(letter).swapCase()\n\
    \                      ~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmp1ptcegux.swift:18:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n/tmp/tmp1ptcegux.swift:22:29:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ index = message.index(of: vowel)\n                            ^\n/tmp/tmp1ptcegux.swift:22:29:\
    \ note: use 'firstIndex(of:)' instead\n        let index = message.index(of: vowel)\n\
    \                            ^~~~~\n                            firstIndex\n/tmp/tmp1ptcegux.swift:24:49:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n            let twoLettersBefore = message[index! - 2 : index!]\n   \
    \                                             ^\n/tmp/tmp1ptcegux.swift:28:42:\
    \ error: reference to member 'swapCase' cannot be resolved without a contextual\
    \ type\n                result += String(letter).swapCase()\n                \
    \                         ^\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n        case \"e\"\
    :\n        case \"i\":\n        case \"o\":\n        case \"u\":\n           \
    \ result += letter\n        default:\n            result += String(letter).swapCase()\n\
    \        }\n    }\n    for vowel in \"aeiou\" {\n        result += String(vowel).swapCase()\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmptqcswdh9.swift:16:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"a\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmptqcswdh9.swift:17:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"e\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmptqcswdh9.swift:18:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"i\":\n        ^~~~~~~~~\n                  break\n/tmp/tmptqcswdh9.swift:19:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"o\":\n        ^~~~~~~~~\n                  break\n/tmp/tmptqcswdh9.swift:21:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n/tmp/tmptqcswdh9.swift:23:38:\
    \ error: value of type 'String' has no member 'swapCase'\n            result +=\
    \ String(letter).swapCase()\n                      ~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmptqcswdh9.swift:27:33:\
    \ error: value of type 'String' has no member 'swapCase'\n        result += String(vowel).swapCase()\n\
    \                  ~~~~~~~~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = english.index(of: letter)\n        let replacement\
    \ = english[index! + 2]\n        result += String(letter).uppercased() + replacement\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpi4xlu0qi.swift:15:21: error: cannot find 'english' in scope\n \
    \       let index = english.index(of: letter)\n                    ^~~~~~~\n/tmp/tmpi4xlu0qi.swift:16:27:\
    \ error: cannot find 'english' in scope\n        let replacement = english[index!\
    \ + 2]\n                          ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)\n        let replacement\
    \ = alphabet[(index + 2)%26]\n        result += String(letter).replacingOccurrences(of:\
    \ vowel, with: replacement)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp_nmsxdks.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)\n                    ^~~~~~~~\n\
    /tmp/tmp_nmsxdks.swift:16:27: error: cannot find 'alphabet' in scope\n       \
    \ let replacement = alphabet[(index + 2)%26]\n                          ^~~~~~~~\n\
    /tmp/tmp_nmsxdks.swift:17:59: error: cannot find 'vowel' in scope\n        result\
    \ += String(letter).replacingOccurrences(of: vowel, with: replacement)\n     \
    \                                                     ^~~~~\n/tmp/tmp_nmsxdks.swift:17:34:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ result += String(letter).replacingOccurrences(of: vowel, with: replacement)\n\
    \                  ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = english.index(of: letter)\n        let nextIndex\
    \ = english.index(of: letter, offsetBy: index + 1)\n        let replacement =\
    \ english[nextIndex!]\n        result += replacement\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpym1p8wma.swift:15:21: error: cannot find 'english' in scope\n \
    \       let index = english.index(of: letter)\n                    ^~~~~~~\n/tmp/tmpym1p8wma.swift:16:25:\
    \ error: cannot find 'english' in scope\n        let nextIndex = english.index(of:\
    \ letter, offsetBy: index + 1)\n                        ^~~~~~~\n/tmp/tmpym1p8wma.swift:17:27:\
    \ error: cannot find 'english' in scope\n        let replacement = english[nextIndex!]\n\
    \                          ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += letter.lowercased()\n\
    \        } else {\n            result += letter.uppercased()\n        }\n    }\n\
    \    for letter in result {\n        if letter == letter.lowercased() {\n    \
    \        result += letter.lowercased()\n        } else {\n            result +=\
    \ letter.uppercased()\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp8f0454wh.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmp8f0454wh.swift:22:19:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if letter == letter.lowercased() {\n           ~~~~~~\
    \ ^  ~~~~~~~~~~~~~~~~~~~\n/tmp/tmp8f0454wh.swift:22:19: note: overloads for '=='\
    \ exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if letter == letter.lowercased() {\n             \
    \     ^\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)!\n        let replacement\
    \ = alphabet[(index + 1)..<alphabet.count]\n        result += String(replacement)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpomosd6dg.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)!\n                    ^~~~~~~~\n\
    /tmp/tmpomosd6dg.swift:16:27: error: cannot find 'alphabet' in scope\n       \
    \ let replacement = alphabet[(index + 1)..<alphabet.count]\n                 \
    \         ^~~~~~~~\n/tmp/tmpomosd6dg.swift:16:50: error: cannot find 'alphabet'\
    \ in scope\n        let replacement = alphabet[(index + 1)..<alphabet.count]\n\
    \                                                 ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n        case \"e\"\
    :\n        case \"i\":\n        case \"o\":\n        case \"u\":\n           \
    \ result += letter\n        default:\n            result += letter.swapCase()\n\
    \        }\n    }\n    for letter in result {\n        for vowel in vowels {\n\
    \            if letter == vowel {\n                result += vowel\n         \
    \   }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"\
    Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp5m0_y3yw.swift:16:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"a\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmp5m0_y3yw.swift:17:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"e\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmp5m0_y3yw.swift:18:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"i\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp5m0_y3yw.swift:19:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"o\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp5m0_y3yw.swift:21:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n/tmp/tmp5m0_y3yw.swift:23:30:\
    \ error: value of type 'Character' has no member 'swapCase'\n            result\
    \ += letter.swapCase()\n                      ~~~~~~ ^~~~~~~~\n/tmp/tmp5m0_y3yw.swift:27:22:\
    \ error: cannot find 'vowels' in scope\n        for vowel in vowels {\n      \
    \               ^~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n        case \"e\"\
    :\n        case \"i\":\n        case \"o\":\n        case \"u\":\n           \
    \ result += letter\n        default:\n            result += letter.swapCase()\n\
    \        }\n    }\n    for vowel in \"aeiou\" {\n        result += vowel.swapCase()\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpks_dgayw.swift:16:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"a\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpks_dgayw.swift:17:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"e\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmpks_dgayw.swift:18:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"i\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpks_dgayw.swift:19:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"o\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpks_dgayw.swift:21:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n/tmp/tmpks_dgayw.swift:23:30:\
    \ error: value of type 'Character' has no member 'swapCase'\n            result\
    \ += letter.swapCase()\n                      ~~~~~~ ^~~~~~~~\n/tmp/tmpks_dgayw.swift:27:25:\
    \ error: value of type 'Character' has no member 'swapCase'\n        result +=\
    \ vowel.swapCase()\n                  ~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)!\n        let replacement\
    \ = alphabet[index + 2]\n        result += String(letter).replacingOccurrences(of:\
    \ \"AEIOUaeiou\", with: replacement)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpiipglkpx.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)!\n                    ^~~~~~~~\n\
    /tmp/tmpiipglkpx.swift:16:27: error: cannot find 'alphabet' in scope\n       \
    \ let replacement = alphabet[index + 2]\n                          ^~~~~~~~\n\
    /tmp/tmpiipglkpx.swift:17:34: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        result += String(letter).replacingOccurrences(of: \"AEIOUaeiou\", with:\
    \ replacement)\n                  ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)\n        let replacement\
    \ = alphabet[index + 2]\n        result += replacement\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmplz5wtlgf.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)\n                    ^~~~~~~~\n\
    /tmp/tmplz5wtlgf.swift:16:27: error: cannot find 'alphabet' in scope\n       \
    \ let replacement = alphabet[index + 2]\n                          ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)\n        let replacement\
    \ = alphabet[index + 2]\n        result += String(letter).replacingOccurrences(of:\
    \ \"A\", with: replacement)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpe19satyq.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)\n                    ^~~~~~~~\n\
    /tmp/tmpe19satyq.swift:16:27: error: cannot find 'alphabet' in scope\n       \
    \ let replacement = alphabet[index + 2]\n                          ^~~~~~~~\n\
    /tmp/tmpe19satyq.swift:17:34: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        result += String(letter).replacingOccurrences(of: \"A\", with: replacement)\n\
    \                  ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = english.index(of: letter)\n        let replacement\
    \ = english[index! + 2]\n        result += replacement\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpmve_hk14.swift:15:21: error: cannot find 'english' in scope\n \
    \       let index = english.index(of: letter)\n                    ^~~~~~~\n/tmp/tmpmve_hk14.swift:16:27:\
    \ error: cannot find 'english' in scope\n        let replacement = english[index!\
    \ + 2]\n                          ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        var newLetter = letter\n        for vowel in vowels {\n \
    \           if letter == vowel {\n                newLetter = vowels[vowels.index(vowel)!\
    \ + 1]\n            }\n        }\n        result += newLetter\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\"\
    ) == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpbjmemq2y.swift:16:22: error: cannot find 'vowels' in scope\n  \
    \      for vowel in vowels {\n                     ^~~~~~\n/tmp/tmpbjmemq2y.swift:21:19:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        result += newLetter\n                  ^\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n            result\
    \ = \"t\"\n        case \"e\":\n            result = \"h\"\n        case \"i\"\
    :\n            result = \"k\"\n        case \"o\":\n            result = \"g\"\
    \n        case \"u\":\n            result = \"s\"\n        case \"A\":\n     \
    \       result = \"T\"\n        case \"E\":\n            result = \"H\"\n    \
    \    case \"I\":\n            result = \"K\"\n        case \"O\":\n          \
    \  result = \"G\"\n        case \"U\":\n            result = \"S\"\n        default:\n\
    \            result = letter\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp4wx_b_bh.swift:37:22: error: cannot assign value of type 'Character'\
    \ to type 'String'\n            result = letter\n                     ^~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += letter.lowercased()\n\
    \        } else {\n            result += letter.uppercased()\n        }\n    }\n\
    \    for letter in result {\n        if letter.isUpper() {\n            result\
    \ += letter.lowercased()\n        } else {\n            result += letter.uppercased()\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpo9ucstmd.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmpo9ucstmd.swift:22:19:\
    \ error: value of type 'Character' has no member 'isUpper'\n        if letter.isUpper()\
    \ {\n           ~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)!\n        let replacement\
    \ = alphabet[index + 2]\n        result += String(letter).replacingOccurrences(of:\
    \ \"AEIOUaeiou\", with: replacement)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpiipglkpx.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)!\n                    ^~~~~~~~\n\
    /tmp/tmpiipglkpx.swift:16:27: error: cannot find 'alphabet' in scope\n       \
    \ let replacement = alphabet[index + 2]\n                          ^~~~~~~~\n\
    /tmp/tmpiipglkpx.swift:17:34: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        result += String(letter).replacingOccurrences(of: \"AEIOUaeiou\", with:\
    \ replacement)\n                  ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for char in\
    \ message {\n        let index = english.index(of: char)\n        let replacement\
    \ = english[index! + 2]\n        result += String(char).replacingOccurrences(of:\
    \ \"AEIOUaeiou\", with: replacement)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpg5sbmvwb.swift:15:21: error: cannot find 'english' in scope\n \
    \       let index = english.index(of: char)\n                    ^~~~~~~\n/tmp/tmpg5sbmvwb.swift:16:27:\
    \ error: cannot find 'english' in scope\n        let replacement = english[index!\
    \ + 2]\n                          ^~~~~~~\n/tmp/tmpg5sbmvwb.swift:17:32: error:\
    \ value of type 'String' has no member 'replacingOccurrences'\n        result\
    \ += String(char).replacingOccurrences(of: \"AEIOUaeiou\", with: replacement)\n\
    \                  ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)\n        let replacement\
    \ = alphabet[(index + 2) % 26]\n        result += replacement\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\"\
    ) == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp08cswh9i.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)\n                    ^~~~~~~~\n\
    /tmp/tmp08cswh9i.swift:16:27: error: cannot find 'alphabet' in scope\n       \
    \ let replacement = alphabet[(index + 2) % 26]\n                          ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += letter.swapCase()\n\
    \        } else {\n            result += letter\n        }\n    }\n    for vowel\
    \ in \"aeiouAEIOU\" {\n        let index = message.indexOf(vowel)\n        if\
    \ index != -1 {\n            let letter = message[index + 2]\n            result\
    \ += letter.swapCase()\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpscnt378z.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmpscnt378z.swift:16:30:\
    \ error: value of type 'Character' has no member 'swapCase'\n            result\
    \ += letter.swapCase()\n                      ~~~~~~ ^~~~~~~~\n/tmp/tmpscnt378z.swift:18:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n/tmp/tmpscnt378z.swift:22:29:\
    \ error: value of type 'String' has no member 'indexOf'\n        let index = message.indexOf(vowel)\n\
    \                    ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n            result\
    \ += \"A\"\n        case \"b\":\n            result += \"B\"\n        case \"\
    c\":\n            result += \"C\"\n        case \"d\":\n            result +=\
    \ \"D\"\n        case \"e\":\n            result += \"E\"\n        case \"f\"\
    :\n            result += \"F\"\n        case \"g\":\n            result += \"\
    G\"\n        case \"h\":\n            result += \"H\"\n        case \"i\":\n \
    \           result += \"I\"\n        case \"j\":\n            result += \"J\"\n\
    \        case \"k\":\n            result += \"K\"\n        case \"l\":\n     \
    \       result += \"L\"\n        case \"m\":\n            result += \"M\"\n  \
    \      case \"n\":\n            result += \"N\"\n        case \"o\":\n       \
    \     result += \"O\"\n        case \"p\":\n            result += \"P\"\n    \
    \    case \"q\":\n            result += \"Q\"\n        case \"r\":\n         \
    \   result += \"R\"\n        case \"s\":\n            result += \"S\"\n      \
    \  case \"t\":\n            result += \"T\"\n        case \"u\":\n           \
    \ result += \"U\"\n        case \"v\":\n            result += \"V\"\n        case\
    \ \"w\":\n            result += \"W\"\n        case \"x\":\n            result\
    \ += \"X\"\n        case \"y\":\n            result += \"Y\"\n        case \"\
    z\":\n            result += \"Z\"\n        default:\n            result += letter\n\
    \        }\n    }\n    for vowel in \"aeiou\" {\n        let index = message.index(of:\
    \ vowel)\n        let nextIndex = message.index(of: vowel, offsetBy: 2)\n    \
    \    if index != nil && nextIndex != nil {\n            let replacement = message[index!]\
    \ + message[nextIndex!]\n            result += replacement\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encode(message: \"\
    TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmptdinz1gw.swift:69:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += letter\n         \
    \             ^\n/tmp/tmptdinz1gw.swift:73:29: warning: 'index(of:)' is deprecated:\
    \ renamed to 'firstIndex(of:)'\n        let index = message.index(of: vowel)\n\
    \                            ^\n/tmp/tmptdinz1gw.swift:73:29: note: use 'firstIndex(of:)'\
    \ instead\n        let index = message.index(of: vowel)\n                    \
    \        ^~~~~\n                            firstIndex\n/tmp/tmptdinz1gw.swift:74:33:\
    \ error: no exact matches in call to instance method 'index'\n        let nextIndex\
    \ = message.index(of: vowel, offsetBy: 2)\n                                ^\n\
    /tmp/tmptdinz1gw.swift:74:33: note: candidate has partially matching parameter\
    \ list (String.Index, offsetBy: Int)\n        let nextIndex = message.index(of:\
    \ vowel, offsetBy: 2)\n                                ^\n/tmp/tmptdinz1gw.swift:74:33:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int)\n        let nextIndex = message.index(of: vowel, offsetBy: 2)\n      \
    \                          ^\nSwift.Collection:3:28: note: candidate '(String.Element)\
    \ -> String.Index?' (aka '(Character) -> Optional<String.Index>') requires 1 argument,\
    \ but 2 were provided\n    @inlinable public func index(of element: Self.Element)\
    \ -> Self.Index?\n                           ^\n/tmp/tmptdinz1gw.swift:74:33:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int)\n        let nextIndex = message.index(of: vowel, offsetBy: 2)\n      \
    \                          ^\n/tmp/tmptdinz1gw.swift:76:38: error: subscript 'subscript(_:)'\
    \ requires that 'String.Index' conform to 'RangeExpression'\n            let replacement\
    \ = message[index!] + message[nextIndex!]\n                                  \
    \   ^\nSwift.Collection:2:23: note: where 'R' = 'String.Index'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get }\n                      ^\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n            result\
    \ += \"t\"\n        case \"e\":\n            result += \"h\"\n        case \"\
    i\":\n            result += \"k\"\n        case \"o\":\n            result +=\
    \ \"s\"\n        case \"u\":\n            result += \"c\"\n        case \"A\"\
    :\n            result += \"T\"\n        case \"E\":\n            result += \"\
    H\"\n        case \"I\":\n            result += \"K\"\n        case \"O\":\n \
    \           result += \"S\"\n        case \"U\":\n            result += \"C\"\n\
    \        default:\n            result += letter\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\"\
    ) == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpu2guji2t.swift:37:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += letter\n         \
    \             ^\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n        case \"e\"\
    :\n        case \"i\":\n        case \"o\":\n        case \"u\":\n           \
    \ result += letter\n        default:\n            result += letter\n        }\n\
    \    }\n    for letter in result {\n        if letter == \"a\" || letter == \"\
    e\" || letter == \"i\" || letter == \"o\" || letter == \"u\" {\n            result\
    \ += letter\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpqe_8ck4t.swift:16:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"a\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpqe_8ck4t.swift:17:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"e\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmpqe_8ck4t.swift:18:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"i\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpqe_8ck4t.swift:19:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"o\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpqe_8ck4t.swift:21:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n/tmp/tmpqe_8ck4t.swift:23:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n/tmp/tmpqe_8ck4t.swift:28:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = english.index(of: letter)\n        let replacement\
    \ = english[(index?.successor())!]\n        result += String(letter).replacingOccurrences(of:\
    \ \"AEIOUaeiou\", with: replacement)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpif2ic0z8.swift:15:21: error: cannot find 'english' in scope\n \
    \       let index = english.index(of: letter)\n                    ^~~~~~~\n/tmp/tmpif2ic0z8.swift:16:27:\
    \ error: cannot find 'english' in scope\n        let replacement = english[(index?.successor())!]\n\
    \                          ^~~~~~~\n/tmp/tmpif2ic0z8.swift:17:34: error: value\
    \ of type 'String' has no member 'replacingOccurrences'\n        result += String(letter).replacingOccurrences(of:\
    \ \"AEIOUaeiou\", with: replacement)\n                  ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        var newLetter = letter\n        var newVowel = \"\"\n   \
    \     if letter == \"a\" {\n            newVowel = \"A\"\n        } else if letter\
    \ == \"e\" {\n            newVowel = \"E\"\n        } else if letter == \"i\"\
    \ {\n            newVowel = \"I\"\n        } else if letter == \"o\" {\n     \
    \       newVowel = \"O\"\n        } else if letter == \"u\" {\n            newVowel\
    \ = \"U\"\n        } else if letter == \"A\" {\n            newVowel = \"a\"\n\
    \        } else if letter == \"E\" {\n            newVowel = \"e\"\n        }\
    \ else if letter == \"I\" {\n            newVowel = \"i\"\n        } else if letter\
    \ == \"O\" {\n            newVowel = \"o\"\n        } else if letter == \"U\"\
    \ {\n            newVowel = \"u\"\n        }\n        if newVowel != \"\" {\n\
    \            newLetter = newVowel + String(newLetter)\n        }\n        result\
    \ = result + newLetter\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpr7b2rb99.swift:39:34: error: cannot assign value of type 'String'\
    \ to type 'Character'\n            newLetter = newVowel + String(newLetter)\n\
    \                        ~~~~~~~~~^~~~~~~~~~~~~~~~~~~\n/tmp/tmpr7b2rb99.swift:41:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        result = result + newLetter\n                          ^\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += letter.lowercased()\n\
    \        } else {\n            result += letter.uppercased()\n        }\n    }\n\
    \    for vowel in \"AEIOUaeiou\" {\n        let index = result.index(of: vowel)\n\
    \        if index != nil {\n            let vowelIndex = index! + 2\n        \
    \    if vowelIndex < result.count {\n                result += result[vowelIndex]\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpwvlkhupy.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmpwvlkhupy.swift:22:28:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ index = result.index(of: vowel)\n                           ^\n/tmp/tmpwvlkhupy.swift:22:28:\
    \ note: use 'firstIndex(of:)' instead\n        let index = result.index(of: vowel)\n\
    \                           ^~~~~\n                           firstIndex\n/tmp/tmpwvlkhupy.swift:24:35:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n            let vowelIndex = index! + 2\n                           \
    \       ^\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for char in\
    \ message {\n        let index = alphabet.index(of: char)\n        let replacement\
    \ = alphabet[index! + 1]\n        result += String(replacement)\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\"\
    ) == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpnegsi_5e.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmpnegsi_5e.swift:16:27: error: cannot find 'alphabet' in scope\n       \
    \ let replacement = alphabet[index! + 1]\n                          ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for char in\
    \ message {\n        let index = alphabet.index(of: char)\n        let replacement\
    \ = alphabet[(index! + 2) % alphabet.count]\n        result += String(char).replacingOccurrences(of:\
    \ char, with: replacement)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpaz37zaht.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmpaz37zaht.swift:16:27: error: cannot find 'alphabet' in scope\n       \
    \ let replacement = alphabet[(index! + 2) % alphabet.count]\n                \
    \          ^~~~~~~~\n/tmp/tmpaz37zaht.swift:16:51: error: cannot find 'alphabet'\
    \ in scope\n        let replacement = alphabet[(index! + 2) % alphabet.count]\n\
    \                                                  ^~~~~~~~\n/tmp/tmpaz37zaht.swift:17:32:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ result += String(char).replacingOccurrences(of: char, with: replacement)\n \
    \                 ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n            result\
    \ += \"A\"\n        case \"b\":\n            result += \"B\"\n        case \"\
    c\":\n            result += \"C\"\n        case \"d\":\n            result +=\
    \ \"D\"\n        case \"e\":\n            result += \"E\"\n        case \"f\"\
    :\n            result += \"F\"\n        case \"g\":\n            result += \"\
    G\"\n        case \"h\":\n            result += \"H\"\n        case \"i\":\n \
    \           result += \"I\"\n        case \"j\":\n            result += \"J\"\n\
    \        case \"k\":\n            result += \"K\"\n        case \"l\":\n     \
    \       result += \"L\"\n        case \"m\":\n            result += \"M\"\n  \
    \      case \"n\":\n            result += \"N\"\n        case \"o\":\n       \
    \     result += \"O\"\n        case \"p\":\n            result += \"P\"\n    \
    \    case \"q\":\n            result += \"Q\"\n        case \"r\":\n         \
    \   result += \"R\"\n        case \"s\":\n            result += \"S\"\n      \
    \  case \"t\":\n            result += \"T\"\n        case \"u\":\n           \
    \ result += \"U\"\n        case \"v\":\n            result += \"V\"\n        case\
    \ \"w\":\n            result += \"W\"\n        case \"x\":\n            result\
    \ += \"X\"\n        case \"y\":\n            result += \"Y\"\n        case \"\
    z\":\n            result += \"Z\"\n        case \"A\":\n            result +=\
    \ \"a\"\n        case \"B\":\n            result += \"b\"\n        case \"C\"\
    :\n            result += \"c\"\n        case \"D\":\n            result += \"\
    d\"\n        case \"E\":\n            result += \"e\"\n        case \"F\":\n \
    \           result += \"f\"\n        case \"G\":\n            result += \"g\"\n\
    \        case \"H\":\n            result += \"h\"\n        case \"I\":\n     \
    \       result += \"i\"\n        case \"J\":\n            result += \"j\"\n  \
    \      case \"K\":\n            result += \"k\"\n        case \"L\":\n       \
    \     result += \"l\"\n        case \"M\":\n            result += \"m\"\n    \
    \    case \"N\":\n            result += \"n\"\n        case \"O\":\n         \
    \   result += \"o\"\n        case \"P\":\n            result += \"p\"\n      \
    \  case \"Q\":\n            result += \"q\"\n        case \"R\":\n           \
    \ result += \"r\"\n        case \"S\":\n            result += \"s\"\n        case\
    \ \"T\":\n            result += \"t\"\n        case \"U\":\n            \n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp_dwjd4v7.swift:108:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"U\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmp_dwjd4v7.swift:129:84: error: expected '}' at\
    \ end of brace statement\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\"\
    ) == \"k dQnT kNqW wHcT Tq wRkTg\")\n                                        \
    \                                           ^\n/tmp/tmp_dwjd4v7.swift:14:27: note:\
    \ to match this opening '{'\n    for letter in message {\n                   \
    \       ^\n/tmp/tmp_dwjd4v7.swift:129:84: error: expected '}' at end of brace\
    \ statement\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT\
    \ kNqW wHcT Tq wRkTg\")\n                                                    \
    \                               ^\n/tmp/tmp_dwjd4v7.swift:12:40: note: to match\
    \ this opening '{'\nfunc encode(message: String) -> String {\n               \
    \                        ^\n/tmp/tmp_dwjd4v7.swift:15:9: error: switch must be\
    \ exhaustive\n        switch letter {\n        ^\n/tmp/tmp_dwjd4v7.swift:15:9:\
    \ note: do you want to add a default clause?\n        switch letter {\n      \
    \  ^\n/tmp/tmp_dwjd4v7.swift:113:6: error: operator functions can only be declared\
    \ at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n            result\
    \ += \"A\"\n        case \"b\":\n            result += \"B\"\n        case \"\
    c\":\n            result += \"C\"\n        case \"d\":\n            result +=\
    \ \"D\"\n        case \"e\":\n            result += \"E\"\n        case \"f\"\
    :\n            result += \"F\"\n        case \"g\":\n            result += \"\
    G\"\n        case \"h\":\n            result += \"H\"\n        case \"i\":\n \
    \           result += \"I\"\n        case \"j\":\n            result += \"J\"\n\
    \        case \"k\":\n            result += \"K\"\n        case \"l\":\n     \
    \       result += \"L\"\n        case \"m\":\n            result += \"M\"\n  \
    \      case \"n\":\n            result += \"N\"\n        case \"o\":\n       \
    \     result += \"O\"\n        case \"p\":\n            result += \"P\"\n    \
    \    case \"q\":\n            result += \"Q\"\n        case \"r\":\n         \
    \   result += \"R\"\n        case \"s\":\n            result += \"S\"\n      \
    \  case \"t\":\n            result += \"T\"\n        case \"u\":\n           \
    \ result += \"U\"\n        case \"v\":\n            result += \"V\"\n        case\
    \ \"w\":\n            result += \"W\"\n        case \"x\":\n            result\
    \ += \"X\"\n        case \"y\":\n            result += \"Y\"\n        case \"\
    z\":\n            result += \"Z\"\n        default:\n            result += letter\n\
    \        }\n    }\n    for letter in result {\n        if letter == \"A\" || letter\
    \ == \"a\" {\n            letter = \"a\"\n        } else if letter == \"B\" ||\
    \ letter == \"b\" {\n            letter = \"b\"\n        } else if letter == \"\
    C\" || letter == \"c\" {\n            letter = \"c\"\n        } else if letter\
    \ == \"D\" || letter == \"d\" {\n            letter = \"d\"\n        } else if\
    \ letter == \"E\" || letter == \"e\" {\n            letter = \"e\"\n        }\
    \ else if letter == \"F\" || letter == \"f\" {\n            letter = \"f\"\n \
    \       } else if letter == \"G\" || letter == \"g\" {\n            letter = \"\
    g\"\n        } else if letter == \"H\" || letter == \"h\" {\n            letter\
    \ = \"h\"\n        } else if letter == \"I\" || letter == \"i\" {\n          \
    \  letter = \"i\"\n        } else if letter == \"J\" || letter == \"j\" {\n  \
    \          letter = \"j\"\n        } else if letter == \"K\" || letter == \"k\"\
    \ {\n            letter = \"k\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpbf3xg3gc.swift:114:84: error: expected '}' at end of brace statement\n\
    assert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq\
    \ wRkTg\")\n                                                                 \
    \                  ^\n/tmp/tmpbf3xg3gc.swift:72:26: note: to match this opening\
    \ '{'\n    for letter in result {\n                         ^\n/tmp/tmpbf3xg3gc.swift:114:84:\
    \ error: expected '}' at end of brace statement\nassert(encode(message: \"I DoNt\
    \ KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")\n                  \
    \                                                                 ^\n/tmp/tmpbf3xg3gc.swift:12:40:\
    \ note: to match this opening '{'\nfunc encode(message: String) -> String {\n\
    \                                       ^\n/tmp/tmpbf3xg3gc.swift:69:23: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n/tmp/tmpbf3xg3gc.swift:74:13:\
    \ error: cannot assign to value: 'letter' is a 'let' constant\n            letter\
    \ = \"a\"\n            ^~~~~~\n/tmp/tmpbf3xg3gc.swift:76:13: error: cannot assign\
    \ to value: 'letter' is a 'let' constant\n            letter = \"b\"\n       \
    \     ^~~~~~\n/tmp/tmpbf3xg3gc.swift:78:13: error: cannot assign to value: 'letter'\
    \ is a 'let' constant\n            letter = \"c\"\n            ^~~~~~\n/tmp/tmpbf3xg3gc.swift:80:13:\
    \ error: cannot assign to value: 'letter' is a 'let' constant\n            letter\
    \ = \"d\"\n            ^~~~~~\n/tmp/tmpbf3xg3gc.swift:82:13: error: cannot assign\
    \ to value: 'letter' is a 'let' constant\n            letter = \"e\"\n       \
    \     ^~~~~~\n/tmp/tmpbf3xg3gc.swift:84:13: error: cannot assign to value: 'letter'\
    \ is a 'let' constant\n            letter = \"f\"\n            ^~~~~~\n/tmp/tmpbf3xg3gc.swift:86:13:\
    \ error: cannot assign to value: 'letter' is a 'let' constant\n            letter\
    \ = \"g\"\n            ^~~~~~\n/tmp/tmpbf3xg3gc.swift:88:13: error: cannot assign\
    \ to value: 'letter' is a 'let' constant\n            letter = \"h\"\n       \
    \     ^~~~~~\n/tmp/tmpbf3xg3gc.swift:90:13: error: cannot assign to valu"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = english.index(of: letter)\n        let replacement\
    \ = english[index! + 2]\n        result += String(letter).replacingOccurrences(of:\
    \ \"AEIOUaeiou\", with: replacement)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpdl2b1u_3.swift:15:21: error: cannot find 'english' in scope\n \
    \       let index = english.index(of: letter)\n                    ^~~~~~~\n/tmp/tmpdl2b1u_3.swift:16:27:\
    \ error: cannot find 'english' in scope\n        let replacement = english[index!\
    \ + 2]\n                          ^~~~~~~\n/tmp/tmpdl2b1u_3.swift:17:34: error:\
    \ value of type 'String' has no member 'replacingOccurrences'\n        result\
    \ += String(letter).replacingOccurrences(of: \"AEIOUaeiou\", with: replacement)\n\
    \                  ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        var index = alphabet.index(letter)\n        if index == -1\
    \ {\n            index = alphabet.index(letter, letter + 1)\n        }\n     \
    \   if index != -1 {\n            result += alphabet[index + 2]\n        } else\
    \ {\n            result += letter\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp6xk_duar.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        var index = alphabet.index(letter)\n                    ^~~~~~~~\n/tmp/tmp6xk_duar.swift:17:21:\
    \ error: cannot find 'alphabet' in scope\n            index = alphabet.index(letter,\
    \ letter + 1)\n                    ^~~~~~~~\n/tmp/tmp6xk_duar.swift:17:44: error:\
    \ cannot convert value of type 'Character' to expected argument type 'Int'\n \
    \           index = alphabet.index(letter, letter + 1)\n                     \
    \                      ^\n/tmp/tmp6xk_duar.swift:20:23: error: cannot find 'alphabet'\
    \ in scope\n            result += alphabet[index + 2]\n                      ^~~~~~~~\n\
    /tmp/tmp6xk_duar.swift:22:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += letter\n         \
    \             ^\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += letter.lowercased()\n\
    \        } else {\n            result += letter.uppercased()\n        }\n    }\n\
    \    for vowel in \"AEIOUaeiou\" {\n        let index = result.index(of: vowel)\n\
    \        if index != nil {\n            let replacement = result.index(before:\
    \ index!)\n            result += String(result[replacement!...])\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpbj3o1eaf.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmpbj3o1eaf.swift:22:28:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ index = result.index(of: vowel)\n                           ^\n/tmp/tmpbj3o1eaf.swift:22:28:\
    \ note: use 'firstIndex(of:)' instead\n        let index = result.index(of: vowel)\n\
    \                           ^~~~~\n                           firstIndex\n/tmp/tmpbj3o1eaf.swift:25:48:\
    \ error: cannot force unwrap value of non-optional type 'String.Index'\n     \
    \       result += String(result[replacement!...])\n                          \
    \          ~~~~~~~~~~~^\n                                               \n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)!\n        let replacement\
    \ = alphabet[index + 2]\n        result += String(letter).replacingOccurrences(of:\
    \ \"AEIOUaeiou\", with: replacement)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpiipglkpx.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)!\n                    ^~~~~~~~\n\
    /tmp/tmpiipglkpx.swift:16:27: error: cannot find 'alphabet' in scope\n       \
    \ let replacement = alphabet[index + 2]\n                          ^~~~~~~~\n\
    /tmp/tmpiipglkpx.swift:17:34: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        result += String(letter).replacingOccurrences(of: \"AEIOUaeiou\", with:\
    \ replacement)\n                  ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = english.index(of: letter)\n        let replacement\
    \ = english[index! + 2]\n        result += replacement\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpmve_hk14.swift:15:21: error: cannot find 'english' in scope\n \
    \       let index = english.index(of: letter)\n                    ^~~~~~~\n/tmp/tmpmve_hk14.swift:16:27:\
    \ error: cannot find 'english' in scope\n        let replacement = english[index!\
    \ + 2]\n                          ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n            result\
    \ += \"A\"\n        case \"b\":\n            result += \"B\"\n        case \"\
    c\":\n            result += \"C\"\n        case \"d\":\n            result +=\
    \ \"D\"\n        case \"e\":\n            result += \"E\"\n        case \"f\"\
    :\n            result += \"F\"\n        case \"g\":\n            result += \"\
    G\"\n        case \"h\":\n            result += \"H\"\n        case \"i\":\n \
    \           result += \"I\"\n        case \"j\":\n            result += \"J\"\n\
    \        case \"k\":\n            result += \"K\"\n        case \"l\":\n     \
    \       result += \"L\"\n        case \"m\":\n            result += \"M\"\n  \
    \      case \"n\":\n            result += \"N\"\n        case \"o\":\n       \
    \     result += \"O\"\n        case \"p\":\n            result += \"P\"\n    \
    \    case \"q\":\n            result += \"Q\"\n        case \"r\":\n         \
    \   result += \"R\"\n        case \"s\":\n            result += \"S\"\n      \
    \  case \"t\":\n            result += \"T\"\n        case \"u\":\n           \
    \ result += \"U\"\n        case \"v\":\n            result += \"V\"\n        case\
    \ \"w\":\n            result += \"W\"\n        case \"x\":\n            result\
    \ += \"X\"\n        case \"y\":\n            result += \"Y\"\n        case \"\
    z\":\n            result += \"Z\"\n        case \"A\":\n            result +=\
    \ \"a\"\n        case \"B\":\n            result += \"b\"\n        case \"C\"\
    :\n            result += \"c\"\n        case \"D\":\n            result += \"\
    d\"\n        case \"E\":\n            result += \"e\"\n        case \"F\":\n \
    \           result += \"f\"\n        case \"G\":\n            result += \"g\"\n\
    \        case \"H\":\n            result += \"h\"\n        case \"I\":\n     \
    \       result += \"i\"\n        case \"J\":\n            result += \"j\"\n  \
    \      case \"K\":\n            result += \"k\"\n        case \"L\":\n       \
    \     result += \"l\"\n        case \"M\":\n            result += \"m\"\n    \
    \    case \"N\":\n            result += \"n\"\n        case \"O\":\n         \
    \   result += \"o\"\n        case \"P\":\n            result += \"p\"\n      \
    \  case \"Q\":\n            result += \"q\"\n        case \"R\":\n           \
    \ result += \"r\"\n        case \"S\":\n            result += \"s\"\n        case\
    \ \"T\":\n            result += \"t\"\n        case \"U\":\n            \n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp_dwjd4v7.swift:108:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"U\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmp_dwjd4v7.swift:129:84: error: expected '}' at\
    \ end of brace statement\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\"\
    ) == \"k dQnT kNqW wHcT Tq wRkTg\")\n                                        \
    \                                           ^\n/tmp/tmp_dwjd4v7.swift:14:27: note:\
    \ to match this opening '{'\n    for letter in message {\n                   \
    \       ^\n/tmp/tmp_dwjd4v7.swift:129:84: error: expected '}' at end of brace\
    \ statement\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT\
    \ kNqW wHcT Tq wRkTg\")\n                                                    \
    \                               ^\n/tmp/tmp_dwjd4v7.swift:12:40: note: to match\
    \ this opening '{'\nfunc encode(message: String) -> String {\n               \
    \                        ^\n/tmp/tmp_dwjd4v7.swift:15:9: error: switch must be\
    \ exhaustive\n        switch letter {\n        ^\n/tmp/tmp_dwjd4v7.swift:15:9:\
    \ note: do you want to add a default clause?\n        switch letter {\n      \
    \  ^\n/tmp/tmp_dwjd4v7.swift:113:6: error: operator functions can only be declared\
    \ at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)\n        let replacement\
    \ = alphabet[index! + 1]\n        result += String(letter).replacingOccurrences(of:\
    \ replacement, with: replacement)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpcxfctusr.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)\n                    ^~~~~~~~\n\
    /tmp/tmpcxfctusr.swift:16:27: error: cannot find 'alphabet' in scope\n       \
    \ let replacement = alphabet[index! + 1]\n                          ^~~~~~~~\n\
    /tmp/tmpcxfctusr.swift:17:34: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        result += String(letter).replacingOccurrences(of: replacement, with:\
    \ replacement)\n                  ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        var newLetter = letter\n        switch letter {\n       \
    \ case \"a\":\n            newLetter = \"A\"\n        case \"b\":\n          \
    \  newLetter = \"B\"\n        case \"c\":\n            newLetter = \"C\"\n   \
    \     case \"d\":\n            newLetter = \"D\"\n        case \"e\":\n      \
    \      newLetter = \"E\"\n        case \"f\":\n            newLetter = \"F\"\n\
    \        case \"g\":\n            newLetter = \"G\"\n        case \"h\":\n   \
    \         newLetter = \"H\"\n        case \"i\":\n            newLetter = \"I\"\
    \n        case \"j\":\n            newLetter = \"J\"\n        case \"k\":\n  \
    \          newLetter = \"K\"\n        case \"l\":\n            newLetter = \"\
    L\"\n        case \"m\":\n            newLetter = \"M\"\n        case \"n\":\n\
    \            newLetter = \"N\"\n        case \"o\":\n            newLetter = \"\
    O\"\n        case \"p\":\n            newLetter = \"P\"\n        case \"q\":\n\
    \            newLetter = \"Q\"\n        case \"r\":\n            newLetter = \"\
    R\"\n        case \"s\":\n            newLetter = \"S\"\n        case \"t\":\n\
    \            newLetter = \"T\"\n        case \"u\":\n            newLetter = \"\
    U\"\n        case \"v\":\n            newLetter = \"V\"\n        case \"w\":\n\
    \            newLetter = \"W\"\n        case \"x\":\n            newLetter = \"\
    X\"\n        case \"y\":\n            newLetter = \"Y\"\n        case \"z\":\n\
    \            newLetter = \"Z\"\n        case \"A\":\n            newLetter = \"\
    a\"\n        case \"B\":\n            newLetter = \"b\"\n        case \"C\":\n\
    \            newLetter = \"c\"\n        case \"D\":\n            newLetter = \"\
    d\"\n        case \"E\":\n            newLetter = \"e\"\n        case \"F\":\n\
    \            newLetter = \"f\"\n        case \"G\":\n            newLetter = \"\
    g\"\n        case \"H\":\n            newLetter = \"h\"\n        case \"I\":\n\
    \            newLetter = \"i\"\n        case \"J\":\n            newLetter = \"\
    j\"\n        case \"K\":\n            newLetter = \"k\"\n        case \"L\":\n\
    \            newLetter = \"l\"\n        case \"M\":\n            newLetter = \"\
    m\"\n        case \"N\":\n            newLetter = \"n\"\n        case \"O\":\n\
    \            newLetter = \"o\"\n        case \"P\":\n            newLetter = \"\
    p\"\n        case \"Q\":\n            newLetter = \"q\"\n        case \"R\":\n\
    \            newLetter = \"r\"\n        case \"S\":\n            newLetter = \"\
    s\"\n        case \"T\":\n            newLetter = \"t\"\n\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp8oy0ms3n.swift:129:84: error: expected '}' at end of brace statement\n\
    assert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq\
    \ wRkTg\")\n                                                                 \
    \                  ^\n/tmp/tmp8oy0ms3n.swift:14:27: note: to match this opening\
    \ '{'\n    for letter in message {\n                          ^\n/tmp/tmp8oy0ms3n.swift:129:84:\
    \ error: expected '}' at end of brace statement\nassert(encode(message: \"I DoNt\
    \ KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")\n                  \
    \                                                                 ^\n/tmp/tmp8oy0ms3n.swift:12:40:\
    \ note: to match this opening '{'\nfunc encode(message: String) -> String {\n\
    \                                       ^\n/tmp/tmp8oy0ms3n.swift:16:9: error:\
    \ switch must be exhaustive\n        switch letter {\n        ^\n/tmp/tmp8oy0ms3n.swift:16:9:\
    \ note: do you want to add a default clause?\n        switch letter {\n      \
    \  ^\n/tmp/tmp8oy0ms3n.swift:113:6: error: operator functions can only be declared\
    \ at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n     ^\n/tmp/tmp8oy0ms3n.swift:13:9: warning: initialization of variable\
    \ 'result' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    var result = \"\"\n    ~~~~^~~~~~\n    _\n/tmp/tmp8oy0ms3n.swift:15:13:\
    \ warning: variable 'newLetter' was written to, but never read\n        var newLetter\
    \ = letter\n            ^\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)!\n        let replacement\
    \ = alphabet[index + 2]\n        result += replacement\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp_3_w4ekd.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)!\n                    ^~~~~~~~\n\
    /tmp/tmp_3_w4ekd.swift:16:27: error: cannot find 'alphabet' in scope\n       \
    \ let replacement = alphabet[index + 2]\n                          ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)!\n        let replacement\
    \ = alphabet[(index + 1) % alphabet.count]\n        result += replacement\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp7p0u4s6s.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)!\n                    ^~~~~~~~\n\
    /tmp/tmp7p0u4s6s.swift:16:27: error: cannot find 'alphabet' in scope\n       \
    \ let replacement = alphabet[(index + 1) % alphabet.count]\n                 \
    \         ^~~~~~~~\n/tmp/tmp7p0u4s6s.swift:16:50: error: cannot find 'alphabet'\
    \ in scope\n        let replacement = alphabet[(index + 1) % alphabet.count]\n\
    \                                                 ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += letter.lowercased()\n\
    \        } else {\n            result += letter.uppercased()\n        }\n    }\n\
    \    for letter in result {\n        if letter.hasVowel() {\n            result\
    \ += letter.swapVowels()\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpjhc526ia.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmpjhc526ia.swift:22:19:\
    \ error: value of type 'Character' has no member 'hasVowel'\n        if letter.hasVowel()\
    \ {\n           ~~~~~~ ^~~~~~~~\n/tmp/tmpjhc526ia.swift:23:30: error: value of\
    \ type 'Character' has no member 'swapVowels'\n            result += letter.swapVowels()\n\
    \                      ~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += letter.lowercased()\n\
    \        } else {\n            result += letter.uppercased()\n        }\n    }\n\
    \    for letter in result {\n        if letter == \"A\" {\n            result\
    \ = \"B\"\n        } else if letter == \"B\" {\n            result = \"C\"\n \
    \       } else if letter == \"C\" {\n            result = \"D\"\n        } else\
    \ if letter == \"D\" {\n            result = \"E\"\n        } else if letter ==\
    \ \"E\" {\n            result = \"F\"\n        } else if letter == \"F\" {\n \
    \           result = \"G\"\n        } else if letter == \"G\" {\n            result\
    \ = \"H\"\n        } else if letter == \"H\" {\n            result = \"I\"\n \
    \       } else if letter == \"I\" {\n            result = \"J\"\n        } else\
    \ if letter == \"J\" {\n            result = \"K\"\n        } else if letter ==\
    \ \"K\" {\n            result = \"L\"\n        } else if letter == \"L\" {\n \
    \           result = \"M\"\n        } else if letter == \"M\" {\n            result\
    \ = \"N\"\n        } else if letter == \"N\" {\n            result = \"O\"\n \
    \       } else if letter == \"O\" {\n            result = \"P\"\n        } else\
    \ if letter == \"P\" {\n            result = \"Q\"\n        } else if letter ==\
    \ \"Q\" {\n            result = \"R\"\n        } else if letter == \"R\" {\n \
    \           result = \"S\"\n        } else if letter == \"S\" {\n            result\
    \ = \"T\"\n        } else if letter == \"T\" {\n            result = \"U\"\n \
    \       } else if letter == \"U\" {\n            result = \"V\"\n        } else\
    \ if letter == \"V\" {\n            result = \"W\"\n        } else if letter ==\
    \ \"W\" {\n            result = \"X\"\n        } else if letter == \"X\" {\n \
    \           result = \"Y\"\n        } else if letter == \"Y\" {\n            result\
    \ = \"Z\"\n        } else if letter == \"Z\" {\n            result = \"A\"\n \
    \       }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmprwyrd2bs.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)\n        let replacement\
    \ = alphabet[index! + 1]\n        result += String(letter).replacingOccurrences(of:\
    \ replacement, with: replacement)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpcxfctusr.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)\n                    ^~~~~~~~\n\
    /tmp/tmpcxfctusr.swift:16:27: error: cannot find 'alphabet' in scope\n       \
    \ let replacement = alphabet[index! + 1]\n                          ^~~~~~~~\n\
    /tmp/tmpcxfctusr.swift:17:34: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        result += String(letter).replacingOccurrences(of: replacement, with:\
    \ replacement)\n                  ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"A\":\n            result\
    \ = \"T\"\n        case \"B\":\n            result = \"G\"\n        case \"C\"\
    :\n            result = \"K\"\n        case \"D\":\n            result = \"S\"\
    \n        case \"E\":\n            result = \"C\"\n        case \"F\":\n     \
    \       result = \"M\"\n        case \"G\":\n            result = \"G\"\n    \
    \    case \"H\":\n            result = \"H\"\n        case \"I\":\n          \
    \  result = \"K\"\n        case \"J\":\n            result = \"J\"\n        case\
    \ \"K\":\n            result = \"K\"\n        case \"L\":\n            result\
    \ = \"L\"\n        case \"M\":\n            result = \"M\"\n        case \"N\"\
    :\n            result = \"N\"\n        case \"O\":\n            result = \"O\"\
    \n        case \"P\":\n            result = \"P\"\n        case \"Q\":\n     \
    \       result = \"Q\"\n        case \"R\":\n            result = \"R\"\n    \
    \    case \"S\":\n            result = \"S\"\n        case \"T\":\n          \
    \  result = \"T\"\n        case \"U\":\n            result = \"U\"\n        case\
    \ \"V\":\n            result = \"V\"\n        case \"W\":\n            result\
    \ = \"W\"\n        case \"X\":\n            result = \"X\"\n        case \"Y\"\
    :\n            result = \"Y\"\n        case \"Z\":\n            result = \"Z\"\
    \n        default:\n            result = letter\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\"\
    ) == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpwfqmg0ug.swift:69:22: error: cannot assign value of type 'Character'\
    \ to type 'String'\n            result = letter\n                     ^~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n            result\
    \ += \"A\"\n        case \"b\":\n            result += \"B\"\n        case \"\
    c\":\n            result += \"C\"\n        case \"d\":\n            result +=\
    \ \"D\"\n        case \"e\":\n            result += \"E\"\n        case \"f\"\
    :\n            result += \"F\"\n        case \"g\":\n            result += \"\
    G\"\n        case \"h\":\n            result += \"H\"\n        case \"i\":\n \
    \           result += \"I\"\n        case \"j\":\n            result += \"J\"\n\
    \        case \"k\":\n            result += \"K\"\n        case \"l\":\n     \
    \       result += \"L\"\n        case \"m\":\n            result += \"M\"\n  \
    \      case \"n\":\n            result += \"N\"\n        case \"o\":\n       \
    \     result += \"O\"\n        case \"p\":\n            result += \"P\"\n    \
    \    case \"q\":\n            result += \"Q\"\n        case \"r\":\n         \
    \   result += \"R\"\n        case \"s\":\n            result += \"S\"\n      \
    \  case \"t\":\n            result += \"T\"\n        case \"u\":\n           \
    \ result += \"U\"\n        case \"v\":\n            result += \"V\"\n        case\
    \ \"w\":\n            result += \"W\"\n        case \"x\":\n            result\
    \ += \"X\"\n        case \"y\":\n            result += \"Y\"\n        case \"\
    z\":\n            result += \"Z\"\n        default:\n            result += letter\n\
    \        }\n    }\n    for letter in result {\n        switch letter {\n     \
    \   case \"A\":\n            result += \"a\"\n        case \"B\":\n          \
    \  result += \"b\"\n        case \"C\":\n            result += \"c\"\n       \
    \ case \"D\":\n            result += \"d\"\n        case \"E\":\n            result\
    \ += \"e\"\n        case \"F\":\n            result += \"f\"\n        case \"\
    G\":\n            result += \"g\"\n        case \"H\":\n            result +=\
    \ \"h\"\n        case \"I\":\n            result += \"i\"\n        case \"J\"\
    :\n            result += \"j\"\n        case \"K\":\n            result += \"\
    k\"\n        case \"L\":\n            result += \"l\"\n        case \"M\":\n \
    \           result += \"m\"\n        case \"N\":\n            result += \"n\"\n\
    \        case \"O\":\n            result += \"o\"\n        case \"P\":\n     \
    \       result += \"p\"\n        case \"Q\":\n            result += \"q\"\n  \
    \      case \"R\":\n            result += \"r\"\n        case \"S\":\n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpzzldxrd2.swift:110:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"S\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpzzldxrd2.swift:131:84: error: expected '}' at\
    \ end of brace statement\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\"\
    ) == \"k dQnT kNqW wHcT Tq wRkTg\")\n                                        \
    \                                           ^\n/tmp/tmpzzldxrd2.swift:72:26: note:\
    \ to match this opening '{'\n    for letter in result {\n                    \
    \     ^\n/tmp/tmpzzldxrd2.swift:131:84: error: expected '}' at end of brace statement\n\
    assert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq\
    \ wRkTg\")\n                                                                 \
    \                  ^\n/tmp/tmpzzldxrd2.swift:12:40: note: to match this opening\
    \ '{'\nfunc encode(message: String) -> String {\n                            \
    \           ^\n/tmp/tmpzzldxrd2.swift:69:23: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n            result += letter\n\
    \                      ^\n/tmp/tmpzzldxrd2.swift:73:9: error: switch must be exhaustive\n\
    \        switch letter {\n        ^\n/tmp/tmpzzldxrd2.swift:73:9: note: do you\
    \ want to add a default clause?\n        switch letter {\n        ^\n/tmp/tmpzzldxrd2.swift:115:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += letter.lowercased()\n\
    \        } else {\n            result += letter.uppercased()\n        }\n    }\n\
    \    for letter in result {\n        if letter.hasVowel() {\n            result\
    \ += letter.swapVowels()\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpjhc526ia.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmpjhc526ia.swift:22:19:\
    \ error: value of type 'Character' has no member 'hasVowel'\n        if letter.hasVowel()\
    \ {\n           ~~~~~~ ^~~~~~~~\n/tmp/tmpjhc526ia.swift:23:30: error: value of\
    \ type 'Character' has no member 'swapVowels'\n            result += letter.swapVowels()\n\
    \                      ~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += String(letter).swapCase()\n\
    \        } else {\n            result += letter\n        }\n    }\n    for vowel\
    \ in \"aeiouAEIOU\" {\n        let index = message.index(of: vowel)\n        if\
    \ index != nil {\n            let vowelIndex = index! + 2\n            if vowelIndex\
    \ < message.count {\n                result += String(message[vowelIndex])\n \
    \           }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpe7tpn609.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmpe7tpn609.swift:16:38:\
    \ error: value of type 'String' has no member 'swapCase'\n            result +=\
    \ String(letter).swapCase()\n                      ~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmpe7tpn609.swift:18:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n/tmp/tmpe7tpn609.swift:22:29:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ index = message.index(of: vowel)\n                            ^\n/tmp/tmpe7tpn609.swift:22:29:\
    \ note: use 'firstIndex(of:)' instead\n        let index = message.index(of: vowel)\n\
    \                            ^~~~~\n                            firstIndex\n/tmp/tmpe7tpn609.swift:24:35:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n            let vowelIndex = index! + 2\n                           \
    \       ^\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)!\n        let replacement\
    \ = alphabet[index + 2]\n        result += replacement\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp_3_w4ekd.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)!\n                    ^~~~~~~~\n\
    /tmp/tmp_3_w4ekd.swift:16:27: error: cannot find 'alphabet' in scope\n       \
    \ let replacement = alphabet[index + 2]\n                          ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += letter\n   \
    \     } else if letter.isLower() {\n            result += letter.swapCase()\n\
    \        } else {\n            result += letter.swapCase()\n        }\n    }\n\
    \    for letter in result {\n        if letter.isUpper() {\n            result\
    \ += letter.swapCase()\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpo7wc5ddp.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmpo7wc5ddp.swift:16:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n/tmp/tmpo7wc5ddp.swift:17:26:\
    \ error: value of type 'Character' has no member 'isLower'\n        } else if\
    \ letter.isLower() {\n                  ~~~~~~ ^~~~~~~\n/tmp/tmpo7wc5ddp.swift:18:30:\
    \ error: value of type 'Character' has no member 'swapCase'\n            result\
    \ += letter.swapCase()\n                      ~~~~~~ ^~~~~~~~\n/tmp/tmpo7wc5ddp.swift:20:30:\
    \ error: value of type 'Character' has no member 'swapCase'\n            result\
    \ += letter.swapCase()\n                      ~~~~~~ ^~~~~~~~\n/tmp/tmpo7wc5ddp.swift:24:19:\
    \ error: value of type 'Character' has no member 'isUpper'\n        if letter.isUpper()\
    \ {\n           ~~~~~~ ^~~~~~~\n/tmp/tmpo7wc5ddp.swift:25:30: error: value of\
    \ type 'Character' has no member 'swapCase'\n            result += letter.swapCase()\n\
    \                      ~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"A\":\n        case \"E\"\
    :\n        case \"I\":\n        case \"O\":\n        case \"U\":\n           \
    \ result += letter\n        default:\n            result += letter + String(letter).characters.map\
    \ { String($0).characters.map { String($0).characters.count }.max()! + String($0).characters.map\
    \ { String($0).characters.count }.min()!\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpzjoonu5d.swift:16:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"A\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpzjoonu5d.swift:17:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"E\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmpzjoonu5d.swift:18:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"I\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpzjoonu5d.swift:19:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"O\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpzjoonu5d.swift:46:84:\
    \ error: expected '}' at end of brace statement\nassert(encode(message: \"I DoNt\
    \ KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")\n                  \
    \                                                                 ^\n/tmp/tmpzjoonu5d.swift:12:40:\
    \ note: to match this opening '{'\nfunc encode(message: String) -> String {\n\
    \                                       ^\n/tmp/tmpzjoonu5d.swift:21:23: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n/tmp/tmpzjoonu5d.swift:23:13:\
    \ error: the compiler is unable to type-check this expression in reasonable time;\
    \ try breaking up the expression into distinct sub-expressions\n            result\
    \ += letter + String(letter).characters.map { String($0).characters.map { String($0).characters.count\
    \ }.max()! + String($0).characters.map { String($0).characters.count }.min()!\n\
    \            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpzjoonu5d.swift:30:6: error: operator functions can only be declared at\
    \ global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)!\n        let replacement\
    \ = alphabet[index + 2]\n        result += String(letter).replacingOccurrences(of:\
    \ \"AEIOUaeiou\", with: replacement)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpiipglkpx.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)!\n                    ^~~~~~~~\n\
    /tmp/tmpiipglkpx.swift:16:27: error: cannot find 'alphabet' in scope\n       \
    \ let replacement = alphabet[index + 2]\n                          ^~~~~~~~\n\
    /tmp/tmpiipglkpx.swift:17:34: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        result += String(letter).replacingOccurrences(of: \"AEIOUaeiou\", with:\
    \ replacement)\n                  ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for char in\
    \ message {\n        let index = english.index(of: char)\n        let replacement\
    \ = english[index! + 2]\n        result += String(char).replacingOccurrences(of:\
    \ \"AEIOUaeiou\", with: replacement)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpg5sbmvwb.swift:15:21: error: cannot find 'english' in scope\n \
    \       let index = english.index(of: char)\n                    ^~~~~~~\n/tmp/tmpg5sbmvwb.swift:16:27:\
    \ error: cannot find 'english' in scope\n        let replacement = english[index!\
    \ + 2]\n                          ^~~~~~~\n/tmp/tmpg5sbmvwb.swift:17:32: error:\
    \ value of type 'String' has no member 'replacingOccurrences'\n        result\
    \ += String(char).replacingOccurrences(of: \"AEIOUaeiou\", with: replacement)\n\
    \                  ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"A\":\n            result\
    \ += \"T\"\n        case \"B\":\n            result += \"G\"\n        case \"\
    C\":\n            result += \"S\"\n        case \"D\":\n            result +=\
    \ \"K\"\n        case \"E\":\n            result += \"H\"\n        case \"F\"\
    :\n            result += \"T\"\n        case \"G\":\n            result += \"\
    C\"\n        case \"H\":\n            result += \"K\"\n        case \"I\":\n \
    \           result += \"G\"\n        case \"J\":\n            result += \"C\"\n\
    \        case \"K\":\n            result += \"S\"\n        case \"L\":\n     \
    \       result += \"K\"\n        case \"M\":\n            result += \"G\"\n  \
    \      case \"N\":\n            result += \"C\"\n        case \"O\":\n       \
    \     result += \"G\"\n        case \"P\":\n            result += \"K\"\n    \
    \    case \"Q\":\n            result += \"C\"\n        case \"R\":\n         \
    \   result += \"G\"\n        case \"S\":\n            result += \"K\"\n      \
    \  case \"T\":\n            result += \"T\"\n        case \"U\":\n           \
    \ result += \"H\"\n        case \"V\":\n            result += \"T\"\n        case\
    \ \"W\":\n            result += \"C\"\n        case \"X\":\n            result\
    \ += \"G\"\n        case \"Y\":\n            result += \"C\"\n        case \"\
    Z\":\n            result += \"G\"\n        default:\n            result += letter\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpn03xy5ej.swift:69:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += letter\n         \
    \             ^\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n            result\
    \ += \"A\"\n        case \"b\":\n            result += \"B\"\n        case \"\
    c\":\n            result += \"C\"\n        case \"d\":\n            result +=\
    \ \"D\"\n        case \"e\":\n            result += \"E\"\n        case \"f\"\
    :\n            result += \"F\"\n        case \"g\":\n            result += \"\
    G\"\n        case \"h\":\n            result += \"H\"\n        case \"i\":\n \
    \           result += \"I\"\n        case \"j\":\n            result += \"J\"\n\
    \        case \"k\":\n            result += \"K\"\n        case \"l\":\n     \
    \       result += \"L\"\n        case \"m\":\n            result += \"M\"\n  \
    \      case \"n\":\n            result += \"N\"\n        case \"o\":\n       \
    \     result += \"O\"\n        case \"p\":\n            result += \"P\"\n    \
    \    case \"q\":\n            result += \"Q\"\n        case \"r\":\n         \
    \   result += \"R\"\n        case \"s\":\n            result += \"S\"\n      \
    \  case \"t\":\n            result += \"T\"\n        case \"u\":\n           \
    \ result += \"U\"\n        case \"v\":\n            result += \"V\"\n        case\
    \ \"w\":\n            result += \"W\"\n        case \"x\":\n            result\
    \ += \"X\"\n        case \"y\":\n            result += \"Y\"\n        case \"\
    z\":\n            result += \"Z\"\n        case \"A\":\n            result +=\
    \ \"a\"\n        case \"B\":\n            result += \"b\"\n        case \"C\"\
    :\n            result += \"c\"\n        case \"D\":\n            result += \"\
    d\"\n        case \"E\":\n            result += \"e\"\n        case \"F\":\n \
    \           result += \"f\"\n        case \"G\":\n            result += \"g\"\n\
    \        case \"H\":\n            result += \"h\"\n        case \"I\":\n     \
    \       result += \"i\"\n        case \"J\":\n            result += \"j\"\n  \
    \      case \"K\":\n            result += \"k\"\n        case \"L\":\n       \
    \     result += \"l\"\n        case \"M\":\n            result += \"m\"\n    \
    \    case \"N\":\n            result += \"n\"\n        case \"O\":\n         \
    \   result += \"o\"\n        case \"P\":\n            result += \"p\"\n      \
    \  case \"Q\":\n            result += \"q\"\n        case \"R\":\n           \
    \ result += \"r\"\n        case \"S\":\n            result += \"s\"\n        case\
    \ \"T\":\n            result += \"t\"\n        case \"U\":\n            \n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp_dwjd4v7.swift:108:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"U\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmp_dwjd4v7.swift:129:84: error: expected '}' at\
    \ end of brace statement\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\"\
    ) == \"k dQnT kNqW wHcT Tq wRkTg\")\n                                        \
    \                                           ^\n/tmp/tmp_dwjd4v7.swift:14:27: note:\
    \ to match this opening '{'\n    for letter in message {\n                   \
    \       ^\n/tmp/tmp_dwjd4v7.swift:129:84: error: expected '}' at end of brace\
    \ statement\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT\
    \ kNqW wHcT Tq wRkTg\")\n                                                    \
    \                               ^\n/tmp/tmp_dwjd4v7.swift:12:40: note: to match\
    \ this opening '{'\nfunc encode(message: String) -> String {\n               \
    \                        ^\n/tmp/tmp_dwjd4v7.swift:15:9: error: switch must be\
    \ exhaustive\n        switch letter {\n        ^\n/tmp/tmp_dwjd4v7.swift:15:9:\
    \ note: do you want to add a default clause?\n        switch letter {\n      \
    \  ^\n/tmp/tmp_dwjd4v7.swift:113:6: error: operator functions can only be declared\
    \ at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += String(letter).swapCase()\n\
    \        } else {\n            result += String(letter)\n        }\n    }\n  \
    \  for vowel in \"aeiouAEIOU\" {\n        let index = message.index(of: vowel)\n\
    \        let nextIndex = message.index(of: vowel, offsetBy: index + 1)\n     \
    \   let replacement = String(message.substring(from: index, to: nextIndex))\n\
    \        result += replacement\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpzzay2lxn.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmpzzay2lxn.swift:16:38:\
    \ error: value of type 'String' has no member 'swapCase'\n            result +=\
    \ String(letter).swapCase()\n                      ~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmpzzay2lxn.swift:22:29:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ index = message.index(of: vowel)\n                            ^\n/tmp/tmpzzay2lxn.swift:22:29:\
    \ note: use 'firstIndex(of:)' instead\n        let index = message.index(of: vowel)\n\
    \                            ^~~~~\n                            firstIndex\n/tmp/tmpzzay2lxn.swift:23:60:\
    \ error: cannot convert value of type 'String.Index?' to expected argument type\
    \ 'Int'\n        let nextIndex = message.index(of: vowel, offsetBy: index + 1)\n\
    \                                                           ^\n/tmp/tmpzzay2lxn.swift:23:33:\
    \ error: no exact matches in call to instance method 'index'\n        let nextIndex\
    \ = message.index(of: vowel, offsetBy: index + 1)\n                          \
    \      ^\n/tmp/tmpzzay2lxn.swift:23:33: note: candidate has partially matching\
    \ parameter list (String.Index, offsetBy: Int)\n        let nextIndex = message.index(of:\
    \ vowel, offsetBy: index + 1)\n                                ^\n/tmp/tmpzzay2lxn.swift:23:33:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int)\n        let nextIndex = message.index(of: vowel, offsetBy: index + 1)\n\
    \                                ^\n/tmp/tmpzzay2lxn.swift:23:33: note: candidate\
    \ has partially matching parameter list (of: String.Element)\n        let nextIndex\
    \ = message.index(of: vowel, offsetBy: index + 1)\n                          \
    \      ^\n/tmp/tmpzzay2lxn.swift:23:33: note: candidate has partially matching\
    \ parameter list (String.Index, offsetBy: Int)\n        let nextIndex = message.index(of:\
    \ vowel, offsetBy: index + 1)\n                                ^\n/tmp/tmpzzay2lxn.swift:24:42:\
    \ error: value of type 'String' has no mem"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)!\n        let replacement\
    \ = alphabet[index + 2]\n        result += String(letter).replacingOccurrences(of:\
    \ \"A\", with: replacement)\n        result += String(letter).replacingOccurrences(of:\
    \ \"E\", with: replacement)\n        result += String(letter).replacingOccurrences(of:\
    \ \"I\", with: replacement)\n        result += String(letter).replacingOccurrences(of:\
    \ \"O\", with: replacement)\n        result += String(letter).replacingOccurrences(of:\
    \ \"U\", with: replacement)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpe2sq3nd2.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)!\n                    ^~~~~~~~\n\
    /tmp/tmpe2sq3nd2.swift:16:27: error: cannot find 'alphabet' in scope\n       \
    \ let replacement = alphabet[index + 2]\n                          ^~~~~~~~\n\
    /tmp/tmpe2sq3nd2.swift:17:34: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        result += String(letter).replacingOccurrences(of: \"A\", with: replacement)\n\
    \                  ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpe2sq3nd2.swift:18:34:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ result += String(letter).replacingOccurrences(of: \"E\", with: replacement)\n\
    \                  ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpe2sq3nd2.swift:19:34:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ result += String(letter).replacingOccurrences(of: \"I\", with: replacement)\n\
    \                  ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpe2sq3nd2.swift:20:34:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ result += String(letter).replacingOccurrences(of: \"O\", with: replacement)\n\
    \                  ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpe2sq3nd2.swift:21:34:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ result += String(letter).replacingOccurrences(of: \"U\", with: replacement)\n\
    \                  ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for char in\
    \ message {\n        switch char {\n        case \"a\":\n        case \"e\":\n\
    \        case \"i\":\n        case \"o\":\n        case \"u\":\n            result\
    \ += char\n        default:\n            result += char.swapCase()\n        }\n\
    \    }\n    for char in result {\n        switch char {\n        case \"A\":\n\
    \        case \"E\":\n        case \"I\":\n        case \"O\":\n        case \"\
    U\":\n            result += char\n        default:\n            result += char.swapCase()\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpbgfy99gv.swift:16:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"a\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpbgfy99gv.swift:17:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"e\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmpbgfy99gv.swift:18:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"i\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpbgfy99gv.swift:19:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"o\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpbgfy99gv.swift:28:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"A\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpbgfy99gv.swift:29:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"E\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpbgfy99gv.swift:30:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"I\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpbgfy99gv.swift:31:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"O\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpbgfy99gv.swift:21:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n/tmp/tmpbgfy99gv.swift:23:28:\
    \ error: value of type 'Character' has no member 'swapCase'\n            result\
    \ += char.swapCase()\n                      ~~~~ ^~~~~~~~\n/tmp/tmpbgfy99gv.swift:33:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n/tmp/tmpbgfy99gv.swift:35:28:\
    \ error: value of type 'Character' has no member 'swapCase'\n            result\
    \ += char.swapCase()\n                      ~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n            result\
    \ = \"t\"\n        case \"e\":\n            result = \"h\"\n        case \"i\"\
    :\n            result = \"k\"\n        case \"o\":\n            result = \"g\"\
    \n        case \"u\":\n            result = \"s\"\n        case \"A\":\n     \
    \       result = \"T\"\n        case \"E\":\n            result = \"H\"\n    \
    \    case \"I\":\n            result = \"K\"\n        case \"O\":\n          \
    \  result = \"G\"\n        case \"U\":\n            result = \"S\"\n        default:\n\
    \            result = letter\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp4wx_b_bh.swift:37:22: error: cannot assign value of type 'Character'\
    \ to type 'String'\n            result = letter\n                     ^~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n            result\
    \ += \"A\"\n        case \"b\":\n            result += \"B\"\n        case \"\
    c\":\n            result += \"C\"\n        case \"d\":\n            result +=\
    \ \"D\"\n        case \"e\":\n            result += \"E\"\n        case \"f\"\
    :\n            result += \"F\"\n        case \"g\":\n            result += \"\
    G\"\n        case \"h\":\n            result += \"H\"\n        case \"i\":\n \
    \           result += \"I\"\n        case \"j\":\n            result += \"J\"\n\
    \        case \"k\":\n            result += \"K\"\n        case \"l\":\n     \
    \       result += \"L\"\n        case \"m\":\n            result += \"M\"\n  \
    \      case \"n\":\n            result += \"N\"\n        case \"o\":\n       \
    \     result += \"O\"\n        case \"p\":\n            result += \"P\"\n    \
    \    case \"q\":\n            result += \"Q\"\n        case \"r\":\n         \
    \   result += \"R\"\n        case \"s\":\n            result += \"S\"\n      \
    \  case \"t\":\n            result += \"T\"\n        case \"u\":\n           \
    \ result += \"U\"\n        case \"v\":\n            result += \"V\"\n        case\
    \ \"w\":\n            result += \"W\"\n        case \"x\":\n            result\
    \ += \"X\"\n        case \"y\":\n            result += \"Y\"\n        case \"\
    z\":\n            result += \"Z\"\n        default:\n            result += letter\n\
    \        }\n    }\n    for vowel in \"aeiou\" {\n        switch vowel {\n    \
    \    case \"a\":\n            result += \"A\"\n        case \"e\":\n         \
    \   result += \"E\"\n        case \"i\":\n            result += \"I\"\n      \
    \  case \"o\":\n            result += \"O\"\n        case \"u\":\n           \
    \ result += \"U\"\n        default:\n            result += vowel\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpayzgov2r.swift:69:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += letter\n         \
    \             ^\n/tmp/tmpayzgov2r.swift:85:23: error: cannot convert value of\
    \ type 'Character' to expected argument type 'String'\n            result += vowel\n\
    \                      ^\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += String(letter).swapCase()\n\
    \        } else {\n            result += letter\n        }\n    }\n    for vowel\
    \ in \"aeiou\" {\n        let index = message.indexOf(vowel)\n        if index\
    \ != nil {\n            let vowelIndex = index! + 2\n            if vowelIndex\
    \ < message.count {\n                result += String(message[vowelIndex]).swapCase()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpbp5rckj9.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmpbp5rckj9.swift:16:38:\
    \ error: value of type 'String' has no member 'swapCase'\n            result +=\
    \ String(letter).swapCase()\n                      ~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmpbp5rckj9.swift:18:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n/tmp/tmpbp5rckj9.swift:22:29:\
    \ error: value of type 'String' has no member 'indexOf'\n        let index = message.indexOf(vowel)\n\
    \                    ~~~~~~~ ^~~~~~~\n/tmp/tmpbp5rckj9.swift:26:55: error: value\
    \ of type 'String' has no member 'swapCase'\n                result += String(message[vowelIndex]).swapCase()\n\
    \                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)\n        let replacement\
    \ = alphabet[index + 2]\n        result += String(letter).replacingOccurrences(of:\
    \ \"AEIOUaeiou\", with: replacement)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp9vnid52i.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)\n                    ^~~~~~~~\n\
    /tmp/tmp9vnid52i.swift:16:27: error: cannot find 'alphabet' in scope\n       \
    \ let replacement = alphabet[index + 2]\n                          ^~~~~~~~\n\
    /tmp/tmp9vnid52i.swift:17:34: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        result += String(letter).replacingOccurrences(of: \"AEIOUaeiou\", with:\
    \ replacement)\n                  ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n            result\
    \ = \"t\"\n        case \"e\":\n            result = \"h\"\n        case \"i\"\
    :\n            result = \"k\"\n        case \"o\":\n            result = \"g\"\
    \n        case \"u\":\n            result = \"s\"\n        case \"A\":\n     \
    \       result = \"T\"\n        case \"E\":\n            result = \"H\"\n    \
    \    case \"I\":\n            result = \"K\"\n        case \"O\":\n          \
    \  result = \"G\"\n        case \"U\":\n            result = \"S\"\n        default:\n\
    \            result = letter\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp4wx_b_bh.swift:37:22: error: cannot assign value of type 'Character'\
    \ to type 'String'\n            result = letter\n                     ^~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for char in\
    \ message {\n        let index = english.index(of: char)\n        let nextIndex\
    \ = english.index(of: char, offsetBy: index + 1)\n        let replacement = english[nextIndex!]\n\
    \        result += replacement\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpb2p4lo46.swift:15:21: error: cannot find 'english' in scope\n \
    \       let index = english.index(of: char)\n                    ^~~~~~~\n/tmp/tmpb2p4lo46.swift:16:25:\
    \ error: cannot find 'english' in scope\n        let nextIndex = english.index(of:\
    \ char, offsetBy: index + 1)\n                        ^~~~~~~\n/tmp/tmpb2p4lo46.swift:17:27:\
    \ error: cannot find 'english' in scope\n        let replacement = english[nextIndex!]\n\
    \                          ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n            result\
    \ = \"t\"\n        case \"b\":\n            result = \"h\"\n        case \"c\"\
    :\n            result = \"k\"\n        case \"d\":\n            result = \"g\"\
    \n        case \"e\":\n            result = \"s\"\n        case \"f\":\n     \
    \       result = \"c\"\n        case \"g\":\n            result = \"g\"\n    \
    \    case \"h\":\n            result = \"h\"\n        case \"i\":\n          \
    \  result = \"k\"\n        case \"j\":\n            result = \"k\"\n        case\
    \ \"k\":\n            result = \"k\"\n        case \"l\":\n            result\
    \ = \"g\"\n        case \"m\":\n            result = \"s\"\n        case \"n\"\
    :\n            result = \"c\"\n        case \"o\":\n            result = \"m\"\
    \n        case \"p\":\n            result = \"c\"\n        case \"q\":\n     \
    \       result = \"k\"\n        case \"r\":\n            result = \"k\"\n    \
    \    case \"s\":\n            result = \"s\"\n        case \"t\":\n          \
    \  result = \"t\"\n        case \"u\":\n            result = \"u\"\n        case\
    \ \"v\":\n            result = \"v\"\n        case \"w\":\n            result\
    \ = \"w\"\n        case \"x\":\n            result = \"x\"\n        case \"y\"\
    :\n            result = \"y\"\n        case \"z\":\n            result = \"z\"\
    \n        default:\n            result = letter\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\"\
    ) == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpqyvnhlbp.swift:69:22: error: cannot assign value of type 'Character'\
    \ to type 'String'\n            result = letter\n                     ^~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n            result\
    \ += \"A\"\n        case \"e\":\n            result += \"E\"\n        case \"\
    i\":\n            result += \"I\"\n        case \"o\":\n            result +=\
    \ \"O\"\n        case \"u\":\n            result += \"U\"\n        default:\n\
    \            result += letter\n        }\n    }\n    for vowel in \"AEIOU\" {\n\
    \        let index = result.index(of: vowel)\n        let replacement = result.index(index,\
    \ offsetBy: 2)\n        let replacementLetter = result[replacement]\n        result\
    \ = result.replacingCharacters(in: Range(uncheckedBounds: (index, replacement)),\
    \ with: replacementLetter)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpnte1jylq.swift:27:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += letter\n         \
    \             ^\n/tmp/tmpnte1jylq.swift:31:28: warning: 'index(of:)' is deprecated:\
    \ renamed to 'firstIndex(of:)'\n        let index = result.index(of: vowel)\n\
    \                           ^\n/tmp/tmpnte1jylq.swift:31:28: note: use 'firstIndex(of:)'\
    \ instead\n        let index = result.index(of: vowel)\n                     \
    \      ^~~~~\n                           firstIndex\n/tmp/tmpnte1jylq.swift:32:40:\
    \ error: value of optional type 'String.Index?' must be unwrapped to a value of\
    \ type 'String.Index'\n        let replacement = result.index(index, offsetBy:\
    \ 2)\n                                       ^\n/tmp/tmpnte1jylq.swift:32:40:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        let replacement = result.index(index, offsetBy: 2)\n        \
    \                               ^\n                                          \
    \   ?? <#default value#>\n/tmp/tmpnte1jylq.swift:32:40: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n        let replacement\
    \ = result.index(index, offsetBy: 2)\n                                       ^\n\
    \                                            !\n/tmp/tmpnte1jylq.swift:34:25:\
    \ error: value of type 'String' has no member 'replacingCharacters'\n        result\
    \ = result.replacingCharacters(in: Range(uncheckedBounds: (index, replacement)),\
    \ with: replacementLetter)\n                 ~~~~~~ ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpnte1jylq.swift:34:72:\
    \ error: tuple type '(String.Index?, String.Index)' is not convertible to tuple\
    \ type '(lower: String.Index, upper: String.Index)'\n        result = result.replacingCharacters(in:\
    \ Range(uncheckedBounds: (index, replacement)), with: replacementLetter)\n   \
    \                                                                    ^\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)!\n        let replacement\
    \ = alphabet[index + 2]\n        result += String(letter).replacingOccurrences(of:\
    \ vowel, with: replacement)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmphl1lkr80.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)!\n                    ^~~~~~~~\n\
    /tmp/tmphl1lkr80.swift:16:27: error: cannot find 'alphabet' in scope\n       \
    \ let replacement = alphabet[index + 2]\n                          ^~~~~~~~\n\
    /tmp/tmphl1lkr80.swift:17:59: error: cannot find 'vowel' in scope\n        result\
    \ += String(letter).replacingOccurrences(of: vowel, with: replacement)\n     \
    \                                                     ^~~~~\n/tmp/tmphl1lkr80.swift:17:34:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ result += String(letter).replacingOccurrences(of: vowel, with: replacement)\n\
    \                  ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for char in\
    \ message {\n        let index = english.index(of: char)\n        let nextIndex\
    \ = english.index(of: char, offsetBy: index + 1)\n        if index != nextIndex\
    \ {\n            result += swapCase(char)\n        } else {\n            result\
    \ += char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"\
    Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpq0tm3tcd.swift:15:21: error: cannot find 'english' in scope\n \
    \       let index = english.index(of: char)\n                    ^~~~~~~\n/tmp/tmpq0tm3tcd.swift:16:25:\
    \ error: cannot find 'english' in scope\n        let nextIndex = english.index(of:\
    \ char, offsetBy: index + 1)\n                        ^~~~~~~\n/tmp/tmpq0tm3tcd.swift:18:23:\
    \ error: cannot find 'swapCase' in scope\n            result += swapCase(char)\n\
    \                      ^~~~~~~~\n/tmp/tmpq0tm3tcd.swift:20:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n            result\
    \ += \"A\"\n        case \"b\":\n            result += \"B\"\n        case \"\
    c\":\n            result += \"C\"\n        case \"d\":\n            result +=\
    \ \"D\"\n        case \"e\":\n            result += \"E\"\n        case \"f\"\
    :\n            result += \"F\"\n        case \"g\":\n            result += \"\
    G\"\n        case \"h\":\n            result += \"H\"\n        case \"i\":\n \
    \           result += \"I\"\n        case \"j\":\n            result += \"J\"\n\
    \        case \"k\":\n            result += \"K\"\n        case \"l\":\n     \
    \       result += \"L\"\n        case \"m\":\n            result += \"M\"\n  \
    \      case \"n\":\n            result += \"N\"\n        case \"o\":\n       \
    \     result += \"O\"\n        case \"p\":\n            result += \"P\"\n    \
    \    case \"q\":\n            result += \"Q\"\n        case \"r\":\n         \
    \   result += \"R\"\n        case \"s\":\n            result += \"S\"\n      \
    \  case \"t\":\n            result += \"T\"\n        case \"u\":\n           \
    \ result += \"U\"\n        case \"v\":\n            result += \"V\"\n        case\
    \ \"w\":\n            result += \"W\"\n        case \"x\":\n            result\
    \ += \"X\"\n        case \"y\":\n            result += \"Y\"\n        case \"\
    z\":\n            result += \"Z\"\n        default:\n            result += letter\n\
    \        }\n    }\n    for vowel in \"aeiou\" {\n        switch vowel {\n    \
    \    case \"a\":\n            result += \"A\"\n        case \"e\":\n         \
    \   result += \"E\"\n        case \"i\":\n            result += \"I\"\n      \
    \  case \"o\":\n            result += \"O\"\n        case \"u\":\n           \
    \ result += \"U\"\n        case \"y\":\n            result += \"Y\"\n        default:\n\
    \            result += vowel\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpgb4kj0mv.swift:69:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += letter\n         \
    \             ^\n/tmp/tmpgb4kj0mv.swift:87:23: error: cannot convert value of\
    \ type 'Character' to expected argument type 'String'\n            result += vowel\n\
    \                      ^\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)!\n        let nextLetter\
    \ = alphabet[index + 1]\n        if letter.isUppercase {\n            result +=\
    \ nextLetter\n        } else {\n            result += letter\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encode(message: \"\
    TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpgimfbfq3.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)!\n                    ^~~~~~~~\n\
    /tmp/tmpgimfbfq3.swift:16:26: error: cannot find 'alphabet' in scope\n       \
    \ let nextLetter = alphabet[index + 1]\n                         ^~~~~~~~\n/tmp/tmpgimfbfq3.swift:20:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += String(letter)\n\
    \        } else {\n            result += String(letter).swapCase()\n        }\n\
    \    }\n    for vowel in \"AEIOUaeiou\" {\n        let index = message.indexOf(vowel)\n\
    \        if index != nil {\n            let vowelIndex = index!\n            let\
    \ vowelCount = message.countElements(of: vowel)\n            let vowelIndex =\
    \ vowelIndex + vowelCount\n            let vowelIndex = vowelIndex % 26\n    \
    \        let vowel = String(vowel)\n            result += String(vowel)\n    \
    \        result += String(vowel)\n            result += String(vowelIndex)\n \
    \       }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp4cqmotl2.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmp4cqmotl2.swift:18:38:\
    \ error: value of type 'String' has no member 'swapCase'\n            result +=\
    \ String(letter).swapCase()\n                      ~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmp4cqmotl2.swift:22:29:\
    \ error: value of type 'String' has no member 'indexOf'\n        let index = message.indexOf(vowel)\n\
    \                    ~~~~~~~ ^~~~~~~\n/tmp/tmp4cqmotl2.swift:25:38: error: value\
    \ of type 'String' has no member 'countElements'\n            let vowelCount =\
    \ message.countElements(of: vowel)\n                             ~~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)\n        let nextIndex\
    \ = alphabet.index(of: letter, offsetBy: index + 1)\n        if index != nextIndex\
    \ {\n            result += alphabet[index + alphabet.count - nextIndex - 1]\n\
    \        } else {\n            result += letter\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\"\
    ) == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp11rewb5a.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)\n                    ^~~~~~~~\n\
    /tmp/tmp11rewb5a.swift:16:25: error: cannot find 'alphabet' in scope\n       \
    \ let nextIndex = alphabet.index(of: letter, offsetBy: index + 1)\n          \
    \              ^~~~~~~~\n/tmp/tmp11rewb5a.swift:18:23: error: cannot find 'alphabet'\
    \ in scope\n            result += alphabet[index + alphabet.count - nextIndex\
    \ - 1]\n                      ^~~~~~~~\n/tmp/tmp11rewb5a.swift:18:40: error: cannot\
    \ find 'alphabet' in scope\n            result += alphabet[index + alphabet.count\
    \ - nextIndex - 1]\n                                       ^~~~~~~~\n/tmp/tmp11rewb5a.swift:20:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += letter.swapCase()\n\
    \        } else {\n            result += letter\n        }\n    }\n    for vowel\
    \ in \"AEIOUaeiou\" {\n        let index = result.index(of: vowel)\n        let\
    \ replacement = result.index(index, offsetBy: 2)\n        let replacementLetter\
    \ = result[replacement]\n        result += replacementLetter\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\"\
    ) == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpmvufv9uq.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmpmvufv9uq.swift:16:30:\
    \ error: value of type 'Character' has no member 'swapCase'\n            result\
    \ += letter.swapCase()\n                      ~~~~~~ ^~~~~~~~\n/tmp/tmpmvufv9uq.swift:18:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n/tmp/tmpmvufv9uq.swift:22:28:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ index = result.index(of: vowel)\n                           ^\n/tmp/tmpmvufv9uq.swift:22:28:\
    \ note: use 'firstIndex(of:)' instead\n        let index = result.index(of: vowel)\n\
    \                           ^~~~~\n                           firstIndex\n/tmp/tmpmvufv9uq.swift:23:40:\
    \ error: value of optional type 'String.Index?' must be unwrapped to a value of\
    \ type 'String.Index'\n        let replacement = result.index(index, offsetBy:\
    \ 2)\n                                       ^\n/tmp/tmpmvufv9uq.swift:22:13:\
    \ note: short-circuit using 'guard' to exit this function early if the optional\
    \ value contains 'nil'\n        let index = result.index(of: vowel)\n        \
    \    ^\n        guard                               else { return <#default value#>\
    \ }\n/tmp/tmpmvufv9uq.swift:22:28: note: coalesce using '??' to provide a default\
    \ when the optional value contains 'nil'\n        let index = result.index(of:\
    \ vowel)\n                           ^\n                                     \
    \       ?? <#default value#>\n/tmp/tmpmvufv9uq.swift:22:28: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        let\
    \ index = result.index(of: vowel)\n                           ^\n            \
    \                               !\n/tmp/tmpmvufv9uq.swift:23:40: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \     let replacement = result.index(index, offsetBy: 2)\n                   \
    \                    ^\n                           "
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += letter.lowercased()\n\
    \        } else {\n            result += letter.uppercased()\n        }\n    }\n\
    \    for vowel in \"AEIOUaeiou\" {\n        let index = result.index(of: vowel)\n\
    \        if index != nil {\n            let vowelIndex = index! + 2\n        \
    \    if vowelIndex < result.count {\n                result += result[vowelIndex]\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpwvlkhupy.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmpwvlkhupy.swift:22:28:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ index = result.index(of: vowel)\n                           ^\n/tmp/tmpwvlkhupy.swift:22:28:\
    \ note: use 'firstIndex(of:)' instead\n        let index = result.index(of: vowel)\n\
    \                           ^~~~~\n                           firstIndex\n/tmp/tmpwvlkhupy.swift:24:35:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n            let vowelIndex = index! + 2\n                           \
    \       ^\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += String(letter).swapCase()\n\
    \        } else {\n            result += letter\n        }\n    }\n    for vowel\
    \ in \"aeiou\" {\n        let index = message.index(of: vowel)\n        let letter\
    \ = message[index! + 2]\n        result += String(letter).swapCase()\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encode(message: \"\
    TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp7tqysxgq.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmp7tqysxgq.swift:16:38:\
    \ error: value of type 'String' has no member 'swapCase'\n            result +=\
    \ String(letter).swapCase()\n                      ~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmp7tqysxgq.swift:18:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n/tmp/tmp7tqysxgq.swift:22:29:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ index = message.index(of: vowel)\n                            ^\n/tmp/tmp7tqysxgq.swift:22:29:\
    \ note: use 'firstIndex(of:)' instead\n        let index = message.index(of: vowel)\n\
    \                            ^~~~~\n                            firstIndex\n/tmp/tmp7tqysxgq.swift:23:35:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n        let letter = message[index! + 2]\n                          \
    \        ^\n/tmp/tmp7tqysxgq.swift:24:34: error: reference to member 'swapCase'\
    \ cannot be resolved without a contextual type\n        result += String(letter).swapCase()\n\
    \                                 ^\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n            result\
    \ = \"t\"\n        case \"e\":\n            result = \"h\"\n        case \"i\"\
    :\n            result = \"k\"\n        case \"o\":\n            result = \"g\"\
    \n        case \"u\":\n            result = \"s\"\n        case \"A\":\n     \
    \       result = \"T\"\n        case \"E\":\n            result = \"H\"\n    \
    \    case \"I\":\n            result = \"K\"\n        case \"O\":\n          \
    \  result = \"G\"\n        case \"U\":\n            result = \"S\"\n        default:\n\
    \            result = letter\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp4wx_b_bh.swift:37:22: error: cannot assign value of type 'Character'\
    \ to type 'String'\n            result = letter\n                     ^~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for char in\
    \ message {\n        let index = english.index(of: char)\n        let replacement\
    \ = english[index! + 2]\n        result += String(char).replacingOccurrences(of:\
    \ \"AEIOUaeiou\", with: replacement)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpg5sbmvwb.swift:15:21: error: cannot find 'english' in scope\n \
    \       let index = english.index(of: char)\n                    ^~~~~~~\n/tmp/tmpg5sbmvwb.swift:16:27:\
    \ error: cannot find 'english' in scope\n        let replacement = english[index!\
    \ + 2]\n                          ^~~~~~~\n/tmp/tmpg5sbmvwb.swift:17:32: error:\
    \ value of type 'String' has no member 'replacingOccurrences'\n        result\
    \ += String(char).replacingOccurrences(of: \"AEIOUaeiou\", with: replacement)\n\
    \                  ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n        case \"e\"\
    :\n        case \"i\":\n        case \"o\":\n        case \"u\":\n           \
    \ result += letter\n        default:\n            result += letter.swapCase()\n\
    \        }\n    }\n    for vowel in \"aeiou\" {\n        result += vowel.swapCase()\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpks_dgayw.swift:16:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"a\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpks_dgayw.swift:17:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"e\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmpks_dgayw.swift:18:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"i\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpks_dgayw.swift:19:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"o\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpks_dgayw.swift:21:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n/tmp/tmpks_dgayw.swift:23:30:\
    \ error: value of type 'Character' has no member 'swapCase'\n            result\
    \ += letter.swapCase()\n                      ~~~~~~ ^~~~~~~~\n/tmp/tmpks_dgayw.swift:27:25:\
    \ error: value of type 'Character' has no member 'swapCase'\n        result +=\
    \ vowel.swapCase()\n                  ~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += letter.lowercased()\n\
    \        } else {\n            result += letter.uppercased()\n        }\n    }\n\
    \    for vowel in \"AEIOUaeiou\" {\n        let index = result.index(of: vowel)\n\
    \        if index != nil {\n            let vowelIndex = index! + 2\n        \
    \    if vowelIndex < result.count {\n                result += result[vowelIndex]\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpwvlkhupy.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmpwvlkhupy.swift:22:28:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ index = result.index(of: vowel)\n                           ^\n/tmp/tmpwvlkhupy.swift:22:28:\
    \ note: use 'firstIndex(of:)' instead\n        let index = result.index(of: vowel)\n\
    \                           ^~~~~\n                           firstIndex\n/tmp/tmpwvlkhupy.swift:24:35:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n            let vowelIndex = index! + 2\n                           \
    \       ^\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += String(letter).swapCase()\n\
    \        } else {\n            result += String(letter)\n        }\n    }\n  \
    \  for vowel in \"aeiouAEIOU\" {\n        let index = message.index(of: vowel)\n\
    \        let nextIndex = message.index(of: vowel, offsetBy: index! + 1)\n    \
    \    if index != nil && nextIndex != nil {\n            result += String(message[index!]).swapCase()\n\
    \            result += String(message[nextIndex!])\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\"\
    ) == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp6p999j9o.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmp6p999j9o.swift:16:38:\
    \ error: value of type 'String' has no member 'swapCase'\n            result +=\
    \ String(letter).swapCase()\n                      ~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmp6p999j9o.swift:22:29:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ index = message.index(of: vowel)\n                            ^\n/tmp/tmp6p999j9o.swift:22:29:\
    \ note: use 'firstIndex(of:)' instead\n        let index = message.index(of: vowel)\n\
    \                            ^~~~~\n                            firstIndex\n/tmp/tmp6p999j9o.swift:23:33:\
    \ error: no exact matches in call to instance method 'index'\n        let nextIndex\
    \ = message.index(of: vowel, offsetBy: index! + 1)\n                         \
    \       ^\n/tmp/tmp6p999j9o.swift:23:33: note: candidate has partially matching\
    \ parameter list (String.Index, offsetBy: Int)\n        let nextIndex = message.index(of:\
    \ vowel, offsetBy: index! + 1)\n                                ^\n/tmp/tmp6p999j9o.swift:23:33:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int)\n        let nextIndex = message.index(of: vowel, offsetBy: index! + 1)\n\
    \                                ^\n/tmp/tmp6p999j9o.swift:23:33: note: candidate\
    \ has partially matching parameter list (of: String.Element)\n        let nextIndex\
    \ = message.index(of: vowel, offsetBy: index! + 1)\n                         \
    \       ^\n/tmp/tmp6p999j9o.swift:23:33: note: candidate has partially matching\
    \ parameter list (String.Index, offsetBy: Int)\n        let nextIndex = message.index(of:\
    \ vowel, offsetBy: index! + 1)\n                                ^\n/tmp/tmp6p999j9o.swift:23:65:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n        let nextIndex = message.index(of: vowel, offsetBy: index! + 1)\n\
    \                                                                ^\n/tmp/tmp6p999j9o.swift:25:47:\
    \ error: value of type 'String' "
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for char in\
    \ message {\n        switch char {\n        case 'A':\n            result += \"\
    A\"\n        case 'B':\n            result += \"B\"\n        case 'C':\n     \
    \       result += \"C\"\n        case 'D':\n            result += \"D\"\n    \
    \    case 'E':\n            result += \"E\"\n        case 'F':\n            result\
    \ += \"F\"\n        case 'G':\n            result += \"G\"\n        case 'H':\n\
    \            result += \"H\"\n        case 'I':\n            result += \"I\"\n\
    \        case 'J':\n            result += \"J\"\n        case 'K':\n         \
    \   result += \"K\"\n        case 'L':\n            result += \"L\"\n        case\
    \ 'M':\n            result += \"M\"\n        case 'N':\n            result +=\
    \ \"N\"\n        case 'O':\n            result += \"O\"\n        case 'P':\n \
    \           result += \"P\"\n        case 'Q':\n            result += \"Q\"\n\
    \        case 'R':\n            result += \"R\"\n        case 'S':\n         \
    \   result += \"S\"\n        case 'T':\n            result += \"T\"\n        case\
    \ 'U':\n            result += \"U\"\n        case 'V':\n            result +=\
    \ \"V\"\n        case 'W':\n            result += \"W\"\n        case 'X':\n \
    \           result += \"X\"\n        case 'Y':\n            result += \"Y\"\n\
    \        case 'Z':\n            result += \"Z\"\n        case 'a':\n         \
    \   result += \"a\"\n        case 'b':\n            result += \"b\"\n        case\
    \ 'c':\n            result += \"c\"\n        case 'd':\n            result +=\
    \ \"d\"\n        case 'e':\n            result += \"e\"\n        case 'f':\n \
    \           result += \"f\"\n        case 'g':\n            result += \"g\"\n\
    \        case 'h':\n            result += \"h\"\n        case 'i':\n         \
    \   result += \"i\"\n        case 'j':\n            result += \"j\"\n        case\
    \ 'k':\n            result += \"k\"\n        case 'l':\n            result +=\
    \ \"l\"\n        case 'm':\n            result += \"m\"\n        case 'n':\n \
    \           result += \"n\"\n        case 'o':\n            result += \"o\"\n\
    \        case 'p':\n            result += \"p\"\n        case 'q':\n         \
    \   result += \"q\"\n        case 'r':\n            result += \"r\"\n        case\
    \ 's':\n            result += \"s\"\n        case 't':\n            result +=\
    \ \"t\"\n        case 'u':\n            result += \"u\"\n        case 'v':\n \
    \           result += \"v\"\n        case 'w':\n            result += \"w\"\n\
    \        case 'x':\n            result += \"x\"\n        case 'y':\n         \
    \   result += \"y\"\n        case '\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpm274hhh3.swift:16:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'A':\n             ^~~\n             \"A\"\n/tmp/tmpm274hhh3.swift:18:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'B':\n   \
    \          ^~~\n             \"B\"\n/tmp/tmpm274hhh3.swift:20:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'C':\n             ^~~\n      \
    \       \"C\"\n/tmp/tmpm274hhh3.swift:22:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'D':\n             ^~~\n             \"D\"\n/tmp/tmpm274hhh3.swift:24:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'E':\n   \
    \          ^~~\n             \"E\"\n/tmp/tmpm274hhh3.swift:26:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'F':\n             ^~~\n      \
    \       \"F\"\n/tmp/tmpm274hhh3.swift:28:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'G':\n             ^~~\n             \"G\"\n/tmp/tmpm274hhh3.swift:30:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'H':\n   \
    \          ^~~\n             \"H\"\n/tmp/tmpm274hhh3.swift:32:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'I':\n             ^~~\n      \
    \       \"I\"\n/tmp/tmpm274hhh3.swift:34:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'J':\n             ^~~\n             \"J\"\n/tmp/tmpm274hhh3.swift:36:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'K':\n   \
    \          ^~~\n             \"K\"\n/tmp/tmpm274hhh3.swift:38:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'L':\n             ^~~\n      \
    \       \"L\"\n/tmp/tmpm274hhh3.swift:40:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'M':\n             ^~~\n             \"M\"\n/tmp/tmpm274hhh3.swift:42:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'N':\n   \
    \          ^~~\n             \"N\"\n/tmp/tmpm274hhh3.swift:44:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'O':\n             ^~~\n      \
    \       \"O\"\n/tmp/tmpm274hhh3.swift:46:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n        case \"e\"\
    :\n        case \"i\":\n        case \"o\":\n        case \"u\":\n           \
    \ result += letter\n        default:\n            result += letter.swapCase()\n\
    \        }\n    }\n    for letter in result {\n        switch letter {\n     \
    \   case \"A\":\n        case \"E\":\n        case \"I\":\n        case \"O\"\
    :\n        case \"U\":\n            result += letter\n        default:\n     \
    \       result += letter.swapCase()\n        }\n    }\n    for letter in result\
    \ {\n        switch letter {\n        case \"a\":\n        case \"e\":\n     \
    \   case \"i\":\n        case \"o\":\n        case \"u\":\n            result\
    \ += letter\n        default:\n            result += letter.swapCase()\n     \
    \   }\n    }\n    for letter in result {\n        switch letter {\n        case\
    \ \"A\":\n        case \"E\":\n        case \"I\":\n        case \"O\":\n    \
    \    case \"U\":\n            result += letter\n        default:\n           \
    \ result += letter.swapCase()\n        }\n    }\n    for letter in result {\n\
    \        switch letter {\n        case \"a\":\n        case \"e\":\n        case\
    \ \"i\":\n        case \"o\":\n        case \"u\":\n            result += letter\n\
    \        default:\n            result += letter.swapCase()\n        }\n    }\n\
    \    for letter in result {\n        switch letter {\n        case \"A\":\n  \
    \      case \"E\":\n        case \"I\":\n        case \"O\":\n        case \"\
    U\":\n            result += letter\n        default:\n            result += letter.swapCase()\n\
    \        }\n    }\n    for letter in result {\n        switch letter {\n     \
    \   case \"a\":\n        case \"e\":\n        case \"i\":\n        case \"o\"\
    :\n        case \"u\":\n            result += letter\n        default:\n     \
    \       result += letter.swapCase()\n        }\n    }\n    for letter in result\
    \ {\n        switch letter {\n        case \"A\":\n        case \"E\":\n     \
    \   case \"I\":\n        case \"O\":\n        case \"U\":\n            result\
    \ += letter\n        default:\n            result += letter.swapCase()\n     \
    \   }\n    }\n    for letter in result {\n        switch letter {\n        case\
    \ \"a\":\n        case \"e\":\n        case \"i\":\n        case \"o\":\n    \
    \    case \"u\":\n            result += letter\n        default:\n           \
    \ result += letter.swapCase()\n        }\n    }\n    for letter in result {\n\
    \        switch letter {\n        case \"A\":\n        case \"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp3zfti5fs.swift:16:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"a\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmp3zfti5fs.swift:17:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"e\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmp3zfti5fs.swift:18:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"i\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp3zfti5fs.swift:19:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"o\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp3zfti5fs.swift:28:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"A\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp3zfti5fs.swift:29:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"E\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp3zfti5fs.swift:30:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"I\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp3zfti5fs.swift:31:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"O\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp3zfti5fs.swift:40:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"a\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp3zfti5fs.swift:41:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"e\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp3zfti5fs.swift:42:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"i\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp3zfti5fs.swift:43:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"o\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp3zfti5fs.swift:52:9:\
    \ error: 'case' l"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)\n        let nextIndex\
    \ = alphabet.index(of: letter, offsetBy: index + 1)\n        if index != nextIndex\
    \ {\n            result += alphabet[index] + alphabet[nextIndex]\n        } else\
    \ {\n            result += letter\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp2mcq83u7.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)\n                    ^~~~~~~~\n\
    /tmp/tmp2mcq83u7.swift:16:25: error: cannot find 'alphabet' in scope\n       \
    \ let nextIndex = alphabet.index(of: letter, offsetBy: index + 1)\n          \
    \              ^~~~~~~~\n/tmp/tmp2mcq83u7.swift:18:23: error: cannot find 'alphabet'\
    \ in scope\n            result += alphabet[index] + alphabet[nextIndex]\n    \
    \                  ^~~~~~~~\n/tmp/tmp2mcq83u7.swift:18:41: error: cannot find\
    \ 'alphabet' in scope\n            result += alphabet[index] + alphabet[nextIndex]\n\
    \                                        ^~~~~~~~\n/tmp/tmp2mcq83u7.swift:20:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = english.index(of: letter)\n        let replacement\
    \ = english[index! + 2]\n        result += replacement\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpmve_hk14.swift:15:21: error: cannot find 'english' in scope\n \
    \       let index = english.index(of: letter)\n                    ^~~~~~~\n/tmp/tmpmve_hk14.swift:16:27:\
    \ error: cannot find 'english' in scope\n        let replacement = english[index!\
    \ + 2]\n                          ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n        case \"e\"\
    :\n        case \"i\":\n        case \"o\":\n        case \"u\":\n           \
    \ result += letter\n        default:\n            result += letter.swapCase()\n\
    \        }\n    }\n    for letter in result {\n        for vowel in vowels {\n\
    \            if letter == vowel {\n                result += vowel\n         \
    \   }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"\
    Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp5m0_y3yw.swift:16:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"a\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmp5m0_y3yw.swift:17:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"e\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmp5m0_y3yw.swift:18:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"i\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp5m0_y3yw.swift:19:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"o\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp5m0_y3yw.swift:21:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n/tmp/tmp5m0_y3yw.swift:23:30:\
    \ error: value of type 'Character' has no member 'swapCase'\n            result\
    \ += letter.swapCase()\n                      ~~~~~~ ^~~~~~~~\n/tmp/tmp5m0_y3yw.swift:27:22:\
    \ error: cannot find 'vowels' in scope\n        for vowel in vowels {\n      \
    \               ^~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for char in\
    \ message {\n        switch char {\n        case 'a':\n            result += \"\
    A\"\n        case 'b':\n            result += \"B\"\n        case 'c':\n     \
    \       result += \"C\"\n        case 'd':\n            result += \"D\"\n    \
    \    case 'e':\n            result += \"E\"\n        case 'f':\n            result\
    \ += \"F\"\n        case 'g':\n            result += \"G\"\n        case 'h':\n\
    \            result += \"H\"\n        case 'i':\n            result += \"I\"\n\
    \        case 'j':\n            result += \"J\"\n        case 'k':\n         \
    \   result += \"K\"\n        case 'l':\n            result += \"L\"\n        case\
    \ 'm':\n            result += \"M\"\n        case 'n':\n            result +=\
    \ \"N\"\n        case 'o':\n            result += \"O\"\n        case 'p':\n \
    \           result += \"P\"\n        case 'q':\n            result += \"Q\"\n\
    \        case 'r':\n            result += \"R\"\n        case 's':\n         \
    \   result += \"S\"\n        case 't':\n            result += \"T\"\n        case\
    \ 'u':\n            result += \"U\"\n        case 'v':\n            result +=\
    \ \"V\"\n        case 'w':\n            result += \"W\"\n        case 'x':\n \
    \           result += \"X\"\n        case 'y':\n            result += \"Y\"\n\
    \        case 'z':\n            result += \"Z\"\n        case 'A':\n         \
    \   result += \"a\"\n        case 'B':\n            result += \"b\"\n        case\
    \ 'C':\n            result += \"c\"\n        case 'D':\n            result +=\
    \ \"d\"\n        case 'E':\n            result += \"e\"\n        case 'F':\n \
    \           result += \"f\"\n        case 'G':\n            result += \"g\"\n\
    \        case 'H':\n            result += \"h\"\n        case 'I':\n         \
    \   result += \"i\"\n        case 'J':\n            result += \"j\"\n        case\
    \ 'K':\n            result += \"k\"\n        case 'L':\n            result +=\
    \ \"l\"\n        case 'M':\n            result += \"m\"\n        case 'N':\n \
    \           result += \"n\"\n        case 'O':\n            result += \"o\"\n\
    \        case 'P':\n            result += \"p\"\n        case 'Q':\n         \
    \   result += \"q\"\n        case 'R':\n            result += \"r\"\n        case\
    \ 'S':\n            result += \"s\"\n        case 'T':\n            result +=\
    \ \"t\"\n        case 'U':\n            result += \"u\"\n        case 'V':\n \
    \           result += \"v\"\n        case 'W':\n            result += \"w\"\n\
    \        case 'X':\n            result += \"x\"\n        case 'Y':\n         \
    \   result += \"y\"\n        case '\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpgnt4e4ve.swift:16:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpgnt4e4ve.swift:18:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmpgnt4e4ve.swift:20:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmpgnt4e4ve.swift:22:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmpgnt4e4ve.swift:24:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpgnt4e4ve.swift:26:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmpgnt4e4ve.swift:28:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmpgnt4e4ve.swift:30:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmpgnt4e4ve.swift:32:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmpgnt4e4ve.swift:34:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmpgnt4e4ve.swift:36:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmpgnt4e4ve.swift:38:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmpgnt4e4ve.swift:40:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmpgnt4e4ve.swift:42:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmpgnt4e4ve.swift:44:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmpgnt4e4ve.swift:46:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = english.index(of: letter)\n        let replacement\
    \ = english[index! + 2]\n        result += english[index!] + replacement\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp5opf1ltg.swift:15:21: error: cannot find 'english' in scope\n \
    \       let index = english.index(of: letter)\n                    ^~~~~~~\n/tmp/tmp5opf1ltg.swift:16:27:\
    \ error: cannot find 'english' in scope\n        let replacement = english[index!\
    \ + 2]\n                          ^~~~~~~\n/tmp/tmp5opf1ltg.swift:17:19: error:\
    \ cannot find 'english' in scope\n        result += english[index!] + replacement\n\
    \                  ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)!\n        let replacement\
    \ = alphabet[index + 2]\n        result += String(letter).replacingOccurrences(of:\
    \ \"AEIOUaeiou\", with: replacement)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpiipglkpx.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)!\n                    ^~~~~~~~\n\
    /tmp/tmpiipglkpx.swift:16:27: error: cannot find 'alphabet' in scope\n       \
    \ let replacement = alphabet[index + 2]\n                          ^~~~~~~~\n\
    /tmp/tmpiipglkpx.swift:17:34: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        result += String(letter).replacingOccurrences(of: \"AEIOUaeiou\", with:\
    \ replacement)\n                  ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n        case \"e\"\
    :\n        case \"i\":\n        case \"o\":\n        case \"u\":\n           \
    \ result += letter\n        default:\n            result += letter.swapCase()\n\
    \        }\n    }\n    for vowel in \"aeiou\" {\n        result += vowel\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpxf9iogqw.swift:16:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"a\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpxf9iogqw.swift:17:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"e\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmpxf9iogqw.swift:18:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"i\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpxf9iogqw.swift:19:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"o\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpxf9iogqw.swift:21:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n/tmp/tmpxf9iogqw.swift:23:30:\
    \ error: value of type 'Character' has no member 'swapCase'\n            result\
    \ += letter.swapCase()\n                      ~~~~~~ ^~~~~~~~\n/tmp/tmpxf9iogqw.swift:27:19:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        result += vowel\n                  ^\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += String(letter).swapCase()\n\
    \        } else {\n            result += String(letter)\n        }\n    }\n  \
    \  for letter in result {\n        if letter.isLetter() {\n            if let\
    \ vowelIndex = vowels.indexOf(letter) {\n                let vowel = vowels[vowelIndex]\n\
    \                let nextVowelIndex = vowelIndex + 2\n                if nextVowelIndex\
    \ < vowels.count {\n                    result += vowels[nextVowelIndex]\n   \
    \             }\n            }\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpv42yat1l.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmpv42yat1l.swift:16:38:\
    \ error: value of type 'String' has no member 'swapCase'\n            result +=\
    \ String(letter).swapCase()\n                      ~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmpv42yat1l.swift:22:19:\
    \ error: cannot call value of non-function type 'Bool'\n        if letter.isLetter()\
    \ {\n                  ^       ~~\n                          \n/tmp/tmpv42yat1l.swift:23:33:\
    \ error: cannot find 'vowels' in scope\n            if let vowelIndex = vowels.indexOf(letter)\
    \ {\n                                ^~~~~~\n/tmp/tmpv42yat1l.swift:24:29: error:\
    \ cannot find 'vowels' in scope\n                let vowel = vowels[vowelIndex]\n\
    \                            ^~~~~~\n/tmp/tmpv42yat1l.swift:26:37: error: cannot\
    \ find 'vowels' in scope\n                if nextVowelIndex < vowels.count {\n\
    \                                    ^~~~~~\n/tmp/tmpv42yat1l.swift:27:31: error:\
    \ cannot find 'vowels' in scope\n                    result += vowels[nextVowelIndex]\n\
    \                              ^~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)!\n        let replacement\
    \ = alphabet[index + 2]\n        result += String(letter).replacingOccurrences(of:\
    \ \"A\", with: replacement)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpfrbeb_za.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)!\n                    ^~~~~~~~\n\
    /tmp/tmpfrbeb_za.swift:16:27: error: cannot find 'alphabet' in scope\n       \
    \ let replacement = alphabet[index + 2]\n                          ^~~~~~~~\n\
    /tmp/tmpfrbeb_za.swift:17:34: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        result += String(letter).replacingOccurrences(of: \"A\", with: replacement)\n\
    \                  ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += letter\n   \
    \     } else {\n            result += letter.lowercased()\n        }\n    }\n\
    \    for letter in result {\n        if letter.isUpper() {\n            result\
    \ += letter.lowercased()\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpiie5nmw1.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmpiie5nmw1.swift:16:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n/tmp/tmpiie5nmw1.swift:22:19:\
    \ error: value of type 'Character' has no member 'isUpper'\n        if letter.isUpper()\
    \ {\n           ~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += letter\n   \
    \     } else {\n            result += letter.lowercased()\n        }\n    }\n\
    \    for letter in result {\n        if letter.isUpper() {\n            result\
    \ += letter.lowercased()\n        }\n    }\n    for letter in result {\n     \
    \   if letter.isUpper() {\n            result += letter.lowercased()\n       \
    \ }\n    }\n    for letter in result {\n        if letter.isUpper() {\n      \
    \      result += letter.lowercased()\n        }\n    }\n    for letter in result\
    \ {\n        if letter.isUpper() {\n            result += letter.lowercased()\n\
    \        }\n    }\n    for letter in result {\n        if letter.isUpper() {\n\
    \            result += letter.lowercased()\n        }\n    }\n    for letter in\
    \ result {\n        if letter.isUpper() {\n            result += letter.lowercased()\n\
    \        }\n    }\n    for letter in result {\n        if letter.isUpper() {\n\
    \            result += letter.lowercased()\n        }\n    }\n    for letter in\
    \ result {\n        if letter.isUpper() {\n            result += letter.lowercased()\n\
    \        }\n    }\n    for letter in result {\n        if letter.isUpper() {\n\
    \            result += letter.lowercased()\n        }\n    }\n    for letter in\
    \ result {\n        if letter.isUpper() {\n            result += letter.lowercased()\n\
    \        }\n    }\n    for letter in result {\n        if letter.isUpper() {\n\
    \            result += letter.lowercased()\n        }\n    }\n    for letter in\
    \ result {\n        if letter.isUpper() {\n            result += letter.lowercased()\n\
    \        }\n    }\n    for letter in result {\n        if letter.isUpper() {\n\
    \            result += letter.lowercased()\n        }\n    }\n    for letter in\
    \ result {\n        if letter.isUpper() {\n            result += letter.lowercased()\n\
    \        }\n    }\n    for letter in result {\n        if letter.isUpper() {\n\
    \            result += letter.lowercased()\n        }\n    }\n    for letter in\
    \ result {\n        if letter.isUpper() {\n            result += letter.lowercased()\n\
    \        }\n    }\n    for letter in result {\n        if letter.isUpper() {\n\
    \            result += letter.lowercased()\n        }\n    }\n    for letter in\
    \ result {\n        if letter.isUpper() {\n            result += letter.lowercased()\n\
    \        }\n    }\n    for letter in result {\n        if letter.isUpper() {\n\
    \            result += letter.lowercased()\n        }\n    }\n    for letter in\
    \ result {\n        if letter.isUpper() {\n            result += letter.lowercased()\n\
    \        }\n    }\n    for letter in result {\n        if letter.isUpper() {\n\
    \            result += letter.lowercased()\n\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"\
    Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp9mpx8_d6.swift:144:84: error: expected '}' at end of brace statement\n\
    assert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq\
    \ wRkTg\")\n                                                                 \
    \                  ^\n/tmp/tmp9mpx8_d6.swift:121:26: note: to match this opening\
    \ '{'\n    for letter in result {\n                         ^\n/tmp/tmp9mpx8_d6.swift:144:84:\
    \ error: expected '}' at end of brace statement\nassert(encode(message: \"I DoNt\
    \ KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")\n                  \
    \                                                                 ^\n/tmp/tmp9mpx8_d6.swift:12:40:\
    \ note: to match this opening '{'\nfunc encode(message: String) -> String {\n\
    \                                       ^\n/tmp/tmp9mpx8_d6.swift:15:19: error:\
    \ value of type 'Character' has no member 'isUpper'\n        if letter.isUpper()\
    \ {\n           ~~~~~~ ^~~~~~~\n/tmp/tmp9mpx8_d6.swift:16:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ += letter\n                      ^\n/tmp/tmp9mpx8_d6.swift:22:19: error: value\
    \ of type 'Character' has no member 'isUpper'\n        if letter.isUpper() {\n\
    \           ~~~~~~ ^~~~~~~\n/tmp/tmp9mpx8_d6.swift:27:19: error: value of type\
    \ 'Character' has no member 'isUpper'\n        if letter.isUpper() {\n       \
    \    ~~~~~~ ^~~~~~~\n/tmp/tmp9mpx8_d6.swift:32:19: error: value of type 'Character'\
    \ has no member 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n\
    /tmp/tmp9mpx8_d6.swift:37:19: error: value of type 'Character' has no member 'isUpper'\n\
    \        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmp9mpx8_d6.swift:42:19:\
    \ error: value of type 'Character' has no member 'isUpper'\n        if letter.isUpper()\
    \ {\n           ~~~~~~ ^~~~~~~\n/tmp/tmp9mpx8_d6.swift:47:19: error: value of\
    \ type 'Character' has no member 'isUpper'\n        if letter.isUpper() {\n  \
    \         ~~~~~~ ^~~~~~~\n/tmp/tmp9mpx8_d6.swift:52:19: error: value of type 'Character'\
    \ has no member 'isUpper'\n        if letter.isUpper() {\n           "
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n        case \"e\"\
    :\n        case \"i\":\n        case \"o\":\n        case \"u\":\n           \
    \ result += letter\n        default:\n            result += letter + String(letter).characters.reversed()[Int(letter)\
    \ - 1]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"\
    Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp89sv9o84.swift:16:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"a\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmp89sv9o84.swift:17:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"e\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmp89sv9o84.swift:18:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"i\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp89sv9o84.swift:19:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"o\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp89sv9o84.swift:21:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n/tmp/tmp89sv9o84.swift:23:13:\
    \ error: the compiler is unable to type-check this expression in reasonable time;\
    \ try breaking up the expression into distinct sub-expressions\n            result\
    \ += letter + String(letter).characters.reversed()[Int(letter) - 1]\n        \
    \    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824738
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += letter\n   \
    \     } else {\n            result += letter.lowercased()\n        }\n    }\n\
    \    for letter in result {\n        if letter == \"A\" {\n            result\
    \ += \"B\"\n        } else if letter == \"B\" {\n            result += \"A\"\n\
    \        } else if letter == \"C\" {\n            result += \"D\"\n        } else\
    \ if letter == \"D\" {\n            result += \"C\"\n        } else if letter\
    \ == \"E\" {\n            result += \"F\"\n        } else if letter == \"F\" {\n\
    \            result += \"E\"\n        } else if letter == \"G\" {\n          \
    \  result += \"H\"\n        } else if letter == \"H\" {\n            result +=\
    \ \"G\"\n        } else if letter == \"I\" {\n            result += \"J\"\n  \
    \      } else if letter == \"J\" {\n            result += \"I\"\n        } else\
    \ if letter == \"K\" {\n            result += \"L\"\n        } else if letter\
    \ == \"L\" {\n            result += \"K\"\n        } else if letter == \"M\" {\n\
    \            result += \"N\"\n        } else if letter == \"N\" {\n          \
    \  result += \"M\"\n        } else if letter == \"O\" {\n            result +=\
    \ \"P\"\n        } else if letter == \"P\" {\n            result += \"O\"\n  \
    \      } else if letter == \"Q\" {\n            result += \"R\"\n        } else\
    \ if letter == \"R\" {\n            result += \"Q\"\n        } else if letter\
    \ == \"S\" {\n            result += \"T\"\n        } else if letter == \"T\" {\n\
    \            result += \"S\"\n        } else if letter == \"U\" {\n          \
    \  result += \"V\"\n        } else if letter == \"V\" {\n            result +=\
    \ \"U\"\n        } else if letter == \"W\" {\n            result += \"X\"\n  \
    \      } else if letter == \"X\" {\n            result += \"W\"\n        } else\
    \ if letter == \"Y\" {\n            result += \"Z\"\n        } else if letter\
    \ == \"Z\" {\n            result += \"Y\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmphqhvr2z6.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmphqhvr2z6.swift:16:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for char in\
    \ message {\n        let index = english.index(of: char)\n        let replacement\
    \ = english[english.index(of: char, offsetBy: index! + 2)]\n        result +=\
    \ replacement\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp29nk7xaf.swift:15:21: error: cannot find 'english' in scope\n \
    \       let index = english.index(of: char)\n                    ^~~~~~~\n/tmp/tmp29nk7xaf.swift:16:27:\
    \ error: cannot find 'english' in scope\n        let replacement = english[english.index(of:\
    \ char, offsetBy: index! + 2)]\n                          ^~~~~~~\n/tmp/tmp29nk7xaf.swift:16:35:\
    \ error: cannot find 'english' in scope\n        let replacement = english[english.index(of:\
    \ char, offsetBy: index! + 2)]\n                                  ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)!\n        let replacement\
    \ = alphabet[(index + 1) % alphabet.count]\n        result += String(letter).replacingOccurrences(of:\
    \ letter, with: replacement)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp5tag3xj3.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)!\n                    ^~~~~~~~\n\
    /tmp/tmp5tag3xj3.swift:16:27: error: cannot find 'alphabet' in scope\n       \
    \ let replacement = alphabet[(index + 1) % alphabet.count]\n                 \
    \         ^~~~~~~~\n/tmp/tmp5tag3xj3.swift:16:50: error: cannot find 'alphabet'\
    \ in scope\n        let replacement = alphabet[(index + 1) % alphabet.count]\n\
    \                                                 ^~~~~~~~\n/tmp/tmp5tag3xj3.swift:17:34:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ result += String(letter).replacingOccurrences(of: letter, with: replacement)\n\
    \                  ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n            result\
    \ += \"t\"\n        case \"b\":\n            result += \"g\"\n        case \"\
    c\":\n            result += \"k\"\n        case \"d\":\n            result +=\
    \ \"s\"\n        case \"e\":\n            result += \"c\"\n        case \"f\"\
    :\n            result += \"g\"\n        case \"g\":\n            result += \"\
    h\"\n        case \"h\":\n            result += \"k\"\n        case \"i\":\n \
    \           result += \"k\"\n        case \"j\":\n            result += \"s\"\n\
    \        case \"k\":\n            result += \"c\"\n        case \"l\":\n     \
    \       result += \"g\"\n        case \"m\":\n            result += \"s\"\n  \
    \      case \"n\":\n            result += \"g\"\n        case \"o\":\n       \
    \     result += \"c\"\n        case \"p\":\n            result += \"h\"\n    \
    \    case \"q\":\n            result += \"k\"\n        case \"r\":\n         \
    \   result += \"k\"\n        case \"s\":\n            result += \"s\"\n      \
    \  case \"t\":\n            result += \"t\"\n        case \"u\":\n           \
    \ result += \"c\"\n        case \"v\":\n            result += \"g\"\n        case\
    \ \"w\":\n            result += \"k\"\n        case \"x\":\n            result\
    \ += \"k\"\n        case \"y\":\n            result += \"s\"\n        case \"\
    z\":\n            result += \"c\"\n        default:\n            result += letter\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpc7ozhpje.swift:69:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += letter\n         \
    \             ^\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n            result\
    \ += \"A\"\n        case \"b\":\n            result += \"B\"\n        case \"\
    c\":\n            result += \"C\"\n        case \"d\":\n            result +=\
    \ \"D\"\n        case \"e\":\n            result += \"E\"\n        case \"f\"\
    :\n            result += \"F\"\n        case \"g\":\n            result += \"\
    G\"\n        case \"h\":\n            result += \"H\"\n        case \"i\":\n \
    \           result += \"I\"\n        case \"j\":\n            result += \"J\"\n\
    \        case \"k\":\n            result += \"K\"\n        case \"l\":\n     \
    \       result += \"L\"\n        case \"m\":\n            result += \"M\"\n  \
    \      case \"n\":\n            result += \"N\"\n        case \"o\":\n       \
    \     result += \"O\"\n        case \"p\":\n            result += \"P\"\n    \
    \    case \"q\":\n            result += \"Q\"\n        case \"r\":\n         \
    \   result += \"R\"\n        case \"s\":\n            result += \"S\"\n      \
    \  case \"t\":\n            result += \"T\"\n        case \"u\":\n           \
    \ result += \"U\"\n        case \"v\":\n            result += \"V\"\n        case\
    \ \"w\":\n            result += \"W\"\n        case \"x\":\n            result\
    \ += \"X\"\n        case \"y\":\n            result += \"Y\"\n        case \"\
    z\":\n            result += \"Z\"\n        default:\n            result += letter\n\
    \        }\n    }\n    for letter in result {\n        switch letter {\n     \
    \   case \"A\":\n            result += \"a\"\n        case \"B\":\n          \
    \  result += \"b\"\n        case \"C\":\n            result += \"c\"\n       \
    \ case \"D\":\n            result += \"d\"\n        case \"E\":\n            result\
    \ += \"e\"\n        case \"F\":\n            result += \"f\"\n        case \"\
    G\":\n            result += \"g\"\n        case \"H\":\n            result +=\
    \ \"h\"\n        case \"I\":\n            result += \"i\"\n        case \"J\"\
    :\n            result += \"j\"\n        case \"K\":\n            result += \"\
    k\"\n        case \"L\":\n            result += \"l\"\n        case \"M\":\n \
    \           result += \"m\"\n        case \"N\":\n            result += \"n\"\n\
    \        case \"O\":\n            result += \"o\"\n        case \"P\":\n     \
    \       result += \"p\"\n        case \"Q\":\n            result += \"q\"\n  \
    \      case \"R\":\n            result += \"r\"\n        case \"S\":\n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpzzldxrd2.swift:110:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"S\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpzzldxrd2.swift:131:84: error: expected '}' at\
    \ end of brace statement\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\"\
    ) == \"k dQnT kNqW wHcT Tq wRkTg\")\n                                        \
    \                                           ^\n/tmp/tmpzzldxrd2.swift:72:26: note:\
    \ to match this opening '{'\n    for letter in result {\n                    \
    \     ^\n/tmp/tmpzzldxrd2.swift:131:84: error: expected '}' at end of brace statement\n\
    assert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq\
    \ wRkTg\")\n                                                                 \
    \                  ^\n/tmp/tmpzzldxrd2.swift:12:40: note: to match this opening\
    \ '{'\nfunc encode(message: String) -> String {\n                            \
    \           ^\n/tmp/tmpzzldxrd2.swift:69:23: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n            result += letter\n\
    \                      ^\n/tmp/tmpzzldxrd2.swift:73:9: error: switch must be exhaustive\n\
    \        switch letter {\n        ^\n/tmp/tmpzzldxrd2.swift:73:9: note: do you\
    \ want to add a default clause?\n        switch letter {\n        ^\n/tmp/tmpzzldxrd2.swift:115:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += letter.lowercased()\n\
    \        } else {\n            result += letter.uppercased()\n        }\n    }\n\
    \    for letter in result {\n        if letter.isUpper() {\n            result\
    \ += letter.lowercased()\n        } else {\n            result += letter.uppercased()\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpo9ucstmd.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmpo9ucstmd.swift:22:19:\
    \ error: value of type 'Character' has no member 'isUpper'\n        if letter.isUpper()\
    \ {\n           ~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n        case \"e\"\
    :\n        case \"i\":\n        case \"o\":\n        case \"u\":\n           \
    \ result += letter\n        default:\n            result += letter.lowercased()\n\
    \        }\n    }\n    for vowel in \"aeiou\" {\n        let index = result.index(of:\
    \ vowel)\n        if index != nil {\n            let replacement = result.index(before:\
    \ index!)\n            let replacementLetter = result[index! + 1]\n          \
    \  result = result.substring(to: replacement)\n            result += replacementLetter\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmphpluer4_.swift:16:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"a\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmphpluer4_.swift:17:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"e\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmphpluer4_.swift:18:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"i\":\n        ^~~~~~~~~\n                  break\n/tmp/tmphpluer4_.swift:19:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"o\":\n        ^~~~~~~~~\n                  break\n/tmp/tmphpluer4_.swift:21:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n/tmp/tmphpluer4_.swift:27:28:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ index = result.index(of: vowel)\n                           ^\n/tmp/tmphpluer4_.swift:27:28:\
    \ note: use 'firstIndex(of:)' instead\n        let index = result.index(of: vowel)\n\
    \                           ^~~~~\n                           firstIndex\n/tmp/tmphpluer4_.swift:30:49:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n            let replacementLetter = result[index! + 1]\n            \
    \                                    ^\n/tmp/tmphpluer4_.swift:31:29: error: value\
    \ of type 'String' has no member 'substring'\n            result = result.substring(to:\
    \ replacement)\n                     ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)\n        let replacement\
    \ = alphabet[index! + 2]\n        result += String(replacement)\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\"\
    ) == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpsiziwcb8.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)\n                    ^~~~~~~~\n\
    /tmp/tmpsiziwcb8.swift:16:27: error: cannot find 'alphabet' in scope\n       \
    \ let replacement = alphabet[index! + 2]\n                          ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)!\n        let replacement\
    \ = alphabet[(index + 1) % alphabet.count]\n        result += replacement\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp7p0u4s6s.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)!\n                    ^~~~~~~~\n\
    /tmp/tmp7p0u4s6s.swift:16:27: error: cannot find 'alphabet' in scope\n       \
    \ let replacement = alphabet[(index + 1) % alphabet.count]\n                 \
    \         ^~~~~~~~\n/tmp/tmp7p0u4s6s.swift:16:50: error: cannot find 'alphabet'\
    \ in scope\n        let replacement = alphabet[(index + 1) % alphabet.count]\n\
    \                                                 ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n            result\
    \ += \"A\"\n        case \"b\":\n            result += \"B\"\n        case \"\
    c\":\n            result += \"C\"\n        case \"d\":\n            result +=\
    \ \"D\"\n        case \"e\":\n            result += \"E\"\n        case \"f\"\
    :\n            result += \"F\"\n        case \"g\":\n            result += \"\
    G\"\n        case \"h\":\n            result += \"H\"\n        case \"i\":\n \
    \           result += \"I\"\n        case \"j\":\n            result += \"J\"\n\
    \        case \"k\":\n            result += \"K\"\n        case \"l\":\n     \
    \       result += \"L\"\n        case \"m\":\n            result += \"M\"\n  \
    \      case \"n\":\n            result += \"N\"\n        case \"o\":\n       \
    \     result += \"O\"\n        case \"p\":\n            result += \"P\"\n    \
    \    case \"q\":\n            result += \"Q\"\n        case \"r\":\n         \
    \   result += \"R\"\n        case \"s\":\n            result += \"S\"\n      \
    \  case \"t\":\n            result += \"T\"\n        case \"u\":\n           \
    \ result += \"U\"\n        case \"v\":\n            result += \"V\"\n        case\
    \ \"w\":\n            result += \"W\"\n        case \"x\":\n            result\
    \ += \"X\"\n        case \"y\":\n            result += \"Y\"\n        case \"\
    z\":\n            result += \"Z\"\n        case \"A\":\n            result +=\
    \ \"a\"\n        case \"B\":\n            result += \"b\"\n        case \"C\"\
    :\n            result += \"c\"\n        case \"D\":\n            result += \"\
    d\"\n        case \"E\":\n            result += \"e\"\n        case \"F\":\n \
    \           result += \"f\"\n        case \"G\":\n            result += \"g\"\n\
    \        case \"H\":\n            result += \"h\"\n        case \"I\":\n     \
    \       result += \"i\"\n        case \"J\":\n            result += \"j\"\n  \
    \      case \"K\":\n            result += \"k\"\n        case \"L\":\n       \
    \     result += \"l\"\n        case \"M\":\n            result += \"m\"\n    \
    \    case \"N\":\n            result += \"n\"\n        case \"O\":\n         \
    \   result += \"o\"\n        case \"P\":\n            result += \"p\"\n      \
    \  case \"Q\":\n            result += \"q\"\n        case \"R\":\n           \
    \ result += \"r\"\n        case \"S\":\n            result += \"s\"\n        case\
    \ \"T\":\n            result += \"t\"\n        case \"U\":\n            \n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp_dwjd4v7.swift:108:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"U\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmp_dwjd4v7.swift:129:84: error: expected '}' at\
    \ end of brace statement\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\"\
    ) == \"k dQnT kNqW wHcT Tq wRkTg\")\n                                        \
    \                                           ^\n/tmp/tmp_dwjd4v7.swift:14:27: note:\
    \ to match this opening '{'\n    for letter in message {\n                   \
    \       ^\n/tmp/tmp_dwjd4v7.swift:129:84: error: expected '}' at end of brace\
    \ statement\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT\
    \ kNqW wHcT Tq wRkTg\")\n                                                    \
    \                               ^\n/tmp/tmp_dwjd4v7.swift:12:40: note: to match\
    \ this opening '{'\nfunc encode(message: String) -> String {\n               \
    \                        ^\n/tmp/tmp_dwjd4v7.swift:15:9: error: switch must be\
    \ exhaustive\n        switch letter {\n        ^\n/tmp/tmp_dwjd4v7.swift:15:9:\
    \ note: do you want to add a default clause?\n        switch letter {\n      \
    \  ^\n/tmp/tmp_dwjd4v7.swift:113:6: error: operator functions can only be declared\
    \ at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n            result\
    \ += \"A\"\n        case \"e\":\n            result += \"E\"\n        case \"\
    i\":\n            result += \"I\"\n        case \"o\":\n            result +=\
    \ \"O\"\n        case \"u\":\n            result += \"U\"\n        default:\n\
    \            result += letter\n        }\n    }\n    for letter in result {\n\
    \        switch letter {\n        case \"A\":\n            result += \"a\"\n \
    \       case \"E\":\n            result += \"e\"\n        case \"I\":\n      \
    \      result += \"i\"\n        case \"O\":\n            result += \"o\"\n   \
    \     case \"U\":\n            result += \"u\"\n        default:\n           \
    \ result += letter\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmphlvp_2sj.swift:27:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += letter\n         \
    \             ^\n/tmp/tmphlvp_2sj.swift:43:23: error: cannot convert value of\
    \ type 'Character' to expected argument type 'String'\n            result += letter\n\
    \                      ^\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += letter.lowercased()\n\
    \        } else {\n            result += letter.uppercased()\n        }\n    }\n\
    \    for vowel in \"AEIOUaeiou\" {\n        let index = result.indexOf(vowel)\n\
    \        if index != -1 {\n            let two = result.index(before: index)\n\
    \            let three = result.index(before: two, offsetBy: 2)\n            let\
    \ replacement = result.substring(two, three)\n            result = result.replacingOccurrences(of:\
    \ vowel, with: replacement)\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp4l_fpogv.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmp4l_fpogv.swift:22:28:\
    \ error: value of type 'String' has no member 'indexOf'\n        let index = result.indexOf(vowel)\n\
    \                    ~~~~~~ ^~~~~~~\n/tmp/tmp4l_fpogv.swift:25:32: error: no exact\
    \ matches in call to instance method 'index'\n            let three = result.index(before:\
    \ two, offsetBy: 2)\n                               ^\n/tmp/tmp4l_fpogv.swift:25:32:\
    \ note: found candidate with type '(String.Index, Int) -> String.Index'\n    \
    \        let three = result.index(before: two, offsetBy: 2)\n                \
    \               ^\n/tmp/tmp4l_fpogv.swift:26:38: error: value of type 'String'\
    \ has no member 'substring'\n            let replacement = result.substring(two,\
    \ three)\n                              ~~~~~~ ^~~~~~~~~\n/tmp/tmp4l_fpogv.swift:27:29:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \     result = result.replacingOccurrences(of: vowel, with: replacement)\n   \
    \                  ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n            result\
    \ += \"A\"\n        case \"e\":\n            result += \"E\"\n        case \"\
    i\":\n            result += \"I\"\n        case \"o\":\n            result +=\
    \ \"O\"\n        case \"u\":\n            result += \"U\"\n        default:\n\
    \            result += letter\n        }\n    }\n    for vowel in \"aeiou\" {\n\
    \        result += vowel\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmprq1ptjw6.swift:27:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += letter\n         \
    \             ^\n/tmp/tmprq1ptjw6.swift:31:19: error: cannot convert value of\
    \ type 'Character' to expected argument type 'String'\n        result += vowel\n\
    \                  ^\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n            result\
    \ += \"A\"\n        case \"b\":\n            result += \"B\"\n        case \"\
    c\":\n            result += \"C\"\n        case \"d\":\n            result +=\
    \ \"D\"\n        case \"e\":\n            result += \"E\"\n        case \"f\"\
    :\n            result += \"F\"\n        case \"g\":\n            result += \"\
    G\"\n        case \"h\":\n            result += \"H\"\n        case \"i\":\n \
    \           result += \"I\"\n        case \"j\":\n            result += \"J\"\n\
    \        case \"k\":\n            result += \"K\"\n        case \"l\":\n     \
    \       result += \"L\"\n        case \"m\":\n            result += \"M\"\n  \
    \      case \"n\":\n            result += \"N\"\n        case \"o\":\n       \
    \     result += \"O\"\n        case \"p\":\n            result += \"P\"\n    \
    \    case \"q\":\n            result += \"Q\"\n        case \"r\":\n         \
    \   result += \"R\"\n        case \"s\":\n            result += \"S\"\n      \
    \  case \"t\":\n            result += \"T\"\n        case \"u\":\n           \
    \ result += \"U\"\n        case \"v\":\n            result += \"V\"\n        case\
    \ \"w\":\n            result += \"W\"\n        case \"x\":\n            result\
    \ += \"X\"\n        case \"y\":\n            result += \"Y\"\n        case \"\
    z\":\n            result += \"Z\"\n        case \"A\":\n            result +=\
    \ \"a\"\n        case \"B\":\n            result += \"b\"\n        case \"C\"\
    :\n            result += \"c\"\n        case \"D\":\n            result += \"\
    d\"\n        case \"E\":\n            result += \"e\"\n        case \"F\":\n \
    \           result += \"f\"\n        case \"G\":\n            result += \"g\"\n\
    \        case \"H\":\n            result += \"h\"\n        case \"I\":\n     \
    \       result += \"i\"\n        case \"J\":\n            result += \"j\"\n  \
    \      case \"K\":\n            result += \"k\"\n        case \"L\":\n       \
    \     result += \"l\"\n        case \"M\":\n            result += \"m\"\n    \
    \    case \"N\":\n            result += \"n\"\n        case \"O\":\n         \
    \   result += \"o\"\n        case \"P\":\n            result += \"p\"\n      \
    \  case \"Q\":\n            result += \"q\"\n        case \"R\":\n           \
    \ result += \"r\"\n        case \"S\":\n            result += \"s\"\n        case\
    \ \"T\":\n            result += \"t\"\n        case \"U\":\n            \n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp_dwjd4v7.swift:108:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"U\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmp_dwjd4v7.swift:129:84: error: expected '}' at\
    \ end of brace statement\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\"\
    ) == \"k dQnT kNqW wHcT Tq wRkTg\")\n                                        \
    \                                           ^\n/tmp/tmp_dwjd4v7.swift:14:27: note:\
    \ to match this opening '{'\n    for letter in message {\n                   \
    \       ^\n/tmp/tmp_dwjd4v7.swift:129:84: error: expected '}' at end of brace\
    \ statement\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT\
    \ kNqW wHcT Tq wRkTg\")\n                                                    \
    \                               ^\n/tmp/tmp_dwjd4v7.swift:12:40: note: to match\
    \ this opening '{'\nfunc encode(message: String) -> String {\n               \
    \                        ^\n/tmp/tmp_dwjd4v7.swift:15:9: error: switch must be\
    \ exhaustive\n        switch letter {\n        ^\n/tmp/tmp_dwjd4v7.swift:15:9:\
    \ note: do you want to add a default clause?\n        switch letter {\n      \
    \  ^\n/tmp/tmp_dwjd4v7.swift:113:6: error: operator functions can only be declared\
    \ at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n            result\
    \ += \"A\"\n        case \"e\":\n            result += \"E\"\n        case \"\
    i\":\n            result += \"I\"\n        case \"o\":\n            result +=\
    \ \"O\"\n        case \"u\":\n            result += \"U\"\n        default:\n\
    \            result += letter\n        }\n    }\n    for vowel in \"aeiou\" {\n\
    \        if let index = result.index(of: vowel) {\n            let twoLettersBefore\
    \ = result[index - 2]\n            let twoLettersAfter = result[index + 2]\n \
    \           if twoLettersBefore == vowel && twoLettersAfter == vowel {\n     \
    \           result += vowel\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpuh8cy3t0.swift:27:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += letter\n         \
    \             ^\n/tmp/tmpuh8cy3t0.swift:31:31: warning: 'index(of:)' is deprecated:\
    \ renamed to 'firstIndex(of:)'\n        if let index = result.index(of: vowel)\
    \ {\n                              ^\n/tmp/tmpuh8cy3t0.swift:31:31: note: use\
    \ 'firstIndex(of:)' instead\n        if let index = result.index(of: vowel) {\n\
    \                              ^~~~~\n                              firstIndex\n\
    /tmp/tmpuh8cy3t0.swift:32:43: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n            let twoLettersBefore = result[index\
    \ - 2]\n                                          ^\n/tmp/tmpuh8cy3t0.swift:33:42:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n            let twoLettersAfter = result[index + 2]\n               \
    \                          ^\n/tmp/tmpuh8cy3t0.swift:35:27: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n             \
    \   result += vowel\n                          ^\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)\n        let replacement\
    \ = alphabet[(index + 2) % 26]\n        result += replacement\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\"\
    ) == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp08cswh9i.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)\n                    ^~~~~~~~\n\
    /tmp/tmp08cswh9i.swift:16:27: error: cannot find 'alphabet' in scope\n       \
    \ let replacement = alphabet[(index + 2) % 26]\n                          ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for char in\
    \ message {\n        switch char {\n        case 'a':\n            result += \"\
    A\"\n        case 'b':\n            result += \"B\"\n        case 'c':\n     \
    \       result += \"C\"\n        case 'd':\n            result += \"D\"\n    \
    \    case 'e':\n            result += \"E\"\n        case 'f':\n            result\
    \ += \"F\"\n        case 'g':\n            result += \"G\"\n        case 'h':\n\
    \            result += \"H\"\n        case 'i':\n            result += \"I\"\n\
    \        case 'j':\n            result += \"J\"\n        case 'k':\n         \
    \   result += \"K\"\n        case 'l':\n            result += \"L\"\n        case\
    \ 'm':\n            result += \"M\"\n        case 'n':\n            result +=\
    \ \"N\"\n        case 'o':\n            result += \"O\"\n        case 'p':\n \
    \           result += \"P\"\n        case 'q':\n            result += \"Q\"\n\
    \        case 'r':\n            result += \"R\"\n        case 's':\n         \
    \   result += \"S\"\n        case 't':\n            result += \"T\"\n        case\
    \ 'u':\n            result += \"U\"\n        case 'v':\n            result +=\
    \ \"V\"\n        case 'w':\n            result += \"W\"\n        case 'x':\n \
    \           result += \"X\"\n        case 'y':\n            result += \"Y\"\n\
    \        case 'z':\n            result += \"Z\"\n        case 'A':\n         \
    \   result += \"a\"\n        case 'B':\n            result += \"b\"\n        case\
    \ 'C':\n            result += \"c\"\n        case 'D':\n            result +=\
    \ \"d\"\n        case 'E':\n            result += \"e\"\n        case 'F':\n \
    \           result += \"f\"\n        case 'G':\n            result += \"g\"\n\
    \        case 'H':\n            result += \"h\"\n        case 'I':\n         \
    \   result += \"i\"\n        case 'J':\n            result += \"j\"\n        case\
    \ 'K':\n            result += \"k\"\n        case 'L':\n            result +=\
    \ \"l\"\n        case 'M':\n            result += \"m\"\n        case 'N':\n \
    \           result += \"n\"\n        case 'O':\n            result += \"o\"\n\
    \        case 'P':\n            result += \"p\"\n        case 'Q':\n         \
    \   result += \"q\"\n        case 'R':\n            result += \"r\"\n        case\
    \ 'S':\n            result += \"s\"\n        case 'T':\n            result +=\
    \ \"t\"\n        case 'U':\n            result += \"u\"\n        case 'V':\n \
    \           result += \"v\"\n        case 'W':\n            result += \"w\"\n\
    \        case 'X':\n            result += \"x\"\n        case 'Y':\n         \
    \   result += \"y\"\n        case '\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpgnt4e4ve.swift:16:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpgnt4e4ve.swift:18:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmpgnt4e4ve.swift:20:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmpgnt4e4ve.swift:22:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmpgnt4e4ve.swift:24:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpgnt4e4ve.swift:26:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmpgnt4e4ve.swift:28:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmpgnt4e4ve.swift:30:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmpgnt4e4ve.swift:32:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmpgnt4e4ve.swift:34:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmpgnt4e4ve.swift:36:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmpgnt4e4ve.swift:38:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmpgnt4e4ve.swift:40:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmpgnt4e4ve.swift:42:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmpgnt4e4ve.swift:44:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmpgnt4e4ve.swift:46:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for char in\
    \ message {\n        switch char {\n        case 'a':\n            result += \"\
    A\"\n        case 'b':\n            result += \"B\"\n        case 'c':\n     \
    \       result += \"C\"\n        case 'd':\n            result += \"D\"\n    \
    \    case 'e':\n            result += \"E\"\n        case 'f':\n            result\
    \ += \"F\"\n        case 'g':\n            result += \"G\"\n        case 'h':\n\
    \            result += \"H\"\n        case 'i':\n            result += \"I\"\n\
    \        case 'j':\n            result += \"J\"\n        case 'k':\n         \
    \   result += \"K\"\n        case 'l':\n            result += \"L\"\n        case\
    \ 'm':\n            result += \"M\"\n        case 'n':\n            result +=\
    \ \"N\"\n        case 'o':\n            result += \"O\"\n        case 'p':\n \
    \           result += \"P\"\n        case 'q':\n            result += \"Q\"\n\
    \        case 'r':\n            result += \"R\"\n        case 's':\n         \
    \   result += \"S\"\n        case 't':\n            result += \"T\"\n        case\
    \ 'u':\n            result += \"U\"\n        case 'v':\n            result +=\
    \ \"V\"\n        case 'w':\n            result += \"W\"\n        case 'x':\n \
    \           result += \"X\"\n        case 'y':\n            result += \"Y\"\n\
    \        case 'z':\n            result += \"Z\"\n        default:\n          \
    \  result += char\n        }\n    }\n    for char in result {\n        switch\
    \ char {\n        case 'A':\n            result += \"a\"\n        case 'B':\n\
    \            result += \"b\"\n        case 'C':\n            result += \"c\"\n\
    \        case 'D':\n            result += \"d\"\n        case 'E':\n         \
    \   result += \"e\"\n        case 'F':\n            result += \"f\"\n        case\
    \ 'G':\n            result += \"g\"\n        case 'H':\n            result +=\
    \ \"h\"\n        case 'I':\n            result += \"i\"\n        case 'J':\n \
    \           result += \"j\"\n        case 'K':\n            result += \"k\"\n\
    \        case 'L':\n            result += \"l\"\n        case 'M':\n         \
    \   result += \"m\"\n        case 'N':\n            result += \"n\"\n        case\
    \ 'O':\n            result += \"o\"\n        case 'P':\n            result +=\
    \ \"p\"\n        case 'Q':\n            result += \"q\"\n        case 'R':\n \
    \           result += \"r\"\n        case 'S':\n            result += \"s\"\n\
    \        case 'T':\n            result += \"t\"\n        case 'U':\n         \
    \   result += \"u\"\n        case 'V':\n            result += \"v\"\n        case\
    \ 'W':\n            result += \"w\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpsli9loaj.swift:16:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpsli9loaj.swift:18:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmpsli9loaj.swift:20:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmpsli9loaj.swift:22:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmpsli9loaj.swift:24:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpsli9loaj.swift:26:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmpsli9loaj.swift:28:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmpsli9loaj.swift:30:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmpsli9loaj.swift:32:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmpsli9loaj.swift:34:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmpsli9loaj.swift:36:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmpsli9loaj.swift:38:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmpsli9loaj.swift:40:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmpsli9loaj.swift:42:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmpsli9loaj.swift:44:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmpsli9loaj.swift:46:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n            result\
    \ = \"t\"\n        case \"e\":\n            result = \"h\"\n        case \"i\"\
    :\n            result = \"k\"\n        case \"o\":\n            result = \"g\"\
    \n        case \"u\":\n            result = \"s\"\n        case \"A\":\n     \
    \       result = \"T\"\n        case \"E\":\n            result = \"H\"\n    \
    \    case \"I\":\n            result = \"K\"\n        case \"O\":\n          \
    \  result = \"G\"\n        case \"U\":\n            result = \"S\"\n        default:\n\
    \            result = letter\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp4wx_b_bh.swift:37:22: error: cannot assign value of type 'Character'\
    \ to type 'String'\n            result = letter\n                     ^~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = english.index(of: letter)\n        let replacement\
    \ = english[english.index(of: letter, offsetBy: index)]\n        result += String(letter).replacingOccurrences(of:\
    \ replacement, with: replacement)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpgcyn77pd.swift:15:21: error: cannot find 'english' in scope\n \
    \       let index = english.index(of: letter)\n                    ^~~~~~~\n/tmp/tmpgcyn77pd.swift:16:27:\
    \ error: cannot find 'english' in scope\n        let replacement = english[english.index(of:\
    \ letter, offsetBy: index)]\n                          ^~~~~~~\n/tmp/tmpgcyn77pd.swift:16:35:\
    \ error: cannot find 'english' in scope\n        let replacement = english[english.index(of:\
    \ letter, offsetBy: index)]\n                                  ^~~~~~~\n/tmp/tmpgcyn77pd.swift:17:34:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ result += String(letter).replacingOccurrences(of: replacement, with: replacement)\n\
    \                  ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)!\n        let replacement\
    \ = alphabet[(index + 1)..<alphabet.count]\n        result += replacement\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpspx2opvn.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)!\n                    ^~~~~~~~\n\
    /tmp/tmpspx2opvn.swift:16:27: error: cannot find 'alphabet' in scope\n       \
    \ let replacement = alphabet[(index + 1)..<alphabet.count]\n                 \
    \         ^~~~~~~~\n/tmp/tmpspx2opvn.swift:16:50: error: cannot find 'alphabet'\
    \ in scope\n        let replacement = alphabet[(index + 1)..<alphabet.count]\n\
    \                                                 ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += letter.lowercased()\n\
    \        } else {\n            result += letter.uppercased()\n        }\n    }\n\
    \    for letter in result {\n        if letter.isUpper() {\n            result\
    \ += letter.lowercased()\n        } else {\n            result += letter.uppercased()\n\
    \        }\n    }\n    for letter in result {\n        if letter.isUpper() {\n\
    \            result += letter.lowercased()\n        } else {\n            result\
    \ += letter.uppercased()\n        }\n    }\n    for letter in result {\n     \
    \   if letter.isUpper() {\n            result += letter.lowercased()\n       \
    \ } else {\n            result += letter.uppercased()\n        }\n    }\n    for\
    \ letter in result {\n        if letter.isUpper() {\n            result += letter.lowercased()\n\
    \        } else {\n            result += letter.uppercased()\n        }\n    }\n\
    \    for letter in result {\n        if letter.isUpper() {\n            result\
    \ += letter.lowercased()\n        } else {\n            result += letter.uppercased()\n\
    \        }\n    }\n    for letter in result {\n        if letter.isUpper() {\n\
    \            result += letter.lowercased()\n        } else {\n            result\
    \ += letter.uppercased()\n        }\n    }\n    for letter in result {\n     \
    \   if letter.isUpper() {\n            result += letter.lowercased()\n       \
    \ } else {\n            result += letter.uppercased()\n        }\n    }\n    for\
    \ letter in result {\n        if letter.isUpper() {\n            result += letter.lowercased()\n\
    \        } else {\n            result += letter.uppercased()\n        }\n    }\n\
    \    for letter in result {\n        if letter.isUpper() {\n            result\
    \ += letter.lowercased()\n        } else {\n            result += letter.uppercased()\n\
    \        }\n    }\n    for letter in result {\n        if letter.isUpper() {\n\
    \            result += letter.lowercased()\n        } else {\n            result\
    \ += letter.uppercased()\n        }\n    }\n    for letter in result {\n     \
    \   if letter.isUpper() {\n            result += letter.lowercased()\n       \
    \ } else {\n            result += letter.uppercased()\n        }\n    }\n    for\
    \ letter in result {\n        if letter.isUpper() {\n            result += letter.lowercased()\n\
    \        } else {\n            result += letter.uppercased()\n        }\n    }\n\
    \    for letter in result {\n        if letter.isUpper() {\n            result\
    \ += letter.lowercased()\n        } else {\n            result += letter.uppercased()\n\
    \        }\n    }\n    for letter in result {\n        if letter.isUpper() {\n\
    \            result += letter.lowercased()\n        } else {\n            result\
    \ += letter.uppercased()\n        }\n    }\n    for letter in result {\n     \
    \   if letter.isUpper() {\n            result += letter.lowercased()\n       \
    \ } else {\n            result += letter.uppercased()\n\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpbudwvzqt.swift:144:84: error: expected '}' at end of brace statement\n\
    assert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq\
    \ wRkTg\")\n                                                                 \
    \                  ^\n/tmp/tmpbudwvzqt.swift:119:26: note: to match this opening\
    \ '{'\n    for letter in result {\n                         ^\n/tmp/tmpbudwvzqt.swift:144:84:\
    \ error: expected '}' at end of brace statement\nassert(encode(message: \"I DoNt\
    \ KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")\n                  \
    \                                                                 ^\n/tmp/tmpbudwvzqt.swift:12:40:\
    \ note: to match this opening '{'\nfunc encode(message: String) -> String {\n\
    \                                       ^\n/tmp/tmpbudwvzqt.swift:15:19: error:\
    \ value of type 'Character' has no member 'isUpper'\n        if letter.isUpper()\
    \ {\n           ~~~~~~ ^~~~~~~\n/tmp/tmpbudwvzqt.swift:22:19: error: value of\
    \ type 'Character' has no member 'isUpper'\n        if letter.isUpper() {\n  \
    \         ~~~~~~ ^~~~~~~\n/tmp/tmpbudwvzqt.swift:29:19: error: value of type 'Character'\
    \ has no member 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n\
    /tmp/tmpbudwvzqt.swift:36:19: error: value of type 'Character' has no member 'isUpper'\n\
    \        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmpbudwvzqt.swift:43:19:\
    \ error: value of type 'Character' has no member 'isUpper'\n        if letter.isUpper()\
    \ {\n           ~~~~~~ ^~~~~~~\n/tmp/tmpbudwvzqt.swift:50:19: error: value of\
    \ type 'Character' has no member 'isUpper'\n        if letter.isUpper() {\n  \
    \         ~~~~~~ ^~~~~~~\n/tmp/tmpbudwvzqt.swift:57:19: error: value of type 'Character'\
    \ has no member 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n\
    /tmp/tmpbudwvzqt.swift:64:19: error: value of type 'Character' has no member 'isUpper'\n\
    \        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmpbudwvzqt.swift:71:19:\
    \ error: value of type 'Character' has no member 'isUpper'\n        if letter.isUpper()\
    \ {\n           ~~~~~~ ^~~~~~~\n/tmp/tmp"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += letter\n   \
    \     } else {\n            result += letter.lowercased()\n        }\n    }\n\
    \    for vowel in \"aeiou\" {\n        result += vowel.lowercased()\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encode(message: \"\
    TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp39a_z0jh.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmp39a_z0jh.swift:16:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n            result\
    \ = \"t\"\n        case \"e\":\n            result = \"h\"\n        case \"i\"\
    :\n            result = \"k\"\n        case \"o\":\n            result = \"g\"\
    \n        case \"u\":\n            result = \"s\"\n        case \"A\":\n     \
    \       result = \"T\"\n        case \"E\":\n            result = \"H\"\n    \
    \    case \"I\":\n            result = \"K\"\n        case \"O\":\n          \
    \  result = \"G\"\n        case \"U\":\n            result = \"S\"\n        default:\n\
    \            result = letter\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp4wx_b_bh.swift:37:22: error: cannot assign value of type 'Character'\
    \ to type 'String'\n            result = letter\n                     ^~~~~~\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)\n        let replacement\
    \ = alphabet[index + 2]\n        result += String(letter).replacingOccurrences(of:\
    \ \"A\", with: replacement)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpe19satyq.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)\n                    ^~~~~~~~\n\
    /tmp/tmpe19satyq.swift:16:27: error: cannot find 'alphabet' in scope\n       \
    \ let replacement = alphabet[index + 2]\n                          ^~~~~~~~\n\
    /tmp/tmpe19satyq.swift:17:34: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        result += String(letter).replacingOccurrences(of: \"A\", with: replacement)\n\
    \                  ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for char in\
    \ message {\n        let index = english.index(of: char)\n        let replacement\
    \ = english[index! + 1]\n        result += english[index!] + replacement\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpbba9iojs.swift:15:21: error: cannot find 'english' in scope\n \
    \       let index = english.index(of: char)\n                    ^~~~~~~\n/tmp/tmpbba9iojs.swift:16:27:\
    \ error: cannot find 'english' in scope\n        let replacement = english[index!\
    \ + 1]\n                          ^~~~~~~\n/tmp/tmpbba9iojs.swift:17:19: error:\
    \ cannot find 'english' in scope\n        result += english[index!] + replacement\n\
    \                  ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)!\n        let replacement\
    \ = alphabet[(index + 1)..<alphabet.count]\n        result += replacement\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpspx2opvn.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)!\n                    ^~~~~~~~\n\
    /tmp/tmpspx2opvn.swift:16:27: error: cannot find 'alphabet' in scope\n       \
    \ let replacement = alphabet[(index + 1)..<alphabet.count]\n                 \
    \         ^~~~~~~~\n/tmp/tmpspx2opvn.swift:16:50: error: cannot find 'alphabet'\
    \ in scope\n        let replacement = alphabet[(index + 1)..<alphabet.count]\n\
    \                                                 ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = english.index(of: letter)\n        let nextIndex\
    \ = english.index(of: letter, offsetBy: index + 1)\n        if index != nil &&\
    \ nextIndex != nil {\n            let firstLetter = english[index!]\n        \
    \    let secondLetter = english[nextIndex!]\n            let firstIndex = english.index(of:\
    \ firstLetter)\n            let secondIndex = english.index(of: secondLetter)\n\
    \            if firstIndex != nil && secondIndex != nil {\n                let\
    \ firstVowel = english[firstIndex!]\n                let secondVowel = english[secondIndex!]\n\
    \                let firstIndex = english.index(of: firstVowel)\n            \
    \    let secondIndex = english.index(of: secondVowel)\n                if firstIndex\
    \ != nil && secondIndex != nil {\n                    let firstLetter = english[firstIndex!]\n\
    \                    let secondLetter = english[secondIndex!]\n              \
    \      let firstIndex = english.index(of: firstLetter)\n                    let\
    \ secondIndex = english.index(of: secondLetter)\n                    if firstIndex\
    \ != nil && secondIndex != nil {\n                        let firstLetter = english[firstIndex!]\n\
    \                        let secondLetter = english[secondIndex!]\n          \
    \              let firstIndex = english.index(of: firstLetter)\n             \
    \           let secondIndex = english.index(of: secondLetter)\n              \
    \          if firstIndex != nil && secondIndex != nil {\n                    \
    \        let firstLetter = english[firstIndex!]\n                            let\
    \ secondLetter = english[secondIndex!]\n                            let firstIndex\
    \ = english.index(of: firstLetter)\n                            let secondIndex\
    \ = english.index(of: secondLetter)\n                            if firstIndex\
    \ != nil && secondIndex != nil {\n                                let firstLetter\
    \ = english[firstIndex!]\n                                let secondLetter = english[secondIndex!]\n\
    \                                let firstIndex = english.index(of: firstLetter)\n\
    \                                let secondIndex = english.index(of: secondLetter)\n\
    \                                if firstIndex != nil && secondIndex != nil {\n\
    \                                    let firstLetter = english[firstIndex!]\n\
    \                                    let secondLetter = english[secondIndex!]\n\
    \                                    let firstIndex = english.index(of: firstLetter)\n\
    \                                    let secondIndex = english.index(of: secondLetter)\n\
    \                                    if firstIndex != nil && secondIndex != nil\
    \ {\n                                        let firstLetter = english[firstIndex!]\n\
    \                                        let secondLetter = english[secondIndex!]\n\
    \                                        let firstIndex = english.index(of: firstLetter)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpbs3ct2ki.swift:75:84: error: expected '}' at end of brace statement\n\
    assert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq\
    \ wRkTg\")\n                                                                 \
    \                  ^\n/tmp/tmpbs3ct2ki.swift:47:76: note: to match this opening\
    \ '{'\n                                if firstIndex != nil && secondIndex !=\
    \ nil {\n                                                                    \
    \       ^\n/tmp/tmpbs3ct2ki.swift:75:84: error: expected '}' at end of brace statement\n\
    assert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq\
    \ wRkTg\")\n                                                                 \
    \                  ^\n/tmp/tmpbs3ct2ki.swift:42:72: note: to match this opening\
    \ '{'\n                            if firstIndex != nil && secondIndex != nil\
    \ {\n                                                                       ^\n\
    /tmp/tmpbs3ct2ki.swift:75:84: error: expected '}' at end of brace statement\n\
    assert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq\
    \ wRkTg\")\n                                                                 \
    \                  ^\n/tmp/tmpbs3ct2ki.swift:37:68: note: to match this opening\
    \ '{'\n                        if firstIndex != nil && secondIndex != nil {\n\
    \                                                                   ^\n/tmp/tmpbs3ct2ki.swift:75:84:\
    \ error: expected '}' at end of brace statement\nassert(encode(message: \"I DoNt\
    \ KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")\n                  \
    \                                                                 ^\n/tmp/tmpbs3ct2ki.swift:32:64:\
    \ note: to match this opening '{'\n                    if firstIndex != nil &&\
    \ secondIndex != nil {\n                                                     \
    \          ^\n/tmp/tmpbs3ct2ki.swift:75:84: error: expected '}' at end of brace\
    \ statement\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT\
    \ kNqW wHcT Tq wRkTg\")\n                                                    \
    \                               ^\n/tmp/tm"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        var newLetter = letter\n        var vowels = \"AEIOUaeiou\"\
    \n        for vowel in vowels {\n            if letter == vowel {\n          \
    \      newLetter = vowels[vowels.indexOf(letter) + 1]\n            }\n       \
    \ }\n        result += newLetter\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpr_56fznf.swift:19:43: error: value of type 'String' has no member\
    \ 'indexOf'\n                newLetter = vowels[vowels.indexOf(letter) + 1]\n\
    \                                   ~~~~~~ ^~~~~~~\n/tmp/tmpr_56fznf.swift:22:19:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        result += newLetter\n                  ^\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += String(letter)\n\
    \        } else {\n            result += String(letter).swapCase()\n        }\n\
    \    }\n    for vowel in \"AEIOUaeiou\" {\n        result += String(vowel).swapCase()\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpetka92a1.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmpetka92a1.swift:18:38:\
    \ error: value of type 'String' has no member 'swapCase'\n            result +=\
    \ String(letter).swapCase()\n                      ~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmpetka92a1.swift:22:33:\
    \ error: value of type 'String' has no member 'swapCase'\n        result += String(vowel).swapCase()\n\
    \                  ~~~~~~~~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += String(letter)\n\
    \        } else {\n            result += String(letter).swapCase()\n        }\n\
    \    }\n    for letter in result {\n        if letter.isLetter() {\n         \
    \   result += String(letter)\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp1cl4o8pb.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmp1cl4o8pb.swift:18:38:\
    \ error: value of type 'String' has no member 'swapCase'\n            result +=\
    \ String(letter).swapCase()\n                      ~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmp1cl4o8pb.swift:22:19:\
    \ error: cannot call value of non-function type 'Bool'\n        if letter.isLetter()\
    \ {\n                  ^       ~~\n                          \n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)\n        let replacement\
    \ = alphabet[index + 2]\n        result += String(letter).uppercased() + replacement\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpywvx_tjr.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)\n                    ^~~~~~~~\n\
    /tmp/tmpywvx_tjr.swift:16:27: error: cannot find 'alphabet' in scope\n       \
    \ let replacement = alphabet[index + 2]\n                          ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)!\n        let replacement\
    \ = alphabet[index + 2]\n        result += replacement\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp_3_w4ekd.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)!\n                    ^~~~~~~~\n\
    /tmp/tmp_3_w4ekd.swift:16:27: error: cannot find 'alphabet' in scope\n       \
    \ let replacement = alphabet[index + 2]\n                          ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n        case \"e\"\
    :\n        case \"i\":\n        case \"o\":\n        case \"u\":\n           \
    \ result += letter\n        default:\n            result += letter.swapCase()\n\
    \        }\n    }\n    for vowel in \"aeiou\" {\n        result += vowel\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpxf9iogqw.swift:16:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"a\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpxf9iogqw.swift:17:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"e\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmpxf9iogqw.swift:18:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"i\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpxf9iogqw.swift:19:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"o\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpxf9iogqw.swift:21:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n/tmp/tmpxf9iogqw.swift:23:30:\
    \ error: value of type 'Character' has no member 'swapCase'\n            result\
    \ += letter.swapCase()\n                      ~~~~~~ ^~~~~~~~\n/tmp/tmpxf9iogqw.swift:27:19:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        result += vowel\n                  ^\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        switch letter {\n        case \"a\":\n            result\
    \ += \"A\"\n        case \"b\":\n            result += \"B\"\n        case \"\
    c\":\n            result += \"C\"\n        case \"d\":\n            result +=\
    \ \"D\"\n        case \"e\":\n            result += \"E\"\n        case \"f\"\
    :\n            result += \"F\"\n        case \"g\":\n            result += \"\
    G\"\n        case \"h\":\n            result += \"H\"\n        case \"i\":\n \
    \           result += \"I\"\n        case \"j\":\n            result += \"J\"\n\
    \        case \"k\":\n            result += \"K\"\n        case \"l\":\n     \
    \       result += \"L\"\n        case \"m\":\n            result += \"M\"\n  \
    \      case \"n\":\n            result += \"N\"\n        case \"o\":\n       \
    \     result += \"O\"\n        case \"p\":\n            result += \"P\"\n    \
    \    case \"q\":\n            result += \"Q\"\n        case \"r\":\n         \
    \   result += \"R\"\n        case \"s\":\n            result += \"S\"\n      \
    \  case \"t\":\n            result += \"T\"\n        case \"u\":\n           \
    \ result += \"U\"\n        case \"v\":\n            result += \"V\"\n        case\
    \ \"w\":\n            result += \"W\"\n        case \"x\":\n            result\
    \ += \"X\"\n        case \"y\":\n            result += \"Y\"\n        case \"\
    z\":\n            result += \"Z\"\n        case \"A\":\n            result +=\
    \ \"a\"\n        case \"B\":\n            result += \"b\"\n        case \"C\"\
    :\n            result += \"c\"\n        case \"D\":\n            result += \"\
    d\"\n        case \"E\":\n            result += \"e\"\n        case \"F\":\n \
    \           result += \"f\"\n        case \"G\":\n            result += \"g\"\n\
    \        case \"H\":\n            result += \"h\"\n        case \"I\":\n     \
    \       result += \"i\"\n        case \"J\":\n            result += \"j\"\n  \
    \      case \"K\":\n            result += \"k\"\n        case \"L\":\n       \
    \     result += \"l\"\n        case \"M\":\n            result += \"m\"\n    \
    \    case \"N\":\n            result += \"n\"\n        case \"O\":\n         \
    \   result += \"o\"\n        case \"P\":\n            result += \"p\"\n      \
    \  case \"Q\":\n            result += \"q\"\n        case \"R\":\n           \
    \ result += \"r\"\n        case \"S\":\n            result += \"s\"\n        case\
    \ \"T\":\n            result += \"t\"\n        case \"U\":\n            \n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp_dwjd4v7.swift:108:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"U\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmp_dwjd4v7.swift:129:84: error: expected '}' at\
    \ end of brace statement\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\"\
    ) == \"k dQnT kNqW wHcT Tq wRkTg\")\n                                        \
    \                                           ^\n/tmp/tmp_dwjd4v7.swift:14:27: note:\
    \ to match this opening '{'\n    for letter in message {\n                   \
    \       ^\n/tmp/tmp_dwjd4v7.swift:129:84: error: expected '}' at end of brace\
    \ statement\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT\
    \ kNqW wHcT Tq wRkTg\")\n                                                    \
    \                               ^\n/tmp/tmp_dwjd4v7.swift:12:40: note: to match\
    \ this opening '{'\nfunc encode(message: String) -> String {\n               \
    \                        ^\n/tmp/tmp_dwjd4v7.swift:15:9: error: switch must be\
    \ exhaustive\n        switch letter {\n        ^\n/tmp/tmp_dwjd4v7.swift:15:9:\
    \ note: do you want to add a default clause?\n        switch letter {\n      \
    \  ^\n/tmp/tmp_dwjd4v7.swift:113:6: error: operator functions can only be declared\
    \ at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659824717
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        let index = alphabet.index(of: letter)!\n        let nextIndex\
    \ = alphabet.index(of: letter, offsetBy: 2)!\n        let replacement = alphabet[nextIndex]\n\
    \        result += alphabet[index] + replacement\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpa9syzbwd.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)!\n                    ^~~~~~~~\n\
    /tmp/tmpa9syzbwd.swift:16:25: error: cannot find 'alphabet' in scope\n       \
    \ let nextIndex = alphabet.index(of: letter, offsetBy: 2)!\n                 \
    \       ^~~~~~~~\n/tmp/tmpa9syzbwd.swift:17:27: error: cannot find 'alphabet'\
    \ in scope\n        let replacement = alphabet[nextIndex]\n                  \
    \        ^~~~~~~~\n/tmp/tmpa9syzbwd.swift:18:19: error: cannot find 'alphabet'\
    \ in scope\n        result += alphabet[index] + replacement\n                \
    \  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += letter\n   \
    \     } else {\n            result += letter.lowercased()\n        }\n    }\n\
    \    for vowel in \"aeiou\" {\n        result += vowel.lowercased()\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encode(message: \"\
    TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp39a_z0jh.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmp39a_z0jh.swift:16:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n"
  stdout: ''
  timestamp: 1659824718
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfunc\
    \ encode(message: String) -> String {\n    var result = \"\"\n    for letter in\
    \ message {\n        if letter.isUpper() {\n            result += String(letter)\n\
    \        } else {\n            result += String(letter).swapCase()\n        }\n\
    \    }\n    for vowel in \"aeiouAEIOU\" {\n        result += String(vowel).swapCase()\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmprf9l45uf.swift:15:19: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if letter.isUpper() {\n           ~~~~~~ ^~~~~~~\n/tmp/tmprf9l45uf.swift:18:38:\
    \ error: value of type 'String' has no member 'swapCase'\n            result +=\
    \ String(letter).swapCase()\n                      ~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmprf9l45uf.swift:22:33:\
    \ error: value of type 'String' has no member 'swapCase'\n        result += String(vowel).swapCase()\n\
    \                  ~~~~~~~~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824718
