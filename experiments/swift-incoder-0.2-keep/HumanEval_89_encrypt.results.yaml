language: swift
name: HumanEval_89_encrypt
results:
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    alphabet.append(Character(UnicodeScalar(UInt8(97))))\n\
    \    alphabet.append(Character(UnicodeScalar(UInt8(98))))\n    alphabet.append(Character(UnicodeScalar(UInt8(99))))\n\
    \    alphabet.append(Character(UnicodeScalar(UInt8(100))))\n    alphabet.append(Character(UnicodeScalar(UInt8(101))))\n\
    \    alphabet.append(Character(UnicodeScalar(UInt8(102))))\n    alphabet.append(Character(UnicodeScalar(UInt8(103))))\n\
    \    alphabet.append(Character(UnicodeScalar(UInt8(104))))\n    alphabet.append(Character(UnicodeScalar(UInt8(105))))\n\
    \    alphabet.append(Character(UnicodeScalar(UInt8(106))))\n    alphabet.append(Character(UnicodeScalar(UInt8(107))))\n\
    \    alphabet.append(Character(UnicodeScalar(UInt8(108))))\n    alphabet.append(Character(UnicodeScalar(UInt8(109))))\n\
    \    alphabet.append(Character(UnicodeScalar(UInt8(110))))\n    alphabet.append(Character(UnicodeScalar(UInt8(111))))\n\
    \    alphabet.append(Character(UnicodeScalar(UInt8(112))))\n    alphabet.append(Character(UnicodeScalar(UInt8(113))))\n\
    \    alphabet.append(Character(UnicodeScalar(UInt8(114))))\n    alphabet.append(Character(UnicodeScalar(UInt8(115))))\n\
    \    alphabet.append(Character(UnicodeScalar(UInt8(116))))\n    alphabet.append(Character(UnicodeScalar(UInt8(117))))\n\
    \    alphabet.append(Character(UnicodeScalar(UInt8(118))))\n    alphabet.append(Character(UnicodeScalar(UInt8(119))))\n\
    \    alphabet.append(Character(UnicodeScalar(UInt8(120))))\n    alphabet.append(Character(UnicodeScalar(UInt8(121))))\n\
    \    alphabet.append(Character(UnicodeScalar(UInt8(122))))\n    alphabet.append(Character(UnicodeScalar(UInt8(123))))\n\
    \    alphabet.append(Character(UnicodeScalar(UInt8(124))))\n    alphabet.append(Character(UnicodeScalar(UInt8(125))))\n\
    \    alphabet.append(Character(UnicodeScalar(UInt8(126))))\n    alphabet.append(Character(UnicodeScalar(UInt8(127))))\n\
    \    \n    var result = \"\"\n    for c in s {\n        var index = alphabet.index(of:\
    \ c)!\n        index = index % alphabet.count\n        index = index + 2\n   \
    \     index = index % alphabet.count\n        result += alphabet[index]\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmptv1oriyv.swift:47:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        var index = alphabet.index(of: c)!\n         \
    \                    ^\n/tmp/tmptv1oriyv.swift:47:30: note: use 'firstIndex(of:)'\
    \ instead\n        var index = alphabet.index(of: c)!\n                      \
    \       ^~~~~\n                             firstIndex\n/tmp/tmptv1oriyv.swift:51:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        result += alphabet[index]\n                          ^\n/tmp/tmptv1oriyv.swift:51:27:\
    \ error: no exact matches in call to subscript \n        result += alphabet[index]\n\
    \                          ^\nSwift.String:3:35: note: candidate expects value\
    \ of type 'String' for parameter #2 (got 'Character')\n    @inlinable public static\
    \ func += (lhs: inout String, rhs: String)\n                                 \
    \ ^\nSwift.Array:17:23: note: candidate expects value of type 'Range<Int>' for\
    \ parameter #1 (got 'Array<Character>.Index' (aka 'Int'))\n    @inlinable public\
    \ subscript(bounds: Range<Int>) -> ArraySlice<Element> { get set }\n         \
    \             ^\nSwift.Collection:3:23: note: candidate expects value of type\
    \ '(UnboundedRange_) -> ()' for parameter #1 (got 'Array<Character>.Index' (aka\
    \ 'Int'))\n    @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence\
    \ { get }\n                      ^\nSwift.MutableCollection:3:23: note: candidate\
    \ expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Array<Character>.Index'\
    \ (aka 'Int'))\n    @inlinable public subscript(x: (UnboundedRange_) -> ()) ->\
    \ Self.SubSequence { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        result = result + alphabet[alphabet.IndexOf(c)\
    \ + 2]\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp241dvynn.swift:14:27: error: cannot find 'alphabet' in scope\n\
    \        result = result + alphabet[alphabet.IndexOf(c) + 2]\n               \
    \           ^~~~~~~~\n/tmp/tmp241dvynn.swift:14:36: error: cannot find 'alphabet'\
    \ in scope\n        result = result + alphabet[alphabet.IndexOf(c) + 2]\n    \
    \                               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 1)))\n    var result = \"\"\n    for c in s.characters {\n        var index\
    \ = alphabet.indexOf(c)\n        if index != -1 {\n            result += alphabet[(index\
    \ + alphabet.count) % alphabet.count]\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpp8h0ed90.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpp8h0ed90.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 1)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpp8h0ed90.swift:18:16:\
    \ error: 'characters' is unavailable: Please use String directly\n    for c in\
    \ s.characters {\n               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpp8h0ed90.swift:19:30: error: value of type '[Character]'\
    \ has no member 'indexOf'\n        var index = alphabet.indexOf(c)\n         \
    \           ~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+1))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+2))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+3))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+4))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+5))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+6))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+7))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+8))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+9))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+10))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+11))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+12))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+13))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+14))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+15))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+16))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+17))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+18))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+19))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+20))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+21))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+22))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+23))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+24))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+25))))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp4fhgjnmp.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp4fhgjnmp.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count))))\n\
    \                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp4fhgjnmp.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+1))))\n\
    \                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp4fhgjnmp.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+2))))\n\
    \                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp4fhgjnmp.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+3))))\n\
    \                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp4fhgjnmp.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+4))))\n\
    \                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp4fhgjnmp.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+5))))\n\
    \                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp4fhgjnmp.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+6))))\n\
    \                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp4fhgjnmp.swift:23:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+7))))\n\
    \                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp4fhgjnm"
  stdout: ''
  timestamp: 1659824988
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    alphabet.insert(Character(\"a\"), at: 0)\n    alphabet.insert(Character(\"\
    b\"), at: 1)\n    alphabet.insert(Character(\"c\"), at: 2)\n    alphabet.insert(Character(\"\
    d\"), at: 3)\n    alphabet.insert(Character(\"e\"), at: 4)\n    alphabet.insert(Character(\"\
    f\"), at: 5)\n    alphabet.insert(Character(\"g\"), at: 6)\n    alphabet.insert(Character(\"\
    h\"), at: 7)\n    alphabet.insert(Character(\"i\"), at: 8)\n    alphabet.insert(Character(\"\
    j\"), at: 9)\n    alphabet.insert(Character(\"k\"), at: 10)\n    alphabet.insert(Character(\"\
    l\"), at: 11)\n    alphabet.insert(Character(\"m\"), at: 12)\n    alphabet.insert(Character(\"\
    n\"), at: 13)\n    alphabet.insert(Character(\"o\"), at: 14)\n    alphabet.insert(Character(\"\
    p\"), at: 15)\n    alphabet.insert(Character(\"q\"), at: 16)\n    alphabet.insert(Character(\"\
    r\"), at: 17)\n    alphabet.insert(Character(\"s\"), at: 18)\n    alphabet.insert(Character(\"\
    t\"), at: 19)\n    alphabet.insert(Character(\"u\"), at: 20)\n    alphabet.insert(Character(\"\
    v\"), at: 21)\n    alphabet.insert(Character(\"w\"), at: 22)\n    alphabet.insert(Character(\"\
    x\"), at: 23)\n    alphabet.insert(Character(\"y\"), at: 24)\n    alphabet.insert(Character(\"\
    z\"), at: 25)\n    alphabet.insert(Character(\"A\"), at: 26)\n    alphabet.insert(Character(\"\
    B\"), at: 27)\n    alphabet.insert(Character(\"C\"), at: 28)\n    alphabet.insert(Character(\"\
    D\"), at: 29)\n    alphabet.insert(Character(\"E\"), at: 30)\n    alphabet.insert(Character(\"\
    F\"), at: 31)\n    alphabet.insert(Character(\"G\"), at: 32)\n    alphabet.insert(Character(\"\
    H\"), at: 33)\n    alphabet.insert(Character(\"I\"), at: 34)\n    alphabet.insert(Character(\"\
    J\"), at: 35)\n    alphabet.insert(Character(\"K\"), at: 36)\n    alphabet.insert(Character(\"\
    L\"), at: 37)\n    alphabet.insert(Character(\"M\"), at: 38)\n    alphabet.insert(Character(\"\
    N\"), at: 39)\n    alphabet.insert(Character(\"O\"), at: 40)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: '/tmp/tmp00l6bpl3.swift:54:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Charact\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpz31nwtqv.swift:44:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpz31nwtqv.swift:43:30: note: to match this opening '('\n    alphabet.append(Character(Charact\n\
    \                             ^\n/tmp/tmpz31nwtqv.swift:13:16: error: 'characters'\
    \ is unavailable: Please use String directly\n    for c in s.characters {\n  \
    \             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpz31nwtqv.swift:16:41: error: type 'Character' has no member 'UnicodeScalar'\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count) -\
    \ 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpz31nwtqv.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpz31nwtqv.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpz31nwtqv.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpz31nwtqv.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpz31nwtqv.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpz31nwtqv.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpz31nwtqv.swift:"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for _ in 0..<26 {\n        alphabet.append(Character(UnicodeScalar(UInt32((0x41\
    \ * UInt32(s.count) + 0x61) % 26))))\n    }\n    var result = \"\"\n    for c\
    \ in s {\n        result += alphabet[(alphabet.index(of: c) + 2) % 26]\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpeo2hndno.swift:14:35: error: value of optional type 'UnicodeScalar?'\
    \ (aka 'Optional<Unicode.Scalar>') must be unwrapped to a value of type 'UnicodeScalar'\
    \ (aka 'Unicode.Scalar')\n        alphabet.append(Character(UnicodeScalar(UInt32((0x41\
    \ * UInt32(s.count) + 0x61) % 26))))\n                                  ^\n/tmp/tmpeo2hndno.swift:14:35:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        alphabet.append(Character(UnicodeScalar(UInt32((0x41 * UInt32(s.count)\
    \ + 0x61) % 26))))\n                                  ^\n                    \
    \                                                                          ??\
    \ <#default value#>\n/tmp/tmpeo2hndno.swift:14:35: note: force-unwrap using '!'\
    \ to abort execution if the optional value contains 'nil'\n        alphabet.append(Character(UnicodeScalar(UInt32((0x41\
    \ * UInt32(s.count) + 0x61) % 26))))\n                                  ^\n  \
    \                                                                            \
    \               !\n/tmp/tmpeo2hndno.swift:18:27: error: cannot convert value of\
    \ type 'Character' to expected argument type 'String'\n        result += alphabet[(alphabet.index(of:\
    \ c) + 2) % 26]\n                          ^\n/tmp/tmpeo2hndno.swift:18:27: error:\
    \ no exact matches in call to subscript \n        result += alphabet[(alphabet.index(of:\
    \ c) + 2) % 26]\n                          ^\n/tmp/tmpeo2hndno.swift:18:27: note:\
    \ candidate has partially matching parameter list (Int)\n        result += alphabet[(alphabet.index(of:\
    \ c) + 2) % 26]\n                          ^\n/tmp/tmpeo2hndno.swift:18:27: note:\
    \ candidate expects value of type 'Range<Int>' for parameter #1 (got 'Int')\n\
    \        result += alphabet[(alphabet.index(of: c) + 2) % 26]\n              \
    \            ^\n/tmp/tmpeo2hndno.swift:18:27: note: candidate expects value of\
    \ type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n        result\
    \ += alphabet[(alphabet.index(of: c) + 2) % 26]\n                          ^\n\
    /tmp/tmpeo2hndno.swift:18:27: note: candidate expects value of type "
  stdout: ''
  timestamp: 1659824997
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n\tlet alphabet\
    \ = Array(s.characters)\n\tlet alphabetLength = alphabet.count\n\tlet alphabetRotation\
    \ = alphabet[alphabetLength - 1]\n\tlet alphabetLength = alphabetRotation.count\n\
    \tlet alphabetRotationLength = alphabetRotation.count\n\tlet alphabetRotationLength\
    \ = alphabetRotationLength / 2\n\tlet alphabetRotationLength = alphabetRotationLength\
    \ * 2\n\tlet alphabetRotationLength = alphabetRotationLength / 2\n\tlet alphabetRotationLength\
    \ = alphabetRotationLength * 2\n\tlet alphabetRotationLength = alphabetRotationLength\
    \ / 2\n\tlet alphabetRotationLength = alphabetRotationLength * 2\n\tlet alphabetRotationLength\
    \ = alphabetRotationLength / 2\n\tlet alphabetRotationLength = alphabetRotationLength\
    \ * 2\n\tlet alphabetRotationLength = alphabetRotationLength / 2\n\tlet alphabetRotationLength\
    \ = alphabetRotationLength * 2\n\tlet alphabetRotationLength = alphabetRotationLength\
    \ / 2\n\tlet alphabetRotationLength = alphabetRotationLength * 2\n\tlet alphabetRotationLength\
    \ = alphabetRotationLength / 2\n\tlet alphabetRotationLength = alphabetRotationLength\
    \ * 2\n\tlet alphabetRotationLength = alphabetRotationLength / 2\n\tlet alphabetRotationLength\
    \ = alphabetRotationLength * 2\n\tlet alphabetRotationLength = alphabetRotationLength\
    \ / 2\n\tlet alphabetRotationLength = alphabetRotationLength * 2\n\tlet alphabetRotationLength\
    \ = alphabetRotationLength / 2\n\tlet alphabetRotationLength = alphabetRotationLength\
    \ * 2\n\tlet alphabetRotationLength = alphabetRotationLength / 2\n\tlet alphabetRotationLength\
    \ = alphabetRotationLength * 2\n\tlet alphabetRotationLength = alphabetRotationLength\
    \ / 2\n\tlet alphabetRotationLength = alphabetRotationLength * 2\n\tlet alphabetRotationLength\
    \ = alphabetRotationLength / 2\n\tlet alphabetRotationLength = alphabetRotationLength\
    \ * 2\n\tlet alphabetRotationLength = alphabetRotationLength / 2\n\tlet alphabetRotationLength\
    \ = alphabetRotationLength * 2\n\tlet alphabetRotationLength = alphabetRotationLength\
    \ / 2\n\tlet alphabetRotationLength = alphabetRotationLength * 2\n\tlet alphabetRotationLength\
    \ = alphabetRotationLength / 2\n\tlet alphabetRotationLength = alphabetRotationLength\
    \ * 2\n\tlet alphabetRotationLength = alphabetRotationLength / 2\n\tlet alphabetRotationLength\
    \ = alphabetRotationLength * 2\n\tlet alphabetRotationLength = alphabetRotationLength\
    \ / 2\n\tlet alphabetRotationLength = alphabetRotationLength * 2\n\tlet alphabetRotationLength\
    \ = alphabetRotationLength / 2\n\tlet alphabetRotationLength = alphabetRotationLength\
    \ * 2\n\tlet alphabetRotationLength = alphabetRotationLength / 2\n\tlet alphabetRotationLength\
    \ = alphabetRotationLength * 2\n\tlet alphabetRotationLength = alphabetRotationLength\
    \ / 2\n\tlet alphabetRotationLength = alphabetRotationLength * 2\n\tlet alphabet\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpx_84i43p.swift:12:25: error: 'characters' is unavailable: Please\
    \ use String directly\n        let alphabet = Array(s.characters)\n          \
    \                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpx_84i43p.swift:15:40: error: value of type 'String.Element' (aka\
    \ 'Character') has no member 'count'\n        let alphabetLength = alphabetRotation.count\n\
    \                             ~~~~~~~~~~~~~~~~ ^~~~~\n/tmp/tmpx_84i43p.swift:16:48:\
    \ error: value of type 'String.Element' (aka 'Character') has no member 'count'\n\
    \        let alphabetRotationLength = alphabetRotation.count\n               \
    \                      ~~~~~~~~~~~~~~~~ ^~~~~\n/tmp/tmpx_84i43p.swift:59:6: error:\
    \ type annotation missing in pattern\n        let alphabet\n            ^\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        let index = alphabet.indexOf(c)\n        let\
    \ newIndex = index + 2\n        if newIndex < alphabet.count {\n            result\
    \ += alphabet[newIndex]\n        } else {\n            result += c\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpguz98d2l.swift:14:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.indexOf(c)\n                    ^~~~~~~~\n/tmp/tmpguz98d2l.swift:16:23:\
    \ error: cannot find 'alphabet' in scope\n        if newIndex < alphabet.count\
    \ {\n                      ^~~~~~~~\n/tmp/tmpguz98d2l.swift:17:23: error: cannot\
    \ find 'alphabet' in scope\n            result += alphabet[newIndex]\n       \
    \               ^~~~~~~~\n/tmp/tmpguz98d2l.swift:19:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ += c\n                      ^\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 18)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 20)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 22)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 24)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 26)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 28)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 30)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 32)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 34)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 36)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 38)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 40)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 42)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 44)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 46)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 48)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 50)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 52)))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp0ag9gkho.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp0ag9gkho.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:23:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:24:41:\
    \ error: type"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    a\".unicodeScalars.first!))\n    }\n    alphabet.append(Character(\"z\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"A\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    Z\".unicodeScalars.first!))\n    alphabet.append(Character(\"0\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"9\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    _\".unicodeScalars.first!))\n    alphabet.append(Character(\"$\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"%\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    &\".unicodeScalars.first!))\n    alphabet.append(Character(\"*\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"(\").unicodeScalars.first!)\n    alphabet.append(Character(\"\
    )\".unicodeScalars.first!))\n    alphabet.append(Character(\"_\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"_\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    _\".unicodeScalars.first!))\n    alphabet.append(Character(\"_\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"_\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    _\".unicodeScalars.first!))\n    alphabet.append(Character(\"_\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"_\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    _\".unicodeScalars.first!))\n    alphabet.append(Character(\"_\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"_\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    _\".unicodeScalars.first!))\n    alphabet.append(Character(\"_\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"_\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    _\".unicodeScalars.first!))\n    alphabet.append(Character(\"_\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"_\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    _\".unicodeScalars.first!))\n    alphabet.append(Character(\"_\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"_\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    _\".unicodeScalars.first!))\n    alphabet.append(Character(\"_\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpy9wi3xqz.swift:50:31: error: unterminated string literal\n    alphabet.append(Character(\"\
    \n                              ^\n/tmp/tmpy9wi3xqz.swift:26:56: error: cannot\
    \ convert value of type 'Unicode.Scalar' to expected argument type 'Character'\n\
    \    alphabet.append(Character(\"(\").unicodeScalars.first!)\n               \
    \                                        ^\n/tmp/tmpy9wi3xqz.swift:50:31: error:\
    \ missing argument for parameter #1 in call\n    alphabet.append(Character(\"\n\
    \                              ^\n                              <#Unicode.Scalar#>\n\
    Swift.Character:2:23: note: 'init(_:)' declared here\n    @inlinable public init(_\
    \ content: Unicode.Scalar)\n                      ^\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    alphabet.append(Character(\"a\"))\n    alphabet.append(Character(\"\
    b\"))\n    alphabet.append(Character(\"c\"))\n    alphabet.append(Character(\"\
    d\"))\n    alphabet.append(Character(\"e\"))\n    alphabet.append(Character(\"\
    f\"))\n    alphabet.append(Character(\"g\"))\n    alphabet.append(Character(\"\
    h\"))\n    alphabet.append(Character(\"i\"))\n    alphabet.append(Character(\"\
    j\"))\n    alphabet.append(Character(\"k\"))\n    alphabet.append(Character(\"\
    l\"))\n    alphabet.append(Character(\"m\"))\n    alphabet.append(Character(\"\
    n\"))\n    alphabet.append(Character(\"o\"))\n    alphabet.append(Character(\"\
    p\"))\n    alphabet.append(Character(\"q\"))\n    alphabet.append(Character(\"\
    r\"))\n    alphabet.append(Character(\"s\"))\n    alphabet.append(Character(\"\
    t\"))\n    alphabet.append(Character(\"u\"))\n    alphabet.append(Character(\"\
    v\"))\n    alphabet.append(Character(\"w\"))\n    alphabet.append(Character(\"\
    x\"))\n    alphabet.append(Character(\"y\"))\n    alphabet.append(Character(\"\
    z\"))\n    \n    var newString = \"\"\n    for char in s {\n        var index\
    \ = alphabet.index(of: char)!\n        index = index + 2\n        index = index\
    \ % alphabet.count\n        newString = newString + alphabet[index]\n    }\n \
    \   return newString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp9el65iug.swift:42:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        var index = alphabet.index(of: char)!\n      \
    \                       ^\n/tmp/tmp9el65iug.swift:42:30: note: use 'firstIndex(of:)'\
    \ instead\n        var index = alphabet.index(of: char)!\n                   \
    \          ^~~~~\n                             firstIndex\n/tmp/tmp9el65iug.swift:45:41:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        newString = newString + alphabet[index]\n                           \
    \             ^\n/tmp/tmp9el65iug.swift:45:41: error: no exact matches in call\
    \ to subscript \n        newString = newString + alphabet[index]\n           \
    \                             ^\nSwift.String:2:35: note: candidate expects value\
    \ of type 'String' for parameter #2 (got 'Character')\n    @inlinable public static\
    \ func + (lhs: String, rhs: String) -> String\n                              \
    \    ^\nSwift.Array:17:23: note: candidate expects value of type 'Range<Int>'\
    \ for parameter #1 (got 'Array<Character>.Index' (aka 'Int'))\n    @inlinable\
    \ public subscript(bounds: Range<Int>) -> ArraySlice<Element> { get set }\n  \
    \                    ^\nSwift.Collection:3:23: note: candidate expects value of\
    \ type '(UnboundedRange_) -> ()' for parameter #1 (got 'Array<Character>.Index'\
    \ (aka 'Int'))\n    @inlinable public subscript(x: (UnboundedRange_) -> ()) ->\
    \ Self.SubSequence { get }\n                      ^\nSwift.MutableCollection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Array<Character>.Index' (aka 'Int'))\n    @inlinable public subscript(x:\
    \ (UnboundedRange_) -> ()) -> Self.SubSequence { get set }\n                 \
    \     ^\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 18)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 20)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 22)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 24)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 26)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 28)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 30)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 32)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 34)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 36)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 38)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 40)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 42)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 44)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 46)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 48)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 50)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 52)))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp0ag9gkho.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp0ag9gkho.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:23:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:24:41:\
    \ error: type"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.sort()\n    alphabet = alphabet[1..<alphabet.count]\n    var\
    \ newAlphabet = [Character]()\n    for c in alphabet {\n        newAlphabet.append(c)\n\
    \    }\n    newAlphabet.sort()\n    newAlphabet = newAlphabet[1..<newAlphabet.count]\n\
    \    var newString = \"\"\n    for c in s.characters {\n        newString += newAlphabet[alphabet.indexOf(c)]\n\
    \    }\n    return newString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpzau4w07n.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpzau4w07n.swift:17:24:\
    \ error: cannot assign value of type 'ArraySlice<Character>' to type '[Character]'\n\
    \    alphabet = alphabet[1..<alphabet.count]\n               ~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpzau4w07n.swift:23:30: error: cannot assign value of type 'ArraySlice<Character>'\
    \ to type '[Character]'\n    newAlphabet = newAlphabet[1..<newAlphabet.count]\n\
    \                  ~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpzau4w07n.swift:25:16:\
    \ error: 'characters' is unavailable: Please use String directly\n    for c in\
    \ s.characters {\n               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpzau4w07n.swift:26:43: error: value of type '[Character]'\
    \ has no member 'indexOf'\n        newString += newAlphabet[alphabet.indexOf(c)]\n\
    \                                 ~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        result = result + alphabet.charAt((alphabet.indexOf(c)\
    \ + 2) % alphabet.count) + c\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpuc4ygfp8.swift:14:27: error: cannot find 'alphabet' in scope\n\
    \        result = result + alphabet.charAt((alphabet.indexOf(c) + 2) % alphabet.count)\
    \ + c\n                          ^~~~~~~~\n/tmp/tmpuc4ygfp8.swift:14:44: error:\
    \ cannot find 'alphabet' in scope\n        result = result + alphabet.charAt((alphabet.indexOf(c)\
    \ + 2) % alphabet.count) + c\n                                           ^~~~~~~~\n\
    /tmp/tmpuc4ygfp8.swift:14:71: error: cannot find 'alphabet' in scope\n       \
    \ result = result + alphabet.charAt((alphabet.indexOf(c) + 2) % alphabet.count)\
    \ + c\n                                                                      ^~~~~~~~\n\
    /tmp/tmpuc4ygfp8.swift:14:89: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        result = result + alphabet.charAt((alphabet.indexOf(c)\
    \ + 2) % alphabet.count) + c\n                                               \
    \                                         ^\n"
  stdout: ''
  timestamp: 1659824993
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Charact\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpdhxzp1si.swift:44:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpdhxzp1si.swift:43:30: note: to match this opening '('\n    alphabet.append(Character(Charact\n\
    \                             ^\n/tmp/tmpdhxzp1si.swift:13:16: error: 'characters'\
    \ is unavailable: Please use String directly\n    for c in s.characters {\n  \
    \             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpdhxzp1si.swift:16:41: error: type 'Character' has no member 'UnicodeScalar'\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpdhxzp1si.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpdhxzp1si.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpdhxzp1si.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpdhxzp1si.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpdhxzp1si.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpdhxzp1si.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpdhxzp1si"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    a\".unicodeScalars.first!))\n    }\n    alphabet.append(Character(\"z\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"A\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    Z\".unicodeScalars.first!))\n    alphabet.append(Character(\"0\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"1\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    2\".unicodeScalars.first!))\n    alphabet.append(Character(\"3\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"4\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    5\".unicodeScalars.first!))\n    alphabet.append(Character(\"6\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"7\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    8\".unicodeScalars.first!))\n    alphabet.append(Character(\"9\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"_\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    $\".unicodeScalars.first!))\n    alphabet.append(Character(\"%\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"&\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    *\".unicodeScalars.first!))\n    alphabet.append(Character(\"(\").unicodeScalars.first!)\n\
    \    alphabet.append(Character(\")\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    ,\".unicodeScalars.first!))\n    alphabet.append(Character(\"-\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\".\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    /\".unicodeScalars.first!))\n    alphabet.append(Character(\":\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\">\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    <\".unicodeScalars.first!))\n    alphabet.append(Character(\"?\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"@\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    !\".unicodeScalars.first!))\n    alphabet.append(Character(\"'\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"\\\"\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    [\".unicodeScalars.first!))\n    alphabet.append(Character(\"]\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"{\".unicodeScalars.\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpo0j9hg20.swift:50:49: error: expected member name following '.'\n\
    \    alphabet.append(Character(\"{\".unicodeScalars.\n                       \
    \                         ^\n/tmp/tmpo0j9hg20.swift:51:1: error: expected ')'\
    \ in expression list\n}\n^\n/tmp/tmpo0j9hg20.swift:50:30: note: to match this\
    \ opening '('\n    alphabet.append(Character(\"{\".unicodeScalars.\n         \
    \                    ^\n/tmp/tmpo0j9hg20.swift:34:56: error: cannot convert value\
    \ of type 'Unicode.Scalar' to expected argument type 'Character'\n    alphabet.append(Character(\"\
    (\").unicodeScalars.first!)\n                                                \
    \       ^\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        let index = alphabet.index(of: c)!\n     \
    \   let newIndex = index + 2\n        if newIndex < alphabet.count {\n       \
    \     result += alphabet[newIndex]\n        } else {\n            result += alphabet[alphabet.count\
    \ - 1]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpumhpiz7o.swift:14:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: c)!\n                    ^~~~~~~~\n/tmp/tmpumhpiz7o.swift:16:23:\
    \ error: cannot find 'alphabet' in scope\n        if newIndex < alphabet.count\
    \ {\n                      ^~~~~~~~\n/tmp/tmpumhpiz7o.swift:17:23: error: cannot\
    \ find 'alphabet' in scope\n            result += alphabet[newIndex]\n       \
    \               ^~~~~~~~\n/tmp/tmpumhpiz7o.swift:19:23: error: cannot find 'alphabet'\
    \ in scope\n            result += alphabet[alphabet.count - 1]\n             \
    \         ^~~~~~~~\n/tmp/tmpumhpiz7o.swift:19:32: error: cannot find 'alphabet'\
    \ in scope\n            result += alphabet[alphabet.count - 1]\n             \
    \                  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        result += alphabet.charAt((alphabet.indexOf(c)\
    \ + 2) % 26)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpjc6zoe8_.swift:14:19: error: cannot find 'alphabet' in scope\n\
    \        result += alphabet.charAt((alphabet.indexOf(c) + 2) % 26)\n         \
    \         ^~~~~~~~\n/tmp/tmpjc6zoe8_.swift:14:36: error: cannot find 'alphabet'\
    \ in scope\n        result += alphabet.charAt((alphabet.indexOf(c) + 2) % 26)\n\
    \                                   ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        result = result + alphabet[alphabet.index(c)\
    \ + 2]\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpi2k6kouw.swift:14:27: error: cannot find 'alphabet' in scope\n\
    \        result = result + alphabet[alphabet.index(c) + 2]\n                 \
    \         ^~~~~~~~\n/tmp/tmpi2k6kouw.swift:14:36: error: cannot find 'alphabet'\
    \ in scope\n        result = result + alphabet[alphabet.index(c) + 2]\n      \
    \                             ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.sort()\n    alphabet = alphabet[1..<alphabet.count]\n    var\
    \ result = [Character]()\n    for c in s.characters {\n        var index = alphabet.indexOf(c)\n\
    \        if index == -1 {\n            index = alphabet.count\n        }\n   \
    \     result.append(alphabet[(index - 1) % alphabet.count])\n    }\n    return\
    \ String(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpxqpvxuz3.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpxqpvxuz3.swift:17:24:\
    \ error: cannot assign value of type 'ArraySlice<Character>' to type '[Character]'\n\
    \    alphabet = alphabet[1..<alphabet.count]\n               ~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpxqpvxuz3.swift:19:16: error: 'characters' is unavailable: Please use String\
    \ directly\n    for c in s.characters {\n               ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpxqpvxuz3.swift:20:30: error: value of\
    \ type '[Character]' has no member 'indexOf'\n        var index = alphabet.indexOf(c)\n\
    \                    ~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        let index = alphabet.indexOf(c)\n        let\
    \ newIndex = index + 2\n        if newIndex < alphabet.count {\n            result\
    \ += alphabet[newIndex]\n        } else {\n            result += c\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpguz98d2l.swift:14:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.indexOf(c)\n                    ^~~~~~~~\n/tmp/tmpguz98d2l.swift:16:23:\
    \ error: cannot find 'alphabet' in scope\n        if newIndex < alphabet.count\
    \ {\n                      ^~~~~~~~\n/tmp/tmpguz98d2l.swift:17:23: error: cannot\
    \ find 'alphabet' in scope\n            result += alphabet[newIndex]\n       \
    \               ^~~~~~~~\n/tmp/tmpguz98d2l.swift:19:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ += c\n                      ^\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    a\"))\n    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"b\"))\n\
    \    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"c\"))\n   \
    \ }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"d\"))\n    }\n\
    \    for _ in 0..<26 {\n        alphabet.append(Character(\"e\"))\n    }\n   \
    \ for _ in 0..<26 {\n        alphabet.append(Character(\"f\"))\n    }\n    for\
    \ _ in 0..<26 {\n        alphabet.append(Character(\"g\"))\n    }\n    for _ in\
    \ 0..<26 {\n        alphabet.append(Character(\"h\"))\n    }\n    for _ in 0..<26\
    \ {\n        alphabet.append(Character(\"i\"))\n    }\n    for _ in 0..<26 {\n\
    \        alphabet.append(Character(\"j\"))\n    }\n    for _ in 0..<26 {\n   \
    \     alphabet.append(Character(\"k\"))\n    }\n    for _ in 0..<26 {\n      \
    \  alphabet.append(Character(\"l\"))\n    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    m\"))\n    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"n\"))\n\
    \    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"o\"))\n   \
    \ }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"p\"))\n    }\n\
    \    for _ in 0..<26 {\n        alphabet.append(Character(\"q\"))\n    }\n   \
    \ for _ in 0..<26 {\n        alphabet.append(Character(\"r\"))\n    }\n    for\
    \ _ in 0..<26 {\n        alphabet.append(Character(\"s\"))\n    }\n    for _ in\
    \ 0..<26 {\n        alphabet.append(Character(\"t\"))\n    }\n    for _ in 0..<26\
    \ {\n        alphabet.append(Character(\"u\"))\n    }\n    for _ in 0..<26 {\n\
    \        alphabet.append(Character(\"v\"))\n    }\n    for _ in 0..<26 {\n   \
    \     alphabet.append(Character(\"w\"))\n    }\n    for _ in 0..<26 {\n      \
    \  alphabet.append(Character(\"x\"))\n    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    y\"))\n    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"z\"))\n\
    \    }\n    var result = [Character]()\n    for c in s {\n        let index =\
    \ alphabet.index(of: c)!\n        let newIndex = index - 2\n        result.append(alphabet[newIndex])\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") == \"\
    lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"\
    gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\"\
    ) == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\"\
    )\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"a\") ==\
    \ \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmps70d3rn3.swift:93:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        let index = alphabet.index(of: c)!\n         \
    \                    ^\n/tmp/tmps70d3rn3.swift:93:30: note: use 'firstIndex(of:)'\
    \ instead\n        let index = alphabet.index(of: c)!\n                      \
    \       ^~~~~\n                             firstIndex\n/tmp/tmps70d3rn3.swift:97:1:\
    \ error: missing return in global function expected to return 'String'\n}\n^\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    a\".unicodeScalars.first!))\n    }\n    alphabet.append(Character(\"z\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"A\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    Z\".unicodeScalars.first!))\n    alphabet.append(Character(\"0\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"9\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    _\".unicodeScalars.first!))\n    alphabet.append(Character(\"$\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"%\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    &\".unicodeScalars.first!))\n    alphabet.append(Character(\"*\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"(\").unicodeScalars.first!)\n    alphabet.append(Character(\"\
    )\".unicodeScalars.first!))\n    alphabet.append(Character(\"'\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"!\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    ~\".unicodeScalars.first!))\n    alphabet.append(Character(\":\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\";\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    ,\".unicodeScalars.first!))\n    alphabet.append(Character(\"-\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\".\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    /\".unicodeScalars.first!))\n    alphabet.append(Character(\"?\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"'\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    '\".unicodeScalars.first!))\n    alphabet.append(Character(\"'\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"'\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    '\".unicodeScalars.first!))\n    alphabet.append(Character(\"'\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"'\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    '\".unicodeScalars.first!))\n    alphabet.append(Character(\"'\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"'\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    '\".unicodeScalars.first!))\n    alphabet.append(Character(\"'\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"'\".unicode\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmphdtsmpl2.swift:51:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmphdtsmpl2.swift:50:30: note: to match this opening '('\n    alphabet.append(Character(\"\
    '\".unicode\n                             ^\n/tmp/tmphdtsmpl2.swift:26:56: error:\
    \ cannot convert value of type 'Unicode.Scalar' to expected argument type 'Character'\n\
    \    alphabet.append(Character(\"(\").unicodeScalars.first!)\n               \
    \                                        ^\n/tmp/tmphdtsmpl2.swift:50:35: error:\
    \ value of type 'String' has no member 'unicode'\n    alphabet.append(Character(\"\
    '\".unicode\n                              ~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 18)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 20)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 22)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 24)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 26)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 28)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 30)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 32)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 34)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 36)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 38)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 40)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 42)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 44)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 46)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 48)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 50)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 52)))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp0ag9gkho.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp0ag9gkho.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:23:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:24:41:\
    \ error: type"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        result += alphabet.charAt((alphabet.indexOf(c)\
    \ + 2) % alphabet.count) + c\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp2sg__vah.swift:14:19: error: cannot find 'alphabet' in scope\n\
    \        result += alphabet.charAt((alphabet.indexOf(c) + 2) % alphabet.count)\
    \ + c\n                  ^~~~~~~~\n/tmp/tmp2sg__vah.swift:14:36: error: cannot\
    \ find 'alphabet' in scope\n        result += alphabet.charAt((alphabet.indexOf(c)\
    \ + 2) % alphabet.count) + c\n                                   ^~~~~~~~\n/tmp/tmp2sg__vah.swift:14:63:\
    \ error: cannot find 'alphabet' in scope\n        result += alphabet.charAt((alphabet.indexOf(c)\
    \ + 2) % alphabet.count) + c\n                                               \
    \               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 1)))\n    alphabet.sort()\n    var result = [Character]()\n    for c in alphabet\
    \ {\n        result.append(c)\n    }\n    var resultString = \"\"\n    for c in\
    \ result {\n        resultString += String(UnicodeScalar(UInt32(c)))\n    }\n\
    \    return resultString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp9qprhbcz.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp9qprhbcz.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 1)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp9qprhbcz.swift:24:46:\
    \ error: no exact matches in call to initializer \n        resultString += String(UnicodeScalar(UInt32(c)))\n\
    \                                             ^\n/tmp/tmp9qprhbcz.swift:24:46:\
    \ note: candidate expects value of type 'Float16' for parameter #1 (got 'UnicodeScalar?'\
    \ (aka 'Optional<Unicode.Scalar>'))\n        resultString += String(UnicodeScalar(UInt32(c)))\n\
    \                                             ^\n/tmp/tmp9qprhbcz.swift:24:46:\
    \ note: candidate expects value of type 'Float' for parameter #1 (got 'UnicodeScalar?'\
    \ (aka 'Optional<Unicode.Scalar>'))\n        resultString += String(UnicodeScalar(UInt32(c)))\n\
    \                                             ^\n/tmp/tmp9qprhbcz.swift:24:46:\
    \ note: candidate expects value of type 'Double' for parameter #1 (got 'UnicodeScalar?'\
    \ (aka 'Optional<Unicode.Scalar>'))\n        resultString += String(UnicodeScalar(UInt32(c)))\n\
    \                                             ^\n/tmp/tmp9qprhbcz.swift:24:46:\
    \ note: candidate expects value of type 'Float80' for parameter #1 (got 'UnicodeScalar?'\
    \ (aka 'Optional<Unicode.Scalar>'))\n        resultString += String(UnicodeScalar(UInt32(c)))\n\
    \                                             ^\n/tmp/tmp9qprhbcz.swift:24:46:\
    \ note: candidate expects value of type 'Builtin.Int32' for parameter #1 (got\
    \ 'UnicodeScalar?' (aka 'Optional<Unicode.Scalar>'))\n        resultString +=\
    \ String(UnicodeScalar(UInt32(c)))\n                                         \
    \    ^\n/tmp/tmp9qprhbcz.swift:24:46: note: candidate expects value of type 'Unicode.Scalar'\
    \ for pa"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 1)))\n    alphabet.sort()\n    var result = [Character]()\n    for c in alphabet\
    \ {\n        result.append(c)\n    }\n    return String(result)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpoylej0t6.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpoylej0t6.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 1)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpwwz01jmv.swift:64:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpwwz01jmv.swift:13:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.first!))\n                        \
    \      ^\n                              extendedGraphemeClusterLiteral: \n/tmp/tmpwwz01jmv.swift:14:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpwwz01jmv.swift:15:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpwwz01jmv.swift:16:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpwwz01jmv.swift:17:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpwwz01jmv.swift:18:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpwwz01jmv.swift:19:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpwwz01jmv.swift:20:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpwwz01jmv.swift:21:31:\
    \ error: missing argument label 'exte"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        result = result + alphabet[alphabet.indexOf(c)\
    \ + 2]\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpbw4bcy9o.swift:14:27: error: cannot find 'alphabet' in scope\n\
    \        result = result + alphabet[alphabet.indexOf(c) + 2]\n               \
    \           ^~~~~~~~\n/tmp/tmpbw4bcy9o.swift:14:36: error: cannot find 'alphabet'\
    \ in scope\n        result = result + alphabet[alphabet.indexOf(c) + 2]\n    \
    \                               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        result += alphabet[alphabet.index(c) + alphabet.index(alphabet[alphabet.index(c)\
    \ + 1])]\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp80grdha7.swift:14:19: error: cannot find 'alphabet' in scope\n\
    \        result += alphabet[alphabet.index(c) + alphabet.index(alphabet[alphabet.index(c)\
    \ + 1])]\n                  ^~~~~~~~\n/tmp/tmp80grdha7.swift:14:28: error: cannot\
    \ find 'alphabet' in scope\n        result += alphabet[alphabet.index(c) + alphabet.index(alphabet[alphabet.index(c)\
    \ + 1])]\n                           ^~~~~~~~\n/tmp/tmp80grdha7.swift:14:48: error:\
    \ cannot find 'alphabet' in scope\n        result += alphabet[alphabet.index(c)\
    \ + alphabet.index(alphabet[alphabet.index(c) + 1])]\n                       \
    \                        ^~~~~~~~\n/tmp/tmp80grdha7.swift:14:63: error: cannot\
    \ find 'alphabet' in scope\n        result += alphabet[alphabet.index(c) + alphabet.index(alphabet[alphabet.index(c)\
    \ + 1])]\n                                                              ^~~~~~~~\n\
    /tmp/tmp80grdha7.swift:14:72: error: cannot find 'alphabet' in scope\n       \
    \ result += alphabet[alphabet.index(c) + alphabet.index(alphabet[alphabet.index(c)\
    \ + 1])]\n                                                                   \
    \    ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    alphabet.insert(Character(\"a\"), at: 0)\n    alphabet.insert(Character(\"\
    b\"), at: 1)\n    alphabet.insert(Character(\"c\"), at: 2)\n    alphabet.insert(Character(\"\
    d\"), at: 3)\n    alphabet.insert(Character(\"e\"), at: 4)\n    alphabet.insert(Character(\"\
    f\"), at: 5)\n    alphabet.insert(Character(\"g\"), at: 6)\n    alphabet.insert(Character(\"\
    h\"), at: 7)\n    alphabet.insert(Character(\"i\"), at: 8)\n    alphabet.insert(Character(\"\
    j\"), at: 9)\n    alphabet.insert(Character(\"k\"), at: 10)\n    alphabet.insert(Character(\"\
    l\"), at: 11)\n    alphabet.insert(Character(\"m\"), at: 12)\n    alphabet.insert(Character(\"\
    n\"), at: 13)\n    alphabet.insert(Character(\"o\"), at: 14)\n    alphabet.insert(Character(\"\
    p\"), at: 15)\n    alphabet.insert(Character(\"q\"), at: 16)\n    alphabet.insert(Character(\"\
    r\"), at: 17)\n    alphabet.insert(Character(\"s\"), at: 18)\n    alphabet.insert(Character(\"\
    t\"), at: 19)\n    alphabet.insert(Character(\"u\"), at: 20)\n    alphabet.insert(Character(\"\
    v\"), at: 21)\n    alphabet.insert(Character(\"w\"), at: 22)\n    alphabet.insert(Character(\"\
    x\"), at: 23)\n    alphabet.insert(Character(\"y\"), at: 24)\n    alphabet.insert(Character(\"\
    z\"), at: 25)\n    alphabet.insert(Character(\"A\"), at: 26)\n    alphabet.insert(Character(\"\
    B\"), at: 27)\n    alphabet.insert(Character(\"C\"), at: 28)\n    alphabet.insert(Character(\"\
    D\"), at: 29)\n    alphabet.insert(Character(\"E\"), at: 30)\n    alphabet.insert(Character(\"\
    F\"), at: 31)\n    alphabet.insert(Character(\"G\"), at: 32)\n    alphabet.insert(Character(\"\
    H\"), at: 33)\n    alphabet.insert(Character(\"I\"), at: 34)\n    alphabet.insert(Character(\"\
    J\"), at: 35)\n    alphabet.insert(Character(\"K\"), at: 36)\n    alphabet.insert(Character(\"\
    L\"), at: 37)\n    alphabet.insert(Character(\"M\"), at: 38)\n    alphabet.insert(Character(\"\
    N\"), at: 39)\n    alphabet.insert(Character(\"O\"), at: 40)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: '/tmp/tmp00l6bpl3.swift:54:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Charact\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp8wsff5th.swift:44:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmp8wsff5th.swift:43:30: note: to match this opening '('\n    alphabet.append(Character(Charact\n\
    \                             ^\n/tmp/tmp8wsff5th.swift:13:16: error: 'characters'\
    \ is unavailable: Please use String directly\n    for c in s.characters {\n  \
    \             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp8wsff5th.swift:16:41: error: type 'Character' has no member 'UnicodeScalar'\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp8wsff5th.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 1)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp8wsff5th.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp8wsff5th.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp8wsff5th.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp8wsff5th.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp8wsff5th.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp8wsff5th"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for _ in 0..<26 {\n        alphabet.append(Character('a'\
    \ + String(_).unicodeScalars.count-1))\n    }\n    \n    var result = \"\"\n \
    \   for char in s {\n        let index = alphabet.index(of: char)!\n        let\
    \ newIndex = index + 2\n        let newChar = alphabet[newIndex]\n        result\
    \ += String(newChar)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp5v6rj7gp.swift:14:35: error: single-quoted string literal found,\
    \ use '\"'\n        alphabet.append(Character('a' + String(_).unicodeScalars.count-1))\n\
    \                                  ^~~\n                                  \"a\"\
    \n/tmp/tmp5v6rj7gp.swift:14:48: error: '_' can only appear in a pattern or on\
    \ the left side of an assignment\n        alphabet.append(Character('a' + String(_).unicodeScalars.count-1))\n\
    \                                               ^\n/tmp/tmp5v6rj7gp.swift:19:30:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ index = alphabet.index(of: char)!\n                             ^\n/tmp/tmp5v6rj7gp.swift:19:30:\
    \ note: use 'firstIndex(of:)' instead\n        let index = alphabet.index(of:\
    \ char)!\n                             ^~~~~\n                             firstIndex\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpwwz01jmv.swift:64:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpwwz01jmv.swift:13:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.first!))\n                        \
    \      ^\n                              extendedGraphemeClusterLiteral: \n/tmp/tmpwwz01jmv.swift:14:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpwwz01jmv.swift:15:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpwwz01jmv.swift:16:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpwwz01jmv.swift:17:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpwwz01jmv.swift:18:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpwwz01jmv.swift:19:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpwwz01jmv.swift:20:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpwwz01jmv.swift:21:31:\
    \ error: missing argument label 'exte"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        result = result + alphabet[alphabet.IndexOf(alphabet[c])+2]\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpha7d6o45.swift:14:27: error: cannot find 'alphabet' in scope\n\
    \        result = result + alphabet[alphabet.IndexOf(alphabet[c])+2]\n       \
    \                   ^~~~~~~~\n/tmp/tmpha7d6o45.swift:14:36: error: cannot find\
    \ 'alphabet' in scope\n        result = result + alphabet[alphabet.IndexOf(alphabet[c])+2]\n\
    \                                   ^~~~~~~~\n/tmp/tmpha7d6o45.swift:14:53: error:\
    \ cannot find 'alphabet' in scope\n        result = result + alphabet[alphabet.IndexOf(alphabet[c])+2]\n\
    \                                                    ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    alphabet.append(Character(\"a\"))\n    alphabet.append(Character(\"\
    b\"))\n    alphabet.append(Character(\"c\"))\n    alphabet.append(Character(\"\
    d\"))\n    alphabet.append(Character(\"e\"))\n    alphabet.append(Character(\"\
    f\"))\n    alphabet.append(Character(\"g\"))\n    alphabet.append(Character(\"\
    h\"))\n    alphabet.append(Character(\"i\"))\n    alphabet.append(Character(\"\
    j\"))\n    alphabet.append(Character(\"k\"))\n    alphabet.append(Character(\"\
    l\"))\n    alphabet.append(Character(\"m\"))\n    alphabet.append(Character(\"\
    n\"))\n    alphabet.append(Character(\"o\"))\n    alphabet.append(Character(\"\
    p\"))\n    alphabet.append(Character(\"q\"))\n    alphabet.append(Character(\"\
    r\"))\n    alphabet.append(Character(\"s\"))\n    alphabet.append(Character(\"\
    t\"))\n    alphabet.append(Character(\"u\"))\n    alphabet.append(Character(\"\
    v\"))\n    alphabet.append(Character(\"w\"))\n    alphabet.append(Character(\"\
    x\"))\n    alphabet.append(Character(\"y\"))\n    alphabet.append(Character(\"\
    z\"))\n    alphabet.append(Character(\"A\"))\n    alphabet.append(Character(\"\
    B\"))\n    alphabet.append(Character(\"C\"))\n    alphabet.append(Character(\"\
    D\"))\n    alphabet.append(Character(\"E\"))\n    alphabet.append(Character(\"\
    F\"))\n    alphabet.append(Character(\"G\"))\n    alphabet.append(Character(\"\
    H\"))\n    alphabet.append(Character(\"I\"))\n    alphabet.append(Character(\"\
    J\"))\n    alphabet.append(Character(\"K\"))\n    alphabet.append(Character(\"\
    L\"))\n    alphabet.append(Character(\"M\"))\n    alphabet.append(Character(\"\
    N\"))\n    alphabet.append(Character(\"O\"))\n    alphabet.append(Character(\"\
    P\"))\n    alphabet.append(Character(\"Q\"))\n    alphabet.append(Character(\"\
    R\"))\n    alphabet.append(Character(\"S\"))\n    alphabet.append(Character(\"\
    T\"))\n    alphabet.append(Character(\"U\"))\n    alphabet.append(Character(\"\
    V\"))\n    alphabet.append(Character(\"W\"))\n    alphabet.append(Character(\"\
    X\"))\n    alphabet.append(Character(\"Y\"))\n    alphabet.append(Character(\"\
    Z\"))\n    \n    var result = [Character]()\n    var i = 0\n    for c in s {\n\
    \        result.append(alphabet[(i + 2) % alphabet.count])\n        i += 1\n \
    \   }\n    return String(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmph10kbvb1/tmph10kbvb1.swift:88: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7755c0fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7755906b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7755906988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b77559057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph10kbvb1                        0x00005594b05106f7 <unavailable> + 5879

    5    libc.so.6                          0x00002b7755dfb460 __libc_start_main +
    245

    6    tmph10kbvb1                        0x00005594b0510339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for _ in 0..<26 {\n        alphabet.append(Character(UnicodeScalar(UInt32(97\
    \ + _))))\n    }\n    \n    var result = [Character]()\n    for c in s {\n   \
    \     var index = alphabet.index(of: c)!\n        \n        // Rotate by two and\
    \ multiply by two\n        index = ((index + 2) % 26) * 2\n        \n        result.append(alphabet[index])\n\
    \    }\n    return String(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp_di6k944.swift:14:61: error: '_' can only appear in a pattern or\
    \ on the left side of an assignment\n        alphabet.append(Character(UnicodeScalar(UInt32(97\
    \ + _))))\n                                                            ^\n/tmp/tmp_di6k944.swift:19:30:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        var\
    \ index = alphabet.index(of: c)!\n                             ^\n/tmp/tmp_di6k944.swift:19:30:\
    \ note: use 'firstIndex(of:)' instead\n        var index = alphabet.index(of:\
    \ c)!\n                             ^~~~~\n                             firstIndex\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Charact\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpeofgl_hi.swift:44:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpeofgl_hi.swift:43:30: note: to match this opening '('\n    alphabet.append(Character(Charact\n\
    \                             ^\n/tmp/tmpeofgl_hi.swift:13:16: error: 'characters'\
    \ is unavailable: Please use String directly\n    for c in s.characters {\n  \
    \             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpeofgl_hi.swift:16:41: error: type 'Character' has no member 'UnicodeScalar'\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count) -\
    \ 1)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpeofgl_hi.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 1)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpeofgl_hi.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 1)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpeofgl_hi.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 1)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpeofgl_hi.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 1)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpeofgl_hi.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 1)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpeofgl_hi.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 1)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpeofgl_hi.swift:"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.removeLast()\n    alphabet.insert(contentsOf: alphabet.suffix(2))\n\
    \    alphabet.insert(contentsOf: alphabet.prefix(2))\n    return String(alphabet)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmphp3hygz9.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmphp3hygz9.swift:17:51:\
    \ error: missing argument for parameter 'at' in call\n    alphabet.insert(contentsOf:\
    \ alphabet.suffix(2))\n                                                  ^\n \
    \                                                 , at: <#Array<Character>.Index#>\n\
    Swift.RangeReplaceableCollection:7:37: note: 'insert(contentsOf:at:)' declared\
    \ here\n    @inlinable public mutating func insert<C>(contentsOf newElements:\
    \ __owned C, at i: Self.Index) where C : Collection, Self.Element == C.Element\n\
    \                                    ^\n/tmp/tmphp3hygz9.swift:18:51: error: missing\
    \ argument for parameter 'at' in call\n    alphabet.insert(contentsOf: alphabet.prefix(2))\n\
    \                                                  ^\n                       \
    \                           , at: <#Array<Character>.Index#>\nSwift.RangeReplaceableCollection:7:37:\
    \ note: 'insert(contentsOf:at:)' declared here\n    @inlinable public mutating\
    \ func insert<C>(contentsOf newElements: __owned C, at i: Self.Index) where C\
    \ : Collection, Self.Element == C.Element\n                                  \
    \  ^\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.sort()\n    alphabet = alphabet[1..<alphabet.count]\n    var\
    \ result = [Character]()\n    for c in alphabet {\n        result.append(c)\n\
    \    }\n    for _ in 0..<s.characters.count {\n        result.append(result[0])\n\
    \    }\n    return String(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmppdjd11z9.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmppdjd11z9.swift:17:24:\
    \ error: cannot assign value of type 'ArraySlice<Character>' to type '[Character]'\n\
    \    alphabet = alphabet[1..<alphabet.count]\n               ~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmppdjd11z9.swift:22:20: error: 'characters' is unavailable: Please use String\
    \ directly\n    for _ in 0..<s.characters.count {\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    alphabet.append(Character(s.characters.count))\n    alphabet.append(Character(s.characters.count))\n\
    \    alphabet.append(Character(s.characters.count))\n    alphabet.append(Character(s.characters.count))\n\
    \    alphabet.append(Character(s.characters.count))\n    alphabet.append(Character(s.characters.count))\n\
    \    alphabet.append(Character(s.characters.count))\n    alphabet.append(Character(s.characters.count))\n\
    \    alphabet.append(Character(s.characters.count))\n    alphabet.append(Character(s.characters.count))\n\
    \    alphabet.append(Character(s.characters.count))\n    alphabet.append(Character(s.characters.count))\n\
    \    alphabet.append(Character(s.characters.count))\n    alphabet.append(Character(s.characters.count))\n\
    \    alphabet.append(Character(s.characters.count))\n    alphabet.append(Character(s.characters.count))\n\
    \    alphabet.append(Character(s.characters.count))\n    alphabet.append(Character(s.characters.count))\n\
    \    alphabet.append(Character(s.characters.count))\n    alphabet.append(Character(s.characters.count))\n\
    \    alphabet.append(Character(s.characters.count))\n    alphabet.append(Character(s.characters.count))\n\
    \    alphabet.append(Character(s.characters.count))\n    alphabet.append(Character(s.characters.count))\n\
    \    alphabet.append(Character(s.characters.count))\n    alphabet.append(Character(s.characters.count))\n\
    \    alphabet.append(Character(s.characters.count))\n    alphabet.append(Character(s.characters.count))\n\
    \    alphabet.append(Character(s.characters.count))\n    alphabet.append(Character(s.characters.count))\n\
    \    alphabet.append(Character(s.characters.count))\n    alphabet.append(Character(s.characters.count))\n\
    \    alphabet.append(Character(s.characters.count))\n    alphabet.append(Character(s.characters.count))\n\
    \    alphabet.append(Character(s.characters.count))\n    alphabet.append(Character(s.characters.count))\n\
    \    alphabet.append(Character(s.characters.count))\n    alphabet.append(Character(s.characters.count))\n\
    \    alphabet.append(Character(s.characters.count))\n    alphabet.append(Character(s.characters.count))\n\
    \    alphabet.append(Character(s.characters.count))\n    alphabet.append(Character(s.characters.count))\n\
    \    alphabet.append(Character(s.characters.count))\n    alphabet.append(Character(s.characters.count))\n\
    \    alphabet.append(Character(s.characters.count))\n    alphabet.append(Character(s.characters.count))\n\
    \    alphabet.append(Character(s.characters.count))\n    alphabet.append(Character(s.characters.count))\n\
    \    alphabet.append(Character(s.characters.count))\n    alphabet.append(Character(s.characters.count))\n\
    \    alphabet.append(Character(s.characters.count))\n    alphabet.append(Character(s.characters.count))\n\
    \    alphabet.append(Character(s.characters.count))\n    alphabet.append(Character(s.characters.count))\n\
    \    alphabet.append(Character(s.characters.count))\n    alphabet.append(Character(s.characters.count))\n\
    \    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") == \"\
    lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"\
    gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\"\
    ) == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\"\
    )\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"a\") ==\
    \ \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpv18l_ugh.swift:13:21: error: no exact matches in call to initializer\
    \ \n    alphabet.append(Character(s.characters.count))\n                    ^\n\
    Swift.Character:2:23: note: candidate expects value of type 'Unicode.Scalar' for\
    \ parameter #1 (got 'Int')\n    @inlinable public init(_ content: Unicode.Scalar)\n\
    \                      ^\nSwift.Character:6:23: note: candidate expects value\
    \ of type 'String' for parameter #1 (got 'Int')\n    @inlinable public init(_\
    \ s: String)\n                      ^\n/tmp/tmpv18l_ugh.swift:14:21: error: no\
    \ exact matches in call to initializer \n    alphabet.append(Character(s.characters.count))\n\
    \                    ^\nSwift.Character:2:23: note: candidate expects value of\
    \ type 'Unicode.Scalar' for parameter #1 (got 'Int')\n    @inlinable public init(_\
    \ content: Unicode.Scalar)\n                      ^\nSwift.Character:6:23: note:\
    \ candidate expects value of type 'String' for parameter #1 (got 'Int')\n    @inlinable\
    \ public init(_ s: String)\n                      ^\n/tmp/tmpv18l_ugh.swift:15:21:\
    \ error: no exact matches in call to initializer \n    alphabet.append(Character(s.characters.count))\n\
    \                    ^\nSwift.Character:2:23: note: candidate expects value of\
    \ type 'Unicode.Scalar' for parameter #1 (got 'Int')\n    @inlinable public init(_\
    \ content: Unicode.Scalar)\n                      ^\nSwift.Character:6:23: note:\
    \ candidate expects value of type 'String' for parameter #1 (got 'Int')\n    @inlinable\
    \ public init(_ s: String)\n                      ^\n/tmp/tmpv18l_ugh.swift:16:21:\
    \ error: no exact matches in call to initializer \n    alphabet.append(Character(s.characters.count))\n\
    \                    ^\nSwift.Character:2:23: note: candidate expects value of\
    \ type 'Unicode.Scalar' for parameter #1 (got 'Int')\n    @inlinable public init(_\
    \ content: Unicode.Scalar)\n                      ^\nSwift.Character:6:23: note:\
    \ candidate expects value of type 'String' for parameter #1 (got 'Int')\n    @inlinable\
    \ public init(_ s: String)\n                      ^\n/tmp/tmpv18l_ugh.swift:17:21:\
    \ error: no exact matches in cal"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 18)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 20)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 22)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 24)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 26)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 28)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 30)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 32)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 34)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 36)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 38)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 40)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 42)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 44)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 46)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 48)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 50)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 52)))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp0ag9gkho.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp0ag9gkho.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:23:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:24:41:\
    \ error: type"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        result += alphabet[alphabet.index(c)%len(alphabet)]\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp7kwefciy.swift:14:19: error: cannot find 'alphabet' in scope\n\
    \        result += alphabet[alphabet.index(c)%len(alphabet)]\n               \
    \   ^~~~~~~~\n/tmp/tmp7kwefciy.swift:14:28: error: cannot find 'alphabet' in scope\n\
    \        result += alphabet[alphabet.index(c)%len(alphabet)]\n               \
    \            ^~~~~~~~\n/tmp/tmp7kwefciy.swift:14:46: error: cannot find 'len'\
    \ in scope\n        result += alphabet[alphabet.index(c)%len(alphabet)]\n    \
    \                                         ^~~\n/tmp/tmp7kwefciy.swift:14:50: error:\
    \ cannot find 'alphabet' in scope\n        result += alphabet[alphabet.index(c)%len(alphabet)]\n\
    \                                                 ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    a\".unicodeScalars.first!))\n    }\n    alphabet.append(Character(\"z\".unicodeScalars.first!))\n\
    \    var result = \"\"\n    for c in s {\n        let index = alphabet.index(of:\
    \ c)!\n        let newIndex = index + 2\n        result += alphabet[newIndex]\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpwkp1n25j.swift:19:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        let index = alphabet.index(of: c)!\n         \
    \                    ^\n/tmp/tmpwkp1n25j.swift:19:30: note: use 'firstIndex(of:)'\
    \ instead\n        let index = alphabet.index(of: c)!\n                      \
    \       ^~~~~\n                             firstIndex\n/tmp/tmpwkp1n25j.swift:21:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        result += alphabet[newIndex]\n                          ^\n/tmp/tmpwkp1n25j.swift:21:27:\
    \ error: no exact matches in call to subscript \n        result += alphabet[newIndex]\n\
    \                          ^\nSwift.String:3:35: note: candidate expects value\
    \ of type 'String' for parameter #2 (got 'Character')\n    @inlinable public static\
    \ func += (lhs: inout String, rhs: String)\n                                 \
    \ ^\nSwift.Array:17:23: note: candidate expects value of type 'Range<Int>' for\
    \ parameter #1 (got 'Int')\n    @inlinable public subscript(bounds: Range<Int>)\
    \ -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\nSwift.MutableCollection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 18)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 20)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 22)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 24)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 26)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 28)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 30)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 32)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 34)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 36)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 38)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 40)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 42)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 44)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 46)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 48)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 50)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 52)))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp0ag9gkho.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp0ag9gkho.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:23:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:24:41:\
    \ error: type"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        result = result + alphabet[alphabet.Index(c)%len(alphabet)]\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp4_huntow.swift:14:27: error: cannot find 'alphabet' in scope\n\
    \        result = result + alphabet[alphabet.Index(c)%len(alphabet)]\n       \
    \                   ^~~~~~~~\n/tmp/tmp4_huntow.swift:14:36: error: cannot find\
    \ 'alphabet' in scope\n        result = result + alphabet[alphabet.Index(c)%len(alphabet)]\n\
    \                                   ^~~~~~~~\n/tmp/tmp4_huntow.swift:14:54: error:\
    \ cannot find 'len' in scope\n        result = result + alphabet[alphabet.Index(c)%len(alphabet)]\n\
    \                                                     ^~~\n/tmp/tmp4_huntow.swift:14:58:\
    \ error: cannot find 'alphabet' in scope\n        result = result + alphabet[alphabet.Index(c)%len(alphabet)]\n\
    \                                                         ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 18)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 20)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 22)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 24)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 26)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 28)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 30)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 32)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 34)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 36)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 38)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 40)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 42)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 44)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 46)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 48)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 50)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 52)))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp0ag9gkho.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp0ag9gkho.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:23:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:24:41:\
    \ error: type"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    alphabet.insert(Character(\"a\"), at: 0)\n    alphabet.insert(Character(\"\
    b\"), at: 1)\n    alphabet.insert(Character(\"c\"), at: 2)\n    alphabet.insert(Character(\"\
    d\"), at: 3)\n    alphabet.insert(Character(\"e\"), at: 4)\n    alphabet.insert(Character(\"\
    f\"), at: 5)\n    alphabet.insert(Character(\"g\"), at: 6)\n    alphabet.insert(Character(\"\
    h\"), at: 7)\n    alphabet.insert(Character(\"i\"), at: 8)\n    alphabet.insert(Character(\"\
    j\"), at: 9)\n    alphabet.insert(Character(\"k\"), at: 10)\n    alphabet.insert(Character(\"\
    l\"), at: 11)\n    alphabet.insert(Character(\"m\"), at: 12)\n    alphabet.insert(Character(\"\
    n\"), at: 13)\n    alphabet.insert(Character(\"o\"), at: 14)\n    alphabet.insert(Character(\"\
    p\"), at: 15)\n    alphabet.insert(Character(\"q\"), at: 16)\n    alphabet.insert(Character(\"\
    r\"), at: 17)\n    alphabet.insert(Character(\"s\"), at: 18)\n    alphabet.insert(Character(\"\
    t\"), at: 19)\n    alphabet.insert(Character(\"u\"), at: 20)\n    alphabet.insert(Character(\"\
    v\"), at: 21)\n    alphabet.insert(Character(\"w\"), at: 22)\n    alphabet.insert(Character(\"\
    x\"), at: 23)\n    alphabet.insert(Character(\"y\"), at: 24)\n    alphabet.insert(Character(\"\
    z\"), at: 25)\n    alphabet.insert(Character(\"A\"), at: 26)\n    alphabet.insert(Character(\"\
    B\"), at: 27)\n    alphabet.insert(Character(\"C\"), at: 28)\n    alphabet.insert(Character(\"\
    D\"), at: 29)\n    alphabet.insert(Character(\"E\"), at: 30)\n    alphabet.insert(Character(\"\
    F\"), at: 31)\n    alphabet.insert(Character(\"G\"), at: 32)\n    alphabet.insert(Character(\"\
    H\"), at: 33)\n    alphabet.insert(Character(\"I\"), at: 34)\n    alphabet.insert(Character(\"\
    J\"), at: 35)\n    alphabet.insert(Character(\"K\"), at: 36)\n    alphabet.insert(Character(\"\
    L\"), at: 37)\n    alphabet.insert(Character(\"M\"), at: 38)\n    alphabet.insert(Character(\"\
    N\"), at: 39)\n    alphabet.insert(Character(\"O\"), at: 40)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: '/tmp/tmp00l6bpl3.swift:54:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.sort()\n    alphabet.append(Character(\"z\"))\n    alphabet.append(Character(\"\
    a\"))\n    alphabet.append(Character(\"b\"))\n    alphabet.append(Character(\"\
    c\"))\n    alphabet.append(Character(\"d\"))\n    alphabet.append(Character(\"\
    e\"))\n    alphabet.append(Character(\"f\"))\n    alphabet.append(Character(\"\
    g\"))\n    alphabet.append(Character(\"h\"))\n    alphabet.append(Character(\"\
    i\"))\n    alphabet.append(Character(\"j\"))\n    alphabet.append(Character(\"\
    k\"))\n    alphabet.append(Character(\"l\"))\n    alphabet.append(Character(\"\
    m\"))\n    alphabet.append(Character(\"n\"))\n    alphabet.append(Character(\"\
    o\"))\n    alphabet.append(Character(\"p\"))\n    alphabet.append(Character(\"\
    q\"))\n    alphabet.append(Character(\"r\"))\n    alphabet.append(Character(\"\
    s\"))\n    alphabet.append(Character(\"t\"))\n    alphabet.append(Character(\"\
    u\"))\n    alphabet.append(Character(\"v\"))\n    alphabet.append(Character(\"\
    w\"))\n    alphabet.append(Character(\"x\"))\n    alphabet.append(Character(\"\
    y\"))\n    alphabet.append(Character(\"z\"))\n    alphabet.append(Character(\"\
    a\"))\n    alphabet.append(Character(\"b\"))\n    alphabet.append(Character(\"\
    c\"))\n    alphabet.append(Character(\"d\"))\n    alphabet.append(Character(\"\
    e\"))\n    alphabet.append(Character(\"f\"))\n    alphabet.append(Character(\"\
    g\"))\n    alphabet.append(Character(\"h\"))\n    alphabet.append(Character(\"\
    i\"))\n    alphabet.append(Character(\"j\"))\n    alphabet.append(Character(\"\
    k\"))\n    alphabet.append(Character(\"l\"))\n    alphabet.append(Character(\"\
    m\"))\n    alphabet.append(Character(\"n\"))\n    alphabet.append(Character(\"\
    o\"))\n    alphabet.append(Character(\"p\"))\n    alphabet.append(Character(\"\
    q\"))\n    alphabet.append(Character(\"r\"))\n    alphabet.append(Character(\"\
    s\"))\n    alphabet.append(Character(\"t\"))\n    alphabet.append(Character(\"\
    u\"))\n    alphabet.append(Character(\"v\"))\n    alphabet.append(Character(\"\
    w\"))\n    alphabet.append(Character(\"x\"))\n    alphabet.append(Character(\"\
    y\"))\n    alphabet.append(Character(\"z\"))\n    alphabet.append(Character(\"\
    a\"))\n    alphabet.append(Character(\"b\"))\n    alphabet.append(Character(\"\
    c\"))\n    alphabet.append(Character(\"d\"))\n    alphabet.append(Character(\"\
    e\"))\n    alphabet.append(Character(\"f\"))\n    alphabet.append(Character(\"\
    g\"))\n    alphabet.append(Character(\"h\"))\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpxgkowef1.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        result += alphabet[alphabet.index(c) + 2]\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpz4naxmt4.swift:14:19: error: cannot find 'alphabet' in scope\n\
    \        result += alphabet[alphabet.index(c) + 2]\n                  ^~~~~~~~\n\
    /tmp/tmpz4naxmt4.swift:14:28: error: cannot find 'alphabet' in scope\n       \
    \ result += alphabet[alphabet.index(c) + 2]\n                           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        result = result + alphabet[alphabet.IndexOf(c.ToUpper())\
    \ + 2]\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp5xfqy0po.swift:14:27: error: cannot find 'alphabet' in scope\n\
    \        result = result + alphabet[alphabet.IndexOf(c.ToUpper()) + 2]\n     \
    \                     ^~~~~~~~\n/tmp/tmp5xfqy0po.swift:14:36: error: cannot find\
    \ 'alphabet' in scope\n        result = result + alphabet[alphabet.IndexOf(c.ToUpper())\
    \ + 2]\n                                   ^~~~~~~~\n/tmp/tmp5xfqy0po.swift:14:55:\
    \ error: value of type 'Character' has no member 'ToUpper'\n        result = result\
    \ + alphabet[alphabet.IndexOf(c.ToUpper()) + 2]\n                            \
    \                        ~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        result = result + alphabet[alphabet.indexOf(c)\
    \ + 2]\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpbw4bcy9o.swift:14:27: error: cannot find 'alphabet' in scope\n\
    \        result = result + alphabet[alphabet.indexOf(c) + 2]\n               \
    \           ^~~~~~~~\n/tmp/tmpbw4bcy9o.swift:14:36: error: cannot find 'alphabet'\
    \ in scope\n        result = result + alphabet[alphabet.indexOf(c) + 2]\n    \
    \                               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 18)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 20)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 22)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 24)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 26)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 28)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 30)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 32)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 34)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 36)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 38)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 40)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 42)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 44)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 46)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 48)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 50)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 52)))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp0ag9gkho.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp0ag9gkho.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:23:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:24:41:\
    \ error: type"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        let index = alphabet.indexOf(c)\n        let\
    \ newIndex = index + 2\n        if newIndex < alphabet.count {\n            result\
    \ += alphabet[newIndex]\n        } else {\n            result += c\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpguz98d2l.swift:14:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.indexOf(c)\n                    ^~~~~~~~\n/tmp/tmpguz98d2l.swift:16:23:\
    \ error: cannot find 'alphabet' in scope\n        if newIndex < alphabet.count\
    \ {\n                      ^~~~~~~~\n/tmp/tmpguz98d2l.swift:17:23: error: cannot\
    \ find 'alphabet' in scope\n            result += alphabet[newIndex]\n       \
    \               ^~~~~~~~\n/tmp/tmpguz98d2l.swift:19:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ += c\n                      ^\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet = alphabet[1..<alphabet.count]\n    alphabet = alphabet[2..<alphabet.count]\n\
    \    alphabet = alphabet[3..<alphabet.count]\n    alphabet = alphabet[4..<alphabet.count]\n\
    \    alphabet = alphabet[5..<alphabet.count]\n    alphabet = alphabet[6..<alphabet.count]\n\
    \    alphabet = alphabet[7..<alphabet.count]\n    alphabet = alphabet[8..<alphabet.count]\n\
    \    alphabet = alphabet[9..<alphabet.count]\n    alphabet = alphabet[10..<alphabet.count]\n\
    \    alphabet = alphabet[11..<alphabet.count]\n    alphabet = alphabet[12..<alphabet.count]\n\
    \    alphabet = alphabet[13..<alphabet.count]\n    alphabet = alphabet[14..<alphabet.count]\n\
    \    alphabet = alphabet[15..<alphabet.count]\n    alphabet = alphabet[16..<alphabet.count]\n\
    \    alphabet = alphabet[17..<alphabet.count]\n    alphabet = alphabet[18..<alphabet.count]\n\
    \    alphabet = alphabet[19..<alphabet.count]\n    alphabet = alphabet[20..<alphabet.count]\n\
    \    alphabet = alphabet[21..<alphabet.count]\n    alphabet = alphabet[22..<alphabet.count]\n\
    \    alphabet = alphabet[23..<alphabet.count]\n    alphabet = alphabet[24..<alphabet.count]\n\
    \    alphabet = alphabet[25..<alphabet.count]\n    alphabet = alphabet[26..<alphabet.count]\n\
    \    alphabet = alphabet[27..<alphabet.count]\n    alphabet = alphabet[28..<alphabet.count]\n\
    \    alphabet = alphabet[29..<alphabet.count]\n    alphabet = alphabet[30..<alphabet.count]\n\
    \    alphabet = alphabet[31..<alphabet.count]\n    alphabet = alphabet[32..<alphabet.count]\n\
    \    alphabet = alphabet[33..<alphabet.count]\n    alphabet = alphabet[34..<alphabet.count]\n\
    \    alphabet = alphabet[35..<alphabet.count]\n    alphabet = alphabet[36..<alphabet.count]\n\
    \    alphabet = alphabet[37..<alphabet.count]\n    alphabet = alphabet[38..<alphabet.count]\n\
    \    alphabet = alphabet[39..<\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp_0tlkp7e.swift:55:1: error: expected ']' in expression list\n}\n\
    ^\n/tmp/tmp_0tlkp7e.swift:54:24: note: to match this opening '['\n    alphabet\
    \ = alphabet[39..<\n                       ^\n/tmp/tmp_0tlkp7e.swift:13:16: error:\
    \ 'characters' is unavailable: Please use String directly\n    for c in s.characters\
    \ {\n               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp_0tlkp7e.swift:16:24: error: cannot assign value of type 'ArraySlice<Character>'\
    \ to type '[Character]'\n    alphabet = alphabet[1..<alphabet.count]\n       \
    \        ~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp_0tlkp7e.swift:17:24: error: cannot\
    \ assign value of type 'ArraySlice<Character>' to type '[Character]'\n    alphabet\
    \ = alphabet[2..<alphabet.count]\n               ~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp_0tlkp7e.swift:18:24: error: cannot assign value of type 'ArraySlice<Character>'\
    \ to type '[Character]'\n    alphabet = alphabet[3..<alphabet.count]\n       \
    \        ~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp_0tlkp7e.swift:19:24: error: cannot\
    \ assign value of type 'ArraySlice<Character>' to type '[Character]'\n    alphabet\
    \ = alphabet[4..<alphabet.count]\n               ~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp_0tlkp7e.swift:20:24: error: cannot assign value of type 'ArraySlice<Character>'\
    \ to type '[Character]'\n    alphabet = alphabet[5..<alphabet.count]\n       \
    \        ~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp_0tlkp7e.swift:21:24: error: cannot\
    \ assign value of type 'ArraySlice<Character>' to type '[Character]'\n    alphabet\
    \ = alphabet[6..<alphabet.count]\n               ~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp_0tlkp7e.swift:22:24: error: cannot assign value of type 'ArraySlice<Character>'\
    \ to type '[Character]'\n    alphabet = alphabet[7..<alphabet.count]\n       \
    \        ~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp_0tlkp7e.swift:23:24: error: cannot\
    \ assign value of type 'ArraySlice<Character>' to type '[Character]'\n    alphabet\
    \ = alphabet[8..<alphabet.count]\n               ~~~~~~~~^~~~~~~~~~~~~"
  stdout: ''
  timestamp: 1659824986
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    alphabet.append(Character(\"a\"))\n    alphabet.append(Character(\"\
    b\"))\n    alphabet.append(Character(\"c\"))\n    alphabet.append(Character(\"\
    d\"))\n    alphabet.append(Character(\"e\"))\n    alphabet.append(Character(\"\
    f\"))\n    alphabet.append(Character(\"g\"))\n    alphabet.append(Character(\"\
    h\"))\n    alphabet.append(Character(\"i\"))\n    alphabet.append(Character(\"\
    j\"))\n    alphabet.append(Character(\"k\"))\n    alphabet.append(Character(\"\
    l\"))\n    alphabet.append(Character(\"m\"))\n    alphabet.append(Character(\"\
    n\"))\n    alphabet.append(Character(\"o\"))\n    alphabet.append(Character(\"\
    p\"))\n    alphabet.append(Character(\"q\"))\n    alphabet.append(Character(\"\
    r\"))\n    alphabet.append(Character(\"s\"))\n    alphabet.append(Character(\"\
    t\"))\n    alphabet.append(Character(\"u\"))\n    alphabet.append(Character(\"\
    v\"))\n    alphabet.append(Character(\"w\"))\n    alphabet.append(Character(\"\
    x\"))\n    alphabet.append(Character(\"y\"))\n    alphabet.append(Character(\"\
    z\"))\n    \n    var result = [Character]()\n    var i = 0\n    for c in s {\n\
    \        result.append(alphabet[(alphabet.count - i) % alphabet.count])\n    \
    \    i += 1\n    }\n    return String(result)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpr_m2spjd/tmpr_m2spjd.swift:62: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab6715c8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab6712bfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab6712bf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab6712be7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr_m2spjd                        0x000055789e57e6f7 <unavailable> + 5879

    5    libc.so.6                          0x00002ab6717b4460 __libc_start_main +
    245

    6    tmpr_m2spjd                        0x000055789e57e339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    a\".unicodeScalars.first!))\n    }\n    alphabet.append(Character(\"z\".unicodeScalars.first!))\n\
    \    \n    var result = \"\"\n    for c in s {\n        let index = alphabet.index(of:\
    \ c)!\n        let newIndex = index + 2\n        result += alphabet[newIndex]\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmps8xjxfxm.swift:20:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        let index = alphabet.index(of: c)!\n         \
    \                    ^\n/tmp/tmps8xjxfxm.swift:20:30: note: use 'firstIndex(of:)'\
    \ instead\n        let index = alphabet.index(of: c)!\n                      \
    \       ^~~~~\n                             firstIndex\n/tmp/tmps8xjxfxm.swift:22:27:\
    \ error: no exact matches in call to subscript \n        result += alphabet[newIndex]\n\
    \                          ^\nSwift.String:3:35: note: candidate expects value\
    \ of type 'String' for parameter #2 (got 'Character')\n    @inlinable public static\
    \ func += (lhs: inout String, rhs: String)\n                                 \
    \ ^\nSwift.Array:17:23: note: candidate expects value of type 'Range<Int>' for\
    \ parameter #1 (got 'Int')\n    @inlinable public subscript(bounds: Range<Int>)\
    \ -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\nSwift.MutableCollection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get set }\n                      ^\n/tmp/tmps8xjxfxm.swift:22:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        result += alphabet[newIndex]\n                          ^\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 18)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 20)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 22)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 24)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 26)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 28)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 30)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 32)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 34)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 36)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 38)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 40)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 42)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 44)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 46)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 48)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 50)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 52)))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp0ag9gkho.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp0ag9gkho.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:23:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:24:41:\
    \ error: type"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n\tlet alphabet\
    \ = s.characters\n\tlet alphabetLength = alphabet.count\n\tlet alphabetRotation\
    \ = alphabetLength / 2\n\tlet alphabetRotationOffset = alphabetLength - alphabetRotation\n\
    \tlet alphabetRotationOffset2 = alphabetRotationOffset * 2\n\tlet alphabetRotationOffset3\
    \ = alphabetRotationOffset2 * 2\n\tlet alphabetRotationOffset4 = alphabetRotationOffset3\
    \ * 2\n\tlet alphabetRotationOffset5 = alphabetRotationOffset4 * 2\n\tlet alphabetRotationOffset6\
    \ = alphabetRotationOffset5 * 2\n\tlet alphabetRotationOffset7 = alphabetRotationOffset6\
    \ * 2\n\tlet alphabetRotationOffset8 = alphabetRotationOffset7 * 2\n\tlet alphabetRotationOffset9\
    \ = alphabetRotationOffset8 * 2\n\tlet alphabetRotationOffset10 = alphabetRotationOffset9\
    \ * 2\n\tlet alphabetRotationOffset11 = alphabetRotationOffset10 * 2\n\tlet alphabetRotationOffset12\
    \ = alphabetRotationOffset11 * 2\n\tlet alphabetRotationOffset13 = alphabetRotationOffset12\
    \ * 2\n\tlet alphabetRotationOffset14 = alphabetRotationOffset13 * 2\n\tlet alphabetRotationOffset15\
    \ = alphabetRotationOffset14 * 2\n\tlet alphabetRotationOffset16 = alphabetRotationOffset15\
    \ * 2\n\tlet alphabetRotationOffset17 = alphabetRotationOffset16 * 2\n\tlet alphabetRotationOffset18\
    \ = alphabetRotationOffset17 * 2\n\tlet alphabetRotationOffset19 = alphabetRotationOffset18\
    \ * 2\n\tlet alphabetRotationOffset20 = alphabetRotationOffset19 * 2\n\tlet alphabetRotationOffset21\
    \ = alphabetRotationOffset20 * 2\n\tlet alphabetRotationOffset22 = alphabetRotationOffset21\
    \ * 2\n\tlet alphabetRotationOffset23 = alphabetRotationOffset22 * 2\n\tlet alphabetRotationOffset24\
    \ = alphabetRotationOffset23 * 2\n\tlet alphabetRotationOffset25 = alphabetRotationOffset24\
    \ * 2\n\tlet alphabetRotationOffset26 = alphabetRotationOffset25 * 2\n\tlet alphabetRotationOffset27\
    \ = alphabetRotationOffset26 * 2\n\tlet alphabetRotationOffset28 = alphabetRotationOffset27\
    \ * 2\n\tlet alphabetRotationOffset29 = alphabetRotationOffset28 * 2\n\tlet alphabetRotationOffset30\
    \ = alphabetRotationOffset29 * 2\n\tlet alphabetRotationOffset31 = alphabetRotationOffset30\
    \ * 2\n\tlet alphabetRotationOffset32 = alphabetRotationOffset31 * 2\n\tlet alphabetRotationOffset33\
    \ = alphabetRotationOffset32 * 2\n\tlet alphabetRotationOffset34 = alphabetRotationOffset33\
    \ * 2\n\tlet alphabetRotationOffset35 = alphabetRotationOffset34 * 2\n\tlet alphabetRotationOffset36\
    \ = alphabetRotationOffset35 * 2\n\tlet alphabet\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmprp7p9lw4.swift:12:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        let alphabet = s.characters\n                 \
    \        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmprp7p9lw4.swift:51:6:\
    \ error: type annotation missing in pattern\n        let alphabet\n          \
    \  ^\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetLength = alphabet.count\n\
    \    var alphabetRotated = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetRotatedLength\
    \ = alphabetRotated.count\n    var alphabetRotatedRotated = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    var alphabetRotatedRotatedLength = alphabetRotatedRotated.count\n    var\
    \ alphabetRotatedRotatedRotated = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetRotatedRotatedRotatedLength\
    \ = alphabetRotatedRotatedRotated.count\n    var alphabetRotatedRotatedRotatedRotated\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetRotatedRotatedRotatedRotatedLength\
    \ = alphabetRotatedRotatedRotatedRotated.count\n    var alphabetRotatedRotatedRotatedRotatedRotated\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetRotatedRotatedRotatedRotatedRotatedLength\
    \ = alphabetRotatedRotatedRotatedRotatedRotated.count\n    var alphabetRotatedRotatedRotatedRotatedRotatedRotated\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetRotatedRotatedRotatedRotatedRotatedRotatedLength\
    \ = alphabetRotatedRotatedRotatedRotatedRotatedRotated.count\n    var alphabetRotatedRotatedRotatedRotatedRotatedRotatedRotated\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetRotatedRotatedRotatedRotatedRotatedRotatedRotatedLength\
    \ = alphabetRotatedRotatedRotatedRotatedRotatedRotatedRotated.count\n    var alphabetRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotated\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedLength\
    \ = alphabetRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotated.count\n \
    \   var alphabetRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotated = \"\
    abcdefghijklmnopqrstuvwxyz\"\n    var alphabetRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedLength\
    \ = alphabetRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotated.count\n \
    \   var alphabetRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotated\
    \ = \"abcdefghijklmno\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpumvozwlw.swift:32:83: error: unterminated string literal\n    var\
    \ alphabetRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotated = \"\
    abcdefghijklmno\n                                                            \
    \                      ^\n/tmp/tmpumvozwlw.swift:30:9: error: invalid redeclaration\
    \ of 'alphabetRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotated'\n    var\
    \ alphabetRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotated = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        ^\n/tmp/tmpumvozwlw.swift:28:9: note: 'alphabetRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotated'\
    \ previously declared here\n    var alphabetRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotated\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        ^\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    alphabet.append(Character(UnicodeScalar(97)))\n    alphabet.append(Character(UnicodeScalar(65)))\n\
    \    alphabet.append(Character(UnicodeScalar(90)))\n    alphabet.append(Character(UnicodeScalar(48)))\n\
    \    alphabet.append(Character(UnicodeScalar(57)))\n    alphabet.append(Character(UnicodeScalar(65)))\n\
    \    alphabet.append(Character(UnicodeScalar(90)))\n    alphabet.append(Character(UnicodeScalar(48)))\n\
    \    alphabet.append(Character(UnicodeScalar(57)))\n    alphabet.append(Character(UnicodeScalar(65)))\n\
    \    alphabet.append(Character(UnicodeScalar(90)))\n    alphabet.append(Character(UnicodeScalar(48)))\n\
    \    alphabet.append(Character(UnicodeScalar(57)))\n    alphabet.append(Character(UnicodeScalar(65)))\n\
    \    alphabet.append(Character(UnicodeScalar(90)))\n    alphabet.append(Character(UnicodeScalar(48)))\n\
    \    alphabet.append(Character(UnicodeScalar(57)))\n    alphabet.append(Character(UnicodeScalar(65)))\n\
    \    alphabet.append(Character(UnicodeScalar(90)))\n    alphabet.append(Character(UnicodeScalar(48)))\n\
    \    alphabet.append(Character(UnicodeScalar(57)))\n    alphabet.append(Character(UnicodeScalar(65)))\n\
    \    alphabet.append(Character(UnicodeScalar(90)))\n    alphabet.append(Character(UnicodeScalar(48)))\n\
    \    alphabet.append(Character(UnicodeScalar(57)))\n    alphabet.append(Character(UnicodeScalar(65)))\n\
    \    alphabet.append(Character(UnicodeScalar(90)))\n    alphabet.append(Character(UnicodeScalar(48)))\n\
    \    alphabet.append(Character(UnicodeScalar(57)))\n    alphabet.append(Character(UnicodeScalar(65)))\n\
    \    alphabet.append(Character(UnicodeScalar(90)))\n    alphabet.append(Character(UnicodeScalar(48)))\n\
    \    alphabet.append(Character(UnicodeScalar(57)))\n    alphabet.append(Character(UnicodeScalar(65)))\n\
    \    alphabet.append(Character(UnicodeScalar(90)))\n    alphabet.append(Character(UnicodeScalar(48)))\n\
    \    alphabet.append(Character(UnicodeScalar(57)))\n    alphabet.append(Character(UnicodeScalar(65)))\n\
    \    alphabet.append(Character(UnicodeScalar(90)))\n    alphabet.append(Character(UnicodeScalar(48)))\n\
    \    alphabet.append(Character(UnicodeScalar(57)))\n    alphabet.append(Character(UnicodeScalar(65)))\n\
    \    alphabet.append(Character(UnicodeScalar(90)))\n    alphabet.append(Character(UnicodeScalar(48)))\n\
    \    alphabet.append(Character(UnicodeScalar(57)))\n    alphabet.append(Character(UnicodeScalar(65)))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: '/tmp/tmpvjc34_e3.swift:59:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.sort()\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 18)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 20)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 22)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 24)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 26)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 28)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 30)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 32)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 34)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 36)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 38)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 40)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 42)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 44)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 46)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 48)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 50)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpkud_fycw.swift:43:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpkud_fycw.swift:42:60: note: to match this opening '('\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt\n\
    \                                                           ^\n/tmp/tmpkud_fycw.swift:13:16:\
    \ error: 'characters' is unavailable: Please use String directly\n    for c in\
    \ s.characters {\n               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpkud_fycw.swift:17:41: error: type 'Character' has no\
    \ member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpkud_fycw.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpkud_fycw.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpkud_fycw.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpkud_fycw.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpkud_fycw.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpkud_fycw.swift:23:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    a\"))\n    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"b\"))\n\
    \    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"c\"))\n   \
    \ }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"d\"))\n    }\n\
    \    for _ in 0..<26 {\n        alphabet.append(Character(\"e\"))\n    }\n   \
    \ for _ in 0..<26 {\n        alphabet.append(Character(\"f\"))\n    }\n    for\
    \ _ in 0..<26 {\n        alphabet.append(Character(\"g\"))\n    }\n    for _ in\
    \ 0..<26 {\n        alphabet.append(Character(\"h\"))\n    }\n    for _ in 0..<26\
    \ {\n        alphabet.append(Character(\"i\"))\n    }\n    for _ in 0..<26 {\n\
    \        alphabet.append(Character(\"j\"))\n    }\n    for _ in 0..<26 {\n   \
    \     alphabet.append(Character(\"k\"))\n    }\n    for _ in 0..<26 {\n      \
    \  alphabet.append(Character(\"l\"))\n    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    m\"))\n    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"n\"))\n\
    \    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"o\"))\n   \
    \ }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"p\"))\n    }\n\
    \    for _ in 0..<26 {\n        alphabet.append(Character(\"q\"))\n    }\n   \
    \ for _ in 0..<26 {\n        alphabet.append(Character(\"r\"))\n    }\n    for\
    \ _ in 0..<26 {\n        alphabet.append(Character(\"s\"))\n    }\n    for _ in\
    \ 0..<26 {\n        alphabet.append(Character(\"t\"))\n    }\n    for _ in 0..<26\
    \ {\n        alphabet.append(Character(\"u\"))\n    }\n    for _ in 0..<26 {\n\
    \        alphabet.append(Character(\"v\"))\n    }\n    for _ in 0..<26 {\n   \
    \     alphabet.append(Character(\"w\"))\n    }\n    for _ in 0..<26 {\n      \
    \  alphabet.append(Character(\"x\"))\n    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    y\"))\n    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"z\"))\n\
    \    }\n    \n    var result = [Character]()\n    for c in s {\n        var index\
    \ = alphabet.index(of: c)!\n        index = index * 2\n        index = index +\
    \ 2\n        index = index % 26\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpmda8f3iv.swift:121:31: error: expected '}' at end of brace statement\n\
    assert(encrypt(s: \"a\") == \"e\")\n                              ^\n/tmp/tmpmda8f3iv.swift:11:35:\
    \ note: to match this opening '{'\nfunc encrypt(s: String) -> String {\n     \
    \                             ^\n/tmp/tmpmda8f3iv.swift:94:30: warning: 'index(of:)'\
    \ is deprecated: renamed to 'firstIndex(of:)'\n        var index = alphabet.index(of:\
    \ c)!\n                             ^\n/tmp/tmpmda8f3iv.swift:94:30: note: use\
    \ 'firstIndex(of:)' instead\n        var index = alphabet.index(of: c)!\n    \
    \                         ^~~~~\n                             firstIndex\n/tmp/tmpmda8f3iv.swift:102:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmpmda8f3iv.swift:92:9:\
    \ warning: initialization of variable 'result' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var result = [Character]()\n    ~~~~^~~~~~\n\
    \    _\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n\tlet alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n\tlet alphabetLength = alphabet.count\n\t\
    let alphabetLength = alphabet.characters.count\n\tlet alphabetLength = alphabet.utf8.count\n\
    \tlet alphabetLength = alphabet.unicodeScalars.count\n\tlet alphabetLength = alphabet.unicodeScalars.count\n\
    \tlet alphabetLength = alphabet.unicodeScalars.count\n\tlet alphabetLength = alphabet.unicodeScalars.count\n\
    \tlet alphabetLength = alphabet.unicodeScalars.count\n\tlet alphabetLength = alphabet.unicodeScalars.count\n\
    \tlet alphabetLength = alphabet.unicodeScalars.count\n\tlet alphabetLength = alphabet.unicodeScalars.count\n\
    \tlet alphabetLength = alphabet.unicodeScalars.count\n\tlet alphabetLength = alphabet.unicodeScalars.count\n\
    \tlet alphabetLength = alphabet.unicodeScalars.count\n\tlet alphabetLength = alphabet.unicodeScalars.count\n\
    \tlet alphabetLength = alphabet.unicodeScalars.count\n\tlet alphabetLength = alphabet.unicodeScalars.count\n\
    \tlet alphabetLength = alphabet.unicodeScalars.count\n\tlet alphabetLength = alphabet.unicodeScalars.count\n\
    \tlet alphabetLength = alphabet.unicodeScalars.count\n\tlet alphabetLength = alphabet.unicodeScalars.count\n\
    \tlet alphabetLength = alphabet.unicodeScalars.count\n\tlet alphabetLength = alphabet.unicodeScalars.count\n\
    \tlet alphabetLength = alphabet.unicodeScalars.count\n\tlet alphabetLength = alphabet.unicodeScalars.count\n\
    \tlet alphabetLength = alphabet.unicodeScalars.count\n\tlet alphabetLength = alphabet.unicodeScalars.count\n\
    \tlet alphabetLength = alphabet.unicodeScalars.count\n\tlet alphabetLength = alphabet.unicodeScalars.count\n\
    \tlet alphabetLength = alphabet.unicodeScalars.count\n\tlet alphabetLength = alphabet.unicodeScalars.count\n\
    \tlet alphabetLength = alphabet.unicodeScalars.count\n\tlet alphabetLength = alphabet.unicodeScalars.count\n\
    \tlet alphabetLength = alphabet.unicodeScalars.count\n\tlet alphabetLength = alphabet.unicodeScalars.count\n\
    \tlet alphabetLength = alphabet.unicodeScalars.count\n\tlet alphabetLength = alphabet.unicodeScalars.count\n\
    \tlet alphabetLength = alphabet.unicodeScalars.count\n\tlet alphabetLength = alphabet.unicodeScalars.count\n\
    \tlet alphabetLength = alphabet.unicodeScalars.count\n\tlet alphabetLength = alphabet.unicodeScalars.count\n\
    \tlet alphabetLength = alphabet.unicodeScalars.count\n\tlet alphabetLength = alphabet.unicodeScalars.count\n\
    \tlet alphabetLength = alphabet.unicodeScalars.count\n\tlet alphabetLength = alphabet.unicodeScalars.count\n\
    \tlet alphabetLength = alphabet.\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpeff59rgc.swift:58:31: error: expected member name following '.'\n\
    \        let alphabetLength = alphabet.\n                                    \
    \ ^\n/tmp/tmpeff59rgc.swift:14:32: error: 'characters' is unavailable: Please\
    \ use String directly\n        let alphabetLength = alphabet.characters.count\n\
    \                                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpeff59rgc.swift:14:6: error: invalid redeclaration of\
    \ 'alphabetLength'\n        let alphabetLength = alphabet.characters.count\n \
    \           ^\n/tmp/tmpeff59rgc.swift:13:6: note: 'alphabetLength' previously\
    \ declared here\n        let alphabetLength = alphabet.count\n            ^\n\
    /tmp/tmpeff59rgc.swift:15:6: error: invalid redeclaration of 'alphabetLength'\n\
    \        let alphabetLength = alphabet.utf8.count\n            ^\n/tmp/tmpeff59rgc.swift:13:6:\
    \ note: 'alphabetLength' previously declared here\n        let alphabetLength\
    \ = alphabet.count\n            ^\n/tmp/tmpeff59rgc.swift:16:6: error: invalid\
    \ redeclaration of 'alphabetLength'\n        let alphabetLength = alphabet.unicodeScalars.count\n\
    \            ^\n/tmp/tmpeff59rgc.swift:13:6: note: 'alphabetLength' previously\
    \ declared here\n        let alphabetLength = alphabet.count\n            ^\n\
    /tmp/tmpeff59rgc.swift:17:6: error: invalid redeclaration of 'alphabetLength'\n\
    \        let alphabetLength = alphabet.unicodeScalars.count\n            ^\n/tmp/tmpeff59rgc.swift:13:6:\
    \ note: 'alphabetLength' previously declared here\n        let alphabetLength\
    \ = alphabet.count\n            ^\n/tmp/tmpeff59rgc.swift:18:6: error: invalid\
    \ redeclaration of 'alphabetLength'\n        let alphabetLength = alphabet.unicodeScalars.count\n\
    \            ^\n/tmp/tmpeff59rgc.swift:13:6: note: 'alphabetLength' previously\
    \ declared here\n        let alphabetLength = alphabet.count\n            ^\n\
    /tmp/tmpeff59rgc.swift:19:6: error: invalid redeclaration of 'alphabetLength'\n\
    \        let alphabetLength = alphabet.unicodeScalars.count\n            ^\n/tmp/t"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 18)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 20)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 22)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 24)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 26)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 28)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 30)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 32)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 34)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 36)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 38)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 40)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 42)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 44)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 46)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 48)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 50)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 52)))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp0ag9gkho.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp0ag9gkho.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:23:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:24:41:\
    \ error: type"
  stdout: ''
  timestamp: 1659824987
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    a\".unicodeScalars.first!))\n    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    z\".unicodeScalars.first!))\n    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    A\".unicodeScalars.first!))\n    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    Z\".unicodeScalars.first!))\n    }\n    var result = [Character]()\n    for c\
    \ in s {\n        var index = alphabet.index(of: c)!\n        index = index *\
    \ 2\n        index = index + 2\n        index = index % 26\n        result.append(alphabet[index])\n\
    \    }\n    return String(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmp_eb9qg1b/tmp_eb9qg1b.swift:27: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002b5f0deb0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5f0dba7561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b5f0dba7286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b5f0dba713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b5f0dba6bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp_eb9qg1b                        0x00005573747ffb9d <unavailable> + 11165

    6    tmp_eb9qg1b                        0x00005573747fe8e6 <unavailable> + 6374

    7    libc.so.6                          0x00002b5f0e09c460 __libc_start_main +
    245

    8    tmp_eb9qg1b                        0x00005573747fe5e9 <unavailable> + 5609

    '
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        let index = alphabet.indexOf(c)\n        let\
    \ newIndex = index + 2\n        if newIndex < alphabet.count {\n            result\
    \ += alphabet[newIndex]\n        } else {\n            result += c\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpguz98d2l.swift:14:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.indexOf(c)\n                    ^~~~~~~~\n/tmp/tmpguz98d2l.swift:16:23:\
    \ error: cannot find 'alphabet' in scope\n        if newIndex < alphabet.count\
    \ {\n                      ^~~~~~~~\n/tmp/tmpguz98d2l.swift:17:23: error: cannot\
    \ find 'alphabet' in scope\n            result += alphabet[newIndex]\n       \
    \               ^~~~~~~~\n/tmp/tmpguz98d2l.swift:19:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ += c\n                      ^\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        result = result + alphabet[alphabet.index(c)\
    \ + 2]\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpi2k6kouw.swift:14:27: error: cannot find 'alphabet' in scope\n\
    \        result = result + alphabet[alphabet.index(c) + 2]\n                 \
    \         ^~~~~~~~\n/tmp/tmpi2k6kouw.swift:14:36: error: cannot find 'alphabet'\
    \ in scope\n        result = result + alphabet[alphabet.index(c) + 2]\n      \
    \                             ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 4)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 6)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 8)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 10)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 12)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 14)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 16)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 18)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 20)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 22)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 24)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 26)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 28)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 30)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 32)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 34)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 36)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 38)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 40)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 42)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 44)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 46)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 48)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 50)))\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpmoyyggnd.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpmoyyggnd.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmoyyggnd.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmoyyggnd.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 4)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmoyyggnd.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 6)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmoyyggnd.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 8)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmoyyggnd.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 10)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmoyyggnd.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 12)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmoyyggnd.swift:23:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 14)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmoyyggnd.swift:24:41:\
    \ error: type "
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        let index = alphabet.indexOf(c)\n        let\
    \ newIndex = index + 2\n        if newIndex < alphabet.count {\n            result\
    \ += alphabet[newIndex]\n        } else {\n            result += alphabet[0]\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpb36jwadj.swift:14:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.indexOf(c)\n                    ^~~~~~~~\n/tmp/tmpb36jwadj.swift:16:23:\
    \ error: cannot find 'alphabet' in scope\n        if newIndex < alphabet.count\
    \ {\n                      ^~~~~~~~\n/tmp/tmpb36jwadj.swift:17:23: error: cannot\
    \ find 'alphabet' in scope\n            result += alphabet[newIndex]\n       \
    \               ^~~~~~~~\n/tmp/tmpb36jwadj.swift:19:23: error: cannot find 'alphabet'\
    \ in scope\n            result += alphabet[0]\n                      ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    alphabet.append(Character(\"a\"))\n    alphabet.append(Character(\"\
    b\"))\n    alphabet.append(Character(\"c\"))\n    alphabet.append(Character(\"\
    d\"))\n    alphabet.append(Character(\"e\"))\n    alphabet.append(Character(\"\
    f\"))\n    alphabet.append(Character(\"g\"))\n    alphabet.append(Character(\"\
    h\"))\n    alphabet.append(Character(\"i\"))\n    alphabet.append(Character(\"\
    j\"))\n    alphabet.append(Character(\"k\"))\n    alphabet.append(Character(\"\
    l\"))\n    alphabet.append(Character(\"m\"))\n    alphabet.append(Character(\"\
    n\"))\n    alphabet.append(Character(\"o\"))\n    alphabet.append(Character(\"\
    p\"))\n    alphabet.append(Character(\"q\"))\n    alphabet.append(Character(\"\
    r\"))\n    alphabet.append(Character(\"s\"))\n    alphabet.append(Character(\"\
    t\"))\n    alphabet.append(Character(\"u\"))\n    alphabet.append(Character(\"\
    v\"))\n    alphabet.append(Character(\"w\"))\n    alphabet.append(Character(\"\
    x\"))\n    alphabet.append(Character(\"y\"))\n    alphabet.append(Character(\"\
    z\"))\n    alphabet.append(Character(\"A\"))\n    alphabet.append(Character(\"\
    B\"))\n    alphabet.append(Character(\"C\"))\n    alphabet.append(Character(\"\
    D\"))\n    alphabet.append(Character(\"E\"))\n    alphabet.append(Character(\"\
    F\"))\n    alphabet.append(Character(\"G\"))\n    alphabet.append(Character(\"\
    H\"))\n    alphabet.append(Character(\"I\"))\n    alphabet.append(Character(\"\
    J\"))\n    alphabet.append(Character(\"K\"))\n    alphabet.append(Character(\"\
    L\"))\n    alphabet.append(Character(\"M\"))\n    alphabet.append(Character(\"\
    N\"))\n    alphabet.append(Character(\"O\"))\n    alphabet.append(Character(\"\
    P\"))\n    alphabet.append(Character(\"Q\"))\n    alphabet.append(Character(\"\
    R\"))\n    alphabet.append(Character(\"S\"))\n    alphabet.append(Character(\"\
    T\"))\n    alphabet.append(Character(\"U\"))\n    alphabet.append(Character(\"\
    V\"))\n    alphabet.append(Character(\"W\"))\n    alphabet.append(Character(\"\
    X\"))\n    alphabet.append(Character(\"Y\"))\n    alphabet.append(Character(\"\
    Z\"))\n    \n    var newString = \"\"\n    for c in s {\n        var index = alphabet.index(of:\
    \ c)!\n        index = index * 2\n        index = index + 1\n        index = index\
    \ % alphabet.count\n        newString = newString + alphabet[index]\n    }\n \
    \   return newString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpxxgegkz9.swift:68:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        var index = alphabet.index(of: c)!\n         \
    \                    ^\n/tmp/tmpxxgegkz9.swift:68:30: note: use 'firstIndex(of:)'\
    \ instead\n        var index = alphabet.index(of: c)!\n                      \
    \       ^~~~~\n                             firstIndex\n/tmp/tmpxxgegkz9.swift:72:41:\
    \ error: no exact matches in call to subscript \n        newString = newString\
    \ + alphabet[index]\n                                        ^\nSwift.String:2:35:\
    \ note: candidate expects value of type 'String' for parameter #2 (got 'Character')\n\
    \    @inlinable public static func + (lhs: String, rhs: String) -> String\n  \
    \                                ^\nSwift.Array:17:23: note: candidate expects\
    \ value of type 'Range<Int>' for parameter #1 (got 'Array<Character>.Index' (aka\
    \ 'Int'))\n    @inlinable public subscript(bounds: Range<Int>) -> ArraySlice<Element>\
    \ { get set }\n                      ^\nSwift.Collection:3:23: note: candidate\
    \ expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Array<Character>.Index'\
    \ (aka 'Int'))\n    @inlinable public subscript(x: (UnboundedRange_) -> ()) ->\
    \ Self.SubSequence { get }\n                      ^\nSwift.MutableCollection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Array<Character>.Index' (aka 'Int'))\n    @inlinable public subscript(x:\
    \ (UnboundedRange_) -> ()) -> Self.SubSequence { get set }\n                 \
    \     ^\n/tmp/tmpxxgegkz9.swift:72:41: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        newString = newString + alphabet[index]\n\
    \                                        ^\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpwwz01jmv.swift:64:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpwwz01jmv.swift:13:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.first!))\n                        \
    \      ^\n                              extendedGraphemeClusterLiteral: \n/tmp/tmpwwz01jmv.swift:14:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpwwz01jmv.swift:15:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpwwz01jmv.swift:16:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpwwz01jmv.swift:17:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpwwz01jmv.swift:18:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpwwz01jmv.swift:19:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpwwz01jmv.swift:20:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpwwz01jmv.swift:21:31:\
    \ error: missing argument label 'exte"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 18)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 20)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 22)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 24)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 26)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 28)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 30)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 32)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 34)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 36)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 38)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 40)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 42)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 44)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 46)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 48)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 50)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 52)))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp0ag9gkho.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp0ag9gkho.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:23:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:24:41:\
    \ error: type"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        var index = alphabet.indexOf(c)\n        index\
    \ = index / 2\n        index = index * 2\n        index = index + alphabet.indexOf(\"\
    a\")\n        result += alphabet[index]\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpn3sddkjp.swift:14:21: error: cannot find 'alphabet' in scope\n\
    \        var index = alphabet.indexOf(c)\n                    ^~~~~~~~\n/tmp/tmpn3sddkjp.swift:17:25:\
    \ error: cannot find 'alphabet' in scope\n        index = index + alphabet.indexOf(\"\
    a\")\n                        ^~~~~~~~\n/tmp/tmpn3sddkjp.swift:18:19: error: cannot\
    \ find 'alphabet' in scope\n        result += alphabet[index]\n              \
    \    ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 18)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 20)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 22)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 24)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 26)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 28)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 30)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 32)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 34)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 36)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 38)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 40)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 42)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 44)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 46)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 48)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 50)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 52)))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp0ag9gkho.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp0ag9gkho.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:23:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:24:41:\
    \ error: type"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 18)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 20)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 22)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 24)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 26)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 28)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 30)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 32)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 34)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 36)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 38)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 40)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 42)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 44)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 46)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 48)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 50)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 52)))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp0ag9gkho.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp0ag9gkho.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:23:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:24:41:\
    \ error: type"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 18)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 20)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 22)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 24)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 26)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 28)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 30)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 32)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 34)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 36)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 38)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 40)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 42)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 44)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 46)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 48)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 50)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 52)))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp0ag9gkho.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp0ag9gkho.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:23:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:24:41:\
    \ error: type"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.sort()\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n    alphabet.sort()\n    var result = [Character]()\n    for c in s.characters\
    \ {\n        var index = alphabet.indexOf(c)\n        if index != -1 {\n     \
    \       result.append(alphabet[(index + 2) % alphabet.count])\n        } else\
    \ {\n            result.append(c)\n        }\n    }\n    return String(result)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpssxhcxrg.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpssxhcxrg.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpssxhcxrg.swift:20:16:\
    \ error: 'characters' is unavailable: Please use String directly\n    for c in\
    \ s.characters {\n               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpssxhcxrg.swift:21:30: error: value of type '[Character]'\
    \ has no member 'indexOf'\n        var index = alphabet.indexOf(c)\n         \
    \           ~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    a\".unicodeScalars.first!))\n    }\n    alphabet.append(Character(\"z\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"A\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    Z\".unicodeScalars.first!))\n    alphabet.append(Character(\"0\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"9\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    _\".unicodeScalars.first!))\n    alphabet.append(Character(\"a\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"b\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    c\".unicodeScalars.first!))\n    alphabet.append(Character(\"d\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"e\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    f\".unicodeScalars.first!))\n    alphabet.append(Character(\"g\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"h\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    i\".unicodeScalars.first!))\n    alphabet.append(Character(\"j\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"k\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    l\".unicodeScalars.first!))\n    alphabet.append(Character(\"m\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"n\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    o\".unicodeScalars.first!))\n    alphabet.append(Character(\"p\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"q\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    r\".unicodeScalars.first!))\n    alphabet.append(Character(\"s\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"t\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    u\".unicodeScalars.first!))\n    alphabet.append(Character(\"v\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"w\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    x\".unicodeScalars.first!))\n    alphabet.append(Character(\"y\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"z\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    0\".unicodeScalars.first!))\n    alphabet.append(Character(\"1\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpaahnkbfn.swift:50:31: error: unterminated string literal\n    alphabet.append(Character(\"\
    \n                              ^\n/tmp/tmpaahnkbfn.swift:50:31: error: missing\
    \ argument for parameter #1 in call\n    alphabet.append(Character(\"\n      \
    \                        ^\n                              <#Unicode.Scalar#>\n\
    Swift.Character:2:23: note: 'init(_:)' declared here\n    @inlinable public init(_\
    \ content: Unicode.Scalar)\n                      ^\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for letter in s {\n        let index = alphabet.index(of: letter)!\n\
    \        let newIndex = index + 2\n        let newLetter = alphabet[newIndex]\n\
    \        result += newLetter\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpbzbgipei.swift:14:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)!\n                    ^~~~~~~~\n\
    /tmp/tmpbzbgipei.swift:16:25: error: cannot find 'alphabet' in scope\n       \
    \ let newLetter = alphabet[newIndex]\n                        ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        let index = alphabet.indexOf(c)\n        let\
    \ newIndex = index + 2\n        if newIndex < alphabet.count {\n            result\
    \ += alphabet[newIndex]\n        } else {\n            result += alphabet[0]\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpb36jwadj.swift:14:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.indexOf(c)\n                    ^~~~~~~~\n/tmp/tmpb36jwadj.swift:16:23:\
    \ error: cannot find 'alphabet' in scope\n        if newIndex < alphabet.count\
    \ {\n                      ^~~~~~~~\n/tmp/tmpb36jwadj.swift:17:23: error: cannot\
    \ find 'alphabet' in scope\n            result += alphabet[newIndex]\n       \
    \               ^~~~~~~~\n/tmp/tmpb36jwadj.swift:19:23: error: cannot find 'alphabet'\
    \ in scope\n            result += alphabet[0]\n                      ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        result += alphabet[alphabet.IndexOf(c) + 2]\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpbuxm9wax.swift:14:19: error: cannot find 'alphabet' in scope\n\
    \        result += alphabet[alphabet.IndexOf(c) + 2]\n                  ^~~~~~~~\n\
    /tmp/tmpbuxm9wax.swift:14:28: error: cannot find 'alphabet' in scope\n       \
    \ result += alphabet[alphabet.IndexOf(c) + 2]\n                           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    a\"))\n    }\n    alphabet.append(Character(\"z\"))\n    \n    var result = [Character]()\n\
    \    for c in s {\n        let index = alphabet.index(of: c)!\n        let newIndex\
    \ = index + 2\n        result.append(alphabet[newIndex])\n    }\n    return String(result)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpzkgj5j3a/tmpzkgj5j3a.swift:20: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002b6e49176c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6e48e6d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b6e48e6d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b6e48e6d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b6e48e6cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpzkgj5j3a                        0x000055ce1d1e3373 <unavailable> + 9075

    6    tmpzkgj5j3a                        0x000055ce1d1e27b6 <unavailable> + 6070

    7    libc.so.6                          0x00002b6e49362460 __libc_start_main +
    245

    8    tmpzkgj5j3a                        0x000055ce1d1e24b9 <unavailable> + 5305

    '
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    alphabet.append(Character(UnicodeScalar(97)))\n    alphabet.append(Character(UnicodeScalar(65)))\n\
    \    alphabet.append(Character(UnicodeScalar(97)))\n    alphabet.append(Character(UnicodeScalar(65)))\n\
    \    alphabet.append(Character(UnicodeScalar(97)))\n    alphabet.append(Character(UnicodeScalar(65)))\n\
    \    alphabet.append(Character(UnicodeScalar(97)))\n    alphabet.append(Character(UnicodeScalar(65)))\n\
    \    alphabet.append(Character(UnicodeScalar(97)))\n    alphabet.append(Character(UnicodeScalar(65)))\n\
    \    alphabet.append(Character(UnicodeScalar(97)))\n    alphabet.append(Character(UnicodeScalar(65)))\n\
    \    alphabet.append(Character(UnicodeScalar(97)))\n    alphabet.append(Character(UnicodeScalar(65)))\n\
    \    alphabet.append(Character(UnicodeScalar(97)))\n    alphabet.append(Character(UnicodeScalar(65)))\n\
    \    alphabet.append(Character(UnicodeScalar(97)))\n    alphabet.append(Character(UnicodeScalar(65)))\n\
    \    alphabet.append(Character(UnicodeScalar(97)))\n    alphabet.append(Character(UnicodeScalar(65)))\n\
    \    alphabet.append(Character(UnicodeScalar(97)))\n    alphabet.append(Character(UnicodeScalar(65)))\n\
    \    alphabet.append(Character(UnicodeScalar(97)))\n    alphabet.append(Character(UnicodeScalar(65)))\n\
    \    alphabet.append(Character(UnicodeScalar(97)))\n    alphabet.append(Character(UnicodeScalar(65)))\n\
    \    alphabet.append(Character(UnicodeScalar(97)))\n    alphabet.append(Character(UnicodeScalar(65)))\n\
    \    alphabet.append(Character(UnicodeScalar(97)))\n    alphabet.append(Character(UnicodeScalar(65)))\n\
    \    alphabet.append(Character(UnicodeScalar(97)))\n    alphabet.append(Character(UnicodeScalar(65)))\n\
    \    alphabet.append(Character(UnicodeScalar(97)))\n    alphabet.append(Character(UnicodeScalar(65)))\n\
    \    alphabet.append(Character(UnicodeScalar(97)))\n    alphabet.append(Character(UnicodeScalar(65)))\n\
    \    alphabet.append(Character(UnicodeScalar(97)))\n    alphabet.append(Character(UnicodeScalar(65)))\n\
    \    alphabet.append(Character(UnicodeScalar(97)))\n    alphabet.append(Character(UnicodeScalar(65)))\n\
    \    alphabet.append(Character(UnicodeScalar(97)))\n    alphabet.append(Character(UnicodeScalar(65)))\n\
    \    alphabet.append(Character(UnicodeScalar(97)))\n    alphabet.append(Character(UnicodeScalar(65)))\n\
    \    alphabet.append(Character(UnicodeScalar(97)))\n    alphabet.append(Character(UnicodeScalar(65)))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: '/tmp/tmpv9apwkns.swift:59:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 18)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 20)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 22)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 24)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 26)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 28)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 30)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 32)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 34)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 36)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 38)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 40)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 42)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 44)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 46)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 48)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 50)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 52)))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp0ag9gkho.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp0ag9gkho.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:23:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:24:41:\
    \ error: type"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        result = result + alphabet[alphabet.IndexOf(c)\
    \ + 2]\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp241dvynn.swift:14:27: error: cannot find 'alphabet' in scope\n\
    \        result = result + alphabet[alphabet.IndexOf(c) + 2]\n               \
    \           ^~~~~~~~\n/tmp/tmp241dvynn.swift:14:36: error: cannot find 'alphabet'\
    \ in scope\n        result = result + alphabet[alphabet.IndexOf(c) + 2]\n    \
    \                               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for letter in s {\n        result = result + alphabet[alphabet.index(letter,\
    \ offsetBy: 2)] + letter\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpvh0i_z7v.swift:14:27: error: cannot find 'alphabet' in scope\n\
    \        result = result + alphabet[alphabet.index(letter, offsetBy: 2)] + letter\n\
    \                          ^~~~~~~~\n/tmp/tmpvh0i_z7v.swift:14:36: error: cannot\
    \ find 'alphabet' in scope\n        result = result + alphabet[alphabet.index(letter,\
    \ offsetBy: 2)] + letter\n                                   ^~~~~~~~\n/tmp/tmpvh0i_z7v.swift:14:75:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        result = result + alphabet[alphabet.index(letter, offsetBy: 2)] + letter\n\
    \                                                                          ^\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        let index = alphabet.indexOf(c)\n        let\
    \ newIndex = index + 2\n        if newIndex < alphabet.count {\n            result\
    \ += alphabet[newIndex]\n        } else {\n            result += alphabet[0]\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpb36jwadj.swift:14:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.indexOf(c)\n                    ^~~~~~~~\n/tmp/tmpb36jwadj.swift:16:23:\
    \ error: cannot find 'alphabet' in scope\n        if newIndex < alphabet.count\
    \ {\n                      ^~~~~~~~\n/tmp/tmpb36jwadj.swift:17:23: error: cannot\
    \ find 'alphabet' in scope\n            result += alphabet[newIndex]\n       \
    \               ^~~~~~~~\n/tmp/tmpb36jwadj.swift:19:23: error: cannot find 'alphabet'\
    \ in scope\n            result += alphabet[0]\n                      ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n\tlet alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n\tlet alphabetLength = alphabet.characters.count\n\
    \tlet alphabetLength = alphabet.characters.count\n\tlet alphabetLength = alphabet.characters.count\n\
    \tlet alphabetLength = alphabet.characters.count\n\tlet alphabetLength = alphabet.characters.count\n\
    \tlet alphabetLength = alphabet.characters.count\n\tlet alphabetLength = alphabet.characters.count\n\
    \tlet alphabetLength = alphabet.characters.count\n\tlet alphabetLength = alphabet.characters.count\n\
    \tlet alphabetLength = alphabet.characters.count\n\tlet alphabetLength = alphabet.characters.count\n\
    \tlet alphabetLength = alphabet.characters.count\n\tlet alphabetLength = alphabet.characters.count\n\
    \tlet alphabetLength = alphabet.characters.count\n\tlet alphabetLength = alphabet.characters.count\n\
    \tlet alphabetLength = alphabet.characters.count\n\tlet alphabetLength = alphabet.characters.count\n\
    \tlet alphabetLength = alphabet.characters.count\n\tlet alphabetLength = alphabet.characters.count\n\
    \tlet alphabetLength = alphabet.characters.count\n\tlet alphabetLength = alphabet.characters.count\n\
    \tlet alphabetLength = alphabet.characters.count\n\tlet alphabetLength = alphabet.characters.count\n\
    \tlet alphabetLength = alphabet.characters.count\n\tlet alphabetLength = alphabet.characters.count\n\
    \tlet alphabetLength = alphabet.characters.count\n\tlet alphabetLength = alphabet.characters.count\n\
    \tlet alphabetLength = alphabet.characters.count\n\tlet alphabetLength = alphabet.characters.count\n\
    \tlet alphabetLength = alphabet.characters.count\n\tlet alphabetLength = alphabet.characters.count\n\
    \tlet alphabetLength = alphabet.characters.count\n\tlet alphabetLength = alphabet.characters.count\n\
    \tlet alphabetLength = alphabet.characters.count\n\tlet alphabetLength = alphabet.characters.count\n\
    \tlet alphabetLength = alphabet.characters.count\n\tlet alphabetLength = alphabet.characters.count\n\
    \tlet alphabetLength = alphabet.characters.count\n\tlet alphabetLength = alphabet.characters.count\n\
    \tlet alphabetLength = alphabet.characters.count\n\tlet alphabetLength = alphabet.characters.count\n\
    \tlet alphabetLength = alphabet.characters.count\n\tlet alphabetLength = alphabet.characters.count\n\
    \tlet alphabetLength = alphabet.characters.count\n\tlet alphabetLength = alphabet.characters.count\n\
    \tlet alphabetLength = alphabet.characters.count\n\tlet alphabetLength = alphabet.characters.count\n\
    \tlet alphabetLength = alphabet.characters.count\n\tlet alphabetLength = alphabet.characters.count\n\
    \tlet alphabetLength = alphabet.characters.count\n\tlet alphabetLength = alphabet.characters.count\n\
    \tlet alphabetLength = alphabet.characters.count\n\tlet alphabetLength = alphabet.characters.count\n\
    \tlet alphabetLength = alphabet.characters.count\n\tlet alphabetLength = alphabet.characters.count\n\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpej2ka4or.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n        let alphabetLength = alphabet.characters.count\n\
    \                                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpej2ka4or.swift:14:32: error: 'characters' is unavailable:\
    \ Please use String directly\n        let alphabetLength = alphabet.characters.count\n\
    \                                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpej2ka4or.swift:14:6: error: invalid redeclaration of\
    \ 'alphabetLength'\n        let alphabetLength = alphabet.characters.count\n \
    \           ^\n/tmp/tmpej2ka4or.swift:13:6: note: 'alphabetLength' previously\
    \ declared here\n        let alphabetLength = alphabet.characters.count\n    \
    \        ^\n/tmp/tmpej2ka4or.swift:15:32: error: 'characters' is unavailable:\
    \ Please use String directly\n        let alphabetLength = alphabet.characters.count\n\
    \                                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpej2ka4or.swift:15:6: error: invalid redeclaration of\
    \ 'alphabetLength'\n        let alphabetLength = alphabet.characters.count\n \
    \           ^\n/tmp/tmpej2ka4or.swift:13:6: note: 'alphabetLength' previously\
    \ declared here\n        let alphabetLength = alphabet.characters.count\n    \
    \        ^\n/tmp/tmpej2ka4or.swift:16:32: error: 'characters' is unavailable:\
    \ Please use String directly\n        let alphabetLength = alphabet.characters.count\n\
    \                                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpej2ka4or.swift:16:6: error: invalid redeclaration of\
    \ 'alphabetLength'\n        let alphabetLength = alphabet.characters.count\n \
    \           ^\n/tmp/tmpej2ka4o"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 18)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 20)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 22)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 24)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 26)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 28)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 30)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 32)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 34)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 36)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 38)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 40)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 42)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 44)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 46)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 48)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 50)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 52)))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp0ag9gkho.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp0ag9gkho.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:23:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:24:41:\
    \ error: type"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    a\"))\n    }\n    alphabet.append(Character(\"z\"))\n    alphabet.append(Character(\"\
    A\"))\n    alphabet.append(Character(\"Z\"))\n    alphabet.append(Character(\"\
    0\"))\n    alphabet.append(Character(\"1\"))\n    alphabet.append(Character(\"\
    2\"))\n    alphabet.append(Character(\"3\"))\n    alphabet.append(Character(\"\
    4\"))\n    alphabet.append(Character(\"5\"))\n    alphabet.append(Character(\"\
    6\"))\n    alphabet.append(Character(\"7\"))\n    alphabet.append(Character(\"\
    8\"))\n    alphabet.append(Character(\"9\"))\n    alphabet.append(Character(\"\
    _\"))\n    alphabet.append(Character(\"$\"))\n    alphabet.append(Character(\"\
    %\"))\n    alphabet.append(Character(\"!\"))\n    alphabet.append(Character(\"\
    @\"))\n    alphabet.append(Character(\"(\"))\n    alphabet.append(Character(\"\
    )\"))\n    alphabet.append(Character(\",\"))\n    alphabet.append(Character(\"\
    -\"))\n    alphabet.append(Character(\".\"))\n    alphabet.append(Character(\"\
    /\"))\n    alphabet.append(Character(\":\"))\n    alphabet.append(Character(\"\
    ;\"))\n    alphabet.append(Character(\"<\"))\n    alphabet.append(Character(\"\
    >\"))\n    alphabet.append(Character(\"?\"))\n    alphabet.append(Character(\"\
    '\"))\n    alphabet.append(Character(\"\\\"\"))\n    alphabet.append(Character(\"\
    [\"))\n    alphabet.append(Character(\"]\"))\n    alphabet.append(Character(\"\
    {\"))\n    alphabet.append(Character(\"}\"))\n    alphabet.append(Character(\"\
    =\"))\n    alphabet.append(Character(\"~\"))\n    alphabet.append(Character(\"\
    !\"))\n    alphabet.append(Character(\"@\"))\n    alphabet.append(Character(\"\
    (\"))\n    alphabet.append(Character(\")\"))\n    alphabet.append(Character(\"\
    ,\"))\n    alphabet.append(Character(\"-\"))\n    alphabet.append(Character(\"\
    .\"))\n    alphabet.append(Character(\"/\"))\n    alphabet.append(Character(\"\
    :\"))\n    alphabet.append(Character(\";\"))\n    alphabet.append(Character(\"\
    <\"))\n    alphabet.append(Character(\">\"))\n    alphabet.append(Character(\"\
    ?\"))\n    alphabet.append(Character(\"'\"))\n    alphabet.append(Character(\"\
    \\\"\"))\n    alphabet.append(Character(\"[\"))\n    alphabet.append(Character(\"\
    ]\"))\n    alphabet.append(Character(\"{\"))\n    alphabet.append(Character(\"\
    }\"))\n    alphabet.append(Character(\"=\"))\n    alphabet.append(Character(\"\
    ~\"))\n    alphabet.append(Character(\"!\"))\n    alphabet.append(Character(\"\
    @\"))\n    alphabet.append(Character(\"(\"))\n    alphabet.append(Character(\"\
    )\"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") == \"\
    lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"\
    gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\"\
    ) == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\"\
    )\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"a\") ==\
    \ \"e\")"
  status: SyntaxError
  stderr: '/tmp/tmppmcwtvzc.swift:78:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.sort()\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp50zplqf_.swift:46:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmp50zplqf_.swift:45:54: note: to match this opening '('\n    alphabet.append(Character(Character.UnicodeScalar(UInt\n\
    \                                                     ^\n/tmp/tmp50zplqf_.swift:13:16:\
    \ error: 'characters' is unavailable: Please use String directly\n    for c in\
    \ s.characters {\n               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp50zplqf_.swift:17:41: error: type 'Character' has no\
    \ member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count))))\n\
    \                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp50zplqf_.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count))))\n\
    \                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp50zplqf_.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count))))\n\
    \                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp50zplqf_.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count))))\n\
    \                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp50zplqf_.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count))))\n\
    \                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp50zplqf_.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count))))\n\
    \                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp50zplqf_.swift:23:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count))))\n\
    \                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/t"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        result = result + alphabet[alphabet.IndexOf(c)\
    \ + 2]\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp241dvynn.swift:14:27: error: cannot find 'alphabet' in scope\n\
    \        result = result + alphabet[alphabet.IndexOf(c) + 2]\n               \
    \           ^~~~~~~~\n/tmp/tmp241dvynn.swift:14:36: error: cannot find 'alphabet'\
    \ in scope\n        result = result + alphabet[alphabet.IndexOf(c) + 2]\n    \
    \                               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for _ in 0..<26 {\n        alphabet.append(Character(UnicodeScalar(UInt32(97\
    \ + _))))\n    }\n    var result = \"\"\n    for c in s {\n        result += alphabet[(alphabet.index(of:\
    \ c) + 2) % 26]\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp5v4ys36c.swift:14:61: error: '_' can only appear in a pattern or\
    \ on the left side of an assignment\n        alphabet.append(Character(UnicodeScalar(UInt32(97\
    \ + _))))\n                                                            ^\n/tmp/tmp5v4ys36c.swift:18:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        result += alphabet[(alphabet.index(of: c) + 2) % 26]\n              \
    \            ^\n/tmp/tmp5v4ys36c.swift:18:27: error: no exact matches in call\
    \ to subscript \n        result += alphabet[(alphabet.index(of: c) + 2) % 26]\n\
    \                          ^\n/tmp/tmp5v4ys36c.swift:18:27: note: candidate has\
    \ partially matching parameter list (Int)\n        result += alphabet[(alphabet.index(of:\
    \ c) + 2) % 26]\n                          ^\n/tmp/tmp5v4ys36c.swift:18:27: note:\
    \ candidate expects value of type 'Range<Int>' for parameter #1 (got 'Int')\n\
    \        result += alphabet[(alphabet.index(of: c) + 2) % 26]\n              \
    \            ^\n/tmp/tmp5v4ys36c.swift:18:27: note: candidate expects value of\
    \ type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n        result\
    \ += alphabet[(alphabet.index(of: c) + 2) % 26]\n                          ^\n\
    /tmp/tmp5v4ys36c.swift:18:27: note: candidate expects value of type '(UnboundedRange_)\
    \ -> ()' for parameter #1 (got 'Int')\n        result += alphabet[(alphabet.index(of:\
    \ c) + 2) % 26]\n                          ^\n/tmp/tmp5v4ys36c.swift:18:38: error:\
    \ value of optional type 'Array<Character>.Index?' (aka 'Optional<Int>') must\
    \ be unwrapped to a value of type 'Array<Character>.Index' (aka 'Int')\n     \
    \   result += alphabet[(alphabet.index(of: c) + 2) % 26]\n                   \
    \                  ^\n/tmp/tmp5v4ys36c.swift:18:38: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n        result\
    \ += alphabet[(alphabet.index(of: c) + 2) % 26]\n                            \
    \         ^\n                            (                     ?? <#default value#>)\n\
    /tmp/tmp5v4ys36c.swift:18:38: note: force-unwrap using '!' to abort execut"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 18)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 20)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 22)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 24)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 26)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 28)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 30)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 32)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 34)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 36)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 38)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 40)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 42)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 44)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 46)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 48)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 50)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 52)))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp0ag9gkho.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp0ag9gkho.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:23:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:24:41:\
    \ error: type"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for letter in s {\n        result = result + alphabet[alphabet.index(letter)!\
    \ + 2]\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp2j5k4cql.swift:14:27: error: cannot find 'alphabet' in scope\n\
    \        result = result + alphabet[alphabet.index(letter)! + 2]\n           \
    \               ^~~~~~~~\n/tmp/tmp2j5k4cql.swift:14:36: error: cannot find 'alphabet'\
    \ in scope\n        result = result + alphabet[alphabet.index(letter)! + 2]\n\
    \                                   ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count))))\n\
    \    var result = [Character]()\n    for c in s.characters {\n        var index\
    \ = alphabet.index(of: c)!\n        result.append(alphabet[(index + 1) % alphabet.count])\n\
    \    }\n    return String(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp2rq2c37j.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp2rq2c37j.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count))))\n\
    \                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp2rq2c37j.swift:18:16:\
    \ error: 'characters' is unavailable: Please use String directly\n    for c in\
    \ s.characters {\n               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp2rq2c37j.swift:19:30: warning: 'index(of:)' is deprecated:\
    \ renamed to 'firstIndex(of:)'\n        var index = alphabet.index(of: c)!\n \
    \                            ^\n/tmp/tmp2rq2c37j.swift:19:30: note: use 'firstIndex(of:)'\
    \ instead\n        var index = alphabet.index(of: c)!\n                      \
    \       ^~~~~\n                             firstIndex\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        let index = alphabet.indexOf(c)\n        if\
    \ index == -1 {\n            return s\n        }\n        let newIndex = index\
    \ + 2\n        if newIndex < alphabet.count {\n            result += alphabet[newIndex]\n\
    \        } else {\n            result += alphabet[alphabet.count - 1]\n      \
    \  }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpymij8ux4.swift:14:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.indexOf(c)\n                    ^~~~~~~~\n/tmp/tmpymij8ux4.swift:19:23:\
    \ error: cannot find 'alphabet' in scope\n        if newIndex < alphabet.count\
    \ {\n                      ^~~~~~~~\n/tmp/tmpymij8ux4.swift:20:23: error: cannot\
    \ find 'alphabet' in scope\n            result += alphabet[newIndex]\n       \
    \               ^~~~~~~~\n/tmp/tmpymij8ux4.swift:22:23: error: cannot find 'alphabet'\
    \ in scope\n            result += alphabet[alphabet.count - 1]\n             \
    \         ^~~~~~~~\n/tmp/tmpymij8ux4.swift:22:32: error: cannot find 'alphabet'\
    \ in scope\n            result += alphabet[alphabet.count - 1]\n             \
    \                  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.sort()\n    alphabet = alphabet[1..<alphabet.count]\n    var\
    \ result = [Character]()\n    for c in s.characters {\n        result.append(alphabet[alphabet.index(of:\
    \ c) + 1])\n    }\n    return String(result)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpblg0q69i.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpblg0q69i.swift:17:24:\
    \ error: cannot assign value of type 'ArraySlice<Character>' to type '[Character]'\n\
    \    alphabet = alphabet[1..<alphabet.count]\n               ~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpblg0q69i.swift:19:16: error: 'characters' is unavailable: Please use String\
    \ directly\n    for c in s.characters {\n               ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpblg0q69i.swift:20:41: error: value of\
    \ optional type 'Array<Character>.Index?' (aka 'Optional<Int>') must be unwrapped\
    \ to a value of type 'Array<Character>.Index' (aka 'Int')\n        result.append(alphabet[alphabet.index(of:\
    \ c) + 1])\n                                        ^\n/tmp/tmpblg0q69i.swift:20:41:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        result.append(alphabet[alphabet.index(of: c) + 1])\n        \
    \                                ^\n                               (         \
    \            ?? <#default value#>)\n/tmp/tmpblg0q69i.swift:20:41: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        result.append(alphabet[alphabet.index(of:\
    \ c) + 1])\n                                        ^\n                      \
    \                              !\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    a\".unicodeScalars.first!))\n    }\n    alphabet.append(Character(\"z\".unicodeScalars.first!))\n\
    \    var result = [Character]()\n    for c in s {\n        var index = alphabet.index(of:\
    \ c)!\n        alphabet[index] = alphabet[index].unicodeScalars.first!\n     \
    \   result.append(alphabet[index])\n    }\n    return String(result)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpk362scv5.swift:19:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        var index = alphabet.index(of: c)!\n         \
    \                    ^\n/tmp/tmpk362scv5.swift:19:30: note: use 'firstIndex(of:)'\
    \ instead\n        var index = alphabet.index(of: c)!\n                      \
    \       ^~~~~\n                             firstIndex\n/tmp/tmpk362scv5.swift:20:63:\
    \ error: cannot assign value of type 'Unicode.Scalar' to subscript of type 'Character'\n\
    \        alphabet[index] = alphabet[index].unicodeScalars.first!\n           \
    \               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        let index = alphabet.indexOf(c)\n        let\
    \ newIndex = index + 2\n        if newIndex < alphabet.count {\n            result\
    \ += alphabet[newIndex]\n        } else {\n            result += c\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpguz98d2l.swift:14:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.indexOf(c)\n                    ^~~~~~~~\n/tmp/tmpguz98d2l.swift:16:23:\
    \ error: cannot find 'alphabet' in scope\n        if newIndex < alphabet.count\
    \ {\n                      ^~~~~~~~\n/tmp/tmpguz98d2l.swift:17:23: error: cannot\
    \ find 'alphabet' in scope\n            result += alphabet[newIndex]\n       \
    \               ^~~~~~~~\n/tmp/tmpguz98d2l.swift:19:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ += c\n                      ^\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    a\"))\n    }\n    alphabet.append(Character(\"z\"))\n    alphabet.append(Character(\"\
    A\"))\n    alphabet.append(Character(\"Z\"))\n    alphabet.append(Character(\"\
    0\"))\n    alphabet.append(Character(\"1\"))\n    alphabet.append(Character(\"\
    2\"))\n    alphabet.append(Character(\"3\"))\n    alphabet.append(Character(\"\
    4\"))\n    alphabet.append(Character(\"5\"))\n    alphabet.append(Character(\"\
    6\"))\n    alphabet.append(Character(\"7\"))\n    alphabet.append(Character(\"\
    8\"))\n    alphabet.append(Character(\"9\"))\n    alphabet.append(Character(\"\
    !\"))\n    alphabet.append(Character(\"$\"))\n    alphabet.append(Character(\"\
    %\"))\n    alphabet.append(Character(\"&\"))\n    alphabet.append(Character(\"\
    (\"))\n    alphabet.append(Character(\")\"))\n    alphabet.append(Character(\"\
    *\"))\n    alphabet.append(Character(\"+\"))\n    alphabet.append(Character(\"\
    -\"))\n    alphabet.append(Character(\"/\"))\n    alphabet.append(Character(\"\
    =\"))\n    alphabet.append(Character(\"?\"))\n    alphabet.append(Character(\"\
    @\"))\n    alphabet.append(Character(\"[\"))\n    alphabet.append(Character(\"\
    ]\"))\n    alphabet.append(Character(\"^\"))\n    alphabet.append(Character(\"\
    _\"))\n    alphabet.append(Character(\"`\"))\n    alphabet.append(Character(\"\
    {\"))\n    alphabet.append(Character(\"}\"))\n    alphabet.append(Character(\"\
    |\"))\n    alphabet.append(Character(\":\"))\n    alphabet.append(Character(\"\
    ;\"))\n    alphabet.append(Character(\"'\"))\n    alphabet.append(Character(\"\
    \\\"\"))\n    alphabet.append(Character(\",\"))\n    alphabet.append(Character(\"\
    `\"))\n    alphabet.append(Character(\"~\"))\n    alphabet.append(Character(\"\
    ?\"))\n    alphabet.append(Character(\"!\"))\n    alphabet.append(Character(\"\
    '\"))\n    alphabet.append(Character(\"\\\"\"))\n    alphabet.append(Character(\"\
    (\"))\n    alphabet.append(Character(\")\"))\n    alphabet.append(Character(\"\
    [\"))\n    alphabet.append(Character(\"]\"))\n    alphabet.append(Character(\"\
    {\"))\n    alphabet.append(Character(\"}\"))\n    alphabet.append(Character(\"\
    ,\"))\n    alphabet.append(Character(\";\"))\n    alphabet.append(Character(\"\
    :\"))\n    alphabet.append(Character(\"=\"))\n    alphabet.append(Character(\"\
    +\"))\n    alphabet.append(Character(\"-\"))\n    alphabet.append(Character(\"\
    /\"))\n    alphabet.append(Character(\"*\"))\n    alphabet.append(Character(\"\
    (\"))\n    alphabet.append(Character(\")\"))\n    alphabet.append(\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmph1m2rzfz.swift:78:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmph1m2rzfz.swift:77:20: error: missing argument for parameter #1 in\
    \ call\n    alphabet.append(\n                   ^\n                   <#Character#>\n\
    Swift.Array:6:37: note: 'append' declared here\n    @inlinable public mutating\
    \ func append(_ newElement: __owned Element)\n                               \
    \     ^\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+1))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+2))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+3))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+4))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+5))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+6))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+7))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+8))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+9))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+10))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+11))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+12))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+13))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+14))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+15))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+16))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+17))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+18))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+19))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+20))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+21))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+22))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+23))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+24))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+25))))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp4fhgjnmp.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp4fhgjnmp.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count))))\n\
    \                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp4fhgjnmp.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+1))))\n\
    \                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp4fhgjnmp.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+2))))\n\
    \                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp4fhgjnmp.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+3))))\n\
    \                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp4fhgjnmp.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+4))))\n\
    \                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp4fhgjnmp.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+5))))\n\
    \                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp4fhgjnmp.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+6))))\n\
    \                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp4fhgjnmp.swift:23:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+7))))\n\
    \                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp4fhgjnm"
  stdout: ''
  timestamp: 1659824988
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 4)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 6)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 8)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 10)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 12)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 14)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 16)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 18)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 20)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 22)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 24)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 26)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 28)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 30)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 32)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 34)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 36)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 38)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 40)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 42)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 44)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 46)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 48)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 50)))\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpmoyyggnd.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpmoyyggnd.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmoyyggnd.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmoyyggnd.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 4)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmoyyggnd.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 6)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmoyyggnd.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 8)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmoyyggnd.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 10)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmoyyggnd.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 12)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmoyyggnd.swift:23:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 14)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmoyyggnd.swift:24:41:\
    \ error: type "
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        result += alphabet[alphabet.index(c) + 2]\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpz4naxmt4.swift:14:19: error: cannot find 'alphabet' in scope\n\
    \        result += alphabet[alphabet.index(c) + 2]\n                  ^~~~~~~~\n\
    /tmp/tmpz4naxmt4.swift:14:28: error: cannot find 'alphabet' in scope\n       \
    \ result += alphabet[alphabet.index(c) + 2]\n                           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        result = result + alphabet[alphabet.IndexOf(c)\
    \ + 2]\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp241dvynn.swift:14:27: error: cannot find 'alphabet' in scope\n\
    \        result = result + alphabet[alphabet.IndexOf(c) + 2]\n               \
    \           ^~~~~~~~\n/tmp/tmp241dvynn.swift:14:36: error: cannot find 'alphabet'\
    \ in scope\n        result = result + alphabet[alphabet.IndexOf(c) + 2]\n    \
    \                               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n\tlet alphabet\
    \ = Array(s.characters)\n\tlet alphabetLength = alphabet.count\n\tlet alphabetRotation\
    \ = alphabetLength / 2\n\tlet alphabetRotationOffset = alphabetLength - alphabetRotation\n\
    \tlet alphabetRotationOffset2 = alphabetRotationOffset * 2\n\tlet alphabetRotationOffset3\
    \ = alphabetRotationOffset2 * 2\n\tlet alphabetRotationOffset4 = alphabetRotationOffset3\
    \ * 2\n\tlet alphabetRotationOffset5 = alphabetRotationOffset4 * 2\n\tlet alphabetRotationOffset6\
    \ = alphabetRotationOffset5 * 2\n\tlet alphabetRotationOffset7 = alphabetRotationOffset6\
    \ * 2\n\tlet alphabetRotationOffset8 = alphabetRotationOffset7 * 2\n\tlet alphabetRotationOffset9\
    \ = alphabetRotationOffset8 * 2\n\tlet alphabetRotationOffset10 = alphabetRotationOffset9\
    \ * 2\n\tlet alphabetRotationOffset11 = alphabetRotationOffset10 * 2\n\tlet alphabetRotationOffset12\
    \ = alphabetRotationOffset11 * 2\n\tlet alphabetRotationOffset13 = alphabetRotationOffset12\
    \ * 2\n\tlet alphabetRotationOffset14 = alphabetRotationOffset13 * 2\n\tlet alphabetRotationOffset15\
    \ = alphabetRotationOffset14 * 2\n\tlet alphabetRotationOffset16 = alphabetRotationOffset15\
    \ * 2\n\tlet alphabetRotationOffset17 = alphabetRotationOffset16 * 2\n\tlet alphabetRotationOffset18\
    \ = alphabetRotationOffset17 * 2\n\tlet alphabetRotationOffset19 = alphabetRotationOffset18\
    \ * 2\n\tlet alphabetRotationOffset20 = alphabetRotationOffset19 * 2\n\tlet alphabetRotationOffset21\
    \ = alphabetRotationOffset20 * 2\n\tlet alphabetRotationOffset22 = alphabetRotationOffset21\
    \ * 2\n\tlet alphabetRotationOffset23 = alphabetRotationOffset22 * 2\n\tlet alphabetRotationOffset24\
    \ = alphabetRotationOffset23 * 2\n\tlet alphabetRotationOffset25 = alphabetRotationOffset24\
    \ * 2\n\tlet alphabetRotationOffset26 = alphabetRotationOffset25 * 2\n\tlet alphabetRotationOffset27\
    \ = alphabetRotationOffset26 * 2\n\tlet alphabetRotationOffset28 = alphabetRotationOffset27\
    \ * 2\n\tlet alphabetRotationOffset29 = alphabetRotationOffset28 * 2\n\tlet alphabetRotationOffset30\
    \ = alphabetRotationOffset29 * 2\n\tlet alphabetRotationOffset31 = alphabetRotationOffset30\
    \ * 2\n\tlet alphabetRotationOffset32 = alphabetRotationOffset31 * 2\n\tlet alphabetRotationOffset33\
    \ = alphabetRotationOffset32 * 2\n\tlet alphabetRotationOffset34 = alphabetRotationOffset33\
    \ * 2\n\tlet alphabetRotationOffset35 = alphabetRotationOffset34 * 2\n\tlet alphabetRotationOffset36\
    \ = alphabetRotationOffset35 * 2\n\t\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpvb_otewl.swift:12:25: error: 'characters' is unavailable: Please\
    \ use String directly\n        let alphabet = Array(s.characters)\n          \
    \                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpvb_otewl.swift:50:6: warning: initialization of immutable value 'alphabetRotationOffset36'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \       let alphabetRotationOffset36 = alphabetRotationOffset35 * 2\n        ~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n\
    \        _\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        let index = alphabet.indexOf(c)\n        let\
    \ newIndex = index + 2\n        if newIndex < alphabet.count {\n            result\
    \ += alphabet[newIndex]\n        } else {\n            result += c\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpguz98d2l.swift:14:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.indexOf(c)\n                    ^~~~~~~~\n/tmp/tmpguz98d2l.swift:16:23:\
    \ error: cannot find 'alphabet' in scope\n        if newIndex < alphabet.count\
    \ {\n                      ^~~~~~~~\n/tmp/tmpguz98d2l.swift:17:23: error: cannot\
    \ find 'alphabet' in scope\n            result += alphabet[newIndex]\n       \
    \               ^~~~~~~~\n/tmp/tmpguz98d2l.swift:19:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ += c\n                      ^\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count))))\n\
    \    alphabet.sort()\n    var result = \"\"\n    for c in s.characters {\n   \
    \     result += alphabet[alphabet.index(of: c)!]\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpozil3enq.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpozil3enq.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count))))\n\
    \                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpozil3enq.swift:19:16:\
    \ error: 'characters' is unavailable: Please use String directly\n    for c in\
    \ s.characters {\n               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpozil3enq.swift:20:27: error: no exact matches in call\
    \ to subscript \n        result += alphabet[alphabet.index(of: c)!]\n        \
    \                  ^\nSwift.String:3:35: note: candidate expects value of type\
    \ 'String' for parameter #2 (got 'Character')\n    @inlinable public static func\
    \ += (lhs: inout String, rhs: String)\n                                  ^\nSwift.Array:17:23:\
    \ note: candidate expects value of type 'Range<Int>' for parameter #1 (got 'Array<Character>.Index'\
    \ (aka 'Int'))\n    @inlinable public subscript(bounds: Range<Int>) -> ArraySlice<Element>\
    \ { get set }\n                      ^\nSwift.Collection:3:23: note: candidate\
    \ expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Array<Character>.Index'\
    \ (aka 'Int'))\n    @inlinable public subscript(x: (UnboundedRange_) -> ()) ->\
    \ Self.SubSequence { get }\n                      ^\nSwift.MutableCollection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Array<Character>.Index' (aka 'Int'))\n    @inlinable public subscript(x:\
    \ (UnboundedRange_) -> ()) -> Self.SubSequence { get set }\n                 \
    \     ^\n/tmp/tmpozil3enq.swift:20:27: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        result += alphabet[alphabet"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.sort()\n    var result = [Character]()\n    for c in alphabet\
    \ {\n        result.append(c)\n    }\n    for i := 0; i < len(alphabet); i +=\
    \ 2 {\n        result.append(alphabet[i])\n        result.append(alphabet[i+1])\n\
    \    }\n    return String(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmps9qpgdf0.swift:21:12: error: expected type\n    for i := 0; i <\
    \ len(alphabet); i += 2 {\n           ^\n            <#type#>\n/tmp/tmps9qpgdf0.swift:21:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(alphabet);\
    \ i += 2 {\n           ^\n/tmp/tmps9qpgdf0.swift:21:12: error: expected Sequence\
    \ expression for for-each loop\n    for i := 0; i < len(alphabet); i += 2 {\n\
    \           ^\n/tmp/tmps9qpgdf0.swift:13:16: error: 'characters' is unavailable:\
    \ Please use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetLength = alphabet.count\n\
    \    var alphabetIndex = 0\n    var encryptedString = \"\"\n    for letter in\
    \ s {\n        encryptedString += alphabet[alphabetIndex % alphabetLength]\n \
    \       alphabetIndex++\n    }\n    return encryptedString\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp4zwpjl1j.swift:17:36: error: no exact matches in call to subscript\
    \ \n        encryptedString += alphabet[alphabetIndex % alphabetLength]\n    \
    \                               ^\nSwift.String:3:12: note: candidate expects\
    \ value of type 'Range<String.Index>' for parameter #1 (got 'Int')\n    public\
    \ subscript(r: Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n/tmp/tmp4zwpjl1j.swift:18:22:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        alphabetIndex++\n\
    \                     ^~\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.first!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmptv_i30h5.swift:13:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.first!))\n             \
    \                 ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmptv_i30h5.swift:14:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.last!))\n              \
    \                ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmptv_i30h5.swift:15:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.last!))\n              \
    \                ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmptv_i30h5.swift:16:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.first!))\n             \
    \                 ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmptv_i30h5.swift:17:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.last!))\n              \
    \                ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmptv_i30h5.swift:18:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.last!))\n              \
    \                ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmptv_i30h5.swift:19:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.last!))\n              \
    \                ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmptv_i30h5.swift:20:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.last!))\n              \
    \                ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmptv_i30h5.swift:21:31: error: missing argument label 'e"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.sort()\n    alphabet.append(Character(\"z\"))\n    alphabet.append(Character(\"\
    z\"))\n    alphabet.append(Character(\"z\"))\n    alphabet.append(Character(\"\
    z\"))\n    alphabet.append(Character(\"z\"))\n    alphabet.append(Character(\"\
    z\"))\n    alphabet.append(Character(\"z\"))\n    alphabet.append(Character(\"\
    z\"))\n    alphabet.append(Character(\"z\"))\n    alphabet.append(Character(\"\
    z\"))\n    alphabet.append(Character(\"z\"))\n    alphabet.append(Character(\"\
    z\"))\n    alphabet.append(Character(\"z\"))\n    alphabet.append(Character(\"\
    z\"))\n    alphabet.append(Character(\"z\"))\n    alphabet.append(Character(\"\
    z\"))\n    alphabet.append(Character(\"z\"))\n    alphabet.append(Character(\"\
    z\"))\n    alphabet.append(Character(\"z\"))\n    alphabet.append(Character(\"\
    z\"))\n    alphabet.append(Character(\"z\"))\n    alphabet.append(Character(\"\
    z\"))\n    alphabet.append(Character(\"z\"))\n    alphabet.append(Character(\"\
    z\"))\n    alphabet.append(Character(\"z\"))\n    alphabet.append(Character(\"\
    z\"))\n    alphabet.append(Character(\"z\"))\n    alphabet.append(Character(\"\
    z\"))\n    alphabet.append(Character(\"z\"))\n    alphabet.append(Character(\"\
    z\"))\n    alphabet.append(Character(\"z\"))\n    alphabet.append(Character(\"\
    z\"))\n    alphabet.append(Character(\"z\"))\n    alphabet.append(Character(\"\
    z\"))\n    alphabet.append(Character(\"z\"))\n    alphabet.append(Character(\"\
    z\"))\n    alphabet.append(Character(\"z\"))\n    alphabet.append(Character(\"\
    z\"))\n    alphabet.append(Character(\"z\"))\n    alphabet.append(Character(\"\
    z\"))\n    alphabet.append(Character(\"z\"))\n    alphabet.append(Character(\"\
    z\"))\n    alphabet.append(Character(\"z\"))\n    alphabet.append(Character(\"\
    z\"))\n    alphabet.append(Character(\"z\"))\n    alphabet.append(Character(\"\
    z\"))\n    alphabet.append(Character(\"z\"))\n    alphabet.append(Character(\"\
    z\"))\n    alphabet.append(Character(\"z\"))\n    alphabet.append(Character(\"\
    z\"))\n    alphabet.append(Character(\"z\"))\n    alphabet.append(Character(\"\
    z\"))\n    alphabet.append(Character(\"z\"))\n    alphabet.append(Character(\"\
    z\"))\n    alphabet.append(Character(\"z\"))\n    alphabet.append(Character(\"\
    z\"))\n    alphabet.append(Character(\"z\"))\n    alphabet.append(Character(\"\
    z\"))\n    alphabet.append(Character(\"z\"))\n    alphabet.append(Character(\"\
    z\"))\n    alphabet.append(Character(\"z\"))\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpbi3ri8p5.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    alphabet.append(Character(s.characters[s.characters.startIndex]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+1]))\n   \
    \ alphabet.append(Character(s.characters[s.characters.startIndex+2]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+3]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+4]))\n   \
    \ alphabet.append(Character(s.characters[s.characters.startIndex+5]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+6]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+7]))\n   \
    \ alphabet.append(Character(s.characters[s.characters.startIndex+8]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+9]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+10]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+11]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+12]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+13]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+14]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+15]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+16]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+17]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+18]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+19]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+20]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+21]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+22]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+23]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+24]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+25]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+26]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+27]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+28]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+29]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+30]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpegmyyew7.swift:45:1: error: expected ']' in expression list\n}\n\
    ^\n/tmp/tmpegmyyew7.swift:44:43: note: to match this opening '['\n    alphabet.append(Character(s.characters[s.characters.startIndex\n\
    \                                          ^\n/tmp/tmpegmyyew7.swift:13:31: error:\
    \ missing argument label 'extendedGraphemeClusterLiteral:' in call\n    alphabet.append(Character(s.characters[s.characters.startIndex]))\n\
    \                              ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpegmyyew7.swift:14:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters[s.characters.startIndex+1]))\n\
    \                              ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpegmyyew7.swift:14:57: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n    alphabet.append(Character(s.characters[s.characters.startIndex+1]))\n\
    \                                                        ^\n/tmp/tmpegmyyew7.swift:15:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+2]))\n     \
    \                         ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpegmyyew7.swift:15:57: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n    alphabet.append(Character(s.characters[s.characters.startIndex+2]))\n\
    \                                                        ^\n/tmp/tmpegmyyew7.swift:16:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+3]))\n     \
    \                         ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpegmyyew7.swift:16:57: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n    alphabet.append(Character(s.characters[s.characters.startIndex+3]))\n\
    \                                                        ^\n"
  stdout: ''
  timestamp: 1659824989
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 1)))\n    var result = [Character]()\n    for c in s.characters {\n      \
    \  result.append(alphabet[alphabet.index(c)])\n    }\n    return String(result)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp3qz1b2pp.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp3qz1b2pp.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 1)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp3qz1b2pp.swift:18:16:\
    \ error: 'characters' is unavailable: Please use String directly\n    for c in\
    \ s.characters {\n               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp3qz1b2pp.swift:19:47: error: missing argument label\
    \ 'of:' in call\n        result.append(alphabet[alphabet.index(c)])\n        \
    \                                      ^\n                                   \
    \           of: \n/tmp/tmp3qz1b2pp.swift:19:41: error: value of optional type\
    \ 'Array<Character>.Index?' (aka 'Optional<Int>') must be unwrapped to a value\
    \ of type 'Array<Character>.Index' (aka 'Int')\n        result.append(alphabet[alphabet.index(c)])\n\
    \                                        ^\n/tmp/tmp3qz1b2pp.swift:19:41: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \        result.append(alphabet[alphabet.index(c)])\n                        \
    \                ^\n                                                 ?? <#default\
    \ value#>\n/tmp/tmp3qz1b2pp.swift:19:41: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        result.append(alphabet[alphabet.index(c)])\n\
    \                                        ^\n                                 \
    \               !\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(Character(c))\n\
    \    }\n    alphabet.append(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp1jyn0yke.swift:17:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmp1jyn0yke.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp1jyn0yke.swift:14:35:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \      alphabet.append(Character(c))\n                                  ^\n  \
    \                                extendedGraphemeClusterLiteral: \n/tmp/tmp1jyn0yke.swift:16:2450:\
    \ error: missing argument for parameter #1 in call\n    alphabet.append(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Character(Charac"
  stdout: ''
  timestamp: 1659824988
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Charact\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpdhxzp1si.swift:44:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpdhxzp1si.swift:43:30: note: to match this opening '('\n    alphabet.append(Character(Charact\n\
    \                             ^\n/tmp/tmpdhxzp1si.swift:13:16: error: 'characters'\
    \ is unavailable: Please use String directly\n    for c in s.characters {\n  \
    \             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpdhxzp1si.swift:16:41: error: type 'Character' has no member 'UnicodeScalar'\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpdhxzp1si.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpdhxzp1si.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpdhxzp1si.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpdhxzp1si.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpdhxzp1si.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpdhxzp1si.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpdhxzp1si"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    alphabet.append(Character(UnicodeScalar(97)))\n    alphabet.append(Character(UnicodeScalar(65)))\n\
    \    alphabet.append(Character(UnicodeScalar(90)))\n    alphabet.append(Character(UnicodeScalar(48)))\n\
    \    alphabet.append(Character(UnicodeScalar(57)))\n    alphabet.append(Character(UnicodeScalar(122)))\n\
    \    alphabet.append(Character(UnicodeScalar(98)))\n    alphabet.append(Character(UnicodeScalar(90)))\n\
    \    alphabet.append(Character(UnicodeScalar(48)))\n    alphabet.append(Character(UnicodeScalar(57)))\n\
    \    alphabet.append(Character(UnicodeScalar(122)))\n    alphabet.append(Character(UnicodeScalar(98)))\n\
    \    alphabet.append(Character(UnicodeScalar(90)))\n    alphabet.append(Character(UnicodeScalar(48)))\n\
    \    alphabet.append(Character(UnicodeScalar(57)))\n    alphabet.append(Character(UnicodeScalar(122)))\n\
    \    alphabet.append(Character(UnicodeScalar(98)))\n    alphabet.append(Character(UnicodeScalar(90)))\n\
    \    alphabet.append(Character(UnicodeScalar(48)))\n    alphabet.append(Character(UnicodeScalar(57)))\n\
    \    alphabet.append(Character(UnicodeScalar(122)))\n    alphabet.append(Character(UnicodeScalar(98)))\n\
    \    alphabet.append(Character(UnicodeScalar(90)))\n    alphabet.append(Character(UnicodeScalar(48)))\n\
    \    alphabet.append(Character(UnicodeScalar(57)))\n    alphabet.append(Character(UnicodeScalar(122)))\n\
    \    alphabet.append(Character(UnicodeScalar(98)))\n    alphabet.append(Character(UnicodeScalar(90)))\n\
    \    alphabet.append(Character(UnicodeScalar(48)))\n    alphabet.append(Character(UnicodeScalar(57)))\n\
    \    alphabet.append(Character(UnicodeScalar(122)))\n    alphabet.append(Character(UnicodeScalar(98)))\n\
    \    alphabet.append(Character(UnicodeScalar(90)))\n    alphabet.append(Character(UnicodeScalar(48)))\n\
    \    alphabet.append(Character(UnicodeScalar(57)))\n    alphabet.append(Character(UnicodeScalar(122)))\n\
    \    alphabet.append(Character(UnicodeScalar(98)))\n    alphabet.append(Character(UnicodeScalar(90)))\n\
    \    alphabet.append(Character(UnicodeScalar(48)))\n    alphabet.append(Character(UnicodeScalar(57)))\n\
    \    alphabet.append(Character(UnicodeScalar(122)))\n    alphabet.append(Character(UnicodeScalar(98)))\n\
    \    alphabet.append(Character(UnicodeScalar(90)))\n    alphabet.append(Character(UnicodeScalar(48)))\n\
    \    alphabet.append(Character(UnicodeScalar(57)))\n    alphabet.append(Character(UnicodeScalar(122)))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: '/tmp/tmp9kfzrg73.swift:59:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    a\".unicodeScalars.first!))\n    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    b\".unicodeScalars.first!))\n    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    c\".unicodeScalars.first!))\n    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    d\".unicodeScalars.first!))\n    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    e\".unicodeScalars.first!))\n    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    f\".unicodeScalars.first!))\n    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    g\".unicodeScalars.first!))\n    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    h\".unicodeScalars.first!))\n    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    i\".unicodeScalars.first!))\n    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    j\".unicodeScalars.first!))\n    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    k\".unicodeScalars.first!))\n    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    l\".unicodeScalars.first!))\n    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    m\".unicodeScalars.first!))\n    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    n\".unicodeScalars.first!))\n    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    o\".unicodeScalars.first!))\n    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    p\".unicodeScalars.first!))\n    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    q\".unicodeScalars.first!))\n    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    r\".unicodeScalars.first!))\n    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    s\".unicodeScalars.first!))\n    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    t\".unicodeScalars.first!))\n    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    u\".unicodeScalars.first!))\n    }\n    for \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp3hxuz83h.swift:76:8: error: expected pattern\n    for \n      \
    \ ^\n/tmp/tmp3hxuz83h.swift:76:8: error: expected Sequence expression for for-each\
    \ loop\n    for \n       ^\n/tmp/tmp3hxuz83h.swift:76:8: error: expected '{' to\
    \ start the body of for-each loop\n    for \n       ^\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 4)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 6)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 8)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 10)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 12)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 14)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 16)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 18)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 20)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 22)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 24)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 26)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 28)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 30)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 32)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 34)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 36)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 38)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 40)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 42)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 44)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 46)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 48)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 50)))\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpmoyyggnd.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpmoyyggnd.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmoyyggnd.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmoyyggnd.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 4)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmoyyggnd.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 6)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmoyyggnd.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 8)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmoyyggnd.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 10)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmoyyggnd.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 12)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmoyyggnd.swift:23:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 14)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmoyyggnd.swift:24:41:\
    \ error: type "
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n\tlet alphabet\
    \ = Array(s.characters)\n\tlet alphabetLength = alphabet.count\n\tlet alphabetRotation\
    \ = alphabet[alphabetLength - 1]\n\tlet alphabetRotationMultiplier = alphabet[alphabetLength\
    \ - 2]\n\tlet alphabetRotationMultiplierMultiplier = alphabetRotationMultiplier\
    \ * 2\n\tlet alphabetRotationMultiplierMultiplierMultiplier = alphabetRotationMultiplierMultiplier\
    \ * 2\n\tlet alphabetRotationMultiplierMultiplierMultiplierMultiplier = alphabetRotationMultiplierMultiplierMultiplier\
    \ * 2\n\tlet alphabetRotationMultiplierMultiplierMultiplierMultiplierMultiplier\
    \ = alphabetRotationMultiplierMultiplierMultiplierMultiplier * 2\n\tlet alphabetRotationMultiplierMultiplierMultiplierMultiplierMultiplierMultiplier\
    \ = alphabetRotationMultiplierMultiplierMultiplierMultiplierMultiplier * 2\n\t\
    let alphabetRotationMultiplierMultiplierMultiplierMultiplierMultiplierMultiplierMultiplier\
    \ = alphabetRotationMultiplierMultiplierMultiplierMultiplierMultiplierMultiplier\
    \ * 2\n\tlet alphabetRotationMultiplierMultiplierMultiplierMultiplierMultiplierMultiplierMultiplierMultiplier\
    \ = alphabetRotationMultiplierMultiplierMultiplierMultiplierMultiplierMultiplierMultiplier\
    \ * 2\n\tlet alphabetRotationMultiplierMultiplierMultiplierMultiplierMultiplierMultiplierMultiplierMultiplierMultiplier\
    \ = alphabetRotationMultiplierMultiplierMultiplierMultiplierMultiplierMultiplierMultiplier\
    \ * 2\n\tlet alphabetRotationMultiplierMultiplierMultiplierMultiplierMultiplierMultiplierMultiplierMultiplierMultiplier\
    \ = alphabetRotationMultiplierMultiplierMultiplierMultiplierMultiplierMultiplierMultiplier\
    \ * 2\n\tlet alphabetRotationMultiplierMultiplierMultiplierMultiplierMultiplierMultiplierMultiplierMultiplierMultiplier\
    \ = alphabetRotationMultiplierMultiplierMultiplierMultiplierMultiplierMultiplierMultiplierMultiplier\
    \ * 2\n\tlet alphabetRotationMultiplierMultiplierMultiplierMultiplierMultiplierMultiplierMultiplierMultiplierMultiplierMultiplier\
    \ = alphabetRotationMultiplierMultiplierMultiplierMultiplierMultiplierMultiplierMultiplierMultiplier\
    \ * 2\n\tlet alphabetRotationMultiplierMultiplierMultiplierMultiplierMultiplierMultiplierMultiplierMultiplierMultiplierMultiplier\
    \ = alphabetRotationMultiplierMultiplierMultiplierMultiplierMultiplierMultiplierMultiplier\
    \ * 2\n\tlet alphabetRotationMultiplierMultiplierMultiplierMultiplierMultiplierMultiplierMultiplierMultiplierMultiplierMultiplier\
    \ = alphabetRotationMultiplierMultiplierMultiplierMultiplierMultiplierMultiplierMultiplierMultiplier\
    \ * 2\n\tlet alphabetRotationMultiplierMultiplierMultiplierMultiplierMultiplierMultiplierMultiplierMultiplierMultiplierMultiplier\
    \ = \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\"\
    )\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\"\
    ) == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\"\
    ) == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\"\
    )\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"a\") ==\
    \ \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp4r2vbktr.swift:29:124: error: expected initial value after '='\n\
    \        let alphabetRotationMultiplierMultiplierMultiplierMultiplierMultiplierMultiplierMultiplierMultiplierMultiplierMultiplier\
    \ = \n                                                                       \
    \                                                           ^\n/tmp/tmp4r2vbktr.swift:12:25:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ alphabet = Array(s.characters)\n                               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp4r2vbktr.swift:16:72:\
    \ error: binary operator '*' cannot be applied to operands of type 'String.Element'\
    \ (aka 'Character') and 'Int'\n        let alphabetRotationMultiplierMultiplier\
    \ = alphabetRotationMultiplier * 2\n                                         \
    \          ~~~~~~~~~~~~~~~~~~~~~~~~~~ ^ ~\n/tmp/tmp4r2vbktr.swift:16:72: note:\
    \ overloads for '*' exist with these partially matching parameter lists: (Int,\
    \ Int)\n        let alphabetRotationMultiplierMultiplier = alphabetRotationMultiplier\
    \ * 2\n                                                                      \
    \        ^\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 18)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 20)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 22)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 24)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 26)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 28)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 30)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 32)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 34)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 36)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 38)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 40)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 42)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 44)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 46)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 48)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 50)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 52)))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp0ag9gkho.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp0ag9gkho.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:23:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:24:41:\
    \ error: type"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetLength = alphabet.count\n\
    \    var alphabetRotation = alphabet.characters.map { $0.nextUp() }\n    var alphabetRotationLength\
    \ = alphabetRotation.count\n    var alphabetRotationIndex = 0\n    var alphabetRotationIndex2\
    \ = 0\n    var alphabetRotationIndex3 = 0\n    var alphabetRotationIndex4 = 0\n\
    \    var alphabetRotationIndex5 = 0\n    var alphabetRotationIndex6 = 0\n    var\
    \ alphabetRotationIndex7 = 0\n    var alphabetRotationIndex8 = 0\n    var alphabetRotationIndex9\
    \ = 0\n    var alphabetRotationIndex10 = 0\n    var alphabetRotationIndex11 =\
    \ 0\n    var alphabetRotationIndex12 = 0\n    var alphabetRotationIndex13 = 0\n\
    \    var alphabetRotationIndex14 = 0\n    var alphabetRotationIndex15 = 0\n  \
    \  var alphabetRotationIndex16 = 0\n    var alphabetRotationIndex17 = 0\n    var\
    \ alphabetRotationIndex18 = 0\n    var alphabetRotationIndex19 = 0\n    var alphabetRotationIndex20\
    \ = 0\n    var alphabetRotationIndex21 = 0\n    var alphabetRotationIndex22 =\
    \ 0\n    var alphabetRotationIndex23 = 0\n    var alphabetRotationIndex24 = 0\n\
    \    var alphabetRotationIndex25 = 0\n    var alphabetRotationIndex26 = 0\n  \
    \  var alphabetRotationIndex27 = 0\n    var alphabetRotationIndex28 = 0\n    var\
    \ alphabetRotationIndex29 = 0\n    var alphabetRotationIndex30 = 0\n    var alphabetRotationIndex31\
    \ = 0\n    var alphabetRotationIndex32 = 0\n    var alphabetRotationIndex33 =\
    \ 0\n    var alphabetRotationIndex34 = 0\n    var alphabetRotationIndex35 = 0\n\
    \    var alphabetRotationIndex36 = 0\n    var alphabetRotationIndex37 = 0\n  \
    \  var alphabetRotationIndex38 = 0\n    var alphabetRotationIndex39 = 0\n    var\
    \ alphabetRotationIndex40 = 0\n    var alphabetRotationIndex41 = 0\n    var alphabetRotationIndex42\
    \ = 0\n    var alphabetRotationIndex43 = 0\n    var alphabetRotationIndex44 =\
    \ 0\n    var alphabetRotationIndex45 = 0\n    var alphabetRotationIndex46 = 0\n\
    \    var alphabetRotationIndex47 = 0\n    var alphabetRotationIndex48 = 0\n  \
    \  var alphabetRotationIndex49 = 0\n    var alphabetRotationIndex50 = 0\n    var\
    \ alphabetRotationIndex51 = 0\n    var alphabetRotationIndex52 = 0\n    var alphabetRotationIndex53\
    \ = 0\n    var alphabetRotationIndex54 = 0\n    var alphabetRotationIndex55 =\
    \ 0\n    var alphabetRotationIndex56 = 0\n    var alphabetRotationIndex57 = 0\n\
    \    var alphabetRotationIndex58 = 0\n    var alphabetRotationIndex59 = 0\n  \
    \  var alphabetRotationIndex60 = 0\n    var alphabetRotationIndex61 = 0\n    var\
    \ alphabetRotationIndex62 = 0\n    var alphabetRotationIndex63 = 0\n    var alphabetRotationIndex64\
    \ = 0\n    var alphabetRotationIndex65 = 0\n    var alphabetRotationIndex66 =\
    \ 0\n    var alphabetRotation\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmplvkacv_i.swift:14:57: error: value of type 'String.Element' (aka\
    \ 'Character') has no member 'nextUp'\n    var alphabetRotation = alphabet.characters.map\
    \ { $0.nextUp() }\n                                                     ~~ ^~~~~~\n\
    /tmp/tmplvkacv_i.swift:82:9: error: type annotation missing in pattern\n    var\
    \ alphabetRotation\n        ^\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 18)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 20)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 22)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 24)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 26)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 28)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 30)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 32)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 34)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 36)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 38)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 40)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 42)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 44)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 46)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 48)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 50)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 52)))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp0ag9gkho.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp0ag9gkho.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:23:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:24:41:\
    \ error: type"
  stdout: ''
  timestamp: 1659824987
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    a\".unicodeScalars.first!))\n    }\n    alphabet.append(Character(\"z\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"A\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    Z\".unicodeScalars.first!))\n    var result = [Character]()\n    for c in s {\n\
    \        var index = alphabet.index(of: c)!\n        index = index * 2\n     \
    \   index = index + 2\n        index = index % 26\n        result.append(alphabet[index])\n\
    \    }\n    return String(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpmgibcv9g/tmpmgibcv9g.swift:21: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002b9947710c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9947407561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9947407286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b994740713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9947406bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpmgibcv9g                        0x0000562d458c19dc <unavailable> + 10716

    6    tmpmgibcv9g                        0x0000562d458c08e6 <unavailable> + 6374

    7    libc.so.6                          0x00002b99478fc460 __libc_start_main +
    245

    8    tmpmgibcv9g                        0x0000562d458c05e9 <unavailable> + 5609

    '
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.sort()\n    alphabet.append(Character(\"z\"))\n    alphabet.append(Character(\"\
    a\"))\n    alphabet.append(Character(\"b\"))\n    alphabet.append(Character(\"\
    c\"))\n    alphabet.append(Character(\"d\"))\n    alphabet.append(Character(\"\
    e\"))\n    alphabet.append(Character(\"f\"))\n    alphabet.append(Character(\"\
    g\"))\n    alphabet.append(Character(\"h\"))\n    alphabet.append(Character(\"\
    i\"))\n    alphabet.append(Character(\"j\"))\n    alphabet.append(Character(\"\
    k\"))\n    alphabet.append(Character(\"l\"))\n    alphabet.append(Character(\"\
    m\"))\n    alphabet.append(Character(\"n\"))\n    alphabet.append(Character(\"\
    o\"))\n    alphabet.append(Character(\"p\"))\n    alphabet.append(Character(\"\
    q\"))\n    alphabet.append(Character(\"r\"))\n    alphabet.append(Character(\"\
    s\"))\n    alphabet.append(Character(\"t\"))\n    alphabet.append(Character(\"\
    u\"))\n    alphabet.append(Character(\"v\"))\n    alphabet.append(Character(\"\
    w\"))\n    alphabet.append(Character(\"x\"))\n    alphabet.append(Character(\"\
    y\"))\n    alphabet.append(Character(\"z\"))\n    alphabet.append(Character(\"\
    a\"))\n    alphabet.append(Character(\"b\"))\n    alphabet.append(Character(\"\
    c\"))\n    alphabet.append(Character(\"d\"))\n    alphabet.append(Character(\"\
    e\"))\n    alphabet.append(Character(\"f\"))\n    alphabet.append(Character(\"\
    g\"))\n    alphabet.append(Character(\"h\"))\n    alphabet.append(Character(\"\
    i\"))\n    alphabet.append(Character(\"j\"))\n    alphabet.append(Character(\"\
    k\"))\n    alphabet.append(Character(\"l\"))\n    alphabet.append(Character(\"\
    m\"))\n    alphabet.append(Character(\"n\"))\n    alphabet.append(Character(\"\
    o\"))\n    alphabet.append(Character(\"p\"))\n    alphabet.append(Character(\"\
    q\"))\n    alphabet.append(Character(\"r\"))\n    alphabet.append(Character(\"\
    s\"))\n    alphabet.append(Character(\"t\"))\n    alphabet.append(Character(\"\
    u\"))\n    alphabet.append(Character(\"v\"))\n    alphabet.append(Character(\"\
    w\"))\n    alphabet.append(Character(\"x\"))\n    alphabet.append(Character(\"\
    y\"))\n    alphabet.append(Character(\"z\"))\n    alphabet.append(Character(\"\
    a\"))\n    alphabet.append(Character(\"b\"))\n    alphabet.append(Character(\"\
    c\"))\n    alphabet.append(Character(\"d\"))\n    alphabet.append(Character(\"\
    e\"))\n    alphabet.append(Character(\"f\"))\n    alphabet.append(Character(\"\
    g\"))\n    alphabet.append(Character(\"h\"))\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpxgkowef1.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 18)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 20)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 22)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 24)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 26)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 28)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 30)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 32)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 34)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 36)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 38)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 40)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 42)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 44)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 46)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 48)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 50)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 52)))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp0ag9gkho.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp0ag9gkho.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:23:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:24:41:\
    \ error: type"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet = rotate(alphabet)\n    var result = \"\"\n    for c in s.characters\
    \ {\n        result = result + alphabet[c - s.characters]\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpejwk3h6f.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpejwk3h6f.swift:16:16:\
    \ error: cannot find 'rotate' in scope\n    alphabet = rotate(alphabet)\n    \
    \           ^~~~~~\n/tmp/tmpejwk3h6f.swift:18:16: error: 'characters' is unavailable:\
    \ Please use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpejwk3h6f.swift:19:35:\
    \ error: no exact matches in call to subscript \n        result = result + alphabet[c\
    \ - s.characters]\n                                  ^\n/tmp/tmpejwk3h6f.swift:19:35:\
    \ note: found candidate with type '(Range<Int>) -> @lvalue ArraySlice<Character>'\n\
    \        result = result + alphabet[c - s.characters]\n                      \
    \            ^\n/tmp/tmpejwk3h6f.swift:19:35: note: found candidate with type\
    \ '(_) -> ArraySlice<Character>'\n        result = result + alphabet[c - s.characters]\n\
    \                                  ^\n/tmp/tmpejwk3h6f.swift:19:35: note: found\
    \ candidate with type '((UnboundedRange_) -> ()) -> ArraySlice<Character>'\n \
    \       result = result + alphabet[c - s.characters]\n                       \
    \           ^\n/tmp/tmpejwk3h6f.swift:19:35: note: found candidate with type '(_)\
    \ -> @lvalue ArraySlice<Character>'\n        result = result + alphabet[c - s.characters]\n\
    \                                  ^\n/tmp/tmpejwk3h6f.swift:19:35: note: found\
    \ candidate with type '((UnboundedRange_) -> ()) -> @lvalue ArraySlice<Character>'\n\
    \        result = result + alphabet[c - s.characters]\n                      \
    \            ^\n/tmp/tmpejwk3h6f.swift:19:38: error: binary operator '-' cannot\
    \ be applied to operands of type 'Character' and 'String'\n        result = result\
    \ + alphabet[c - s.characters]\n                                   ~ ^ ~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 18)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 20)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 22)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 24)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 26)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 28)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 30)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 32)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 34)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 36)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 38)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 40)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 42)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 44)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 46)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 48)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 50)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 52)))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp0ag9gkho.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp0ag9gkho.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:23:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:24:41:\
    \ error: type"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        let index = alphabet.indexOf(c)\n        let\
    \ newIndex = index + 2\n        if newIndex < alphabet.count {\n            result\
    \ += alphabet[newIndex]\n        } else {\n            result += alphabet[alphabet.count-1]\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp4ji_s42i.swift:14:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.indexOf(c)\n                    ^~~~~~~~\n/tmp/tmp4ji_s42i.swift:16:23:\
    \ error: cannot find 'alphabet' in scope\n        if newIndex < alphabet.count\
    \ {\n                      ^~~~~~~~\n/tmp/tmp4ji_s42i.swift:17:23: error: cannot\
    \ find 'alphabet' in scope\n            result += alphabet[newIndex]\n       \
    \               ^~~~~~~~\n/tmp/tmp4ji_s42i.swift:19:23: error: cannot find 'alphabet'\
    \ in scope\n            result += alphabet[alphabet.count-1]\n               \
    \       ^~~~~~~~\n/tmp/tmp4ji_s42i.swift:19:32: error: cannot find 'alphabet'\
    \ in scope\n            result += alphabet[alphabet.count-1]\n               \
    \                ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0061)) +\
    \ 2))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0062)) +\
    \ 2))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0063)) +\
    \ 2))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0064)) +\
    \ 2))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0065)) +\
    \ 2))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0066)) +\
    \ 2))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0067)) +\
    \ 2))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0068)) +\
    \ 2))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0069)) +\
    \ 2))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x006A)) +\
    \ 2))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x006B)) +\
    \ 2))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x006C)) +\
    \ 2))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x006D)) +\
    \ 2))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x006E)) +\
    \ 2))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x006F)) +\
    \ 2))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0070)) +\
    \ 2))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0071)) +\
    \ 2))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0072)) +\
    \ 2))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0073)) +\
    \ 2))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0074)) +\
    \ 2))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0075)) +\
    \ 2))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0076)) +\
    \ 2))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0077)) +\
    \ 2))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0078)) +\
    \ 2))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0079)) +\
    \ 2))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x007A)) +\
    \ 2))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") == \"\
    lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"\
    gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\"\
    ) == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\"\
    )\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"a\") ==\
    \ \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpuolqj3a4.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpuolqj3a4.swift:16:73:\
    \ error: cannot convert value of type 'Int' to expected argument type 'String'\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0061)) + 2))\n\
    \                                                                        ^\n/tmp/tmpuolqj3a4.swift:16:21:\
    \ error: no exact matches in call to initializer \n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0061))\
    \ + 2))\n                    ^\n/tmp/tmpuolqj3a4.swift:16:21: note: found candidate\
    \ with type '(Unicode.Scalar) -> Character'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0061))\
    \ + 2))\n                    ^\n/tmp/tmpuolqj3a4.swift:16:21: note: found candidate\
    \ with type '(String) -> Character'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0061))\
    \ + 2))\n                    ^\n/tmp/tmpuolqj3a4.swift:16:41: error: type 'Character'\
    \ has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0061))\
    \ + 2))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpuolqj3a4.swift:17:21:\
    \ error: no exact matches in call to initializer \n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0062))\
    \ + 2))\n                    ^\n/tmp/tmpuolqj3a4.swift:17:21: note: found candidate\
    \ with type '(Unicode.Scalar) -> Character'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0062))\
    \ + 2))\n                    ^\n/tmp/tmpuolqj3a4.swift:17:21: note: found candidate\
    \ with type '(String) -> Character'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0062))\
    \ + 2))\n                    ^\n/tmp/tmpuolqj3a4.swift:17:73: error: cannot convert\
    \ value of type 'Int' to expected argument type 'String'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0062))\
    \ + 2))\n               "
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.sort()\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n    alphabet.sort()\n    \n    var result = [Character]()\n    for c\
    \ in s.characters {\n        result.append(alphabet[alphabet.indexOf(c)])\n  \
    \  }\n    return String(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp303_6fvb.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp303_6fvb.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp303_6fvb.swift:21:16:\
    \ error: 'characters' is unavailable: Please use String directly\n    for c in\
    \ s.characters {\n               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp303_6fvb.swift:22:41: error: value of type '[Character]'\
    \ has no member 'indexOf'\n        result.append(alphabet[alphabet.indexOf(c)])\n\
    \                               ~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    alphabet.append(Character(s.characters[s.characters.startIndex]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+1]))\n   \
    \ alphabet.append(Character(s.characters[s.characters.startIndex+2]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+3]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+4]))\n   \
    \ alphabet.append(Character(s.characters[s.characters.startIndex+5]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+6]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+7]))\n   \
    \ alphabet.append(Character(s.characters[s.characters.startIndex+8]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+9]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+10]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+11]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+12]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+13]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+14]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+15]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+16]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+17]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+18]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+19]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+20]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+21]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+22]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+23]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+24]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+25]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+26]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+27]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+28]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+29]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+30]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpegmyyew7.swift:45:1: error: expected ']' in expression list\n}\n\
    ^\n/tmp/tmpegmyyew7.swift:44:43: note: to match this opening '['\n    alphabet.append(Character(s.characters[s.characters.startIndex\n\
    \                                          ^\n/tmp/tmpegmyyew7.swift:13:31: error:\
    \ missing argument label 'extendedGraphemeClusterLiteral:' in call\n    alphabet.append(Character(s.characters[s.characters.startIndex]))\n\
    \                              ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpegmyyew7.swift:14:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters[s.characters.startIndex+1]))\n\
    \                              ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpegmyyew7.swift:14:57: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n    alphabet.append(Character(s.characters[s.characters.startIndex+1]))\n\
    \                                                        ^\n/tmp/tmpegmyyew7.swift:15:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+2]))\n     \
    \                         ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpegmyyew7.swift:15:57: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n    alphabet.append(Character(s.characters[s.characters.startIndex+2]))\n\
    \                                                        ^\n/tmp/tmpegmyyew7.swift:16:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+3]))\n     \
    \                         ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpegmyyew7.swift:16:57: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n    alphabet.append(Character(s.characters[s.characters.startIndex+3]))\n\
    \                                                        ^\n"
  stdout: ''
  timestamp: 1659824989
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 18)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 20)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 22)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 24)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 26)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 28)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 30)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 32)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 34)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 36)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 38)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 40)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 42)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 44)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 46)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 48)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 50)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 52)))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp0ag9gkho.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp0ag9gkho.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:23:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:24:41:\
    \ error: type"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        result += alphabet[alphabet.indexOf(c) + 2]\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp9ir7otwz.swift:14:19: error: cannot find 'alphabet' in scope\n\
    \        result += alphabet[alphabet.indexOf(c) + 2]\n                  ^~~~~~~~\n\
    /tmp/tmp9ir7otwz.swift:14:28: error: cannot find 'alphabet' in scope\n       \
    \ result += alphabet[alphabet.indexOf(c) + 2]\n                           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0061)) +\
    \ UInt32(0x0062)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0062))\
    \ + UInt32(0x0063)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0063))\
    \ + UInt32(0x0064)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0064))\
    \ + UInt32(0x0065)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0065))\
    \ + UInt32(0x0066)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0066))\
    \ + UInt32(0x0067)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0067))\
    \ + UInt32(0x0068)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0068))\
    \ + UInt32(0x0069)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0069))\
    \ + UInt32(0x006A)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x006A))\
    \ + UInt32(0x006B)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x006B))\
    \ + UInt32(0x006C)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x006C))\
    \ + UInt32(0x006D)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x006D))\
    \ + UInt32(0x006E)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x006E))\
    \ + UInt32(0x006F)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x006F))\
    \ + UInt32(0x0070)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0070))\
    \ + UInt32(0x0071)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0071))\
    \ + UInt32(0x0072)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0072))\
    \ + UInt32(0x0073)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0073))\
    \ + UInt32(0x0074)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0074))\
    \ + UInt32(0x0075)))\n    alphabet.append(Character(Charact\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpc49oxdsq.swift:37:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpc49oxdsq.swift:36:30: note: to match this opening '('\n    alphabet.append(Character(Charact\n\
    \                             ^\n/tmp/tmpc49oxdsq.swift:13:16: error: 'characters'\
    \ is unavailable: Please use String directly\n    for c in s.characters {\n  \
    \             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpc49oxdsq.swift:16:21: error: no exact matches in call to initializer\
    \ \n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0061)) + UInt32(0x0062)))\n\
    \                    ^\n/tmp/tmpc49oxdsq.swift:16:21: note: found candidate with\
    \ type '(Unicode.Scalar) -> Character'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0061))\
    \ + UInt32(0x0062)))\n                    ^\n/tmp/tmpc49oxdsq.swift:16:21: note:\
    \ found candidate with type '(String) -> Character'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0061))\
    \ + UInt32(0x0062)))\n                    ^\n/tmp/tmpc49oxdsq.swift:16:73: error:\
    \ cannot convert value of type 'UInt32' to expected argument type 'String'\n \
    \   alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0061)) + UInt32(0x0062)))\n\
    \                                                                        ^\n/tmp/tmpc49oxdsq.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0061))\
    \ + UInt32(0x0062)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n\
    /tmp/tmpc49oxdsq.swift:17:21: error: no exact matches in call to initializer \n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0062)) + UInt32(0x0063)))\n\
    \                    ^\n/tmp/tmpc49oxdsq.swift:17:21: note: found candidate with\
    \ type '(Unicode.Scalar) -> Character'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0062))\
    \ + UInt32(0x0063)))\n                    ^\n/tmp/tmpc49oxdsq.swift:17:21: note:\
    \ found candidate with type '(String) -> Character'"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 18)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 20)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 22)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 24)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 26)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 28)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 30)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 32)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 34)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 36)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 38)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 40)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 42)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 44)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 46)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 48)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 50)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 52)))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp0ag9gkho.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp0ag9gkho.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:23:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:24:41:\
    \ error: type"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 18)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 20)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 22)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 24)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 26)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 28)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 30)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 32)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 34)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 36)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 38)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 40)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 42)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 44)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 46)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 48)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 50)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 52)))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp0ag9gkho.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp0ag9gkho.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:23:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:24:41:\
    \ error: type"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n    var alphabetLength = alphabet.count\n\
    \    var alphabetRotation = alphabet.characters.reversed().map { $0 }\n    var\
    \ alphabetRotationLength = alphabetRotation.count\n    var alphabetRotationIndex\
    \ = 0\n    var alphabetRotationIndex2 = 0\n    var alphabetRotationIndex3 = 0\n\
    \    var alphabetRotationIndex4 = 0\n    var alphabetRotationIndex5 = 0\n    var\
    \ alphabetRotationIndex6 = 0\n    var alphabetRotationIndex7 = 0\n    var alphabetRotationIndex8\
    \ = 0\n    var alphabetRotationIndex9 = 0\n    var alphabetRotationIndex10 = 0\n\
    \    var alphabetRotationIndex11 = 0\n    var alphabetRotationIndex12 = 0\n  \
    \  var alphabetRotationIndex13 = 0\n    var alphabetRotationIndex14 = 0\n    var\
    \ alphabetRotationIndex15 = 0\n    var alphabetRotationIndex16 = 0\n    var alphabetRotationIndex17\
    \ = 0\n    var alphabetRotationIndex18 = 0\n    var alphabetRotationIndex19 =\
    \ 0\n    var alphabetRotationIndex20 = 0\n    var alphabetRotationIndex21 = 0\n\
    \    var alphabetRotationIndex22 = 0\n    var alphabetRotationIndex23 = 0\n  \
    \  var alphabetRotationIndex24 = 0\n    var alphabetRotationIndex25 = 0\n    var\
    \ alphabetRotationIndex26 = 0\n    var alphabetRotationIndex27 = 0\n    var alphabetRotationIndex28\
    \ = 0\n    var alphabetRotationIndex29 = 0\n    var alphabetRotationIndex30 =\
    \ 0\n    var alphabetRotationIndex31 = 0\n    var alphabetRotationIndex32 = 0\n\
    \    var alphabetRotationIndex33 = 0\n    var alphabetRotationIndex34 = 0\n  \
    \  var alphabetRotationIndex35 = 0\n    var alphabetRotationIndex36 = 0\n    var\
    \ alphabetRotationIndex37 = 0\n    var alphabetRotationIndex38 = 0\n    var alphabetRotationIndex39\
    \ = 0\n    var alphabetRotationIndex40 = 0\n    var alphabetRotationIndex41 =\
    \ 0\n    var alphabetRotationIndex42 = 0\n    var alphabetRotationIndex43 = 0\n\
    \    var alphabetRotationIndex44 = 0\n    var alphabetRotationIndex45 = 0\n  \
    \  var alphabetRotationIndex46 = 0\n    var alphabetRotationIndex47 = 0\n    var\
    \ alphabetRotationIndex48 = 0\n    var alphabetRotationIndex49 = 0\n    var alphabetRotationIndex50\
    \ = 0\n    var alphabetRotationIndex51 = 0\n    var alphabetRotationIndex52 =\
    \ 0\n    var alphabetRotationIndex53 = 0\n    var alphabetRotationIndex54 = 0\n\
    \    var alphabetRotationIndex55 = 0\n    var alphabetRotationIndex56 = 0\n  \
    \  var alphabetRotationIndex57 = 0\n    var alphabetRotationIndex58 = 0\n    var\
    \ alphabetRotationIndex59 = 0\n    var alphabetRotationIndex60 = 0\n    var alphabetRotationIndex61\
    \ = 0\n    var alphabetRotationIndex62 = 0\n    var alphabetRotationIndex63 =\
    \ 0\n    var alphabetRotationIndex64 = 0\n    var alphabetRotationIndex65 = 0\n\
    \    var alphabetRotationIndex66 = 0\n    var alphabetRotation\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp8_wlo6sf.swift:14:37: error: 'characters' is unavailable: Please\
    \ use String directly\n    var alphabetRotation = alphabet.characters.reversed().map\
    \ { $0 }\n                                    ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp8_wlo6sf.swift:82:9: error: type annotation\
    \ missing in pattern\n    var alphabetRotation\n        ^\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        result = result + alphabet[alphabet.index(c)\
    \ + 2]\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpi2k6kouw.swift:14:27: error: cannot find 'alphabet' in scope\n\
    \        result = result + alphabet[alphabet.index(c) + 2]\n                 \
    \         ^~~~~~~~\n/tmp/tmpi2k6kouw.swift:14:36: error: cannot find 'alphabet'\
    \ in scope\n        result = result + alphabet[alphabet.index(c) + 2]\n      \
    \                             ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n\tlet alphabet\
    \ = Array(s.characters)\n\tlet alphabetLength = alphabet.count\n\tlet alphabetShift\
    \ = alphabetLength / 2\n\tlet alphabetShift2 = alphabetShift * 2\n\tlet alphabetShift3\
    \ = alphabetShift * 3\n\tlet alphabetShift4 = alphabetShift * 4\n\tlet alphabetShift5\
    \ = alphabetShift * 5\n\tlet alphabetShift6 = alphabetShift * 6\n\tlet alphabetShift7\
    \ = alphabetShift * 7\n\tlet alphabetShift8 = alphabetShift * 8\n\tlet alphabetShift9\
    \ = alphabetShift * 9\n\tlet alphabetShift10 = alphabetShift * 10\n\tlet alphabetShift11\
    \ = alphabetShift * 11\n\tlet alphabetShift12 = alphabetShift * 12\n\tlet alphabetShift13\
    \ = alphabetShift * 13\n\tlet alphabetShift14 = alphabetShift * 14\n\tlet alphabetShift15\
    \ = alphabetShift * 15\n\tlet alphabetShift16 = alphabetShift * 16\n\tlet alphabetShift17\
    \ = alphabetShift * 17\n\tlet alphabetShift18 = alphabetShift * 18\n\tlet alphabetShift19\
    \ = alphabetShift * 19\n\tlet alphabetShift20 = alphabetShift * 20\n\tlet alphabetShift21\
    \ = alphabetShift * 21\n\tlet alphabetShift22 = alphabetShift * 22\n\tlet alphabetShift23\
    \ = alphabetShift * 23\n\tlet alphabetShift24 = alphabetShift * 24\n\tlet alphabetShift25\
    \ = alphabetShift * 25\n\tlet alphabetShift26 = alphabetShift * 26\n\tlet alphabetShift27\
    \ = alphabetShift * 27\n\tlet alphabetShift28 = alphabetShift * 28\n\tlet alphabetShift29\
    \ = alphabetShift * 29\n\tlet alphabetShift30 = alphabetShift * 30\n\tlet alphabetShift31\
    \ = alphabetShift * 31\n\tlet alphabetShift32 = alphabetShift * 32\n\tlet alphabetShift33\
    \ = alphabetShift * 33\n\tlet alphabetShift34 = alphabetShift * 34\n\tlet alphabetShift35\
    \ = alphabetShift * 35\n\tlet alphabetShift36 = alphabetShift * 36\n\tlet alphabetShift37\
    \ = alphabetShift * 37\n\tlet alphabetShift38 = alphabetShift * 38\n\tlet alphabetShift39\
    \ = alphabetShift * 39\n\tlet alphabetShift40 = alphabetShift * 40\n\tlet alphabetShift41\
    \ = alphabetShift * 41\n\tlet alphabetShift42 = alphabetShift * 42\n\tlet alphabetShift43\
    \ = alphabetShift * 43\n\tlet alphabetShift44 = alphabetShift * 44\n\tlet alphabetShift45\
    \ = alphabetShift * 45\n\tlet alphabetShift46 = alphabetShift * 46\n\t\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpk4pf5ycl.swift:12:25: error: 'characters' is unavailable: Please\
    \ use String directly\n        let alphabet = Array(s.characters)\n          \
    \                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpk4pf5ycl.swift:15:6: warning: initialization of immutable value 'alphabetShift2'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \       let alphabetShift2 = alphabetShift * 2\n        ~~~~^~~~~~~~~~~~~~\n \
    \       _\n/tmp/tmpk4pf5ycl.swift:16:6: warning: initialization of immutable value\
    \ 'alphabetShift3' was never used; consider replacing with assignment to '_' or\
    \ removing it\n        let alphabetShift3 = alphabetShift * 3\n        ~~~~^~~~~~~~~~~~~~\n\
    \        _\n/tmp/tmpk4pf5ycl.swift:17:6: warning: initialization of immutable\
    \ value 'alphabetShift4' was never used; consider replacing with assignment to\
    \ '_' or removing it\n        let alphabetShift4 = alphabetShift * 4\n       \
    \ ~~~~^~~~~~~~~~~~~~\n        _\n/tmp/tmpk4pf5ycl.swift:18:6: warning: initialization\
    \ of immutable value 'alphabetShift5' was never used; consider replacing with\
    \ assignment to '_' or removing it\n        let alphabetShift5 = alphabetShift\
    \ * 5\n        ~~~~^~~~~~~~~~~~~~\n        _\n/tmp/tmpk4pf5ycl.swift:19:6: warning:\
    \ initialization of immutable value 'alphabetShift6' was never used; consider\
    \ replacing with assignment to '_' or removing it\n        let alphabetShift6\
    \ = alphabetShift * 6\n        ~~~~^~~~~~~~~~~~~~\n        _\n/tmp/tmpk4pf5ycl.swift:20:6:\
    \ warning: initialization of immutable value 'alphabetShift7' was never used;\
    \ consider replacing with assignment to '_' or removing it\n        let alphabetShift7\
    \ = alphabetShift * 7\n        ~~~~^~~~~~~~~~~~~~\n        _\n/tmp/tmpk4pf5ycl.swift:21:6:\
    \ warning: initialization of immutable value 'alphabetShift8' was never used;\
    \ consider replacing with assignment to '_' or removing it\n        let alphabetShift8\
    \ = alphabetShift * 8\n        ~~~~^~~~~~~~~~~~~~\n        _\n/tmp/tmpk4pf5ycl.swi"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(Character(c))\n\
    \    }\n    alphabet.append(Character(Character(s.characters.last!) + 1))\n  \
    \  alphabet.append(Character(Character(s.characters.last!) - 1))\n    alphabet.append(Character(Character(s.characters.last!)\
    \ - 2))\n    alphabet.append(Character(Character(s.characters.last!) - 3))\n \
    \   alphabet.append(Character(Character(s.characters.last!) - 4))\n    alphabet.append(Character(Character(s.characters.last!)\
    \ - 5))\n    alphabet.append(Character(Character(s.characters.last!) - 6))\n \
    \   alphabet.append(Character(Character(s.characters.last!) - 7))\n    alphabet.append(Character(Character(s.characters.last!)\
    \ - 8))\n    alphabet.append(Character(Character(s.characters.last!) - 9))\n \
    \   alphabet.append(Character(Character(s.characters.last!) - 10))\n    alphabet.append(Character(Character(s.characters.last!)\
    \ - 11))\n    alphabet.append(Character(Character(s.characters.last!) - 12))\n\
    \    alphabet.append(Character(Character(s.characters.last!) - 13))\n    alphabet.append(Character(Character(s.characters.last!)\
    \ - 14))\n    alphabet.append(Character(Character(s.characters.last!) - 15))\n\
    \    alphabet.append(Character(Character(s.characters.last!) - 16))\n    alphabet.append(Character(Character(s.characters.last!)\
    \ - 17))\n    alphabet.append(Character(Character(s.characters.last!) - 18))\n\
    \    alphabet.append(Character(Character(s.characters.last!) - 19))\n    alphabet.append(Character(Character(s.characters.last!)\
    \ - 20))\n    alphabet.append(Character(Character(s.characters.last!) - 21))\n\
    \    alphabet.append(Character(Character(s.characters.last!) - 22))\n    alphabet.append(Character(Character(s.characters.last!)\
    \ - 23))\n    alphabet.append(Character(Character(s.characters.last!) - 24))\n\
    \    alphabet.append(Character(Character(s.characters.last!) - 25))\n    alphabet.append(Character(Character(s.characters.last!)\
    \ - 26))\n    alphabet.append(Character(Character(s.characters.last!) - 27))\n\
    \    alphabet.append(Character(Character(s.characters.last!) - 28))\n    alphabet.append(Character(Character(s.characters.last!)\
    \ - 29))\n    alphabet.append(Character(Character(s.characters.last!) - 30))\n\
    \    alphabet.append(Character(Character(s.characters.last!) - 31))\n    alphabet.append(Character(Character(s.characters.last!)\
    \ - 32))\n    alphabet.append(Character(Charact\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpgcqez1y4.swift:50:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpgcqez1y4.swift:49:30: note: to match this opening '('\n    alphabet.append(Character(Charact\n\
    \                             ^\n/tmp/tmpgcqez1y4.swift:13:16: error: 'characters'\
    \ is unavailable: Please use String directly\n    for c in s.characters {\n  \
    \             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpgcqez1y4.swift:14:35: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n        alphabet.append(Character(c))\n                           \
    \       ^\n                                  extendedGraphemeClusterLiteral: \n\
    /tmp/tmpgcqez1y4.swift:16:21: error: no exact matches in call to initializer \n\
    \    alphabet.append(Character(Character(s.characters.last!) + 1))\n         \
    \           ^\n/tmp/tmpgcqez1y4.swift:16:21: note: candidate has partially matching\
    \ parameter list (Unicode.Scalar)\n    alphabet.append(Character(Character(s.characters.last!)\
    \ + 1))\n                    ^\n/tmp/tmpgcqez1y4.swift:16:21: note: candidate\
    \ has partially matching parameter list (String)\n    alphabet.append(Character(Character(s.characters.last!)\
    \ + 1))\n                    ^\n/tmp/tmpgcqez1y4.swift:16:31: error: cannot convert\
    \ value of type 'Character' to expected argument type 'Int'\n    alphabet.append(Character(Character(s.characters.last!)\
    \ + 1))\n                              ^\n/tmp/tmpgcqez1y4.swift:16:41: error:\
    \ missing argument label 'extendedGraphemeClusterLiteral:' in call\n    alphabet.append(Character(Character(s.characters.last!)\
    \ + 1))\n                                        ^\n                         \
    \               extendedGraphemeClusterLiteral: \n/tmp/tmpgcqez1y4.swift:17:21:\
    \ error: no exact matches in call to initializer \n    alphabet.append(Character(Character(s.characters.last!)\
    \ - 1))\n                    ^\n/tmp/tmpgcqez1y4.swift:17:21: note: candidate\
    \ has partially matching parameter list (Unicode.Scalar)\n    alphabet.append(Character(Cha"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for letter in s {\n        result += alphabet.index(letter)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpgeakcbc6.swift:14:19: error: cannot find 'alphabet' in scope\n\
    \        result += alphabet.index(letter)\n                  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.sort()\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 4)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 6)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 8)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 10)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 12)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 14)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 16)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 18)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 20)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 22)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 24)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 26)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 28)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 30)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 32)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 34)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 36)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 38)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 40)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 42)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 44)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 46)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 48)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpn9om_y6d.swift:42:66: error: expected member name following '.'\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.\n        \
    \                                                         ^\n/tmp/tmpn9om_y6d.swift:43:1:\
    \ error: expected ')' in expression list\n}\n^\n/tmp/tmpn9om_y6d.swift:42:60:\
    \ note: to match this opening '('\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.\n\
    \                                                           ^\n/tmp/tmpn9om_y6d.swift:13:16:\
    \ error: 'characters' is unavailable: Please use String directly\n    for c in\
    \ s.characters {\n               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpn9om_y6d.swift:17:41: error: type 'Character' has no\
    \ member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpn9om_y6d.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpn9om_y6d.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 4)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpn9om_y6d.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 6)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpn9om_y6d.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 8)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpn9om_y6d.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 10)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp"
  stdout: ''
  timestamp: 1659824988
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet = alphabet[1..<alphabet.count]\n    alphabet = alphabet[1..<alphabet.count]\n\
    \    alphabet = alphabet[1..<alphabet.count]\n    alphabet = alphabet[1..<alphabet.count]\n\
    \    alphabet = alphabet[1..<alphabet.count]\n    alphabet = alphabet[1..<alphabet.count]\n\
    \    alphabet = alphabet[1..<alphabet.count]\n    alphabet = alphabet[1..<alphabet.count]\n\
    \    alphabet = alphabet[1..<alphabet.count]\n    alphabet = alphabet[1..<alphabet.count]\n\
    \    alphabet = alphabet[1..<alphabet.count]\n    alphabet = alphabet[1..<alphabet.count]\n\
    \    alphabet = alphabet[1..<alphabet.count]\n    alphabet = alphabet[1..<alphabet.count]\n\
    \    alphabet = alphabet[1..<alphabet.count]\n    alphabet = alphabet[1..<alphabet.count]\n\
    \    alphabet = alphabet[1..<alphabet.count]\n    alphabet = alphabet[1..<alphabet.count]\n\
    \    alphabet = alphabet[1..<alphabet.count]\n    alphabet = alphabet[1..<alphabet.count]\n\
    \    alphabet = alphabet[1..<alphabet.count]\n    alphabet = alphabet[1..<alphabet.count]\n\
    \    alphabet = alphabet[1..<alphabet.count]\n    alphabet = alphabet[1..<alphabet.count]\n\
    \    alphabet = alphabet[1..<alphabet.count]\n    alphabet = alphabet[1..<alphabet.count]\n\
    \    alphabet = alphabet[1..<alphabet.count]\n    alphabet = alphabet[1..<alphabet.count]\n\
    \    alphabet = alphabet[1..<alphabet.count]\n    alphabet = alphabet[1..<alphabet.count]\n\
    \    alphabet = alphabet[1..<alphabet.count]\n    alphabet = alphabet[1..<alphabet.count]\n\
    \    alphabet = alphabet[1..<alphabet.count]\n    alphabet = alphabet[1..<alphabet.count]\n\
    \    alphabet = alphabet[1..<alphabet.count]\n    alphabet = alphabet[1..<alphabet.count]\n\
    \    alphabet = alphabet[1..<alphabet.count]\n    alphabet = alphabet[1..<alphabet.count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp1moe8n_w.swift:54:1: error: expected ']' in expression list\n}\n\
    ^\n/tmp/tmp1moe8n_w.swift:53:24: note: to match this opening '['\n    alphabet\
    \ = alphabet[1..<alphabet.count\n                       ^\n/tmp/tmp1moe8n_w.swift:13:16:\
    \ error: 'characters' is unavailable: Please use String directly\n    for c in\
    \ s.characters {\n               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp1moe8n_w.swift:16:24: error: cannot assign value of\
    \ type 'ArraySlice<Character>' to type '[Character]'\n    alphabet = alphabet[1..<alphabet.count]\n\
    \               ~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1moe8n_w.swift:17:24: error:\
    \ cannot assign value of type 'ArraySlice<Character>' to type '[Character]'\n\
    \    alphabet = alphabet[1..<alphabet.count]\n               ~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp1moe8n_w.swift:18:24: error: cannot assign value of type 'ArraySlice<Character>'\
    \ to type '[Character]'\n    alphabet = alphabet[1..<alphabet.count]\n       \
    \        ~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1moe8n_w.swift:19:24: error: cannot\
    \ assign value of type 'ArraySlice<Character>' to type '[Character]'\n    alphabet\
    \ = alphabet[1..<alphabet.count]\n               ~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp1moe8n_w.swift:20:24: error: cannot assign value of type 'ArraySlice<Character>'\
    \ to type '[Character]'\n    alphabet = alphabet[1..<alphabet.count]\n       \
    \        ~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1moe8n_w.swift:21:24: error: cannot\
    \ assign value of type 'ArraySlice<Character>' to type '[Character]'\n    alphabet\
    \ = alphabet[1..<alphabet.count]\n               ~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp1moe8n_w.swift:22:24: error: cannot assign value of type 'ArraySlice<Character>'\
    \ to type '[Character]'\n    alphabet = alphabet[1..<alphabet.count]\n       \
    \        ~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1moe8n_w.swift:23:24: error: cannot\
    \ assign value of type 'ArraySlice<Character>' to type '[Character]'\n    alphabet\
    \ = alphabet[1..<alphabet.count]\n               ~~~~~~~~"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n\tlet alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n\tlet alphabetLength = alphabet.count\n\t\
    let alphabetIndex: Dictionary<String, Int> = [:]\n\t\n\tfor char in alphabet {\n\
    \t\talphabetIndex[char] = alphabet.index(char)\n\t}\n\t\n\tlet alphabetIndexLength\
    \ = alphabetIndex.count\n\t\n\tlet newAlphabet = Array(alphabet)\n\t\n\tlet newAlphabetLength\
    \ = newAlphabet.count\n\t\n\tlet newAlphabetIndex: Dictionary<String, Int> = [:]\n\
    \t\n\tfor char in newAlphabet {\n\t\tnewAlphabetIndex[char] = newAlphabet.index(char)\n\
    \t}\n\t\n\tlet newAlphabetIndexLength = newAlphabetIndex.count\n\t\n\tlet newAlphabetIndexEncrypted:\
    \ Dictionary<String, Int> = [:]\n\t\n\tfor char in newAlphabet {\n\t\tlet index\
    \ = alphabetIndex[char]\n\t\tlet indexEncrypted = (index * 2) + 1\n\t\tnewAlphabetIndexEncrypted[char]\
    \ = indexEncrypted\n\t}\n\t\n\tlet newAlphabetIndexEncryptedLength = newAlphabetIndexEncrypted.count\n\
    \t\n\tlet newAlphabetIndexEncryptedEncrypted: Dictionary<String, Int> = [:]\n\t\
    \n\tfor char in newAlphabet {\n\t\tlet index = newAlphabetIndexEncrypted[char]\n\
    \t\tlet indexEncrypted = (index * 2) + 2\n\t\tnewAlphabetIndexEncryptedEncrypted[char]\
    \ = indexEncrypted\n\t}\n\t\n\tlet newAlphabetIndexEncryptedEncryptedLength =\
    \ newAlphabetIndexEncryptedEncrypted.count\n\t\n\tlet newAlphabetIndexEncryptedEncryptedEncrypted:\
    \ Dictionary<String, Int> = [:]\n\t\n\tfor char in newAlphabet {\n\t\tlet index\
    \ = newAlphabetIndexEncryptedEncrypted[char]\n\t\tlet indexEncrypted = (index\
    \ * 2) + 3\n\t\tnewAlphabetIndexEncryptedEncryptedEncrypted[char] = indexEncrypted\n\
    \t}\n\t\n\tlet newAlphabetIndexEncryptedEncryptedEncryptedLength = newAlphabetIndexEncryptedEncryptedEncrypted.count\n\
    \t\n\tlet newAlphabetIndexEncryptedEncryptedEncryptedEncrypted: Dictionary<String,\
    \ Int> = [:]\n\t\n\tfor char in newAlphabet {\n\t\tlet index = new\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp_cnv2d7u.swift:90:31: error: expected '}' at end of brace statement\n\
    assert(encrypt(s: \"a\") == \"e\")\n                              ^\n/tmp/tmp_cnv2d7u.swift:11:35:\
    \ note: to match this opening '{'\nfunc encrypt(s: String) -> String {\n     \
    \                             ^\n/tmp/tmp_cnv2d7u.swift:17:16: error: no exact\
    \ matches in call to subscript \n                alphabetIndex[char] = alphabet.index(char)\n\
    \                             ^\n/tmp/tmp_cnv2d7u.swift:17:16: note: found candidate\
    \ with type '(Dictionary<String, Int>.Index) -> (key: String, value: Int)'\n \
    \               alphabetIndex[char] = alphabet.index(char)\n                 \
    \            ^\n/tmp/tmp_cnv2d7u.swift:17:16: note: found candidate with type\
    \ '(Range<Dictionary<String, Int>.Index>) -> Slice<[String : Int]>'\n        \
    \        alphabetIndex[char] = alphabet.index(char)\n                        \
    \     ^\n/tmp/tmp_cnv2d7u.swift:17:16: note: found candidate with type '((UnboundedRange_)\
    \ -> ()) -> Dictionary<String, Int>.SubSequence' (aka '((UnboundedRange_) -> ())\
    \ -> Slice<Dictionary<String, Int>>')\n                alphabetIndex[char] = alphabet.index(char)\n\
    \                             ^\n/tmp/tmp_cnv2d7u.swift:17:40: error: missing\
    \ argument label 'of:' in call\n                alphabetIndex[char] = alphabet.index(char)\n\
    \                                                     ^\n                    \
    \                                 of: \n/tmp/tmp_cnv2d7u.swift:17:34: error: no\
    \ 'index' candidates produce the expected contextual result type '(key: String,\
    \ value: Int)'\n                alphabetIndex[char] = alphabet.index(char)\n \
    \                                              ^\nSwift.Collection:3:28: note:\
    \ 'index(of:)' produces 'String.Index?', not the expected contextual result type\
    \ '(key: String, value: Int)'\n    @inlinable public func index(of element: Self.Element)\
    \ -> Self.Index?\n                           ^\nSwift.Collection:3:28: note: 'index(of:)'\
    \ produces 'String.Index?', not the expected contextual result type 'Slice<Dictionary<String,\
    \ Int>>'\n    @inlinable public fu"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n\tlet alphabet\
    \ = Array(s.characters)\n\tlet alphabetLength = alphabet.count\n\tlet alphabetLength\
    \ = alphabetLength * 2\n\tlet alphabetLength = alphabetLength / 2\n\tlet alphabetLength\
    \ = alphabetLength + alphabetLength\n\tlet alphabetLength = alphabetLength + alphabetLength\n\
    \tlet alphabetLength = alphabetLength + alphabetLength\n\tlet alphabetLength =\
    \ alphabetLength + alphabetLength\n\tlet alphabetLength = alphabetLength + alphabetLength\n\
    \tlet alphabetLength = alphabetLength + alphabetLength\n\tlet alphabetLength =\
    \ alphabetLength + alphabetLength\n\tlet alphabetLength = alphabetLength + alphabetLength\n\
    \tlet alphabetLength = alphabetLength + alphabetLength\n\tlet alphabetLength =\
    \ alphabetLength + alphabetLength\n\tlet alphabetLength = alphabetLength + alphabetLength\n\
    \tlet alphabetLength = alphabetLength + alphabetLength\n\tlet alphabetLength =\
    \ alphabetLength + alphabetLength\n\tlet alphabetLength = alphabetLength + alphabetLength\n\
    \tlet alphabetLength = alphabetLength + alphabetLength\n\tlet alphabetLength =\
    \ alphabetLength + alphabetLength\n\tlet alphabetLength = alphabetLength + alphabetLength\n\
    \tlet alphabetLength = alphabetLength + alphabetLength\n\tlet alphabetLength =\
    \ alphabetLength + alphabetLength\n\tlet alphabetLength = alphabetLength + alphabetLength\n\
    \tlet alphabetLength = alphabetLength + alphabetLength\n\tlet alphabetLength =\
    \ alphabetLength + alphabetLength\n\tlet alphabetLength = alphabetLength + alphabetLength\n\
    \tlet alphabetLength = alphabetLength + alphabetLength\n\tlet alphabetLength =\
    \ alphabetLength + alphabetLength\n\tlet alphabetLength = alphabetLength + alphabetLength\n\
    \tlet alphabetLength = alphabetLength + alphabetLength\n\tlet alphabetLength =\
    \ alphabetLength + alphabetLength\n\tlet alphabetLength = alphabetLength + alphabetLength\n\
    \tlet alphabetLength = alphabetLength + alphabetLength\n\tlet alphabetLength =\
    \ alphabetLength + alphabetLength\n\tlet alphabetLength = alphabetLength + alphabetLength\n\
    \tlet alphabetLength = alphabetLength + alphabetLength\n\tlet alphabetLength =\
    \ alphabetLength + alphabetLength\n\tlet alphabetLength = alphabetLength + alphabetLength\n\
    \tlet alphabetLength = alphabetLength + alphabetLength\n\tlet alphabetLength =\
    \ alphabetLength + alphabetLength\n\tlet alphabetLength = alphabetLength + alphabetLength\n\
    \tlet alphabetLength = alphabetLength + alphabetLength\n\tlet alphabetLength =\
    \ alphabetLength + alphabetLength\n\tlet alphabetLength = alphabetLength + alphabetLength\n\
    \tlet alphabetLength = alphabetLength + alphabetLength\n\tlet alphabetLength =\
    \ alphabetLength + alphabetLength\n\tlet alphabetLength = alphabetLength + alphabetLength\n\
    \tlet alphabetLength = alphabetLength + alphabetLength\n\tlet alphabetLength =\
    \ alphabetLength + alphabetLength\n\tlet alphabetLength = alphabetLength + alphabetLength\n\
    \tlet alphabetLength = alphabetLength + \n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpxt8vedo6.swift:64:1: error: expected expression after operator\n\
    }\n^\n/tmp/tmpxt8vedo6.swift:12:25: error: 'characters' is unavailable: Please\
    \ use String directly\n        let alphabet = Array(s.characters)\n          \
    \                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpxt8vedo6.swift:14:6: error: invalid redeclaration of 'alphabetLength'\n\
    \        let alphabetLength = alphabetLength * 2\n            ^\n/tmp/tmpxt8vedo6.swift:13:6:\
    \ note: 'alphabetLength' previously declared here\n        let alphabetLength\
    \ = alphabet.count\n            ^\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.sort()\n    var result = [Character]()\n    for c in alphabet\
    \ {\n        result.append(c)\n        result.append(c)\n    }\n    return String(result)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmponbdycni.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        var index = alphabet.indexOf(c)\n        index\
    \ = index / 2\n        index = index * 2\n        index = index + alphabet.indexOf(\"\
    a\")\n        result += alphabet[index]\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpn3sddkjp.swift:14:21: error: cannot find 'alphabet' in scope\n\
    \        var index = alphabet.indexOf(c)\n                    ^~~~~~~~\n/tmp/tmpn3sddkjp.swift:17:25:\
    \ error: cannot find 'alphabet' in scope\n        index = index + alphabet.indexOf(\"\
    a\")\n                        ^~~~~~~~\n/tmp/tmpn3sddkjp.swift:18:19: error: cannot\
    \ find 'alphabet' in scope\n        result += alphabet[index]\n              \
    \    ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    alphabet.append(Character(\"a\"))\n    alphabet.append(Character(\"\
    b\"))\n    alphabet.append(Character(\"c\"))\n    alphabet.append(Character(\"\
    d\"))\n    alphabet.append(Character(\"e\"))\n    alphabet.append(Character(\"\
    f\"))\n    alphabet.append(Character(\"g\"))\n    alphabet.append(Character(\"\
    h\"))\n    alphabet.append(Character(\"i\"))\n    alphabet.append(Character(\"\
    j\"))\n    alphabet.append(Character(\"k\"))\n    alphabet.append(Character(\"\
    l\"))\n    alphabet.append(Character(\"m\"))\n    alphabet.append(Character(\"\
    n\"))\n    alphabet.append(Character(\"o\"))\n    alphabet.append(Character(\"\
    p\"))\n    alphabet.append(Character(\"q\"))\n    alphabet.append(Character(\"\
    r\"))\n    alphabet.append(Character(\"s\"))\n    alphabet.append(Character(\"\
    t\"))\n    alphabet.append(Character(\"u\"))\n    alphabet.append(Character(\"\
    v\"))\n    alphabet.append(Character(\"w\"))\n    alphabet.append(Character(\"\
    x\"))\n    alphabet.append(Character(\"y\"))\n    alphabet.append(Character(\"\
    z\"))\n    alphabet.append(Character(\"A\"))\n    alphabet.append(Character(\"\
    B\"))\n    alphabet.append(Character(\"C\"))\n    alphabet.append(Character(\"\
    D\"))\n    alphabet.append(Character(\"E\"))\n    alphabet.append(Character(\"\
    F\"))\n    alphabet.append(Character(\"G\"))\n    alphabet.append(Character(\"\
    H\"))\n    alphabet.append(Character(\"I\"))\n    alphabet.append(Character(\"\
    J\"))\n    alphabet.append(Character(\"K\"))\n    alphabet.append(Character(\"\
    L\"))\n    alphabet.append(Character(\"M\"))\n    alphabet.append(Character(\"\
    N\"))\n    alphabet.append(Character(\"O\"))\n    alphabet.append(Character(\"\
    P\"))\n    alphabet.append(Character(\"Q\"))\n    alphabet.append(Character(\"\
    R\"))\n    alphabet.append(Character(\"S\"))\n    alphabet.append(Character(\"\
    T\"))\n    alphabet.append(Character(\"U\"))\n    alphabet.append(Character(\"\
    V\"))\n    alphabet.append(Character(\"W\"))\n    alphabet.append(Character(\"\
    X\"))\n    alphabet.append(Character(\"Y\"))\n    alphabet.append(Character(\"\
    Z\"))\n    \n    var result = [Character]()\n    var index = 0\n    for char in\
    \ s {\n        result.append(alphabet[(index+2)%26])\n        index++\n    }\n\
    \    return String(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp_cnj149y.swift:70:14: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n        index++\n             ^~\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n\tlet alphabet\
    \ = Array(s.characters)\n\tlet alphabetLength = alphabet.count\n\tlet alphabetRotation\
    \ = alphabet.map { $0 }\n\tlet alphabetRotationLength = alphabetRotation.count\n\
    \tlet alphabetRotationOffset = alphabetRotationLength / 2\n\tlet alphabetRotationOffset2\
    \ = alphabetRotationOffset * 2\n\tlet alphabetRotationOffset3 = alphabetRotationOffset2\
    \ * 2\n\tlet alphabetRotationOffset4 = alphabetRotationOffset3 * 2\n\tlet alphabetRotationOffset5\
    \ = alphabetRotationOffset4 * 2\n\tlet alphabetRotationOffset6 = alphabetRotationOffset5\
    \ * 2\n\tlet alphabetRotationOffset7 = alphabetRotationOffset6 * 2\n\tlet alphabetRotationOffset8\
    \ = alphabetRotationOffset7 * 2\n\tlet alphabetRotationOffset9 = alphabetRotationOffset8\
    \ * 2\n\tlet alphabetRotationOffset10 = alphabetRotationOffset9 * 2\n\tlet alphabetRotationOffset11\
    \ = alphabetRotationOffset10 * 2\n\tlet alphabetRotationOffset12 = alphabetRotationOffset11\
    \ * 2\n\tlet alphabetRotationOffset13 = alphabetRotationOffset12 * 2\n\tlet alphabetRotationOffset14\
    \ = alphabetRotationOffset13 * 2\n\tlet alphabetRotationOffset15 = alphabetRotationOffset14\
    \ * 2\n\tlet alphabetRotationOffset16 = alphabetRotationOffset15 * 2\n\tlet alphabetRotationOffset17\
    \ = alphabetRotationOffset16 * 2\n\tlet alphabetRotationOffset18 = alphabetRotationOffset17\
    \ * 2\n\tlet alphabetRotationOffset19 = alphabetRotationOffset18 * 2\n\tlet alphabetRotationOffset20\
    \ = alphabetRotationOffset19 * 2\n\tlet alphabetRotationOffset21 = alphabetRotationOffset20\
    \ * 2\n\tlet alphabetRotationOffset22 = alphabetRotationOffset21 * 2\n\tlet alphabetRotationOffset23\
    \ = alphabetRotationOffset22 * 2\n\tlet alphabetRotationOffset24 = alphabetRotationOffset23\
    \ * 2\n\tlet alphabetRotationOffset25 = alphabetRotationOffset24 * 2\n\tlet alphabetRotationOffset26\
    \ = alphabetRotationOffset25 * 2\n\tlet alphabetRotationOffset27 = alphabetRotationOffset26\
    \ * 2\n\tlet alphabetRotationOffset28 = alphabetRotationOffset27 * 2\n\tlet alphabetRotationOffset29\
    \ = alphabetRotationOffset28 * 2\n\tlet alphabetRotationOffset30 = alphabetRotationOffset29\
    \ * 2\n\tlet alphabetRotationOffset31 = alphabetRotationOffset30 * 2\n\tlet alphabetRotationOffset32\
    \ = alphabetRotationOffset31 * 2\n\tlet alphabetRotationOffset33 = alphabetRotationOffset32\
    \ * 2\n\tlet alphabetRotationOffset34 = alphabetRotationOffset33 * 2\n\tlet alphabetRotationOffset35\
    \ = alphabetRotationOffset34 * 2\n\tlet \n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp10s83e1e.swift:51:5: error: expected pattern\n        let \n  \
    \         ^\n/tmp/tmp10s83e1e.swift:12:25: error: 'characters' is unavailable:\
    \ Please use String directly\n        let alphabet = Array(s.characters)\n   \
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp10s83e1e.swift:13:6: warning: initialization of immutable\
    \ value 'alphabetLength' was never used; consider replacing with assignment to\
    \ '_' or removing it\n        let alphabetLength = alphabet.count\n        ~~~~^~~~~~~~~~~~~~\n\
    \        _\n/tmp/tmp10s83e1e.swift:50:6: warning: initialization of immutable\
    \ value 'alphabetRotationOffset35' was never used; consider replacing with assignment\
    \ to '_' or removing it\n        let alphabetRotationOffset35 = alphabetRotationOffset34\
    \ * 2\n        ~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n        _\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 18)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 20)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 22)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 24)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 26)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 28)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 30)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 32)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 34)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 36)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 38)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 40)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 42)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 44)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 46)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 48)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 50)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 52)))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp0ag9gkho.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp0ag9gkho.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:23:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:24:41:\
    \ error: type"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        result = result + alphabet[alphabet.IndexOf(alphabet[c])]\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp1n6_y0u2.swift:14:27: error: cannot find 'alphabet' in scope\n\
    \        result = result + alphabet[alphabet.IndexOf(alphabet[c])]\n         \
    \                 ^~~~~~~~\n/tmp/tmp1n6_y0u2.swift:14:36: error: cannot find 'alphabet'\
    \ in scope\n        result = result + alphabet[alphabet.IndexOf(alphabet[c])]\n\
    \                                   ^~~~~~~~\n/tmp/tmp1n6_y0u2.swift:14:53: error:\
    \ cannot find 'alphabet' in scope\n        result = result + alphabet[alphabet.IndexOf(alphabet[c])]\n\
    \                                                    ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        result = result + alphabet[alphabet.Index(c)%alphabet.Length]\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpul_lh90t.swift:14:27: error: cannot find 'alphabet' in scope\n\
    \        result = result + alphabet[alphabet.Index(c)%alphabet.Length]\n     \
    \                     ^~~~~~~~\n/tmp/tmpul_lh90t.swift:14:36: error: cannot find\
    \ 'alphabet' in scope\n        result = result + alphabet[alphabet.Index(c)%alphabet.Length]\n\
    \                                   ^~~~~~~~\n/tmp/tmpul_lh90t.swift:14:54: error:\
    \ cannot find 'alphabet' in scope\n        result = result + alphabet[alphabet.Index(c)%alphabet.Length]\n\
    \                                                     ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        let index = alphabet.indexOf(c)\n        let\
    \ newIndex = index + 2\n        if newIndex < alphabet.count {\n            result\
    \ += alphabet[newIndex]\n        } else {\n            result += alphabet[alphabet.count\
    \ - 1]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpr9hn6wu5.swift:14:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.indexOf(c)\n                    ^~~~~~~~\n/tmp/tmpr9hn6wu5.swift:16:23:\
    \ error: cannot find 'alphabet' in scope\n        if newIndex < alphabet.count\
    \ {\n                      ^~~~~~~~\n/tmp/tmpr9hn6wu5.swift:17:23: error: cannot\
    \ find 'alphabet' in scope\n            result += alphabet[newIndex]\n       \
    \               ^~~~~~~~\n/tmp/tmpr9hn6wu5.swift:19:23: error: cannot find 'alphabet'\
    \ in scope\n            result += alphabet[alphabet.count - 1]\n             \
    \         ^~~~~~~~\n/tmp/tmpr9hn6wu5.swift:19:32: error: cannot find 'alphabet'\
    \ in scope\n            result += alphabet[alphabet.count - 1]\n             \
    \                  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Charact\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpz31nwtqv.swift:44:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpz31nwtqv.swift:43:30: note: to match this opening '('\n    alphabet.append(Character(Charact\n\
    \                             ^\n/tmp/tmpz31nwtqv.swift:13:16: error: 'characters'\
    \ is unavailable: Please use String directly\n    for c in s.characters {\n  \
    \             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpz31nwtqv.swift:16:41: error: type 'Character' has no member 'UnicodeScalar'\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count) -\
    \ 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpz31nwtqv.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpz31nwtqv.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpz31nwtqv.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpz31nwtqv.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpz31nwtqv.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpz31nwtqv.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpz31nwtqv.swift:"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Charact\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpafv4fmj0.swift:44:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpafv4fmj0.swift:43:30: note: to match this opening '('\n    alphabet.append(Character(Charact\n\
    \                             ^\n/tmp/tmpafv4fmj0.swift:13:16: error: 'characters'\
    \ is unavailable: Please use String directly\n    for c in s.characters {\n  \
    \             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpafv4fmj0.swift:16:41: error: type 'Character' has no member 'UnicodeScalar'\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpafv4fmj0.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 1)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpafv4fmj0.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpafv4fmj0.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 1)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpafv4fmj0.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpafv4fmj0.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 1)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpafv4fmj0.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpafv4fmj0"
  stdout: ''
  timestamp: 1659824988
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        var index = alphabet.indexOf(c)\n        index\
    \ = index * 2\n        index = index + 2\n        index = index % alphabet.count\n\
    \        result = result + alphabet[index]\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpgxr9mv12.swift:14:21: error: cannot find 'alphabet' in scope\n\
    \        var index = alphabet.indexOf(c)\n                    ^~~~~~~~\n/tmp/tmpgxr9mv12.swift:17:25:\
    \ error: cannot find 'alphabet' in scope\n        index = index % alphabet.count\n\
    \                        ^~~~~~~~\n/tmp/tmpgxr9mv12.swift:18:27: error: cannot\
    \ find 'alphabet' in scope\n        result = result + alphabet[index]\n      \
    \                    ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        let index = alphabet.indexOf(c)\n        let\
    \ newIndex = index + 2\n        if newIndex < alphabet.count {\n            result\
    \ += alphabet[newIndex]\n        } else {\n            result += alphabet[0]\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpb36jwadj.swift:14:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.indexOf(c)\n                    ^~~~~~~~\n/tmp/tmpb36jwadj.swift:16:23:\
    \ error: cannot find 'alphabet' in scope\n        if newIndex < alphabet.count\
    \ {\n                      ^~~~~~~~\n/tmp/tmpb36jwadj.swift:17:23: error: cannot\
    \ find 'alphabet' in scope\n            result += alphabet[newIndex]\n       \
    \               ^~~~~~~~\n/tmp/tmpb36jwadj.swift:19:23: error: cannot find 'alphabet'\
    \ in scope\n            result += alphabet[0]\n                      ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        result = result + alphabet[alphabet.indexOf(c)\
    \ + 2]\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpbw4bcy9o.swift:14:27: error: cannot find 'alphabet' in scope\n\
    \        result = result + alphabet[alphabet.indexOf(c) + 2]\n               \
    \           ^~~~~~~~\n/tmp/tmpbw4bcy9o.swift:14:36: error: cannot find 'alphabet'\
    \ in scope\n        result = result + alphabet[alphabet.indexOf(c) + 2]\n    \
    \                               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0061)) +\
    \ UInt32(0x0062)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0062))\
    \ + UInt32(0x0063)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0063))\
    \ + UInt32(0x0064)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0064))\
    \ + UInt32(0x0065)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0065))\
    \ + UInt32(0x0066)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0066))\
    \ + UInt32(0x0067)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0067))\
    \ + UInt32(0x0068)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0068))\
    \ + UInt32(0x0069)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0069))\
    \ + UInt32(0x006A)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x006A))\
    \ + UInt32(0x006B)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x006B))\
    \ + UInt32(0x006C)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x006C))\
    \ + UInt32(0x006D)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x006D))\
    \ + UInt32(0x006E)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x006E))\
    \ + UInt32(0x006F)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x006F))\
    \ + UInt32(0x0070)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0070))\
    \ + UInt32(0x0071)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0071))\
    \ + UInt32(0x0072)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0072))\
    \ + UInt32(0x0073)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0073))\
    \ + UInt32(0x0074)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0074))\
    \ + UInt32(0x0075)))\n    alphabet.append(Character(Charact\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpc49oxdsq.swift:37:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpc49oxdsq.swift:36:30: note: to match this opening '('\n    alphabet.append(Character(Charact\n\
    \                             ^\n/tmp/tmpc49oxdsq.swift:13:16: error: 'characters'\
    \ is unavailable: Please use String directly\n    for c in s.characters {\n  \
    \             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpc49oxdsq.swift:16:21: error: no exact matches in call to initializer\
    \ \n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0061)) + UInt32(0x0062)))\n\
    \                    ^\n/tmp/tmpc49oxdsq.swift:16:21: note: found candidate with\
    \ type '(Unicode.Scalar) -> Character'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0061))\
    \ + UInt32(0x0062)))\n                    ^\n/tmp/tmpc49oxdsq.swift:16:21: note:\
    \ found candidate with type '(String) -> Character'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0061))\
    \ + UInt32(0x0062)))\n                    ^\n/tmp/tmpc49oxdsq.swift:16:73: error:\
    \ cannot convert value of type 'UInt32' to expected argument type 'String'\n \
    \   alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0061)) + UInt32(0x0062)))\n\
    \                                                                        ^\n/tmp/tmpc49oxdsq.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0061))\
    \ + UInt32(0x0062)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n\
    /tmp/tmpc49oxdsq.swift:17:21: error: no exact matches in call to initializer \n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0062)) + UInt32(0x0063)))\n\
    \                    ^\n/tmp/tmpc49oxdsq.swift:17:21: note: found candidate with\
    \ type '(Unicode.Scalar) -> Character'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(0x0062))\
    \ + UInt32(0x0063)))\n                    ^\n/tmp/tmpc49oxdsq.swift:17:21: note:\
    \ found candidate with type '(String) -> Character'"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        let index = alphabet.index(of: c)!\n     \
    \   let newIndex = index + 2\n        let newChar = alphabet[newIndex]\n     \
    \   result += newChar\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpznz49ml9.swift:14:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: c)!\n                    ^~~~~~~~\n/tmp/tmpznz49ml9.swift:16:23:\
    \ error: cannot find 'alphabet' in scope\n        let newChar = alphabet[newIndex]\n\
    \                      ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    a\"))\n    }\n    alphabet.append(Character(\"z\"))\n    var result = \"\"\n \
    \   for char in s {\n        let index = alphabet.index(of: char)!\n        result\
    \ += alphabet[(index+2)%26]\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpii2gwkz1.swift:19:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        let index = alphabet.index(of: char)!\n      \
    \                       ^\n/tmp/tmpii2gwkz1.swift:19:30: note: use 'firstIndex(of:)'\
    \ instead\n        let index = alphabet.index(of: char)!\n                   \
    \          ^~~~~\n                             firstIndex\n/tmp/tmpii2gwkz1.swift:20:27:\
    \ error: no exact matches in call to subscript \n        result += alphabet[(index+2)%26]\n\
    \                          ^\nSwift.String:3:35: note: candidate expects value\
    \ of type 'String' for parameter #2 (got 'Character')\n    @inlinable public static\
    \ func += (lhs: inout String, rhs: String)\n                                 \
    \ ^\nSwift.Array:17:23: note: candidate expects value of type 'Range<Int>' for\
    \ parameter #1 (got 'Int')\n    @inlinable public subscript(bounds: Range<Int>)\
    \ -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\nSwift.MutableCollection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get set }\n                      ^\n/tmp/tmpii2gwkz1.swift:20:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        result += alphabet[(index+2)%26]\n                          ^\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.sort()\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 1)))\n    var result = [Character]()\n    for c in alphabet {\n        result.append(c)\n\
    \    }\n    for _ in 0..<(alphabet.count - 1) {\n        result.append(result[0])\n\
    \    }\n    return String(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpo0pwmeci.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpo0pwmeci.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 1)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+1))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+2))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+3))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+4))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+5))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+6))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+7))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+8))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+9))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+10))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+11))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+12))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+13))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+14))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+15))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+16))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+17))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+18))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+19))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+20))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+21))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+22))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+23))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+24))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+25))))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp4fhgjnmp.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp4fhgjnmp.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count))))\n\
    \                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp4fhgjnmp.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+1))))\n\
    \                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp4fhgjnmp.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+2))))\n\
    \                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp4fhgjnmp.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+3))))\n\
    \                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp4fhgjnmp.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+4))))\n\
    \                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp4fhgjnmp.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+5))))\n\
    \                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp4fhgjnmp.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+6))))\n\
    \                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp4fhgjnmp.swift:23:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count+7))))\n\
    \                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp4fhgjnm"
  stdout: ''
  timestamp: 1659824988
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet = rotate(alphabet)\n    return String(alphabet)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp2dv7hqsg.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp2dv7hqsg.swift:16:16:\
    \ error: cannot find 'rotate' in scope\n    alphabet = rotate(alphabet)\n    \
    \           ^~~~~~\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n\tlet alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n\tvar newString = \"\"\n\tfor char in s {\n\
    \t\tlet index = alphabet.index(of: char)!\n\t\tlet newIndex = index + 2\n\t\t\
    newString = newString + alphabet[newIndex]\n\t}\n\treturn newString\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp9s52vavo.swift:15:24: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n                let index = alphabet.index(of: char)!\n\
    \                                     ^\n/tmp/tmp9s52vavo.swift:15:24: note: use\
    \ 'firstIndex(of:)' instead\n                let index = alphabet.index(of: char)!\n\
    \                                     ^~~~~\n                                \
    \     firstIndex\n/tmp/tmp9s52vavo.swift:16:18: error: cannot convert value of\
    \ type 'String.Index' to expected argument type 'Int'\n                let newIndex\
    \ = index + 2\n                               ^\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    alphabet.append(Character(s.characters[s.characters.startIndex]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+1]))\n   \
    \ alphabet.append(Character(s.characters[s.characters.startIndex+2]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+3]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+4]))\n   \
    \ alphabet.append(Character(s.characters[s.characters.startIndex+5]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+6]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+7]))\n   \
    \ alphabet.append(Character(s.characters[s.characters.startIndex+8]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+9]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+10]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+11]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+12]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+13]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+14]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+15]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+16]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+17]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+18]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+19]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+20]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+21]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+22]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+23]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+24]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+25]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+26]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+27]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+28]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+29]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+30]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpegmyyew7.swift:45:1: error: expected ']' in expression list\n}\n\
    ^\n/tmp/tmpegmyyew7.swift:44:43: note: to match this opening '['\n    alphabet.append(Character(s.characters[s.characters.startIndex\n\
    \                                          ^\n/tmp/tmpegmyyew7.swift:13:31: error:\
    \ missing argument label 'extendedGraphemeClusterLiteral:' in call\n    alphabet.append(Character(s.characters[s.characters.startIndex]))\n\
    \                              ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpegmyyew7.swift:14:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters[s.characters.startIndex+1]))\n\
    \                              ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpegmyyew7.swift:14:57: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n    alphabet.append(Character(s.characters[s.characters.startIndex+1]))\n\
    \                                                        ^\n/tmp/tmpegmyyew7.swift:15:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+2]))\n     \
    \                         ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpegmyyew7.swift:15:57: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n    alphabet.append(Character(s.characters[s.characters.startIndex+2]))\n\
    \                                                        ^\n/tmp/tmpegmyyew7.swift:16:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+3]))\n     \
    \                         ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpegmyyew7.swift:16:57: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n    alphabet.append(Character(s.characters[s.characters.startIndex+3]))\n\
    \                                                        ^\n"
  stdout: ''
  timestamp: 1659824989
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    alphabet.append(Character(s.characters[s.characters.startIndex]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+1]))\n   \
    \ alphabet.append(Character(s.characters[s.characters.startIndex+2]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+3]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+4]))\n   \
    \ alphabet.append(Character(s.characters[s.characters.startIndex+5]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+6]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+7]))\n   \
    \ alphabet.append(Character(s.characters[s.characters.startIndex+8]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+9]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+10]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+11]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+12]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+13]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+14]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+15]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+16]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+17]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+18]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+19]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+20]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+21]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+22]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+23]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+24]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+25]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+26]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+27]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex+28]))\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+29]))\n    alphabet.append(Character(s.characters[s.characters.startIndex+30]))\n\
    \    alphabet.append(Character(s.characters[s.characters.startIndex\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpegmyyew7.swift:45:1: error: expected ']' in expression list\n}\n\
    ^\n/tmp/tmpegmyyew7.swift:44:43: note: to match this opening '['\n    alphabet.append(Character(s.characters[s.characters.startIndex\n\
    \                                          ^\n/tmp/tmpegmyyew7.swift:13:31: error:\
    \ missing argument label 'extendedGraphemeClusterLiteral:' in call\n    alphabet.append(Character(s.characters[s.characters.startIndex]))\n\
    \                              ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpegmyyew7.swift:14:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters[s.characters.startIndex+1]))\n\
    \                              ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpegmyyew7.swift:14:57: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n    alphabet.append(Character(s.characters[s.characters.startIndex+1]))\n\
    \                                                        ^\n/tmp/tmpegmyyew7.swift:15:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+2]))\n     \
    \                         ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpegmyyew7.swift:15:57: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n    alphabet.append(Character(s.characters[s.characters.startIndex+2]))\n\
    \                                                        ^\n/tmp/tmpegmyyew7.swift:16:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.characters[s.characters.startIndex+3]))\n     \
    \                         ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpegmyyew7.swift:16:57: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n    alphabet.append(Character(s.characters[s.characters.startIndex+3]))\n\
    \                                                        ^\n"
  stdout: ''
  timestamp: 1659824989
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        var index = alphabet.indexOf(c)\n        index\
    \ = index / 2\n        index = index * 2\n        index = index + alphabet.indexOf(\"\
    a\")\n        result += alphabet[index]\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpn3sddkjp.swift:14:21: error: cannot find 'alphabet' in scope\n\
    \        var index = alphabet.indexOf(c)\n                    ^~~~~~~~\n/tmp/tmpn3sddkjp.swift:17:25:\
    \ error: cannot find 'alphabet' in scope\n        index = index + alphabet.indexOf(\"\
    a\")\n                        ^~~~~~~~\n/tmp/tmpn3sddkjp.swift:18:19: error: cannot\
    \ find 'alphabet' in scope\n        result += alphabet[index]\n              \
    \    ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    a\"))\n    }\n    alphabet.append(Character(\"z\"))\n    alphabet.append(Character(\"\
    A\"))\n    alphabet.append(Character(\"Z\"))\n    alphabet.append(Character(\"\
    0\"))\n    alphabet.append(Character(\"1\"))\n    alphabet.append(Character(\"\
    2\"))\n    alphabet.append(Character(\"3\"))\n    alphabet.append(Character(\"\
    4\"))\n    alphabet.append(Character(\"5\"))\n    alphabet.append(Character(\"\
    6\"))\n    alphabet.append(Character(\"7\"))\n    alphabet.append(Character(\"\
    8\"))\n    alphabet.append(Character(\"9\"))\n    alphabet.append(Character(\"\
    _\"))\n    alphabet.append(Character(\"!\"))\n    alphabet.append(Character(\"\
    $\"))\n    alphabet.append(Character(\"%\"))\n    alphabet.append(Character(\"\
    &\"))\n    alphabet.append(Character(\"(\"))\n    alphabet.append(Character(\"\
    )\"))\n    alphabet.append(Character(\"*\"))\n    alphabet.append(Character(\"\
    +\"))\n    alphabet.append(Character(\"-\"))\n    alphabet.append(Character(\"\
    =\"))\n    alphabet.append(Character(\";\"))\n    alphabet.append(Character(\"\
    /\"))\n    alphabet.append(Character(\"?\"))\n    alphabet.append(Character(\"\
    '\"))\n    alphabet.append(Character(\"\\\"\"))\n    alphabet.append(Character(\"\
    ,\"))\n    alphabet.append(Character(\":\"))\n    alphabet.append(Character(\"\
    <\"))\n    alphabet.append(Character(\">\"))\n    alphabet.append(Character(\"\
    ?\"))\n    alphabet.append(Character(\"@\"))\n    alphabet.append(Character(\"\
    [\"))\n    alphabet.append(Character(\"]\"))\n    alphabet.append(Character(\"\
    {\"))\n    alphabet.append(Character(\"}\"))\n    alphabet.append(Character(\"\
    |\"))\n    alphabet.append(Character(\"~\"))\n    alphabet.append(Character(\"\
    `\"))\n    alphabet.append(Character(\"'\"))\n    alphabet.append(Character(\"\
    ~\"))\n    alphabet.append(Character(\"!\"))\n    alphabet.append(Character(\"\
    @\"))\n    alphabet.append(Character(\"$\"))\n    alphabet.append(Character(\"\
    %\"))\n    alphabet.append(Character(\"^\"))\n    alphabet.append(Character(\"\
    &\"))\n    alphabet.append(Character(\"*\"))\n    alphabet.append(Character(\"\
    (\"))\n    alphabet.append(Character(\")\"))\n    alphabet.append(Character(\"\
    _\"))\n    alphabet.append(Character(\"+\"))\n    alphabet.append(Character(\"\
    -\"))\n    alphabet.append(Character(\"=\"))\n    alphabet.append(Character(\"\
    ,\"))\n    alphabet.append(Character(\";\"))\n    alphabet.append(Character(\"\
    /\"))\n    alphabet.append(Character(\"?\"))\n    alphabet.append(Character(\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp1cono6b7.swift:77:31: error: unterminated string literal\n    alphabet.append(Character(\"\
    \n                              ^\n/tmp/tmp1cono6b7.swift:77:31: error: missing\
    \ argument for parameter #1 in call\n    alphabet.append(Character(\"\n      \
    \                        ^\n                              <#Unicode.Scalar#>\n\
    Swift.Character:2:23: note: 'init(_:)' declared here\n    @inlinable public init(_\
    \ content: Unicode.Scalar)\n                      ^\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    alphabet.insert(Character(\"a\"), at: 0)\n    alphabet.insert(Character(\"\
    b\"), at: 1)\n    alphabet.insert(Character(\"c\"), at: 2)\n    alphabet.insert(Character(\"\
    d\"), at: 3)\n    alphabet.insert(Character(\"e\"), at: 4)\n    alphabet.insert(Character(\"\
    f\"), at: 5)\n    alphabet.insert(Character(\"g\"), at: 6)\n    alphabet.insert(Character(\"\
    h\"), at: 7)\n    alphabet.insert(Character(\"i\"), at: 8)\n    alphabet.insert(Character(\"\
    j\"), at: 9)\n    alphabet.insert(Character(\"k\"), at: 10)\n    alphabet.insert(Character(\"\
    l\"), at: 11)\n    alphabet.insert(Character(\"m\"), at: 12)\n    alphabet.insert(Character(\"\
    n\"), at: 13)\n    alphabet.insert(Character(\"o\"), at: 14)\n    alphabet.insert(Character(\"\
    p\"), at: 15)\n    alphabet.insert(Character(\"q\"), at: 16)\n    alphabet.insert(Character(\"\
    r\"), at: 17)\n    alphabet.insert(Character(\"s\"), at: 18)\n    alphabet.insert(Character(\"\
    t\"), at: 19)\n    alphabet.insert(Character(\"u\"), at: 20)\n    alphabet.insert(Character(\"\
    v\"), at: 21)\n    alphabet.insert(Character(\"w\"), at: 22)\n    alphabet.insert(Character(\"\
    x\"), at: 23)\n    alphabet.insert(Character(\"y\"), at: 24)\n    alphabet.insert(Character(\"\
    z\"), at: 25)\n    alphabet.insert(Character(\"A\"), at: 26)\n    alphabet.insert(Character(\"\
    B\"), at: 27)\n    alphabet.insert(Character(\"C\"), at: 28)\n    alphabet.insert(Character(\"\
    D\"), at: 29)\n    alphabet.insert(Character(\"E\"), at: 30)\n    alphabet.insert(Character(\"\
    F\"), at: 31)\n    alphabet.insert(Character(\"G\"), at: 32)\n    alphabet.insert(Character(\"\
    H\"), at: 33)\n    alphabet.insert(Character(\"I\"), at: 34)\n    alphabet.insert(Character(\"\
    J\"), at: 35)\n    alphabet.insert(Character(\"K\"), at: 36)\n    alphabet.insert(Character(\"\
    L\"), at: 37)\n    alphabet.insert(Character(\"M\"), at: 38)\n    alphabet.insert(Character(\"\
    N\"), at: 39)\n    alphabet.insert(Character(\"O\"), at: 40)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: '/tmp/tmp00l6bpl3.swift:54:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1659824986
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    a\".unicodeScalars.first!))\n    }\n    alphabet.append(Character(\"z\".unicodeScalars.first!))\n\
    \    \n    var result = [Character]()\n    for c in s {\n        let index = alphabet.index(of:\
    \ c)!\n        result.append(alphabet[(index+2)%26])\n    }\n    return String(result)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpks6m1pls/tmpks6m1pls.swift:20: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002ae2b2f62c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae2b2c59561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae2b2c59286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae2b2c5913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae2b2c58bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpks6m1pls                        0x00005557753f1707 <unavailable> + 9991

    6    tmpks6m1pls                        0x00005557753f08e6 <unavailable> + 6374

    7    libc.so.6                          0x00002ae2b314e460 __libc_start_main +
    245

    8    tmpks6m1pls                        0x00005557753f05e9 <unavailable> + 5609

    '
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        result = result + alphabet[alphabet.IndexOf(alphabet[c])]\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp1n6_y0u2.swift:14:27: error: cannot find 'alphabet' in scope\n\
    \        result = result + alphabet[alphabet.IndexOf(alphabet[c])]\n         \
    \                 ^~~~~~~~\n/tmp/tmp1n6_y0u2.swift:14:36: error: cannot find 'alphabet'\
    \ in scope\n        result = result + alphabet[alphabet.IndexOf(alphabet[c])]\n\
    \                                   ^~~~~~~~\n/tmp/tmp1n6_y0u2.swift:14:53: error:\
    \ cannot find 'alphabet' in scope\n        result = result + alphabet[alphabet.IndexOf(alphabet[c])]\n\
    \                                                    ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(Character(c))\n\
    \    }\n    alphabet.append(Character(Character.max))\n    alphabet.append(Character(Character.min))\n\
    \    alphabet.append(Character(Character.min))\n    alphabet.append(Character(Character.max))\n\
    \    alphabet.append(Character(Character.max))\n    alphabet.append(Character(Character.min))\n\
    \    alphabet.append(Character(Character.max))\n    alphabet.append(Character(Character.min))\n\
    \    alphabet.append(Character(Character.max))\n    alphabet.append(Character(Character.min))\n\
    \    alphabet.append(Character(Character.max))\n    alphabet.append(Character(Character.min))\n\
    \    alphabet.append(Character(Character.max))\n    alphabet.append(Character(Character.min))\n\
    \    alphabet.append(Character(Character.max))\n    alphabet.append(Character(Character.min))\n\
    \    alphabet.append(Character(Character.max))\n    alphabet.append(Character(Character.min))\n\
    \    alphabet.append(Character(Character.max))\n    alphabet.append(Character(Character.min))\n\
    \    alphabet.append(Character(Character.max))\n    alphabet.append(Character(Character.min))\n\
    \    alphabet.append(Character(Character.max))\n    alphabet.append(Character(Character.min))\n\
    \    alphabet.append(Character(Character.max))\n    alphabet.append(Character(Character.min))\n\
    \    alphabet.append(Character(Character.max))\n    alphabet.append(Character(Character.min))\n\
    \    alphabet.append(Character(Character.max))\n    alphabet.append(Character(Character.min))\n\
    \    alphabet.append(Character(Character.max))\n    alphabet.append(Character(Character.min))\n\
    \    alphabet.append(Character(Character.max))\n    alphabet.append(Character(Character.min))\n\
    \    alphabet.append(Character(Character.max))\n    alphabet.append(Character(Character.min))\n\
    \    alphabet.append(Character(Character.max))\n    alphabet.append(Character(Character.min))\n\
    \    alphabet.append(Character(Character.max))\n    alphabet.append(Character(Character.min))\n\
    \    alphabet.append(Character(Character.max))\n    alphabet.append(Character(Character.min))\n\
    \    alphabet.append(Character(Character.max))\n    alphabet.append(Character(Character.min))\n\
    \    alphabet.append(Character(Character.max))\n    alphabet.append(Character(Character.min))\n\
    \    alphabet.append(Character(Character.max))\n    alphabet.append(Character(Character.min))\n\
    \    alphabet.append(Character(Character.max))\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp17wd6omg.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp17wd6omg.swift:14:35:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \      alphabet.append(Character(c))\n                                  ^\n  \
    \                                extendedGraphemeClusterLiteral: \n/tmp/tmp17wd6omg.swift:16:41:\
    \ error: type 'Character' has no member 'max'\n    alphabet.append(Character(Character.max))\n\
    \                              ~~~~~~~~~ ^~~\n/tmp/tmp17wd6omg.swift:17:41: error:\
    \ type 'Character' has no member 'min'\n    alphabet.append(Character(Character.min))\n\
    \                              ~~~~~~~~~ ^~~\n/tmp/tmp17wd6omg.swift:18:41: error:\
    \ type 'Character' has no member 'min'\n    alphabet.append(Character(Character.min))\n\
    \                              ~~~~~~~~~ ^~~\n/tmp/tmp17wd6omg.swift:19:41: error:\
    \ type 'Character' has no member 'max'\n    alphabet.append(Character(Character.max))\n\
    \                              ~~~~~~~~~ ^~~\n/tmp/tmp17wd6omg.swift:20:41: error:\
    \ type 'Character' has no member 'max'\n    alphabet.append(Character(Character.max))\n\
    \                              ~~~~~~~~~ ^~~\n/tmp/tmp17wd6omg.swift:21:41: error:\
    \ type 'Character' has no member 'min'\n    alphabet.append(Character(Character.min))\n\
    \                              ~~~~~~~~~ ^~~\n/tmp/tmp17wd6omg.swift:22:41: error:\
    \ type 'Character' has no member 'max'\n    alphabet.append(Character(Character.max))\n\
    \                              ~~~~~~~~~ ^~~\n/tmp/tmp17wd6omg.swift:23:41: error:\
    \ type 'Character' has no member 'min'\n    alphabet.append(Character(Character.min))\n\
    \                              ~~~~~~~~~ ^~~\n/tmp/tmp17wd6omg.swift:24:41: error:\
    \ type 'Character' has no member 'max'\n    alphabet.append(Character(Character.max))\n\
    \                              ~~~~~~~~~ ^~~\n/tmp/tmp17wd6omg.swift:25:41: error:\
    \ type 'Character' "
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    alphabet.append(Character(\"a\"))\n    alphabet.append(Character(\"\
    b\"))\n    alphabet.append(Character(\"c\"))\n    alphabet.append(Character(\"\
    d\"))\n    alphabet.append(Character(\"e\"))\n    alphabet.append(Character(\"\
    f\"))\n    alphabet.append(Character(\"g\"))\n    alphabet.append(Character(\"\
    h\"))\n    alphabet.append(Character(\"i\"))\n    alphabet.append(Character(\"\
    j\"))\n    alphabet.append(Character(\"k\"))\n    alphabet.append(Character(\"\
    l\"))\n    alphabet.append(Character(\"m\"))\n    alphabet.append(Character(\"\
    n\"))\n    alphabet.append(Character(\"o\"))\n    alphabet.append(Character(\"\
    p\"))\n    alphabet.append(Character(\"q\"))\n    alphabet.append(Character(\"\
    r\"))\n    alphabet.append(Character(\"s\"))\n    alphabet.append(Character(\"\
    t\"))\n    alphabet.append(Character(\"u\"))\n    alphabet.append(Character(\"\
    v\"))\n    alphabet.append(Character(\"w\"))\n    alphabet.append(Character(\"\
    x\"))\n    alphabet.append(Character(\"y\"))\n    alphabet.append(Character(\"\
    z\"))\n    alphabet.append(Character(\"A\"))\n    alphabet.append(Character(\"\
    B\"))\n    alphabet.append(Character(\"C\"))\n    alphabet.append(Character(\"\
    D\"))\n    alphabet.append(Character(\"E\"))\n    alphabet.append(Character(\"\
    F\"))\n    alphabet.append(Character(\"G\"))\n    alphabet.append(Character(\"\
    H\"))\n    alphabet.append(Character(\"I\"))\n    alphabet.append(Character(\"\
    J\"))\n    alphabet.append(Character(\"K\"))\n    alphabet.append(Character(\"\
    L\"))\n    alphabet.append(Character(\"M\"))\n    alphabet.append(Character(\"\
    N\"))\n    alphabet.append(Character(\"O\"))\n    alphabet.append(Character(\"\
    P\"))\n    alphabet.append(Character(\"Q\"))\n    alphabet.append(Character(\"\
    R\"))\n    alphabet.append(Character(\"S\"))\n    alphabet.append(Character(\"\
    T\"))\n    alphabet.append(Character(\"U\"))\n    alphabet.append(Character(\"\
    V\"))\n    alphabet.append(Character(\"W\"))\n    alphabet.append(Character(\"\
    X\"))\n    alphabet.append(Character(\"Y\"))\n    alphabet.append(Character(\"\
    Z\"))\n    \n    var result = \"\"\n    for c in s {\n        var index = alphabet.index(of:\
    \ c)!\n        index = index * 2\n        index = index + 2\n        index = index\
    \ % 26\n        result = result + alphabet[index]\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpk3963uvy.swift:68:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        var index = alphabet.index(of: c)!\n         \
    \                    ^\n/tmp/tmpk3963uvy.swift:68:30: note: use 'firstIndex(of:)'\
    \ instead\n        var index = alphabet.index(of: c)!\n                      \
    \       ^~~~~\n                             firstIndex\n/tmp/tmpk3963uvy.swift:72:35:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        result = result + alphabet[index]\n                                 \
    \ ^\n/tmp/tmpk3963uvy.swift:72:35: error: no exact matches in call to subscript\
    \ \n        result = result + alphabet[index]\n                              \
    \    ^\nSwift.String:2:35: note: candidate expects value of type 'String' for\
    \ parameter #2 (got 'Character')\n    @inlinable public static func + (lhs: String,\
    \ rhs: String) -> String\n                                  ^\nSwift.Array:17:23:\
    \ note: candidate expects value of type 'Range<Int>' for parameter #1 (got 'Array<Character>.Index'\
    \ (aka 'Int'))\n    @inlinable public subscript(bounds: Range<Int>) -> ArraySlice<Element>\
    \ { get set }\n                      ^\nSwift.Collection:3:23: note: candidate\
    \ expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Array<Character>.Index'\
    \ (aka 'Int'))\n    @inlinable public subscript(x: (UnboundedRange_) -> ()) ->\
    \ Self.SubSequence { get }\n                      ^\nSwift.MutableCollection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Array<Character>.Index' (aka 'Int'))\n    @inlinable public subscript(x:\
    \ (UnboundedRange_) -> ()) -> Self.SubSequence { get set }\n                 \
    \     ^\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        let index = alphabet.index(c)\n        let\
    \ newIndex = index + 2\n        if newIndex < alphabet.count {\n            result\
    \ += alphabet[newIndex]\n        } else {\n            result += alphabet[alphabet.count\
    \ - 1]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpdb_0pkm0.swift:14:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(c)\n                    ^~~~~~~~\n/tmp/tmpdb_0pkm0.swift:16:23:\
    \ error: cannot find 'alphabet' in scope\n        if newIndex < alphabet.count\
    \ {\n                      ^~~~~~~~\n/tmp/tmpdb_0pkm0.swift:17:23: error: cannot\
    \ find 'alphabet' in scope\n            result += alphabet[newIndex]\n       \
    \               ^~~~~~~~\n/tmp/tmpdb_0pkm0.swift:19:23: error: cannot find 'alphabet'\
    \ in scope\n            result += alphabet[alphabet.count - 1]\n             \
    \         ^~~~~~~~\n/tmp/tmpdb_0pkm0.swift:19:32: error: cannot find 'alphabet'\
    \ in scope\n            result += alphabet[alphabet.count - 1]\n             \
    \                  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    a\"))\n    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"b\"))\n\
    \    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"c\"))\n   \
    \ }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"d\"))\n    }\n\
    \    for _ in 0..<26 {\n        alphabet.append(Character(\"e\"))\n    }\n   \
    \ for _ in 0..<26 {\n        alphabet.append(Character(\"f\"))\n    }\n    for\
    \ _ in 0..<26 {\n        alphabet.append(Character(\"g\"))\n    }\n    for _ in\
    \ 0..<26 {\n        alphabet.append(Character(\"h\"))\n    }\n    for _ in 0..<26\
    \ {\n        alphabet.append(Character(\"i\"))\n    }\n    for _ in 0..<26 {\n\
    \        alphabet.append(Character(\"j\"))\n    }\n    for _ in 0..<26 {\n   \
    \     alphabet.append(Character(\"k\"))\n    }\n    for _ in 0..<26 {\n      \
    \  alphabet.append(Character(\"l\"))\n    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    m\"))\n    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"n\"))\n\
    \    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"o\"))\n   \
    \ }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"p\"))\n    }\n\
    \    for _ in 0..<26 {\n        alphabet.append(Character(\"q\"))\n    }\n   \
    \ for _ in 0..<26 {\n        alphabet.append(Character(\"r\"))\n    }\n    for\
    \ _ in 0..<26 {\n        alphabet.append(Character(\"s\"))\n    }\n    for _ in\
    \ 0..<26 {\n        alphabet.append(Character(\"t\"))\n    }\n    for _ in 0..<26\
    \ {\n        alphabet.append(Character(\"u\"))\n    }\n    for _ in 0..<26 {\n\
    \        alphabet.append(Character(\"v\"))\n    }\n    for _ in 0..<26 {\n   \
    \     alphabet.append(Character(\"w\"))\n    }\n    for _ in 0..<26 {\n      \
    \  alphabet.append(Character(\"x\"))\n    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    y\"))\n    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"z\"))\n\
    \    }\n    \n    var result = [Character]()\n    for c in s {\n        let index\
    \ = alphabet.index(of: c)!\n        let newIndex = index + 2\n        result.append(alphabet[newIndex])\n\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpe02t_xej.swift:120:31: error: expected '}' at end of brace statement\n\
    assert(encrypt(s: \"a\") == \"e\")\n                              ^\n/tmp/tmpe02t_xej.swift:11:35:\
    \ note: to match this opening '{'\nfunc encrypt(s: String) -> String {\n     \
    \                             ^\n/tmp/tmpe02t_xej.swift:94:30: warning: 'index(of:)'\
    \ is deprecated: renamed to 'firstIndex(of:)'\n        let index = alphabet.index(of:\
    \ c)!\n                             ^\n/tmp/tmpe02t_xej.swift:94:30: note: use\
    \ 'firstIndex(of:)' instead\n        let index = alphabet.index(of: c)!\n    \
    \                         ^~~~~\n                             firstIndex\n/tmp/tmpe02t_xej.swift:101:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    alphabet.append(Character(\"a\"))\n    alphabet.append(Character(\"\
    b\"))\n    alphabet.append(Character(\"c\"))\n    alphabet.append(Character(\"\
    d\"))\n    alphabet.append(Character(\"e\"))\n    alphabet.append(Character(\"\
    f\"))\n    alphabet.append(Character(\"g\"))\n    alphabet.append(Character(\"\
    h\"))\n    alphabet.append(Character(\"i\"))\n    alphabet.append(Character(\"\
    j\"))\n    alphabet.append(Character(\"k\"))\n    alphabet.append(Character(\"\
    l\"))\n    alphabet.append(Character(\"m\"))\n    alphabet.append(Character(\"\
    n\"))\n    alphabet.append(Character(\"o\"))\n    alphabet.append(Character(\"\
    p\"))\n    alphabet.append(Character(\"q\"))\n    alphabet.append(Character(\"\
    r\"))\n    alphabet.append(Character(\"s\"))\n    alphabet.append(Character(\"\
    t\"))\n    alphabet.append(Character(\"u\"))\n    alphabet.append(Character(\"\
    v\"))\n    alphabet.append(Character(\"w\"))\n    alphabet.append(Character(\"\
    x\"))\n    alphabet.append(Character(\"y\"))\n    alphabet.append(Character(\"\
    z\"))\n    alphabet.append(Character(\"A\"))\n    alphabet.append(Character(\"\
    B\"))\n    alphabet.append(Character(\"C\"))\n    alphabet.append(Character(\"\
    D\"))\n    alphabet.append(Character(\"E\"))\n    alphabet.append(Character(\"\
    F\"))\n    alphabet.append(Character(\"G\"))\n    alphabet.append(Character(\"\
    H\"))\n    alphabet.append(Character(\"I\"))\n    alphabet.append(Character(\"\
    J\"))\n    alphabet.append(Character(\"K\"))\n    alphabet.append(Character(\"\
    L\"))\n    alphabet.append(Character(\"M\"))\n    alphabet.append(Character(\"\
    N\"))\n    alphabet.append(Character(\"O\"))\n    alphabet.append(Character(\"\
    P\"))\n    alphabet.append(Character(\"Q\"))\n    alphabet.append(Character(\"\
    R\"))\n    alphabet.append(Character(\"S\"))\n    alphabet.append(Character(\"\
    T\"))\n    alphabet.append(Character(\"U\"))\n    alphabet.append(Character(\"\
    V\"))\n    alphabet.append(Character(\"W\"))\n    alphabet.append(Character(\"\
    X\"))\n    alphabet.append(Character(\"Y\"))\n    alphabet.append(Character(\"\
    Z\"))\n    \n    var result = [Character]()\n    var i = 0\n    for c in s {\n\
    \        result.append(alphabet[i % alphabet.count])\n        i += 1\n    }\n\
    \    return String(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpinl7h4c7/tmpinl7h4c7.swift:88: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5d54660c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5d54357b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5d54357988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5d543567b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpinl7h4c7                        0x0000561c9a2d66f7 <unavailable> + 5879

    5    libc.so.6                          0x00002b5d5484c460 __libc_start_main +
    245

    6    tmpinl7h4c7                        0x0000561c9a2d6339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824988
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for letter in s {\n        let index = alphabet.index(of: letter)!\n\
    \        let newIndex = index + 2\n        let newLetter = alphabet[newIndex]\n\
    \        result += newLetter\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpbzbgipei.swift:14:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: letter)!\n                    ^~~~~~~~\n\
    /tmp/tmpbzbgipei.swift:16:25: error: cannot find 'alphabet' in scope\n       \
    \ let newLetter = alphabet[newIndex]\n                        ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    a\".unicodeScalars.first!))\n    }\n    alphabet.append(Character(\"z\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"A\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    Z\".unicodeScalars.first!))\n    alphabet.append(Character(\"0\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"9\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    _\".unicodeScalars.first!))\n    alphabet.append(Character(\"a\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"b\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    c\".unicodeScalars.first!))\n    alphabet.append(Character(\"d\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"e\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    f\".unicodeScalars.first!))\n    alphabet.append(Character(\"g\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"h\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    i\".unicodeScalars.first!))\n    alphabet.append(Character(\"j\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"k\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    l\".unicodeScalars.first!))\n    alphabet.append(Character(\"m\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"n\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    o\".unicodeScalars.first!))\n    alphabet.append(Character(\"p\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"q\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    r\".unicodeScalars.first!))\n    alphabet.append(Character(\"s\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"t\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    u\".unicodeScalars.first!))\n    alphabet.append(Character(\"v\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"w\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    x\".unicodeScalars.first!))\n    alphabet.append(Character(\"y\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"z\".unicodeScalars.first!))\n    alphabet.append(Character(\"\
    0\".unicodeScalars.first!))\n    alphabet.append(Character(\"1\".unicodeScalars.first!))\n\
    \    alphabet.append(Character(\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpaahnkbfn.swift:50:31: error: unterminated string literal\n    alphabet.append(Character(\"\
    \n                              ^\n/tmp/tmpaahnkbfn.swift:50:31: error: missing\
    \ argument for parameter #1 in call\n    alphabet.append(Character(\"\n      \
    \                        ^\n                              <#Unicode.Scalar#>\n\
    Swift.Character:2:23: note: 'init(_:)' declared here\n    @inlinable public init(_\
    \ content: Unicode.Scalar)\n                      ^\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 18)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 20)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 22)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 24)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 26)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 28)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 30)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 32)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 34)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 36)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 38)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 40)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 42)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 44)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 46)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 48)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 50)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 52)))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp0ag9gkho.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp0ag9gkho.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:23:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:24:41:\
    \ error: type"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(s.first!))\n    alphabet.append(Character(s.last!))\n\
    \    alphabet.append(Character(\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpwwz01jmv.swift:64:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpwwz01jmv.swift:13:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.first!))\n                        \
    \      ^\n                              extendedGraphemeClusterLiteral: \n/tmp/tmpwwz01jmv.swift:14:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpwwz01jmv.swift:15:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpwwz01jmv.swift:16:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpwwz01jmv.swift:17:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpwwz01jmv.swift:18:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpwwz01jmv.swift:19:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.first!))\n                              ^\n   \
    \                           extendedGraphemeClusterLiteral: \n/tmp/tmpwwz01jmv.swift:20:31:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \  alphabet.append(Character(s.last!))\n                              ^\n    \
    \                          extendedGraphemeClusterLiteral: \n/tmp/tmpwwz01jmv.swift:21:31:\
    \ error: missing argument label 'exte"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.sort()\n    alphabet = alphabet[1..<alphabet.count]\n    var\
    \ result = \"\"\n    for c in s.characters {\n        result += alphabet[(alphabet.indexOf(c)\
    \ + 2) % alphabet.count]\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpaus_pjy6.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpaus_pjy6.swift:17:24:\
    \ error: cannot assign value of type 'ArraySlice<Character>' to type '[Character]'\n\
    \    alphabet = alphabet[1..<alphabet.count]\n               ~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpaus_pjy6.swift:19:16: error: 'characters' is unavailable: Please use String\
    \ directly\n    for c in s.characters {\n               ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpaus_pjy6.swift:20:38: error: value of\
    \ type '[Character]' has no member 'indexOf'\n        result += alphabet[(alphabet.indexOf(c)\
    \ + 2) % alphabet.count]\n                            ~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824988
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    a\"))\n    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"b\"))\n\
    \    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"c\"))\n   \
    \ }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"d\"))\n    }\n\
    \    for _ in 0..<26 {\n        alphabet.append(Character(\"e\"))\n    }\n   \
    \ for _ in 0..<26 {\n        alphabet.append(Character(\"f\"))\n    }\n    for\
    \ _ in 0..<26 {\n        alphabet.append(Character(\"g\"))\n    }\n    for _ in\
    \ 0..<26 {\n        alphabet.append(Character(\"h\"))\n    }\n    for _ in 0..<26\
    \ {\n        alphabet.append(Character(\"i\"))\n    }\n    for _ in 0..<26 {\n\
    \        alphabet.append(Character(\"j\"))\n    }\n    for _ in 0..<26 {\n   \
    \     alphabet.append(Character(\"k\"))\n    }\n    for _ in 0..<26 {\n      \
    \  alphabet.append(Character(\"l\"))\n    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    m\"))\n    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"n\"))\n\
    \    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"o\"))\n   \
    \ }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"p\"))\n    }\n\
    \    for _ in 0..<26 {\n        alphabet.append(Character(\"q\"))\n    }\n   \
    \ for _ in 0..<26 {\n        alphabet.append(Character(\"r\"))\n    }\n    for\
    \ _ in 0..<26 {\n        alphabet.append(Character(\"s\"))\n    }\n    for _ in\
    \ 0..<26 {\n        alphabet.append(Character(\"t\"))\n    }\n    for _ in 0..<26\
    \ {\n        alphabet.append(Character(\"u\"))\n    }\n    for _ in 0..<26 {\n\
    \        alphabet.append(Character(\"v\"))\n    }\n    for _ in 0..<26 {\n   \
    \     alphabet.append(Character(\"w\"))\n    }\n    for _ in 0..<26 {\n      \
    \  alphabet.append(Character(\"x\"))\n    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"\
    y\"))\n    }\n    for _ in 0..<26 {\n        alphabet.append(Character(\"z\"))\n\
    \    }\n    \n    var result = \"\"\n    for char in s {\n        result += alphabet[alphabet.index(char)\
    \ + 1]\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpcvnzxdch.swift:94:27: error: no exact matches in call to subscript\
    \ \n        result += alphabet[alphabet.index(char) + 1]\n                   \
    \       ^\n/tmp/tmpcvnzxdch.swift:94:27: note: candidate expects value of type\
    \ 'Int' for parameter #1 (got 'Character')\n        result += alphabet[alphabet.index(char)\
    \ + 1]\n                          ^\n/tmp/tmpcvnzxdch.swift:94:27: note: candidate\
    \ expects value of type 'Range<Int>' for parameter #1 (got 'Character')\n    \
    \    result += alphabet[alphabet.index(char) + 1]\n                          ^\n\
    /tmp/tmpcvnzxdch.swift:94:27: note: candidate expects value of type '(UnboundedRange_)\
    \ -> ()' for parameter #1 (got 'Character')\n        result += alphabet[alphabet.index(char)\
    \ + 1]\n                          ^\n/tmp/tmpcvnzxdch.swift:94:27: note: candidate\
    \ expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Character')\n\
    \        result += alphabet[alphabet.index(char) + 1]\n                      \
    \    ^\n/tmp/tmpcvnzxdch.swift:94:43: error: missing argument label 'of:' in call\n\
    \        result += alphabet[alphabet.index(char) + 1]\n                      \
    \                    ^\n                                          of: \n/tmp/tmpcvnzxdch.swift:94:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        result += alphabet[alphabet.index(char) + 1]\n                      \
    \    ^\n/tmp/tmpcvnzxdch.swift:94:37: error: value of optional type 'Array<Character>.Index?'\
    \ (aka 'Optional<Int>') must be unwrapped to a value of type 'Array<Character>.Index'\
    \ (aka 'Int')\n        result += alphabet[alphabet.index(char) + 1]\n        \
    \                            ^\n/tmp/tmpcvnzxdch.swift:94:37: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n        result\
    \ += alphabet[alphabet.index(char) + 1]\n                                    ^\n\
    \                           (                    ?? <#default value#>)\n/tmp/tmpcvnzxdch.swift:94:37:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n       "
  stdout: ''
  timestamp: 1659824988
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 18)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 20)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 22)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 24)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 26)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 28)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 30)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 32)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 34)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 36)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 38)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 40)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 42)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 44)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 46)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 48)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 50)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 52)))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp0ag9gkho.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp0ag9gkho.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:23:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:24:41:\
    \ error: type"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.removeLast()\n    alphabet.insert(contentsOf: alphabet.dropLast())\n\
    \    alphabet.insert(contentsOf: alphabet.dropFirst())\n    alphabet.insert(contentsOf:\
    \ alphabet.dropLast())\n    alphabet.insert(contentsOf: alphabet.dropFirst())\n\
    \    alphabet.insert(contentsOf: alphabet.dropLast())\n    alphabet.insert(contentsOf:\
    \ alphabet.dropFirst())\n    alphabet.insert(contentsOf: alphabet.dropLast())\n\
    \    alphabet.insert(contentsOf: alphabet.dropFirst())\n    alphabet.insert(contentsOf:\
    \ alphabet.dropLast())\n    alphabet.insert(contentsOf: alphabet.dropFirst())\n\
    \    alphabet.insert(contentsOf: alphabet.dropLast())\n    alphabet.insert(contentsOf:\
    \ alphabet.dropFirst())\n    alphabet.insert(contentsOf: alphabet.dropLast())\n\
    \    alphabet.insert(contentsOf: alphabet.dropFirst())\n    alphabet.insert(contentsOf:\
    \ alphabet.dropLast())\n    alphabet.insert(contentsOf: alphabet.dropFirst())\n\
    \    alphabet.insert(contentsOf: alphabet.dropLast())\n    alphabet.insert(contentsOf:\
    \ alphabet.dropFirst())\n    alphabet.insert(contentsOf: alphabet.dropLast())\n\
    \    alphabet.insert(contentsOf: alphabet.dropFirst())\n    alphabet.insert(contentsOf:\
    \ alphabet.dropLast())\n    alphabet.insert(contentsOf: alphabet.dropFirst())\n\
    \    alphabet.insert(contentsOf: alphabet.dropLast())\n    alphabet.insert(contentsOf:\
    \ alphabet.dropFirst())\n    alphabet.insert(contentsOf: alphabet.dropLast())\n\
    \    alphabet.insert(contentsOf: alphabet.dropFirst())\n    alphabet.insert(contentsOf:\
    \ alphabet.dropLast())\n    alphabet.insert(contentsOf: alphabet.dropFirst())\n\
    \    alphabet.insert(contentsOf: alphabet.dropLast())\n    alphabet.insert(contentsOf:\
    \ alphabet.dropFirst())\n    alphabet.insert(contentsOf: alphabet.dropLast())\n\
    \    alphabet.insert(contentsOf: alphabet.dropFirst())\n    alphabet.insert(contentsOf:\
    \ alphabet.dropLast())\n    alphabet.insert(contentsOf: alphabet.dropFirst())\n\
    \    alphabet.insert(contentsOf: alphabet.dropLast())\n    alphabet.insert(contentsOf:\
    \ alphabet.dropFirst())\n    alphabet.insert(contentsOf: alphabet.dropLast())\n\
    \    alphabet.insert(contents\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpqclu20o0.swift:55:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpqclu20o0.swift:54:20: note: to match this opening '('\n    alphabet.insert(contents\n\
    \                   ^\n/tmp/tmpqclu20o0.swift:13:16: error: 'characters' is unavailable:\
    \ Please use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpqclu20o0.swift:17:52:\
    \ error: missing argument for parameter 'at' in call\n    alphabet.insert(contentsOf:\
    \ alphabet.dropLast())\n                                                   ^\n\
    \                                                   , at: <#Array<Character>.Index#>\n\
    Swift.RangeReplaceableCollection:7:37: note: 'insert(contentsOf:at:)' declared\
    \ here\n    @inlinable public mutating func insert<C>(contentsOf newElements:\
    \ __owned C, at i: Self.Index) where C : Collection, Self.Element == C.Element\n\
    \                                    ^\n/tmp/tmpqclu20o0.swift:18:53: error: missing\
    \ argument for parameter 'at' in call\n    alphabet.insert(contentsOf: alphabet.dropFirst())\n\
    \                                                    ^\n                     \
    \                               , at: <#Array<Character>.Index#>\nSwift.RangeReplaceableCollection:7:37:\
    \ note: 'insert(contentsOf:at:)' declared here\n    @inlinable public mutating\
    \ func insert<C>(contentsOf newElements: __owned C, at i: Self.Index) where C\
    \ : Collection, Self.Element == C.Element\n                                  \
    \  ^\n/tmp/tmpqclu20o0.swift:19:52: error: missing argument for parameter 'at'\
    \ in call\n    alphabet.insert(contentsOf: alphabet.dropLast())\n            \
    \                                       ^\n                                  \
    \                 , at: <#Array<Character>.Index#>\nSwift.RangeReplaceableCollection:7:37:\
    \ note: 'insert(contentsOf:at:)' declared here\n    @inlinable public mutating\
    \ func insert<C>(contentsOf newElements: __owned C, at i: Self.Index) where C\
    \ : Collection, Self.Element == C.Element\n    "
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 18)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 20)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 22)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 24)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 26)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 28)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 30)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 32)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 34)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 36)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 38)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 40)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 42)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 44)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 46)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 48)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 50)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 52)))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp0ag9gkho.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp0ag9gkho.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:23:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:24:41:\
    \ error: type"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Charact\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpz31nwtqv.swift:44:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpz31nwtqv.swift:43:30: note: to match this opening '('\n    alphabet.append(Character(Charact\n\
    \                             ^\n/tmp/tmpz31nwtqv.swift:13:16: error: 'characters'\
    \ is unavailable: Please use String directly\n    for c in s.characters {\n  \
    \             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpz31nwtqv.swift:16:41: error: type 'Character' has no member 'UnicodeScalar'\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count) -\
    \ 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpz31nwtqv.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpz31nwtqv.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpz31nwtqv.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpz31nwtqv.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpz31nwtqv.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpz31nwtqv.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpz31nwtqv.swift:"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 4)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 3)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 6)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 5)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 7)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 8)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 9)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 10)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 11)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 12)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 13)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 14)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 15)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 16)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 17)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 18)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 19)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 20)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 21)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 22)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 23)))\n    alphabet.append(Character(\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpjligvy85.swift:43:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpjligvy85.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpjligvy85.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpjligvy85.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 1)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpjligvy85.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count))))\n\
    \                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpjligvy85.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpjligvy85.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 1)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpjligvy85.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 4)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpjligvy85.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 3)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpjligvy85.swift:23:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UI"
  stdout: ''
  timestamp: 1659824988
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        let index = alphabet.index(c)\n        let\
    \ newIndex = index + 2\n        if newIndex < alphabet.count {\n            result\
    \ += alphabet[newIndex]\n        } else {\n            result += alphabet[alphabet.count\
    \ - 1]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpdb_0pkm0.swift:14:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(c)\n                    ^~~~~~~~\n/tmp/tmpdb_0pkm0.swift:16:23:\
    \ error: cannot find 'alphabet' in scope\n        if newIndex < alphabet.count\
    \ {\n                      ^~~~~~~~\n/tmp/tmpdb_0pkm0.swift:17:23: error: cannot\
    \ find 'alphabet' in scope\n            result += alphabet[newIndex]\n       \
    \               ^~~~~~~~\n/tmp/tmpdb_0pkm0.swift:19:23: error: cannot find 'alphabet'\
    \ in scope\n            result += alphabet[alphabet.count - 1]\n             \
    \         ^~~~~~~~\n/tmp/tmpdb_0pkm0.swift:19:32: error: cannot find 'alphabet'\
    \ in scope\n            result += alphabet[alphabet.count - 1]\n             \
    \                  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 18)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 20)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 22)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 24)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 26)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 28)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 30)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 32)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 34)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 36)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 38)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 40)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 42)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 44)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 46)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 48)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 50)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 52)))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp0ag9gkho.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp0ag9gkho.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 4)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 6)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 8)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 10)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 12)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 14)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:23:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 16)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0ag9gkho.swift:24:41:\
    \ error: type"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        let index = alphabet.indexOf(c)\n        let\
    \ newIndex = index + 2\n        if newIndex < alphabet.count {\n            result\
    \ += alphabet[newIndex]\n        } else {\n            result += c\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpguz98d2l.swift:14:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.indexOf(c)\n                    ^~~~~~~~\n/tmp/tmpguz98d2l.swift:16:23:\
    \ error: cannot find 'alphabet' in scope\n        if newIndex < alphabet.count\
    \ {\n                      ^~~~~~~~\n/tmp/tmpguz98d2l.swift:17:23: error: cannot\
    \ find 'alphabet' in scope\n            result += alphabet[newIndex]\n       \
    \               ^~~~~~~~\n/tmp/tmpguz98d2l.swift:19:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ += c\n                      ^\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 3)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 4)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 5)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 6)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 7)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 8)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 9)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 10)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 11)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 12)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 13)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 14)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 15)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 16)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 17)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 18)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 19)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 20)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 21)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 22)))\n    alphabet.append(Character(Charact\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpxc41pfaj.swift:43:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpxc41pfaj.swift:42:30: note: to match this opening '('\n    alphabet.append(Character(Charact\n\
    \                             ^\n/tmp/tmpxc41pfaj.swift:13:16: error: 'characters'\
    \ is unavailable: Please use String directly\n    for c in s.characters {\n  \
    \             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpxc41pfaj.swift:16:41: error: type 'Character' has no member 'UnicodeScalar'\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpxc41pfaj.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 1)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpxc41pfaj.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count))))\n\
    \                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpxc41pfaj.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpxc41pfaj.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 1)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpxc41pfaj.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpxc41pfaj.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 3)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpxc41pfaj.swi"
  stdout: ''
  timestamp: 1659824988
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    alphabet.append(Character(s.characters.first!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    \    alphabet.append(Character(s.characters.last!))\n    alphabet.append(Character(s.characters.last!))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpf3rangpc.swift:13:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.first!))\n             \
    \                 ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpf3rangpc.swift:14:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.last!))\n              \
    \                ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpf3rangpc.swift:15:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.last!))\n              \
    \                ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpf3rangpc.swift:16:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.last!))\n              \
    \                ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpf3rangpc.swift:17:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.last!))\n              \
    \                ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpf3rangpc.swift:18:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.last!))\n              \
    \                ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpf3rangpc.swift:19:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.last!))\n              \
    \                ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpf3rangpc.swift:20:31: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    alphabet.append(Character(s.characters.last!))\n              \
    \                ^\n                              extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpf3rangpc.swift:21:31: error: missing argument label 'ex"
  stdout: ''
  timestamp: 1659824988
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        result = result + alphabet[alphabet.Index(c)%alphabet.Length]\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpul_lh90t.swift:14:27: error: cannot find 'alphabet' in scope\n\
    \        result = result + alphabet[alphabet.Index(c)%alphabet.Length]\n     \
    \                     ^~~~~~~~\n/tmp/tmpul_lh90t.swift:14:36: error: cannot find\
    \ 'alphabet' in scope\n        result = result + alphabet[alphabet.Index(c)%alphabet.Length]\n\
    \                                   ^~~~~~~~\n/tmp/tmpul_lh90t.swift:14:54: error:\
    \ cannot find 'alphabet' in scope\n        result = result + alphabet[alphabet.Index(c)%alphabet.Length]\n\
    \                                                     ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var result\
    \ = \"\"\n    for c in s {\n        result = result + alphabet[alphabet.IndexOf(c)\
    \ + 2]\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp241dvynn.swift:14:27: error: cannot find 'alphabet' in scope\n\
    \        result = result + alphabet[alphabet.IndexOf(c) + 2]\n               \
    \           ^~~~~~~~\n/tmp/tmp241dvynn.swift:14:36: error: cannot find 'alphabet'\
    \ in scope\n        result = result + alphabet[alphabet.IndexOf(c) + 2]\n    \
    \                               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824986
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 4)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 6)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 8)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 10)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 12)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 14)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 16)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 18)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 20)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 22)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 24)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 26)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 28)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 30)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 32)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 34)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 36)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 38)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 40)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 42)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 44)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 46)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 48)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 50)))\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpmoyyggnd.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpmoyyggnd.swift:16:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmoyyggnd.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmoyyggnd.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 4)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmoyyggnd.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 6)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmoyyggnd.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 8)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmoyyggnd.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 10)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmoyyggnd.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 12)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmoyyggnd.swift:23:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt8(UInt8.max)\
    \ - 14)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpmoyyggnd.swift:24:41:\
    \ error: type "
  stdout: ''
  timestamp: 1659824987
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfunc encrypt(s: String) -> String {\n    var alphabet\
    \ = [Character]()\n    for c in s.characters {\n        alphabet.append(c)\n \
    \   }\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count))))\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 1)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 2)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 3)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 4)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 5)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 6)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 7)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 8)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 9)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 10)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 11)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 12)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 13)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 14)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 15)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 16)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 17)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 18)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 19)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 20)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 21)))\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 22)))\n    alphabet.append(Character(Charact\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpxc41pfaj.swift:43:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpxc41pfaj.swift:42:30: note: to match this opening '('\n    alphabet.append(Character(Charact\n\
    \                             ^\n/tmp/tmpxc41pfaj.swift:13:16: error: 'characters'\
    \ is unavailable: Please use String directly\n    for c in s.characters {\n  \
    \             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpxc41pfaj.swift:16:41: error: type 'Character' has no member 'UnicodeScalar'\n\
    \    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpxc41pfaj.swift:17:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ - 1)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpxc41pfaj.swift:18:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count))))\n\
    \                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpxc41pfaj.swift:19:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpxc41pfaj.swift:20:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 1)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpxc41pfaj.swift:21:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 2)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpxc41pfaj.swift:22:41:\
    \ error: type 'Character' has no member 'UnicodeScalar'\n    alphabet.append(Character(Character.UnicodeScalar(UInt32(alphabet.count)\
    \ + 3)))\n                              ~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpxc41pfaj.swi"
  stdout: ''
  timestamp: 1659824988
