language: swift
name: HumanEval_158_find_max
results:
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        if maxCount < word.characters.count\
    \ {\n            maxCount = word.characters.count\n            maxWord = word\n\
    \        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp5xon94e3.swift:13:28: error: 'characters' is unavailable: Please\
    \ use String directly\n        if maxCount < word.characters.count {\n       \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp5xon94e3.swift:14:29: error: 'characters' is unavailable: Please\
    \ use String directly\n            maxCount = word.characters.count\n        \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == char.lowercased() {\n                count +=\
    \ 1\n            }\n        }\n        if count > maxCount {\n            maxCount\
    \ = count\n            maxWord = word\n        }\n    }\n    return maxWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpr21lo869.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == char.lowercased()\
    \ {\n               ~~~~ ^  ~~~~~~~~~~~~~~~~~\n/tmp/tmpr21lo869.swift:15:21: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n            if char == char.lowercased() {\n \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == char.lowercased() {\n                count +=\
    \ 1\n            }\n        }\n        if count > maxCount {\n            maxCount\
    \ = count\n            maxWord = word\n        }\n    }\n    return maxWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpr21lo869.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == char.lowercased()\
    \ {\n               ~~~~ ^  ~~~~~~~~~~~~~~~~~\n/tmp/tmpr21lo869.swift:15:21: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n            if char == char.lowercased() {\n \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var max = \"\"\n    var maxCount\
    \ = 0\n    for word in words {\n        if maxCount < word.characters.count {\n\
    \            max = word\n            maxCount = word.characters.count\n      \
    \  }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpvmbczecu.swift:13:28: error: 'characters' is unavailable: Please\
    \ use String directly\n        if maxCount < word.characters.count {\n       \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpvmbczecu.swift:15:29: error: 'characters' is unavailable: Please\
    \ use String directly\n            maxCount = word.characters.count\n        \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char.unicodeScalars.count > count {\n               \
    \ count = char.unicodeScalars.count\n            }\n        }\n        if count\
    \ > maxCount {\n            maxCount = count\n            maxWord = word\n   \
    \     }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpi8f6osb6/tmpi8f6osb6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae144c0fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae144906b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae144906988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae1449057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi8f6osb6                        0x000055cc6db7d84e <unavailable> + 6222

    5    libc.so.6                          0x00002ae144dfb460 __libc_start_main +
    245

    6    tmpi8f6osb6                        0x000055cc6db7d409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == ' ' {\n                continue\n           \
    \ }\n            count += 1\n        }\n        if count > maxCount {\n      \
    \      maxCount = count\n            maxWord = word\n        }\n    }\n    return\
    \ maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpc93q39wr.swift:15:24: error: single-quoted string literal found,\
    \ use '\"'\n            if char == ' ' {\n                       ^~~\n       \
    \                \" \"\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == char.lowercased() {\n                count +=\
    \ 1\n            }\n        }\n        if count > maxCount {\n            maxCount\
    \ = count\n            maxWord = word\n        }\n    }\n    return maxWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpr21lo869.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == char.lowercased()\
    \ {\n               ~~~~ ^  ~~~~~~~~~~~~~~~~~\n/tmp/tmpr21lo869.swift:15:21: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n            if char == char.lowercased() {\n \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for c in word\
    \ {\n            if word[c] == word[count] {\n                count++\n      \
    \      }\n        }\n        if count > maxCount {\n            maxCount = count\n\
    \            maxWord = word\n        }\n    }\n    return maxWord\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmp02rc2_fk.swift:15:21: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String.Index'\n            if word[c] == word[count]\
    \ {\n                    ^\n/tmp/tmp02rc2_fk.swift:16:22: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n                count++\n             \
    \        ^~\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char.unicodeScalars.count > count {\n               \
    \ count = char.unicodeScalars.count\n            }\n        }\n        if count\
    \ > maxCount {\n            maxCount = count\n            maxWord = word\n   \
    \     }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpi8f6osb6/tmpi8f6osb6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae144c0fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae144906b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae144906988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae1449057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi8f6osb6                        0x000055cc6db7d84e <unavailable> + 6222

    5    libc.so.6                          0x00002ae144dfb460 __libc_start_main +
    245

    6    tmpi8f6osb6                        0x000055cc6db7d409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1660013562
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char.unicodeScalars.count > count {\n               \
    \ count = char.unicodeScalars.count\n            }\n        }\n        if count\
    \ > maxCount {\n            maxCount = count\n            maxWord = word\n   \
    \     }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpi8f6osb6/tmpi8f6osb6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae144c0fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae144906b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae144906988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae1449057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi8f6osb6                        0x000055cc6db7d84e <unavailable> + 6222

    5    libc.so.6                          0x00002ae144dfb460 __libc_start_main +
    245

    6    tmpi8f6osb6                        0x000055cc6db7d409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1660013562
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char.unicodeScalars.isEmpty {\n                continue\n\
    \            }\n            count += 1\n        }\n        if count > maxCount\
    \ {\n            maxCount = count\n            maxWord = word\n        }\n   \
    \ }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpmfdm3v7v/tmpmfdm3v7v.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b257b672c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b257b369b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b257b369988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b257b3687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmfdm3v7v                        0x000055555e2c69e3 <unavailable> + 6627

    5    libc.so.6                          0x00002b257b85e460 __libc_start_main +
    245

    6    tmpmfdm3v7v                        0x000055555e2c6409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1660013562
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char.unicodeScalars.count > count {\n               \
    \ count = char.unicodeScalars.count\n            }\n        }\n        if count\
    \ > maxCount {\n            maxCount = count\n            maxWord = word\n   \
    \     }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpi8f6osb6/tmpi8f6osb6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae144c0fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae144906b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae144906988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae1449057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi8f6osb6                        0x000055cc6db7d84e <unavailable> + 6222

    5    libc.so.6                          0x00002ae144dfb460 __libc_start_main +
    245

    6    tmpi8f6osb6                        0x000055cc6db7d409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var max = \"\"\n    var maxCount\
    \ = 0\n    for word in words {\n        var count = 0\n        for char in word\
    \ {\n            if char == max {\n                count += 1\n            } else\
    \ {\n                count = 0\n            }\n            if count > maxCount\
    \ {\n                max = char\n                maxCount = count\n          \
    \  }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpybgntes_.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == max {\n\
    \               ~~~~ ^  ~~~\n/tmp/tmpybgntes_.swift:15:21: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n            if char == max {\n                    ^\n/tmp/tmpybgntes_.swift:21:23:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \      max = char\n                      ^~~~\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var max = \"\"\n    var maxCount\
    \ = 0\n    for word in words {\n        var count = 0\n        for char in word\
    \ {\n            if char == max {\n                count += 1\n            } else\
    \ {\n                count = 0\n            }\n            if count > maxCount\
    \ {\n                max = char\n                maxCount = count\n          \
    \  }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpybgntes_.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == max {\n\
    \               ~~~~ ^  ~~~\n/tmp/tmpybgntes_.swift:15:21: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n            if char == max {\n                    ^\n/tmp/tmpybgntes_.swift:21:23:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \      max = char\n                      ^~~~\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char.unicodeScalars.count > count {\n               \
    \ count = char.unicodeScalars.count\n            }\n        }\n        if count\
    \ > maxCount {\n            maxCount = count\n            maxWord = word\n   \
    \     }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpi8f6osb6/tmpi8f6osb6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae144c0fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae144906b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae144906988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae1449057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi8f6osb6                        0x000055cc6db7d84e <unavailable> + 6222

    5    libc.so.6                          0x00002ae144dfb460 __libc_start_main +
    245

    6    tmpi8f6osb6                        0x000055cc6db7d409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char != ' ' {\n                count += 1\n         \
    \   }\n        }\n        if count > maxCount {\n            maxCount = count\n\
    \            maxWord = word\n        }\n    }\n    return maxWord\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpu3q07ecb.swift:15:24: error: single-quoted string literal found,\
    \ use '\"'\n            if char != ' ' {\n                       ^~~\n       \
    \                \" \"\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        if maxCount < word.characters.count\
    \ {\n            maxCount = word.characters.count\n            maxWord = word\n\
    \        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp5xon94e3.swift:13:28: error: 'characters' is unavailable: Please\
    \ use String directly\n        if maxCount < word.characters.count {\n       \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp5xon94e3.swift:14:29: error: 'characters' is unavailable: Please\
    \ use String directly\n            maxCount = word.characters.count\n        \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var max = \"\"\n    var maxCount\
    \ = 0\n    for word in words {\n        var count = 0\n        for char in word\
    \ {\n            if char == max {\n                count += 1\n            } else\
    \ {\n                count = 0\n            }\n            if count > maxCount\
    \ {\n                max = char\n                maxCount = count\n          \
    \  }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpybgntes_.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == max {\n\
    \               ~~~~ ^  ~~~\n/tmp/tmpybgntes_.swift:15:21: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n            if char == max {\n                    ^\n/tmp/tmpybgntes_.swift:21:23:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \      max = char\n                      ^~~~\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = countUniqueChars(word)\n\
    \        if count > maxCount {\n            maxCount = count\n            maxWord\
    \ = word\n        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpviw5165v.swift:13:21: error: cannot find 'countUniqueChars' in\
    \ scope\n        var count = countUniqueChars(word)\n                    ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char.unicodeScalars.count > count {\n               \
    \ count = char.unicodeScalars.count\n            }\n        }\n        if count\
    \ > maxCount {\n            maxCount = count\n            maxWord = word\n   \
    \     }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpi8f6osb6/tmpi8f6osb6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae144c0fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae144906b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae144906988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae1449057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi8f6osb6                        0x000055cc6db7d84e <unavailable> + 6222

    5    libc.so.6                          0x00002ae144dfb460 __libc_start_main +
    245

    6    tmpi8f6osb6                        0x000055cc6db7d409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = countChars(word)\n    \
    \    if count > maxCount {\n            maxCount = count\n            maxWord\
    \ = word\n        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp716p20ps.swift:13:21: error: cannot find 'countChars' in scope\n\
    \        var count = countChars(word)\n                    ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == char.lowercased() {\n                count +=\
    \ 1\n            }\n        }\n        if count > maxCount {\n            maxCount\
    \ = count\n            maxWord = word\n        }\n    }\n    return maxWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpr21lo869.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == char.lowercased()\
    \ {\n               ~~~~ ^  ~~~~~~~~~~~~~~~~~\n/tmp/tmpr21lo869.swift:15:21: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n            if char == char.lowercased() {\n \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char.unicodeScalars.count > count {\n               \
    \ count = char.unicodeScalars.count\n            }\n        }\n        if count\
    \ > maxCount {\n            maxCount = count\n            maxWord = word\n   \
    \     }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpi8f6osb6/tmpi8f6osb6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae144c0fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae144906b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae144906988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae1449057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi8f6osb6                        0x000055cc6db7d84e <unavailable> + 6222

    5    libc.so.6                          0x00002ae144dfb460 __libc_start_main +
    245

    6    tmpi8f6osb6                        0x000055cc6db7d409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        if maxCount < word.characters.count\
    \ {\n            maxCount = word.characters.count\n            maxWord = word\n\
    \        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp5xon94e3.swift:13:28: error: 'characters' is unavailable: Please\
    \ use String directly\n        if maxCount < word.characters.count {\n       \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp5xon94e3.swift:14:29: error: 'characters' is unavailable: Please\
    \ use String directly\n            maxCount = word.characters.count\n        \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        if maxCount < word.characters.count\
    \ {\n            maxCount = word.characters.count\n            maxWord = word\n\
    \        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp5xon94e3.swift:13:28: error: 'characters' is unavailable: Please\
    \ use String directly\n        if maxCount < word.characters.count {\n       \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp5xon94e3.swift:14:29: error: 'characters' is unavailable: Please\
    \ use String directly\n            maxCount = word.characters.count\n        \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var max = \"\"\n    var maxCount\
    \ = 0\n    for word in words {\n        var count = 0\n        for char in word\
    \ {\n            if char == max {\n                count += 1\n            } else\
    \ {\n                count = 0\n            }\n            if count > maxCount\
    \ {\n                max = char\n                maxCount = count\n          \
    \  }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpybgntes_.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == max {\n\
    \               ~~~~ ^  ~~~\n/tmp/tmpybgntes_.swift:15:21: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n            if char == max {\n                    ^\n/tmp/tmpybgntes_.swift:21:23:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \      max = char\n                      ^~~~\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char != ' ' {\n                count = count + 1\n  \
    \          }\n        }\n        if count > maxCount {\n            maxCount =\
    \ count\n            maxWord = word\n        }\n    }\n    return maxWord\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpbq3kkngs.swift:15:24: error: single-quoted string literal found,\
    \ use '\"'\n            if char != ' ' {\n                       ^~~\n       \
    \                \" \"\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == ' ' {\n                count = count + 1\n  \
    \          } else {\n                count = count + 1\n                if count\
    \ > maxCount {\n                    maxCount = count\n                    maxWord\
    \ = word\n                }\n            }\n        }\n    }\n    return maxWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpztq35ami.swift:15:24: error: single-quoted string literal found,\
    \ use '\"'\n            if char == ' ' {\n                       ^~~\n       \
    \                \" \"\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == char.lowercased() {\n                count +=\
    \ 1\n            }\n        }\n        if count > maxCount {\n            maxCount\
    \ = count\n            maxWord = word\n        }\n    }\n    return maxWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpr21lo869.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == char.lowercased()\
    \ {\n               ~~~~ ^  ~~~~~~~~~~~~~~~~~\n/tmp/tmpr21lo869.swift:15:21: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n            if char == char.lowercased() {\n \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        if maxCount < word.characters.count\
    \ {\n            maxCount = word.characters.count\n            maxWord = word\n\
    \        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp5xon94e3.swift:13:28: error: 'characters' is unavailable: Please\
    \ use String directly\n        if maxCount < word.characters.count {\n       \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp5xon94e3.swift:14:29: error: 'characters' is unavailable: Please\
    \ use String directly\n            maxCount = word.characters.count\n        \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == ' ' {\n                continue\n           \
    \ }\n            if char == maxWord {\n                count += 1\n          \
    \  } else {\n                count = 1\n            }\n            if count >\
    \ maxCount {\n                maxCount = count\n                maxWord = word\n\
    \            }\n        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp09el1ann.swift:15:24: error: single-quoted string literal found,\
    \ use '\"'\n            if char == ' ' {\n                       ^~~\n       \
    \                \" \"\n/tmp/tmp09el1ann.swift:18:21: error: binary operator '=='\
    \ cannot be applied to operands of type 'Character' and 'String'\n           \
    \ if char == maxWord {\n               ~~~~ ^  ~~~~~~~\n/tmp/tmp09el1ann.swift:18:21:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n            if char == maxWord {\n\
    \                    ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = count_unique(word)\n  \
    \      if count > maxCount {\n            maxCount = count\n            maxWord\
    \ = word\n        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp880lvbls.swift:13:21: error: cannot find 'count_unique' in scope\n\
    \        var count = count_unique(word)\n                    ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var max = \"\"\n    var maxCount\
    \ = 0\n    for word in words {\n        var count = 0\n        for char in word\
    \ {\n            if char == max {\n                count += 1\n            } else\
    \ {\n                count = 0\n            }\n            if count > maxCount\
    \ {\n                max = char\n                maxCount = count\n          \
    \  }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpybgntes_.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == max {\n\
    \               ~~~~ ^  ~~~\n/tmp/tmpybgntes_.swift:15:21: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n            if char == max {\n                    ^\n/tmp/tmpybgntes_.swift:21:23:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \      max = char\n                      ^~~~\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        if maxCount < word.characters.count\
    \ {\n            maxCount = word.characters.count\n            maxWord = word\n\
    \        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp5xon94e3.swift:13:28: error: 'characters' is unavailable: Please\
    \ use String directly\n        if maxCount < word.characters.count {\n       \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp5xon94e3.swift:14:29: error: 'characters' is unavailable: Please\
    \ use String directly\n            maxCount = word.characters.count\n        \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == char.lowercased() {\n                count +=\
    \ 1\n            }\n        }\n        if count > maxCount {\n            maxCount\
    \ = count\n            maxWord = word\n        }\n    }\n    return maxWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpr21lo869.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == char.lowercased()\
    \ {\n               ~~~~ ^  ~~~~~~~~~~~~~~~~~\n/tmp/tmpr21lo869.swift:15:21: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n            if char == char.lowercased() {\n \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        if maxCount < word.characters.count\
    \ {\n            maxCount = word.characters.count\n            maxWord = word\n\
    \        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp5xon94e3.swift:13:28: error: 'characters' is unavailable: Please\
    \ use String directly\n        if maxCount < word.characters.count {\n       \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp5xon94e3.swift:14:29: error: 'characters' is unavailable: Please\
    \ use String directly\n            maxCount = word.characters.count\n        \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == char.lowercased() {\n                count +=\
    \ 1\n            }\n        }\n        if count > maxCount {\n            maxCount\
    \ = count\n            maxWord = word\n        }\n    }\n    return maxWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpr21lo869.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == char.lowercased()\
    \ {\n               ~~~~ ^  ~~~~~~~~~~~~~~~~~\n/tmp/tmpr21lo869.swift:15:21: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n            if char == char.lowercased() {\n \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == char.lowercased() {\n                count +=\
    \ 1\n            }\n        }\n        if count > maxCount {\n            maxCount\
    \ = count\n            maxWord = word\n        }\n    }\n    return maxWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpr21lo869.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == char.lowercased()\
    \ {\n               ~~~~ ^  ~~~~~~~~~~~~~~~~~\n/tmp/tmpr21lo869.swift:15:21: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n            if char == char.lowercased() {\n \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        if word.characters.count > maxCount\
    \ {\n            maxCount = word.characters.count\n            maxWord = word\n\
    \        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpsbfiia9c.swift:13:17: error: 'characters' is unavailable: Please\
    \ use String directly\n        if word.characters.count > maxCount {\n       \
    \         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpsbfiia9c.swift:14:29:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ maxCount = word.characters.count\n                            ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        if word.characters.count > maxCount\
    \ {\n            maxCount = word.characters.count\n            maxWord = word\n\
    \        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpsbfiia9c.swift:13:17: error: 'characters' is unavailable: Please\
    \ use String directly\n        if word.characters.count > maxCount {\n       \
    \         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpsbfiia9c.swift:14:29:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ maxCount = word.characters.count\n                            ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var max = \"\"\n    var maxCount\
    \ = 0\n    for word in words {\n        var count = 0\n        for char in word\
    \ {\n            if char == max {\n                count += 1\n            } else\
    \ {\n                count = 0\n            }\n            if count > maxCount\
    \ {\n                max = char\n                maxCount = count\n          \
    \  }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpybgntes_.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == max {\n\
    \               ~~~~ ^  ~~~\n/tmp/tmpybgntes_.swift:15:21: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n            if char == max {\n                    ^\n/tmp/tmpybgntes_.swift:21:23:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \      max = char\n                      ^~~~\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var max = \"\"\n    var maxCount\
    \ = 0\n    for word in words {\n        var count = 0\n        for char in word\
    \ {\n            if char == max {\n                count += 1\n            } else\
    \ {\n                count = 0\n            }\n            if count > maxCount\
    \ {\n                max = char\n                maxCount = count\n          \
    \  }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpybgntes_.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == max {\n\
    \               ~~~~ ^  ~~~\n/tmp/tmpybgntes_.swift:15:21: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n            if char == max {\n                    ^\n/tmp/tmpybgntes_.swift:21:23:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \      max = char\n                      ^~~~\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var max = \"\"\n    var maxCount\
    \ = 0\n    for word in words {\n        var count = word.characters.count\n  \
    \      if count > maxCount {\n            max = word\n            maxCount = count\n\
    \        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpkmmcrz_5.swift:13:26: error: 'characters' is unavailable: Please\
    \ use String directly\n        var count = word.characters.count\n           \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpkmmcrz_5.swift:13:13: warning: variable 'count' was never mutated;\
    \ consider changing to 'let' constant\n        var count = word.characters.count\n\
    \        ~~~ ^\n        let\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var max = \"\"\n    var maxCount\
    \ = 0\n    for word in words {\n        var count = 0\n        for char in word\
    \ {\n            if char == max {\n                count += 1\n            } else\
    \ {\n                count = 0\n            }\n            if count > maxCount\
    \ {\n                max = char\n                maxCount = count\n          \
    \  }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpybgntes_.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == max {\n\
    \               ~~~~ ^  ~~~\n/tmp/tmpybgntes_.swift:15:21: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n            if char == max {\n                    ^\n/tmp/tmpybgntes_.swift:21:23:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \      max = char\n                      ^~~~\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == char.lowercased() {\n                count +=\
    \ 1\n            }\n        }\n        if count > maxCount {\n            maxCount\
    \ = count\n            maxWord = word\n        }\n    }\n    return maxWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpr21lo869.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == char.lowercased()\
    \ {\n               ~~~~ ^  ~~~~~~~~~~~~~~~~~\n/tmp/tmpr21lo869.swift:15:21: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n            if char == char.lowercased() {\n \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == ' ' {\n                continue\n           \
    \ }\n            count = count + 1\n        }\n        if count > maxCount {\n\
    \            maxCount = count\n            maxWord = word\n        }\n    }\n\
    \    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmph3jgli4f.swift:15:24: error: single-quoted string literal found,\
    \ use '\"'\n            if char == ' ' {\n                       ^~~\n       \
    \                \" \"\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        if maxCount < word.characters.count\
    \ {\n            maxCount = word.characters.count\n            maxWord = word\n\
    \        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp5xon94e3.swift:13:28: error: 'characters' is unavailable: Please\
    \ use String directly\n        if maxCount < word.characters.count {\n       \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp5xon94e3.swift:14:29: error: 'characters' is unavailable: Please\
    \ use String directly\n            maxCount = word.characters.count\n        \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == ' ' {\n                continue\n           \
    \ }\n            if char == maxWord {\n                count++\n            }\
    \ else {\n                count = 0\n            }\n            if count > maxCount\
    \ {\n                maxCount = count\n                maxWord = word\n      \
    \      }\n        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp8la28yk4.swift:15:24: error: single-quoted string literal found,\
    \ use '\"'\n            if char == ' ' {\n                       ^~~\n       \
    \                \" \"\n/tmp/tmp8la28yk4.swift:18:21: error: binary operator '=='\
    \ cannot be applied to operands of type 'Character' and 'String'\n           \
    \ if char == maxWord {\n               ~~~~ ^  ~~~~~~~\n/tmp/tmp8la28yk4.swift:18:21:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n            if char == maxWord {\n\
    \                    ^\n/tmp/tmp8la28yk4.swift:19:22: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n                count++\n             \
    \        ^~\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == ' ' {\n                continue\n           \
    \ }\n            count = count + 1\n        }\n        if count > maxCount {\n\
    \            maxCount = count\n            maxWord = word\n        }\n    }\n\
    \    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmph3jgli4f.swift:15:24: error: single-quoted string literal found,\
    \ use '\"'\n            if char == ' ' {\n                       ^~~\n       \
    \                \" \"\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == ' ' {\n                continue\n           \
    \ }\n            count = count + 1\n        }\n        if count > maxCount {\n\
    \            maxCount = count\n            maxWord = word\n        }\n    }\n\
    \    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmph3jgli4f.swift:15:24: error: single-quoted string literal found,\
    \ use '\"'\n            if char == ' ' {\n                       ^~~\n       \
    \                \" \"\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var max = \"\"\n    var maxCount\
    \ = 0\n    for word in words {\n        var count = 0\n        for char in word\
    \ {\n            if char != max {\n                count += 1\n            }\n\
    \        }\n        if count > maxCount {\n            max = word\n          \
    \  maxCount = count\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp3lpnxf_a.swift:15:24: error: cannot convert value of type 'String'\
    \ to expected argument type 'Character'\n            if char != max {\n      \
    \                 ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == char.lowercased() {\n                count +=\
    \ 1\n            }\n        }\n        if count > maxCount {\n            maxCount\
    \ = count\n            maxWord = word\n        }\n    }\n    return maxWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpr21lo869.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == char.lowercased()\
    \ {\n               ~~~~ ^  ~~~~~~~~~~~~~~~~~\n/tmp/tmpr21lo869.swift:15:21: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n            if char == char.lowercased() {\n \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char != ' ' {\n                count += 1\n         \
    \   }\n        }\n        if count > maxCount {\n            maxCount = count\n\
    \            maxWord = word\n        }\n    }\n    return maxWord\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpu3q07ecb.swift:15:24: error: single-quoted string literal found,\
    \ use '\"'\n            if char != ' ' {\n                       ^~~\n       \
    \                \" \"\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == ' ' {\n                continue\n           \
    \ }\n            count += 1\n        }\n        if count > maxCount {\n      \
    \      maxCount = count\n            maxWord = word\n        }\n    }\n    return\
    \ maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpc93q39wr.swift:15:24: error: single-quoted string literal found,\
    \ use '\"'\n            if char == ' ' {\n                       ^~~\n       \
    \                \" \"\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char.unicodeScalars.count > count {\n               \
    \ count = char.unicodeScalars.count\n            }\n        }\n        if count\
    \ > maxCount {\n            maxCount = count\n            maxWord = word\n   \
    \     }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpi8f6osb6/tmpi8f6osb6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae144c0fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae144906b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae144906988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae1449057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi8f6osb6                        0x000055cc6db7d84e <unavailable> + 6222

    5    libc.so.6                          0x00002ae144dfb460 __libc_start_main +
    245

    6    tmpi8f6osb6                        0x000055cc6db7d409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1660013562
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char.unicodeScalars.count > count {\n               \
    \ count = char.unicodeScalars.count\n            }\n        }\n        if count\
    \ > maxCount {\n            maxCount = count\n            maxWord = word\n   \
    \     }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpi8f6osb6/tmpi8f6osb6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae144c0fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae144906b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae144906988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae1449057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi8f6osb6                        0x000055cc6db7d84e <unavailable> + 6222

    5    libc.so.6                          0x00002ae144dfb460 __libc_start_main +
    245

    6    tmpi8f6osb6                        0x000055cc6db7d409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        if maxCount < word.characters.count\
    \ {\n            maxCount = word.characters.count\n            maxWord = word\n\
    \        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp5xon94e3.swift:13:28: error: 'characters' is unavailable: Please\
    \ use String directly\n        if maxCount < word.characters.count {\n       \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp5xon94e3.swift:14:29: error: 'characters' is unavailable: Please\
    \ use String directly\n            maxCount = word.characters.count\n        \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == char.lowercased() {\n                count +=\
    \ 1\n            }\n        }\n        if count > maxCount {\n            maxCount\
    \ = count\n            maxWord = word\n        }\n    }\n    return maxWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpr21lo869.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == char.lowercased()\
    \ {\n               ~~~~ ^  ~~~~~~~~~~~~~~~~~\n/tmp/tmpr21lo869.swift:15:21: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n            if char == char.lowercased() {\n \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var max = \"\"\n    var maxCount\
    \ = 0\n    for word in words {\n        var count = 0\n        for char in word\
    \ {\n            if char == max {\n                count += 1\n            } else\
    \ {\n                count = 0\n            }\n            if count > maxCount\
    \ {\n                max = char\n                maxCount = count\n          \
    \  }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpybgntes_.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == max {\n\
    \               ~~~~ ^  ~~~\n/tmp/tmpybgntes_.swift:15:21: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n            if char == max {\n                    ^\n/tmp/tmpybgntes_.swift:21:23:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \      max = char\n                      ^~~~\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var max = \"\"\n    var maxCount\
    \ = 0\n    for word in words {\n        var count = 0\n        for char in word\
    \ {\n            if char != max[count] {\n                count = count + 1\n\
    \            }\n        }\n        if count > maxCount {\n            max = word\n\
    \            maxCount = count\n        }\n    }\n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpu_v_c4cm.swift:15:24: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n            if char\
    \ != max[count] {\n                       ^~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = word.characters.count\n\
    \        if count > maxCount {\n            maxCount = count\n            maxWord\
    \ = word\n        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpbd9z0vdh.swift:13:26: error: 'characters' is unavailable: Please\
    \ use String directly\n        var count = word.characters.count\n           \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpbd9z0vdh.swift:13:13: warning: variable 'count' was never mutated;\
    \ consider changing to 'let' constant\n        var count = word.characters.count\n\
    \        ~~~ ^\n        let\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char != ' ' {\n                count += 1\n         \
    \   }\n        }\n        if count > maxCount {\n            maxCount = count\n\
    \            maxWord = word\n        }\n    }\n    return maxWord\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpu3q07ecb.swift:15:24: error: single-quoted string literal found,\
    \ use '\"'\n            if char != ' ' {\n                       ^~~\n       \
    \                \" \"\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var max = \"\"\n    var maxCount\
    \ = 0\n    for word in words {\n        if maxCount < word.characters.count {\n\
    \            max = word\n            maxCount = word.characters.count\n      \
    \  }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpvmbczecu.swift:13:28: error: 'characters' is unavailable: Please\
    \ use String directly\n        if maxCount < word.characters.count {\n       \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpvmbczecu.swift:15:29: error: 'characters' is unavailable: Please\
    \ use String directly\n            maxCount = word.characters.count\n        \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        if maxCount < word.characters.count\
    \ {\n            maxCount = word.characters.count\n            maxWord = word\n\
    \        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp5xon94e3.swift:13:28: error: 'characters' is unavailable: Please\
    \ use String directly\n        if maxCount < word.characters.count {\n       \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp5xon94e3.swift:14:29: error: 'characters' is unavailable: Please\
    \ use String directly\n            maxCount = word.characters.count\n        \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char.unicodeScalars.count > count {\n               \
    \ count = char.unicodeScalars.count\n            }\n        }\n        if count\
    \ > maxCount {\n            maxCount = count\n            maxWord = word\n   \
    \     }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpi8f6osb6/tmpi8f6osb6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae144c0fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae144906b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae144906988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae1449057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi8f6osb6                        0x000055cc6db7d84e <unavailable> + 6222

    5    libc.so.6                          0x00002ae144dfb460 __libc_start_main +
    245

    6    tmpi8f6osb6                        0x000055cc6db7d409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1660013562
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char.unicodeScalars.count > count {\n               \
    \ count = char.unicodeScalars.count\n            }\n        }\n        if count\
    \ > maxCount {\n            maxCount = count\n            maxWord = word\n   \
    \     }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpi8f6osb6/tmpi8f6osb6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae144c0fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae144906b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae144906988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae1449057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi8f6osb6                        0x000055cc6db7d84e <unavailable> + 6222

    5    libc.so.6                          0x00002ae144dfb460 __libc_start_main +
    245

    6    tmpi8f6osb6                        0x000055cc6db7d409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var max = \"\"\n    var maxCount\
    \ = 0\n    for word in words {\n        var count = 0\n        for char in word\
    \ {\n            if char != max {\n                count = count + 1\n       \
    \     }\n        }\n        if count > maxCount {\n            max = word\n  \
    \          maxCount = count\n        }\n    }\n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpck__rfls.swift:15:24: error: cannot convert value of type 'String'\
    \ to expected argument type 'Character'\n            if char != max {\n      \
    \                 ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == char.lowercased() {\n                count +=\
    \ 1\n            }\n        }\n        if count > maxCount {\n            maxCount\
    \ = count\n            maxWord = word\n        }\n    }\n    return maxWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpr21lo869.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == char.lowercased()\
    \ {\n               ~~~~ ^  ~~~~~~~~~~~~~~~~~\n/tmp/tmpr21lo869.swift:15:21: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n            if char == char.lowercased() {\n \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == char.lowercased() {\n                count +=\
    \ 1\n            }\n        }\n        if count > maxCount {\n            maxCount\
    \ = count\n            maxWord = word\n        }\n    }\n    return maxWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpr21lo869.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == char.lowercased()\
    \ {\n               ~~~~ ^  ~~~~~~~~~~~~~~~~~\n/tmp/tmpr21lo869.swift:15:21: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n            if char == char.lowercased() {\n \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var max = \"\"\n    var maxCount\
    \ = 0\n    for word in words {\n        var count = 0\n        for char in word\
    \ {\n            if char == max {\n                count += 1\n            } else\
    \ {\n                count = 0\n            }\n            if count > maxCount\
    \ {\n                max = char\n                maxCount = count\n          \
    \  }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpybgntes_.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == max {\n\
    \               ~~~~ ^  ~~~\n/tmp/tmpybgntes_.swift:15:21: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n            if char == max {\n                    ^\n/tmp/tmpybgntes_.swift:21:23:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \      max = char\n                      ^~~~\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == char.lowercased() {\n                count +=\
    \ 1\n            }\n        }\n        if count > maxCount {\n            maxCount\
    \ = count\n            maxWord = word\n        }\n    }\n    return maxWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpr21lo869.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == char.lowercased()\
    \ {\n               ~~~~ ^  ~~~~~~~~~~~~~~~~~\n/tmp/tmpr21lo869.swift:15:21: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n            if char == char.lowercased() {\n \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for c in word\
    \ {\n            if c == maxWord[count] {\n                count += 1\n      \
    \      } else {\n                count = 0\n            }\n        }\n       \
    \ if count > maxCount {\n            maxCount = count\n            maxWord = word\n\
    \        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp6wslrtxd.swift:15:21: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n            if c\
    \ == maxWord[count] {\n                    ^~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == word[count] {\n                count += 1\n \
    \           } else {\n                break\n            }\n        }\n      \
    \  if count > maxCount {\n            maxCount = count\n            maxWord =\
    \ word\n        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp4xn5pi9_.swift:15:24: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n            if char\
    \ == word[count] {\n                       ^~~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var max = \"\"\n    var maxCount\
    \ = 0\n    for word in words {\n        var count = 0\n        for char in word\
    \ {\n            if char == max {\n                count += 1\n            } else\
    \ {\n                count = 0\n            }\n            if count > maxCount\
    \ {\n                max = char\n                maxCount = count\n          \
    \  }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpybgntes_.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == max {\n\
    \               ~~~~ ^  ~~~\n/tmp/tmpybgntes_.swift:15:21: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n            if char == max {\n                    ^\n/tmp/tmpybgntes_.swift:21:23:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \      max = char\n                      ^~~~\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = word.characters.count\n\
    \        if count > maxCount {\n            maxCount = count\n            maxWord\
    \ = word\n        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpbd9z0vdh.swift:13:26: error: 'characters' is unavailable: Please\
    \ use String directly\n        var count = word.characters.count\n           \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpbd9z0vdh.swift:13:13: warning: variable 'count' was never mutated;\
    \ consider changing to 'let' constant\n        var count = word.characters.count\n\
    \        ~~~ ^\n        let\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for c in word\
    \ {\n            if c == maxWord {\n                count += 1\n            }\
    \ else {\n                count = 0\n            }\n        }\n        if count\
    \ > maxCount {\n            maxCount = count\n            maxWord = word\n   \
    \     }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpipcnebiw.swift:15:18: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if c == maxWord {\n\
    \               ~ ^  ~~~~~~~\n/tmp/tmpipcnebiw.swift:15:18: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n            if c == maxWord {\n                 ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == ' ' {\n                continue\n           \
    \ }\n            if char.unicodeScalars.isEmpty {\n                continue\n\
    \            }\n            count += char.unicodeScalars.count\n        }\n  \
    \      if count > maxCount {\n            maxCount = count\n            maxWord\
    \ = word\n        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpzicg9eyh.swift:15:24: error: single-quoted string literal found,\
    \ use '\"'\n            if char == ' ' {\n                       ^~~\n       \
    \                \" \"\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char.unicodeScalars.isEmpty {\n                continue\n\
    \            }\n            count += char.unicodeScalars.count\n        }\n  \
    \      if count > maxCount {\n            maxCount = count\n            maxWord\
    \ = word\n        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: Exception
  stderr: 'tmp8_gc56ox/tmp8_gc56ox.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b305187fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3051576b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3051576988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b30515757b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8_gc56ox                        0x000055c488059a33 <unavailable> + 6707

    5    libc.so.6                          0x00002b3051a6b460 __libc_start_main +
    245

    6    tmp8_gc56ox                        0x000055c488059459 <unavailable> + 5209

    '
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var max = \"\"\n    var maxCount\
    \ = 0\n    for word in words {\n        var count = 0\n        for char in word\
    \ {\n            if char == max {\n                count += 1\n            } else\
    \ {\n                count = 0\n            }\n            if count > maxCount\
    \ {\n                max = char\n                maxCount = count\n          \
    \  }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpybgntes_.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == max {\n\
    \               ~~~~ ^  ~~~\n/tmp/tmpybgntes_.swift:15:21: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n            if char == max {\n                    ^\n/tmp/tmpybgntes_.swift:21:23:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \      max = char\n                      ^~~~\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char != ' ' {\n                count += 1\n         \
    \   }\n        }\n        if count > maxCount {\n            maxCount = count\n\
    \            maxWord = word\n        }\n    }\n    return maxWord\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpu3q07ecb.swift:15:24: error: single-quoted string literal found,\
    \ use '\"'\n            if char != ' ' {\n                       ^~~\n       \
    \                \" \"\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char != ' ' {\n                count += 1\n         \
    \   }\n        }\n        if count > maxCount {\n            maxCount = count\n\
    \            maxWord = word\n        }\n    }\n    return maxWord\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpu3q07ecb.swift:15:24: error: single-quoted string literal found,\
    \ use '\"'\n            if char != ' ' {\n                       ^~~\n       \
    \                \" \"\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == char.lowercased() {\n                count +=\
    \ 1\n            }\n        }\n        if count > maxCount {\n            maxCount\
    \ = count\n            maxWord = word\n        }\n    }\n    return maxWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpr21lo869.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == char.lowercased()\
    \ {\n               ~~~~ ^  ~~~~~~~~~~~~~~~~~\n/tmp/tmpr21lo869.swift:15:21: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n            if char == char.lowercased() {\n \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var max = \"\"\n    var maxCount\
    \ = 0\n    for word in words {\n        var count = 0\n        for char in word\
    \ {\n            if char == max {\n                count += 1\n            } else\
    \ {\n                count = 0\n            }\n            if count > maxCount\
    \ {\n                max = char\n                maxCount = count\n          \
    \  }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpybgntes_.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == max {\n\
    \               ~~~~ ^  ~~~\n/tmp/tmpybgntes_.swift:15:21: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n            if char == max {\n                    ^\n/tmp/tmpybgntes_.swift:21:23:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \      max = char\n                      ^~~~\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == char.lowercased() {\n                count +=\
    \ 1\n            }\n        }\n        if count > maxCount {\n            maxCount\
    \ = count\n            maxWord = word\n        }\n    }\n    return maxWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpr21lo869.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == char.lowercased()\
    \ {\n               ~~~~ ^  ~~~~~~~~~~~~~~~~~\n/tmp/tmpr21lo869.swift:15:21: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n            if char == char.lowercased() {\n \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == word[count] {\n                count += 1\n \
    \           } else {\n                break\n            }\n        }\n      \
    \  if count > maxCount {\n            maxCount = count\n            maxWord =\
    \ word\n        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp4xn5pi9_.swift:15:24: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n            if char\
    \ == word[count] {\n                       ^~~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        if maxCount < word.characters.count\
    \ {\n            maxCount = word.characters.count\n            maxWord = word\n\
    \        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp5xon94e3.swift:13:28: error: 'characters' is unavailable: Please\
    \ use String directly\n        if maxCount < word.characters.count {\n       \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp5xon94e3.swift:14:29: error: 'characters' is unavailable: Please\
    \ use String directly\n            maxCount = word.characters.count\n        \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for c in word\
    \ {\n            if c == maxWord[count] {\n                count += 1\n      \
    \      } else {\n                count = 0\n            }\n        }\n       \
    \ if count > maxCount {\n            maxCount = count\n            maxWord = word\n\
    \        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp6wslrtxd.swift:15:21: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n            if c\
    \ == maxWord[count] {\n                    ^~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == char.lowercased() {\n                count +=\
    \ 1\n            }\n        }\n        if count > maxCount {\n            maxCount\
    \ = count\n            maxWord = word\n        }\n    }\n    return maxWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpr21lo869.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == char.lowercased()\
    \ {\n               ~~~~ ^  ~~~~~~~~~~~~~~~~~\n/tmp/tmpr21lo869.swift:15:21: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n            if char == char.lowercased() {\n \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == char.lowercased() {\n                count +=\
    \ 1\n            }\n        }\n        if count > maxCount {\n            maxCount\
    \ = count\n            maxWord = word\n        }\n    }\n    return maxWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpr21lo869.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == char.lowercased()\
    \ {\n               ~~~~ ^  ~~~~~~~~~~~~~~~~~\n/tmp/tmpr21lo869.swift:15:21: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n            if char == char.lowercased() {\n \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        if maxCount < word.characters.count\
    \ {\n            maxCount = word.characters.count\n            maxWord = word\n\
    \        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp5xon94e3.swift:13:28: error: 'characters' is unavailable: Please\
    \ use String directly\n        if maxCount < word.characters.count {\n       \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp5xon94e3.swift:14:29: error: 'characters' is unavailable: Please\
    \ use String directly\n            maxCount = word.characters.count\n        \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        if maxCount == 0 || maxCount < word.characters.count\
    \ {\n            maxCount = word.characters.count\n            maxWord = word\n\
    \        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpid7u18qk.swift:13:45: error: 'characters' is unavailable: Please\
    \ use String directly\n        if maxCount == 0 || maxCount < word.characters.count\
    \ {\n                                            ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpid7u18qk.swift:14:29: error: 'characters'\
    \ is unavailable: Please use String directly\n            maxCount = word.characters.count\n\
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = word.characters.count\n\
    \        if count > maxCount {\n            maxCount = count\n            maxWord\
    \ = word\n        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpbd9z0vdh.swift:13:26: error: 'characters' is unavailable: Please\
    \ use String directly\n        var count = word.characters.count\n           \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpbd9z0vdh.swift:13:13: warning: variable 'count' was never mutated;\
    \ consider changing to 'let' constant\n        var count = word.characters.count\n\
    \        ~~~ ^\n        let\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char.unicodeScalars.count > count {\n               \
    \ count = char.unicodeScalars.count\n            }\n        }\n        if count\
    \ > maxCount {\n            maxCount = count\n            maxWord = word\n   \
    \     }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpi8f6osb6/tmpi8f6osb6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae144c0fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae144906b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae144906988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae1449057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi8f6osb6                        0x000055cc6db7d84e <unavailable> + 6222

    5    libc.so.6                          0x00002ae144dfb460 __libc_start_main +
    245

    6    tmpi8f6osb6                        0x000055cc6db7d409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1660013562
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        if maxCount < word.count {\n      \
    \      maxCount = word.count\n            maxWord = word\n        }\n    }\n \
    \   return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpa9idafv1/tmpa9idafv1.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba5f1d92c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba5f1a89b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba5f1a89988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5f1a887b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa9idafv1                        0x00005587771ad823 <unavailable> + 6179

    5    libc.so.6                          0x00002ba5f1f7e460 __libc_start_main +
    245

    6    tmpa9idafv1                        0x00005587771ad249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char != ' ' {\n                count += 1\n         \
    \   }\n        }\n        if count > maxCount {\n            maxCount = count\n\
    \            maxWord = word\n        }\n    }\n    return maxWord\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpu3q07ecb.swift:15:24: error: single-quoted string literal found,\
    \ use '\"'\n            if char != ' ' {\n                       ^~~\n       \
    \                \" \"\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var max = \"\"\n    var maxCount\
    \ = 0\n    for word in words {\n        var count = 0\n        for char in word\
    \ {\n            if char == max[count] {\n                count += 1\n       \
    \     } else {\n                count = 0\n            }\n        }\n        if\
    \ count > maxCount {\n            max = word\n            maxCount = count\n \
    \       }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp917kts9s.swift:15:24: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n            if char\
    \ == max[count] {\n                       ^~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        if maxCount < word.characters.count\
    \ {\n            maxCount = word.characters.count\n            maxWord = word\n\
    \        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp5xon94e3.swift:13:28: error: 'characters' is unavailable: Please\
    \ use String directly\n        if maxCount < word.characters.count {\n       \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp5xon94e3.swift:14:29: error: 'characters' is unavailable: Please\
    \ use String directly\n            maxCount = word.characters.count\n        \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        if maxCount < word.characters.count\
    \ {\n            maxCount = word.characters.count\n            maxWord = word\n\
    \        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp5xon94e3.swift:13:28: error: 'characters' is unavailable: Please\
    \ use String directly\n        if maxCount < word.characters.count {\n       \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp5xon94e3.swift:14:29: error: 'characters' is unavailable: Please\
    \ use String directly\n            maxCount = word.characters.count\n        \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char.unicodeScalars.isEmpty {\n                continue\n\
    \            }\n            count += 1\n        }\n        if count > maxCount\
    \ {\n            maxCount = count\n            maxWord = word\n        }\n   \
    \ }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpmfdm3v7v/tmpmfdm3v7v.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b257b672c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b257b369b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b257b369988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b257b3687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmfdm3v7v                        0x000055555e2c69e3 <unavailable> + 6627

    5    libc.so.6                          0x00002b257b85e460 __libc_start_main +
    245

    6    tmpmfdm3v7v                        0x000055555e2c6409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == char.lowercased() {\n                count +=\
    \ 1\n            }\n        }\n        if count > maxCount {\n            maxCount\
    \ = count\n            maxWord = word\n        }\n    }\n    return maxWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpr21lo869.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == char.lowercased()\
    \ {\n               ~~~~ ^  ~~~~~~~~~~~~~~~~~\n/tmp/tmpr21lo869.swift:15:21: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n            if char == char.lowercased() {\n \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = countUniqueChars(word)\n\
    \        if count > maxCount {\n            maxCount = count\n            maxWord\
    \ = word\n        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpviw5165v.swift:13:21: error: cannot find 'countUniqueChars' in\
    \ scope\n        var count = countUniqueChars(word)\n                    ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var max = \"\"\n    var maxCount\
    \ = 0\n    for word in words {\n        var count = 0\n        for char in word\
    \ {\n            if char == max {\n                count += 1\n            } else\
    \ {\n                count = 0\n            }\n            if count > maxCount\
    \ {\n                max = char\n                maxCount = count\n          \
    \  }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpybgntes_.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == max {\n\
    \               ~~~~ ^  ~~~\n/tmp/tmpybgntes_.swift:15:21: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n            if char == max {\n                    ^\n/tmp/tmpybgntes_.swift:21:23:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \      max = char\n                      ^~~~\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == char.lowercased() {\n                count +=\
    \ 1\n            }\n        }\n        if count > maxCount {\n            maxCount\
    \ = count\n            maxWord = word\n        }\n    }\n    return maxWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpr21lo869.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == char.lowercased()\
    \ {\n               ~~~~ ^  ~~~~~~~~~~~~~~~~~\n/tmp/tmpr21lo869.swift:15:21: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n            if char == char.lowercased() {\n \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char.unicodeScalars.count > count {\n               \
    \ count = char.unicodeScalars.count\n            }\n        }\n        if count\
    \ > maxCount {\n            maxCount = count\n            maxWord = word\n   \
    \     }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpi8f6osb6/tmpi8f6osb6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae144c0fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae144906b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae144906988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae1449057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi8f6osb6                        0x000055cc6db7d84e <unavailable> + 6222

    5    libc.so.6                          0x00002ae144dfb460 __libc_start_main +
    245

    6    tmpi8f6osb6                        0x000055cc6db7d409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1660013562
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char.unicodeScalars.count > count {\n               \
    \ count = char.unicodeScalars.count\n            }\n        }\n        if count\
    \ > maxCount {\n            maxCount = count\n            maxWord = word\n   \
    \     }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpi8f6osb6/tmpi8f6osb6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae144c0fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae144906b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae144906988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae1449057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi8f6osb6                        0x000055cc6db7d84e <unavailable> + 6222

    5    libc.so.6                          0x00002ae144dfb460 __libc_start_main +
    245

    6    tmpi8f6osb6                        0x000055cc6db7d409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        if maxCount < word.characters.count\
    \ {\n            maxCount = word.characters.count\n            maxWord = word\n\
    \        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp5xon94e3.swift:13:28: error: 'characters' is unavailable: Please\
    \ use String directly\n        if maxCount < word.characters.count {\n       \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp5xon94e3.swift:14:29: error: 'characters' is unavailable: Please\
    \ use String directly\n            maxCount = word.characters.count\n        \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        if maxCount < word.characters.count\
    \ {\n            maxCount = word.characters.count\n            maxWord = word\n\
    \        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp5xon94e3.swift:13:28: error: 'characters' is unavailable: Please\
    \ use String directly\n        if maxCount < word.characters.count {\n       \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp5xon94e3.swift:14:29: error: 'characters' is unavailable: Please\
    \ use String directly\n            maxCount = word.characters.count\n        \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var max = \"\"\n    var maxCount\
    \ = 0\n    for word in words {\n        var count = 0\n        for char in word\
    \ {\n            if char == max {\n                count += 1\n            } else\
    \ {\n                count = 0\n            }\n            if count > maxCount\
    \ {\n                max = char\n                maxCount = count\n          \
    \  }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpybgntes_.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == max {\n\
    \               ~~~~ ^  ~~~\n/tmp/tmpybgntes_.swift:15:21: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n            if char == max {\n                    ^\n/tmp/tmpybgntes_.swift:21:23:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \      max = char\n                      ^~~~\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        if maxCount < word.characters.count\
    \ {\n            maxCount = word.characters.count\n            maxWord = word\n\
    \        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp5xon94e3.swift:13:28: error: 'characters' is unavailable: Please\
    \ use String directly\n        if maxCount < word.characters.count {\n       \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp5xon94e3.swift:14:29: error: 'characters' is unavailable: Please\
    \ use String directly\n            maxCount = word.characters.count\n        \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char.unicodeScalars.count > count {\n               \
    \ count = char.unicodeScalars.count\n            }\n        }\n        if count\
    \ > maxCount {\n            maxCount = count\n            maxWord = word\n   \
    \     }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpi8f6osb6/tmpi8f6osb6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae144c0fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae144906b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae144906988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae1449057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi8f6osb6                        0x000055cc6db7d84e <unavailable> + 6222

    5    libc.so.6                          0x00002ae144dfb460 __libc_start_main +
    245

    6    tmpi8f6osb6                        0x000055cc6db7d409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == char.lowercased() {\n                count +=\
    \ 1\n            }\n        }\n        if count > maxCount {\n            maxCount\
    \ = count\n            maxWord = word\n        }\n    }\n    return maxWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpr21lo869.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == char.lowercased()\
    \ {\n               ~~~~ ^  ~~~~~~~~~~~~~~~~~\n/tmp/tmpr21lo869.swift:15:21: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n            if char == char.lowercased() {\n \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == char.lowercased() {\n                count +=\
    \ 1\n            }\n        }\n        if count > maxCount {\n            maxCount\
    \ = count\n            maxWord = word\n        }\n    }\n    return maxWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpr21lo869.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == char.lowercased()\
    \ {\n               ~~~~ ^  ~~~~~~~~~~~~~~~~~\n/tmp/tmpr21lo869.swift:15:21: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n            if char == char.lowercased() {\n \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        if maxCount < word.characters.count\
    \ {\n            maxCount = word.characters.count\n            maxWord = word\n\
    \        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp5xon94e3.swift:13:28: error: 'characters' is unavailable: Please\
    \ use String directly\n        if maxCount < word.characters.count {\n       \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp5xon94e3.swift:14:29: error: 'characters' is unavailable: Please\
    \ use String directly\n            maxCount = word.characters.count\n        \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char.unicodeScalars.count > count {\n               \
    \ count = char.unicodeScalars.count\n            }\n        }\n        if count\
    \ > maxCount {\n            maxCount = count\n            maxWord = word\n   \
    \     }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpi8f6osb6/tmpi8f6osb6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae144c0fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae144906b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae144906988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae1449057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi8f6osb6                        0x000055cc6db7d84e <unavailable> + 6222

    5    libc.so.6                          0x00002ae144dfb460 __libc_start_main +
    245

    6    tmpi8f6osb6                        0x000055cc6db7d409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        if maxCount < word.characters.count\
    \ {\n            maxCount = word.characters.count\n            maxWord = word\n\
    \        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp5xon94e3.swift:13:28: error: 'characters' is unavailable: Please\
    \ use String directly\n        if maxCount < word.characters.count {\n       \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp5xon94e3.swift:14:29: error: 'characters' is unavailable: Please\
    \ use String directly\n            maxCount = word.characters.count\n        \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char.unicodeScalars.count > count {\n               \
    \ count = char.unicodeScalars.count\n            }\n        }\n        if count\
    \ > maxCount {\n            maxCount = count\n            maxWord = word\n   \
    \     }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpi8f6osb6/tmpi8f6osb6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae144c0fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae144906b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae144906988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae1449057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi8f6osb6                        0x000055cc6db7d84e <unavailable> + 6222

    5    libc.so.6                          0x00002ae144dfb460 __libc_start_main +
    245

    6    tmpi8f6osb6                        0x000055cc6db7d409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var max = \"\"\n    var maxCount\
    \ = 0\n    for word in words {\n        var count = 0\n        for char in word\
    \ {\n            if char == max {\n                count += 1\n            } else\
    \ {\n                count = 0\n            }\n            if count > maxCount\
    \ {\n                max = char\n                maxCount = count\n          \
    \  }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpybgntes_.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == max {\n\
    \               ~~~~ ^  ~~~\n/tmp/tmpybgntes_.swift:15:21: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n            if char == max {\n                    ^\n/tmp/tmpybgntes_.swift:21:23:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \      max = char\n                      ^~~~\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for c in word\
    \ {\n            if word.contains(c) {\n                count += 1\n         \
    \   }\n        }\n        if count > maxCount {\n            maxCount = count\n\
    \            maxWord = word\n        }\n    }\n    return maxWord\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmpjuu9m70u/tmpjuu9m70u.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b349f9c2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b349f6b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b349f6b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b349f6b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjuu9m70u                        0x0000560b37b73963 <unavailable> + 6499

    5    libc.so.6                          0x00002b349fbae460 __libc_start_main +
    245

    6    tmpjuu9m70u                        0x0000560b37b73389 <unavailable> + 5001

    '
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == char.lowercased() {\n                count +=\
    \ 1\n            }\n        }\n        if count > maxCount {\n            maxCount\
    \ = count\n            maxWord = word\n        }\n    }\n    return maxWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpr21lo869.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == char.lowercased()\
    \ {\n               ~~~~ ^  ~~~~~~~~~~~~~~~~~\n/tmp/tmpr21lo869.swift:15:21: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n            if char == char.lowercased() {\n \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == char.lowercased() {\n                count +=\
    \ 1\n            }\n        }\n        if count > maxCount {\n            maxCount\
    \ = count\n            maxWord = word\n        }\n    }\n    return maxWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpr21lo869.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == char.lowercased()\
    \ {\n               ~~~~ ^  ~~~~~~~~~~~~~~~~~\n/tmp/tmpr21lo869.swift:15:21: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n            if char == char.lowercased() {\n \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = countUniqueChars(word)\n\
    \        if count > maxCount {\n            maxCount = count\n            maxWord\
    \ = word\n        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpviw5165v.swift:13:21: error: cannot find 'countUniqueChars' in\
    \ scope\n        var count = countUniqueChars(word)\n                    ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = count_unique(word)\n  \
    \      if count > maxCount {\n            maxCount = count\n            maxWord\
    \ = word\n        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp880lvbls.swift:13:21: error: cannot find 'count_unique' in scope\n\
    \        var count = count_unique(word)\n                    ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        if maxCount < word.characters.count\
    \ {\n            maxCount = word.characters.count\n            maxWord = word\n\
    \        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp5xon94e3.swift:13:28: error: 'characters' is unavailable: Please\
    \ use String directly\n        if maxCount < word.characters.count {\n       \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp5xon94e3.swift:14:29: error: 'characters' is unavailable: Please\
    \ use String directly\n            maxCount = word.characters.count\n        \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == char.lowercased() {\n                count +=\
    \ 1\n            }\n        }\n        if count > maxCount {\n            maxCount\
    \ = count\n            maxWord = word\n        }\n    }\n    return maxWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpr21lo869.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == char.lowercased()\
    \ {\n               ~~~~ ^  ~~~~~~~~~~~~~~~~~\n/tmp/tmpr21lo869.swift:15:21: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n            if char == char.lowercased() {\n \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var max = \"\"\n    var maxCount\
    \ = 0\n    for word in words {\n        var count = 0\n        for char in word\
    \ {\n            if char == max {\n                count += 1\n            } else\
    \ {\n                count = 0\n            }\n            if count > maxCount\
    \ {\n                max = char\n                maxCount = count\n          \
    \  }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpybgntes_.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == max {\n\
    \               ~~~~ ^  ~~~\n/tmp/tmpybgntes_.swift:15:21: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n            if char == max {\n                    ^\n/tmp/tmpybgntes_.swift:21:23:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \      max = char\n                      ^~~~\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == ' ' {\n                continue\n           \
    \ }\n            count += 1\n        }\n        if count > maxCount {\n      \
    \      maxCount = count\n            maxWord = word\n        }\n    }\n    return\
    \ maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpc93q39wr.swift:15:24: error: single-quoted string literal found,\
    \ use '\"'\n            if char == ' ' {\n                       ^~~\n       \
    \                \" \"\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        if maxCount < word.characters.count\
    \ {\n            maxCount = word.characters.count\n            maxWord = word\n\
    \        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp5xon94e3.swift:13:28: error: 'characters' is unavailable: Please\
    \ use String directly\n        if maxCount < word.characters.count {\n       \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp5xon94e3.swift:14:29: error: 'characters' is unavailable: Please\
    \ use String directly\n            maxCount = word.characters.count\n        \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == ' ' {\n                continue\n           \
    \ }\n            if char.unicodeScalars.count > count {\n                count\
    \ = char.unicodeScalars.count\n            }\n        }\n        if count > maxCount\
    \ {\n            maxCount = count\n            maxWord = word\n        }\n   \
    \ }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpejh33hgq.swift:15:24: error: single-quoted string literal found,\
    \ use '\"'\n            if char == ' ' {\n                       ^~~\n       \
    \                \" \"\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var max = \"\"\n    var maxCount\
    \ = 0\n    for word in words {\n        var count = 0\n        for char in word\
    \ {\n            if char == max {\n                count += 1\n            } else\
    \ {\n                count = 0\n            }\n            if count > maxCount\
    \ {\n                max = char\n                maxCount = count\n          \
    \  }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpybgntes_.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == max {\n\
    \               ~~~~ ^  ~~~\n/tmp/tmpybgntes_.swift:15:21: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n            if char == max {\n                    ^\n/tmp/tmpybgntes_.swift:21:23:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \      max = char\n                      ^~~~\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == char.lowercased() {\n                count +=\
    \ 1\n            }\n        }\n        if count > maxCount {\n            maxCount\
    \ = count\n            maxWord = word\n        }\n    }\n    return maxWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpr21lo869.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == char.lowercased()\
    \ {\n               ~~~~ ^  ~~~~~~~~~~~~~~~~~\n/tmp/tmpr21lo869.swift:15:21: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n            if char == char.lowercased() {\n \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char.unicodeScalars.count > count {\n               \
    \ count = char.unicodeScalars.count\n            }\n        }\n        if count\
    \ > maxCount {\n            maxCount = count\n            maxWord = word\n   \
    \     }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpi8f6osb6/tmpi8f6osb6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae144c0fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae144906b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae144906988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae1449057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi8f6osb6                        0x000055cc6db7d84e <unavailable> + 6222

    5    libc.so.6                          0x00002ae144dfb460 __libc_start_main +
    245

    6    tmpi8f6osb6                        0x000055cc6db7d409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == char.lowercased() {\n                count +=\
    \ 1\n            }\n        }\n        if count > maxCount {\n            maxCount\
    \ = count\n            maxWord = word\n        }\n    }\n    return maxWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpr21lo869.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == char.lowercased()\
    \ {\n               ~~~~ ^  ~~~~~~~~~~~~~~~~~\n/tmp/tmpr21lo869.swift:15:21: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n            if char == char.lowercased() {\n \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for c in word\
    \ {\n            if c == maxWord {\n                count += 1\n            }\
    \ else {\n                if count > maxCount {\n                    maxCount\
    \ = count\n                    maxWord = word\n                }\n           \
    \     count = 0\n            }\n        }\n    }\n    return maxWord\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpvonwff92.swift:15:18: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if c == maxWord {\n\
    \               ~ ^  ~~~~~~~\n/tmp/tmpvonwff92.swift:15:18: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n            if c == maxWord {\n                 ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char != ' ' {\n                count += 1\n         \
    \   }\n        }\n        if count > maxCount {\n            maxCount = count\n\
    \            maxWord = word\n        }\n    }\n    return maxWord\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpu3q07ecb.swift:15:24: error: single-quoted string literal found,\
    \ use '\"'\n            if char != ' ' {\n                       ^~~\n       \
    \                \" \"\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char.unicodeScalars.count > count {\n               \
    \ count = char.unicodeScalars.count\n            }\n        }\n        if count\
    \ > maxCount {\n            maxCount = count\n            maxWord = word\n   \
    \     }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpi8f6osb6/tmpi8f6osb6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae144c0fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae144906b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae144906988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae1449057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi8f6osb6                        0x000055cc6db7d84e <unavailable> + 6222

    5    libc.so.6                          0x00002ae144dfb460 __libc_start_main +
    245

    6    tmpi8f6osb6                        0x000055cc6db7d409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        if maxCount < word.characters.count\
    \ {\n            maxCount = word.characters.count\n            maxWord = word\n\
    \        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp5xon94e3.swift:13:28: error: 'characters' is unavailable: Please\
    \ use String directly\n        if maxCount < word.characters.count {\n       \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp5xon94e3.swift:14:29: error: 'characters' is unavailable: Please\
    \ use String directly\n            maxCount = word.characters.count\n        \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == char.lowercased() {\n                count +=\
    \ 1\n            }\n        }\n        if count > maxCount {\n            maxCount\
    \ = count\n            maxWord = word\n        }\n    }\n    return maxWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpr21lo869.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == char.lowercased()\
    \ {\n               ~~~~ ^  ~~~~~~~~~~~~~~~~~\n/tmp/tmpr21lo869.swift:15:21: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n            if char == char.lowercased() {\n \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        if maxCount < word.characters.count\
    \ {\n            maxCount = word.characters.count\n            maxWord = word\n\
    \        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp5xon94e3.swift:13:28: error: 'characters' is unavailable: Please\
    \ use String directly\n        if maxCount < word.characters.count {\n       \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp5xon94e3.swift:14:29: error: 'characters' is unavailable: Please\
    \ use String directly\n            maxCount = word.characters.count\n        \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char.unicodeScalars.count > count {\n               \
    \ count = char.unicodeScalars.count\n            }\n        }\n        if count\
    \ > maxCount {\n            maxCount = count\n            maxWord = word\n   \
    \     }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpi8f6osb6/tmpi8f6osb6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae144c0fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae144906b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae144906988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae1449057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi8f6osb6                        0x000055cc6db7d84e <unavailable> + 6222

    5    libc.so.6                          0x00002ae144dfb460 __libc_start_main +
    245

    6    tmpi8f6osb6                        0x000055cc6db7d409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1660013562
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char.unicodeScalars.count > count {\n               \
    \ count = char.unicodeScalars.count\n            }\n        }\n        if count\
    \ > maxCount {\n            maxCount = count\n            maxWord = word\n   \
    \     }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpi8f6osb6/tmpi8f6osb6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae144c0fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae144906b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae144906988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae1449057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi8f6osb6                        0x000055cc6db7d84e <unavailable> + 6222

    5    libc.so.6                          0x00002ae144dfb460 __libc_start_main +
    245

    6    tmpi8f6osb6                        0x000055cc6db7d409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == char.lowercased() {\n                count +=\
    \ 1\n            }\n        }\n        if count > maxCount {\n            maxCount\
    \ = count\n            maxWord = word\n        }\n    }\n    return maxWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpr21lo869.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == char.lowercased()\
    \ {\n               ~~~~ ^  ~~~~~~~~~~~~~~~~~\n/tmp/tmpr21lo869.swift:15:21: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n            if char == char.lowercased() {\n \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for c in word\
    \ {\n            if word[count] == c {\n                count += 1\n         \
    \   }\n        }\n        if count > maxCount {\n            maxCount = count\n\
    \            maxWord = word\n        }\n    }\n    return maxWord\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmp8mhohx0n.swift:15:16: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n            if word[count]\
    \ == c {\n               ^~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        if word.characters.count > maxCount\
    \ {\n            maxCount = word.characters.count\n            maxWord = word\n\
    \        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpsbfiia9c.swift:13:17: error: 'characters' is unavailable: Please\
    \ use String directly\n        if word.characters.count > maxCount {\n       \
    \         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpsbfiia9c.swift:14:29:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ maxCount = word.characters.count\n                            ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        if maxCount < word.count {\n      \
    \      maxCount = word.count\n            maxWord = word\n        }\n    }\n \
    \   return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpa9idafv1/tmpa9idafv1.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba5f1d92c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba5f1a89b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba5f1a89988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5f1a887b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa9idafv1                        0x00005587771ad823 <unavailable> + 6179

    5    libc.so.6                          0x00002ba5f1f7e460 __libc_start_main +
    245

    6    tmpa9idafv1                        0x00005587771ad249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013562
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        if maxCount < word.count {\n      \
    \      maxCount = word.count\n            maxWord = word\n        }\n    }\n \
    \   return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpa9idafv1/tmpa9idafv1.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba5f1d92c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba5f1a89b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba5f1a89988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5f1a887b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa9idafv1                        0x00005587771ad823 <unavailable> + 6179

    5    libc.so.6                          0x00002ba5f1f7e460 __libc_start_main +
    245

    6    tmpa9idafv1                        0x00005587771ad249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == ' ' {\n                continue\n           \
    \ }\n            if char.unicodeScalars.count > count {\n                count\
    \ = char.unicodeScalars.count\n            }\n        }\n        if count > maxCount\
    \ {\n            maxCount = count\n            maxWord = word\n        }\n   \
    \ }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpejh33hgq.swift:15:24: error: single-quoted string literal found,\
    \ use '\"'\n            if char == ' ' {\n                       ^~~\n       \
    \                \" \"\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char != \" \" {\n                count += 1\n       \
    \     }\n        }\n        if count > maxCount {\n            maxCount = count\n\
    \            maxWord = word\n        }\n    }\n    return maxWord\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmpbsd5g534/tmpbsd5g534.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b385e13fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b385de36b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b385de36988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b385de357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbsd5g534                        0x0000559f7fc86973 <unavailable> + 6515

    5    libc.so.6                          0x00002b385e32b460 __libc_start_main +
    245

    6    tmpbsd5g534                        0x0000559f7fc86399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1660013562
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char.unicodeScalars.count > count {\n               \
    \ count = char.unicodeScalars.count\n            }\n        }\n        if count\
    \ > maxCount {\n            maxCount = count\n            maxWord = word\n   \
    \     }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpi8f6osb6/tmpi8f6osb6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae144c0fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae144906b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae144906988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae1449057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi8f6osb6                        0x000055cc6db7d84e <unavailable> + 6222

    5    libc.so.6                          0x00002ae144dfb460 __libc_start_main +
    245

    6    tmpi8f6osb6                        0x000055cc6db7d409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == ' ' {\n                count += 1\n         \
    \   } else {\n                count = 0\n            }\n            if count >\
    \ maxCount {\n                maxCount = count\n                maxWord = word\n\
    \            }\n        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpw9r2gq_u.swift:15:24: error: single-quoted string literal found,\
    \ use '\"'\n            if char == ' ' {\n                       ^~~\n       \
    \                \" \"\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == ' ' {\n                continue\n           \
    \ }\n            count += 1\n        }\n        if count > maxCount {\n      \
    \      maxCount = count\n            maxWord = word\n        }\n    }\n    return\
    \ maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpc93q39wr.swift:15:24: error: single-quoted string literal found,\
    \ use '\"'\n            if char == ' ' {\n                       ^~~\n       \
    \                \" \"\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char.unicodeScalars.count > count {\n               \
    \ count = char.unicodeScalars.count\n            }\n        }\n        if count\
    \ > maxCount {\n            maxCount = count\n            maxWord = word\n   \
    \     }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpi8f6osb6/tmpi8f6osb6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae144c0fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae144906b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae144906988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae1449057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi8f6osb6                        0x000055cc6db7d84e <unavailable> + 6222

    5    libc.so.6                          0x00002ae144dfb460 __libc_start_main +
    245

    6    tmpi8f6osb6                        0x000055cc6db7d409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char != ' ' {\n                count += 1\n         \
    \   }\n        }\n        if count > maxCount {\n            maxCount = count\n\
    \            maxWord = word\n        }\n    }\n    return maxWord\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpu3q07ecb.swift:15:24: error: single-quoted string literal found,\
    \ use '\"'\n            if char != ' ' {\n                       ^~~\n       \
    \                \" \"\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char != ' ' {\n                count += 1\n         \
    \   }\n        }\n        if count > maxCount {\n            maxCount = count\n\
    \            maxWord = word\n        }\n    }\n    return maxWord\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpu3q07ecb.swift:15:24: error: single-quoted string literal found,\
    \ use '\"'\n            if char != ' ' {\n                       ^~~\n       \
    \                \" \"\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var max = \"\"\n    var maxCount\
    \ = 0\n    for word in words {\n        var count = 0\n        for char in word\
    \ {\n            if char == max {\n                count += 1\n            } else\
    \ {\n                count = 0\n            }\n            if count > maxCount\
    \ {\n                max = char\n                maxCount = count\n          \
    \  }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpybgntes_.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == max {\n\
    \               ~~~~ ^  ~~~\n/tmp/tmpybgntes_.swift:15:21: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n            if char == max {\n                    ^\n/tmp/tmpybgntes_.swift:21:23:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \      max = char\n                      ^~~~\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char != ' ' {\n                count = count + 1\n  \
    \          }\n        }\n        if count > maxCount {\n            maxCount =\
    \ count\n            maxWord = word\n        }\n    }\n    return maxWord\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpbq3kkngs.swift:15:24: error: single-quoted string literal found,\
    \ use '\"'\n            if char != ' ' {\n                       ^~~\n       \
    \                \" \"\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == ' ' {\n                continue\n           \
    \ }\n            if char == maxWord {\n                count += 1\n          \
    \  } else {\n                count = 0\n            }\n            if count >\
    \ maxCount {\n                maxCount = count\n                maxWord = char\n\
    \            }\n        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmport6j44i.swift:15:24: error: single-quoted string literal found,\
    \ use '\"'\n            if char == ' ' {\n                       ^~~\n       \
    \                \" \"\n/tmp/tmport6j44i.swift:18:21: error: binary operator '=='\
    \ cannot be applied to operands of type 'Character' and 'String'\n           \
    \ if char == maxWord {\n               ~~~~ ^  ~~~~~~~\n/tmp/tmport6j44i.swift:18:21:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n            if char == maxWord {\n\
    \                    ^\n/tmp/tmport6j44i.swift:25:27: error: cannot assign value\
    \ of type 'Character' to type 'String'\n                maxWord = char\n     \
    \                     ^~~~\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        if maxCount < word.characters.count\
    \ {\n            maxCount = word.characters.count\n            maxWord = word\n\
    \        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp5xon94e3.swift:13:28: error: 'characters' is unavailable: Please\
    \ use String directly\n        if maxCount < word.characters.count {\n       \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp5xon94e3.swift:14:29: error: 'characters' is unavailable: Please\
    \ use String directly\n            maxCount = word.characters.count\n        \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == maxWord {\n                count += 1\n     \
    \       } else {\n                count = 0\n            }\n            if count\
    \ > maxCount {\n                maxCount = count\n                maxWord = char\n\
    \            }\n        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp6aee9b01.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == maxWord\
    \ {\n               ~~~~ ^  ~~~~~~~\n/tmp/tmp6aee9b01.swift:15:21: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n            if char == maxWord {\n                    ^\n\
    /tmp/tmp6aee9b01.swift:22:27: error: cannot assign value of type 'Character' to\
    \ type 'String'\n                maxWord = char\n                          ^~~~\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = word.characters.count\n\
    \        if count > maxCount {\n            maxCount = count\n            maxWord\
    \ = word\n        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpbd9z0vdh.swift:13:26: error: 'characters' is unavailable: Please\
    \ use String directly\n        var count = word.characters.count\n           \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpbd9z0vdh.swift:13:13: warning: variable 'count' was never mutated;\
    \ consider changing to 'let' constant\n        var count = word.characters.count\n\
    \        ~~~ ^\n        let\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var max = \"\"\n    var maxCount\
    \ = 0\n    for word in words {\n        var count = 0\n        for char in word\
    \ {\n            if char == max {\n                count += 1\n            } else\
    \ {\n                count = 0\n            }\n            if count > maxCount\
    \ {\n                max = char\n                maxCount = count\n          \
    \  }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpybgntes_.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == max {\n\
    \               ~~~~ ^  ~~~\n/tmp/tmpybgntes_.swift:15:21: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n            if char == max {\n                    ^\n/tmp/tmpybgntes_.swift:21:23:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \      max = char\n                      ^~~~\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = countUniqueChars(word)\n\
    \        if count > maxCount {\n            maxCount = count\n            maxWord\
    \ = word\n        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpviw5165v.swift:13:21: error: cannot find 'countUniqueChars' in\
    \ scope\n        var count = countUniqueChars(word)\n                    ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == char.lowercased() {\n                count +=\
    \ 1\n            }\n        }\n        if count > maxCount {\n            maxCount\
    \ = count\n            maxWord = word\n        }\n    }\n    return maxWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpr21lo869.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == char.lowercased()\
    \ {\n               ~~~~ ^  ~~~~~~~~~~~~~~~~~\n/tmp/tmpr21lo869.swift:15:21: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n            if char == char.lowercased() {\n \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char.unicodeScalars.count > count {\n               \
    \ count = char.unicodeScalars.count\n            }\n        }\n        if count\
    \ > maxCount {\n            maxCount = count\n            maxWord = word\n   \
    \     }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpi8f6osb6/tmpi8f6osb6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae144c0fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae144906b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae144906988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae1449057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi8f6osb6                        0x000055cc6db7d84e <unavailable> + 6222

    5    libc.so.6                          0x00002ae144dfb460 __libc_start_main +
    245

    6    tmpi8f6osb6                        0x000055cc6db7d409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var max = \"\"\n    var maxCount\
    \ = 0\n    for word in words {\n        var count = 0\n        for char in word\
    \ {\n            if char == max {\n                count += 1\n            } else\
    \ {\n                count = 0\n            }\n            if count > maxCount\
    \ {\n                max = char\n                maxCount = count\n          \
    \  }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpybgntes_.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == max {\n\
    \               ~~~~ ^  ~~~\n/tmp/tmpybgntes_.swift:15:21: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n            if char == max {\n                    ^\n/tmp/tmpybgntes_.swift:21:23:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \      max = char\n                      ^~~~\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for c in word\
    \ {\n            if word.contains(c) {\n                count += 1\n         \
    \   }\n        }\n        if count > maxCount {\n            maxCount = count\n\
    \            maxWord = word\n        }\n    }\n    return maxWord\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmpjuu9m70u/tmpjuu9m70u.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b349f9c2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b349f6b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b349f6b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b349f6b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjuu9m70u                        0x0000560b37b73963 <unavailable> + 6499

    5    libc.so.6                          0x00002b349fbae460 __libc_start_main +
    245

    6    tmpjuu9m70u                        0x0000560b37b73389 <unavailable> + 5001

    '
  stdout: ''
  timestamp: 1660013562
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char.unicodeScalars.isEmpty {\n                continue\n\
    \            }\n            count += char.unicodeScalars.count\n        }\n  \
    \      if count > maxCount {\n            maxCount = count\n            maxWord\
    \ = word\n        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: Exception
  stderr: 'tmp8_gc56ox/tmp8_gc56ox.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b305187fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3051576b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3051576988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b30515757b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8_gc56ox                        0x000055c488059a33 <unavailable> + 6707

    5    libc.so.6                          0x00002b3051a6b460 __libc_start_main +
    245

    6    tmp8_gc56ox                        0x000055c488059459 <unavailable> + 5209

    '
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var max = \"\"\n    var maxCount\
    \ = 0\n    for word in words {\n        var count = 0\n        for char in word\
    \ {\n            if char == max {\n                count += 1\n            } else\
    \ {\n                count = 0\n            }\n            if count > maxCount\
    \ {\n                max = char\n                maxCount = count\n          \
    \  }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpybgntes_.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == max {\n\
    \               ~~~~ ^  ~~~\n/tmp/tmpybgntes_.swift:15:21: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n            if char == max {\n                    ^\n/tmp/tmpybgntes_.swift:21:23:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \      max = char\n                      ^~~~\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char.unicodeScalars.count > count {\n               \
    \ count = char.unicodeScalars.count\n            }\n        }\n        if count\
    \ > maxCount {\n            maxCount = count\n            maxWord = word\n   \
    \     }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpi8f6osb6/tmpi8f6osb6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae144c0fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae144906b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae144906988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae1449057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi8f6osb6                        0x000055cc6db7d84e <unavailable> + 6222

    5    libc.so.6                          0x00002ae144dfb460 __libc_start_main +
    245

    6    tmpi8f6osb6                        0x000055cc6db7d409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == char.lowercased() {\n                count +=\
    \ 1\n            }\n        }\n        if count > maxCount {\n            maxCount\
    \ = count\n            maxWord = word\n        }\n    }\n    return maxWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpr21lo869.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == char.lowercased()\
    \ {\n               ~~~~ ^  ~~~~~~~~~~~~~~~~~\n/tmp/tmpr21lo869.swift:15:21: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n            if char == char.lowercased() {\n \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == ' ' {\n                continue\n           \
    \ }\n            count += 1\n        }\n        if count > maxCount {\n      \
    \      maxCount = count\n            maxWord = word\n        }\n    }\n    return\
    \ maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpc93q39wr.swift:15:24: error: single-quoted string literal found,\
    \ use '\"'\n            if char == ' ' {\n                       ^~~\n       \
    \                \" \"\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var max = \"\"\n    var maxCount\
    \ = 0\n    for word in words {\n        var count = 0\n        for char in word\
    \ {\n            if char == max {\n                count += 1\n            } else\
    \ {\n                count = 0\n            }\n            if count > maxCount\
    \ {\n                max = char\n                maxCount = count\n          \
    \  }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpybgntes_.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == max {\n\
    \               ~~~~ ^  ~~~\n/tmp/tmpybgntes_.swift:15:21: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n            if char == max {\n                    ^\n/tmp/tmpybgntes_.swift:21:23:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \      max = char\n                      ^~~~\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == char.lowercased() {\n                count +=\
    \ 1\n            }\n        }\n        if count > maxCount {\n            maxCount\
    \ = count\n            maxWord = word\n        }\n    }\n    return maxWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpr21lo869.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == char.lowercased()\
    \ {\n               ~~~~ ^  ~~~~~~~~~~~~~~~~~\n/tmp/tmpr21lo869.swift:15:21: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n            if char == char.lowercased() {\n \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == ' ' {\n                continue\n           \
    \ }\n            count += 1\n        }\n        if count > maxCount {\n      \
    \      maxCount = count\n            maxWord = word\n        }\n    }\n    return\
    \ maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpc93q39wr.swift:15:24: error: single-quoted string literal found,\
    \ use '\"'\n            if char == ' ' {\n                       ^~~\n       \
    \                \" \"\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == ' ' {\n                continue\n           \
    \ }\n            if char == maxWord {\n                count += 1\n          \
    \  } else {\n                count = 0\n            }\n            if count >\
    \ maxCount {\n                maxCount = count\n                maxWord = char\n\
    \            }\n        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmport6j44i.swift:15:24: error: single-quoted string literal found,\
    \ use '\"'\n            if char == ' ' {\n                       ^~~\n       \
    \                \" \"\n/tmp/tmport6j44i.swift:18:21: error: binary operator '=='\
    \ cannot be applied to operands of type 'Character' and 'String'\n           \
    \ if char == maxWord {\n               ~~~~ ^  ~~~~~~~\n/tmp/tmport6j44i.swift:18:21:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n            if char == maxWord {\n\
    \                    ^\n/tmp/tmport6j44i.swift:25:27: error: cannot assign value\
    \ of type 'Character' to type 'String'\n                maxWord = char\n     \
    \                     ^~~~\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        if maxCount < word.characters.count\
    \ {\n            maxCount = word.characters.count\n            maxWord = word\n\
    \        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp5xon94e3.swift:13:28: error: 'characters' is unavailable: Please\
    \ use String directly\n        if maxCount < word.characters.count {\n       \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp5xon94e3.swift:14:29: error: 'characters' is unavailable: Please\
    \ use String directly\n            maxCount = word.characters.count\n        \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var max = \"\"\n    var maxCount\
    \ = 0\n    for word in words {\n        if maxCount == 0 {\n            max =\
    \ word\n            maxCount = word.count\n        } else {\n            if word.count\
    \ > maxCount {\n                max = word\n                maxCount = word.count\n\
    \            }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: Exception
  stderr: 'tmpddqxwoii/tmpddqxwoii.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0757a17c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b075770eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b075770e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b075770d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpddqxwoii                        0x0000563a45049823 <unavailable> + 6179

    5    libc.so.6                          0x00002b0757c03460 __libc_start_main +
    245

    6    tmpddqxwoii                        0x0000563a45049249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for c in word\
    \ {\n            if c != ' ' {\n                count += 1\n            }\n  \
    \      }\n        if count > maxCount {\n            maxCount = count\n      \
    \      maxWord = word\n        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpyw31iq1i.swift:15:21: error: single-quoted string literal found,\
    \ use '\"'\n            if c != ' ' {\n                    ^~~\n             \
    \       \" \"\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char != ' ' {\n                count += 1\n         \
    \   }\n        }\n        if count > maxCount {\n            maxCount = count\n\
    \            maxWord = word\n        }\n    }\n    return maxWord\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpu3q07ecb.swift:15:24: error: single-quoted string literal found,\
    \ use '\"'\n            if char != ' ' {\n                       ^~~\n       \
    \                \" \"\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == ' ' {\n                continue\n           \
    \ }\n            count = count + 1\n            if count > maxCount {\n      \
    \          maxCount = count\n                maxWord = word\n            }\n \
    \       }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpbt3gy6n8.swift:15:24: error: single-quoted string literal found,\
    \ use '\"'\n            if char == ' ' {\n                       ^~~\n       \
    \                \" \"\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        if word.characters.count > maxCount\
    \ {\n            maxCount = word.characters.count\n            maxWord = word\n\
    \        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpsbfiia9c.swift:13:17: error: 'characters' is unavailable: Please\
    \ use String directly\n        if word.characters.count > maxCount {\n       \
    \         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpsbfiia9c.swift:14:29:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ maxCount = word.characters.count\n                            ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == char.lowercased() {\n                count +=\
    \ 1\n            }\n        }\n        if count > maxCount {\n            maxCount\
    \ = count\n            maxWord = word\n        }\n    }\n    return maxWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpr21lo869.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == char.lowercased()\
    \ {\n               ~~~~ ^  ~~~~~~~~~~~~~~~~~\n/tmp/tmpr21lo869.swift:15:21: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n            if char == char.lowercased() {\n \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == char.lowercased() {\n                count +=\
    \ 1\n            }\n        }\n        if count > maxCount {\n            maxCount\
    \ = count\n            maxWord = word\n        }\n    }\n    return maxWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpr21lo869.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == char.lowercased()\
    \ {\n               ~~~~ ^  ~~~~~~~~~~~~~~~~~\n/tmp/tmpr21lo869.swift:15:21: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n            if char == char.lowercased() {\n \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = word.characters.count\n\
    \        if count > maxCount {\n            maxCount = count\n            maxWord\
    \ = word\n        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpbd9z0vdh.swift:13:26: error: 'characters' is unavailable: Please\
    \ use String directly\n        var count = word.characters.count\n           \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpbd9z0vdh.swift:13:13: warning: variable 'count' was never mutated;\
    \ consider changing to 'let' constant\n        var count = word.characters.count\n\
    \        ~~~ ^\n        let\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for c in word\
    \ {\n            if word[word.startIndex.advancedBy(count)] != c {\n         \
    \       break\n            }\n            count += 1\n        }\n        if count\
    \ > maxCount {\n            maxCount = count\n            maxWord = word\n   \
    \     }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpx59a2zjz.swift:15:37: error: value of type 'String.Index' has no\
    \ member 'advancedBy'\n            if word[word.startIndex.advancedBy(count)]\
    \ != c {\n                    ~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == ' ' {\n                continue\n           \
    \ }\n            count += 1\n        }\n        if count > maxCount {\n      \
    \      maxCount = count\n            maxWord = word\n        }\n    }\n    return\
    \ maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpc93q39wr.swift:15:24: error: single-quoted string literal found,\
    \ use '\"'\n            if char == ' ' {\n                       ^~~\n       \
    \                \" \"\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == char.lowercased() {\n                count +=\
    \ 1\n            }\n        }\n        if count > maxCount {\n            maxCount\
    \ = count\n            maxWord = word\n        }\n    }\n    return maxWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpr21lo869.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == char.lowercased()\
    \ {\n               ~~~~ ^  ~~~~~~~~~~~~~~~~~\n/tmp/tmpr21lo869.swift:15:21: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n            if char == char.lowercased() {\n \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = word.characters.count\n\
    \        if count > maxCount {\n            maxCount = count\n            maxWord\
    \ = word\n        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpbd9z0vdh.swift:13:26: error: 'characters' is unavailable: Please\
    \ use String directly\n        var count = word.characters.count\n           \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpbd9z0vdh.swift:13:13: warning: variable 'count' was never mutated;\
    \ consider changing to 'let' constant\n        var count = word.characters.count\n\
    \        ~~~ ^\n        let\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char != ' ' {\n                count += 1\n         \
    \   }\n        }\n        if count > maxCount {\n            maxCount = count\n\
    \            maxWord = word\n        }\n    }\n    return maxWord\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpu3q07ecb.swift:15:24: error: single-quoted string literal found,\
    \ use '\"'\n            if char != ' ' {\n                       ^~~\n       \
    \                \" \"\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = word.characters.count\n\
    \        if count > maxCount {\n            maxCount = count\n            maxWord\
    \ = word\n        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpbd9z0vdh.swift:13:26: error: 'characters' is unavailable: Please\
    \ use String directly\n        var count = word.characters.count\n           \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpbd9z0vdh.swift:13:13: warning: variable 'count' was never mutated;\
    \ consider changing to 'let' constant\n        var count = word.characters.count\n\
    \        ~~~ ^\n        let\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var max = \"\"\n    var maxCount\
    \ = 0\n    for word in words {\n        var count = 0\n        for char in word\
    \ {\n            if char != max[count] {\n                max = char\n       \
    \         maxCount = count\n            }\n            count += 1\n        }\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpemzn0my4.swift:15:24: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n            if char\
    \ != max[count] {\n                       ^~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmpemzn0my4.swift:16:23: error:\
    \ cannot assign value of type 'Character' to type 'String'\n                max\
    \ = char\n                      ^~~~\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == char.lowercased() {\n                count +=\
    \ 1\n            }\n        }\n        if count > maxCount {\n            maxCount\
    \ = count\n            maxWord = word\n        }\n    }\n    return maxWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpr21lo869.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == char.lowercased()\
    \ {\n               ~~~~ ^  ~~~~~~~~~~~~~~~~~\n/tmp/tmpr21lo869.swift:15:21: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n            if char == char.lowercased() {\n \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char.unicodeScalars.count > count {\n               \
    \ count = char.unicodeScalars.count\n            }\n        }\n        if count\
    \ > maxCount {\n            maxCount = count\n            maxWord = word\n   \
    \     }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpi8f6osb6/tmpi8f6osb6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae144c0fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae144906b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae144906988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae1449057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi8f6osb6                        0x000055cc6db7d84e <unavailable> + 6222

    5    libc.so.6                          0x00002ae144dfb460 __libc_start_main +
    245

    6    tmpi8f6osb6                        0x000055cc6db7d409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var max = \"\"\n    var maxCount\
    \ = 0\n    for word in words {\n        var count = 0\n        for char in word\
    \ {\n            if char == max {\n                count += 1\n            } else\
    \ {\n                count = 0\n            }\n            if count > maxCount\
    \ {\n                max = char\n                maxCount = count\n          \
    \  }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpybgntes_.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == max {\n\
    \               ~~~~ ^  ~~~\n/tmp/tmpybgntes_.swift:15:21: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n            if char == max {\n                    ^\n/tmp/tmpybgntes_.swift:21:23:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \      max = char\n                      ^~~~\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var max = \"\"\n    var maxCount\
    \ = 0\n    for word in words {\n        var count = 0\n        for c in word {\n\
    \            if c != max[count] {\n                count++\n            }\n  \
    \      }\n        if count > maxCount {\n            max = word\n            maxCount\
    \ = count\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpl_x87oz1.swift:15:21: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n            if c\
    \ != max[count] {\n                    ^~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpl_x87oz1.swift:16:22: error: cannot\
    \ find operator '++' in scope; did you mean '+= 1'?\n                count++\n\
    \                     ^~\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == ' ' {\n                continue\n           \
    \ }\n            count = count + 1\n            if count > maxCount {\n      \
    \          maxCount = count\n                maxWord = word\n            }\n \
    \       }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpbt3gy6n8.swift:15:24: error: single-quoted string literal found,\
    \ use '\"'\n            if char == ' ' {\n                       ^~~\n       \
    \                \" \"\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var max = \"\"\n    var maxCount\
    \ = 0\n    for word in words {\n        var count = 0\n        for char in word\
    \ {\n            if char == max {\n                count += 1\n            } else\
    \ {\n                count = 0\n            }\n            if count > maxCount\
    \ {\n                max = char\n                maxCount = count\n          \
    \  }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpybgntes_.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == max {\n\
    \               ~~~~ ^  ~~~\n/tmp/tmpybgntes_.swift:15:21: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n            if char == max {\n                    ^\n/tmp/tmpybgntes_.swift:21:23:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \      max = char\n                      ^~~~\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == char.lowercased() {\n                count +=\
    \ 1\n            }\n        }\n        if count > maxCount {\n            maxCount\
    \ = count\n            maxWord = word\n        }\n    }\n    return maxWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpr21lo869.swift:15:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == char.lowercased()\
    \ {\n               ~~~~ ^  ~~~~~~~~~~~~~~~~~\n/tmp/tmpr21lo869.swift:15:21: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n            if char == char.lowercased() {\n \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: -4
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char != \" \" {\n                count += 1\n       \
    \     }\n        }\n        if count > maxCount {\n            maxCount = count\n\
    \            maxWord = word\n        }\n    }\n    return maxWord\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmpbsd5g534/tmpbsd5g534.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b385e13fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b385de36b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b385de36988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b385de357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbsd5g534                        0x0000559f7fc86973 <unavailable> + 6515

    5    libc.so.6                          0x00002b385e32b460 __libc_start_main +
    245

    6    tmpbsd5g534                        0x0000559f7fc86399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        if maxCount < word.characters.count\
    \ {\n            maxCount = word.characters.count\n            maxWord = word\n\
    \        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp5xon94e3.swift:13:28: error: 'characters' is unavailable: Please\
    \ use String directly\n        if maxCount < word.characters.count {\n       \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp5xon94e3.swift:14:29: error: 'characters' is unavailable: Please\
    \ use String directly\n            maxCount = word.characters.count\n        \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "\n/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    func find_max(words: [String]) -> String {\n    var maxCount = 0\n    var maxWord\
    \ = \"\"\n    for word in words {\n        var count = 0\n        for char in\
    \ word {\n            if char == ' ' {\n                continue\n           \
    \ }\n            count += 1\n            if count > maxCount {\n             \
    \   maxCount = count\n                maxWord = word\n            }\n        }\n\
    \    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpuzayv_x7.swift:15:24: error: single-quoted string literal found,\
    \ use '\"'\n            if char == ' ' {\n                       ^~~\n       \
    \                \" \"\n"
  stdout: ''
  timestamp: 1660013562
