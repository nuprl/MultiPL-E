language: swift
name: HumanEval_161_solve
results:
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case let c where c >= 'a' && c <= 'z':\n            result\
    \ += String(c).uppercased()\n        case let c where c >= 'A' && c <= 'Z':\n\
    \            result += String(c).lowercased()\n        default:\n            result\
    \ += char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpsq0a9a5p.swift:15:31: error: single-quoted string literal found,\
    \ use '\"'\n        case let c where c >= 'a' && c <= 'z':\n                 \
    \             ^~~\n                              \"a\"\n/tmp/tmpsq0a9a5p.swift:15:43:\
    \ error: single-quoted string literal found, use '\"'\n        case let c where\
    \ c >= 'a' && c <= 'z':\n                                          ^~~\n     \
    \                                     \"z\"\n/tmp/tmpsq0a9a5p.swift:17:31: error:\
    \ single-quoted string literal found, use '\"'\n        case let c where c >=\
    \ 'A' && c <= 'Z':\n                              ^~~\n                      \
    \        \"A\"\n/tmp/tmpsq0a9a5p.swift:17:43: error: single-quoted string literal\
    \ found, use '\"'\n        case let c where c >= 'A' && c <= 'Z':\n          \
    \                                ^~~\n                                       \
    \   \"Z\"\n/tmp/tmpsq0a9a5p.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpsq0a9a5p.swift:20:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case 'a':\n            result += \"A\"\n        case\
    \ 'b':\n            result += \"B\"\n        case 'c':\n            result +=\
    \ \"C\"\n        case 'd':\n            result += \"D\"\n        case 'e':\n \
    \           result += \"E\"\n        case 'f':\n            result += \"F\"\n\
    \        case 'g':\n            result += \"G\"\n        case 'h':\n         \
    \   result += \"H\"\n        case 'i':\n            result += \"I\"\n        case\
    \ 'j':\n            result += \"J\"\n        case 'k':\n            result +=\
    \ \"K\"\n        case 'l':\n            result += \"L\"\n        case 'm':\n \
    \           result += \"M\"\n        case 'n':\n            result += \"N\"\n\
    \        case 'o':\n            result += \"O\"\n        case 'p':\n         \
    \   result += \"P\"\n        case 'q':\n            result += \"Q\"\n        case\
    \ 'r':\n            result += \"R\"\n        case 's':\n            result +=\
    \ \"S\"\n        case 't':\n            result += \"T\"\n        case 'u':\n \
    \           result += \"U\"\n        case 'v':\n            result += \"V\"\n\
    \        case 'w':\n            result += \"W\"\n        case 'x':\n         \
    \   result += \"X\"\n        case 'y':\n            result += \"Y\"\n        case\
    \ 'z':\n            result += \"Z\"\n        default:\n            result += char\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpoj7_oy_r.swift:15:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpoj7_oy_r.swift:17:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmpoj7_oy_r.swift:19:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmpoj7_oy_r.swift:21:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmpoj7_oy_r.swift:23:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpoj7_oy_r.swift:25:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmpoj7_oy_r.swift:27:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmpoj7_oy_r.swift:29:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmpoj7_oy_r.swift:31:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmpoj7_oy_r.swift:33:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmpoj7_oy_r.swift:35:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmpoj7_oy_r.swift:37:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmpoj7_oy_r.swift:39:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmpoj7_oy_r.swift:41:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmpoj7_oy_r.swift:43:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmpoj7_oy_r.swift:45:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        switch char\
    \ {\n        case \"a\":\n            result = \"A\" + result\n        case \"\
    b\":\n            result = \"B\" + result\n        case \"c\":\n            result\
    \ = \"C\" + result\n        case \"d\":\n            result = \"D\" + result\n\
    \        case \"e\":\n            result = \"E\" + result\n        case \"f\"\
    :\n            result = \"F\" + result\n        case \"g\":\n            result\
    \ = \"G\" + result\n        case \"h\":\n            result = \"H\" + result\n\
    \        case \"i\":\n            result = \"I\" + result\n        case \"j\"\
    :\n            result = \"J\" + result\n        case \"k\":\n            result\
    \ = \"K\" + result\n        case \"l\":\n            result = \"L\" + result\n\
    \        case \"m\":\n            result = \"M\" + result\n        case \"n\"\
    :\n            result = \"N\" + result\n        case \"o\":\n            result\
    \ = \"O\" + result\n        case \"p\":\n            result = \"P\" + result\n\
    \        case \"q\":\n            result = \"Q\" + result\n        case \"r\"\
    :\n            result = \"R\" + result\n        case \"s\":\n            result\
    \ = \"S\" + result\n        case \"t\":\n            result = \"T\" + result\n\
    \        case \"u\":\n            result = \"U\" + result\n        case \"v\"\
    :\n            result = \"V\" + result\n        case \"w\":\n            result\
    \ = \"W\" + result\n        case \"x\":\n            result = \"X\" + result\n\
    \        case \"y\":\n            result = \"Y\" + result\n        case \"z\"\
    :\n            result = \"Z\" + result\n        default:\n            result =\
    \ char + result\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp1sq9tdg8.swift:68:22: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result = char + result\n   \
    \                  ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case 'a':\n            result += \"A\"\n        case\
    \ 'b':\n            result += \"b\"\n        case 'c':\n            result +=\
    \ \"C\"\n        case 'd':\n            result += \"d\"\n        case 'e':\n \
    \           result += \"E\"\n        case 'f':\n            result += \"f\"\n\
    \        case 'g':\n            result += \"g\"\n        case 'h':\n         \
    \   result += \"H\"\n        case 'i':\n            result += \"I\"\n        case\
    \ 'j':\n            result += \"J\"\n        case 'k':\n            result +=\
    \ \"K\"\n        case 'l':\n            result += \"L\"\n        case 'm':\n \
    \           result += \"m\"\n        case 'n':\n            result += \"N\"\n\
    \        case 'o':\n            result += \"O\"\n        case 'p':\n         \
    \   result += \"P\"\n        case 'q':\n            result += \"Q\"\n        case\
    \ 'r':\n            result += \"R\"\n        case 's':\n            result +=\
    \ \"S\"\n        case 't':\n            result += \"T\"\n        case 'u':\n \
    \           result += \"U\"\n        case 'v':\n            result += \"V\"\n\
    \        case 'w':\n            result += \"W\"\n        case 'x':\n         \
    \   result += \"X\"\n        case 'y':\n            result += \"Y\"\n        case\
    \ 'z':\n            result += \"Z\"\n        default:\n            result += char\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpb_tpj9y6.swift:15:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpb_tpj9y6.swift:17:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmpb_tpj9y6.swift:19:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmpb_tpj9y6.swift:21:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmpb_tpj9y6.swift:23:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpb_tpj9y6.swift:25:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmpb_tpj9y6.swift:27:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmpb_tpj9y6.swift:29:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmpb_tpj9y6.swift:31:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmpb_tpj9y6.swift:33:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmpb_tpj9y6.swift:35:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmpb_tpj9y6.swift:37:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmpb_tpj9y6.swift:39:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmpb_tpj9y6.swift:41:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmpb_tpj9y6.swift:43:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmpb_tpj9y6.swift:45:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            switch char.lowercased() {\n            case \"a\":\n       \
    \         result = \"A\"\n            case \"b\":\n                result = \"\
    b\"\n            case \"c\":\n                result = \"C\"\n            case\
    \ \"d\":\n                result = \"d\"\n            case \"e\":\n          \
    \      result = \"E\"\n            case \"f\":\n                result = \"f\"\
    \n            case \"g\":\n                result = \"G\"\n            case \"\
    h\":\n                result = \"H\"\n            case \"i\":\n              \
    \  result = \"I\"\n            case \"j\":\n                result = \"J\"\n \
    \           case \"k\":\n                result = \"K\"\n            case \"l\"\
    :\n                result = \"L\"\n            case \"m\":\n                result\
    \ = \"M\"\n            case \"n\":\n                result = \"N\"\n         \
    \   case \"o\":\n                result = \"O\"\n            case \"p\":\n   \
    \             result = \"P\"\n            case \"q\":\n                result\
    \ = \"Q\"\n            case \"r\":\n                result = \"R\"\n         \
    \   case \"s\":\n                result = \"S\"\n            case \"t\":\n   \
    \             result = \"T\"\n            case \"u\":\n                result\
    \ = \"U\"\n            case \"v\":\n                result = \"V\"\n         \
    \   case \"w\":\n                result = \"W\"\n            case \"x\":\n   \
    \             result = \"X\"\n            case \"y\":\n                result\
    \ = \"Y\"\n            case \"z\":\n                result = \"Z\"\n         \
    \   default:\n                result = \"\\(char)\".uppercased()\n           \
    \ }\n        } else {\n            result = \"\\(char)\".lowercased()\n      \
    \  }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s:\
    \ \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpsgo2fsv_.swift:14:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    return s.characters.reversed().reduce(\"\") { $0 + String($1)\
    \ + String($2) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp8mjtn441.swift:12:12: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n    return s.characters.reversed().reduce(\"\") { $0 + String($1)\
    \ + String($2) }\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659825115
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    return s.characters.reversed().reduce(\"\") { $0 + String($1)\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpm03cykjf.swift:12:14: error: 'characters' is unavailable: Please\
    \ use String directly\n    return s.characters.reversed().reduce(\"\") { $0 +\
    \ String($1) }\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case 'a':\n            result += \"A\"\n        case\
    \ 'b':\n            result += \"b\"\n        case 'c':\n            result +=\
    \ \"C\"\n        case 'd':\n            result += \"d\"\n        case 'e':\n \
    \           result += \"E\"\n        case 'f':\n            result += \"f\"\n\
    \        case 'g':\n            result += \"G\"\n        case 'h':\n         \
    \   result += \"H\"\n        case 'i':\n            result += \"I\"\n        case\
    \ 'j':\n            result += \"J\"\n        case 'k':\n            result +=\
    \ \"K\"\n        case 'l':\n            result += \"L\"\n        case 'm':\n \
    \           result += \"m\"\n        case 'n':\n            result += \"N\"\n\
    \        case 'o':\n            result += \"O\"\n        case 'p':\n         \
    \   result += \"P\"\n        case 'q':\n            result += \"Q\"\n        case\
    \ 'r':\n            result += \"R\"\n        case 's':\n            result +=\
    \ \"S\"\n        case 't':\n            result += \"T\"\n        case 'u':\n \
    \           result += \"U\"\n        case 'v':\n            result += \"V\"\n\
    \        case 'w':\n            result += \"W\"\n        case 'x':\n         \
    \   result += \"X\"\n        case 'y':\n            result += \"Y\"\n        case\
    \ 'z':\n            result += \"Z\"\n        default:\n            result += char\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp1linqd6_.swift:15:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmp1linqd6_.swift:17:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmp1linqd6_.swift:19:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmp1linqd6_.swift:21:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmp1linqd6_.swift:23:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmp1linqd6_.swift:25:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmp1linqd6_.swift:27:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmp1linqd6_.swift:29:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmp1linqd6_.swift:31:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmp1linqd6_.swift:33:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmp1linqd6_.swift:35:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmp1linqd6_.swift:37:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmp1linqd6_.swift:39:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmp1linqd6_.swift:41:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmp1linqd6_.swift:43:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmp1linqd6_.swift:45:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    return s.characters.reduce(\"\") { $0 + String($1) }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpg6vefuyv.swift:12:14: error: 'characters' is unavailable: Please\
    \ use String directly\n    return s.characters.reduce(\"\") { $0 + String($1)\
    \ }\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case 'a':\n            result += \"A\"\n        case\
    \ 'b':\n            result += \"b\"\n        case 'c':\n            result +=\
    \ \"C\"\n        case 'd':\n            result += \"D\"\n        case 'e':\n \
    \           result += \"E\"\n        case 'f':\n            result += \"F\"\n\
    \        case 'g':\n            result += \"G\"\n        case 'h':\n         \
    \   result += \"H\"\n        case 'i':\n            result += \"I\"\n        case\
    \ 'j':\n            result += \"J\"\n        case 'k':\n            result +=\
    \ \"K\"\n        case 'l':\n            result += \"L\"\n        case 'm':\n \
    \           result += \"M\"\n        case 'n':\n            result += \"N\"\n\
    \        case 'o':\n            result += \"O\"\n        case 'p':\n         \
    \   result += \"P\"\n        case 'q':\n            result += \"Q\"\n        case\
    \ 'r':\n            result += \"R\"\n        case 's':\n            result +=\
    \ \"S\"\n        case 't':\n            result += \"T\"\n        case 'u':\n \
    \           result += \"U\"\n        case 'v':\n            result += \"V\"\n\
    \        case 'w':\n            result += \"W\"\n        case 'x':\n         \
    \   result += \"X\"\n        case 'y':\n            result += \"Y\"\n        case\
    \ 'z':\n            result += \"Z\"\n        default:\n            result += char\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpbdfznpt6.swift:15:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpbdfznpt6.swift:17:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmpbdfznpt6.swift:19:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmpbdfznpt6.swift:21:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmpbdfznpt6.swift:23:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpbdfznpt6.swift:25:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmpbdfznpt6.swift:27:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmpbdfznpt6.swift:29:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmpbdfznpt6.swift:31:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmpbdfznpt6.swift:33:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmpbdfznpt6.swift:35:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmpbdfznpt6.swift:37:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmpbdfznpt6.swift:39:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmpbdfznpt6.swift:41:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmpbdfznpt6.swift:43:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmpbdfznpt6.swift:45:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            switch char.unicodeScalars.lowerCase.unicodeScalars.rawValue\
    \ {\n            case 0x41:\n                result += \"A\"\n            case\
    \ 0x42:\n                result += \"B\"\n            case 0x43:\n           \
    \     result += \"C\"\n            case 0x44:\n                result += \"D\"\
    \n            case 0x45:\n                result += \"E\"\n            case 0x46:\n\
    \                result += \"F\"\n            case 0x47:\n                result\
    \ += \"G\"\n            case 0x48:\n                result += \"H\"\n        \
    \    case 0x49:\n                result += \"I\"\n            case 0x4A:\n   \
    \             result += \"J\"\n            case 0x4B:\n                result\
    \ += \"K\"\n            case 0x4C:\n                result += \"L\"\n        \
    \    case 0x4D:\n                result += \"M\"\n            case 0x4E:\n   \
    \             result += \"N\"\n            case 0x4F:\n                result\
    \ += \"O\"\n            case 0x50:\n                result += \"P\"\n        \
    \    case 0x51:\n                result += \"Q\"\n            case 0x52:\n   \
    \             result += \"R\"\n            case 0x53:\n                result\
    \ += \"S\"\n            case 0x54:\n                result += \"T\"\n        \
    \    case 0x55:\n                result += \"U\"\n            case 0x56:\n   \
    \             result += \"V\"\n            case 0x57:\n                result\
    \ += \"W\"\n            case 0x58:\n                result += \"X\"\n        \
    \    case 0x59:\n                result += \"Y\"\n            case 0x5A:\n   \
    \             result += \"Z\"\n            default:\n                result +=\
    \ char\n            }\n        } else {\n            result += char\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpx2u3diny.swift:14:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpx2u3diny.swift:15:40: error: value of type 'Character.UnicodeScalarView'\
    \ (aka 'String.UnicodeScalarView') has no member 'lowerCase'\n            switch\
    \ char.unicodeScalars.lowerCase.unicodeScalars.rawValue {\n                  \
    \ ~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~\n/tmp/tmpx2u3diny.swift:69:27: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n             \
    \   result += char\n                          ^\n/tmp/tmpx2u3diny.swift:72:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case 'a':\n            result += \"A\"\n        case\
    \ 'b':\n            result += \"b\"\n        case 'c':\n            result +=\
    \ \"C\"\n        case 'd':\n            result += \"d\"\n        case 'e':\n \
    \           result += \"E\"\n        case 'f':\n            result += \"f\"\n\
    \        case 'g':\n            result += \"G\"\n        case 'h':\n         \
    \   result += \"h\"\n        case 'i':\n            result += \"I\"\n        case\
    \ 'j':\n            result += \"j\"\n        case 'k':\n            result +=\
    \ \"K\"\n        case 'l':\n            result += \"L\"\n        case 'm':\n \
    \           result += \"m\"\n        case 'n':\n            result += \"N\"\n\
    \        case 'o':\n            result += \"O\"\n        case 'p':\n         \
    \   result += \"P\"\n        case 'q':\n            result += \"Q\"\n        case\
    \ 'r':\n            result += \"r\"\n        case 's':\n            result +=\
    \ \"S\"\n        case 't':\n            result += \"T\"\n        case 'u':\n \
    \           result += \"U\"\n        case 'v':\n            result += \"V\"\n\
    \        case 'w':\n            result += \"W\"\n        case 'x':\n         \
    \   result += \"X\"\n        case 'y':\n            result += \"Y\"\n        case\
    \ 'z':\n            result += \"Z\"\n        default:\n            result += char\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpxlxr8o2s.swift:15:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpxlxr8o2s.swift:17:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmpxlxr8o2s.swift:19:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmpxlxr8o2s.swift:21:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmpxlxr8o2s.swift:23:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpxlxr8o2s.swift:25:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmpxlxr8o2s.swift:27:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmpxlxr8o2s.swift:29:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmpxlxr8o2s.swift:31:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmpxlxr8o2s.swift:33:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmpxlxr8o2s.swift:35:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmpxlxr8o2s.swift:37:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmpxlxr8o2s.swift:39:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmpxlxr8o2s.swift:41:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmpxlxr8o2s.swift:43:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmpxlxr8o2s.swift:45:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    return s.characters.reduce(\"\") { $0 + String($1) + String($2)\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp1ao54lw7.swift:12:36: error: contextual closure type '(String,\
    \ String.Element) throws -> String' (aka '(String, Character) throws -> String')\
    \ expects 2 arguments, but 3 were used in closure body\n    return s.characters.reduce(\"\
    \") { $0 + String($1) + String($2) }\n                                   ^\n"
  stdout: ''
  timestamp: 1659825098
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            let upperCase = char.uppercased()\n            if upperCase ==\
    \ char {\n                result += char\n            } else {\n             \
    \   result += upperCase\n            }\n        } else {\n            result +=\
    \ char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpx06pi7og.swift:14:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpx06pi7og.swift:16:26: error: binary operator '=='\
    \ cannot be applied to operands of type 'String' and 'Character'\n           \
    \ if upperCase == char {\n               ~~~~~~~~~ ^  ~~~~\n/tmp/tmpx06pi7og.swift:16:26:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n            if upperCase == char {\n\
    \                         ^\n/tmp/tmpx06pi7og.swift:17:27: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n             \
    \   result += char\n                          ^\n/tmp/tmpx06pi7og.swift:22:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case 'a':\n            result += \"A\"\n        case\
    \ 'b':\n            result += \"b\"\n        case 'c':\n            result +=\
    \ \"C\"\n        case 'd':\n            result += \"d\"\n        case 'e':\n \
    \           result += \"E\"\n        case 'f':\n            result += \"f\"\n\
    \        case 'g':\n            result += \"G\"\n        case 'h':\n         \
    \   result += \"H\"\n        case 'i':\n            result += \"I\"\n        case\
    \ 'j':\n            result += \"J\"\n        case 'k':\n            result +=\
    \ \"K\"\n        case 'l':\n            result += \"L\"\n        case 'm':\n \
    \           result += \"m\"\n        case 'n':\n            result += \"N\"\n\
    \        case 'o':\n            result += \"O\"\n        case 'p':\n         \
    \   result += \"P\"\n        case 'q':\n            result += \"Q\"\n        case\
    \ 'r':\n            result += \"R\"\n        case 's':\n            result +=\
    \ \"S\"\n        case 't':\n            result += \"T\"\n        case 'u':\n \
    \           result += \"U\"\n        case 'v':\n            result += \"V\"\n\
    \        case 'w':\n            result += \"W\"\n        case 'x':\n         \
    \   result += \"X\"\n        case 'y':\n            result += \"Y\"\n        case\
    \ 'z':\n            result += \"Z\"\n        default:\n            result += char\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp1linqd6_.swift:15:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmp1linqd6_.swift:17:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmp1linqd6_.swift:19:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmp1linqd6_.swift:21:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmp1linqd6_.swift:23:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmp1linqd6_.swift:25:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmp1linqd6_.swift:27:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmp1linqd6_.swift:29:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmp1linqd6_.swift:31:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmp1linqd6_.swift:33:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmp1linqd6_.swift:35:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmp1linqd6_.swift:37:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmp1linqd6_.swift:39:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmp1linqd6_.swift:41:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmp1linqd6_.swift:43:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmp1linqd6_.swift:45:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            switch char.lowercased() {\n            case \"a\":\n       \
    \         result += \"A\"\n            case \"b\":\n                result +=\
    \ \"b\"\n            case \"c\":\n                result += \"C\"\n          \
    \  case \"d\":\n                result += \"d\"\n            case \"e\":\n   \
    \             result += \"E\"\n            case \"f\":\n                result\
    \ += \"f\"\n            case \"g\":\n                result += \"G\"\n       \
    \     case \"h\":\n                result += \"h\"\n            case \"i\":\n\
    \                result += \"I\"\n            case \"j\":\n                result\
    \ += \"j\"\n            case \"k\":\n                result += \"K\"\n       \
    \     case \"l\":\n                result += \"L\"\n            case \"m\":\n\
    \                result += \"m\"\n            case \"n\":\n                result\
    \ += \"N\"\n            case \"o\":\n                result += \"O\"\n       \
    \     case \"p\":\n                result += \"p\"\n            case \"q\":\n\
    \                result += \"Q\"\n            case \"r\":\n                result\
    \ += \"r\"\n            case \"s\":\n                result += \"S\"\n       \
    \     case \"t\":\n                result += \"T\"\n            case \"u\":\n\
    \                result += \"U\"\n            case \"v\":\n                result\
    \ += \"v\"\n            case \"w\":\n                result += \"W\"\n       \
    \     case \"x\":\n                result += \"x\"\n            case \"y\":\n\
    \                result += \"Y\"\n            case \"z\":\n                result\
    \ += \"z\"\n            default:\n                result += char\n           \
    \ }\n        } else {\n            result += char\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp0ce6jt7c.swift:14:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmp0ce6jt7c.swift:69:27: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n                result\
    \ += char\n                          ^\n/tmp/tmp0ce6jt7c.swift:72:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    return s.characters.reversed().reduce(\"\") { $0 + String($1)\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpm03cykjf.swift:12:14: error: 'characters' is unavailable: Please\
    \ use String directly\n    return s.characters.reversed().reduce(\"\") { $0 +\
    \ String($1) }\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ if char.isLetter {\n            switch char.lowercaseString {\n            case\
    \ \"a\":\n                result += \"A\"\n            case \"b\":\n         \
    \       result += \"b\"\n            case \"c\":\n                result += \"\
    C\"\n            case \"d\":\n                result += \"D\"\n            case\
    \ \"e\":\n                result += \"E\"\n            case \"f\":\n         \
    \       result += \"F\"\n            case \"g\":\n                result += \"\
    G\"\n            case \"h\":\n                result += \"H\"\n            case\
    \ \"i\":\n                result += \"I\"\n            case \"j\":\n         \
    \       result += \"J\"\n            case \"k\":\n                result += \"\
    K\"\n            case \"l\":\n                result += \"L\"\n            case\
    \ \"m\":\n                result += \"M\"\n            case \"n\":\n         \
    \       result += \"N\"\n            case \"o\":\n                result += \"\
    O\"\n            case \"p\":\n                result += \"P\"\n            case\
    \ \"q\":\n                result += \"Q\"\n            case \"r\":\n         \
    \       result += \"R\"\n            case \"s\":\n                result += \"\
    S\"\n            case \"t\":\n                result += \"T\"\n            case\
    \ \"u\":\n                result += \"U\"\n            case \"v\":\n         \
    \       result += \"V\"\n            case \"w\":\n                result += \"\
    W\"\n            case \"x\":\n                result += \"X\"\n            case\
    \ \"y\":\n                result += \"Y\"\n            case \"z\":\n         \
    \       result += \"Z\"\n            default:\n                result += char.lowercaseString\n\
    \            }\n        } else {\n            result += char\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmphp_7i_zr.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmphp_7i_zr.swift:15:25:\
    \ error: value of type 'Character' has no member 'lowercaseString'\n         \
    \   switch char.lowercaseString {\n                   ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmphp_7i_zr.swift:69:32:\
    \ error: value of type 'Character' has no member 'lowercaseString'\n         \
    \       result += char.lowercaseString\n                          ~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmphp_7i_zr.swift:72:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        switch char\
    \ {\n        case \"a\":\n        case \"b\":\n        case \"c\":\n        case\
    \ \"d\":\n        case \"e\":\n        case \"f\":\n        case \"g\":\n    \
    \    case \"h\":\n        case \"i\":\n        case \"j\":\n        case \"k\"\
    :\n        case \"l\":\n        case \"m\":\n        case \"n\":\n        case\
    \ \"o\":\n        case \"p\":\n        case \"q\":\n        case \"r\":\n    \
    \    case \"s\":\n        case \"t\":\n        case \"u\":\n        case \"v\"\
    :\n        case \"w\":\n        case \"x\":\n        case \"y\":\n        case\
    \ \"z\":\n        case \"A\":\n        case \"B\":\n        case \"C\":\n    \
    \    case \"D\":\n        case \"E\":\n        case \"F\":\n        case \"G\"\
    :\n        case \"H\":\n        case \"I\":\n        case \"J\":\n        case\
    \ \"K\":\n        case \"L\":\n        case \"M\":\n        case \"N\":\n    \
    \    case \"O\":\n        case \"P\":\n        case \"Q\":\n        case \"R\"\
    :\n        case \"S\":\n        case \"T\":\n        case \"U\":\n        case\
    \ \"V\":\n        case \"W\":\n        case \"X\":\n        case \"Y\":\n    \
    \    case \"Z\":\n        case \"0\":\n        case \"1\":\n        case \"2\"\
    :\n        case \"3\":\n        case \"4\":\n        case \"5\":\n        case\
    \ \"6\":\n        case \"7\":\n        case \"8\":\n        case \"9\":\n    \
    \    case \"@\":\n        case \"#\":\n        case \"$\":\n        case \"%\"\
    :\n        case \"^\":\n        case \"&\":\n        case \"*\":\n        case\
    \ \"(\":\n        case \")\":\n        case \"-\":\n        case \"_\":\n    \
    \    case \"+\":\n        case \"=\":\n        case \"{\":\n        case \"}\"\
    :\n        case \"[\":\n        case \"]\":\n        case \"\\\\\":\n        case\
    \ \"|\":\n        case \"<\":\n        case \">\":\n        case \"?\":\n    \
    \    case \"/\":\n        case \"\\\\\":\n        case \"|\":\n        case \"\
    \\\"\":\n        case \"'\":\n        case \"<\":\n        case \"=\":\n     \
    \   case \"!\":\n        case \"`\":\n        case \"~\":\n        case \"`\"\
    :\n        case \"~\":\n        case \"`\":\n        case \"~\":\n        case\
    \ \"`\":\n        case \"~\":\n        case \"`\":\n        case \"~\":\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpd18q4yh4.swift:15:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"a\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpd18q4yh4.swift:16:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"b\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmpd18q4yh4.swift:17:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"c\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpd18q4yh4.swift:18:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"d\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpd18q4yh4.swift:19:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"e\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpd18q4yh4.swift:20:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"f\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpd18q4yh4.swift:21:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"g\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpd18q4yh4.swift:22:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"h\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpd18q4yh4.swift:23:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"i\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpd18q4yh4.swift:24:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"j\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpd18q4yh4.swift:25:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"k\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpd18q4yh4.swift:26:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"l\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpd18q4yh4.swift:27:9:\
    \ error: 'case' l"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            let upper = char.uppercased()\n            let lower = char.lowercased()\n\
    \            if upper != lower  {\n                result += upper\n         \
    \   } else {\n                result += lower\n            }\n        } else {\n\
    \            result += char\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpd0m2tj3i.swift:14:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpd0m2tj3i.swift:23:23: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n            result +=\
    \ char\n                      ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case 'a':\n            result += \"A\"\n        case\
    \ 'b':\n            result += \"b\"\n        case 'c':\n            result +=\
    \ \"C\"\n        case 'd':\n            result += \"d\"\n        case 'e':\n \
    \           result += \"E\"\n        case 'f':\n            result += \"f\"\n\
    \        case 'g':\n            result += \"G\"\n        case 'h':\n         \
    \   result += \"H\"\n        case 'i':\n            result += \"I\"\n        case\
    \ 'j':\n            result += \"J\"\n        case 'k':\n            result +=\
    \ \"K\"\n        case 'l':\n            result += \"L\"\n        case 'm':\n \
    \           result += \"M\"\n        case 'n':\n            result += \"N\"\n\
    \        case 'o':\n            result += \"O\"\n        case 'p':\n         \
    \   result += \"P\"\n        case 'q':\n            result += \"Q\"\n        case\
    \ 'r':\n            result += \"R\"\n        case 's':\n            result +=\
    \ \"S\"\n        case 't':\n            result += \"T\"\n        case 'u':\n \
    \           result += \"U\"\n        case 'v':\n            result += \"V\"\n\
    \        case 'w':\n            result += \"W\"\n        case 'x':\n         \
    \   result += \"X\"\n        case 'y':\n            result += \"Y\"\n        case\
    \ 'z':\n            result += \"Z\"\n        default:\n            result += char\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpwzlievm8.swift:15:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpwzlievm8.swift:17:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmpwzlievm8.swift:19:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmpwzlievm8.swift:21:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmpwzlievm8.swift:23:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpwzlievm8.swift:25:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmpwzlievm8.swift:27:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmpwzlievm8.swift:29:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmpwzlievm8.swift:31:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmpwzlievm8.swift:33:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmpwzlievm8.swift:35:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmpwzlievm8.swift:37:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmpwzlievm8.swift:39:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmpwzlievm8.swift:41:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmpwzlievm8.swift:43:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmpwzlievm8.swift:45:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    return s.characters.reversed().reduce(\"\") { $0 + String($1)\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpm03cykjf.swift:12:14: error: 'characters' is unavailable: Please\
    \ use String directly\n    return s.characters.reversed().reduce(\"\") { $0 +\
    \ String($1) }\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    return s.characters.reversed().reduce(\"\") { $0 + String($1)\
    \ + String($2) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp8mjtn441.swift:12:12: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n    return s.characters.reversed().reduce(\"\") { $0 + String($1)\
    \ + String($2) }\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659825115
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            let upperCase = char.uppercased()\n            let lowerCase\
    \ = char.lowercased()\n            if upperCase == lowerCase {\n             \
    \   result += upperCase\n            } else {\n                result += lowerCase\n\
    \            }\n        } else {\n            result += char\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpjbrvys6z.swift:14:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpjbrvys6z.swift:23:23: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n            result +=\
    \ char\n                      ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ if char.isLetter() {\n            switch char.lowercased() {\n            case\
    \ \"a\": result = \"A\" + result\n            case \"b\": result = \"B\" + result\n\
    \            case \"c\": result = \"C\" + result\n            case \"d\": result\
    \ = \"D\" + result\n            case \"e\": result = \"E\" + result\n        \
    \    case \"f\": result = \"F\" + result\n            case \"g\": result = \"\
    G\" + result\n            case \"h\": result = \"H\" + result\n            case\
    \ \"i\": result = \"I\" + result\n            case \"j\": result = \"J\" + result\n\
    \            case \"k\": result = \"K\" + result\n            case \"l\": result\
    \ = \"L\" + result\n            case \"m\": result = \"M\" + result\n        \
    \    case \"n\": result = \"N\" + result\n            case \"o\": result = \"\
    O\" + result\n            case \"p\": result = \"P\" + result\n            case\
    \ \"q\": result = \"Q\" + result\n            case \"r\": result = \"R\" + result\n\
    \            case \"s\": result = \"S\" + result\n            case \"t\": result\
    \ = \"T\" + result\n            case \"u\": result = \"U\" + result\n        \
    \    case \"v\": result = \"V\" + result\n            case \"w\": result = \"\
    W\" + result\n            case \"x\": result = \"X\" + result\n            case\
    \ \"y\": result = \"Y\" + result\n            case \"z\": result = \"Z\" + result\n\
    \            default: result = \"\\(char)\" + result\n            }\n        }\
    \ else {\n            result = \"\\(char)\" + result\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp4k2n03fw.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp4k2n03fw.swift:14:17:\
    \ error: cannot call value of non-function type 'Bool'\n        if char.isLetter()\
    \ {\n                ^       ~~\n                        \n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    return s.characters.reduce(\"\") { $0 + String($1) }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpg6vefuyv.swift:12:14: error: 'characters' is unavailable: Please\
    \ use String directly\n    return s.characters.reduce(\"\") { $0 + String($1)\
    \ }\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            switch char.lowercased() {\n            case \"a\":\n       \
    \         result += \"A\"\n            case \"b\":\n                result +=\
    \ \"b\"\n            case \"c\":\n                result += \"C\"\n          \
    \  case \"d\":\n                result += \"d\"\n            case \"e\":\n   \
    \             result += \"E\"\n            case \"f\":\n                result\
    \ += \"f\"\n            case \"g\":\n                result += \"G\"\n       \
    \     case \"h\":\n                result += \"H\"\n            case \"i\":\n\
    \                result += \"I\"\n            case \"j\":\n                result\
    \ += \"J\"\n            case \"k\":\n                result += \"K\"\n       \
    \     case \"l\":\n                result += \"L\"\n            case \"m\":\n\
    \                result += \"m\"\n            case \"n\":\n                result\
    \ += \"N\"\n            case \"o\":\n                result += \"O\"\n       \
    \     case \"p\":\n                result += \"P\"\n            case \"q\":\n\
    \                result += \"Q\"\n            case \"r\":\n                result\
    \ += \"R\"\n            case \"s\":\n                result += \"S\"\n       \
    \     case \"t\":\n                result += \"T\"\n            case \"u\":\n\
    \                result += \"U\"\n            case \"v\":\n                result\
    \ += \"V\"\n            case \"w\":\n                result += \"W\"\n       \
    \     case \"x\":\n                result += \"X\"\n            case \"y\":\n\
    \                result += \"Y\"\n            case \"z\":\n                result\
    \ += \"Z\"\n            default:\n                result += char\n           \
    \ }\n        } else {\n            result += char\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp0uarv2i4.swift:14:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmp0uarv2i4.swift:69:27: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n                result\
    \ += char\n                          ^\n/tmp/tmp0uarv2i4.swift:72:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ if char.isLetter {\n            switch char.caseInsensitiveCompare(Character(\"\
    A\")) {\n            case .orderedSame, .orderedAscending:\n                result\
    \ += Character(\"a\")\n            case .orderedDescending:\n                result\
    \ += Character(\"A\")\n            }\n        } else {\n            result +=\
    \ char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp06xr6ig1.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp06xr6ig1.swift:15:25:\
    \ error: value of type 'Character' has no member 'caseInsensitiveCompare'\n  \
    \          switch char.caseInsensitiveCompare(Character(\"A\")) {\n          \
    \         ~~~~ ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp06xr6ig1.swift:17:27: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \           result += Character(\"a\")\n                          ^\n/tmp/tmp06xr6ig1.swift:19:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                result += Character(\"A\")\n                          ^\n/tmp/tmp06xr6ig1.swift:22:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            let upper = char.uppercased()\n            let lower = char.lowercased()\n\
    \            if upper != nil {\n                result += upper!\n           \
    \ } else {\n                result += lower!\n            }\n        } else {\n\
    \            result += char\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp6v9focj2.swift:14:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmp6v9focj2.swift:17:22: warning: comparing non-optional\
    \ value of type 'String' to 'nil' always returns true\n            if upper !=\
    \ nil {\n               ~~~~~ ^  ~~~\n/tmp/tmp6v9focj2.swift:18:32: error: cannot\
    \ force unwrap value of non-optional type 'String'\n                result +=\
    \ upper!\n                          ~~~~~^\n                               \n\
    /tmp/tmp6v9focj2.swift:20:32: error: cannot force unwrap value of non-optional\
    \ type 'String'\n                result += lower!\n                          ~~~~~^\n\
    \                               \n/tmp/tmp6v9focj2.swift:23:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter\
    \ {\n            result += String(char.uppercased())\n        } else {\n     \
    \       result += String(char)\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpad3iozl1/tmpad3iozl1.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f0d8d3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f0d5cab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0f0d5ca988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0f0d5c97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpad3iozl1                        0x000055773def9657 <unavailable> + 5719

    5    libc.so.6                          0x00002b0f0dabf460 __libc_start_main +
    245

    6    tmpad3iozl1                        0x000055773def9299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            switch char.lowercased() {\n            case \"a\":\n       \
    \         result = \"A\" + result\n            case \"b\":\n                result\
    \ = \"B\" + result\n            case \"c\":\n                result = \"C\" +\
    \ result\n            case \"d\":\n                result = \"D\" + result\n \
    \           case \"e\":\n                result = \"E\" + result\n           \
    \ case \"f\":\n                result = \"F\" + result\n            case \"g\"\
    :\n                result = \"G\" + result\n            case \"h\":\n        \
    \        result = \"H\" + result\n            case \"i\":\n                result\
    \ = \"I\" + result\n            case \"j\":\n                result = \"J\" +\
    \ result\n            case \"k\":\n                result = \"K\" + result\n \
    \           case \"l\":\n                result = \"L\" + result\n           \
    \ case \"m\":\n                result = \"M\" + result\n            case \"n\"\
    :\n                result = \"N\" + result\n            case \"o\":\n        \
    \        result = \"O\" + result\n            case \"p\":\n                result\
    \ = \"P\" + result\n            case \"q\":\n                result = \"Q\" +\
    \ result\n            case \"r\":\n                result = \"R\" + result\n \
    \           case \"s\":\n                result = \"S\" + result\n           \
    \ case \"t\":\n                result = \"T\" + result\n            case \"u\"\
    :\n                result = \"U\" + result\n            case \"v\":\n        \
    \        result = \"V\" + result\n            case \"w\":\n                result\
    \ = \"W\" + result\n            case \"x\":\n                result = \"X\" +\
    \ result\n            case \"y\":\n                result = \"Y\" + result\n \
    \           case \"z\":\n                result = \"Z\" + result\n           \
    \ default:\n                result = \"a\" + result\n            }\n        }\
    \ else {\n            result = char + result\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpw7nap56w.swift:14:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpw7nap56w.swift:72:22: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n            result =\
    \ char + result\n                     ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for letter in s.characters {\n     \
    \   switch letter {\n        case let c where c.isUppercase:\n            result\
    \ += String(c)\n        case let c where !c.isUppercase:\n            result +=\
    \ String(c)\n        default:\n            result += letter\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpnmqzl2np.swift:13:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in s.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpnmqzl2np.swift:20:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    return s.characters.reversed().reduce(\"\") { $0 + String($1)\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpm03cykjf.swift:12:14: error: 'characters' is unavailable: Please\
    \ use String directly\n    return s.characters.reversed().reduce(\"\") { $0 +\
    \ String($1) }\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    return s.characters.reversed().reduce(\"\") { $0 + String($1)\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpm03cykjf.swift:12:14: error: 'characters' is unavailable: Please\
    \ use String directly\n    return s.characters.reversed().reduce(\"\") { $0 +\
    \ String($1) }\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    return s.characters.reversed().reduce(\"\") { $0 + String($1)\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpm03cykjf.swift:12:14: error: 'characters' is unavailable: Please\
    \ use String directly\n    return s.characters.reversed().reduce(\"\") { $0 +\
    \ String($1) }\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var res = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            res = char.lowercased() + res\n        } else {\n           \
    \ res = char + res\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpzbopj8os.swift:14:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpzbopj8os.swift:17:19: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n            res = char\
    \ + res\n                  ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case 'a':\n            result += \"A\"\n        case\
    \ 'b':\n            result += \"b\"\n        case 'c':\n            result +=\
    \ \"C\"\n        case 'd':\n            result += \"D\"\n        case 'e':\n \
    \           result += \"E\"\n        case 'f':\n            result += \"F\"\n\
    \        case 'g':\n            result += \"G\"\n        case 'h':\n         \
    \   result += \"H\"\n        case 'i':\n            result += \"I\"\n        case\
    \ 'j':\n            result += \"J\"\n        case 'k':\n            result +=\
    \ \"K\"\n        case 'l':\n            result += \"L\"\n        case 'm':\n \
    \           result += \"M\"\n        case 'n':\n            result += \"N\"\n\
    \        case 'o':\n            result += \"O\"\n        case 'p':\n         \
    \   result += \"P\"\n        case 'q':\n            result += \"Q\"\n        case\
    \ 'r':\n            result += \"R\"\n        case 's':\n            result +=\
    \ \"S\"\n        case 't':\n            result += \"T\"\n        case 'u':\n \
    \           result += \"U\"\n        case 'v':\n            result += \"V\"\n\
    \        case 'w':\n            result += \"W\"\n        case 'x':\n         \
    \   result += \"X\"\n        case 'y':\n            result += \"Y\"\n        case\
    \ 'z':\n            result += \"Z\"\n        default:\n            result += char\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpbdfznpt6.swift:15:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpbdfznpt6.swift:17:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmpbdfznpt6.swift:19:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmpbdfznpt6.swift:21:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmpbdfznpt6.swift:23:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpbdfznpt6.swift:25:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmpbdfznpt6.swift:27:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmpbdfznpt6.swift:29:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmpbdfznpt6.swift:31:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmpbdfznpt6.swift:33:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmpbdfznpt6.swift:35:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmpbdfznpt6.swift:37:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmpbdfznpt6.swift:39:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmpbdfznpt6.swift:41:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmpbdfznpt6.swift:43:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmpbdfznpt6.swift:45:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case 'a':\n            result += \"A\"\n        case\
    \ 'b':\n            result += \"b\"\n        case 'c':\n            result +=\
    \ \"C\"\n        case 'd':\n            result += \"d\"\n        case 'e':\n \
    \           result += \"E\"\n        case 'f':\n            result += \"f\"\n\
    \        case 'g':\n            result += \"G\"\n        case 'h':\n         \
    \   result += \"h\"\n        case 'i':\n            result += \"I\"\n        case\
    \ 'j':\n            result += \"j\"\n        case 'k':\n            result +=\
    \ \"K\"\n        case 'l':\n            result += \"L\"\n        case 'm':\n \
    \           result += \"m\"\n        case 'n':\n            result += \"N\"\n\
    \        case 'o':\n            result += \"O\"\n        case 'p':\n         \
    \   result += \"p\"\n        case 'q':\n            result += \"Q\"\n        case\
    \ 'r':\n            result += \"r\"\n        case 's':\n            result +=\
    \ \"S\"\n        case 't':\n            result += \"T\"\n        case 'u':\n \
    \           result += \"U\"\n        case 'v':\n            result += \"V\"\n\
    \        case 'w':\n            result += \"W\"\n        case 'x':\n         \
    \   result += \"X\"\n        case 'y':\n            result += \"Y\"\n        case\
    \ 'z':\n            result += \"Z\"\n        default:\n            result += char\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpw_8mezy_.swift:15:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpw_8mezy_.swift:17:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmpw_8mezy_.swift:19:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmpw_8mezy_.swift:21:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmpw_8mezy_.swift:23:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpw_8mezy_.swift:25:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmpw_8mezy_.swift:27:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmpw_8mezy_.swift:29:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmpw_8mezy_.swift:31:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmpw_8mezy_.swift:33:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmpw_8mezy_.swift:35:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmpw_8mezy_.swift:37:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmpw_8mezy_.swift:39:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmpw_8mezy_.swift:41:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmpw_8mezy_.swift:43:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmpw_8mezy_.swift:45:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ if let char = char.lowercaseString {\n            result = char + result\n \
    \       } else if let char = char.uppercaseString {\n            result = result\
    \ + char\n        } else {\n            result = char + result\n        }\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpkx4st5p6.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpkx4st5p6.swift:14:28:\
    \ error: value of type 'Character' has no member 'lowercaseString'\n        if\
    \ let char = char.lowercaseString {\n                      ~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmpkx4st5p6.swift:16:35: error: value of type 'Character' has no member 'uppercaseString'\n\
    \        } else if let char = char.uppercaseString {\n                       \
    \      ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpkx4st5p6.swift:19:22: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ = char + result\n                     ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter\
    \ {\n            let upper = char.uppercaseString\n            let lower = char.lowercaseString\n\
    \            if upper != nil {\n                result += upper!\n           \
    \ } else {\n                result += lower!\n            }\n        } else {\n\
    \            result += char\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpiuf3yr33.swift:15:30: error: value of type 'Character' has no member\
    \ 'uppercaseString'\n            let upper = char.uppercaseString\n          \
    \              ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpiuf3yr33.swift:16:30: error: value\
    \ of type 'Character' has no member 'lowercaseString'\n            let lower =\
    \ char.lowercaseString\n                        ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpiuf3yr33.swift:23:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case let .lowercase(letter):\n            result += String(letter).uppercased()\n\
    \        case let .uppercase(letter):\n            result += String(letter).lowercased()\n\
    \        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp7_gqgxe5.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp7_gqgxe5.swift:15:19:\
    \ error: type 'Character' has no member 'lowercase'\n        case let .lowercase(letter):\n\
    \                 ~^~~~~~~~~\n/tmp/tmp7_gqgxe5.swift:17:19: error: type 'Character'\
    \ has no member 'uppercase'\n        case let .uppercase(letter):\n          \
    \       ~^~~~~~~~~\n/tmp/tmp7_gqgxe5.swift:20:23: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n            result +=\
    \ char\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    return s.characters.reversed().reduce(\"\") { $0 + String($1)\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpm03cykjf.swift:12:14: error: 'characters' is unavailable: Please\
    \ use String directly\n    return s.characters.reversed().reduce(\"\") { $0 +\
    \ String($1) }\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ if char.isLetter() {\n            result += char.lowercased()\n        } else\
    \ {\n            result += char\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmptb2p_6a1.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmptb2p_6a1.swift:14:17:\
    \ error: cannot call value of non-function type 'Bool'\n        if char.isLetter()\
    \ {\n                ^       ~~\n                        \n/tmp/tmptb2p_6a1.swift:17:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ if char.isLetter {\n            switch char.lowercaseString {\n            case\
    \ char.uppercaseString:\n                result += char.uppercaseString\n    \
    \        case char.lowercaseString:\n                result += char.lowercaseString\n\
    \            default:\n                result += char\n            }\n       \
    \ } else {\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpm3yynjag.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpm3yynjag.swift:15:25:\
    \ error: value of type 'Character' has no member 'lowercaseString'\n         \
    \   switch char.lowercaseString {\n                   ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpm3yynjag.swift:17:32:\
    \ error: value of type 'Character' has no member 'uppercaseString'\n         \
    \       result += char.uppercaseString\n                          ~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmpm3yynjag.swift:19:32: error: value of type 'Character' has no member 'lowercaseString'\n\
    \                result += char.lowercaseString\n                          ~~~~\
    \ ^~~~~~~~~~~~~~~\n/tmp/tmpm3yynjag.swift:21:27: error: cannot convert value of\
    \ type 'Character' to expected argument type 'String'\n                result\
    \ += char\n                          ^\n/tmp/tmpm3yynjag.swift:24:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case 'a':\n            result += \"A\"\n        case\
    \ 'b':\n            result += \"b\"\n        case 'c':\n            result +=\
    \ \"C\"\n        case 'd':\n            result += \"D\"\n        case 'e':\n \
    \           result += \"E\"\n        case 'f':\n            result += \"F\"\n\
    \        case 'g':\n            result += \"G\"\n        case 'h':\n         \
    \   result += \"H\"\n        case 'i':\n            result += \"I\"\n        case\
    \ 'j':\n            result += \"J\"\n        case 'k':\n            result +=\
    \ \"K\"\n        case 'l':\n            result += \"L\"\n        case 'm':\n \
    \           result += \"M\"\n        case 'n':\n            result += \"N\"\n\
    \        case 'o':\n            result += \"O\"\n        case 'p':\n         \
    \   result += \"P\"\n        case 'q':\n            result += \"Q\"\n        case\
    \ 'r':\n            result += \"R\"\n        case 's':\n            result +=\
    \ \"S\"\n        case 't':\n            result += \"T\"\n        case 'u':\n \
    \           result += \"U\"\n        case 'v':\n            result += \"V\"\n\
    \        case 'w':\n            result += \"W\"\n        case 'x':\n         \
    \   result += \"X\"\n        case 'y':\n            result += \"Y\"\n        case\
    \ 'z':\n            result += \"Z\"\n        default:\n            result += String(char)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpcfcqb9x1.swift:15:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpcfcqb9x1.swift:17:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmpcfcqb9x1.swift:19:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmpcfcqb9x1.swift:21:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmpcfcqb9x1.swift:23:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpcfcqb9x1.swift:25:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmpcfcqb9x1.swift:27:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmpcfcqb9x1.swift:29:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmpcfcqb9x1.swift:31:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmpcfcqb9x1.swift:33:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmpcfcqb9x1.swift:35:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmpcfcqb9x1.swift:37:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmpcfcqb9x1.swift:39:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmpcfcqb9x1.swift:41:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmpcfcqb9x1.swift:43:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmpcfcqb9x1.swift:45:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    return s.characters.reversed().reduce(\"\") { $0 + String($1)\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpm03cykjf.swift:12:14: error: 'characters' is unavailable: Please\
    \ use String directly\n    return s.characters.reversed().reduce(\"\") { $0 +\
    \ String($1) }\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ if char.isLetter {\n            result += String(char.uppercase)\n        }\
    \ else {\n            result += String(char)\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp0ngt0yyk.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp0ngt0yyk.swift:15:35:\
    \ error: value of type 'Character' has no member 'uppercase'\n            result\
    \ += String(char.uppercase)\n                             ~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            switch char {\n            case \"a\":\n                result\
    \ += \"A\"\n            case \"b\":\n                result += \"b\"\n       \
    \     case \"c\":\n                result += \"C\"\n            case \"d\":\n\
    \                result += \"D\"\n            case \"e\":\n                result\
    \ += \"E\"\n            case \"f\":\n                result += \"F\"\n       \
    \     case \"g\":\n                result += \"G\"\n            case \"h\":\n\
    \                result += \"H\"\n            case \"i\":\n                result\
    \ += \"I\"\n            case \"j\":\n                result += \"J\"\n       \
    \     case \"k\":\n                result += \"K\"\n            case \"l\":\n\
    \                result += \"L\"\n            case \"m\":\n                result\
    \ += \"M\"\n            case \"n\":\n                result += \"N\"\n       \
    \     case \"o\":\n                result += \"O\"\n            case \"p\":\n\
    \                result += \"P\"\n            case \"q\":\n                result\
    \ += \"Q\"\n            case \"r\":\n                result += \"R\"\n       \
    \     case \"s\":\n                result += \"S\"\n            case \"t\":\n\
    \                result += \"T\"\n            case \"u\":\n                result\
    \ += \"U\"\n            case \"v\":\n                result += \"V\"\n       \
    \     case \"w\":\n                result += \"W\"\n            case \"x\":\n\
    \                result += \"X\"\n            case \"y\":\n                result\
    \ += \"Y\"\n            case \"z\":\n                result += \"Z\"\n       \
    \     default:\n                result += char\n            }\n        } else\
    \ {\n            result += char\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpammnmvt7.swift:14:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpammnmvt7.swift:69:27: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n                result\
    \ += char\n                          ^\n/tmp/tmpammnmvt7.swift:72:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for letter in s {\n        if letter.isLetter\
    \ {\n            result += String(letter.toUpper)\n        } else {\n        \
    \    result += String(letter)\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmphlb8w34u.swift:15:37: error: value of type 'Character' has no member\
    \ 'toUpper'\n            result += String(letter.toUpper)\n                  \
    \           ~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var res = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            res = char.lowercased() + res\n        } else {\n           \
    \ res = char + res\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpzbopj8os.swift:14:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpzbopj8os.swift:17:19: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n            res = char\
    \ + res\n                  ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            switch char.lowercased() {\n            case \"a\":\n       \
    \         result += \"A\"\n            case \"b\":\n                result +=\
    \ \"b\"\n            case \"c\":\n                result += \"C\"\n          \
    \  case \"d\":\n                result += \"d\"\n            case \"e\":\n   \
    \             result += \"E\"\n            case \"f\":\n                result\
    \ += \"f\"\n            case \"g\":\n                result += \"G\"\n       \
    \     case \"h\":\n                result += \"h\"\n            case \"i\":\n\
    \                result += \"I\"\n            case \"j\":\n                result\
    \ += \"j\"\n            case \"k\":\n                result += \"K\"\n       \
    \     case \"l\":\n                result += \"L\"\n            case \"m\":\n\
    \                result += \"m\"\n            case \"n\":\n                result\
    \ += \"N\"\n            case \"o\":\n                result += \"O\"\n       \
    \     case \"p\":\n                result += \"p\"\n            case \"q\":\n\
    \                result += \"Q\"\n            case \"r\":\n                result\
    \ += \"r\"\n            case \"s\":\n                result += \"S\"\n       \
    \     case \"t\":\n                result += \"T\"\n            case \"u\":\n\
    \                result += \"U\"\n            case \"v\":\n                result\
    \ += \"V\"\n            case \"w\":\n                result += \"W\"\n       \
    \     case \"x\":\n                result += \"X\"\n            case \"y\":\n\
    \                result += \"Y\"\n            case \"z\":\n                result\
    \ += \"Z\"\n            default:\n                result += char\n           \
    \ }\n        } else {\n            result += char\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmps1t51zt7.swift:14:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmps1t51zt7.swift:69:27: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n                result\
    \ += char\n                          ^\n/tmp/tmps1t51zt7.swift:72:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            let upper = char.uppercased()\n            let lower = char.lowercased()\n\
    \            if upper != lower  {\n                result += upper\n         \
    \   } else {\n                result += lower\n            }\n        } else {\n\
    \            result += char\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpd0m2tj3i.swift:14:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpd0m2tj3i.swift:23:23: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n            result +=\
    \ char\n                      ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    return s.characters.reduce(\"\") { (result, c) in\n       \
    \ if let c = c.lowercased() {\n            return result + String(c)\n       \
    \ } else {\n            return result + c\n        }\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpw08jekne.swift:16:29: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to expected argument type 'String'\n            return result\
    \ + c\n                            ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    var i = 0\n    while i < s.count {\n\
    \        if s[i] == Character(s[i]) {\n            result += String(Character(s[i]).uppercased())\n\
    \            i += 1\n        } else {\n            result += s[i]\n          \
    \  i += 1\n        }\n    }\n    if i == s.count {\n        return String(result)\n\
    \    }\n    return String(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s:\
    \ \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp8uctlqiv.swift:15:30: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n        if s[i] == Character(s[i]) {\n                            \
    \ ^\n                             extendedGraphemeClusterLiteral: \n/tmp/tmp8uctlqiv.swift:16:40:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \          result += String(Character(s[i]).uppercased())\n                  \
    \                     ^\n                                       extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmp8uctlqiv.swift:19:24: error: no exact matches in call to subscript\
    \ \n            result += s[i]\n                       ^\nSwift.String:3:12: note:\
    \ candidate expects value of type 'Range<String.Index>' for parameter #1 (got\
    \ 'Int')\n    public subscript(r: Range<String.Index>) -> Substring { get }\n\
    \           ^\nSwift.Collection:3:23: note: candidate expects value of type '(UnboundedRange_)\
    \ -> ()' for parameter #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_)\
    \ -> ()) -> Self.SubSequence { get }\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    var i = 0\n    var isLetter = false\n\
    \    for char in s {\n        switch char {\n        case \"a\":\n        case\
    \ \"b\":\n        case \"c\":\n        case \"d\":\n        case \"e\":\n    \
    \    case \"f\":\n        case \"g\":\n        case \"h\":\n        case \"i\"\
    :\n        case \"j\":\n        case \"k\":\n        case \"l\":\n        case\
    \ \"m\":\n        case \"n\":\n        case \"o\":\n        case \"p\":\n    \
    \    case \"q\":\n        case \"r\":\n        case \"s\":\n        case \"t\"\
    :\n        case \"u\":\n        case \"v\":\n        case \"w\":\n        case\
    \ \"x\":\n        case \"y\":\n        case \"z\":\n            isLetter = true\n\
    \        default:\n            isLetter = false\n        }\n        if isLetter\
    \ {\n            result += String(char.uppercased())\n        } else {\n     \
    \       result += String(char)\n        }\n        i += 1\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpxgdu1noq.swift:17:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"a\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpxgdu1noq.swift:18:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"b\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmpxgdu1noq.swift:19:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"c\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpxgdu1noq.swift:20:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"d\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpxgdu1noq.swift:21:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"e\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpxgdu1noq.swift:22:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"f\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpxgdu1noq.swift:23:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"g\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpxgdu1noq.swift:24:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"h\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpxgdu1noq.swift:25:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"i\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpxgdu1noq.swift:26:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"j\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpxgdu1noq.swift:27:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"k\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpxgdu1noq.swift:28:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"l\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpxgdu1noq.swift:29:9:\
    \ error: 'case' l"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        switch char\
    \ {\n        case \"a\":\n            result = \"A\" + result\n        case \"\
    b\":\n            result = \"B\" + result\n        case \"c\":\n            result\
    \ = \"C\" + result\n        case \"d\":\n            result = \"D\" + result\n\
    \        case \"e\":\n            result = \"E\" + result\n        case \"f\"\
    :\n            result = \"F\" + result\n        case \"g\":\n            result\
    \ = \"G\" + result\n        case \"h\":\n            result = \"H\" + result\n\
    \        case \"i\":\n            result = \"I\" + result\n        case \"j\"\
    :\n            result = \"J\" + result\n        case \"k\":\n            result\
    \ = \"K\" + result\n        case \"l\":\n            result = \"L\" + result\n\
    \        case \"m\":\n            result = \"M\" + result\n        case \"n\"\
    :\n            result = \"N\" + result\n        case \"o\":\n            result\
    \ = \"O\" + result\n        case \"p\":\n            result = \"P\" + result\n\
    \        case \"q\":\n            result = \"Q\" + result\n        case \"r\"\
    :\n            result = \"R\" + result\n        case \"s\":\n            result\
    \ = \"S\" + result\n        case \"t\":\n            result = \"T\" + result\n\
    \        case \"u\":\n            result = \"U\" + result\n        case \"v\"\
    :\n            result = \"V\" + result\n        case \"w\":\n            result\
    \ = \"W\" + result\n        case \"x\":\n            result = \"X\" + result\n\
    \        case \"y\":\n            result = \"Y\" + result\n        case \"z\"\
    :\n            result = \"Z\" + result\n        default:\n            result =\
    \ char + result\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp1sq9tdg8.swift:68:22: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result = char + result\n   \
    \                  ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        switch char\
    \ {\n        case \"a\":\n            result = \"A\" + result\n        case \"\
    b\":\n            result = \"B\" + result\n        case \"c\":\n            result\
    \ = \"C\" + result\n        case \"d\":\n            result = \"D\" + result\n\
    \        case \"e\":\n            result = \"E\" + result\n        case \"f\"\
    :\n            result = \"F\" + result\n        case \"g\":\n            result\
    \ = \"G\" + result\n        case \"h\":\n            result = \"H\" + result\n\
    \        case \"i\":\n            result = \"I\" + result\n        case \"j\"\
    :\n            result = \"J\" + result\n        case \"k\":\n            result\
    \ = \"K\" + result\n        case \"l\":\n            result = \"L\" + result\n\
    \        case \"m\":\n            result = \"M\" + result\n        case \"n\"\
    :\n            result = \"N\" + result\n        case \"o\":\n            result\
    \ = \"O\" + result\n        case \"p\":\n            result = \"P\" + result\n\
    \        case \"q\":\n            result = \"Q\" + result\n        case \"r\"\
    :\n            result = \"R\" + result\n        case \"s\":\n            result\
    \ = \"S\" + result\n        case \"t\":\n            result = \"T\" + result\n\
    \        case \"u\":\n            result = \"U\" + result\n        case \"v\"\
    :\n            result = \"V\" + result\n        case \"w\":\n            result\
    \ = \"W\" + result\n        case \"x\":\n            result = \"X\" + result\n\
    \        case \"y\":\n            result = \"Y\" + result\n        case \"z\"\
    :\n            result = \"Z\" + result\n        default:\n            result =\
    \ char + result\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp1sq9tdg8.swift:68:22: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result = char + result\n   \
    \                  ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for letter in s {\n        if letter.isLetter\
    \ {\n            switch letter {\n            case \"A\":\n                result\
    \ = \"a\" + result\n            case \"a\":\n                result = \"A\" +\
    \ result\n            case \"B\":\n                result = \"b\" + result\n \
    \           case \"b\":\n                result = \"B\" + result\n           \
    \ case \"C\":\n                result = \"c\" + result\n            case \"c\"\
    :\n                result = \"C\" + result\n            case \"D\":\n        \
    \        result = \"d\" + result\n            case \"d\":\n                result\
    \ = \"D\" + result\n            case \"E\":\n                result = \"e\" +\
    \ result\n            case \"e\":\n                result = \"E\" + result\n \
    \           case \"F\":\n                result = \"f\" + result\n           \
    \ case \"f\":\n                result = \"F\" + result\n            case \"G\"\
    :\n                result = \"g\" + result\n            case \"g\":\n        \
    \        result = \"G\" + result\n            case \"H\":\n                result\
    \ = \"h\" + result\n            case \"h\":\n                result = \"H\" +\
    \ result\n            case \"I\":\n                result = \"i\" + result\n \
    \           case \"i\":\n                result = \"I\" + result\n           \
    \ case \"J\":\n                result = \"j\" + result\n            case \"j\"\
    :\n                result = \"J\" + result\n            case \"K\":\n        \
    \        result = \"k\" + result\n            case \"k\":\n                result\
    \ = \"K\" + result\n            case \"L\":\n                result = \"l\" +\
    \ result\n            case \"l\":\n                result = \"L\" + result\n \
    \           case \"M\":\n                result = \"m\" + result\n           \
    \ case \"m\":\n                result = \"M\" + result\n            case \"N\"\
    :\n                result = \"n\" + result\n            case \"n\":\n        \
    \        result = \"N\" + result\n            case \"O\":\n                result\
    \ = \"o\" + result\n            case \"o\":\n                result = \"O\" +\
    \ result\n            case \"P\":\n                result = \"p\" + result\n \
    \           case \"p\":\n                result = \"P\" + result\n           \
    \ case \"Q\":\n                result = \"q\" + result\n            case \"q\"\
    :\n                result = \"Q\" + result\n            case \"R\":\n        \
    \        result = \"r\" + result\n            case \"r\":\n                result\
    \ = \"R\" + result\n            case \"S\":\n                result = \"s\" +\
    \ result\n            case \"s\":\n                result = \"S\" + result\n \
    \           case \"T\":\n                result = \"t\" + result\n           \
    \ case \"t\":\n                result = \"T\" + result\n            case \"U\"\
    :\n                result = \"u\" + result\n            case \"u\":\n        \
    \        result = \"U\" + result\n            case \"V\":\n                result\
    \ = \"v\" + result\n            case \"v\":\n                result = \"V\" +\
    \ result\n            case \"W\":\n                result = \"w\" + result\n \
    \           \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp8eagbwcw.swift:129:35: error: expected '}' at end of brace statement\n\
    assert(solve(s: \"#ccc\") == \"#CCC\")\n                                  ^\n\
    /tmp/tmp8eagbwcw.swift:14:28: note: to match this opening '{'\n        if letter.isLetter\
    \ {\n                           ^\n/tmp/tmp8eagbwcw.swift:129:35: error: expected\
    \ '}' at end of brace statement\nassert(solve(s: \"#ccc\") == \"#CCC\")\n    \
    \                              ^\n/tmp/tmp8eagbwcw.swift:13:21: note: to match\
    \ this opening '{'\n    for letter in s {\n                    ^\n/tmp/tmp8eagbwcw.swift:129:35:\
    \ error: expected '}' at end of brace statement\nassert(solve(s: \"#ccc\") ==\
    \ \"#CCC\")\n                                  ^\n/tmp/tmp8eagbwcw.swift:11:33:\
    \ note: to match this opening '{'\nfunc solve(s: String) -> String {\n       \
    \                         ^\n/tmp/tmp8eagbwcw.swift:15:13: error: switch must\
    \ be exhaustive\n            switch letter {\n            ^\n/tmp/tmp8eagbwcw.swift:15:13:\
    \ note: do you want to add a default clause?\n            switch letter {\n  \
    \          ^\n/tmp/tmp8eagbwcw.swift:110:6: error: operator functions can only\
    \ be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            let upper = String(char.uppercased())\n            let lower\
    \ = String(char.lowercased())\n            result = upper.prefix(1) + lower +\
    \ upper.suffix(1)\n        } else {\n            result = char\n        }\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpzan2fclj.swift:14:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpzan2fclj.swift:19:22: error: cannot assign value\
    \ of type 'Character' to type 'String'\n            result = char\n          \
    \           ^~~~\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            switch char.lowercased() {\n            case \"a\":\n       \
    \         result = \"A\" + result\n            case \"b\":\n                result\
    \ = \"B\" + result\n            case \"c\":\n                result = \"C\" +\
    \ result\n            case \"d\":\n                result = \"D\" + result\n \
    \           case \"e\":\n                result = \"E\" + result\n           \
    \ case \"f\":\n                result = \"F\" + result\n            case \"g\"\
    :\n                result = \"G\" + result\n            case \"h\":\n        \
    \        result = \"H\" + result\n            case \"i\":\n                result\
    \ = \"I\" + result\n            case \"j\":\n                result = \"J\" +\
    \ result\n            case \"k\":\n                result = \"K\" + result\n \
    \           case \"l\":\n                result = \"L\" + result\n           \
    \ case \"m\":\n                result = \"M\" + result\n            case \"n\"\
    :\n                result = \"N\" + result\n            case \"o\":\n        \
    \        result = \"O\" + result\n            case \"p\":\n                result\
    \ = \"P\" + result\n            case \"q\":\n                result = \"Q\" +\
    \ result\n            case \"r\":\n                result = \"R\" + result\n \
    \           case \"s\":\n                result = \"S\" + result\n           \
    \ case \"t\":\n                result = \"T\" + result\n            case \"u\"\
    :\n                result = \"U\" + result\n            case \"v\":\n        \
    \        result = \"V\" + result\n            case \"w\":\n                result\
    \ = \"W\" + result\n            case \"x\":\n                result = \"X\" +\
    \ result\n            case \"y\":\n                result = \"Y\" + result\n \
    \           case \"z\":\n                result = \"Z\" + result\n           \
    \ default:\n                result = \"0\" + result\n            }\n        }\
    \ else {\n            result = char + result\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpyp_88gpo.swift:14:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpyp_88gpo.swift:72:22: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n            result =\
    \ char + result\n                     ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case let c where c >= 'a' && c <= 'z':\n            result\
    \ += \"\\(c)\"\n        case let c where c >= 'A' && c <= 'Z':\n            result\
    \ += \"\\(c)\"\n        default:\n            result += char\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpo8orvj2d.swift:15:31: error: single-quoted string literal found,\
    \ use '\"'\n        case let c where c >= 'a' && c <= 'z':\n                 \
    \             ^~~\n                              \"a\"\n/tmp/tmpo8orvj2d.swift:15:43:\
    \ error: single-quoted string literal found, use '\"'\n        case let c where\
    \ c >= 'a' && c <= 'z':\n                                          ^~~\n     \
    \                                     \"z\"\n/tmp/tmpo8orvj2d.swift:17:31: error:\
    \ single-quoted string literal found, use '\"'\n        case let c where c >=\
    \ 'A' && c <= 'Z':\n                              ^~~\n                      \
    \        \"A\"\n/tmp/tmpo8orvj2d.swift:17:43: error: single-quoted string literal\
    \ found, use '\"'\n        case let c where c >= 'A' && c <= 'Z':\n          \
    \                                ^~~\n                                       \
    \   \"Z\"\n/tmp/tmpo8orvj2d.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpo8orvj2d.swift:20:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    return s.characters.reduce(\"\") { $0 + String($1) }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpg6vefuyv.swift:12:14: error: 'characters' is unavailable: Please\
    \ use String directly\n    return s.characters.reduce(\"\") { $0 + String($1)\
    \ }\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    return s.characters.reversed().reduce(\"\") { $0 + String($1)\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpm03cykjf.swift:12:14: error: 'characters' is unavailable: Please\
    \ use String directly\n    return s.characters.reversed().reduce(\"\") { $0 +\
    \ String($1) }\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ if char.isLetter() {\n            switch char.lowercased() {\n            case\
    \ \"a\": result = \"A\"; break\n            case \"b\": result = \"b\"; break\n\
    \            case \"c\": result = \"C\"; break\n            case \"d\": result\
    \ = \"d\"; break\n            case \"e\": result = \"E\"; break\n            case\
    \ \"f\": result = \"f\"; break\n            case \"g\": result = \"G\"; break\n\
    \            case \"h\": result = \"H\"; break\n            case \"i\": result\
    \ = \"I\"; break\n            case \"j\": result = \"J\"; break\n            case\
    \ \"k\": result = \"K\"; break\n            case \"l\": result = \"L\"; break\n\
    \            case \"m\": result = \"M\"; break\n            case \"n\": result\
    \ = \"N\"; break\n            case \"o\": result = \"O\"; break\n            case\
    \ \"p\": result = \"P\"; break\n            case \"q\": result = \"Q\"; break\n\
    \            case \"r\": result = \"R\"; break\n            case \"s\": result\
    \ = \"S\"; break\n            case \"t\": result = \"T\"; break\n            case\
    \ \"u\": result = \"U\"; break\n            case \"v\": result = \"V\"; break\n\
    \            case \"w\": result = \"W\"; break\n            case \"x\": result\
    \ = \"X\"; break\n            case \"y\": result = \"Y\"; break\n            case\
    \ \"z\": result = \"Z\"; break\n            default: result = char.lowercased()\n\
    \            }\n        } else {\n            result = char\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpmiphrfx6.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpmiphrfx6.swift:14:17:\
    \ error: cannot call value of non-function type 'Bool'\n        if char.isLetter()\
    \ {\n                ^       ~~\n                        \n/tmp/tmpmiphrfx6.swift:45:22:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \  result = char\n                     ^~~~\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case let c where c.isLetter:\n            result += String(c.uppercase)\n\
    \        case let c where !c.isLetter:\n            result += String(c.lowercase)\n\
    \        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp1eomylaw.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp1eomylaw.swift:16:32:\
    \ error: value of type 'Character' has no member 'uppercase'\n            result\
    \ += String(c.uppercase)\n                             ~ ^~~~~~~~~\n/tmp/tmp1eomylaw.swift:18:32:\
    \ error: value of type 'Character' has no member 'lowercase'\n            result\
    \ += String(c.lowercase)\n                             ~ ^~~~~~~~~\n/tmp/tmp1eomylaw.swift:20:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case 'a':\n            result += \"A\"\n        case\
    \ 'b':\n            result += \"B\"\n        case 'c':\n            result +=\
    \ \"C\"\n        case 'd':\n            result += \"D\"\n        case 'e':\n \
    \           result += \"E\"\n        case 'f':\n            result += \"F\"\n\
    \        case 'g':\n            result += \"G\"\n        case 'h':\n         \
    \   result += \"H\"\n        case 'i':\n            result += \"I\"\n        case\
    \ 'j':\n            result += \"J\"\n        case 'k':\n            result +=\
    \ \"K\"\n        case 'l':\n            result += \"L\"\n        case 'm':\n \
    \           result += \"M\"\n        case 'n':\n            result += \"N\"\n\
    \        case 'o':\n            result += \"O\"\n        case 'p':\n         \
    \   result += \"P\"\n        case 'q':\n            result += \"Q\"\n        case\
    \ 'r':\n            result += \"R\"\n        case 's':\n            result +=\
    \ \"S\"\n        case 't':\n            result += \"T\"\n        case 'u':\n \
    \           result += \"U\"\n        case 'v':\n            result += \"V\"\n\
    \        case 'w':\n            result += \"W\"\n        case 'x':\n         \
    \   result += \"X\"\n        case 'y':\n            result += \"Y\"\n        case\
    \ 'z':\n            result += \"Z\"\n        default:\n            result += char\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpoj7_oy_r.swift:15:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpoj7_oy_r.swift:17:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmpoj7_oy_r.swift:19:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmpoj7_oy_r.swift:21:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmpoj7_oy_r.swift:23:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpoj7_oy_r.swift:25:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmpoj7_oy_r.swift:27:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmpoj7_oy_r.swift:29:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmpoj7_oy_r.swift:31:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmpoj7_oy_r.swift:33:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmpoj7_oy_r.swift:35:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmpoj7_oy_r.swift:37:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmpoj7_oy_r.swift:39:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmpoj7_oy_r.swift:41:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmpoj7_oy_r.swift:43:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmpoj7_oy_r.swift:45:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            switch char.lowercased() {\n            case \"a\":\n       \
    \         result += \"A\"\n            case \"b\":\n                result +=\
    \ \"b\"\n            case \"c\":\n                result += \"C\"\n          \
    \  case \"d\":\n                result += \"D\"\n            case \"e\":\n   \
    \             result += \"E\"\n            case \"f\":\n                result\
    \ += \"F\"\n            case \"g\":\n                result += \"G\"\n       \
    \     case \"h\":\n                result += \"H\"\n            case \"i\":\n\
    \                result += \"I\"\n            case \"j\":\n                result\
    \ += \"J\"\n            case \"k\":\n                result += \"K\"\n       \
    \     case \"l\":\n                result += \"L\"\n            case \"m\":\n\
    \                result += \"M\"\n            case \"n\":\n                result\
    \ += \"N\"\n            case \"o\":\n                result += \"O\"\n       \
    \     case \"p\":\n                result += \"P\"\n            case \"q\":\n\
    \                result += \"Q\"\n            case \"r\":\n                result\
    \ += \"R\"\n            case \"s\":\n                result += \"S\"\n       \
    \     case \"t\":\n                result += \"T\"\n            case \"u\":\n\
    \                result += \"U\"\n            case \"v\":\n                result\
    \ += \"V\"\n            case \"w\":\n                result += \"W\"\n       \
    \     case \"x\":\n                result += \"X\"\n            case \"y\":\n\
    \                result += \"Y\"\n            case \"z\":\n                result\
    \ += \"Z\"\n            default:\n                result += char\n           \
    \ }\n        } else {\n            result += char\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpggdipbze.swift:14:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpggdipbze.swift:69:27: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n                result\
    \ += char\n                          ^\n/tmp/tmpggdipbze.swift:72:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    return s.characters.reversed().reduce(\"\") { $0 + String($1)\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpm03cykjf.swift:12:14: error: 'characters' is unavailable: Please\
    \ use String directly\n    return s.characters.reversed().reduce(\"\") { $0 +\
    \ String($1) }\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    return s.characters.reversed().reduce(\"\") { $0 + String($1)\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpm03cykjf.swift:12:14: error: 'characters' is unavailable: Please\
    \ use String directly\n    return s.characters.reversed().reduce(\"\") { $0 +\
    \ String($1) }\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        switch char\
    \ {\n        case \"a\":\n            result += \"A\"\n        case \"b\":\n \
    \           result += \"b\"\n        case \"c\":\n            result += \"C\"\n\
    \        case \"d\":\n            result += \"D\"\n        case \"e\":\n     \
    \       result += \"E\"\n        case \"f\":\n            result += \"F\"\n  \
    \      case \"g\":\n            result += \"G\"\n        case \"h\":\n       \
    \     result += \"H\"\n        case \"i\":\n            result += \"I\"\n    \
    \    case \"j\":\n            result += \"J\"\n        case \"k\":\n         \
    \   result += \"K\"\n        case \"l\":\n            result += \"L\"\n      \
    \  case \"m\":\n            result += \"M\"\n        case \"n\":\n           \
    \ result += \"N\"\n        case \"o\":\n            result += \"O\"\n        case\
    \ \"p\":\n            result += \"P\"\n        case \"q\":\n            result\
    \ += \"Q\"\n        case \"r\":\n            result += \"R\"\n        case \"\
    s\":\n            result += \"S\"\n        case \"t\":\n            result +=\
    \ \"T\"\n        case \"u\":\n            result += \"U\"\n        case \"v\"\
    :\n            result += \"V\"\n        case \"w\":\n            result += \"\
    W\"\n        case \"x\":\n            result += \"X\"\n        case \"y\":\n \
    \           result += \"Y\"\n        case \"z\":\n            result += \"Z\"\n\
    \        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpv3q437oa.swift:68:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ if char.isLetter {\n            let upperCase = char.uppercaseString\n     \
    \       let lowerCase = char.lowercaseString\n            if upperCase != lowerCase\
    \ {\n                result += upperCase\n            } else {\n             \
    \   result += lowerCase\n            }\n        } else {\n            result +=\
    \ char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp2uyvjyn6.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp2uyvjyn6.swift:15:34:\
    \ error: value of type 'Character' has no member 'uppercaseString'\n         \
    \   let upperCase = char.uppercaseString\n                            ~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmp2uyvjyn6.swift:16:34: error: value of type 'Character' has no member 'lowercaseString'\n\
    \            let lowerCase = char.lowercaseString\n                          \
    \  ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmp2uyvjyn6.swift:23:23: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n            result +=\
    \ char\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case 'a':\n            result += \"A\"\n        case\
    \ 'b':\n            result += \"b\"\n        case 'c':\n            result +=\
    \ \"C\"\n        case 'd':\n            result += \"d\"\n        case 'e':\n \
    \           result += \"E\"\n        case 'f':\n            result += \"f\"\n\
    \        case 'g':\n            result += \"G\"\n        case 'h':\n         \
    \   result += \"h\"\n        case 'i':\n            result += \"I\"\n        case\
    \ 'j':\n            result += \"j\"\n        case 'k':\n            result +=\
    \ \"K\"\n        case 'l':\n            result += \"L\"\n        case 'm':\n \
    \           result += \"m\"\n        case 'n':\n            result += \"N\"\n\
    \        case 'o':\n            result += \"O\"\n        case 'p':\n         \
    \   result += \"p\"\n        case 'q':\n            result += \"Q\"\n        case\
    \ 'r':\n            result += \"r\"\n        case 's':\n            result +=\
    \ \"S\"\n        case 't':\n            result += \"T\"\n        case 'u':\n \
    \           result += \"U\"\n        case 'v':\n            result += \"V\"\n\
    \        case 'w':\n            result += \"W\"\n        case 'x':\n         \
    \   result += \"X\"\n        case 'y':\n            result += \"Y\"\n        case\
    \ 'z':\n            result += \"Z\"\n        default:\n            result += char\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpw_8mezy_.swift:15:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpw_8mezy_.swift:17:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmpw_8mezy_.swift:19:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmpw_8mezy_.swift:21:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmpw_8mezy_.swift:23:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpw_8mezy_.swift:25:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmpw_8mezy_.swift:27:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmpw_8mezy_.swift:29:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmpw_8mezy_.swift:31:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmpw_8mezy_.swift:33:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmpw_8mezy_.swift:35:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmpw_8mezy_.swift:37:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmpw_8mezy_.swift:39:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmpw_8mezy_.swift:41:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmpw_8mezy_.swift:43:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmpw_8mezy_.swift:45:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ if char.isLetter {\n            let upper = char.uppercaseString\n         \
    \   let lower = char.lowercaseString\n            result = upper.characters.reduce(result)\
    \ { $0 + String($1) + lower }\n        } else {\n            result = char.characters.reduce(result)\
    \ { $0 + String($1) + String(char) }\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpb2b32pfx.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpb2b32pfx.swift:15:30:\
    \ error: value of type 'Character' has no member 'uppercaseString'\n         \
    \   let upper = char.uppercaseString\n                        ~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmpb2b32pfx.swift:16:30: error: value of type 'Character' has no member 'lowercaseString'\n\
    \            let lower = char.lowercaseString\n                        ~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmpb2b32pfx.swift:19:27: error: value of type 'Character' has no member 'characters'\n\
    \            result = char.characters.reduce(result) { $0 + String($1) + String(char)\
    \ }\n                     ~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824676
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        switch char\
    \ {\n        case \"a\":\n        case \"b\":\n        case \"c\":\n        case\
    \ \"d\":\n        case \"e\":\n        case \"f\":\n        case \"g\":\n    \
    \    case \"h\":\n        case \"i\":\n        case \"j\":\n        case \"k\"\
    :\n        case \"l\":\n        case \"m\":\n        case \"n\":\n        case\
    \ \"o\":\n        case \"p\":\n        case \"q\":\n        case \"r\":\n    \
    \    case \"s\":\n        case \"t\":\n        case \"u\":\n        case \"v\"\
    :\n        case \"w\":\n        case \"x\":\n        case \"y\":\n        case\
    \ \"z\":\n        case \"A\":\n        case \"B\":\n        case \"C\":\n    \
    \    case \"D\":\n        case \"E\":\n        case \"F\":\n        case \"G\"\
    :\n        case \"H\":\n        case \"I\":\n        case \"J\":\n        case\
    \ \"K\":\n        case \"L\":\n        case \"M\":\n        case \"N\":\n    \
    \    case \"O\":\n        case \"P\":\n        case \"Q\":\n        case \"R\"\
    :\n        case \"S\":\n        case \"T\":\n        case \"U\":\n        case\
    \ \"V\":\n        case \"W\":\n        case \"X\":\n        case \"Y\":\n    \
    \    case \"Z\":\n            result = char + result\n        default:\n     \
    \       result = char + result\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpdctbdg0h.swift:15:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"a\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpdctbdg0h.swift:16:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"b\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmpdctbdg0h.swift:17:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"c\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpdctbdg0h.swift:18:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"d\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpdctbdg0h.swift:19:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"e\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpdctbdg0h.swift:20:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"f\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpdctbdg0h.swift:21:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"g\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpdctbdg0h.swift:22:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"h\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpdctbdg0h.swift:23:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"i\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpdctbdg0h.swift:24:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"j\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpdctbdg0h.swift:25:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"k\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpdctbdg0h.swift:26:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"l\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpdctbdg0h.swift:27:9:\
    \ error: 'case' l"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for letter in s.characters {\n     \
    \   switch letter {\n        case let c as Character:\n            switch c {\n\
    \            case .lowercase:\n                result += \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    [c]\n            case .uppercase:\n                result += \"abcdefghijklmnopqrstuvwxyz\"\
    [c]\n            default:\n                result += letter\n            }\n \
    \       case let c as String:\n            result += c\n        default:\n   \
    \         result += letter\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpd0du5bal.swift:13:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in s.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpd0du5bal.swift:15:20:\
    \ warning: 'as' test is always true\n        case let c as Character:\n      \
    \             ^\n/tmp/tmpd0du5bal.swift:24:20: warning: cast from 'Character'\
    \ to unrelated type 'String' always fails\n        case let c as String:\n   \
    \                ^~ ~~~~~~\n/tmp/tmpd0du5bal.swift:17:19: error: type 'Character'\
    \ has no member 'lowercase'\n            case .lowercase:\n                 ~^~~~~~~~~\n\
    /tmp/tmpd0du5bal.swift:19:19: error: type 'Character' has no member 'uppercase'\n\
    \            case .uppercase:\n                 ~^~~~~~~~~\n/tmp/tmpd0du5bal.swift:18:55:\
    \ error: no exact matches in call to subscript \n                result += \"\
    ABCDEFGHIJKLMNOPQRSTUVWXYZ\"[c]\n                                            \
    \          ^\nSwift.String:3:12: note: candidate expects value of type 'Range<String.Index>'\
    \ for parameter #1 (got 'Character')\n    public subscript(r: Range<String.Index>)\
    \ -> Substring { get }\n           ^\nSwift.Collection:3:23: note: candidate expects\
    \ value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Character')\n\
    \    @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence\
    \ { get }\n                      ^\n/tmp/tmpd0du5bal.swift:20:55: error: no exact\
    \ matches in call to subscript \n                result += \"abcdefghijklmnopqrstuvwxyz\"\
    [c]\n                                                      ^\nSwift.String:3:12:\
    \ note: candidate expects value of type 'Range<String.Index>' for parameter #1\
    \ (got 'Character')\n    public subscript(r: Range<String.Index>) -> Substring\
    \ { get }\n           ^\nSwift.Collection:3:23: note: candidate expects value\
    \ of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Character')\n    @inlinable\
    \ public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }\n "
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        switch char\
    \ {\n        case \"a\":\n        case \"b\":\n        case \"c\":\n        case\
    \ \"d\":\n        case \"e\":\n        case \"f\":\n        case \"g\":\n    \
    \    case \"h\":\n        case \"i\":\n        case \"j\":\n        case \"k\"\
    :\n        case \"l\":\n        case \"m\":\n        case \"n\":\n        case\
    \ \"o\":\n        case \"p\":\n        case \"q\":\n        case \"r\":\n    \
    \    case \"s\":\n        case \"t\":\n        case \"u\":\n        case \"v\"\
    :\n        case \"w\":\n        case \"x\":\n        case \"y\":\n        case\
    \ \"z\":\n        case \"A\":\n        case \"B\":\n        case \"C\":\n    \
    \    case \"D\":\n        case \"E\":\n        case \"F\":\n        case \"G\"\
    :\n        case \"H\":\n        case \"I\":\n        case \"J\":\n        case\
    \ \"K\":\n        case \"L\":\n        case \"M\":\n        case \"N\":\n    \
    \    case \"O\":\n        case \"P\":\n        case \"Q\":\n        case \"R\"\
    :\n        case \"S\":\n        case \"T\":\n        case \"U\":\n        case\
    \ \"V\":\n        case \"W\":\n        case \"X\":\n        case \"Y\":\n    \
    \    case \"Z\":\n            result += char.lowercased()\n        default:\n\
    \            result += char\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpbbr873ol.swift:15:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"a\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpbbr873ol.swift:16:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"b\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmpbbr873ol.swift:17:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"c\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpbbr873ol.swift:18:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"d\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpbbr873ol.swift:19:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"e\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpbbr873ol.swift:20:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"f\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpbbr873ol.swift:21:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"g\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpbbr873ol.swift:22:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"h\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpbbr873ol.swift:23:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"i\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpbbr873ol.swift:24:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"j\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpbbr873ol.swift:25:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"k\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpbbr873ol.swift:26:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"l\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpbbr873ol.swift:27:9:\
    \ error: 'case' l"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case 'a':\n            result += \"A\"\n        case\
    \ 'b':\n            result += \"b\"\n        case 'c':\n            result +=\
    \ \"C\"\n        case 'd':\n            result += \"D\"\n        case 'e':\n \
    \           result += \"E\"\n        case 'f':\n            result += \"F\"\n\
    \        case 'g':\n            result += \"G\"\n        case 'h':\n         \
    \   result += \"H\"\n        case 'i':\n            result += \"I\"\n        case\
    \ 'j':\n            result += \"J\"\n        case 'k':\n            result +=\
    \ \"K\"\n        case 'l':\n            result += \"L\"\n        case 'm':\n \
    \           result += \"M\"\n        case 'n':\n            result += \"N\"\n\
    \        case 'o':\n            result += \"O\"\n        case 'p':\n         \
    \   result += \"P\"\n        case 'q':\n            result += \"Q\"\n        case\
    \ 'r':\n            result += \"R\"\n        case 's':\n            result +=\
    \ \"S\"\n        case 't':\n            result += \"T\"\n        case 'u':\n \
    \           result += \"U\"\n        case 'v':\n            result += \"V\"\n\
    \        case 'w':\n            result += \"W\"\n        case 'x':\n         \
    \   result += \"X\"\n        case 'y':\n            result += \"Y\"\n        case\
    \ 'z':\n            result += \"Z\"\n        default:\n            result += char\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpbdfznpt6.swift:15:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpbdfznpt6.swift:17:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmpbdfznpt6.swift:19:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmpbdfznpt6.swift:21:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmpbdfznpt6.swift:23:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpbdfznpt6.swift:25:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmpbdfznpt6.swift:27:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmpbdfznpt6.swift:29:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmpbdfznpt6.swift:31:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmpbdfznpt6.swift:33:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmpbdfznpt6.swift:35:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmpbdfznpt6.swift:37:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmpbdfznpt6.swift:39:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmpbdfznpt6.swift:41:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmpbdfznpt6.swift:43:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmpbdfznpt6.swift:45:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var res = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            res = char.lowercased() + res\n        } else {\n           \
    \ res = char + res\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpzbopj8os.swift:14:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpzbopj8os.swift:17:19: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n            res = char\
    \ + res\n                  ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var res = \"\"\n    for char in s.characters {\n        switch\
    \ char {\n        case 'a':\n            res += \"A\"\n        case 'b':\n   \
    \         res += \"b\"\n        case 'c':\n            res += \"C\"\n        case\
    \ 'd':\n            res += \"d\"\n        case 'e':\n            res += \"E\"\n\
    \        case 'f':\n            res += \"f\"\n        case 'g':\n            res\
    \ += \"G\"\n        case 'h':\n            res += \"h\"\n        case 'i':\n \
    \           res += \"I\"\n        case 'j':\n            res += \"J\"\n      \
    \  case 'k':\n            res += \"K\"\n        case 'l':\n            res +=\
    \ \"L\"\n        case 'm':\n            res += \"m\"\n        case 'n':\n    \
    \        res += \"N\"\n        case 'o':\n            res += \"O\"\n        case\
    \ 'p':\n            res += \"p\"\n        case 'q':\n            res += \"Q\"\n\
    \        case 'r':\n            res += \"r\"\n        case 's':\n            res\
    \ += \"S\"\n        case 't':\n            res += \"T\"\n        case 'u':\n \
    \           res += \"U\"\n        case 'v':\n            res += \"V\"\n      \
    \  case 'w':\n            res += \"W\"\n        case 'x':\n            res +=\
    \ \"X\"\n        case 'y':\n            res += \"Y\"\n        case 'z':\n    \
    \        res += \"Z\"\n        default:\n            res += char\n        }\n\
    \    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpqz3282c1.swift:15:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpqz3282c1.swift:17:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmpqz3282c1.swift:19:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmpqz3282c1.swift:21:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmpqz3282c1.swift:23:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpqz3282c1.swift:25:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmpqz3282c1.swift:27:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmpqz3282c1.swift:29:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmpqz3282c1.swift:31:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmpqz3282c1.swift:33:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmpqz3282c1.swift:35:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmpqz3282c1.swift:37:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmpqz3282c1.swift:39:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmpqz3282c1.swift:41:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmpqz3282c1.swift:43:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmpqz3282c1.swift:45:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            switch char.lowercased() {\n            case \"a\":\n       \
    \         result += \"A\"\n            case \"b\":\n                result +=\
    \ \"b\"\n            case \"c\":\n                result += \"C\"\n          \
    \  case \"d\":\n                result += \"d\"\n            case \"e\":\n   \
    \             result += \"E\"\n            case \"f\":\n                result\
    \ += \"f\"\n            case \"g\":\n                result += \"G\"\n       \
    \     case \"h\":\n                result += \"h\"\n            case \"i\":\n\
    \                result += \"I\"\n            case \"j\":\n                result\
    \ += \"j\"\n            case \"k\":\n                result += \"K\"\n       \
    \     case \"l\":\n                result += \"L\"\n            case \"m\":\n\
    \                result += \"m\"\n            case \"n\":\n                result\
    \ += \"N\"\n            case \"o\":\n                result += \"o\"\n       \
    \     case \"p\":\n                result += \"P\"\n            case \"q\":\n\
    \                result += \"q\"\n            case \"r\":\n                result\
    \ += \"R\"\n            case \"s\":\n                result += \"s\"\n       \
    \     case \"t\":\n                result += \"T\"\n            case \"u\":\n\
    \                result += \"u\"\n            case \"v\":\n                result\
    \ += \"V\"\n            case \"w\":\n                result += \"w\"\n       \
    \     case \"x\":\n                result += \"x\"\n            case \"y\":\n\
    \                result += \"y\"\n            case \"z\":\n                result\
    \ += \"z\"\n            default:\n                result += char\n           \
    \ }\n        } else {\n            result += char\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp_baroyzf.swift:14:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmp_baroyzf.swift:69:27: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n                result\
    \ += char\n                          ^\n/tmp/tmp_baroyzf.swift:72:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ if char.isLetter {\n            switch char.lowercaseString {\n            case\
    \ \"a\":\n                result += \"A\"\n            case \"b\":\n         \
    \       result += \"b\"\n            case \"c\":\n                result += \"\
    C\"\n            case \"d\":\n                result += \"D\"\n            case\
    \ \"e\":\n                result += \"E\"\n            case \"f\":\n         \
    \       result += \"F\"\n            case \"g\":\n                result += \"\
    G\"\n            case \"h\":\n                result += \"H\"\n            case\
    \ \"i\":\n                result += \"I\"\n            case \"j\":\n         \
    \       result += \"J\"\n            case \"k\":\n                result += \"\
    K\"\n            case \"l\":\n                result += \"L\"\n            case\
    \ \"m\":\n                result += \"M\"\n            case \"n\":\n         \
    \       result += \"N\"\n            case \"o\":\n                result += \"\
    O\"\n            case \"p\":\n                result += \"P\"\n            case\
    \ \"q\":\n                result += \"Q\"\n            case \"r\":\n         \
    \       result += \"R\"\n            case \"s\":\n                result += \"\
    S\"\n            case \"t\":\n                result += \"T\"\n            case\
    \ \"u\":\n                result += \"U\"\n            case \"v\":\n         \
    \       result += \"V\"\n            case \"w\":\n                result += \"\
    W\"\n            case \"x\":\n                result += \"X\"\n            case\
    \ \"y\":\n                result += \"Y\"\n            case \"z\":\n         \
    \       result += \"Z\"\n            default:\n                result += char\n\
    \            }\n        } else {\n            result += char\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpgv7j8sm2.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpgv7j8sm2.swift:15:25:\
    \ error: value of type 'Character' has no member 'lowercaseString'\n         \
    \   switch char.lowercaseString {\n                   ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpgv7j8sm2.swift:69:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                result += char\n                          ^\n/tmp/tmpgv7j8sm2.swift:72:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case 'a':\n            result += \"A\"\n        case\
    \ 'b':\n            result += \"b\"\n        case 'c':\n            result +=\
    \ \"C\"\n        case 'd':\n            result += \"d\"\n        case 'e':\n \
    \           result += \"E\"\n        case 'f':\n            result += \"f\"\n\
    \        case 'g':\n            result += \"G\"\n        case 'h':\n         \
    \   result += \"H\"\n        case 'i':\n            result += \"I\"\n        case\
    \ 'j':\n            result += \"J\"\n        case 'k':\n            result +=\
    \ \"K\"\n        case 'l':\n            result += \"L\"\n        case 'm':\n \
    \           result += \"M\"\n        case 'n':\n            result += \"N\"\n\
    \        case 'o':\n            result += \"O\"\n        case 'p':\n         \
    \   result += \"P\"\n        case 'q':\n            result += \"Q\"\n        case\
    \ 'r':\n            result += \"R\"\n        case 's':\n            result +=\
    \ \"S\"\n        case 't':\n            result += \"T\"\n        case 'u':\n \
    \           result += \"U\"\n        case 'v':\n            result += \"V\"\n\
    \        case 'w':\n            result += \"W\"\n        case 'x':\n         \
    \   result += \"X\"\n        case 'y':\n            result += \"Y\"\n        case\
    \ 'z':\n            result += \"Z\"\n        default:\n            result += String(char)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpf7lr1lta.swift:15:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpf7lr1lta.swift:17:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmpf7lr1lta.swift:19:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmpf7lr1lta.swift:21:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmpf7lr1lta.swift:23:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpf7lr1lta.swift:25:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmpf7lr1lta.swift:27:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmpf7lr1lta.swift:29:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmpf7lr1lta.swift:31:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmpf7lr1lta.swift:33:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmpf7lr1lta.swift:35:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmpf7lr1lta.swift:37:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmpf7lr1lta.swift:39:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmpf7lr1lta.swift:41:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmpf7lr1lta.swift:43:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmpf7lr1lta.swift:45:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var res = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            if char.lowercased() == char {\n                res = char.uppercased()\n\
    \            } else {\n                res = char.lowercased()\n            }\n\
    \        } else {\n            res = char\n        }\n    }\n    return res\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp1au9bju7.swift:14:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmp1au9bju7.swift:15:34: error: binary operator '=='\
    \ cannot be applied to operands of type 'String' and 'Character'\n           \
    \ if char.lowercased() == char {\n               ~~~~~~~~~~~~~~~~~ ^  ~~~~\n/tmp/tmp1au9bju7.swift:15:34:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n            if char.lowercased() ==\
    \ char {\n                                 ^\n/tmp/tmp1au9bju7.swift:21:19: error:\
    \ cannot assign value of type 'Character' to type 'String'\n            res =\
    \ char\n                  ^~~~\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    return s.characters.reversed().reduce(\"\") { $0 + String($1)\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpm03cykjf.swift:12:14: error: 'characters' is unavailable: Please\
    \ use String directly\n    return s.characters.reversed().reduce(\"\") { $0 +\
    \ String($1) }\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            let upper = char.uppercased()\n            let lower = char.lowercased()\n\
    \            if upper != nil {\n                result += upper!\n           \
    \ } else {\n                result += lower!\n            }\n        } else {\n\
    \            result += char\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp6v9focj2.swift:14:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmp6v9focj2.swift:17:22: warning: comparing non-optional\
    \ value of type 'String' to 'nil' always returns true\n            if upper !=\
    \ nil {\n               ~~~~~ ^  ~~~\n/tmp/tmp6v9focj2.swift:18:32: error: cannot\
    \ force unwrap value of non-optional type 'String'\n                result +=\
    \ upper!\n                          ~~~~~^\n                               \n\
    /tmp/tmp6v9focj2.swift:20:32: error: cannot force unwrap value of non-optional\
    \ type 'String'\n                result += lower!\n                          ~~~~~^\n\
    \                               \n/tmp/tmp6v9focj2.swift:23:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case 'a':\n            result += \"A\"\n        case\
    \ 'b':\n            result += \"b\"\n        case 'c':\n            result +=\
    \ \"C\"\n        case 'd':\n            result += \"D\"\n        case 'e':\n \
    \           result += \"E\"\n        case 'f':\n            result += \"F\"\n\
    \        case 'g':\n            result += \"G\"\n        case 'h':\n         \
    \   result += \"H\"\n        case 'i':\n            result += \"I\"\n        case\
    \ 'j':\n            result += \"J\"\n        case 'k':\n            result +=\
    \ \"K\"\n        case 'l':\n            result += \"L\"\n        case 'm':\n \
    \           result += \"M\"\n        case 'n':\n            result += \"N\"\n\
    \        case 'o':\n            result += \"O\"\n        case 'p':\n         \
    \   result += \"P\"\n        case 'q':\n            result += \"Q\"\n        case\
    \ 'r':\n            result += \"R\"\n        case 's':\n            result +=\
    \ \"S\"\n        case 't':\n            result += \"T\"\n        case 'u':\n \
    \           result += \"U\"\n        case 'v':\n            result += \"V\"\n\
    \        case 'w':\n            result += \"W\"\n        case 'x':\n         \
    \   result += \"X\"\n        case 'y':\n            result += \"Y\"\n        case\
    \ 'z':\n            result += \"Z\"\n        default:\n            result += char\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpbdfznpt6.swift:15:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpbdfznpt6.swift:17:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmpbdfznpt6.swift:19:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmpbdfznpt6.swift:21:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmpbdfznpt6.swift:23:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpbdfznpt6.swift:25:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmpbdfznpt6.swift:27:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmpbdfznpt6.swift:29:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmpbdfznpt6.swift:31:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmpbdfznpt6.swift:33:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmpbdfznpt6.swift:35:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmpbdfznpt6.swift:37:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmpbdfznpt6.swift:39:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmpbdfznpt6.swift:41:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmpbdfznpt6.swift:43:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmpbdfznpt6.swift:45:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ if char.isLetter() {\n            switch char.lowercased() {\n            case\
    \ \"a\": result = \"A\"; break\n            case \"b\": result = \"b\"; break\n\
    \            case \"c\": result = \"C\"; break\n            case \"d\": result\
    \ = \"d\"; break\n            case \"e\": result = \"E\"; break\n            case\
    \ \"f\": result = \"f\"; break\n            case \"g\": result = \"G\"; break\n\
    \            case \"h\": result = \"H\"; break\n            case \"i\": result\
    \ = \"I\"; break\n            case \"j\": result = \"J\"; break\n            case\
    \ \"k\": result = \"K\"; break\n            case \"l\": result = \"L\"; break\n\
    \            case \"m\": result = \"M\"; break\n            case \"n\": result\
    \ = \"N\"; break\n            case \"o\": result = \"O\"; break\n            case\
    \ \"p\": result = \"P\"; break\n            case \"q\": result = \"Q\"; break\n\
    \            case \"r\": result = \"R\"; break\n            case \"s\": result\
    \ = \"S\"; break\n            case \"t\": result = \"T\"; break\n            case\
    \ \"u\": result = \"U\"; break\n            case \"v\": result = \"V\"; break\n\
    \            case \"w\": result = \"W\"; break\n            case \"x\": result\
    \ = \"X\"; break\n            case \"y\": result = \"Y\"; break\n            case\
    \ \"z\": result = \"Z\"; break\n            default: result = char\n         \
    \   }\n        } else {\n            result = char\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp63b6yafd.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp63b6yafd.swift:14:17:\
    \ error: cannot call value of non-function type 'Bool'\n        if char.isLetter()\
    \ {\n                ^       ~~\n                        \n/tmp/tmp63b6yafd.swift:42:31:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \  default: result = char\n                              ^~~~\n/tmp/tmp63b6yafd.swift:45:22:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \  result = char\n                     ^~~~\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for letter in s {\n        if letter.isLetter()\
    \ {\n            switch letter {\n            case \"A\":\n                result\
    \ += \"a\"\n            case \"a\":\n                result += \"A\"\n       \
    \     case \"B\":\n                result += \"b\"\n            case \"b\":\n\
    \                result += \"B\"\n            case \"C\":\n                result\
    \ += \"c\"\n            case \"c\":\n                result += \"C\"\n       \
    \     case \"D\":\n                result += \"d\"\n            case \"d\":\n\
    \                result += \"D\"\n            case \"E\":\n                result\
    \ += \"e\"\n            case \"e\":\n                result += \"E\"\n       \
    \     case \"F\":\n                result += \"f\"\n            case \"f\":\n\
    \                result += \"F\"\n            case \"G\":\n                result\
    \ += \"g\"\n            case \"g\":\n                result += \"G\"\n       \
    \     case \"H\":\n                result += \"h\"\n            case \"h\":\n\
    \                result += \"H\"\n            case \"I\":\n                result\
    \ += \"i\"\n            case \"i\":\n                result += \"I\"\n       \
    \     case \"J\":\n                result += \"j\"\n            case \"j\":\n\
    \                result += \"J\"\n            case \"K\":\n                result\
    \ += \"k\"\n            case \"k\":\n                result += \"K\"\n       \
    \     case \"L\":\n                result += \"l\"\n            case \"l\":\n\
    \                result += \"L\"\n            case \"M\":\n                result\
    \ += \"m\"\n            case \"m\":\n                result += \"M\"\n       \
    \     case \"N\":\n                result += \"n\"\n            case \"n\":\n\
    \                result += \"N\"\n            case \"O\":\n                result\
    \ += \"o\"\n            case \"o\":\n                result += \"O\"\n       \
    \     case \"P\":\n                result += \"p\"\n            case \"p\":\n\
    \                result += \"P\"\n            case \"Q\":\n                result\
    \ += \"q\"\n            case \"q\":\n                result += \"Q\"\n       \
    \     case \"R\":\n                result += \"r\"\n            case \"r\":\n\
    \                result += \"R\"\n            case \"S\":\n                result\
    \ += \"s\"\n            case \"s\":\n                result += \"S\"\n       \
    \     case \"T\":\n                result += \"t\"\n            case \"t\":\n\
    \                result += \"T\"\n            case \"U\":\n                result\
    \ += \"u\"\n            case \"u\":\n                result += \"U\"\n       \
    \     case \"V\":\n                result += \"v\"\n            case \"v\":\n\
    \                result += \"V\"\n            case \"W\":\n                result\
    \ += \"w\"\n            case \"w\":\n                result += \"W\"\n       \
    \     \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"\
    aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"\
    AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\")\
    \ == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp1mghqdys.swift:131:35: error: expected '}' at end of brace statement\n\
    assert(solve(s: \"#ccc\") == \"#CCC\")\n                                  ^\n\
    /tmp/tmp1mghqdys.swift:14:30: note: to match this opening '{'\n        if letter.isLetter()\
    \ {\n                             ^\n/tmp/tmp1mghqdys.swift:131:35: error: expected\
    \ '}' at end of brace statement\nassert(solve(s: \"#ccc\") == \"#CCC\")\n    \
    \                              ^\n/tmp/tmp1mghqdys.swift:13:21: note: to match\
    \ this opening '{'\n    for letter in s {\n                    ^\n/tmp/tmp1mghqdys.swift:131:35:\
    \ error: expected '}' at end of brace statement\nassert(solve(s: \"#ccc\") ==\
    \ \"#CCC\")\n                                  ^\n/tmp/tmp1mghqdys.swift:11:33:\
    \ note: to match this opening '{'\nfunc solve(s: String) -> String {\n       \
    \                         ^\n/tmp/tmp1mghqdys.swift:14:19: error: cannot call\
    \ value of non-function type 'Bool'\n        if letter.isLetter() {\n        \
    \          ^       ~~\n                          \n/tmp/tmp1mghqdys.swift:15:13:\
    \ error: switch must be exhaustive\n            switch letter {\n            ^\n\
    /tmp/tmp1mghqdys.swift:15:13: note: do you want to add a default clause?\n   \
    \         switch letter {\n            ^\n/tmp/tmp1mghqdys.swift:112:6: error:\
    \ operator functions can only be declared at global or in type scope\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case 'a':\n            result += \"A\"\n        case\
    \ 'b':\n            result += \"b\"\n        case 'c':\n            result +=\
    \ \"C\"\n        case 'd':\n            result += \"d\"\n        case 'e':\n \
    \           result += \"E\"\n        case 'f':\n            result += \"f\"\n\
    \        case 'g':\n            result += \"g\"\n        case 'h':\n         \
    \   result += \"H\"\n        case 'i':\n            result += \"I\"\n        case\
    \ 'j':\n            result += \"J\"\n        case 'k':\n            result +=\
    \ \"K\"\n        case 'l':\n            result += \"L\"\n        case 'm':\n \
    \           result += \"m\"\n        case 'n':\n            result += \"N\"\n\
    \        case 'o':\n            result += \"O\"\n        case 'p':\n         \
    \   result += \"P\"\n        case 'q':\n            result += \"Q\"\n        case\
    \ 'r':\n            result += \"R\"\n        case 's':\n            result +=\
    \ \"S\"\n        case 't':\n            result += \"T\"\n        case 'u':\n \
    \           result += \"U\"\n        case 'v':\n            result += \"V\"\n\
    \        case 'w':\n            result += \"W\"\n        case 'x':\n         \
    \   result += \"X\"\n        case 'y':\n            result += \"Y\"\n        case\
    \ 'z':\n            result += \"Z\"\n        default:\n            result += char\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpb_tpj9y6.swift:15:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpb_tpj9y6.swift:17:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmpb_tpj9y6.swift:19:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmpb_tpj9y6.swift:21:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmpb_tpj9y6.swift:23:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpb_tpj9y6.swift:25:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmpb_tpj9y6.swift:27:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmpb_tpj9y6.swift:29:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmpb_tpj9y6.swift:31:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmpb_tpj9y6.swift:33:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmpb_tpj9y6.swift:35:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmpb_tpj9y6.swift:37:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmpb_tpj9y6.swift:39:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmpb_tpj9y6.swift:41:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmpb_tpj9y6.swift:43:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmpb_tpj9y6.swift:45:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            if char.lowercased() != char {\n                result += char.uppercased()\n\
    \            } else {\n                result += char.lowercased()\n         \
    \   }\n        } else {\n            result += char\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpmnd71lf0.swift:14:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpmnd71lf0.swift:15:37: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n            if char.lowercased()\
    \ != char {\n                                    ^\n/tmp/tmpmnd71lf0.swift:21:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    return s.characters.reversed().reduce(\"\") { $0 + String($1)\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpm03cykjf.swift:12:14: error: 'characters' is unavailable: Please\
    \ use String directly\n    return s.characters.reversed().reduce(\"\") { $0 +\
    \ String($1) }\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            switch char.lowercased() {\n            case \"a\":\n       \
    \         result = \"A\" + result\n            case \"b\":\n                result\
    \ = \"B\" + result\n            case \"c\":\n                result = \"C\" +\
    \ result\n            case \"d\":\n                result = \"D\" + result\n \
    \           case \"e\":\n                result = \"E\" + result\n           \
    \ case \"f\":\n                result = \"F\" + result\n            case \"g\"\
    :\n                result = \"G\" + result\n            case \"h\":\n        \
    \        result = \"H\" + result\n            case \"i\":\n                result\
    \ = \"I\" + result\n            case \"j\":\n                result = \"J\" +\
    \ result\n            case \"k\":\n                result = \"K\" + result\n \
    \           case \"l\":\n                result = \"L\" + result\n           \
    \ case \"m\":\n                result = \"M\" + result\n            case \"n\"\
    :\n                result = \"N\" + result\n            case \"o\":\n        \
    \        result = \"O\" + result\n            case \"p\":\n                result\
    \ = \"P\" + result\n            case \"q\":\n                result = \"Q\" +\
    \ result\n            case \"r\":\n                result = \"R\" + result\n \
    \           case \"s\":\n                result = \"S\" + result\n           \
    \ case \"t\":\n                result = \"T\" + result\n            case \"u\"\
    :\n                result = \"U\" + result\n            case \"v\":\n        \
    \        result = \"V\" + result\n            case \"w\":\n                result\
    \ = \"W\" + result\n            case \"x\":\n                result = \"X\" +\
    \ result\n            case \"y\":\n                result = \"Y\" + result\n \
    \           case \"z\":\n                result = \"Z\" + result\n           \
    \ default:\n                result = \"0\" + result\n            }\n        }\
    \ else {\n            result = char + result\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpyp_88gpo.swift:14:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpyp_88gpo.swift:72:22: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n            result =\
    \ char + result\n                     ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var res = \"\"\n    for char in s.characters {\n        if\
    \ char.isLetter {\n            res = char.uppercaseString + res\n        } else\
    \ {\n            res = char + res\n        }\n    }\n    return res\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpwp091_rl.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpwp091_rl.swift:15:24:\
    \ error: value of type 'Character' has no member 'uppercaseString'\n         \
    \   res = char.uppercaseString + res\n                  ~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmpwp091_rl.swift:17:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            res = char + res\n         \
    \         ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            switch char {\n            case \"a\": result = \"A\"; break\n\
    \            case \"b\": result = \"b\"; break\n            case \"c\": result\
    \ = \"C\"; break\n            case \"d\": result = \"d\"; break\n            case\
    \ \"e\": result = \"E\"; break\n            case \"f\": result = \"f\"; break\n\
    \            case \"g\": result = \"G\"; break\n            case \"h\": result\
    \ = \"H\"; break\n            case \"i\": result = \"I\"; break\n            case\
    \ \"j\": result = \"J\"; break\n            case \"k\": result = \"K\"; break\n\
    \            case \"l\": result = \"L\"; break\n            case \"m\": result\
    \ = \"M\"; break\n            case \"n\": result = \"N\"; break\n            case\
    \ \"o\": result = \"O\"; break\n            case \"p\": result = \"P\"; break\n\
    \            case \"q\": result = \"Q\"; break\n            case \"r\": result\
    \ = \"R\"; break\n            case \"s\": result = \"S\"; break\n            case\
    \ \"t\": result = \"T\"; break\n            case \"u\": result = \"U\"; break\n\
    \            case \"v\": result = \"V\"; break\n            case \"w\": result\
    \ = \"W\"; break\n            case \"x\": result = \"X\"; break\n            case\
    \ \"y\": result = \"Y\"; break\n            case \"z\": result = \"Z\"; break\n\
    \            default:\n                result = \"\\(char)\\(char)\\(char)\\(char)\\\
    (char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\\
    (char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\\
    (char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\\
    (char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\\
    (char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\\
    (char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\\
    (char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\\
    (char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\\
    (char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\\
    (char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\\
    (char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\\
    (char)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"\
    aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"\
    AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\")\
    \ == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpdxgm3qjq.swift:43:26: error: unterminated string literal\n    \
    \            result = \"\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\\
    (char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\\
    (char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\\
    (char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\\
    (char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\\
    (char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\\
    (char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\\
    (char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\\
    (char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\\
    (char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\\
    (char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\\
    (char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\\(char)\n             \
    \            ^\n/tmp/tmpdxgm3qjq.swift:66:35: error: expected '}' at end of brace\
    \ statement\nassert(solve(s: \"#ccc\") == \"#CCC\")\n                        \
    \          ^\n/tmp/tmpdxgm3qjq.swift:14:28: note: to match this opening '{'\n\
    \        if char.isLetter() {\n                           ^\n/tmp/tmpdxgm3qjq.swift:66:35:\
    \ error: expected '}' at end of brace statement\nassert(solve(s: \"#ccc\") ==\
    \ \"#CCC\")\n                                  ^\n/tmp/tmpdxgm3qjq.swift:13:19:\
    \ note: to match this opening '{'\n    for char in s {\n                  ^\n\
    /tmp/tmpdxgm3qjq.swift:66:35: error: expected '}' at end of brace statement\n\
    assert(solve(s: \"#ccc\") == \"#CCC\")\n                                  ^\n\
    /tmp/tmpdxgm3qjq.swift:11:33: note: to match this opening '{'\nfunc solve(s: String)\
    \ -> String {\n                                ^\n/tmp/tmpdxgm3qjq.swift:14:17:\
    \ error: cannot call value of non-function type 'Bool'\n        if char.isLetter()\
    \ {\n                ^       ~~\n                        \n/tmp/tmpdxgm3qjq.swift:47:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     "
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case let c as Character:\n            switch c {\n  \
    \          case .lowercase:\n                result += \"\\(c)\"\n           \
    \ case .uppercase:\n                result += \"\\(c)\"\n            case .digit:\n\
    \                result += \"\\(c)\"\n            case .other:\n             \
    \   result += String(c)\n            }\n        case let c as String:\n      \
    \      result += String(c)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpo434ow84.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpo434ow84.swift:15:20:\
    \ warning: 'as' test is always true\n        case let c as Character:\n      \
    \             ^\n/tmp/tmpo434ow84.swift:26:20: warning: cast from 'Character'\
    \ to unrelated type 'String' always fails\n        case let c as String:\n   \
    \                ^~ ~~~~~~\n/tmp/tmpo434ow84.swift:17:19: error: type 'Character'\
    \ has no member 'lowercase'\n            case .lowercase:\n                 ~^~~~~~~~~\n\
    /tmp/tmpo434ow84.swift:19:19: error: type 'Character' has no member 'uppercase'\n\
    \            case .uppercase:\n                 ~^~~~~~~~~\n/tmp/tmpo434ow84.swift:21:19:\
    \ error: type 'Character' has no member 'digit'\n            case .digit:\n  \
    \               ~^~~~~\n/tmp/tmpo434ow84.swift:23:19: error: type 'Character'\
    \ has no member 'other'\n            case .other:\n                 ~^~~~~\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case 'a':\n            result += \"A\"\n        case\
    \ 'b':\n            result += \"b\"\n        case 'c':\n            result +=\
    \ \"C\"\n        case 'd':\n            result += \"d\"\n        case 'e':\n \
    \           result += \"E\"\n        case 'f':\n            result += \"f\"\n\
    \        case 'g':\n            result += \"G\"\n        case 'h':\n         \
    \   result += \"h\"\n        case 'i':\n            result += \"I\"\n        case\
    \ 'j':\n            result += \"j\"\n        case 'k':\n            result +=\
    \ \"K\"\n        case 'l':\n            result += \"L\"\n        case 'm':\n \
    \           result += \"m\"\n        case 'n':\n            result += \"N\"\n\
    \        case 'o':\n            result += \"O\"\n        case 'p':\n         \
    \   result += \"p\"\n        case 'q':\n            result += \"Q\"\n        case\
    \ 'r':\n            result += \"r\"\n        case 's':\n            result +=\
    \ \"S\"\n        case 't':\n            result += \"T\"\n        case 'u':\n \
    \           result += \"U\"\n        case 'v':\n            result += \"V\"\n\
    \        case 'w':\n            result += \"W\"\n        case 'x':\n         \
    \   result += \"X\"\n        case 'y':\n            result += \"Y\"\n        case\
    \ 'z':\n            result += \"Z\"\n        default:\n            result += char\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpw_8mezy_.swift:15:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpw_8mezy_.swift:17:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmpw_8mezy_.swift:19:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmpw_8mezy_.swift:21:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmpw_8mezy_.swift:23:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpw_8mezy_.swift:25:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmpw_8mezy_.swift:27:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmpw_8mezy_.swift:29:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmpw_8mezy_.swift:31:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmpw_8mezy_.swift:33:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmpw_8mezy_.swift:35:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmpw_8mezy_.swift:37:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmpw_8mezy_.swift:39:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmpw_8mezy_.swift:41:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmpw_8mezy_.swift:43:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmpw_8mezy_.swift:45:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ if char.isLetter {\n            let upper = char.uppercaseString\n         \
    \   let lower = char.lowercaseString\n            if upper != lower  {\n     \
    \           result += upper\n            } else {\n                result += lower\n\
    \            }\n        } else {\n            result += char\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp0a2d12fc.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp0a2d12fc.swift:15:30:\
    \ error: value of type 'Character' has no member 'uppercaseString'\n         \
    \   let upper = char.uppercaseString\n                        ~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmp0a2d12fc.swift:16:30: error: value of type 'Character' has no member 'lowercaseString'\n\
    \            let lower = char.lowercaseString\n                        ~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmp0a2d12fc.swift:23:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case 'a':\n            result += \"A\"\n        case\
    \ 'b':\n            result += \"b\"\n        case 'c':\n            result +=\
    \ \"C\"\n        case 'd':\n            result += \"d\"\n        case 'e':\n \
    \           result += \"E\"\n        case 'f':\n            result += \"f\"\n\
    \        case 'g':\n            result += \"G\"\n        case 'h':\n         \
    \   result += \"h\"\n        case 'i':\n            result += \"I\"\n        case\
    \ 'j':\n            result += \"j\"\n        case 'k':\n            result +=\
    \ \"K\"\n        case 'l':\n            result += \"L\"\n        case 'm':\n \
    \           result += \"m\"\n        case 'n':\n            result += \"N\"\n\
    \        case 'o':\n            result += \"O\"\n        case 'p':\n         \
    \   result += \"p\"\n        case 'q':\n            result += \"Q\"\n        case\
    \ 'r':\n            result += \"r\"\n        case 's':\n            result +=\
    \ \"S\"\n        case 't':\n            result += \"T\"\n        case 'u':\n \
    \           result += \"U\"\n        case 'v':\n            result += \"V\"\n\
    \        case 'w':\n            result += \"W\"\n        case 'x':\n         \
    \   result += \"X\"\n        case 'y':\n            result += \"Y\"\n        case\
    \ 'z':\n            result += \"Z\"\n        default:\n            result += String(char)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpgnnuyazy.swift:15:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpgnnuyazy.swift:17:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmpgnnuyazy.swift:19:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmpgnnuyazy.swift:21:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmpgnnuyazy.swift:23:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpgnnuyazy.swift:25:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmpgnnuyazy.swift:27:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmpgnnuyazy.swift:29:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmpgnnuyazy.swift:31:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmpgnnuyazy.swift:33:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmpgnnuyazy.swift:35:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmpgnnuyazy.swift:37:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmpgnnuyazy.swift:39:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmpgnnuyazy.swift:41:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmpgnnuyazy.swift:43:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmpgnnuyazy.swift:45:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        switch char\
    \ {\n        case \"a\":\n            result += \"A\"\n        case \"b\":\n \
    \           result += \"b\"\n        case \"c\":\n            result += \"C\"\n\
    \        case \"d\":\n            result += \"D\"\n        case \"e\":\n     \
    \       result += \"E\"\n        case \"f\":\n            result += \"F\"\n  \
    \      case \"g\":\n            result += \"G\"\n        case \"h\":\n       \
    \     result += \"H\"\n        case \"i\":\n            result += \"I\"\n    \
    \    case \"j\":\n            result += \"J\"\n        case \"k\":\n         \
    \   result += \"K\"\n        case \"l\":\n            result += \"L\"\n      \
    \  case \"m\":\n            result += \"M\"\n        case \"n\":\n           \
    \ result += \"N\"\n        case \"o\":\n            result += \"O\"\n        case\
    \ \"p\":\n            result += \"P\"\n        case \"q\":\n            result\
    \ += \"Q\"\n        case \"r\":\n            result += \"R\"\n        case \"\
    s\":\n            result += \"S\"\n        case \"t\":\n            result +=\
    \ \"T\"\n        case \"u\":\n            result += \"U\"\n        case \"v\"\
    :\n            result += \"V\"\n        case \"w\":\n            result += \"\
    W\"\n        case \"x\":\n            result += \"X\"\n        case \"y\":\n \
    \           result += \"Y\"\n        case \"z\":\n            result += \"Z\"\n\
    \        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpv3q437oa.swift:68:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ if char.isLetter {\n            switch char.lowercaseString {\n            case\
    \ \"a\":\n                result += \"A\"\n            case \"b\":\n         \
    \       result += \"b\"\n            case \"c\":\n                result += \"\
    C\"\n            case \"d\":\n                result += \"d\"\n            case\
    \ \"e\":\n                result += \"E\"\n            case \"f\":\n         \
    \       result += \"f\"\n            case \"g\":\n                result += \"\
    g\"\n            case \"h\":\n                result += \"H\"\n            case\
    \ \"i\":\n                result += \"I\"\n            case \"j\":\n         \
    \       result += \"J\"\n            case \"k\":\n                result += \"\
    K\"\n            case \"l\":\n                result += \"L\"\n            case\
    \ \"m\":\n                result += \"m\"\n            case \"n\":\n         \
    \       result += \"N\"\n            case \"o\":\n                result += \"\
    O\"\n            case \"p\":\n                result += \"P\"\n            case\
    \ \"q\":\n                result += \"Q\"\n            case \"r\":\n         \
    \       result += \"R\"\n            case \"s\":\n                result += \"\
    S\"\n            case \"t\":\n                result += \"T\"\n            case\
    \ \"u\":\n                result += \"U\"\n            case \"v\":\n         \
    \       result += \"V\"\n            case \"w\":\n                result += \"\
    W\"\n            case \"x\":\n                result += \"X\"\n            case\
    \ \"y\":\n                result += \"Y\"\n            case \"z\":\n         \
    \       result += \"Z\"\n            default:\n                result += char.lowercaseString\n\
    \            }\n        } else {\n            result += char\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpt1yffb5z.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpt1yffb5z.swift:15:25:\
    \ error: value of type 'Character' has no member 'lowercaseString'\n         \
    \   switch char.lowercaseString {\n                   ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpt1yffb5z.swift:69:32:\
    \ error: value of type 'Character' has no member 'lowercaseString'\n         \
    \       result += char.lowercaseString\n                          ~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmpt1yffb5z.swift:72:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        switch char\
    \ {\n        case \"a\":\n            result += \"A\"\n        case \"b\":\n \
    \           result += \"b\"\n        case \"c\":\n            result += \"C\"\n\
    \        case \"d\":\n            result += \"D\"\n        case \"e\":\n     \
    \       result += \"E\"\n        case \"f\":\n            result += \"F\"\n  \
    \      case \"g\":\n            result += \"G\"\n        case \"h\":\n       \
    \     result += \"H\"\n        case \"i\":\n            result += \"I\"\n    \
    \    case \"j\":\n            result += \"J\"\n        case \"k\":\n         \
    \   result += \"K\"\n        case \"l\":\n            result += \"L\"\n      \
    \  case \"m\":\n            result += \"M\"\n        case \"n\":\n           \
    \ result += \"N\"\n        case \"o\":\n            result += \"O\"\n        case\
    \ \"p\":\n            result += \"P\"\n        case \"q\":\n            result\
    \ += \"Q\"\n        case \"r\":\n            result += \"R\"\n        case \"\
    s\":\n            result += \"S\"\n        case \"t\":\n            result +=\
    \ \"T\"\n        case \"u\":\n            result += \"U\"\n        case \"v\"\
    :\n            result += \"V\"\n        case \"w\":\n            result += \"\
    W\"\n        case \"x\":\n            result += \"X\"\n        case \"y\":\n \
    \           result += \"Y\"\n        case \"z\":\n            result += \"Z\"\n\
    \        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpv3q437oa.swift:68:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case 'a':\n            result += \"A\"\n        case\
    \ 'b':\n            result += \"b\"\n        case 'c':\n            result +=\
    \ \"C\"\n        case 'd':\n            result += \"d\"\n        case 'e':\n \
    \           result += \"E\"\n        case 'f':\n            result += \"f\"\n\
    \        case 'g':\n            result += \"G\"\n        case 'h':\n         \
    \   result += \"H\"\n        case 'i':\n            result += \"I\"\n        case\
    \ 'j':\n            result += \"J\"\n        case 'k':\n            result +=\
    \ \"K\"\n        case 'l':\n            result += \"L\"\n        case 'm':\n \
    \           result += \"m\"\n        case 'n':\n            result += \"N\"\n\
    \        case 'o':\n            result += \"O\"\n        case 'p':\n         \
    \   result += \"P\"\n        case 'q':\n            result += \"Q\"\n        case\
    \ 'r':\n            result += \"R\"\n        case 's':\n            result +=\
    \ \"S\"\n        case 't':\n            result += \"T\"\n        case 'u':\n \
    \           result += \"U\"\n        case 'v':\n            result += \"V\"\n\
    \        case 'w':\n            result += \"W\"\n        case 'x':\n         \
    \   result += \"X\"\n        case 'y':\n            result += \"Y\"\n        case\
    \ 'z':\n            result += \"Z\"\n        default:\n            result += char\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp1linqd6_.swift:15:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmp1linqd6_.swift:17:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmp1linqd6_.swift:19:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmp1linqd6_.swift:21:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmp1linqd6_.swift:23:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmp1linqd6_.swift:25:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmp1linqd6_.swift:27:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmp1linqd6_.swift:29:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmp1linqd6_.swift:31:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmp1linqd6_.swift:33:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmp1linqd6_.swift:35:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmp1linqd6_.swift:37:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmp1linqd6_.swift:39:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmp1linqd6_.swift:41:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmp1linqd6_.swift:43:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmp1linqd6_.swift:45:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for letter in s {\n        if letter.isLetter()\
    \ {\n            if letter.isUpper() {\n                result += String(letter.toUpper())\n\
    \            } else {\n                result += String(letter.toLower())\n  \
    \          }\n        } else {\n            result += letter\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmptins_e52.swift:14:19: error: cannot call value of non-function\
    \ type 'Bool'\n        if letter.isLetter() {\n                  ^       ~~\n\
    \                          \n/tmp/tmptins_e52.swift:15:23: error: value of type\
    \ 'Character' has no member 'isUpper'\n            if letter.isUpper() {\n   \
    \            ~~~~~~ ^~~~~~~\n/tmp/tmptins_e52.swift:16:41: error: value of type\
    \ 'Character' has no member 'toUpper'\n                result += String(letter.toUpper())\n\
    \                                 ~~~~~~ ^~~~~~~\n/tmp/tmptins_e52.swift:18:41:\
    \ error: value of type 'Character' has no member 'toLower'\n                result\
    \ += String(letter.toLower())\n                                 ~~~~~~ ^~~~~~~\n\
    /tmp/tmptins_e52.swift:21:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += letter\n         \
    \             ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter\
    \ {\n            switch char.unicodeScalars.lowercased() {\n            case .uppercase\
    \ , .lowercase:\n                result += char.unicodeScalars.uppercased()\n\
    \            case .other:\n                result += char\n            }\n   \
    \     } else {\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpqang8sj1.swift:15:40: error: value of type 'Character.UnicodeScalarView'\
    \ (aka 'String.UnicodeScalarView') has no member 'lowercased'\n            switch\
    \ char.unicodeScalars.lowercased() {\n                   ~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpqang8sj1.swift:17:47: error: value of type 'Character.UnicodeScalarView'\
    \ (aka 'String.UnicodeScalarView') has no member 'uppercased'\n              \
    \  result += char.unicodeScalars.uppercased()\n                          ~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpqang8sj1.swift:19:27: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n                result += char\n\
    \                          ^\n/tmp/tmpqang8sj1.swift:22:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case let c as Character:\n            switch c {\n  \
    \          case .lowercase:\n                result += \"\\(c)\"\n           \
    \ case .uppercase:\n                result += \"\\(c)\"\n            default:\n\
    \                result += char\n            }\n        case let c as String:\n\
    \            result += c\n        default:\n            result += char\n     \
    \   }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s:\
    \ \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpg6wnfyuw.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpg6wnfyuw.swift:15:20:\
    \ warning: 'as' test is always true\n        case let c as Character:\n      \
    \             ^\n/tmp/tmpg6wnfyuw.swift:24:20: warning: cast from 'Character'\
    \ to unrelated type 'String' always fails\n        case let c as String:\n   \
    \                ^~ ~~~~~~\n/tmp/tmpg6wnfyuw.swift:17:19: error: type 'Character'\
    \ has no member 'lowercase'\n            case .lowercase:\n                 ~^~~~~~~~~\n\
    /tmp/tmpg6wnfyuw.swift:19:19: error: type 'Character' has no member 'uppercase'\n\
    \            case .uppercase:\n                 ~^~~~~~~~~\n/tmp/tmpg6wnfyuw.swift:22:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                result += char\n                          ^\n/tmp/tmpg6wnfyuw.swift:27:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    return s.characters.reduce(\"\") { $0 + String($1).capitalized\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpoxmp5yi_.swift:12:54: error: value of type 'String' has no member\
    \ 'capitalized'\n    return s.characters.reduce(\"\") { $0 + String($1).capitalized\
    \ }\n                                          ~~~~~~~~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case 'a':\n            result += \"A\"\n        case\
    \ 'b':\n            result += \"b\"\n        case 'c':\n            result +=\
    \ \"C\"\n        case 'd':\n            result += \"D\"\n        case 'e':\n \
    \           result += \"E\"\n        case 'f':\n            result += \"F\"\n\
    \        case 'g':\n            result += \"G\"\n        case 'h':\n         \
    \   result += \"H\"\n        case 'i':\n            result += \"I\"\n        case\
    \ 'j':\n            result += \"J\"\n        case 'k':\n            result +=\
    \ \"K\"\n        case 'l':\n            result += \"L\"\n        case 'm':\n \
    \           result += \"M\"\n        case 'n':\n            result += \"N\"\n\
    \        case 'o':\n            result += \"O\"\n        case 'p':\n         \
    \   result += \"P\"\n        case 'q':\n            result += \"Q\"\n        case\
    \ 'r':\n            result += \"R\"\n        case 's':\n            result +=\
    \ \"S\"\n        case 't':\n            result += \"T\"\n        case 'u':\n \
    \           result += \"U\"\n        case 'v':\n            result += \"V\"\n\
    \        case 'w':\n            result += \"W\"\n        case 'x':\n         \
    \   result += \"X\"\n        case 'y':\n            result += \"Y\"\n        case\
    \ 'z':\n            result += \"Z\"\n        default:\n            result += char\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpbdfznpt6.swift:15:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpbdfznpt6.swift:17:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmpbdfznpt6.swift:19:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmpbdfznpt6.swift:21:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmpbdfznpt6.swift:23:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpbdfznpt6.swift:25:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmpbdfznpt6.swift:27:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmpbdfznpt6.swift:29:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmpbdfznpt6.swift:31:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmpbdfznpt6.swift:33:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmpbdfznpt6.swift:35:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmpbdfznpt6.swift:37:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmpbdfznpt6.swift:39:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmpbdfznpt6.swift:41:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmpbdfznpt6.swift:43:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmpbdfznpt6.swift:45:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            switch char.lowercased() {\n            case \"a\":\n       \
    \         result += \"A\"\n            case \"b\":\n                result +=\
    \ \"b\"\n            case \"c\":\n                result += \"C\"\n          \
    \  case \"d\":\n                result += \"D\"\n            case \"e\":\n   \
    \             result += \"E\"\n            case \"f\":\n                result\
    \ += \"F\"\n            case \"g\":\n                result += \"G\"\n       \
    \     case \"h\":\n                result += \"H\"\n            case \"i\":\n\
    \                result += \"I\"\n            case \"j\":\n                result\
    \ += \"J\"\n            case \"k\":\n                result += \"K\"\n       \
    \     case \"l\":\n                result += \"L\"\n            case \"m\":\n\
    \                result += \"M\"\n            case \"n\":\n                result\
    \ += \"N\"\n            case \"o\":\n                result += \"O\"\n       \
    \     case \"p\":\n                result += \"P\"\n            case \"q\":\n\
    \                result += \"Q\"\n            case \"r\":\n                result\
    \ += \"R\"\n            case \"s\":\n                result += \"S\"\n       \
    \     case \"t\":\n                result += \"T\"\n            case \"u\":\n\
    \                result += \"U\"\n            case \"v\":\n                result\
    \ += \"V\"\n            case \"w\":\n                result += \"W\"\n       \
    \     case \"x\":\n                result += \"X\"\n            case \"y\":\n\
    \                result += \"Y\"\n            case \"z\":\n                result\
    \ += \"Z\"\n            default:\n                result += char\n           \
    \ }\n        } else {\n            result += char\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpggdipbze.swift:14:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpggdipbze.swift:69:27: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n                result\
    \ += char\n                          ^\n/tmp/tmpggdipbze.swift:72:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ if let c = Character(char) {\n            switch c.caseInsensitiveCompare(Character(result))\
    \ {\n            case .orderedAscending:\n                result += c.lowercaseString\n\
    \            case .orderedSame:\n                result += c.lowercaseString\n\
    \            case .orderedDescending:\n                result += c.uppercaseString\n\
    \            case .orderedSame:\n                result += c.uppercaseString\n\
    \            }\n        } else {\n            result += char\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpapduc78p.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpapduc78p.swift:14:30:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \      if let c = Character(char) {\n                             ^\n        \
    \                     extendedGraphemeClusterLiteral: \n/tmp/tmpapduc78p.swift:26:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    return s.characters.reversed().reduce(\"\") { $0 + String($1)\
    \ + String($2) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp8mjtn441.swift:12:12: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n    return s.characters.reversed().reduce(\"\") { $0 + String($1)\
    \ + String($2) }\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659825115
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            switch char.lowercased() {\n            case \"a\":\n       \
    \         result += \"A\"\n            case \"b\":\n                result +=\
    \ \"b\"\n            case \"c\":\n                result += \"C\"\n          \
    \  case \"d\":\n                result += \"D\"\n            case \"e\":\n   \
    \             result += \"E\"\n            case \"f\":\n                result\
    \ += \"F\"\n            case \"g\":\n                result += \"G\"\n       \
    \     case \"h\":\n                result += \"H\"\n            case \"i\":\n\
    \                result += \"I\"\n            case \"j\":\n                result\
    \ += \"J\"\n            case \"k\":\n                result += \"K\"\n       \
    \     case \"l\":\n                result += \"L\"\n            case \"m\":\n\
    \                result += \"M\"\n            case \"n\":\n                result\
    \ += \"N\"\n            case \"o\":\n                result += \"O\"\n       \
    \     case \"p\":\n                result += \"P\"\n            case \"q\":\n\
    \                result += \"Q\"\n            case \"r\":\n                result\
    \ += \"R\"\n            case \"s\":\n                result += \"S\"\n       \
    \     case \"t\":\n                result += \"T\"\n            case \"u\":\n\
    \                result += \"U\"\n            case \"v\":\n                result\
    \ += \"V\"\n            case \"w\":\n                result += \"W\"\n       \
    \     case \"x\":\n                result += \"X\"\n            case \"y\":\n\
    \                result += \"Y\"\n            case \"z\":\n                result\
    \ += \"Z\"\n            default:\n                result += char\n           \
    \ }\n        } else {\n            result += char\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpggdipbze.swift:14:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpggdipbze.swift:69:27: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n                result\
    \ += char\n                          ^\n/tmp/tmpggdipbze.swift:72:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            switch char.lowercased() {\n            case \"a\": result =\
    \ \"A\" + result\n            case \"b\": result = \"B\" + result\n          \
    \  case \"c\": result = \"C\" + result\n            case \"d\": result = \"D\"\
    \ + result\n            case \"e\": result = \"E\" + result\n            case\
    \ \"f\": result = \"F\" + result\n            case \"g\": result = \"G\" + result\n\
    \            case \"h\": result = \"H\" + result\n            case \"i\": result\
    \ = \"I\" + result\n            case \"j\": result = \"J\" + result\n        \
    \    case \"k\": result = \"K\" + result\n            case \"l\": result = \"\
    L\" + result\n            case \"m\": result = \"M\" + result\n            case\
    \ \"n\": result = \"N\" + result\n            case \"o\": result = \"O\" + result\n\
    \            case \"p\": result = \"P\" + result\n            case \"q\": result\
    \ = \"Q\" + result\n            case \"r\": result = \"R\" + result\n        \
    \    case \"s\": result = \"S\" + result\n            case \"t\": result = \"\
    T\" + result\n            case \"u\": result = \"U\" + result\n            case\
    \ \"v\": result = \"V\" + result\n            case \"w\": result = \"W\" + result\n\
    \            case \"x\": result = \"X\" + result\n            case \"y\": result\
    \ = \"Y\" + result\n            case \"z\": result = \"Z\" + result\n        \
    \    default: result = \"a\" + result\n            }\n        } else {\n     \
    \       result = char + result\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp5dvbakap.swift:14:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmp5dvbakap.swift:45:22: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n            result =\
    \ char + result\n                     ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ if char.isLetter {\n            switch char.lowercaseString {\n            case\
    \ \"a\":\n                result += \"A\"\n            case \"b\":\n         \
    \       result += \"b\"\n            case \"c\":\n                result += \"\
    C\"\n            case \"d\":\n                result += \"d\"\n            case\
    \ \"e\":\n                result += \"E\"\n            case \"f\":\n         \
    \       result += \"f\"\n            case \"g\":\n                result += \"\
    g\"\n            case \"h\":\n                result += \"H\"\n            case\
    \ \"i\":\n                result += \"I\"\n            case \"j\":\n         \
    \       result += \"J\"\n            case \"k\":\n                result += \"\
    K\"\n            case \"l\":\n                result += \"L\"\n            case\
    \ \"m\":\n                result += \"m\"\n            case \"n\":\n         \
    \       result += \"N\"\n            case \"o\":\n                result += \"\
    O\"\n            case \"p\":\n                result += \"P\"\n            case\
    \ \"q\":\n                result += \"Q\"\n            case \"r\":\n         \
    \       result += \"R\"\n            case \"s\":\n                result += \"\
    S\"\n            case \"t\":\n                result += \"T\"\n            case\
    \ \"u\":\n                result += \"U\"\n            case \"v\":\n         \
    \       result += \"V\"\n            case \"w\":\n                result += \"\
    W\"\n            case \"x\":\n                result += \"X\"\n            case\
    \ \"y\":\n                result += \"Y\"\n            case \"z\":\n         \
    \       result += \"Z\"\n            default:\n                result += char\n\
    \            }\n        } else {\n            result += char\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp944ki4w6.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp944ki4w6.swift:15:25:\
    \ error: value of type 'Character' has no member 'lowercaseString'\n         \
    \   switch char.lowercaseString {\n                   ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmp944ki4w6.swift:69:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                result += char\n                          ^\n/tmp/tmp944ki4w6.swift:72:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    return s.characters.reversed().reduce(\"\") { $0 + String($1)\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpm03cykjf.swift:12:14: error: 'characters' is unavailable: Please\
    \ use String directly\n    return s.characters.reversed().reduce(\"\") { $0 +\
    \ String($1) }\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    return s.characters.reversed().reduce(\"\") { (result, element)\
    \ -> String in\n        if element == nil {\n            return result\n     \
    \   }\n        \n        if let c = element as? Character {\n            let upperCase\
    \ = c.uppercased()\n            return result + upperCase\n        }\n       \
    \ \n        return result + element\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmplee9fxz_.swift:22:25: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to expected argument type 'String'\n        return result\
    \ + element\n                        ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        switch char\
    \ {\n        case \"a\":\n            result += \"A\"\n        case \"b\":\n \
    \           result += \"b\"\n        case \"c\":\n            result += \"C\"\n\
    \        case \"d\":\n            result += \"D\"\n        case \"e\":\n     \
    \       result += \"E\"\n        case \"f\":\n            result += \"F\"\n  \
    \      case \"g\":\n            result += \"G\"\n        case \"h\":\n       \
    \     result += \"H\"\n        case \"i\":\n            result += \"I\"\n    \
    \    case \"j\":\n            result += \"J\"\n        case \"k\":\n         \
    \   result += \"K\"\n        case \"l\":\n            result += \"L\"\n      \
    \  case \"m\":\n            result += \"M\"\n        case \"n\":\n           \
    \ result += \"N\"\n        case \"o\":\n            result += \"O\"\n        case\
    \ \"p\":\n            result += \"P\"\n        case \"q\":\n            result\
    \ += \"Q\"\n        case \"r\":\n            result += \"R\"\n        case \"\
    s\":\n            result += \"S\"\n        case \"t\":\n            result +=\
    \ \"T\"\n        case \"u\":\n            result += \"U\"\n        case \"v\"\
    :\n            result += \"V\"\n        case \"w\":\n            result += \"\
    W\"\n        case \"x\":\n            result += \"X\"\n        case \"y\":\n \
    \           result += \"Y\"\n        case \"z\":\n            result += \"Z\"\n\
    \        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpv3q437oa.swift:68:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    return s.characters.reversed().reduce(\"\") { $0 + String($1)\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpm03cykjf.swift:12:14: error: 'characters' is unavailable: Please\
    \ use String directly\n    return s.characters.reversed().reduce(\"\") { $0 +\
    \ String($1) }\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case 'a':\n        case 'b':\n        case 'c':\n   \
    \     case 'd':\n        case 'e':\n        case 'f':\n        case 'g':\n   \
    \     case 'h':\n        case 'i':\n        case 'j':\n        case 'k':\n   \
    \     case 'l':\n        case 'm':\n        case 'n':\n        case 'o':\n   \
    \     case 'p':\n        case 'q':\n        case 'r':\n        case 's':\n   \
    \     case 't':\n        case 'u':\n        case 'v':\n        case 'w':\n   \
    \     case 'x':\n        case 'y':\n        case 'z':\n            result += String(char.uppercase)\n\
    \        default:\n            result += String(char)\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpupt1bfev.swift:15:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpupt1bfev.swift:15:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case 'a':\n        ^~~~~~~~~\n                  break\n/tmp/tmpupt1bfev.swift:16:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmpupt1bfev.swift:16:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'b':\n        ^~~~~~~~~\n                  break\n/tmp/tmpupt1bfev.swift:17:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'c':\n   \
    \          ^~~\n             \"c\"\n/tmp/tmpupt1bfev.swift:17:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'c':\n        ^~~~~~~~~\n                  break\n/tmp/tmpupt1bfev.swift:18:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'd':\n   \
    \          ^~~\n             \"d\"\n/tmp/tmpupt1bfev.swift:18:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'd':\n        ^~~~~~~~~\n                  break\n/tmp/tmpupt1bfev.swift:19:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpupt1bfev.swift:19:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'e':\n        ^~~~~~~~~\n                  break\n/tmp/tmpupt1bfev.swift:20:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'f':\n   \
    \          ^~~\n             \"f\"\n/tmp/tmpupt1bfev.swift:20:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'f':\n        ^~~~~~~~~\n                  break\n/tmp/tmpupt1bfev.swift:21:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'g':\n   \
    \          ^~~\n             \"g\"\n/tmp/tmpupt1bfev.swift:21:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        "
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case 'a':\n            result += \"A\"\n        case\
    \ 'b':\n            result += \"B\"\n        case 'c':\n            result +=\
    \ \"C\"\n        case 'd':\n            result += \"D\"\n        case 'e':\n \
    \           result += \"E\"\n        case 'f':\n            result += \"F\"\n\
    \        case 'g':\n            result += \"G\"\n        case 'h':\n         \
    \   result += \"H\"\n        case 'i':\n            result += \"I\"\n        case\
    \ 'j':\n            result += \"J\"\n        case 'k':\n            result +=\
    \ \"K\"\n        case 'l':\n            result += \"L\"\n        case 'm':\n \
    \           result += \"M\"\n        case 'n':\n            result += \"N\"\n\
    \        case 'o':\n            result += \"O\"\n        case 'p':\n         \
    \   result += \"P\"\n        case 'q':\n            result += \"Q\"\n        case\
    \ 'r':\n            result += \"R\"\n        case 's':\n            result +=\
    \ \"S\"\n        case 't':\n            result += \"T\"\n        case 'u':\n \
    \           result += \"U\"\n        case 'v':\n            result += \"V\"\n\
    \        case 'w':\n            result += \"W\"\n        case 'x':\n         \
    \   result += \"X\"\n        case 'y':\n            result += \"Y\"\n        case\
    \ 'z':\n            result += \"Z\"\n        default:\n            result += char\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpoj7_oy_r.swift:15:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpoj7_oy_r.swift:17:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmpoj7_oy_r.swift:19:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmpoj7_oy_r.swift:21:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmpoj7_oy_r.swift:23:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpoj7_oy_r.swift:25:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmpoj7_oy_r.swift:27:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmpoj7_oy_r.swift:29:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmpoj7_oy_r.swift:31:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmpoj7_oy_r.swift:33:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmpoj7_oy_r.swift:35:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmpoj7_oy_r.swift:37:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmpoj7_oy_r.swift:39:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmpoj7_oy_r.swift:41:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmpoj7_oy_r.swift:43:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmpoj7_oy_r.swift:45:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case 'a':\n        case 'b':\n        case 'c':\n   \
    \     case 'd':\n        case 'e':\n        case 'f':\n        case 'g':\n   \
    \     case 'h':\n        case 'i':\n        case 'j':\n        case 'k':\n   \
    \     case 'l':\n        case 'm':\n        case 'n':\n        case 'o':\n   \
    \     case 'p':\n        case 'q':\n        case 'r':\n        case 's':\n   \
    \     case 't':\n        case 'u':\n        case 'v':\n        case 'w':\n   \
    \     case 'x':\n        case 'y':\n        case 'z':\n            result += String(char.lowercase)\n\
    \        default:\n            result += String(char)\n        }\n    }\n    if\
    \ result.characters.count == 0 {\n        return \"\"\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpkctvtrbm.swift:15:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpkctvtrbm.swift:15:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case 'a':\n        ^~~~~~~~~\n                  break\n/tmp/tmpkctvtrbm.swift:16:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmpkctvtrbm.swift:16:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'b':\n        ^~~~~~~~~\n                  break\n/tmp/tmpkctvtrbm.swift:17:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'c':\n   \
    \          ^~~\n             \"c\"\n/tmp/tmpkctvtrbm.swift:17:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'c':\n        ^~~~~~~~~\n                  break\n/tmp/tmpkctvtrbm.swift:18:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'd':\n   \
    \          ^~~\n             \"d\"\n/tmp/tmpkctvtrbm.swift:18:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'd':\n        ^~~~~~~~~\n                  break\n/tmp/tmpkctvtrbm.swift:19:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpkctvtrbm.swift:19:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'e':\n        ^~~~~~~~~\n                  break\n/tmp/tmpkctvtrbm.swift:20:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'f':\n   \
    \          ^~~\n             \"f\"\n/tmp/tmpkctvtrbm.swift:20:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'f':\n        ^~~~~~~~~\n                  break\n/tmp/tmpkctvtrbm.swift:21:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'g':\n   \
    \          ^~~\n             \"g\"\n/tmp/tmpkctvtrbm.swift:21:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        "
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    return s.characters.reduce(\"\") { $0 + String($1) }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpg6vefuyv.swift:12:14: error: 'characters' is unavailable: Please\
    \ use String directly\n    return s.characters.reduce(\"\") { $0 + String($1)\
    \ }\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            switch char.lowercased() {\n            case \"a\": result =\
    \ \"A\" + result\n            case \"b\": result = \"B\" + result\n          \
    \  case \"c\": result = \"C\" + result\n            case \"d\": result = \"D\"\
    \ + result\n            case \"e\": result = \"E\" + result\n            case\
    \ \"f\": result = \"F\" + result\n            case \"g\": result = \"G\" + result\n\
    \            case \"h\": result = \"H\" + result\n            case \"i\": result\
    \ = \"I\" + result\n            case \"j\": result = \"J\" + result\n        \
    \    case \"k\": result = \"K\" + result\n            case \"l\": result = \"\
    L\" + result\n            case \"m\": result = \"M\" + result\n            case\
    \ \"n\": result = \"N\" + result\n            case \"o\": result = \"O\" + result\n\
    \            case \"p\": result = \"P\" + result\n            case \"q\": result\
    \ = \"Q\" + result\n            case \"r\": result = \"R\" + result\n        \
    \    case \"s\": result = \"S\" + result\n            case \"t\": result = \"\
    T\" + result\n            case \"u\": result = \"U\" + result\n            case\
    \ \"v\": result = \"V\" + result\n            case \"w\": result = \"W\" + result\n\
    \            case \"x\": result = \"X\" + result\n            case \"y\": result\
    \ = \"Y\" + result\n            case \"z\": result = \"Z\" + result\n        \
    \    default: result = \"\\(char.uppercased())\" + result\n            }\n   \
    \     } else {\n            result = \"\\(char.uppercased())\" + result\n    \
    \    }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s:\
    \ \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmplv_z4bfi.swift:14:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n"
  stdout: ''
  timestamp: 1659824675
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter\
    \ {\n            result += String(char.uppercased())\n        } else {\n     \
    \       result += String(char)\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpad3iozl1/tmpad3iozl1.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f0d8d3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f0d5cab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0f0d5ca988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0f0d5c97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpad3iozl1                        0x000055773def9657 <unavailable> + 5719

    5    libc.so.6                          0x00002b0f0dabf460 __libc_start_main +
    245

    6    tmpad3iozl1                        0x000055773def9299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case let c where c >= 'a' && c <= 'z':\n            result\
    \ += String(c - 'a' + 1)\n        case let c where c >= 'A' && c <= 'Z':\n   \
    \         result += String(c - 'A' + 1)\n        default:\n            result\
    \ += char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpzv70bo_2.swift:15:31: error: single-quoted string literal found,\
    \ use '\"'\n        case let c where c >= 'a' && c <= 'z':\n                 \
    \             ^~~\n                              \"a\"\n/tmp/tmpzv70bo_2.swift:15:43:\
    \ error: single-quoted string literal found, use '\"'\n        case let c where\
    \ c >= 'a' && c <= 'z':\n                                          ^~~\n     \
    \                                     \"z\"\n/tmp/tmpzv70bo_2.swift:16:34: error:\
    \ single-quoted string literal found, use '\"'\n            result += String(c\
    \ - 'a' + 1)\n                                 ^~~\n                         \
    \        \"a\"\n/tmp/tmpzv70bo_2.swift:17:31: error: single-quoted string literal\
    \ found, use '\"'\n        case let c where c >= 'A' && c <= 'Z':\n          \
    \                    ^~~\n                              \"A\"\n/tmp/tmpzv70bo_2.swift:17:43:\
    \ error: single-quoted string literal found, use '\"'\n        case let c where\
    \ c >= 'A' && c <= 'Z':\n                                          ^~~\n     \
    \                                     \"Z\"\n/tmp/tmpzv70bo_2.swift:18:34: error:\
    \ single-quoted string literal found, use '\"'\n            result += String(c\
    \ - 'A' + 1)\n                                 ^~~\n                         \
    \        \"A\"\n/tmp/tmpzv70bo_2.swift:13:19: error: 'characters' is unavailable:\
    \ Please use String directly\n    for char in s.characters {\n               \
    \   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpzv70bo_2.swift:16:38:\
    \ error: referencing operator function '+' on 'SIMD' requires that 'Unicode.Scalar'\
    \ conform to 'SIMD'\n            result += String(c - 'a' + 1)\n             \
    \                        ^\nSwift.SIMD:1:11: note: where 'Self' = 'Unicode.Scalar'\n\
    extension SIMD where Self.Scalar : FloatingPoint {\n          ^\n/tmp/tmpzv70bo_2.swift:18:38:\
    \ error: referencing operator function '+' on 'SIMD' requires that 'Unicode.Scalar'\
    \ conform to 'SIMD'\n            result += String(c - 'A' + 1)\n             \
    \                        ^\nS"
  stdout: ''
  timestamp: 1659824678
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            let upperCase = char.uppercased()\n            if upperCase ==\
    \ char {\n                result += char\n            } else {\n             \
    \   result += upperCase\n            }\n        } else {\n            result +=\
    \ char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpx06pi7og.swift:14:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpx06pi7og.swift:16:26: error: binary operator '=='\
    \ cannot be applied to operands of type 'String' and 'Character'\n           \
    \ if upperCase == char {\n               ~~~~~~~~~ ^  ~~~~\n/tmp/tmpx06pi7og.swift:16:26:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n            if upperCase == char {\n\
    \                         ^\n/tmp/tmpx06pi7og.swift:17:27: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n             \
    \   result += char\n                          ^\n/tmp/tmpx06pi7og.swift:22:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            switch char.lowercased() {\n            case \"a\":\n       \
    \         result += \"A\"\n            case \"b\":\n                result +=\
    \ \"b\"\n            case \"c\":\n                result += \"C\"\n          \
    \  case \"d\":\n                result += \"D\"\n            case \"e\":\n   \
    \             result += \"E\"\n            case \"f\":\n                result\
    \ += \"F\"\n            case \"g\":\n                result += \"G\"\n       \
    \     case \"h\":\n                result += \"H\"\n            case \"i\":\n\
    \                result += \"I\"\n            case \"j\":\n                result\
    \ += \"J\"\n            case \"k\":\n                result += \"K\"\n       \
    \     case \"l\":\n                result += \"L\"\n            case \"m\":\n\
    \                result += \"M\"\n            case \"n\":\n                result\
    \ += \"N\"\n            case \"o\":\n                result += \"O\"\n       \
    \     case \"p\":\n                result += \"P\"\n            case \"q\":\n\
    \                result += \"Q\"\n            case \"r\":\n                result\
    \ += \"R\"\n            case \"s\":\n                result += \"S\"\n       \
    \     case \"t\":\n                result += \"T\"\n            case \"u\":\n\
    \                result += \"U\"\n            case \"v\":\n                result\
    \ += \"V\"\n            case \"w\":\n                result += \"W\"\n       \
    \     case \"x\":\n                result += \"X\"\n            case \"y\":\n\
    \                result += \"Y\"\n            case \"z\":\n                result\
    \ += \"Z\"\n            default:\n                result += char\n           \
    \ }\n        } else {\n            result += char\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpggdipbze.swift:14:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpggdipbze.swift:69:27: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n                result\
    \ += char\n                          ^\n/tmp/tmpggdipbze.swift:72:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    return s.characters.reversed().reduce(\"\") { (result, c) in\n\
    \        if let c = c.lowercased() {\n            return result + String(c)\n\
    \        } else {\n            return result + c\n        }\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpr3qgnhw6.swift:16:29: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to expected argument type 'String'\n            return result\
    \ + c\n                            ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            switch char.lowercased() {\n            case \"a\":\n       \
    \         result = \"A\" + result\n            case \"b\":\n                result\
    \ = \"B\" + result\n            case \"c\":\n                result = \"C\" +\
    \ result\n            case \"d\":\n                result = \"D\" + result\n \
    \           case \"e\":\n                result = \"E\" + result\n           \
    \ case \"f\":\n                result = \"F\" + result\n            case \"g\"\
    :\n                result = \"G\" + result\n            case \"h\":\n        \
    \        result = \"H\" + result\n            case \"i\":\n                result\
    \ = \"I\" + result\n            case \"j\":\n                result = \"J\" +\
    \ result\n            case \"k\":\n                result = \"K\" + result\n \
    \           case \"l\":\n                result = \"L\" + result\n           \
    \ case \"m\":\n                result = \"M\" + result\n            case \"n\"\
    :\n                result = \"N\" + result\n            case \"o\":\n        \
    \        result = \"O\" + result\n            case \"p\":\n                result\
    \ = \"P\" + result\n            case \"q\":\n                result = \"Q\" +\
    \ result\n            case \"r\":\n                result = \"R\" + result\n \
    \           case \"s\":\n                result = \"S\" + result\n           \
    \ case \"t\":\n                result = \"T\" + result\n            case \"u\"\
    :\n                result = \"U\" + result\n            case \"v\":\n        \
    \        result = \"V\" + result\n            case \"w\":\n                result\
    \ = \"W\" + result\n            case \"x\":\n                result = \"X\" +\
    \ result\n            case \"y\":\n                result = \"Y\" + result\n \
    \           case \"z\":\n                result = \"Z\" + result\n           \
    \ default:\n                result = \"0\" + result\n            }\n        }\
    \ else {\n            result = char + result\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpyp_88gpo.swift:14:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpyp_88gpo.swift:72:22: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n            result =\
    \ char + result\n                     ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ if let c = char.lowercaseString {\n            result += c\n        } else if\
    \ let c = char.uppercaseString {\n            result += c\n        } else {\n\
    \            result += char\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp07mzhypd.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp07mzhypd.swift:14:25:\
    \ error: value of type 'Character' has no member 'lowercaseString'\n        if\
    \ let c = char.lowercaseString {\n                   ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmp07mzhypd.swift:16:32:\
    \ error: value of type 'Character' has no member 'uppercaseString'\n        }\
    \ else if let c = char.uppercaseString {\n                          ~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmp07mzhypd.swift:19:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            if char.lowercased() == char {\n                result += char.uppercased()\n\
    \            } else {\n                result += char.lowercased()\n         \
    \   }\n        } else {\n            result += char\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpmhk6gu37.swift:14:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpmhk6gu37.swift:15:34: error: binary operator '=='\
    \ cannot be applied to operands of type 'String' and 'Character'\n           \
    \ if char.lowercased() == char {\n               ~~~~~~~~~~~~~~~~~ ^  ~~~~\n/tmp/tmpmhk6gu37.swift:15:34:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n            if char.lowercased() ==\
    \ char {\n                                 ^\n/tmp/tmpmhk6gu37.swift:21:23: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    return s.characters.reversed().reduce(\"\") { $0 + String($1)\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpm03cykjf.swift:12:14: error: 'characters' is unavailable: Please\
    \ use String directly\n    return s.characters.reversed().reduce(\"\") { $0 +\
    \ String($1) }\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case let c where c >= 'a' && c <= 'z':\n            result\
    \ += \"\\(c)\"\n        case let c where c >= 'A' && c <= 'Z':\n            result\
    \ += \"\\(c)\"\n        default:\n            result += char\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpo8orvj2d.swift:15:31: error: single-quoted string literal found,\
    \ use '\"'\n        case let c where c >= 'a' && c <= 'z':\n                 \
    \             ^~~\n                              \"a\"\n/tmp/tmpo8orvj2d.swift:15:43:\
    \ error: single-quoted string literal found, use '\"'\n        case let c where\
    \ c >= 'a' && c <= 'z':\n                                          ^~~\n     \
    \                                     \"z\"\n/tmp/tmpo8orvj2d.swift:17:31: error:\
    \ single-quoted string literal found, use '\"'\n        case let c where c >=\
    \ 'A' && c <= 'Z':\n                              ^~~\n                      \
    \        \"A\"\n/tmp/tmpo8orvj2d.swift:17:43: error: single-quoted string literal\
    \ found, use '\"'\n        case let c where c >= 'A' && c <= 'Z':\n          \
    \                                ^~~\n                                       \
    \   \"Z\"\n/tmp/tmpo8orvj2d.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpo8orvj2d.swift:20:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        switch char\
    \ {\n        case \"a\":\n            result += \"A\"\n        case \"b\":\n \
    \           result += \"b\"\n        case \"c\":\n            result += \"C\"\n\
    \        case \"d\":\n            result += \"D\"\n        case \"e\":\n     \
    \       result += \"E\"\n        case \"f\":\n            result += \"F\"\n  \
    \      case \"g\":\n            result += \"G\"\n        case \"h\":\n       \
    \     result += \"H\"\n        case \"i\":\n            result += \"I\"\n    \
    \    case \"j\":\n            result += \"J\"\n        case \"k\":\n         \
    \   result += \"K\"\n        case \"l\":\n            result += \"L\"\n      \
    \  case \"m\":\n            result += \"M\"\n        case \"n\":\n           \
    \ result += \"N\"\n        case \"o\":\n            result += \"O\"\n        case\
    \ \"p\":\n            result += \"P\"\n        case \"q\":\n            result\
    \ += \"Q\"\n        case \"r\":\n            result += \"R\"\n        case \"\
    s\":\n            result += \"S\"\n        case \"t\":\n            result +=\
    \ \"T\"\n        case \"u\":\n            result += \"U\"\n        case \"v\"\
    :\n            result += \"V\"\n        case \"w\":\n            result += \"\
    W\"\n        case \"x\":\n            result += \"X\"\n        case \"y\":\n \
    \           result += \"Y\"\n        case \"z\":\n            result += \"Z\"\n\
    \        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpv3q437oa.swift:68:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            let upper = char.uppercased()\n            let lower = char.lowercased()\n\
    \            if upper != nil {\n                result += upper!\n           \
    \ } else {\n                result += lower!\n            }\n        } else {\n\
    \            result += char\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp6v9focj2.swift:14:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmp6v9focj2.swift:17:22: warning: comparing non-optional\
    \ value of type 'String' to 'nil' always returns true\n            if upper !=\
    \ nil {\n               ~~~~~ ^  ~~~\n/tmp/tmp6v9focj2.swift:18:32: error: cannot\
    \ force unwrap value of non-optional type 'String'\n                result +=\
    \ upper!\n                          ~~~~~^\n                               \n\
    /tmp/tmp6v9focj2.swift:20:32: error: cannot force unwrap value of non-optional\
    \ type 'String'\n                result += lower!\n                          ~~~~~^\n\
    \                               \n/tmp/tmp6v9focj2.swift:23:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    return s.characters.reversed().reduce(\"\") { $0 + String($1)\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpm03cykjf.swift:12:14: error: 'characters' is unavailable: Please\
    \ use String directly\n    return s.characters.reversed().reduce(\"\") { $0 +\
    \ String($1) }\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            switch char.lowercased() {\n            case \"a\": result =\
    \ \"A\" + result\n            case \"b\": result = \"B\" + result\n          \
    \  case \"c\": result = \"C\" + result\n            case \"d\": result = \"D\"\
    \ + result\n            case \"e\": result = \"E\" + result\n            case\
    \ \"f\": result = \"F\" + result\n            case \"g\": result = \"G\" + result\n\
    \            case \"h\": result = \"H\" + result\n            case \"i\": result\
    \ = \"I\" + result\n            case \"j\": result = \"J\" + result\n        \
    \    case \"k\": result = \"K\" + result\n            case \"l\": result = \"\
    L\" + result\n            case \"m\": result = \"M\" + result\n            case\
    \ \"n\": result = \"N\" + result\n            case \"o\": result = \"O\" + result\n\
    \            case \"p\": result = \"P\" + result\n            case \"q\": result\
    \ = \"Q\" + result\n            case \"r\": result = \"R\" + result\n        \
    \    case \"s\": result = \"S\" + result\n            case \"t\": result = \"\
    T\" + result\n            case \"u\": result = \"U\" + result\n            case\
    \ \"v\": result = \"V\" + result\n            case \"w\": result = \"W\" + result\n\
    \            case \"x\": result = \"X\" + result\n            case \"y\": result\
    \ = \"Y\" + result\n            case \"z\": result = \"Z\" + result\n        \
    \    default: result = \"0\" + result\n            }\n        } else {\n     \
    \       result += char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpwr8v6cnr.swift:14:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpwr8v6cnr.swift:45:23: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n            result +=\
    \ char\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case 'a':\n            result += \"A\"\n        case\
    \ 'b':\n            result += \"b\"\n        case 'c':\n            result +=\
    \ \"C\"\n        case 'd':\n            result += \"d\"\n        case 'e':\n \
    \           result += \"E\"\n        case 'f':\n            result += \"f\"\n\
    \        case 'g':\n            result += \"G\"\n        case 'h':\n         \
    \   result += \"h\"\n        case 'i':\n            result += \"I\"\n        case\
    \ 'j':\n            result += \"j\"\n        case 'k':\n            result +=\
    \ \"K\"\n        case 'l':\n            result += \"L\"\n        case 'm':\n \
    \           result += \"m\"\n        case 'n':\n            result += \"N\"\n\
    \        case 'o':\n            result += \"O\"\n        case 'p':\n         \
    \   result += \"p\"\n        case 'q':\n            result += \"Q\"\n        case\
    \ 'r':\n            result += \"r\"\n        case 's':\n            result +=\
    \ \"S\"\n        case 't':\n            result += \"T\"\n        case 'u':\n \
    \           result += \"U\"\n        case 'v':\n            result += \"V\"\n\
    \        case 'w':\n            result += \"W\"\n        case 'x':\n         \
    \   result += \"X\"\n        case 'y':\n            result += \"Y\"\n        case\
    \ 'z':\n            result += \"Z\"\n        default:\n            result += char\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpw_8mezy_.swift:15:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpw_8mezy_.swift:17:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmpw_8mezy_.swift:19:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmpw_8mezy_.swift:21:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmpw_8mezy_.swift:23:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpw_8mezy_.swift:25:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmpw_8mezy_.swift:27:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmpw_8mezy_.swift:29:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmpw_8mezy_.swift:31:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmpw_8mezy_.swift:33:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmpw_8mezy_.swift:35:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmpw_8mezy_.swift:37:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmpw_8mezy_.swift:39:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmpw_8mezy_.swift:41:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmpw_8mezy_.swift:43:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmpw_8mezy_.swift:45:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            switch char.lowercased() {\n            case \"a\":\n       \
    \         result += \"A\"\n            case \"b\":\n                result +=\
    \ \"b\"\n            case \"c\":\n                result += \"C\"\n          \
    \  case \"d\":\n                result += \"D\"\n            case \"e\":\n   \
    \             result += \"E\"\n            case \"f\":\n                result\
    \ += \"F\"\n            case \"g\":\n                result += \"G\"\n       \
    \     case \"h\":\n                result += \"H\"\n            case \"i\":\n\
    \                result += \"I\"\n            case \"j\":\n                result\
    \ += \"J\"\n            case \"k\":\n                result += \"K\"\n       \
    \     case \"l\":\n                result += \"L\"\n            case \"m\":\n\
    \                result += \"M\"\n            case \"n\":\n                result\
    \ += \"N\"\n            case \"o\":\n                result += \"O\"\n       \
    \     case \"p\":\n                result += \"P\"\n            case \"q\":\n\
    \                result += \"Q\"\n            case \"r\":\n                result\
    \ += \"R\"\n            case \"s\":\n                result += \"S\"\n       \
    \     case \"t\":\n                result += \"T\"\n            case \"u\":\n\
    \                result += \"U\"\n            case \"v\":\n                result\
    \ += \"V\"\n            case \"w\":\n                result += \"W\"\n       \
    \     case \"x\":\n                result += \"X\"\n            case \"y\":\n\
    \                result += \"Y\"\n            case \"z\":\n                result\
    \ += \"Z\"\n            default:\n                result += char\n           \
    \ }\n        } else {\n            result += char\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpggdipbze.swift:14:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpggdipbze.swift:69:27: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n                result\
    \ += char\n                          ^\n/tmp/tmpggdipbze.swift:72:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            switch char.lowercased() {\n            case \"a\": result =\
    \ \"A\" + result\n            case \"b\": result = \"B\" + result\n          \
    \  case \"c\": result = \"C\" + result\n            case \"d\": result = \"D\"\
    \ + result\n            case \"e\": result = \"E\" + result\n            case\
    \ \"f\": result = \"F\" + result\n            case \"g\": result = \"G\" + result\n\
    \            case \"h\": result = \"H\" + result\n            case \"i\": result\
    \ = \"I\" + result\n            case \"j\": result = \"J\" + result\n        \
    \    case \"k\": result = \"K\" + result\n            case \"l\": result = \"\
    L\" + result\n            case \"m\": result = \"M\" + result\n            case\
    \ \"n\": result = \"N\" + result\n            case \"o\": result = \"O\" + result\n\
    \            case \"p\": result = \"P\" + result\n            case \"q\": result\
    \ = \"Q\" + result\n            case \"r\": result = \"R\" + result\n        \
    \    case \"s\": result = \"S\" + result\n            case \"t\": result = \"\
    T\" + result\n            case \"u\": result = \"U\" + result\n            case\
    \ \"v\": result = \"V\" + result\n            case \"w\": result = \"W\" + result\n\
    \            case \"x\": result = \"X\" + result\n            case \"y\": result\
    \ = \"Y\" + result\n            case \"z\": result = \"Z\" + result\n        \
    \    default: result = \"a\" + result\n            }\n        } else {\n     \
    \       result += char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpgst_b6ch.swift:14:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpgst_b6ch.swift:45:23: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n            result +=\
    \ char\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    return s.characters.reversed().reduce(\"\") { $0 + String($1)\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpm03cykjf.swift:12:14: error: 'characters' is unavailable: Please\
    \ use String directly\n    return s.characters.reversed().reduce(\"\") { $0 +\
    \ String($1) }\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        switch char\
    \ {\n        case \"a\":\n            result += \"A\"\n        case \"b\":\n \
    \           result += \"b\"\n        case \"c\":\n            result += \"C\"\n\
    \        case \"d\":\n            result += \"D\"\n        case \"e\":\n     \
    \       result += \"E\"\n        case \"f\":\n            result += \"F\"\n  \
    \      case \"g\":\n            result += \"G\"\n        case \"h\":\n       \
    \     result += \"H\"\n        case \"i\":\n            result += \"I\"\n    \
    \    case \"j\":\n            result += \"J\"\n        case \"k\":\n         \
    \   result += \"K\"\n        case \"l\":\n            result += \"L\"\n      \
    \  case \"m\":\n            result += \"M\"\n        case \"n\":\n           \
    \ result += \"N\"\n        case \"o\":\n            result += \"O\"\n        case\
    \ \"p\":\n            result += \"P\"\n        case \"q\":\n            result\
    \ += \"Q\"\n        case \"r\":\n            result += \"R\"\n        case \"\
    s\":\n            result += \"S\"\n        case \"t\":\n            result +=\
    \ \"T\"\n        case \"u\":\n            result += \"U\"\n        case \"v\"\
    :\n            result += \"V\"\n        case \"w\":\n            result += \"\
    W\"\n        case \"x\":\n            result += \"X\"\n        case \"y\":\n \
    \           result += \"Y\"\n        case \"z\":\n            result += \"Z\"\n\
    \        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpv3q437oa.swift:68:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case 'a':\n            result += \"A\"\n        case\
    \ 'b':\n            result += \"b\"\n        case 'c':\n            result +=\
    \ \"C\"\n        case 'd':\n            result += \"d\"\n        case 'e':\n \
    \           result += \"E\"\n        case 'f':\n            result += \"f\"\n\
    \        case 'g':\n            result += \"G\"\n        case 'h':\n         \
    \   result += \"H\"\n        case 'i':\n            result += \"I\"\n        case\
    \ 'j':\n            result += \"J\"\n        case 'k':\n            result +=\
    \ \"K\"\n        case 'l':\n            result += \"L\"\n        case 'm':\n \
    \           result += \"m\"\n        case 'n':\n            result += \"N\"\n\
    \        case 'o':\n            result += \"O\"\n        case 'p':\n         \
    \   result += \"P\"\n        case 'q':\n            result += \"Q\"\n        case\
    \ 'r':\n            result += \"R\"\n        case 's':\n            result +=\
    \ \"S\"\n        case 't':\n            result += \"T\"\n        case 'u':\n \
    \           result += \"U\"\n        case 'v':\n            result += \"V\"\n\
    \        case 'w':\n            result += \"W\"\n        case 'x':\n         \
    \   result += \"X\"\n        case 'y':\n            result += \"Y\"\n        case\
    \ 'z':\n            result += \"Z\"\n        default:\n            result += char\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp1linqd6_.swift:15:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmp1linqd6_.swift:17:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmp1linqd6_.swift:19:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmp1linqd6_.swift:21:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmp1linqd6_.swift:23:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmp1linqd6_.swift:25:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmp1linqd6_.swift:27:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmp1linqd6_.swift:29:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmp1linqd6_.swift:31:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmp1linqd6_.swift:33:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmp1linqd6_.swift:35:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmp1linqd6_.swift:37:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmp1linqd6_.swift:39:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmp1linqd6_.swift:41:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmp1linqd6_.swift:43:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmp1linqd6_.swift:45:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    var i = 0\n    while i < s.count {\n\
    \        if s[i] == \".\" {\n            i += 1\n            continue\n      \
    \  }\n        if s[i] == \"@\" {\n            i += 1\n            continue\n \
    \       }\n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"#\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"$\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"%\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"&\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"*\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"-\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"_\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"/\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"^\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"~\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"<\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \">\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"|\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"=\" { // this case is for \"=\"\n           \
    \ i += 1\n            continue\n        }\n        if s[i] == \"?\" {\n      \
    \      i += 1\n            continue\n        }\n        if s[i] == \" \" {\n \
    \           i += 1\n            continue\n        }\n        if s[i] == \"!\"\
    \ {\n            i += 1\n            continue\n        }\n        if s[i] == \"\
    @\" {\n            i += 1\n            continue\n        }\n        if s[i] ==\
    \ \"#\" {\n            i += 1\n            continue\n        }\n        if s[i]\
    \ == \"$\" {\n            i += 1\n            continue\n        }\n        if\
    \ s[i] == \"%\" {\n            i += 1\n            continue\n        }\n     \
    \   if s[i] == \"&\" {\n            i += 1\n            continue\n        }\n\
    \        if s[i] == \"*\" {\n            i += 1\n            continue\n      \
    \  }\n        if s[i] == \"-\" {\n            i += 1\n            continue\n \
    \       }\n        if s[i] == \"_\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"/\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"^\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"~\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"<\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \">\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"|\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"=\" { // this case is for \"=\"\n           \
    \ i += 1\n            continue\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s:\
    \ \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp394mdwve.swift:176:35: error: expected '}' at end of brace statement\n\
    assert(solve(s: \"#ccc\") == \"#CCC\")\n                                  ^\n\
    /tmp/tmp394mdwve.swift:14:23: note: to match this opening '{'\n    while i < s.count\
    \ {\n                      ^\n/tmp/tmp394mdwve.swift:176:35: error: expected '}'\
    \ at end of brace statement\nassert(solve(s: \"#ccc\") == \"#CCC\")\n        \
    \                          ^\n/tmp/tmp394mdwve.swift:11:33: note: to match this\
    \ opening '{'\nfunc solve(s: String) -> String {\n                           \
    \     ^\n/tmp/tmp394mdwve.swift:15:12: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ s[i] == \".\" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmp394mdwve.swift:19:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if s[i] == \"@\" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp394mdwve.swift:23:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp394mdwve.swift:27:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if s[i] == \"#\" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp394mdwve.swift:31:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if s[i] == \"$\" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has "
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ if char.isLetter() {\n            switch char.lowercased() {\n            case\
    \ \"a\": result += \"A\"; break\n            case \"b\": result += \"B\"; break\n\
    \            case \"c\": result += \"C\"; break\n            case \"d\": result\
    \ += \"D\"; break\n            case \"e\": result += \"E\"; break\n          \
    \  case \"f\": result += \"F\"; break\n            case \"g\": result += \"G\"\
    ; break\n            case \"h\": result += \"H\"; break\n            case \"i\"\
    : result += \"I\"; break\n            case \"j\": result += \"J\"; break\n   \
    \         case \"k\": result += \"K\"; break\n            case \"l\": result +=\
    \ \"L\"; break\n            case \"m\": result += \"M\"; break\n            case\
    \ \"n\": result += \"N\"; break\n            case \"o\": result += \"O\"; break\n\
    \            case \"p\": result += \"P\"; break\n            case \"q\": result\
    \ += \"Q\"; break\n            case \"r\": result += \"R\"; break\n          \
    \  case \"s\": result += \"S\"; break\n            case \"t\": result += \"T\"\
    ; break\n            case \"u\": result += \"U\"; break\n            case \"v\"\
    : result += \"V\"; break\n            case \"w\": result += \"W\"; break\n   \
    \         case \"x\": result += \"X\"; break\n            case \"y\": result +=\
    \ \"Y\"; break\n            case \"z\": result += \"Z\"; break\n            default:\
    \ result += char\n            }\n        } else {\n            result += char\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpqe8bbghm.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpqe8bbghm.swift:14:17:\
    \ error: cannot call value of non-function type 'Bool'\n        if char.isLetter()\
    \ {\n                ^       ~~\n                        \n/tmp/tmpqe8bbghm.swift:42:32:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            default: result += char\n                               ^\n/tmp/tmpqe8bbghm.swift:45:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            switch char.unicodeScalars.lowercased() {\n            case .uppercase\
    \ , .lowercase:\n                result += char.unicodeScalars.uppercased()\n\
    \            case .nonBase:\n                result += char\n            }\n \
    \       } else {\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpsxj38bf3.swift:14:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpsxj38bf3.swift:15:40: error: value of type 'Character.UnicodeScalarView'\
    \ (aka 'String.UnicodeScalarView') has no member 'lowercased'\n            switch\
    \ char.unicodeScalars.lowercased() {\n                   ~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpsxj38bf3.swift:17:47: error: value of type 'Character.UnicodeScalarView'\
    \ (aka 'String.UnicodeScalarView') has no member 'uppercased'\n              \
    \  result += char.unicodeScalars.uppercased()\n                          ~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpsxj38bf3.swift:19:27: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n                result += char\n\
    \                          ^\n/tmp/tmpsxj38bf3.swift:22:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    var i = 0\n    for c in s {\n      \
    \  if c.isLetter {\n            if i == 0 {\n                result = c.uppercased()\n\
    \            } else {\n                result = c.lowercased()\n            }\n\
    \        } else {\n            result = c\n        }\n        i += 1\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpie249ssp.swift:22:22: error: cannot assign value of type 'Character'\
    \ to type 'String'\n            result = c\n                     ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        switch char\
    \ {\n        case \"a\":\n            result = \"A\" + result\n        case \"\
    b\":\n            result = \"B\" + result\n        case \"c\":\n            result\
    \ = \"C\" + result\n        case \"d\":\n            result = \"D\" + result\n\
    \        case \"e\":\n            result = \"E\" + result\n        case \"f\"\
    :\n            result = \"F\" + result\n        case \"g\":\n            result\
    \ = \"G\" + result\n        case \"h\":\n            result = \"H\" + result\n\
    \        case \"i\":\n            result = \"I\" + result\n        case \"j\"\
    :\n            result = \"J\" + result\n        case \"k\":\n            result\
    \ = \"K\" + result\n        case \"l\":\n            result = \"L\" + result\n\
    \        case \"m\":\n            result = \"M\" + result\n        case \"n\"\
    :\n            result = \"N\" + result\n        case \"o\":\n            result\
    \ = \"O\" + result\n        case \"p\":\n            result = \"P\" + result\n\
    \        case \"q\":\n            result = \"Q\" + result\n        case \"r\"\
    :\n            result = \"R\" + result\n        case \"s\":\n            result\
    \ = \"S\" + result\n        case \"t\":\n            result = \"T\" + result\n\
    \        case \"u\":\n            result = \"U\" + result\n        case \"v\"\
    :\n            result = \"V\" + result\n        case \"w\":\n            result\
    \ = \"W\" + result\n        case \"x\":\n            result = \"X\" + result\n\
    \        case \"y\":\n            result = \"Y\" + result\n        case \"z\"\
    :\n            result = \"Z\" + result\n        default:\n            result =\
    \ char + result\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp1sq9tdg8.swift:68:22: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result = char + result\n   \
    \                  ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    var i = 0\n    while i < s.count {\n\
    \        if s[i].isLetter {\n            if s[i].isUppercase {\n             \
    \   result += s[i].lowercaseString\n            } else {\n                result\
    \ += s[i].uppercaseString\n            }\n        } else {\n            result\
    \ += s[i]\n        }\n        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpwk3vlua4.swift:15:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if s[i].isLetter\
    \ {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpwk3vlua4.swift:16:16: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \   if s[i].isUppercase {\n               ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpwk3vlua4.swift:17:32: error: value\
    \ of type 'Character' has no member 'lowercaseString'\n                result\
    \ += s[i].lowercaseString\n                          ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpwk3vlua4.swift:19:32:\
    \ error: value of type 'Character' has no member 'uppercaseString'\n         \
    \       result += s[i].uppercaseString\n                          ~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmpwk3vlua4.swift:22:24: error: no exact matches in call to subscript \n\
    \            result += s[i]\n                       ^\nSwift.String:3:12: note:\
    \ candidate expects value of type 'Range<String.Index>' for parameter #1 (got\
    \ 'Int')\n    public subscript(r: Range<String.Index>) -> Substring { get }\n\
    \           ^\nSwift.Collection:3:23: note: candidate expects value of type '(UnboundedRange_)\
    \ -> ()' for parameter #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_)\
    \ -> ()) -> Self.SubSequence { get }\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for letter in s {\n        if letter.isLetter()\
    \ {\n            switch letter {\n            case \"A\":\n                result\
    \ += \"a\"\n            case \"B\":\n                result += \"b\"\n       \
    \     case \"C\":\n                result += \"c\"\n            case \"D\":\n\
    \                result += \"d\"\n            case \"E\":\n                result\
    \ += \"e\"\n            case \"F\":\n                result += \"f\"\n       \
    \     case \"G\":\n                result += \"g\"\n            case \"H\":\n\
    \                result += \"h\"\n            case \"I\":\n                result\
    \ += \"i\"\n            case \"J\":\n                result += \"j\"\n       \
    \     case \"K\":\n                result += \"k\"\n            case \"L\":\n\
    \                result += \"l\"\n            case \"M\":\n                result\
    \ += \"m\"\n            case \"N\":\n                result += \"n\"\n       \
    \     case \"O\":\n                result += \"o\"\n            case \"P\":\n\
    \                result += \"p\"\n            case \"Q\":\n                result\
    \ += \"q\"\n            case \"R\":\n                result += \"r\"\n       \
    \     case \"S\":\n                result += \"s\"\n            case \"T\":\n\
    \                result += \"t\"\n            case \"U\":\n                result\
    \ += \"u\"\n            case \"V\":\n                result += \"v\"\n       \
    \     case \"W\":\n                result += \"w\"\n            case \"X\":\n\
    \                result += \"x\"\n            case \"Y\":\n                result\
    \ += \"y\"\n            case \"Z\":\n                result += \"z\"\n       \
    \     default:\n                result += letter\n            }\n        } else\
    \ {\n            result += letter\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp8k1hyqfw.swift:14:19: error: cannot call value of non-function\
    \ type 'Bool'\n        if letter.isLetter() {\n                  ^       ~~\n\
    \                          \n/tmp/tmp8k1hyqfw.swift:69:27: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n             \
    \   result += letter\n                          ^\n/tmp/tmp8k1hyqfw.swift:72:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            switch char {\n            case \"a\": result = \"A\"; break\n\
    \            case \"b\": result = \"b\"; break\n            case \"c\": result\
    \ = \"C\"; break\n            case \"d\": result = \"d\"; break\n            case\
    \ \"e\": result = \"E\"; break\n            case \"f\": result = \"f\"; break\n\
    \            case \"g\": result = \"G\"; break\n            case \"h\": result\
    \ = \"H\"; break\n            case \"i\": result = \"I\"; break\n            case\
    \ \"j\": result = \"J\"; break\n            case \"k\": result = \"K\"; break\n\
    \            case \"l\": result = \"L\"; break\n            case \"m\": result\
    \ = \"M\"; break\n            case \"n\": result = \"N\"; break\n            case\
    \ \"o\": result = \"O\"; break\n            case \"p\": result = \"P\"; break\n\
    \            case \"q\": result = \"Q\"; break\n            case \"r\": result\
    \ = \"R\"; break\n            case \"s\": result = \"S\"; break\n            case\
    \ \"t\": result = \"T\"; break\n            case \"u\": result = \"U\"; break\n\
    \            case \"v\": result = \"V\"; break\n            case \"w\": result\
    \ = \"W\"; break\n            case \"x\": result = \"X\"; break\n            case\
    \ \"y\": result = \"Y\"; break\n            case \"z\": result = \"Z\"; break\n\
    \            default: result = char\n            }\n        } else {\n       \
    \     result = char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpgmvjyl2q.swift:14:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpgmvjyl2q.swift:42:31: error: cannot assign value\
    \ of type 'Character' to type 'String'\n            default: result = char\n \
    \                             ^~~~\n/tmp/tmpgmvjyl2q.swift:45:22: error: cannot\
    \ assign value of type 'Character' to type 'String'\n            result = char\n\
    \                     ^~~~\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case 'a':\n            result += \"A\"\n        case\
    \ 'b':\n            result += \"b\"\n        case 'c':\n            result +=\
    \ \"C\"\n        case 'd':\n            result += \"d\"\n        case 'e':\n \
    \           result += \"E\"\n        case 'f':\n            result += \"f\"\n\
    \        case 'g':\n            result += \"G\"\n        case 'h':\n         \
    \   result += \"h\"\n        case 'i':\n            result += \"I\"\n        case\
    \ 'j':\n            result += \"j\"\n        case 'k':\n            result +=\
    \ \"K\"\n        case 'l':\n            result += \"L\"\n        case 'm':\n \
    \           result += \"m\"\n        case 'n':\n            result += \"N\"\n\
    \        case 'o':\n            result += \"O\"\n        case 'p':\n         \
    \   result += \"P\"\n        case 'q':\n            result += \"Q\"\n        case\
    \ 'r':\n            result += \"R\"\n        case 's':\n            result +=\
    \ \"S\"\n        case 't':\n            result += \"T\"\n        case 'u':\n \
    \           result += \"U\"\n        case 'v':\n            result += \"V\"\n\
    \        case 'w':\n            result += \"W\"\n        case 'x':\n         \
    \   result += \"X\"\n        case 'y':\n            result += \"Y\"\n        case\
    \ 'z':\n            result += \"Z\"\n        default:\n            result += char\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpt8gtxmkv.swift:15:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpt8gtxmkv.swift:17:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmpt8gtxmkv.swift:19:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmpt8gtxmkv.swift:21:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmpt8gtxmkv.swift:23:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpt8gtxmkv.swift:25:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmpt8gtxmkv.swift:27:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmpt8gtxmkv.swift:29:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmpt8gtxmkv.swift:31:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmpt8gtxmkv.swift:33:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmpt8gtxmkv.swift:35:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmpt8gtxmkv.swift:37:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmpt8gtxmkv.swift:39:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmpt8gtxmkv.swift:41:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmpt8gtxmkv.swift:43:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmpt8gtxmkv.swift:45:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for letter in s {\n        if letter.isLetter()\
    \ {\n            switch letter {\n            case \"a\": letter = \"A\"\n   \
    \         case \"b\": letter = \"B\"\n            case \"c\": letter = \"C\"\n\
    \            case \"d\": letter = \"D\"\n            case \"e\": letter = \"E\"\
    \n            case \"f\": letter = \"F\"\n            case \"g\": letter = \"\
    G\"\n            case \"h\": letter = \"H\"\n            case \"i\": letter =\
    \ \"I\"\n            case \"j\": letter = \"J\"\n            case \"k\": letter\
    \ = \"K\"\n            case \"l\": letter = \"L\"\n            case \"m\": letter\
    \ = \"M\"\n            case \"n\": letter = \"N\"\n            case \"o\": letter\
    \ = \"O\"\n            case \"p\": letter = \"P\"\n            case \"q\": letter\
    \ = \"Q\"\n            case \"r\": letter = \"R\"\n            case \"s\": letter\
    \ = \"S\"\n            case \"t\": letter = \"T\"\n            case \"u\": letter\
    \ = \"U\"\n            case \"v\": letter = \"V\"\n            case \"w\": letter\
    \ = \"W\"\n            case \"x\": letter = \"X\"\n            case \"y\": letter\
    \ = \"Y\"\n            case \"z\": letter = \"Z\"\n            default: letter\
    \ = letter\n            }\n        }\n        result += letter\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp18n_5nug.swift:14:19: error: cannot call value of non-function\
    \ type 'Bool'\n        if letter.isLetter() {\n                  ^       ~~\n\
    \                          \n/tmp/tmp18n_5nug.swift:16:23: error: cannot assign\
    \ to value: 'letter' is a 'let' constant\n            case \"a\": letter = \"\
    A\"\n                      ^~~~~~\n/tmp/tmp18n_5nug.swift:17:23: error: cannot\
    \ assign to value: 'letter' is a 'let' constant\n            case \"b\": letter\
    \ = \"B\"\n                      ^~~~~~\n/tmp/tmp18n_5nug.swift:18:23: error:\
    \ cannot assign to value: 'letter' is a 'let' constant\n            case \"c\"\
    : letter = \"C\"\n                      ^~~~~~\n/tmp/tmp18n_5nug.swift:19:23:\
    \ error: cannot assign to value: 'letter' is a 'let' constant\n            case\
    \ \"d\": letter = \"D\"\n                      ^~~~~~\n/tmp/tmp18n_5nug.swift:20:23:\
    \ error: cannot assign to value: 'letter' is a 'let' constant\n            case\
    \ \"e\": letter = \"E\"\n                      ^~~~~~\n/tmp/tmp18n_5nug.swift:21:23:\
    \ error: cannot assign to value: 'letter' is a 'let' constant\n            case\
    \ \"f\": letter = \"F\"\n                      ^~~~~~\n/tmp/tmp18n_5nug.swift:22:23:\
    \ error: cannot assign to value: 'letter' is a 'let' constant\n            case\
    \ \"g\": letter = \"G\"\n                      ^~~~~~\n/tmp/tmp18n_5nug.swift:23:23:\
    \ error: cannot assign to value: 'letter' is a 'let' constant\n            case\
    \ \"h\": letter = \"H\"\n                      ^~~~~~\n/tmp/tmp18n_5nug.swift:24:23:\
    \ error: cannot assign to value: 'letter' is a 'let' constant\n            case\
    \ \"i\": letter = \"I\"\n                      ^~~~~~\n/tmp/tmp18n_5nug.swift:25:23:\
    \ error: cannot assign to value: 'letter' is a 'let' constant\n            case\
    \ \"j\": letter = \"J\"\n                      ^~~~~~\n/tmp/tmp18n_5nug.swift:26:23:\
    \ error: cannot assign to value: 'letter' is a 'let' constant\n            case\
    \ \"k\": letter = \"K\"\n                      ^~~~~~\n/tmp/tmp18n_5nug.swift:27:23:\
    \ error: cannot assign to value: 'letter' is a 'let' constant\n            case\
    \ \"l\": letter = \"L\"\n                      ^~~~~~\n/tmp/tmp18n_5nug.swift:28:23: "
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case 'a':\n            result += \"A\"\n        case\
    \ 'b':\n            result += \"b\"\n        case 'c':\n            result +=\
    \ \"C\"\n        case 'd':\n            result += \"d\"\n        case 'e':\n \
    \           result += \"E\"\n        case 'f':\n            result += \"f\"\n\
    \        case 'g':\n            result += \"G\"\n        case 'h':\n         \
    \   result += \"h\"\n        case 'i':\n            result += \"I\"\n        case\
    \ 'j':\n            result += \"j\"\n        case 'k':\n            result +=\
    \ \"K\"\n        case 'l':\n            result += \"L\"\n        case 'm':\n \
    \           result += \"m\"\n        case 'n':\n            result += \"N\"\n\
    \        case 'o':\n            result += \"O\"\n        case 'p':\n         \
    \   result += \"p\"\n        case 'q':\n            result += \"Q\"\n        case\
    \ 'r':\n            result += \"r\"\n        case 's':\n            result +=\
    \ \"S\"\n        case 't':\n            result += \"T\"\n        case 'u':\n \
    \           result += \"U\"\n        case 'v':\n            result += \"V\"\n\
    \        case 'w':\n            result += \"W\"\n        case 'x':\n         \
    \   result += \"X\"\n        case 'y':\n            result += \"Y\"\n        case\
    \ 'z':\n            result += \"Z\"\n        default:\n            result += char\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpw_8mezy_.swift:15:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpw_8mezy_.swift:17:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmpw_8mezy_.swift:19:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmpw_8mezy_.swift:21:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmpw_8mezy_.swift:23:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpw_8mezy_.swift:25:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmpw_8mezy_.swift:27:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmpw_8mezy_.swift:29:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmpw_8mezy_.swift:31:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmpw_8mezy_.swift:33:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmpw_8mezy_.swift:35:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmpw_8mezy_.swift:37:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmpw_8mezy_.swift:39:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmpw_8mezy_.swift:41:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmpw_8mezy_.swift:43:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmpw_8mezy_.swift:45:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    return s.characters.reversed().reduce(\"\") { $0 + String($1)\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpm03cykjf.swift:12:14: error: 'characters' is unavailable: Please\
    \ use String directly\n    return s.characters.reversed().reduce(\"\") { $0 +\
    \ String($1) }\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case 'a':\n            result += \"A\"\n        case\
    \ 'b':\n            result += \"b\"\n        case 'c':\n            result +=\
    \ \"C\"\n        case 'd':\n            result += \"D\"\n        case 'e':\n \
    \           result += \"E\"\n        case 'f':\n            result += \"F\"\n\
    \        case 'g':\n            result += \"G\"\n        case 'h':\n         \
    \   result += \"H\"\n        case 'i':\n            result += \"I\"\n        case\
    \ 'j':\n            result += \"J\"\n        case 'k':\n            result +=\
    \ \"K\"\n        case 'l':\n            result += \"L\"\n        case 'm':\n \
    \           result += \"M\"\n        case 'n':\n            result += \"N\"\n\
    \        case 'o':\n            result += \"O\"\n        case 'p':\n         \
    \   result += \"P\"\n        case 'q':\n            result += \"Q\"\n        case\
    \ 'r':\n            result += \"R\"\n        case 's':\n            result +=\
    \ \"S\"\n        case 't':\n            result += \"T\"\n        case 'u':\n \
    \           result += \"U\"\n        case 'v':\n            result += \"V\"\n\
    \        case 'w':\n            result += \"W\"\n        case 'x':\n         \
    \   result += \"X\"\n        case 'y':\n            result += \"Y\"\n        case\
    \ 'z':\n            result += \"Z\"\n        default:\n            result += char\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpbdfznpt6.swift:15:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpbdfznpt6.swift:17:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmpbdfznpt6.swift:19:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmpbdfznpt6.swift:21:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmpbdfznpt6.swift:23:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpbdfznpt6.swift:25:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmpbdfznpt6.swift:27:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmpbdfznpt6.swift:29:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmpbdfznpt6.swift:31:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmpbdfznpt6.swift:33:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmpbdfznpt6.swift:35:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmpbdfznpt6.swift:37:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmpbdfznpt6.swift:39:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmpbdfznpt6.swift:41:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmpbdfznpt6.swift:43:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmpbdfznpt6.swift:45:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case 'a':\n            result += \"A\"\n        case\
    \ 'b':\n            result += \"b\"\n        case 'c':\n            result +=\
    \ \"C\"\n        case 'd':\n            result += \"d\"\n        case 'e':\n \
    \           result += \"E\"\n        case 'f':\n            result += \"f\"\n\
    \        case 'g':\n            result += \"g\"\n        case 'h':\n         \
    \   result += \"H\"\n        case 'i':\n            result += \"I\"\n        case\
    \ 'j':\n            result += \"J\"\n        case 'k':\n            result +=\
    \ \"K\"\n        case 'l':\n            result += \"L\"\n        case 'm':\n \
    \           result += \"m\"\n        case 'n':\n            result += \"N\"\n\
    \        case 'o':\n            result += \"O\"\n        case 'p':\n         \
    \   result += \"P\"\n        case 'q':\n            result += \"Q\"\n        case\
    \ 'r':\n            result += \"R\"\n        case 's':\n            result +=\
    \ \"S\"\n        case 't':\n            result += \"T\"\n        case 'u':\n \
    \           result += \"U\"\n        case 'v':\n            result += \"V\"\n\
    \        case 'w':\n            result += \"W\"\n        case 'x':\n         \
    \   result += \"X\"\n        case 'y':\n            result += \"Y\"\n        case\
    \ 'z':\n            result += \"Z\"\n        default:\n            result += char\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpb_tpj9y6.swift:15:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpb_tpj9y6.swift:17:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmpb_tpj9y6.swift:19:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmpb_tpj9y6.swift:21:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmpb_tpj9y6.swift:23:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpb_tpj9y6.swift:25:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmpb_tpj9y6.swift:27:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmpb_tpj9y6.swift:29:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmpb_tpj9y6.swift:31:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmpb_tpj9y6.swift:33:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmpb_tpj9y6.swift:35:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmpb_tpj9y6.swift:37:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmpb_tpj9y6.swift:39:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmpb_tpj9y6.swift:41:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmpb_tpj9y6.swift:43:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmpb_tpj9y6.swift:45:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case 'a':\n            result += \"A\"\n        case\
    \ 'b':\n            result += \"b\"\n        case 'c':\n            result +=\
    \ \"C\"\n        case 'd':\n            result += \"d\"\n        case 'e':\n \
    \           result += \"E\"\n        case 'f':\n            result += \"f\"\n\
    \        case 'g':\n            result += \"g\"\n        case 'h':\n         \
    \   result += \"H\"\n        case 'i':\n            result += \"I\"\n        case\
    \ 'j':\n            result += \"J\"\n        case 'k':\n            result +=\
    \ \"K\"\n        case 'l':\n            result += \"L\"\n        case 'm':\n \
    \           result += \"m\"\n        case 'n':\n            result += \"N\"\n\
    \        case 'o':\n            result += \"O\"\n        case 'p':\n         \
    \   result += \"P\"\n        case 'q':\n            result += \"Q\"\n        case\
    \ 'r':\n            result += \"R\"\n        case 's':\n            result +=\
    \ \"S\"\n        case 't':\n            result += \"T\"\n        case 'u':\n \
    \           result += \"U\"\n        case 'v':\n            result += \"V\"\n\
    \        case 'w':\n            result += \"W\"\n        case 'x':\n         \
    \   result += \"X\"\n        case 'y':\n            result += \"Y\"\n        case\
    \ 'z':\n            result += \"Z\"\n        default:\n            result += String(char)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpquyrwtp0.swift:15:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpquyrwtp0.swift:17:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmpquyrwtp0.swift:19:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmpquyrwtp0.swift:21:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmpquyrwtp0.swift:23:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpquyrwtp0.swift:25:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmpquyrwtp0.swift:27:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmpquyrwtp0.swift:29:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmpquyrwtp0.swift:31:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmpquyrwtp0.swift:33:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmpquyrwtp0.swift:35:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmpquyrwtp0.swift:37:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmpquyrwtp0.swift:39:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmpquyrwtp0.swift:41:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmpquyrwtp0.swift:43:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmpquyrwtp0.swift:45:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    return s.characters.reversed().reduce(\"\") { $0 + String($1)\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpm03cykjf.swift:12:14: error: 'characters' is unavailable: Please\
    \ use String directly\n    return s.characters.reversed().reduce(\"\") { $0 +\
    \ String($1) }\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            switch char.lowercased() {\n            case \"a\":\n       \
    \         result = \"A\" + result\n            case \"b\":\n                result\
    \ = \"B\" + result\n            case \"c\":\n                result = \"C\" +\
    \ result\n            case \"d\":\n                result = \"D\" + result\n \
    \           case \"e\":\n                result = \"E\" + result\n           \
    \ case \"f\":\n                result = \"F\" + result\n            case \"g\"\
    :\n                result = \"G\" + result\n            case \"h\":\n        \
    \        result = \"H\" + result\n            case \"i\":\n                result\
    \ = \"I\" + result\n            case \"j\":\n                result = \"J\" +\
    \ result\n            case \"k\":\n                result = \"K\" + result\n \
    \           case \"l\":\n                result = \"L\" + result\n           \
    \ case \"m\":\n                result = \"M\" + result\n            case \"n\"\
    :\n                result = \"N\" + result\n            case \"o\":\n        \
    \        result = \"O\" + result\n            case \"p\":\n                result\
    \ = \"P\" + result\n            case \"q\":\n                result = \"Q\" +\
    \ result\n            case \"r\":\n                result = \"R\" + result\n \
    \           case \"s\":\n                result = \"S\" + result\n           \
    \ case \"t\":\n                result = \"T\" + result\n            case \"u\"\
    :\n                result = \"U\" + result\n            case \"v\":\n        \
    \        result = \"V\" + result\n            case \"w\":\n                result\
    \ = \"W\" + result\n            case \"x\":\n                result = \"X\" +\
    \ result\n            case \"y\":\n                result = \"Y\" + result\n \
    \           case \"z\":\n                result = \"Z\" + result\n           \
    \ default:\n                result = \"\\(char.lowercased())\" + result\n    \
    \        }\n        } else {\n            result = \"\\(char.lowercased())\" +\
    \ result\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpuxkzktth.swift:14:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ if let _ = char.unicodeScalars.first?.unicodeScalars.first {\n            result\
    \ += String(char.unicodeScalars.first!)\n        } else {\n            result\
    \ += String(char)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpc5fwz7hz.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpc5fwz7hz.swift:14:62:\
    \ error: type of expression is ambiguous without more context\n        if let\
    \ _ = char.unicodeScalars.first?.unicodeScalars.first {\n                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case let c where c.isLetter:\n            switch char\
    \ {\n            case let c where c.isUpper:\n                result += String(c)\n\
    \            case let c where c.isLower:\n                result += String(c)\n\
    \            default:\n                result += char\n            }\n       \
    \ case let c where !c.isLetter:\n            result += char\n        default:\n\
    \            result += char\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp1rbufic4.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp1rbufic4.swift:17:32:\
    \ error: value of type 'Character' has no member 'isUpper'\n            case let\
    \ c where c.isUpper:\n                             ~ ^~~~~~~\n/tmp/tmp1rbufic4.swift:19:32:\
    \ error: value of type 'Character' has no member 'isLower'\n            case let\
    \ c where c.isLower:\n                             ~ ^~~~~~~\n/tmp/tmp1rbufic4.swift:22:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                result += char\n                          ^\n/tmp/tmp1rbufic4.swift:25:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n/tmp/tmp1rbufic4.swift:27:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ if char.isLetter() {\n            let charUpper = char.uppercased()\n      \
    \      let charLower = char.lowercased()\n            if charUpper == charLower\
    \ {\n                result += charUpper\n            } else {\n             \
    \   result += charLower\n            }\n        } else {\n            result +=\
    \ char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpzccusmlh.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpzccusmlh.swift:14:17:\
    \ error: cannot call value of non-function type 'Bool'\n        if char.isLetter()\
    \ {\n                ^       ~~\n                        \n/tmp/tmpzccusmlh.swift:23:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ if char.isLetter {\n            switch char.lowercaseString {\n            case\
    \ char.uppercaseString:\n                result += char.uppercaseString\n    \
    \        case char.lowercaseString:\n                result += char.lowercaseString\n\
    \            default:\n                result += char\n            }\n       \
    \ } else {\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpm3yynjag.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpm3yynjag.swift:15:25:\
    \ error: value of type 'Character' has no member 'lowercaseString'\n         \
    \   switch char.lowercaseString {\n                   ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpm3yynjag.swift:17:32:\
    \ error: value of type 'Character' has no member 'uppercaseString'\n         \
    \       result += char.uppercaseString\n                          ~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmpm3yynjag.swift:19:32: error: value of type 'Character' has no member 'lowercaseString'\n\
    \                result += char.lowercaseString\n                          ~~~~\
    \ ^~~~~~~~~~~~~~~\n/tmp/tmpm3yynjag.swift:21:27: error: cannot convert value of\
    \ type 'Character' to expected argument type 'String'\n                result\
    \ += char\n                          ^\n/tmp/tmpm3yynjag.swift:24:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case 'a':\n        case 'b':\n        case 'c':\n   \
    \     case 'd':\n        case 'e':\n        case 'f':\n        case 'g':\n   \
    \     case 'h':\n        case 'i':\n        case 'j':\n        case 'k':\n   \
    \     case 'l':\n        case 'm':\n        case 'n':\n        case 'o':\n   \
    \     case 'p':\n        case 'q':\n        case 'r':\n        case 's':\n   \
    \     case 't':\n        case 'u':\n        case 'v':\n        case 'w':\n   \
    \     case 'x':\n        case 'y':\n        case 'z':\n            result += \"\
    \\(char.uppercased())\"\n        default:\n            result += char\n      \
    \  }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s:\
    \ \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmph2dw81pv.swift:15:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmph2dw81pv.swift:15:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case 'a':\n        ^~~~~~~~~\n                  break\n/tmp/tmph2dw81pv.swift:16:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmph2dw81pv.swift:16:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'b':\n        ^~~~~~~~~\n                  break\n/tmp/tmph2dw81pv.swift:17:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'c':\n   \
    \          ^~~\n             \"c\"\n/tmp/tmph2dw81pv.swift:17:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'c':\n        ^~~~~~~~~\n                  break\n/tmp/tmph2dw81pv.swift:18:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'd':\n   \
    \          ^~~\n             \"d\"\n/tmp/tmph2dw81pv.swift:18:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'd':\n        ^~~~~~~~~\n                  break\n/tmp/tmph2dw81pv.swift:19:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmph2dw81pv.swift:19:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'e':\n        ^~~~~~~~~\n                  break\n/tmp/tmph2dw81pv.swift:20:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'f':\n   \
    \          ^~~\n             \"f\"\n/tmp/tmph2dw81pv.swift:20:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'f':\n        ^~~~~~~~~\n                  break\n/tmp/tmph2dw81pv.swift:21:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'g':\n   \
    \          ^~~\n             \"g\"\n/tmp/tmph2dw81pv.swift:21:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        "
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ if char.isLetter() {\n            switch char.lowercased() {\n            case\
    \ \"a\":\n                result += \"A\"\n            case \"b\":\n         \
    \       result += \"b\"\n            case \"c\":\n                result += \"\
    C\"\n            case \"d\":\n                result += \"D\"\n            case\
    \ \"e\":\n                result += \"E\"\n            case \"f\":\n         \
    \       result += \"F\"\n            case \"g\":\n                result += \"\
    G\"\n            case \"h\":\n                result += \"H\"\n            case\
    \ \"i\":\n                result += \"I\"\n            case \"j\":\n         \
    \       result += \"J\"\n            case \"k\":\n                result += \"\
    K\"\n            case \"l\":\n                result += \"L\"\n            case\
    \ \"m\":\n                result += \"M\"\n            case \"n\":\n         \
    \       result += \"N\"\n            case \"o\":\n                result += \"\
    O\"\n            case \"p\":\n                result += \"P\"\n            case\
    \ \"q\":\n                result += \"Q\"\n            case \"r\":\n         \
    \       result += \"R\"\n            case \"s\":\n                result += \"\
    S\"\n            case \"t\":\n                result += \"T\"\n            case\
    \ \"u\":\n                result += \"U\"\n            case \"v\":\n         \
    \       result += \"V\"\n            case \"w\":\n                result += \"\
    W\"\n            case \"x\":\n                result += \"X\"\n            case\
    \ \"y\":\n                result += \"Y\"\n            case \"z\":\n         \
    \       result += \"Z\"\n            default:\n                result += char\n\
    \            }\n        } else {\n            result += char\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp2at5tr5y.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp2at5tr5y.swift:14:17:\
    \ error: cannot call value of non-function type 'Bool'\n        if char.isLetter()\
    \ {\n                ^       ~~\n                        \n/tmp/tmp2at5tr5y.swift:69:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                result += char\n                          ^\n/tmp/tmp2at5tr5y.swift:72:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var res = \"\"\n    for char in s.characters {\n        if\
    \ char.isLetter {\n            res = char.lowercased() + res\n        } else {\n\
    \            res = char + res\n        }\n    }\n    return res\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmprm5w04_i.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmprm5w04_i.swift:17:19:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            res = char + res\n                  ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case let c as Character:\n            switch c {\n  \
    \          case .lowercase:\n                result += String.init(c).uppercased()\n\
    \            case .uppercase:\n                result += String.init(c).lowercased()\n\
    \            default:\n                result += c\n            }\n        case\
    \ let c as String:\n            result += c\n        default:\n            result\
    \ += char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp5fat5pny.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp5fat5pny.swift:15:20:\
    \ warning: 'as' test is always true\n        case let c as Character:\n      \
    \             ^\n/tmp/tmp5fat5pny.swift:24:20: warning: cast from 'Character'\
    \ to unrelated type 'String' always fails\n        case let c as String:\n   \
    \                ^~ ~~~~~~\n/tmp/tmp5fat5pny.swift:17:19: error: type 'Character'\
    \ has no member 'lowercase'\n            case .lowercase:\n                 ~^~~~~~~~~\n\
    /tmp/tmp5fat5pny.swift:19:19: error: type 'Character' has no member 'uppercase'\n\
    \            case .uppercase:\n                 ~^~~~~~~~~\n/tmp/tmp5fat5pny.swift:22:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                result += c\n                          ^\n/tmp/tmp5fat5pny.swift:27:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            switch char.lowercased() {\n            case \"a\":\n       \
    \         result += \"A\"\n            case \"b\":\n                result +=\
    \ \"b\"\n            case \"c\":\n                result += \"C\"\n          \
    \  case \"d\":\n                result += \"D\"\n            case \"e\":\n   \
    \             result += \"E\"\n            case \"f\":\n                result\
    \ += \"F\"\n            case \"g\":\n                result += \"G\"\n       \
    \     case \"h\":\n                result += \"H\"\n            case \"i\":\n\
    \                result += \"I\"\n            case \"j\":\n                result\
    \ += \"J\"\n            case \"k\":\n                result += \"K\"\n       \
    \     case \"l\":\n                result += \"L\"\n            case \"m\":\n\
    \                result += \"M\"\n            case \"n\":\n                result\
    \ += \"N\"\n            case \"o\":\n                result += \"O\"\n       \
    \     case \"p\":\n                result += \"P\"\n            case \"q\":\n\
    \                result += \"Q\"\n            case \"r\":\n                result\
    \ += \"R\"\n            case \"s\":\n                result += \"S\"\n       \
    \     case \"t\":\n                result += \"T\"\n            case \"u\":\n\
    \                result += \"U\"\n            case \"v\":\n                result\
    \ += \"V\"\n            case \"w\":\n                result += \"W\"\n       \
    \     case \"x\":\n                result += \"X\"\n            case \"y\":\n\
    \                result += \"Y\"\n            case \"z\":\n                result\
    \ += \"Z\"\n            default:\n                result += char\n           \
    \ }\n        } else {\n            result += char\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpggdipbze.swift:14:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpggdipbze.swift:69:27: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n                result\
    \ += char\n                          ^\n/tmp/tmpggdipbze.swift:72:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            let lower = char.lowercaseString\n            let upper = char.uppercaseString\n\
    \            if lower == upper {\n                result += lower\n          \
    \  } else {\n                result += upper\n            }\n        } else {\n\
    \            result += char\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpp7_w_3e9.swift:14:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpp7_w_3e9.swift:15:30: error: value of type 'Character'\
    \ has no member 'lowercaseString'\n            let lower = char.lowercaseString\n\
    \                        ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpp7_w_3e9.swift:16:30: error:\
    \ value of type 'Character' has no member 'uppercaseString'\n            let upper\
    \ = char.uppercaseString\n                        ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpp7_w_3e9.swift:23:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ if char.isLetter {\n            result += String(char.uppercased())\n      \
    \  } else {\n            result += String(char)\n        }\n    }\n    if result.characters.count\
    \ == 0 {\n        return \"\"\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp4tciu7f5.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp4tciu7f5.swift:20:15:\
    \ error: 'characters' is unavailable: Please use String directly\n    if result.characters.count\
    \ == 0 {\n              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ if char.isLetter {\n            let upper = char.uppercaseString\n         \
    \   let lower = char.lowercaseString\n            result = upper.characters.joinWithSeparator(lower)\
    \ + result\n        } else {\n            result = char + result\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpcf5ey3gx.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpcf5ey3gx.swift:15:30:\
    \ error: value of type 'Character' has no member 'uppercaseString'\n         \
    \   let upper = char.uppercaseString\n                        ~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmpcf5ey3gx.swift:16:30: error: value of type 'Character' has no member 'lowercaseString'\n\
    \            let lower = char.lowercaseString\n                        ~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmpcf5ey3gx.swift:19:22: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result = char + result\n   \
    \                  ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    return s.characters.reversed().reduce(\"\") { $0 + String($1)\
    \ + String($2) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp8mjtn441.swift:12:12: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n    return s.characters.reversed().reduce(\"\") { $0 + String($1)\
    \ + String($2) }\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659825115
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for letter in s {\n        switch letter\
    \ {\n        case \"a\":\n            letter = \"A\"\n        case \"b\":\n  \
    \          letter = \"B\"\n        case \"c\":\n            letter = \"C\"\n \
    \       case \"d\":\n            letter = \"D\"\n        case \"e\":\n       \
    \     letter = \"E\"\n        case \"f\":\n            letter = \"F\"\n      \
    \  case \"g\":\n            letter = \"G\"\n        case \"h\":\n            letter\
    \ = \"H\"\n        case \"i\":\n            letter = \"I\"\n        case \"j\"\
    :\n            letter = \"J\"\n        case \"k\":\n            letter = \"K\"\
    \n        case \"l\":\n            letter = \"L\"\n        case \"m\":\n     \
    \       letter = \"M\"\n        case \"n\":\n            letter = \"N\"\n    \
    \    case \"o\":\n            letter = \"O\"\n        case \"p\":\n          \
    \  letter = \"P\"\n        case \"q\":\n            letter = \"Q\"\n        case\
    \ \"r\":\n            letter = \"R\"\n        case \"s\":\n            letter\
    \ = \"S\"\n        case \"t\":\n            letter = \"T\"\n        case \"u\"\
    :\n            letter = \"U\"\n        case \"v\":\n            letter = \"V\"\
    \n        case \"w\":\n            letter = \"W\"\n        case \"x\":\n     \
    \       letter = \"X\"\n        case \"y\":\n            letter = \"Y\"\n    \
    \    case \"z\":\n            letter = \"Z\"\n        default:\n            letter\
    \ = letter\n        }\n        result += letter\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp7mf6xa5x.swift:16:13: error: cannot assign to value: 'letter' is\
    \ a 'let' constant\n            letter = \"A\"\n            ^~~~~~\n/tmp/tmp7mf6xa5x.swift:18:13:\
    \ error: cannot assign to value: 'letter' is a 'let' constant\n            letter\
    \ = \"B\"\n            ^~~~~~\n/tmp/tmp7mf6xa5x.swift:20:13: error: cannot assign\
    \ to value: 'letter' is a 'let' constant\n            letter = \"C\"\n       \
    \     ^~~~~~\n/tmp/tmp7mf6xa5x.swift:22:13: error: cannot assign to value: 'letter'\
    \ is a 'let' constant\n            letter = \"D\"\n            ^~~~~~\n/tmp/tmp7mf6xa5x.swift:24:13:\
    \ error: cannot assign to value: 'letter' is a 'let' constant\n            letter\
    \ = \"E\"\n            ^~~~~~\n/tmp/tmp7mf6xa5x.swift:26:13: error: cannot assign\
    \ to value: 'letter' is a 'let' constant\n            letter = \"F\"\n       \
    \     ^~~~~~\n/tmp/tmp7mf6xa5x.swift:28:13: error: cannot assign to value: 'letter'\
    \ is a 'let' constant\n            letter = \"G\"\n            ^~~~~~\n/tmp/tmp7mf6xa5x.swift:30:13:\
    \ error: cannot assign to value: 'letter' is a 'let' constant\n            letter\
    \ = \"H\"\n            ^~~~~~\n/tmp/tmp7mf6xa5x.swift:32:13: error: cannot assign\
    \ to value: 'letter' is a 'let' constant\n            letter = \"I\"\n       \
    \     ^~~~~~\n/tmp/tmp7mf6xa5x.swift:34:13: error: cannot assign to value: 'letter'\
    \ is a 'let' constant\n            letter = \"J\"\n            ^~~~~~\n/tmp/tmp7mf6xa5x.swift:36:13:\
    \ error: cannot assign to value: 'letter' is a 'let' constant\n            letter\
    \ = \"K\"\n            ^~~~~~\n/tmp/tmp7mf6xa5x.swift:38:13: error: cannot assign\
    \ to value: 'letter' is a 'let' constant\n            letter = \"L\"\n       \
    \     ^~~~~~\n/tmp/tmp7mf6xa5x.swift:40:13: error: cannot assign to value: 'letter'\
    \ is a 'let' constant\n            letter = \"M\"\n            ^~~~~~\n/tmp/tmp7mf6xa5x.swift:42:13:\
    \ error: cannot assign to value: 'letter' is a 'let' constant\n            letter\
    \ = \"N\"\n            ^~~~~~\n/tmp/tmp7mf6xa5x.swift:44:13: error: cannot assign\
    \ to value: 'letter' is a 'let' constant\n            letter = \"O\"\n       \
    \     ^~~~~~\n/tmp/tmp7mf6xa5x.swift:46:13: error: c"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        switch char\
    \ {\n        case \"a\":\n            result = \"A\" + result\n        case \"\
    b\":\n            result = \"B\" + result\n        case \"c\":\n            result\
    \ = \"C\" + result\n        case \"d\":\n            result = \"D\" + result\n\
    \        case \"e\":\n            result = \"E\" + result\n        case \"f\"\
    :\n            result = \"F\" + result\n        case \"g\":\n            result\
    \ = \"G\" + result\n        case \"h\":\n            result = \"H\" + result\n\
    \        case \"i\":\n            result = \"I\" + result\n        case \"j\"\
    :\n            result = \"J\" + result\n        case \"k\":\n            result\
    \ = \"K\" + result\n        case \"l\":\n            result = \"L\" + result\n\
    \        case \"m\":\n            result = \"M\" + result\n        case \"n\"\
    :\n            result = \"N\" + result\n        case \"o\":\n            result\
    \ = \"O\" + result\n        case \"p\":\n            result = \"P\" + result\n\
    \        case \"q\":\n            result = \"Q\" + result\n        case \"r\"\
    :\n            result = \"R\" + result\n        case \"s\":\n            result\
    \ = \"S\" + result\n        case \"t\":\n            result = \"T\" + result\n\
    \        case \"u\":\n            result = \"U\" + result\n        case \"v\"\
    :\n            result = \"V\" + result\n        case \"w\":\n            result\
    \ = \"W\" + result\n        case \"x\":\n            result = \"X\" + result\n\
    \        case \"y\":\n            result = \"Y\" + result\n        case \"z\"\
    :\n            result = \"Z\" + result\n        default:\n            result =\
    \ char + result\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp1sq9tdg8.swift:68:22: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result = char + result\n   \
    \                  ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            let upper = char.uppercased()\n            let lower = char.lowercased()\n\
    \            if upper != nil {\n                result += upper!\n           \
    \ } else {\n                result += lower!\n            }\n        } else {\n\
    \            result += char\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp6v9focj2.swift:14:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmp6v9focj2.swift:17:22: warning: comparing non-optional\
    \ value of type 'String' to 'nil' always returns true\n            if upper !=\
    \ nil {\n               ~~~~~ ^  ~~~\n/tmp/tmp6v9focj2.swift:18:32: error: cannot\
    \ force unwrap value of non-optional type 'String'\n                result +=\
    \ upper!\n                          ~~~~~^\n                               \n\
    /tmp/tmp6v9focj2.swift:20:32: error: cannot force unwrap value of non-optional\
    \ type 'String'\n                result += lower!\n                          ~~~~~^\n\
    \                               \n/tmp/tmp6v9focj2.swift:23:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            switch char.lowercased() {\n            case \"a\":\n       \
    \         result += \"A\"\n            case \"b\":\n                result +=\
    \ \"b\"\n            case \"c\":\n                result += \"C\"\n          \
    \  case \"d\":\n                result += \"d\"\n            case \"e\":\n   \
    \             result += \"E\"\n            case \"f\":\n                result\
    \ += \"f\"\n            case \"g\":\n                result += \"g\"\n       \
    \     case \"h\":\n                result += \"H\"\n            case \"i\":\n\
    \                result += \"I\"\n            case \"j\":\n                result\
    \ += \"J\"\n            case \"k\":\n                result += \"K\"\n       \
    \     case \"l\":\n                result += \"L\"\n            case \"m\":\n\
    \                result += \"m\"\n            case \"n\":\n                result\
    \ += \"N\"\n            case \"o\":\n                result += \"O\"\n       \
    \     case \"p\":\n                result += \"P\"\n            case \"q\":\n\
    \                result += \"Q\"\n            case \"r\":\n                result\
    \ += \"R\"\n            case \"s\":\n                result += \"S\"\n       \
    \     case \"t\":\n                result += \"T\"\n            case \"u\":\n\
    \                result += \"U\"\n            case \"v\":\n                result\
    \ += \"V\"\n            case \"w\":\n                result += \"W\"\n       \
    \     case \"x\":\n                result += \"X\"\n            case \"y\":\n\
    \                result += \"Y\"\n            case \"z\":\n                result\
    \ += \"Z\"\n            default:\n                result += char\n           \
    \ }\n        } else {\n            result += char\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpl4tcvvqz.swift:14:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpl4tcvvqz.swift:69:27: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n                result\
    \ += char\n                          ^\n/tmp/tmpl4tcvvqz.swift:72:23: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    return s.characters.reversed().reduce(\"\") { $0 + String($1)\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpm03cykjf.swift:12:14: error: 'characters' is unavailable: Please\
    \ use String directly\n    return s.characters.reversed().reduce(\"\") { $0 +\
    \ String($1) }\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        switch char\
    \ {\n        case \"a\":\n            result += \"A\"\n        case \"b\":\n \
    \           result += \"B\"\n        case \"c\":\n            result += \"C\"\n\
    \        case \"d\":\n            result += \"D\"\n        case \"e\":\n     \
    \       result += \"E\"\n        case \"f\":\n            result += \"F\"\n  \
    \      case \"g\":\n            result += \"G\"\n        case \"h\":\n       \
    \     result += \"H\"\n        case \"i\":\n            result += \"I\"\n    \
    \    case \"j\":\n            result += \"J\"\n        case \"k\":\n         \
    \   result += \"K\"\n        case \"l\":\n            result += \"L\"\n      \
    \  case \"m\":\n            result += \"M\"\n        case \"n\":\n           \
    \ result += \"N\"\n        case \"o\":\n            result += \"O\"\n        case\
    \ \"p\":\n            result += \"P\"\n        case \"q\":\n            result\
    \ += \"Q\"\n        case \"r\":\n            result += \"R\"\n        case \"\
    s\":\n            result += \"S\"\n        case \"t\":\n            result +=\
    \ \"T\"\n        case \"u\":\n            result += \"U\"\n        case \"v\"\
    :\n            result += \"V\"\n        case \"w\":\n            result += \"\
    W\"\n        case \"x\":\n            result += \"X\"\n        case \"y\":\n \
    \           result += \"Y\"\n        case \"z\":\n            result += \"Z\"\n\
    \        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpjj_vz36b.swift:68:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case let c where c.isLetter:\n            result += String(char.lowercased())\n\
    \        case let c where !c.isLetter:\n            result += String(char)\n \
    \       default:\n            result += String(char)\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpyo2agtw0.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case 'a':\n            result += \"A\"\n        case\
    \ 'b':\n            result += \"b\"\n        case 'c':\n            result +=\
    \ \"C\"\n        case 'd':\n            result += \"d\"\n        case 'e':\n \
    \           result += \"E\"\n        case 'f':\n            result += \"f\"\n\
    \        case 'g':\n            result += \"G\"\n        case 'h':\n         \
    \   result += \"h\"\n        case 'i':\n            result += \"I\"\n        case\
    \ 'j':\n            result += \"j\"\n        case 'k':\n            result +=\
    \ \"K\"\n        case 'l':\n            result += \"L\"\n        case 'm':\n \
    \           result += \"m\"\n        case 'n':\n            result += \"N\"\n\
    \        case 'o':\n            result += \"O\"\n        case 'p':\n         \
    \   result += \"p\"\n        case 'q':\n            result += \"Q\"\n        case\
    \ 'r':\n            result += \"r\"\n        case 's':\n            result +=\
    \ \"S\"\n        case 't':\n            result += \"T\"\n        case 'u':\n \
    \           result += \"U\"\n        case 'v':\n            result += \"V\"\n\
    \        case 'w':\n            result += \"W\"\n        case 'x':\n         \
    \   result += \"X\"\n        case 'y':\n            result += \"Y\"\n        case\
    \ 'z':\n            result += \"Z\"\n        default:\n            result += char\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpw_8mezy_.swift:15:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpw_8mezy_.swift:17:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmpw_8mezy_.swift:19:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmpw_8mezy_.swift:21:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmpw_8mezy_.swift:23:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpw_8mezy_.swift:25:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmpw_8mezy_.swift:27:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmpw_8mezy_.swift:29:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmpw_8mezy_.swift:31:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmpw_8mezy_.swift:33:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmpw_8mezy_.swift:35:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmpw_8mezy_.swift:37:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmpw_8mezy_.swift:39:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmpw_8mezy_.swift:41:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmpw_8mezy_.swift:43:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmpw_8mezy_.swift:45:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659824675
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var res = \"\"\n    for char in s {\n        if char.isLetter\
    \ {\n            res = char.lowercased() + res\n        } else {\n           \
    \ res = char.uppercased() + res\n        }\n    }\n    return res\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmptiwuwyki/tmptiwuwyki.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f0dc16c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f0d90db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0f0d90d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0f0d90c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptiwuwyki                        0x00005582c7dcd517 <unavailable> + 5399

    5    libc.so.6                          0x00002b0f0de02460 __libc_start_main +
    245

    6    tmptiwuwyki                        0x00005582c7dcd159 <unavailable> + 4441

    '
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case let c as Character:\n            switch c {\n  \
    \          case .lowercase:\n                result += String.localizedStringWithUppercase(char)\n\
    \            case .uppercase:\n                result += String.localizedStringWithLowercase(char)\n\
    \            default:\n                result += char\n            }\n       \
    \ case let c as String:\n            result += c\n        default:\n         \
    \   result += char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpaygh8mrh.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpaygh8mrh.swift:15:20:\
    \ warning: 'as' test is always true\n        case let c as Character:\n      \
    \             ^\n/tmp/tmpaygh8mrh.swift:24:20: warning: cast from 'Character'\
    \ to unrelated type 'String' always fails\n        case let c as String:\n   \
    \                ^~ ~~~~~~\n/tmp/tmpaygh8mrh.swift:17:19: error: type 'Character'\
    \ has no member 'lowercase'\n            case .lowercase:\n                 ~^~~~~~~~~\n\
    /tmp/tmpaygh8mrh.swift:19:19: error: type 'Character' has no member 'uppercase'\n\
    \            case .uppercase:\n                 ~^~~~~~~~~\n/tmp/tmpaygh8mrh.swift:18:34:\
    \ error: type 'String' has no member 'localizedStringWithUppercase'\n        \
    \        result += String.localizedStringWithUppercase(char)\n               \
    \           ~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpaygh8mrh.swift:20:34:\
    \ error: type 'String' has no member 'localizedStringWithLowercase'\n        \
    \        result += String.localizedStringWithLowercase(char)\n               \
    \           ~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpaygh8mrh.swift:22:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                result += char\n                          ^\n/tmp/tmpaygh8mrh.swift:27:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ if char.isLetter {\n            let upper = char.uppercaseString\n         \
    \   let lower = char.lowercaseString\n            if upper != \"\" {\n       \
    \         result += upper\n            } else {\n                result += lower\n\
    \            }\n        } else {\n            result += char\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpzimubx10.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpzimubx10.swift:15:30:\
    \ error: value of type 'Character' has no member 'uppercaseString'\n         \
    \   let upper = char.uppercaseString\n                        ~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmpzimubx10.swift:16:30: error: value of type 'Character' has no member 'lowercaseString'\n\
    \            let lower = char.lowercaseString\n                        ~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmpzimubx10.swift:23:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    return s.characters.reduce(\"\") { $0 + String($1).capitalized\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpoxmp5yi_.swift:12:54: error: value of type 'String' has no member\
    \ 'capitalized'\n    return s.characters.reduce(\"\") { $0 + String($1).capitalized\
    \ }\n                                          ~~~~~~~~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    var i = 0\n    for char in s {\n   \
    \     switch char {\n        case \"a\":\n            result += \"A\"\n      \
    \  case \"b\":\n            result += \"b\"\n        case \"c\":\n           \
    \ result += \"C\"\n        case \"d\":\n            result += \"D\"\n        case\
    \ \"e\":\n            result += \"E\"\n        case \"f\":\n            result\
    \ += \"F\"\n        case \"g\":\n            result += \"G\"\n        case \"\
    h\":\n            result += \"H\"\n        case \"i\":\n            result +=\
    \ \"I\"\n        case \"j\":\n            result += \"J\"\n        case \"k\"\
    :\n            result += \"K\"\n        case \"l\":\n            result += \"\
    L\"\n        case \"m\":\n            result += \"M\"\n        case \"n\":\n \
    \           result += \"N\"\n        case \"o\":\n            result += \"O\"\n\
    \        case \"p\":\n            result += \"P\"\n        case \"q\":\n     \
    \       result += \"Q\"\n        case \"r\":\n            result += \"R\"\n  \
    \      case \"s\":\n            result += \"S\"\n        case \"t\":\n       \
    \     result += \"T\"\n        case \"u\":\n            result += \"U\"\n    \
    \    case \"v\":\n            result += \"V\"\n        case \"w\":\n         \
    \   result += \"W\"\n        case \"x\":\n            result += \"X\"\n      \
    \  case \"y\":\n            result += \"Y\"\n        case \"z\":\n           \
    \ result += \"Z\"\n        default:\n            result += char\n        }\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp6iit2w1f.swift:69:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ if char.isLetter() {\n            let upper = char.uppercased()\n          \
    \  let lower = char.lowercased()\n            if upper != nil {\n            \
    \    result += upper!\n            } else {\n                result += lower!\n\
    \            }\n        } else {\n            result += char\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpd2r165ii.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpd2r165ii.swift:14:17:\
    \ error: cannot call value of non-function type 'Bool'\n        if char.isLetter()\
    \ {\n                ^       ~~\n                        \n/tmp/tmpd2r165ii.swift:17:22:\
    \ warning: comparing non-optional value of type 'String' to 'nil' always returns\
    \ true\n            if upper != nil {\n               ~~~~~ ^  ~~~\n/tmp/tmpd2r165ii.swift:18:32:\
    \ error: cannot force unwrap value of non-optional type 'String'\n           \
    \     result += upper!\n                          ~~~~~^\n                   \
    \            \n/tmp/tmpd2r165ii.swift:20:32: error: cannot force unwrap value\
    \ of non-optional type 'String'\n                result += lower!\n          \
    \                ~~~~~^\n                               \n/tmp/tmpd2r165ii.swift:23:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    return s.characters.reversed().reduce(\"\") { $0 + String($1)\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpm03cykjf.swift:12:14: error: 'characters' is unavailable: Please\
    \ use String directly\n    return s.characters.reversed().reduce(\"\") { $0 +\
    \ String($1) }\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    return s.characters.reduce(\"\") { $0 + String($1) }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpg6vefuyv.swift:12:14: error: 'characters' is unavailable: Please\
    \ use String directly\n    return s.characters.reduce(\"\") { $0 + String($1)\
    \ }\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ if char.isLetter {\n            result += char.lowercaseString\n        } else\
    \ {\n            result += char\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp7fdn3rg0.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp7fdn3rg0.swift:15:28:\
    \ error: value of type 'Character' has no member 'lowercaseString'\n         \
    \   result += char.lowercaseString\n                      ~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmp7fdn3rg0.swift:17:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for letter in s {\n        switch letter\
    \ {\n        case \"a\":\n            result += \"A\"\n        case \"b\":\n \
    \           result += \"b\"\n        case \"c\":\n            result += \"C\"\n\
    \        case \"d\":\n            result += \"D\"\n        case \"e\":\n     \
    \       result += \"E\"\n        case \"f\":\n            result += \"F\"\n  \
    \      case \"g\":\n            result += \"G\"\n        case \"h\":\n       \
    \     result += \"H\"\n        case \"i\":\n            result += \"I\"\n    \
    \    case \"j\":\n            result += \"J\"\n        case \"k\":\n         \
    \   result += \"K\"\n        case \"l\":\n            result += \"L\"\n      \
    \  case \"m\":\n            result += \"M\"\n        case \"n\":\n           \
    \ result += \"N\"\n        case \"o\":\n            result += \"O\"\n        case\
    \ \"p\":\n            result += \"P\"\n        case \"q\":\n            result\
    \ += \"Q\"\n        case \"r\":\n            result += \"R\"\n        case \"\
    s\":\n            result += \"S\"\n        case \"t\":\n            result +=\
    \ \"T\"\n        case \"u\":\n            result += \"U\"\n        case \"v\"\
    :\n            result += \"V\"\n        case \"w\":\n            result += \"\
    W\"\n        case \"x\":\n            result += \"X\"\n        case \"y\":\n \
    \           result += \"Y\"\n        case \"z\":\n            result += \"Z\"\n\
    \        default:\n            result += letter\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp5htqysc0.swift:68:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += letter\n         \
    \             ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ if char.isLetter() {\n            let upper = char.uppercased()\n          \
    \  let lower = char.lowercased()\n            result = upper.stringByAppendingString(lower)\n\
    \        } else {\n            result = char.stringByAppendingString(result)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp3k1a8g6q.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp3k1a8g6q.swift:14:17:\
    \ error: cannot call value of non-function type 'Bool'\n        if char.isLetter()\
    \ {\n                ^       ~~\n                        \n/tmp/tmp3k1a8g6q.swift:17:28:\
    \ error: value of type 'String' has no member 'stringByAppendingString'\n    \
    \        result = upper.stringByAppendingString(lower)\n                     ~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp3k1a8g6q.swift:19:27: error: value of type\
    \ 'Character' has no member 'stringByAppendingString'\n            result = char.stringByAppendingString(result)\n\
    \                     ~~~~ ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    return s.characters.reduce(\"\") { (result, c) in\n       \
    \ guard let c = c else { return result }\n        switch c {\n        case \"\
    .\":\n            return result + String(c)\n        case \"@\":\n           \
    \ return result + String(c)\n        default:\n            return result + String(c).lowercased()\n\
    \        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp031uhxwb.swift:13:15: error: initializer for conditional binding\
    \ must have Optional type, not 'String.Element' (aka 'Character')\n        guard\
    \ let c = c else { return result }\n              ^       ~\n/tmp/tmp031uhxwb.swift:12:14:\
    \ error: 'characters' is unavailable: Please use String directly\n    return s.characters.reduce(\"\
    \") { (result, c) in\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    return s.characters.reversed().reduce(\"\") { $0 + String($1)\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpm03cykjf.swift:12:14: error: 'characters' is unavailable: Please\
    \ use String directly\n    return s.characters.reversed().reduce(\"\") { $0 +\
    \ String($1) }\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        switch char\
    \ {\n        case \"a\":\n            result += \"A\"\n        case \"b\":\n \
    \           result += \"b\"\n        case \"c\":\n            result += \"C\"\n\
    \        case \"d\":\n            result += \"D\"\n        case \"e\":\n     \
    \       result += \"E\"\n        case \"f\":\n            result += \"F\"\n  \
    \      case \"g\":\n            result += \"G\"\n        case \"h\":\n       \
    \     result += \"H\"\n        case \"i\":\n            result += \"I\"\n    \
    \    case \"j\":\n            result += \"J\"\n        case \"k\":\n         \
    \   result += \"K\"\n        case \"l\":\n            result += \"L\"\n      \
    \  case \"m\":\n            result += \"M\"\n        case \"n\":\n           \
    \ result += \"N\"\n        case \"o\":\n            result += \"O\"\n        case\
    \ \"p\":\n            result += \"P\"\n        case \"q\":\n            result\
    \ += \"Q\"\n        case \"r\":\n            result += \"R\"\n        case \"\
    s\":\n            result += \"S\"\n        case \"t\":\n            result +=\
    \ \"T\"\n        case \"u\":\n            result += \"U\"\n        case \"v\"\
    :\n            result += \"V\"\n        case \"w\":\n            result += \"\
    W\"\n        case \"x\":\n            result += \"X\"\n        case \"y\":\n \
    \           result += \"Y\"\n        case \"z\":\n            result += \"Z\"\n\
    \        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpv3q437oa.swift:68:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    return s.characters.reversed().reduce(\"\") { $0 + String($1)\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpm03cykjf.swift:12:14: error: 'characters' is unavailable: Please\
    \ use String directly\n    return s.characters.reversed().reduce(\"\") { $0 +\
    \ String($1) }\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659824674
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        switch char\
    \ {\n        case \"a\":\n            result += \"A\"\n        case \"b\":\n \
    \           result += \"b\"\n        case \"c\":\n            result += \"C\"\n\
    \        case \"d\":\n            result += \"D\"\n        case \"e\":\n     \
    \       result += \"E\"\n        case \"f\":\n            result += \"F\"\n  \
    \      case \"g\":\n            result += \"G\"\n        case \"h\":\n       \
    \     result += \"H\"\n        case \"i\":\n            result += \"I\"\n    \
    \    case \"j\":\n            result += \"J\"\n        case \"k\":\n         \
    \   result += \"K\"\n        case \"l\":\n            result += \"L\"\n      \
    \  case \"m\":\n            result += \"M\"\n        case \"n\":\n           \
    \ result += \"N\"\n        case \"o\":\n            result += \"O\"\n        case\
    \ \"p\":\n            result += \"P\"\n        case \"q\":\n            result\
    \ += \"Q\"\n        case \"r\":\n            result += \"R\"\n        case \"\
    s\":\n            result += \"S\"\n        case \"t\":\n            result +=\
    \ \"T\"\n        case \"u\":\n            result += \"U\"\n        case \"v\"\
    :\n            result += \"V\"\n        case \"w\":\n            result += \"\
    W\"\n        case \"x\":\n            result += \"X\"\n        case \"y\":\n \
    \           result += \"Y\"\n        case \"z\":\n            result += \"Z\"\n\
    \        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpv3q437oa.swift:68:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s {\n        if char.isLetter()\
    \ {\n            let upperCase = char.uppercased()\n            let lowerCase\
    \ = char.lowercased()\n            if upperCase != lowerCase {\n             \
    \   result += upperCase\n            } else {\n                result += lowerCase\n\
    \            }\n        } else {\n            result += char\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp6gdwlzbm.swift:14:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmp6gdwlzbm.swift:23:23: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n            result +=\
    \ char\n                      ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case let c as Character:\n            switch c {\n  \
    \          case .lowercase:\n                result += \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    [c]\n            case .uppercase:\n                result += \"abcdefghijklmnopqrstuvwxyz\"\
    [c]\n            case .digit:\n                result += \"0123456789\"[c]\n \
    \           default:\n                result += char\n            }\n        case\
    \ let c as String:\n            result += c\n        default:\n            result\
    \ += char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp3ihcsrrh.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp3ihcsrrh.swift:15:20:\
    \ warning: 'as' test is always true\n        case let c as Character:\n      \
    \             ^\n/tmp/tmp3ihcsrrh.swift:26:20: warning: cast from 'Character'\
    \ to unrelated type 'String' always fails\n        case let c as String:\n   \
    \                ^~ ~~~~~~\n/tmp/tmp3ihcsrrh.swift:17:19: error: type 'Character'\
    \ has no member 'lowercase'\n            case .lowercase:\n                 ~^~~~~~~~~\n\
    /tmp/tmp3ihcsrrh.swift:19:19: error: type 'Character' has no member 'uppercase'\n\
    \            case .uppercase:\n                 ~^~~~~~~~~\n/tmp/tmp3ihcsrrh.swift:21:19:\
    \ error: type 'Character' has no member 'digit'\n            case .digit:\n  \
    \               ~^~~~~\n/tmp/tmp3ihcsrrh.swift:18:55: error: no exact matches\
    \ in call to subscript \n                result += \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    [c]\n                                                      ^\nSwift.String:3:12:\
    \ note: candidate expects value of type 'Range<String.Index>' for parameter #1\
    \ (got 'Character')\n    public subscript(r: Range<String.Index>) -> Substring\
    \ { get }\n           ^\nSwift.Collection:3:23: note: candidate expects value\
    \ of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Character')\n    @inlinable\
    \ public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }\n \
    \                     ^\n/tmp/tmp3ihcsrrh.swift:20:55: error: no exact matches\
    \ in call to subscript \n                result += \"abcdefghijklmnopqrstuvwxyz\"\
    [c]\n                                                      ^\nSwift.String:3:12:\
    \ note: candidate expects value of type 'Range<String.Index>' for parameter #1\
    \ (got 'Character')\n    public subscript(r: Range<String.Index>) -> Substring\
    \ { get }\n           ^\nSwift.Collection:3:23: note: candidate expects value\
    \ of type '(UnboundedRange_) -> ()' for"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ if char.isLetter {\n            result += String(char.uppercased())\n      \
    \  } else {\n            result += String(char)\n        }\n    }\n    if result.characters.count\
    \ == 0 {\n        return String(result)\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmppmeuz_5t.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmppmeuz_5t.swift:20:15:\
    \ error: 'characters' is unavailable: Please use String directly\n    if result.characters.count\
    \ == 0 {\n              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n"
  stdout: ''
  timestamp: 1659824675
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s: String)\
    \ -> String {\n    var result = \"\"\n    for char in s.characters {\n       \
    \ switch char {\n        case 'a':\n            result += \"A\"\n        case\
    \ 'b':\n            result += \"b\"\n        case 'c':\n            result +=\
    \ \"C\"\n        case 'd':\n            result += \"d\"\n        case 'e':\n \
    \           result += \"E\"\n        case 'f':\n            result += \"f\"\n\
    \        case 'g':\n            result += \"G\"\n        case 'h':\n         \
    \   result += \"H\"\n        case 'i':\n            result += \"I\"\n        case\
    \ 'j':\n            result += \"J\"\n        case 'k':\n            result +=\
    \ \"K\"\n        case 'l':\n            result += \"L\"\n        case 'm':\n \
    \           result += \"M\"\n        case 'n':\n            result += \"N\"\n\
    \        case 'o':\n            result += \"O\"\n        case 'p':\n         \
    \   result += \"P\"\n        case 'q':\n            result += \"Q\"\n        case\
    \ 'r':\n            result += \"R\"\n        case 's':\n            result +=\
    \ \"S\"\n        case 't':\n            result += \"T\"\n        case 'u':\n \
    \           result += \"U\"\n        case 'v':\n            result += \"V\"\n\
    \        case 'w':\n            result += \"W\"\n        case 'x':\n         \
    \   result += \"X\"\n        case 'y':\n            result += \"Y\"\n        case\
    \ 'z':\n            result += \"Z\"\n        default:\n            result += char\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpwzlievm8.swift:15:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpwzlievm8.swift:17:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmpwzlievm8.swift:19:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmpwzlievm8.swift:21:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmpwzlievm8.swift:23:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpwzlievm8.swift:25:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmpwzlievm8.swift:27:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmpwzlievm8.swift:29:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmpwzlievm8.swift:31:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmpwzlievm8.swift:33:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmpwzlievm8.swift:35:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmpwzlievm8.swift:37:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmpwzlievm8.swift:39:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmpwzlievm8.swift:41:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmpwzlievm8.swift:43:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmpwzlievm8.swift:45:14: error: single-quoted st"
  stdout: ''
  timestamp: 1659824674
