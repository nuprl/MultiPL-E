name: HumanEval_2_truncate_number
language: swift
prompt: "\n/// Given a positive floating point number, it can be decomposed into\n\
  /// and integer part (largest integer smaller than given number) and decimals\n\
  /// (leftover part always smaller than 1).\n/// Return the decimal part of the number.\n\
  /// >>> truncate_number(3.5)\n/// 0.5\nfunc truncate_number(number: Double) -> Double\
  \ {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
  \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
completions: ['    return Double(number).truncatingRemainder(dividingBy: 1)', "  \
    \  if number < 0 {\n        return -truncate_number(-number)\n    }\n    let wholeNumber\
    \ = floor(number)\n    let decimalPart = number - wholeNumber\n    return wholeNumber\
    \ + decimalPart", '    return truncate_number(number, 1)', "    let integerPart\
    \ = Int(number)\n    let decimalPart = number - Double(integerPart)\n    return\
    \ Double(integerPart) + decimalPart", "    let intPart = (number as NSNumber).doubleValue\n\
    \    let decimalPart = (number - intPart).truncatingRemainder(dividingBy: 1)\n\
    \    return intPart + decimalPart", "    let decimalPart = number % 1\n    let\
    \ integerPart = floor(number)\n    return integerPart + decimalPart", "    let\
    \ (integer, decimal) = Double(number).truncatingRemainder(dividingBy: 1)\n   \
    \ return Double(integer) + decimal", "    let decimalPart = number % 1\n    let\
    \ integerPart = floor(number)\n    return integerPart + decimalPart", "    if\
    \ number < 1.0 {\n        return number\n    }\n    let remainder = number % 1.0\n\
    \    return number - remainder", "    if number < 0 {\n        return -truncate_number(-number)\n\
    \    }\n    return trunc(number)", "    let decimalPart = floor(log10(number)\
    \ + 1)\n    let integerPart = floor(number / pow(10.0, Double(decimalPart)))\n\
    \    return Double(integerPart) * pow(10.0, Double(decimalPart))", "    let result\
    \ = Double(trunc(number))\n    if number < result {\n        return result - 1.0\n\
    \    }\n    return result", "    let decimalPart = number % 1\n    let integerPart\
    \ = floor(number)\n    return integerPart + decimalPart", "    let (integer, decimal)\
    \ = Double(number).truncatingRemainder(dividingBy: 1)\n    return Double(integer)\
    \ + decimal", "    let decimalPart = number % 1\n    let integerPart = floor(number)\n\
    \    return integerPart * pow(10, Double(log10(Double(number)))) + decimalPart",
  '    return Double(number).truncatingRemainder(dividingBy: 1)', "    let integerPart\
    \ = Int(round(number))\n    let decimalPart = number - Double(integerPart)\n \
    \   return Double(integerPart) + decimalPart", "    let (integer, decimal) = Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n    return Double(integer) + decimal", "    let intPart = Int(round(number))\n\
    \    let decimalPart = number - intPart\n    return intPart + decimalPart", " \
    \   let (integer, decimal) = Double(number).truncatingRemainder(dividingBy: 1)\n\
    \    return Double(integer) + decimal"]
stop_tokens:
- "\n}"
