language: swift
name: HumanEval_25_factorize
results:
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var primeFactorization = [Int]()\n    var primeFactorizationCount = [Int]()\n\
    \    var primeFactorizationIndex = 0\n    var primeFactorizationIndexCount = 0\n\
    \    var primeFactorizationIndexCountMax = Int(Int64.max) / Int(Int64.max)\n \
    \   var isPrime = [Bool]()\n    var isPrimeCount = 0\n    var isPrimeIndex = 0\n\
    \    var isPrimeIndexCount = 0\n    var isPrimeIndexCountMax = Int(Int64.max)\
    \ / Int(Int64.max)\n    var isPrimeIndexCountMax2 = Int(Int64.max) / Int(Int64.max)\n\
    \    var isPrimeIndexCountMax3 = Int(Int64.max) / Int(Int64.max)\n    var isPrimeIndexCountMax4\
    \ = Int(Int64.max) / Int(Int64.max)\n    var isPrimeIndexCountMax5 = Int(Int64.max)\
    \ / Int(Int64.max)\n    var isPrimeIndexCountMax6 = Int(Int64.max) / Int(Int64.max)\n\
    \    var isPrimeIndexCountMax7 = Int(Int64.max) / Int(Int64.max)\n    var isPrimeIndexCountMax8\
    \ = Int(Int64.max) / Int(Int64.max)\n    var isPrimeIndexCountMax9 = Int(Int64.max)\
    \ / Int(Int64.max)\n    var isPrimeIndexCountMax10 = Int(Int64.max) / Int(Int64.max)\n\
    \    var isPrimeIndexCountMax11 = Int(Int64.max) / Int(Int64.max)\n    var isPrimeIndexCountMax12\
    \ = Int(Int64.max) / Int(Int64.max)\n    var isPrimeIndexCountMax13 = Int(Int64.max)\
    \ / Int(Int64.max)\n    var isPrimeIndexCountMax14 = Int(Int64.max) / Int(Int64.max)\n\
    \    var isPrimeIndexCountMax15 = Int(Int64.max) / Int(Int64.max)\n    var isPrimeIndexCountMax16\
    \ = Int(Int64.max) / Int(Int64.max)\n    var isPrimeIndexCountMax17 = Int(Int64.max)\
    \ / Int(Int64.max)\n    var isPrimeIndexCountMax18 = Int(Int64.max) / Int(Int64.max)\n\
    \    var isPrimeIndexCountMax19 = Int(Int64.max) / Int(Int64.max)\n    var isPrimeIndexCountMax20\
    \ = Int(Int64.max) / Int(Int64.max)\n    var isPrimeIndexCountMax21 = Int(Int64.max)\
    \ / Int(Int64.max)\n    var isPrimeIndexCountMax22 = Int(Int64.max) / Int(Int64.max)\n\
    \    var isPrimeIndexCountMax23 = Int(Int64.max) / Int(\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpah27q3nk.swift:45:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpah27q3nk.swift:12:9: warning: initialization of variable 'factorization'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorization = [Int]()\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmpah27q3nk.swift:13:9:\
    \ warning: initialization of variable 'primeFactorization' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var primeFactorization\
    \ = [Int]()\n    ~~~~^~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpah27q3nk.swift:14:9: warning:\
    \ initialization of variable 'primeFactorizationCount' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var primeFactorizationCount\
    \ = [Int]()\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpah27q3nk.swift:15:9:\
    \ warning: initialization of variable 'primeFactorizationIndex' was never used;\
    \ consider replacing with assignment to '_' or removing it\n    var primeFactorizationIndex\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpah27q3nk.swift:16:9: warning:\
    \ initialization of variable 'primeFactorizationIndexCount' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var primeFactorizationIndexCount\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpah27q3nk.swift:17:9:\
    \ warning: initialization of variable 'primeFactorizationIndexCountMax' was never\
    \ used; consider replacing with assignment to '_' or removing it\n    var primeFactorizationIndexCountMax\
    \ = Int(Int64.max) / Int(Int64.max)\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpah27q3nk.swift:18:9: warning: initialization of variable 'isPrime'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrime = [Bool]()\n    ~~~~^~~~~~~\n    _\n/tmp/tmpah27q3nk.swift:19:9:\
    \ warning: initialization of variable 'isPrimeCount' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var isPrimeCount = 0\n\
    \    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmpah27q3nk.swift:20:9: warning: initialization\
    \ of variable 'isPrimeIndex' was never use"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            factors.append(i)\n\
    \            n /= i\n        } else {\n            i += 1\n        }\n    }\n\
    \    if n > 1 {\n        factors.append(n)\n    }\n    return factors\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpv1s4fi4v.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var factorization\
    \ = factorizationOfNumber(n)\n    var factorizationCount = 1\n    for factor in\
    \ factorization {\n        if factorizationCount > 1 {\n            factors.append(factor)\n\
    \        }\n        factorizationCount *= factor\n    }\n    return factors\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpvzsfonxg.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    var j = 0\n    var k = n\n    while i < k {\n        while j < k {\n\
    \            if n % i == 0 {\n                factors.append(i)\n            \
    \    n /= i\n                j++\n            }\n            j++\n        }\n\
    \        i += 1\n        j = 0\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpqq2bkb90.swift:20:19: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n                n /= i\n                ~\
    \ ^\n/tmp/tmpqq2bkb90.swift:21:18: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n                j++\n                 ^~\n/tmp/tmpqq2bkb90.swift:23:14:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  j++\n             ^~\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var i = 2\n    var j = 1\n    var factor = 2\n    while i <= n {\n       \
    \ while n % i == 0 {\n            factorization[j] = i\n            n /= i\n \
    \           j++\n        }\n        i += 1\n    }\n    if n > 1 {\n        factorization[j]\
    \ = n\n    }\n    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpdm4nmu2j.swift:19:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n/tmp/tmpdm4nmu2j.swift:20:14:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  j++\n             ^~\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var factorizationCount = 0\n    var factorizationIndex = 0\n    var factorizationNumber\
    \ = 0\n    var factorizationNumberIndex = 0\n    var factorizationNumberCount\
    \ = 0\n    var factorizationNumberCountIndex = 0\n    var factorizationNumberCountMax\
    \ = 0\n    var factorizationNumberCountMaxIndex = 0\n    var factorizationNumberCountMin\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n    var factorizationNumberCountMaxIndex\
    \ = 0\n    var factorizationNumberCountMinIndex = 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpb10iv6lk.swift:23:9: error: invalid redeclaration of 'factorizationNumberCountMaxIndex'\n\
    \    var factorizationNumberCountMaxIndex = 0\n        ^\n/tmp/tmpb10iv6lk.swift:20:9:\
    \ note: 'factorizationNumberCountMaxIndex' previously declared here\n    var factorizationNumberCountMaxIndex\
    \ = 0\n        ^\n/tmp/tmpb10iv6lk.swift:24:9: error: invalid redeclaration of\
    \ 'factorizationNumberCountMinIndex'\n    var factorizationNumberCountMinIndex\
    \ = 0\n        ^\n/tmp/tmpb10iv6lk.swift:22:9: note: 'factorizationNumberCountMinIndex'\
    \ previously declared here\n    var factorizationNumberCountMinIndex = 0\n   \
    \     ^\n/tmp/tmpb10iv6lk.swift:25:9: error: invalid redeclaration of 'factorizationNumberCountMaxIndex'\n\
    \    var factorizationNumberCountMaxIndex = 0\n        ^\n/tmp/tmpb10iv6lk.swift:20:9:\
    \ note: 'factorizationNumberCountMaxIndex' previously declared here\n    var factorizationNumberCountMaxIndex\
    \ = 0\n        ^\n/tmp/tmpb10iv6lk.swift:26:9: error: invalid redeclaration of\
    \ 'factorizationNumberCountMinIndex'\n    var factorizationNumberCountMinIndex\
    \ = 0\n        ^\n/tmp/tmpb10iv6lk.swift:22:9: note: 'factorizationNumberCountMinIndex'\
    \ previously declared here\n    var factorizationNumberCountMinIndex = 0\n   \
    \     ^\n/tmp/tmpb10iv6lk.swift:27:9: error: invalid redeclaration of 'factorizationNumberCountMaxIndex'\n\
    \    var factorizationNumberCountMaxIndex = 0\n        ^\n/tmp/tmpb10iv6lk.swift:20:9:\
    \ note: 'factorizationNumberCountMaxIndex' previously declared here\n    var factorizationNumberCountMaxIndex\
    \ = 0\n        ^\n/tmp/tmpb10iv6lk.swift:28:9: error: invalid redeclaration of\
    \ 'factorizationNumberCountMinIndex'\n    var factorizationNumberCountMinIndex\
    \ = 0\n        ^\n/tmp/tmpb10iv6lk.swift:22:9: note: 'factorizationNumberCountMinIndex'\
    \ previously declared here\n    var factorizationNumberCountMinIndex = 0\n   \
    \     ^\n/tmp/tmpb10iv6lk.swift:29:9: error: invalid redeclaration of 'factorizationNumberCountMaxIndex'\n\
    \    var factorizationNumberCountMaxIndex = 0\n        ^\n/tmp/tmpb10iv6lk.swift:20:9:\
    \ note: 'factorizationNumberCountMaxIndex' previously declared h"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n    var\
    \ factorization: [Int] = [1]\n    var factorizationIndex = 0\n    var currentFactorizationIndex\
    \ = 0\n    var currentFactorization = factorization[currentFactorizationIndex]\n\
    \    var currentFactorizationIndexInFactorization = 0\n    var currentFactorizationIndexInFactorizationArray\
    \ = 0\n    var currentFactorizationIndexInFactorizationArrayIndex = 0\n    var\
    \ currentFactorizationIndexInFactorizationArrayIndexMax = 0\n    var currentFactorizationIndexInFactorizationArrayIndexMin\
    \ = 0\n    var currentFactorizationIndexInFactorizationArrayMax = 0\n    var currentFactorizationIndexInFactorizationArrayMin\
    \ = 0\n    var currentFactorizationIndexInFactorizationArrayMinIndex = 0\n   \
    \ var currentFactorizationIndexInFactorizationArrayMaxIndex = 0\n    var currentFactorizationIndexInFactorizationArrayMaxIndex\
    \ = 0\n    var currentFactorizationIndexInFactorizationArrayMaxIndex = 0\n   \
    \ var currentFactorizationIndexInFactorizationArrayMaxIndex = 0\n    var currentFactorizationIndexInFactorizationArrayMaxIndex\
    \ = 0\n    var currentFactorizationIndexInFactorizationArrayMaxIndex = 0\n   \
    \ var currentFactorizationIndexInFactorizationArrayMaxIndex = 0\n    var currentFactorizationIndexInFactorizationArrayMaxIndex\
    \ = 0\n    var currentFactorizationIndexInFactorizationArrayMaxIndex = 0\n   \
    \ var currentFactorizationIndexInFactorizationArrayMaxIndex = 0\n    var currentFactorizationIndexInFactorizationArrayMaxIndex\
    \ = 0\n    var currentFactorizationIndexInFactorizationArrayMaxIndex = 0\n   \
    \ var currentFactorizationIndexInFactorizationArrayMaxIndex = 0\n    var currentFactorizationIndexInFactorizationArrayMaxIndex\
    \ = 0\n    var currentFactorizationIndexInFactorizationArrayMaxIndex = 0\n   \
    \ var currentFactorizationIndexInFactorizationArrayMaxIndex = 0\n    var currentFactorizationIndexInFactorizationArrayMaxIndex\
    \ = 0\n    var currentFactorizationIndexInFactorizationArrayMaxIndex = 0\n   \
    \ var currentFactorizationIndexInFactorizationArrayMaxIndex = 0\n    var currentFactorizationIndexInFactorizationArrayMaxIndex\
    \ = 0\n    var currentFactorizationIndexInFactorizationArrayMaxIndex = 0\n   \
    \ var currentFactorizationIndexInFactorizationArrayMaxIndex = 0\n    var currentFactorizationIndexInFactorizationArrayMaxIndex\
    \ = 0\n    var currentFactorizationIndexInFactorizationArrayMaxIndex = 0\n   \
    \ var currentFactorizationIndexInFactorizationArrayMaxIndex = 0\n    var currentFactorizationIndexInFactorizationArrayMaxIndex\
    \ = 0\n    var currentFactorizationIndexInFactorizationArrayMaxIndex = 0\n   \
    \ var currentFactorizationIndexInFactorizationArrayMaxIndex = 0\n    var currentFactorizationIndexInFactorizationArrayMaxIndex\
    \ = 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpoy0cz6ky.swift:26:9: error: invalid redeclaration of 'currentFactorizationIndexInFactorizationArrayMaxIndex'\n\
    \    var currentFactorizationIndexInFactorizationArrayMaxIndex = 0\n        ^\n\
    /tmp/tmpoy0cz6ky.swift:25:9: note: 'currentFactorizationIndexInFactorizationArrayMaxIndex'\
    \ previously declared here\n    var currentFactorizationIndexInFactorizationArrayMaxIndex\
    \ = 0\n        ^\n/tmp/tmpoy0cz6ky.swift:27:9: error: invalid redeclaration of\
    \ 'currentFactorizationIndexInFactorizationArrayMaxIndex'\n    var currentFactorizationIndexInFactorizationArrayMaxIndex\
    \ = 0\n        ^\n/tmp/tmpoy0cz6ky.swift:25:9: note: 'currentFactorizationIndexInFactorizationArrayMaxIndex'\
    \ previously declared here\n    var currentFactorizationIndexInFactorizationArrayMaxIndex\
    \ = 0\n        ^\n/tmp/tmpoy0cz6ky.swift:28:9: error: invalid redeclaration of\
    \ 'currentFactorizationIndexInFactorizationArrayMaxIndex'\n    var currentFactorizationIndexInFactorizationArrayMaxIndex\
    \ = 0\n        ^\n/tmp/tmpoy0cz6ky.swift:25:9: note: 'currentFactorizationIndexInFactorizationArrayMaxIndex'\
    \ previously declared here\n    var currentFactorizationIndexInFactorizationArrayMaxIndex\
    \ = 0\n        ^\n/tmp/tmpoy0cz6ky.swift:29:9: error: invalid redeclaration of\
    \ 'currentFactorizationIndexInFactorizationArrayMaxIndex'\n    var currentFactorizationIndexInFactorizationArrayMaxIndex\
    \ = 0\n        ^\n/tmp/tmpoy0cz6ky.swift:25:9: note: 'currentFactorizationIndexInFactorizationArrayMaxIndex'\
    \ previously declared here\n    var currentFactorizationIndexInFactorizationArrayMaxIndex\
    \ = 0\n        ^\n/tmp/tmpoy0cz6ky.swift:30:9: error: invalid redeclaration of\
    \ 'currentFactorizationIndexInFactorizationArrayMaxIndex'\n    var currentFactorizationIndexInFactorizationArrayMaxIndex\
    \ = 0\n        ^\n/tmp/tmpoy0cz6ky.swift:25:9: note: 'currentFactorizationIndexInFactorizationArrayMaxIndex'\
    \ previously declared here\n    var currentFactorizationIndexInFactorizationArrayMaxIndex\
    \ = 0\n        ^\n/tmp/tmpoy0cz6ky.swift:31:9: error: invalid redeclaration of\
    \ 'currentFactorizationIndexInFactorizationArrayMaxIndex'\n    va"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var factorization\
    \ = factorizationOfNumber(n)\n    var primeFactorization = factorizationOfPrimes(n)\n\
    \    var factorizationCount = 1\n    var primeFactorizationCount = 1\n    for\
    \ prime in primeFactorization {\n        if factorization[prime] == 1 {\n    \
    \        factors.append(prime)\n            factorizationCount *= prime\n    \
    \        primeFactorizationCount *= prime\n        }\n    }\n    for factor in\
    \ factorization {\n        if factor == 1 {\n            factors.append(factor)\n\
    \            factorizationCount *= factor\n        }\n    }\n    return factors\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp1fk6vai1.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1fk6vai1.swift:14:30: error: cannot find\
    \ 'factorizationOfPrimes' in scope\n    var primeFactorization = factorizationOfPrimes(n)\n\
    \                             ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var factorizationCount = 0\n    var factorizationSum = 0\n    var factorizationSum2\
    \ = 0\n    var factorizationSum3 = 0\n    var factorizationSum4 = 0\n    var factorizationSum5\
    \ = 0\n    var factorizationSum6 = 0\n    var factorizationSum7 = 0\n    var factorizationSum8\
    \ = 0\n    var factorizationSum9 = 0\n    var factorizationSum10 = 0\n    var\
    \ factorizationSum11 = 0\n    var factorizationSum12 = 0\n    var factorizationSum13\
    \ = 0\n    var factorizationSum14 = 0\n    var factorizationSum15 = 0\n    var\
    \ factorizationSum16 = 0\n    var factorizationSum17 = 0\n    var factorizationSum18\
    \ = 0\n    var factorizationSum19 = 0\n    var factorizationSum20 = 0\n    var\
    \ factorizationSum21 = 0\n    var factorizationSum22 = 0\n    var factorizationSum23\
    \ = 0\n    var factorizationSum24 = 0\n    var factorizationSum25 = 0\n    var\
    \ factorizationSum26 = 0\n    var factorizationSum27 = 0\n    var factorizationSum28\
    \ = 0\n    var factorizationSum29 = 0\n    var factorizationSum30 = 0\n    var\
    \ factorizationSum31 = 0\n    var factorizationSum32 = 0\n    var factorizationSum33\
    \ = 0\n    var factorizationSum34 = 0\n    var factorizationSum35 = 0\n    var\
    \ factorizationSum36 = 0\n    var factorizationSum37 = 0\n    var factorizationSum38\
    \ = 0\n    var factorizationSum39 = 0\n    var factorizationSum40 = 0\n    var\
    \ factorizationSum41 = 0\n    var factorizationSum42 = 0\n    var factorizationSum43\
    \ = 0\n    var factorizationSum44 = 0\n    var factorizationSum45 = 0\n    var\
    \ factorizationSum46 = 0\n    var factorizationSum47 = 0\n    var factorizationSum48\
    \ = 0\n    var factorizationSum49 = 0\n    var factorizationSum50 = 0\n    var\
    \ factorizationSum51 = 0\n    var factorizationSum52 = 0\n    var factorizationSum53\
    \ = 0\n    var factorizationSum54 = 0\n    var factorizationSum55 = 0\n    var\
    \ factorizationSum56 = 0\n    var factorizationSum57 = 0\n    var factorizationSum58\
    \ = 0\n    var factorizationSum59 = 0\n    var factorizationSum60 = 0\n    var\
    \ factorizationSum61 = 0\n    var factorizationSum62 = 0\n    var factorizationSum63\
    \ = 0\n    var factorizationSum64 = 0\n    var factorizationSum65 = 0\n    var\
    \ factorizationSum66 = 0\n    var factorizationSum67 = 0\n    var factorizationSum68\
    \ = 0\n    var factorizationSum69 = 0\n    var factorizationSum70 = 0\n    var\
    \ factorizationSum71 = 0\n    var factorization\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpnjuxyg73.swift:85:9: error: type annotation missing in pattern\n\
    \    var factorization\n        ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            factors.append(i)\n\
    \            n /= i\n        } else {\n            i += 1\n        }\n    }\n\
    \    if n > 1 {\n        factors.append(n)\n    }\n    return factors\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpv1s4fi4v.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n    var\
    \ primes: [Int] = []\n    var isPrime: [Bool] = []\n    var isPrimeCount: Int\
    \ = 0\n    var isPrimeCountMax: Int = 0\n    var isPrimeCountMin: Int = 0\n  \
    \  var isPrimeCountMaxMin: Int = 0\n    var isPrimeCountMinMax: Int = 0\n    var\
    \ isPrimeCountMinMaxMin: Int = 0\n    var isPrimeCountMinMaxMinMax: Int = 0\n\
    \    var isPrimeCountMinMaxMinMaxMin: Int = 0\n    var isPrimeCountMinMaxMinMaxMinMax:\
    \ Int = 0\n    var isPrimeCountMinMaxMinMaxMinMaxMin: Int = 0\n    var isPrimeCountMinMaxMinMaxMinMaxMinMax:\
    \ Int = 0\n    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMin: Int = 0\n    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMin:\
    \ Int = 0\n    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMax: Int = 0\n    var\
    \ isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMin: Int = 0\n    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMax:\
    \ Int = 0\n    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMax: Int = 0\n\
    \    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMax: Int = 0\n    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin:\
    \ Int = 0\n    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin: Int =\
    \ 0\n    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax: Int = 0\n\
    \    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax: Int = 0\n   \
    \ var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin: Int = 0\n   \
    \ var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin: Int = 0\n   \
    \ var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax: Int = 0\n\
    \    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin: Int\
    \ = 0\n    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax:\
    \ Int = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpbvji9s5_.swift:27:9: error: invalid redeclaration of 'isPrimeCountMinMaxMinMaxMinMaxMinMaxMin'\n\
    \    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMin: Int = 0\n        ^\n/tmp/tmpbvji9s5_.swift:26:9:\
    \ note: 'isPrimeCountMinMaxMinMaxMinMaxMinMaxMin' previously declared here\n \
    \   var isPrimeCountMinMaxMinMaxMinMaxMinMaxMin: Int = 0\n        ^\n/tmp/tmpbvji9s5_.swift:31:9:\
    \ error: invalid redeclaration of 'isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMax'\n\
    \    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMax: Int = 0\n        ^\n\
    /tmp/tmpbvji9s5_.swift:30:9: note: 'isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMax'\
    \ previously declared here\n    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMax:\
    \ Int = 0\n        ^\n/tmp/tmpbvji9s5_.swift:32:9: error: invalid redeclaration\
    \ of 'isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMax'\n    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMax:\
    \ Int = 0\n        ^\n/tmp/tmpbvji9s5_.swift:30:9: note: 'isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMax'\
    \ previously declared here\n    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMax:\
    \ Int = 0\n        ^\n/tmp/tmpbvji9s5_.swift:34:9: error: invalid redeclaration\
    \ of 'isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin'\n    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin:\
    \ Int = 0\n        ^\n/tmp/tmpbvji9s5_.swift:33:9: note: 'isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin'\
    \ previously declared here\n    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin:\
    \ Int = 0\n        ^\n/tmp/tmpbvji9s5_.swift:36:9: error: invalid redeclaration\
    \ of 'isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax'\n    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax:\
    \ Int = 0\n        ^\n/tmp/tmpbvji9s5_.swift:35:9: note: 'isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax'\
    \ previously declared here\n    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax:\
    \ Int = 0\n        ^\n/tmp/tmpbvji9s5_.swift:38:9: error: invalid redeclaration\
    \ of 'isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin'\n    var isPrimeCountMinMaxMinMaxMinMaxMinMaxMinMaxMi"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var primeFactorization = [Int]()\n    var primeFactorizationCount = [Int]()\n\
    \    var primeFactorizationIndex = 0\n    var factorizationIndex = 0\n    var\
    \ factorizationCount = 0\n    var factorizationIndex2 = 0\n    var factorizationCount2\
    \ = 0\n    var factorizationIndex3 = 0\n    var factorizationCount3 = 0\n    var\
    \ factorizationIndex4 = 0\n    var factorizationCount4 = 0\n    var factorizationIndex5\
    \ = 0\n    var factorizationCount5 = 0\n    var factorizationIndex6 = 0\n    var\
    \ factorizationCount6 = 0\n    var factorizationIndex7 = 0\n    var factorizationCount7\
    \ = 0\n    var factorizationIndex8 = 0\n    var factorizationCount8 = 0\n    var\
    \ factorizationIndex9 = 0\n    var factorizationCount9 = 0\n    var factorizationIndex10\
    \ = 0\n    var factorizationCount10 = 0\n    var factorizationIndex11 = 0\n  \
    \  var factorizationCount11 = 0\n    var factorizationIndex12 = 0\n    var factorizationCount12\
    \ = 0\n    var factorizationIndex13 = 0\n    var factorizationCount13 = 0\n  \
    \  var factorizationIndex14 = 0\n    var factorizationCount14 = 0\n    var factorizationIndex15\
    \ = 0\n    var factorizationCount15 = 0\n    var factorizationIndex16 = 0\n  \
    \  var factorizationCount16 = 0\n    var factorizationIndex17 = 0\n    var factorizationCount17\
    \ = 0\n    var factorizationIndex18 = 0\n    var factorizationCount18 = 0\n  \
    \  var factorizationIndex19 = 0\n    var factorizationCount19 = 0\n    var factorizationIndex20\
    \ = 0\n    var factorizationCount20 = 0\n    var factorizationIndex21 = 0\n  \
    \  var factorizationCount21 = 0\n    var factorizationIndex22 = 0\n    var factorizationCount22\
    \ = 0\n    var factorizationIndex23 = 0\n    var factorizationCount23 = 0\n  \
    \  var factorizationIndex24 = 0\n    var factorizationCount24 = 0\n    var factorizationIndex25\
    \ = 0\n    var factorizationCount25 = 0\n    var factorizationIndex26 = 0\n  \
    \  var factorizationCount26 = 0\n    var factorizationIndex27 = 0\n    var factorizationCount27\
    \ = 0\n    var factorizationIndex28 = 0\n    var factorizationCount28 = 0\n  \
    \  var factorizationIndex29 = 0\n    var factorizationCount29 = 0\n    var factorizationIndex30\
    \ = 0\n    var factorizationCount30 = 0\n    var factorizationIndex31 = 0\n  \
    \  var factorizationCount31 = 0\n    var factorizationIndex32 = 0\n    var factorizationCount32\
    \ = 0\n    var factorizationIndex33 = 0\n    var factorizationCount33 = 0\n  \
    \  var factorizationIndex34 = 0\n    var factorizationCount34 = 0\n    var factorizationIndex\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpe39b9m3w.swift:84:9: error: type annotation missing in pattern\n\
    \    var factorizationIndex\n        ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var factorizationCount = 0\n    var factorizationSum = 0\n    var factorizationSum2\
    \ = 0\n    var factorizationSum3 = 0\n    var factorizationSum4 = 0\n    var factorizationSum5\
    \ = 0\n    var factorizationSum6 = 0\n    var factorizationSum7 = 0\n    var factorizationSum8\
    \ = 0\n    var factorizationSum9 = 0\n    var factorizationSum10 = 0\n    var\
    \ factorizationSum11 = 0\n    var factorizationSum12 = 0\n    var factorizationSum13\
    \ = 0\n    var factorizationSum14 = 0\n    var factorizationSum15 = 0\n    var\
    \ factorizationSum16 = 0\n    var factorizationSum17 = 0\n    var factorizationSum18\
    \ = 0\n    var factorizationSum19 = 0\n    var factorizationSum20 = 0\n    var\
    \ factorizationSum21 = 0\n    var factorizationSum22 = 0\n    var factorizationSum23\
    \ = 0\n    var factorizationSum24 = 0\n    var factorizationSum25 = 0\n    var\
    \ factorizationSum26 = 0\n    var factorizationSum27 = 0\n    var factorizationSum28\
    \ = 0\n    var factorizationSum29 = 0\n    var factorizationSum30 = 0\n    var\
    \ factorizationSum31 = 0\n    var factorizationSum32 = 0\n    var factorizationSum33\
    \ = 0\n    var factorizationSum34 = 0\n    var factorizationSum35 = 0\n    var\
    \ factorizationSum36 = 0\n    var factorizationSum37 = 0\n    var factorizationSum38\
    \ = 0\n    var factorizationSum39 = 0\n    var factorizationSum40 = 0\n    var\
    \ factorizationSum41 = 0\n    var factorizationSum42 = 0\n    var factorizationSum43\
    \ = 0\n    var factorizationSum44 = 0\n    var factorizationSum45 = 0\n    var\
    \ factorizationSum46 = 0\n    var factorizationSum47 = 0\n    var factorizationSum48\
    \ = 0\n    var factorizationSum49 = 0\n    var factorizationSum50 = 0\n    var\
    \ factorizationSum51 = 0\n    var factorizationSum52 = 0\n    var factorizationSum53\
    \ = 0\n    var factorizationSum54 = 0\n    var factorizationSum55 = 0\n    var\
    \ factorizationSum56 = 0\n    var factorizationSum57 = 0\n    var factorizationSum58\
    \ = 0\n    var factorizationSum59 = 0\n    var factorizationSum60 = 0\n    var\
    \ factorizationSum61 = 0\n    var factorizationSum62 = 0\n    var factorizationSum63\
    \ = 0\n    var factorizationSum64 = 0\n    var factorizationSum65 = 0\n    var\
    \ factorizationSum66 = 0\n    var factorizationSum67 = 0\n    var factorizationSum68\
    \ = 0\n    var factorizationSum69 = 0\n    var factorizationSum70 = 0\n    var\
    \ factorizationSum71 = 0\n    var factorization\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpnjuxyg73.swift:85:9: error: type annotation missing in pattern\n\
    \    var factorization\n        ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            factors.append(i)\n\
    \            n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n      \
    \  factors.append(n)\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpi1tj22_o.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n    var\
    \ primeFactors: [Int] = []\n    var primeFactorsCount = 0\n    var isPrime: Bool\
    \ = false\n    var isPrimeCount = 0\n    var isPrimePrime: Bool = false\n    var\
    \ isPrimePrimeCount = 0\n    var isPrimePrimePrime: Bool = false\n    var isPrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrime: Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount =\
    \ 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrime\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpuhjx6tei.swift:25:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrime: Bool = false\n        ^\n/tmp/tmpuhjx6tei.swift:23:9:\
    \ note: 'isPrimePrimePrimePrimePrime' previously declared here\n    var isPrimePrimePrimePrimePrime:\
    \ Bool = false\n        ^\n/tmp/tmpuhjx6tei.swift:26:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimeCount'\n    var isPrimePrimePrimePrimePrimeCount\
    \ = 0\n        ^\n/tmp/tmpuhjx6tei.swift:24:9: note: 'isPrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimeCount = 0\n   \
    \     ^\n/tmp/tmpuhjx6tei.swift:31:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrime: Bool = false\n        ^\n/tmp/tmpuhjx6tei.swift:29:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrime' previously declared here\n   \
    \ var isPrimePrimePrimePrimePrimePrimePrime: Bool = false\n        ^\n/tmp/tmpuhjx6tei.swift:32:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpuhjx6tei.swift:30:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimeCount' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpuhjx6tei.swift:39:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime: Bool = false\n\
    \        ^\n/tmp/tmpuhjx6tei.swift:37:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime:\
    \ Bool = false\n        ^\n/tmp/tmpuhjx6tei.swift:40:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount'\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n        ^\n/tmp/tmpuhjx6tei.swift:38:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePr"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var i = 2\n    var factor = 1\n    while i <= n {\n        if n % i == 0 {\n\
    \            factor *= i\n            factorization[factorizationCount] = i\n\
    \            factorizationCount += 1\n        }\n        i += 1\n    }\n    return\
    \ factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpp9aok43t.swift:18:27: error: cannot find 'factorizationCount' in\
    \ scope\n            factorization[factorizationCount] = i\n                 \
    \         ^~~~~~~~~~~~~~~~~~\n/tmp/tmpp9aok43t.swift:19:13: error: cannot find\
    \ 'factorizationCount' in scope\n            factorizationCount += 1\n       \
    \     ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var factorizationCount = [Int]()\n    var primeFactorization = [Int]()\n   \
    \ var primeFactorizationCount = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeCount\
    \ = [Int]()\n    var isPrimePrime = [Bool]()\n    var isPrimePrimeCount = [Int]()\n\
    \    var isPrimePrimePrime = [Bool]()\n    var isPrimePrimePrimeCount = [Int]()\n\
    \    var isPrimePrimePrimePrime = [Bool]()\n    var isPrimePrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimePrimePrimePrimePrime = [Bool]()\n    var isPrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimePrimePrimePrimePrimePrime = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimePrimePrimePrimePrimePrimePrime = [Bool]()\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimeCount = [Int]()\n    var isPrimePrimePrimePrimePrimePrimePrime\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimeCount = [Int]()\n \
    \   var isPrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n \
    \   var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = [Int]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrime\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = [Int]()\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n\
    \    var isPri\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpxq6wljpo.swift:30:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrime = [Bool]()\n        ^\n/tmp/tmpxq6wljpo.swift:28:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrime' previously declared here\n   \
    \ var isPrimePrimePrimePrimePrimePrimePrime = [Bool]()\n        ^\n/tmp/tmpxq6wljpo.swift:31:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = [Int]()\n        ^\n/tmp/tmpxq6wljpo.swift:29:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimeCount' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = [Int]()\n        ^\n/tmp/tmpxq6wljpo.swift:33:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = [Int]()\n        ^\n/tmp/tmpxq6wljpo.swift:29:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimeCount' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = [Int]()\n        ^\n/tmp/tmpxq6wljpo.swift:34:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n        ^\n/tmp/tmpxq6wljpo.swift:32:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimePrime' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n        ^\n/tmp/tmpxq6wljpo.swift:36:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n        ^\n/tmp/tmpxq6wljpo.swift:32:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimePrime' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n        ^\n/tmp/tmpxq6wljpo.swift:37:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = [Int]()\n        ^\n\
    /tmp/tmpxq6wljpo.swift:35:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    var j = 1\n    var factor = 1\n    while i <= n {\n        if n % i\
    \ == 0 {\n            factors.append(i)\n            n /= i\n        } else {\n\
    \            j += 1\n            factor = 1\n            while j <= i {\n    \
    \            if n % i == 0 {\n                    factor *= i\n              \
    \      n /= i\n                    break\n                }\n                j\
    \ += 1\n            }\n            factors.append(factor)\n        }\n       \
    \ i += 1\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmppbem62av.swift:19:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n/tmp/tmppbem62av.swift:26:23:\
    \ error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n\
    \                    n /= i\n                    ~ ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: -4
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n    var\
    \ i = 2\n    var factor: Int\n    while i < n {\n        factor = 1\n        while\
    \ i < n && n % i == 0 {\n            factor *= i\n            i += 1\n       \
    \ }\n        factors.append(factor)\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmpeo91_933/tmpeo91_933.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaefba45c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaefb73cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaefb73c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaefb73b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpeo91_933                        0x000055ff67949462 <unavailable> + 5218

    5    libc.so.6                          0x00002aaefbc31460 __libc_start_main +
    245

    6    tmpeo91_933                        0x000055ff679490b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var primes\
    \ = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeCount = [Int]()\n    var\
    \ isPrimeCountMax = Int(arc4random_uniform(UInt32(UInt32.max)))\n    var isPrimeCountMin\
    \ = Int(arc4random_uniform(UInt32(UInt32.min)))\n    var isPrimeCountMin2 = Int(arc4random_uniform(UInt32(UInt32.min)))\n\
    \    var isPrimeCountMin3 = Int(arc4random_uniform(UInt32(UInt32.min)))\n    var\
    \ isPrimeCountMin4 = Int(arc4random_uniform(UInt32(UInt32.min)))\n    var isPrimeCountMin5\
    \ = Int(arc4random_uniform(UInt32(UInt32.min)))\n    var isPrimeCountMin6 = Int(arc4random_uniform(UInt32(UInt32.min)))\n\
    \    var isPrimeCountMin7 = Int(arc4random_uniform(UInt32(UInt32.min)))\n    var\
    \ isPrimeCountMin8 = Int(arc4random_uniform(UInt32(UInt32.min)))\n    var isPrimeCountMin9\
    \ = Int(arc4random_uniform(UInt32(UInt32.min)))\n    var isPrimeCountMin10 = Int(arc4random_uniform(UInt32(UInt32.min)))\n\
    \    var isPrimeCountMin11 = Int(arc4random_uniform(UInt32(UInt32.min)))\n   \
    \ var isPrimeCountMin12 = Int(arc4random_uniform(UInt32(UInt32.min)))\n    var\
    \ isPrimeCountMin13 = Int(arc4random_uniform(UInt32(UInt32.min)))\n    var isPrimeCountMin14\
    \ = Int(arc4random_uniform(UInt32(UInt32.min)))\n    var isPrimeCountMin15 = Int(arc4random_uniform(UInt32(UInt32.min)))\n\
    \    var isPrimeCountMin16 = Int(arc4random_uniform(UInt32(UInt32.min)))\n   \
    \ var isPrimeCountMin17 = Int(arc4random_uniform(UInt32(UInt32.min)))\n    var\
    \ isPrimeCountMin18 = Int(arc4random_uniform(UInt32(UInt32.min)))\n    var isPrimeCountMin19\
    \ = Int(arc4random_uniform(UInt32(UInt32.min)))\n    var isPrimeCountMin20 = Int(arc4random_uniform(UInt32(UInt32.min)))\n\
    \    var isPrimeCountMin21 = Int(arc4random_uniform(UInt32(UInt32.min)))\n   \
    \ var isPrimeCountMin22 = Int(arc4random_uniform(UInt32(UInt32.min)))\n    var\
    \ isPrimeCountMin23 = Int(\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpd9k5t243.swift:40:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpd9k5t243.swift:16:31: error: cannot find 'arc4random_uniform' in\
    \ scope\n    var isPrimeCountMax = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \                              ^~~~~~~~~~~~~~~~~~\n/tmp/tmpd9k5t243.swift:17:31:\
    \ error: cannot find 'arc4random_uniform' in scope\n    var isPrimeCountMin =\
    \ Int(arc4random_uniform(UInt32(UInt32.min)))\n                              ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpd9k5t243.swift:18:32: error: cannot find 'arc4random_uniform' in scope\n\
    \    var isPrimeCountMin2 = Int(arc4random_uniform(UInt32(UInt32.min)))\n    \
    \                           ^~~~~~~~~~~~~~~~~~\n/tmp/tmpd9k5t243.swift:19:32:\
    \ error: cannot find 'arc4random_uniform' in scope\n    var isPrimeCountMin3 =\
    \ Int(arc4random_uniform(UInt32(UInt32.min)))\n                              \
    \ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpd9k5t243.swift:20:32: error: cannot find 'arc4random_uniform'\
    \ in scope\n    var isPrimeCountMin4 = Int(arc4random_uniform(UInt32(UInt32.min)))\n\
    \                               ^~~~~~~~~~~~~~~~~~\n/tmp/tmpd9k5t243.swift:21:32:\
    \ error: cannot find 'arc4random_uniform' in scope\n    var isPrimeCountMin5 =\
    \ Int(arc4random_uniform(UInt32(UInt32.min)))\n                              \
    \ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpd9k5t243.swift:22:32: error: cannot find 'arc4random_uniform'\
    \ in scope\n    var isPrimeCountMin6 = Int(arc4random_uniform(UInt32(UInt32.min)))\n\
    \                               ^~~~~~~~~~~~~~~~~~\n/tmp/tmpd9k5t243.swift:23:32:\
    \ error: cannot find 'arc4random_uniform' in scope\n    var isPrimeCountMin7 =\
    \ Int(arc4random_uniform(UInt32(UInt32.min)))\n                              \
    \ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpd9k5t243.swift:24:32: error: cannot find 'arc4random_uniform'\
    \ in scope\n    var isPrimeCountMin8 = Int(arc4random_uniform(UInt32(UInt32.min)))\n\
    \                               ^~~~~~~~~~~~~~~~~~\n/tmp/tmpd9k5t243.swift:25:32:\
    \ error: cannot find 'arc4random_uniform' in scope\n    var isPrimeCountMin9 =\
    \ Int(arc4random_uniform(UInt32(UInt32.min)))\n                   "
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var primes = [Int]()\n    var primeFactorization = [Int]()\n    var isPrime\
    \ = [Bool]()\n    var isPrimeFactorization = [Bool]()\n    var isPrimeFactorizationIndex\
    \ = 0\n    var isPrimeIndex = 0\n    var isPrimeFactorizationIndex2 = 0\n    var\
    \ isPrimeIndex2 = 0\n    var isPrimeFactorizationIndex3 = 0\n    var isPrimeIndex3\
    \ = 0\n    var isPrimeFactorizationIndex4 = 0\n    var isPrimeIndex4 = 0\n   \
    \ var isPrimeFactorizationIndex5 = 0\n    var isPrimeIndex5 = 0\n    var isPrimeFactorizationIndex6\
    \ = 0\n    var isPrimeIndex6 = 0\n    var isPrimeFactorizationIndex7 = 0\n   \
    \ var isPrimeIndex7 = 0\n    var isPrimeFactorizationIndex8 = 0\n    var isPrimeIndex8\
    \ = 0\n    var isPrimeFactorizationIndex9 = 0\n    var isPrimeIndex9 = 0\n   \
    \ var isPrimeFactorizationIndex10 = 0\n    var isPrimeIndex10 = 0\n    var isPrimeFactorizationIndex11\
    \ = 0\n    var isPrimeIndex11 = 0\n    var isPrimeFactorizationIndex12 = 0\n \
    \   var isPrimeIndex12 = 0\n    var isPrimeFactorizationIndex13 = 0\n    var isPrimeIndex13\
    \ = 0\n    var isPrimeFactorizationIndex14 = 0\n    var isPrimeIndex14 = 0\n \
    \   var isPrimeFactorizationIndex15 = 0\n    var isPrimeIndex15 = 0\n    var isPrimeFactorizationIndex16\
    \ = 0\n    var isPrimeIndex16 = 0\n    var isPrimeFactorizationIndex17 = 0\n \
    \   var isPrimeIndex17 = 0\n    var isPrimeFactorizationIndex18 = 0\n    var isPrimeIndex18\
    \ = 0\n    var isPrimeFactorizationIndex19 = 0\n    var isPrimeIndex19 = 0\n \
    \   var isPrimeFactorizationIndex20 = 0\n    var isPrimeIndex20 = 0\n    var isPrimeFactorizationIndex21\
    \ = 0\n    var isPrimeIndex21 = 0\n    var isPrimeFactorizationIndex22 = 0\n \
    \   var isPrimeIndex22 = 0\n    var isPrimeFactorizationIndex23 = 0\n    var isPrimeIndex23\
    \ = 0\n    var isPrimeFactorizationIndex24 = 0\n    var isPrimeIndex24 = 0\n \
    \   var isPrimeFactorizationIndex25 = 0\n    var isPrimeIndex25 = 0\n    var isPrimeFactorizationIndex26\
    \ = 0\n    var isPrimeIndex26 = 0\n    var is\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpip7zq9lr.swift:69:9: error: expected pattern\n    var is\n    \
    \    ^\n/tmp/tmpip7zq9lr.swift:12:9: warning: initialization of variable 'factorization'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorization = [Int]()\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmpip7zq9lr.swift:13:9:\
    \ warning: initialization of variable 'primes' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var primes = [Int]()\n    ~~~~^~~~~~\n\
    \    _\n/tmp/tmpip7zq9lr.swift:14:9: warning: initialization of variable 'primeFactorization'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var primeFactorization = [Int]()\n    ~~~~^~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpip7zq9lr.swift:15:9:\
    \ warning: initialization of variable 'isPrime' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var isPrime = [Bool]()\n    ~~~~^~~~~~~\n\
    \    _\n/tmp/tmpip7zq9lr.swift:16:9: warning: initialization of variable 'isPrimeFactorization'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeFactorization = [Bool]()\n    ~~~~^~~~~~~~~~~~~~~~~~~~\n    _\n\
    /tmp/tmpip7zq9lr.swift:17:9: warning: initialization of variable 'isPrimeFactorizationIndex'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeFactorizationIndex = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n   \
    \ _\n/tmp/tmpip7zq9lr.swift:18:9: warning: initialization of variable 'isPrimeIndex'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeIndex = 0\n    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmpip7zq9lr.swift:19:9:\
    \ warning: initialization of variable 'isPrimeFactorizationIndex2' was never used;\
    \ consider replacing with assignment to '_' or removing it\n    var isPrimeFactorizationIndex2\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpip7zq9lr.swift:20:9:\
    \ warning: initialization of variable 'isPrimeIndex2' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var isPrimeIndex2 = 0\n\
    \    ~~~~^~~~~~~~~~~~~\n    _\n/"
  stdout: ''
  timestamp: 1659824951
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    var p = n\n    while p > 1 {\n        while p % i == 0 {\n        \
    \    factors.append(i)\n            p /= i\n        }\n        i += 1\n    }\n\
    \    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var primeFactorization = [Int]()\n    var factorizationCount = 0\n    var primeFactorizationCount\
    \ = 0\n    var isPrime = true\n    var isPrimeCount = 0\n    var isPrimePrime\
    \ = true\n    var isPrimePrimeCount = 0\n    var isPrimePrimePrime = true\n  \
    \  var isPrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrime = true\n   \
    \ var isPrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrime = true\n\
    \    var isPrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount =\
    \ 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrime\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmphnyt3nou.swift:41:9: error: type annotation missing in pattern\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime\n        ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var factorizationCount = 1\n    var currentFactor = 1\n    var currentFactorCount\
    \ = 0\n    var currentFactorIndex = 0\n    var currentFactorValue = 1\n    var\
    \ currentFactorValueCount = 0\n    var currentFactorValueIndex = 0\n    var currentFactorValue\
    \ = 1\n    var currentFactorValueCount = 0\n    var currentFactorValueIndex =\
    \ 0\n    var currentFactorValue = 1\n    var currentFactorValueCount = 0\n   \
    \ var currentFactorValueIndex = 0\n    var currentFactorValue = 1\n    var currentFactorValueCount\
    \ = 0\n    var currentFactorValueIndex = 0\n    var currentFactorValue = 1\n \
    \   var currentFactorValueCount = 0\n    var currentFactorValueIndex = 0\n   \
    \ var currentFactorValue = 1\n    var currentFactorValueCount = 0\n    var currentFactorValueIndex\
    \ = 0\n    var currentFactorValue = 1\n    var currentFactorValueCount = 0\n \
    \   var currentFactorValueIndex = 0\n    var currentFactorValue = 1\n    var currentFactorValueCount\
    \ = 0\n    var currentFactorValueIndex = 0\n    var currentFactorValue = 1\n \
    \   var currentFactorValueCount = 0\n    var currentFactorValueIndex = 0\n   \
    \ var currentFactorValue = 1\n    var currentFactorValueCount = 0\n    var currentFactorValueIndex\
    \ = 0\n    var currentFactorValue = 1\n    var currentFactorValueCount = 0\n \
    \   var currentFactorValueIndex = 0\n    var currentFactorValue = 1\n    var currentFactorValueCount\
    \ = 0\n    var currentFactorValueIndex = 0\n    var currentFactorValue = 1\n \
    \   var currentFactorValueCount = 0\n    var currentFactorValueIndex = 0\n   \
    \ var currentFactorValue = 1\n    var currentFactorValueCount = 0\n    var currentFactorValueIndex\
    \ = 0\n    var currentFactorValue = 1\n    var currentFactorValueCount = 0\n \
    \   var currentFactorValueIndex = 0\n    var currentFactorValue = 1\n    var currentFactorValueCount\
    \ = 0\n    var currentFactorValueIndex = 0\n    var currentFactorValue = 1\n \
    \   var currentFactorValueCount = 0\n    var currentFactorValueIndex = 0\n   \
    \ var currentFactorValue = 1\n    var currentFactorValueCount = 0\n    var currentFactorValueIndex\
    \ = 0\n    var currentFactorValue = 1\n    var currentFactorValueCount = 0\n \
    \   var currentFactorValueIndex = 0\n    var currentFactorValue = 1\n    var currentFactorValueCount\
    \ = 0\n    var currentFactorValueIndex = 0\n    var currentFactorValue = 1\n \
    \   var currentFactorValueCount = 0\n    var currentFactorValueIndex = 0\n   \
    \ var currentFactorValue = 1\n    var currentFactorValueCount = 0\n    var currentFactorValueIndex\
    \ = 0\n    var currentFactorValue = 1\n    var currentFactorValueCount = 0\n \
    \   var currentFactorValueIndex = 0\n    var currentFactorValue = 1\n    var currentFactorValueCount\
    \ = 0\n    var currentFactorValueIndex = 0\n    var \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpyk9x1kpd.swift:89:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpyk9x1kpd.swift:20:9: error: invalid redeclaration of 'currentFactorValue'\n\
    \    var currentFactorValue = 1\n        ^\n/tmp/tmpyk9x1kpd.swift:17:9: note:\
    \ 'currentFactorValue' previously declared here\n    var currentFactorValue =\
    \ 1\n        ^\n/tmp/tmpyk9x1kpd.swift:21:9: error: invalid redeclaration of 'currentFactorValueCount'\n\
    \    var currentFactorValueCount = 0\n        ^\n/tmp/tmpyk9x1kpd.swift:18:9:\
    \ note: 'currentFactorValueCount' previously declared here\n    var currentFactorValueCount\
    \ = 0\n        ^\n/tmp/tmpyk9x1kpd.swift:22:9: error: invalid redeclaration of\
    \ 'currentFactorValueIndex'\n    var currentFactorValueIndex = 0\n        ^\n\
    /tmp/tmpyk9x1kpd.swift:19:9: note: 'currentFactorValueIndex' previously declared\
    \ here\n    var currentFactorValueIndex = 0\n        ^\n/tmp/tmpyk9x1kpd.swift:23:9:\
    \ error: invalid redeclaration of 'currentFactorValue'\n    var currentFactorValue\
    \ = 1\n        ^\n/tmp/tmpyk9x1kpd.swift:17:9: note: 'currentFactorValue' previously\
    \ declared here\n    var currentFactorValue = 1\n        ^\n/tmp/tmpyk9x1kpd.swift:24:9:\
    \ error: invalid redeclaration of 'currentFactorValueCount'\n    var currentFactorValueCount\
    \ = 0\n        ^\n/tmp/tmpyk9x1kpd.swift:18:9: note: 'currentFactorValueCount'\
    \ previously declared here\n    var currentFactorValueCount = 0\n        ^\n/tmp/tmpyk9x1kpd.swift:25:9:\
    \ error: invalid redeclaration of 'currentFactorValueIndex'\n    var currentFactorValueIndex\
    \ = 0\n        ^\n/tmp/tmpyk9x1kpd.swift:19:9: note: 'currentFactorValueIndex'\
    \ previously declared here\n    var currentFactorValueIndex = 0\n        ^\n/tmp/tmpyk9x1kpd.swift:26:9:\
    \ error: invalid redeclaration of 'currentFactorValue'\n    var currentFactorValue\
    \ = 1\n        ^\n/tmp/tmpyk9x1kpd.swift:17:9: note: 'currentFactorValue' previously\
    \ declared here\n    var currentFactorValue = 1\n        ^\n/tmp/tmpyk9x1kpd.swift:27:9:\
    \ error: invalid redeclaration of 'currentFactorValueCount'\n    var currentFactorValueCount\
    \ = 0\n        ^\n/tmp/tmpyk9x1kpd.swift:18:9: note: 'currentFactor"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    var j = 1\n    var k = 0\n    var m = 1\n    var n = n\n    var p =\
    \ 2\n    var q = 1\n    var r = 1\n    var s = 2\n    var t = 1\n    var u = 1\n\
    \    var v = 1\n    var w = 1\n    var x = 1\n    var y = 1\n    var z = 1\n \
    \   var a = 1\n    var b = 1\n    var c = 1\n    var d = 1\n    var e = 1\n  \
    \  var f = 1\n    var g = 1\n    var h = 1\n    var i = 2\n    var j = 1\n   \
    \ var k = 0\n    var m = 1\n    var n = n\n    var p = 2\n    var q = 1\n    var\
    \ r = 1\n    var s = 2\n    var t = 1\n    var u = 1\n    var v = 1\n    var w\
    \ = 1\n    var x = 1\n    var y = 1\n    var z = 1\n    var a = 1\n    var b =\
    \ 1\n    var c = 1\n    var d = 1\n    var e = 1\n    var f = 1\n    var g = 1\n\
    \    var h = 1\n    var i = 2\n    var j = 1\n    var k = 0\n    var m = 1\n \
    \   var n = n\n    var p = 2\n    var q = 1\n    var r = 1\n    var s = 2\n  \
    \  var t = 1\n    var u = 1\n    var v = 1\n    var w = 1\n    var x = 1\n   \
    \ var y = 1\n    var z = 1\n    var a = 1\n    var b = 1\n    var c = 1\n    var\
    \ d = 1\n    var e = 1\n    var f = 1\n    var g = 1\n    var h = 1\n    var i\
    \ = 2\n    var j = 1\n    var k = 0\n    var m = 1\n    var n = n\n    var p =\
    \ 2\n    var q = 1\n    var r = 1\n    var s = 2\n    var t = 1\n    var u = 1\n\
    \    var v = 1\n    var w = 1\n    var x = 1\n    var y = 1\n    var z = 1\n \
    \   var a = 1\n    var b = 1\n    var c = 1\n    var d = 1\n    var e = 1\n  \
    \  var f = 1\n    var g = 1\n    var h = 1\n    var i = 2\n    var j = 1\n   \
    \ var k = 0\n    var m = 1\n    var n = n\n    var p = 2\n    var q = 1\n    var\
    \ r = 1\n    var s = 2\n    var t = 1\n    var u = 1\n    var v = 1\n    var w\
    \ = 1\n    var x = 1\n    var y = 1\n    var z = 1\n    var a = 1\n    var b =\
    \ 1\n    var c = 1\n    var d = 1\n    var e = 1\n    var f = 1\n    var g = 1\n\
    \    var h = 1\n    var i = 2\n    var j = 1\n    var k = 0\n    var m = 1\n \
    \   var n = n\n    var p = 2\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmprt22ge4l.swift:139:8: error: expected pattern\n    var \n     \
    \  ^\n/tmp/tmprt22ge4l.swift:37:9: error: invalid redeclaration of 'i'\n    var\
    \ i = 2\n        ^\n/tmp/tmprt22ge4l.swift:13:9: note: 'i' previously declared\
    \ here\n    var i = 2\n        ^\n/tmp/tmprt22ge4l.swift:38:9: error: invalid\
    \ redeclaration of 'j'\n    var j = 1\n        ^\n/tmp/tmprt22ge4l.swift:14:9:\
    \ note: 'j' previously declared here\n    var j = 1\n        ^\n/tmp/tmprt22ge4l.swift:39:9:\
    \ error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmprt22ge4l.swift:15:9:\
    \ note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmprt22ge4l.swift:40:9:\
    \ error: invalid redeclaration of 'm'\n    var m = 1\n        ^\n/tmp/tmprt22ge4l.swift:16:9:\
    \ note: 'm' previously declared here\n    var m = 1\n        ^\n/tmp/tmprt22ge4l.swift:41:9:\
    \ error: invalid redeclaration of 'n'\n    var n = n\n        ^\n/tmp/tmprt22ge4l.swift:17:9:\
    \ note: 'n' previously declared here\n    var n = n\n        ^\n/tmp/tmprt22ge4l.swift:42:9:\
    \ error: invalid redeclaration of 'p'\n    var p = 2\n        ^\n/tmp/tmprt22ge4l.swift:18:9:\
    \ note: 'p' previously declared here\n    var p = 2\n        ^\n/tmp/tmprt22ge4l.swift:43:9:\
    \ error: invalid redeclaration of 'q'\n    var q = 1\n        ^\n/tmp/tmprt22ge4l.swift:19:9:\
    \ note: 'q' previously declared here\n    var q = 1\n        ^\n/tmp/tmprt22ge4l.swift:44:9:\
    \ error: invalid redeclaration of 'r'\n    var r = 1\n        ^\n/tmp/tmprt22ge4l.swift:20:9:\
    \ note: 'r' previously declared here\n    var r = 1\n        ^\n/tmp/tmprt22ge4l.swift:45:9:\
    \ error: invalid redeclaration of 's'\n    var s = 2\n        ^\n/tmp/tmprt22ge4l.swift:21:9:\
    \ note: 's' previously declared here\n    var s = 2\n        ^\n/tmp/tmprt22ge4l.swift:46:9:\
    \ error: invalid redeclaration of 't'\n    var t = 1\n        ^\n/tmp/tmprt22ge4l.swift:22:9:\
    \ note: 't' previously declared here\n    var t = 1\n        ^\n/tmp/tmprt22ge4l.swift:47:9:\
    \ error: invalid redeclaration of 'u'\n    var u = 1\n        ^\n/tmp/tmprt22ge4l.swift:23:9:\
    \ note: 'u' previously declared here\n    var u = 1\n        ^\n/tmp/tmprt22ge4l.swift:48:9: "
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n    var\
    \ primeFactorization: [Int] = []\n    var isPrime: [Bool] = []\n    var isPrimeCount:\
    \ Int = 0\n    var isPrimePrimeCount: Int = 0\n    var isPrimePrime: Bool = false\n\
    \    var isPrimePrime2: Bool = false\n    var isPrimePrime3: Bool = false\n  \
    \  var isPrimePrime4: Bool = false\n    var isPrimePrime5: Bool = false\n    var\
    \ isPrimePrime6: Bool = false\n    var isPrimePrime7: Bool = false\n    var isPrimePrime8:\
    \ Bool = false\n    var isPrimePrime9: Bool = false\n    var isPrimePrime10: Bool\
    \ = false\n    var isPrimePrime11: Bool = false\n    var isPrimePrime12: Bool\
    \ = false\n    var isPrimePrime13: Bool = false\n    var isPrimePrime14: Bool\
    \ = false\n    var isPrimePrime15: Bool = false\n    var isPrimePrime16: Bool\
    \ = false\n    var isPrimePrime17: Bool = false\n    var isPrimePrime18: Bool\
    \ = false\n    var isPrimePrime19: Bool = false\n    var isPrimePrime20: Bool\
    \ = false\n    var isPrimePrime21: Bool = false\n    var isPrimePrime22: Bool\
    \ = false\n    var isPrimePrime23: Bool = false\n    var isPrimePrime24: Bool\
    \ = false\n    var isPrimePrime25: Bool = false\n    var isPrimePrime26: Bool\
    \ = false\n    var isPrimePrime27: Bool = false\n    var isPrimePrime28: Bool\
    \ = false\n    var isPrimePrime29: Bool = false\n    var isPrimePrime30: Bool\
    \ = false\n    var isPrimePrime31: Bool = false\n    var isPrimePrime32: Bool\
    \ = false\n    var isPrimePrime33: Bool = false\n    var isPrimePrime34: Bool\
    \ = false\n    var isPrimePrime35: Bool = false\n    var isPrimePrime36: Bool\
    \ = false\n    var isPrimePrime37: Bool = false\n    var isPrimePrime38: Bool\
    \ = false\n    var isPrimePrime39: Bool = false\n    var isPrimePrime40: Bool\
    \ = false\n    var isPrimePrime41: Bool = false\n    var isPrimePrime42: Bool\
    \ = false\n    var isPrimePrime43: Bool = false\n    var is\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpojc_c1in.swift:60:9: error: expected pattern\n    var is\n    \
    \    ^\n/tmp/tmpojc_c1in.swift:12:9: warning: variable 'factors' was never used;\
    \ consider replacing with '_' or removing it\n    var factors: [Int] = []\n  \
    \      ^~~~~~~\n        _\n/tmp/tmpojc_c1in.swift:13:9: warning: variable 'primeFactorization'\
    \ was never used; consider replacing with '_' or removing it\n    var primeFactorization:\
    \ [Int] = []\n        ^~~~~~~~~~~~~~~~~~\n        _\n/tmp/tmpojc_c1in.swift:14:9:\
    \ warning: variable 'isPrime' was never used; consider replacing with '_' or removing\
    \ it\n    var isPrime: [Bool] = []\n        ^~~~~~~\n        _\n/tmp/tmpojc_c1in.swift:15:9:\
    \ warning: variable 'isPrimeCount' was never used; consider replacing with '_'\
    \ or removing it\n    var isPrimeCount: Int = 0\n        ^~~~~~~~~~~~\n      \
    \  _\n/tmp/tmpojc_c1in.swift:16:9: warning: variable 'isPrimePrimeCount' was never\
    \ used; consider replacing with '_' or removing it\n    var isPrimePrimeCount:\
    \ Int = 0\n        ^~~~~~~~~~~~~~~~~\n        _\n/tmp/tmpojc_c1in.swift:17:9:\
    \ warning: variable 'isPrimePrime' was never used; consider replacing with '_'\
    \ or removing it\n    var isPrimePrime: Bool = false\n        ^~~~~~~~~~~~\n \
    \       _\n/tmp/tmpojc_c1in.swift:18:9: warning: variable 'isPrimePrime2' was\
    \ never used; consider replacing with '_' or removing it\n    var isPrimePrime2:\
    \ Bool = false\n        ^~~~~~~~~~~~~\n        _\n/tmp/tmpojc_c1in.swift:19:9:\
    \ warning: variable 'isPrimePrime3' was never used; consider replacing with '_'\
    \ or removing it\n    var isPrimePrime3: Bool = false\n        ^~~~~~~~~~~~~\n\
    \        _\n/tmp/tmpojc_c1in.swift:20:9: warning: variable 'isPrimePrime4' was\
    \ never used; consider replacing with '_' or removing it\n    var isPrimePrime4:\
    \ Bool = false\n        ^~~~~~~~~~~~~\n        _\n/tmp/tmpojc_c1in.swift:21:9:\
    \ warning: variable 'isPrimePrime5' was never used; consider replacing with '_'\
    \ or removing it\n    var isPrimePrime5: Bool = false\n        ^~~~~~~~~~~~~\n\
    \        _\n/tmp/tmpojc_c1in.swift:22:9: warning: variable 'isPrimePrime6' was\
    \ never used; consider replacing with '"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var factorization\
    \ = [Int]()\n    var i = 2\n    var j = 1\n    var k = 0\n    var temp = 0\n \
    \   var factorizationCount = 0\n    var isPrime = true\n    var isPrime2 = true\n\
    \    var isPrime3 = true\n    var isPrime4 = true\n    var isPrime5 = true\n \
    \   var isPrime6 = true\n    var isPrime7 = true\n    var isPrime8 = true\n  \
    \  var isPrime9 = true\n    var isPrime10 = true\n    var isPrime11 = true\n \
    \   var isPrime12 = true\n    var isPrime13 = true\n    var isPrime14 = true\n\
    \    var isPrime15 = true\n    var isPrime16 = true\n    var isPrime17 = true\n\
    \    var isPrime18 = true\n    var isPrime19 = true\n    var isPrime20 = true\n\
    \    var isPrime21 = true\n    var isPrime22 = true\n    var isPrime23 = true\n\
    \    var isPrime24 = true\n    var isPrime25 = true\n    var isPrime26 = true\n\
    \    var isPrime27 = true\n    var isPrime28 = true\n    var isPrime29 = true\n\
    \    var isPrime30 = true\n    var isPrime31 = true\n    var isPrime32 = true\n\
    \    var isPrime33 = true\n    var isPrime34 = true\n    var isPrime35 = true\n\
    \    var isPrime36 = true\n    var isPrime37 = true\n    var isPrime38 = true\n\
    \    var isPrime39 = true\n    var isPrime40 = true\n    var isPrime41 = true\n\
    \    var isPrime42 = true\n    var isPrime43 = true\n    var isPrime44 = true\n\
    \    var isPrime45 = true\n    var isPrime46 = true\n    var isPrime47 = true\n\
    \    var isPrime48 = true\n    var isPrime49 = true\n    var isPrime50 = true\n\
    \    var isPrime51 = true\n    var isPrime52 = true\n    var isPrime53 = true\n\
    \    var isPrime54 = true\n    var isPrime55 = true\n    var isPrime56 = true\n\
    \    var isPrime57 = true\n    var isPrime58 = true\n    var isPrime59 = true\n\
    \    var isPrime60 = true\n    var isPrime61 = true\n    var isPrime62 = true\n\
    \    var isPrime63 = true\n    var isPrime64 = true\n    var isPrime65 = true\n\
    \    var isPrime66 = true\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpqw6yw8if.swift:85:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpqw6yw8if.swift:12:9: warning: initialization of variable 'factors'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factors = [Int]()\n    ~~~~^~~~~~~\n    _\n/tmp/tmpqw6yw8if.swift:13:9:\
    \ warning: initialization of variable 'factorization' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorization = [Int]()\n\
    \    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmpqw6yw8if.swift:14:9: warning: initialization\
    \ of variable 'i' was never used; consider replacing with assignment to '_' or\
    \ removing it\n    var i = 2\n    ~~~~^\n    _\n/tmp/tmpqw6yw8if.swift:15:9: warning:\
    \ initialization of variable 'j' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var j = 1\n    ~~~~^\n    _\n/tmp/tmpqw6yw8if.swift:16:9:\
    \ warning: initialization of variable 'k' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var k = 0\n    ~~~~^\n    _\n/tmp/tmpqw6yw8if.swift:17:9:\
    \ warning: initialization of variable 'temp' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var temp = 0\n    ~~~~^~~~\n    _\n\
    /tmp/tmpqw6yw8if.swift:18:9: warning: initialization of variable 'factorizationCount'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorizationCount = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpqw6yw8if.swift:19:9:\
    \ warning: initialization of variable 'isPrime' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var isPrime = true\n    ~~~~^~~~~~~\n\
    \    _\n/tmp/tmpqw6yw8if.swift:20:9: warning: initialization of variable 'isPrime2'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrime2 = true\n    ~~~~^~~~~~~~\n    _\n/tmp/tmpqw6yw8if.swift:21:9:\
    \ warning: initialization of variable 'isPrime3' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var isPrime3 = true\n    ~~~~^~~~~~~~\n\
    \    _\n/tmp/tmpqw6yw8if.swift:22:9: warning: initialization of variab"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    if n < 2 {\n        return []\n \
    \   }\n    var factors = [Int]()\n    var factorization = [Int]()\n    var i =\
    \ 2\n    var j = 1\n    var k = n\n    while i <= k {\n        while k % i ==\
    \ 0 {\n            factors.append(i)\n            factors.append(j)\n        \
    \    factors.append(k)\n            factors.append(k)\n            factors.append(k)\n\
    \            factors.append(k)\n            factors.append(k)\n            factors.append(k)\n\
    \            factors.append(k)\n            factors.append(k)\n            factors.append(k)\n\
    \            factors.append(k)\n            factors.append(k)\n            factors.append(k)\n\
    \            factors.append(k)\n            factors.append(k)\n            factors.append(k)\n\
    \            factors.append(k)\n            factors.append(k)\n            factors.append(k)\n\
    \            factors.append(k)\n            factors.append(k)\n            factors.append(k)\n\
    \            factors.append(k)\n            factors.append(k)\n            factors.append(k)\n\
    \            factors.append(k)\n            factors.append(k)\n            factors.append(k)\n\
    \            factors.append(k)\n            factors.append(k)\n            factors.append(k)\n\
    \            factors.append(k)\n            factors.append(k)\n            factors.append(k)\n\
    \            factors.append(k)\n            factors.append(k)\n            factors.append(k)\n\
    \            factors.append(k)\n            factors.append(k)\n            factors.append(k)\n\
    \            factors.append(k)\n            factors.append(k)\n            factors.append(k)\n\
    \            factors.append(k)\n            factors.append(k)\n            factors.append(k)\n\
    \            factors.append(k)\n            factors.append(k)\n            factors.append(k)\n\
    \            factors.append(k)\n            factors.append(k)\n            factors.append(k)\n\
    \            factors.append(k)\n            factors.append(k)\n            factors.append(k)\n\
    \            factors.append(k)\n            factors.append(k)\n            factors.append(k)\n\
    \            factors.append(k)\n            factors.append(k)\n            factors.append(k)\n\
    \            factors.append(k)\n            factors.append(k)\n            factors.append(k)\n\
    \            factors.append(k)\n            factors.append(k)\n            factors.append(k)\n\
    \            factors.append(k)\n            factors.append(k)\n            factors.append(k)\n\
    \            factors.append(k)\n            factors.append(k)\n            factors.append(k)\n\
    \            factors.append(k)\n            factors.append(k)\n            factors.append(k)\n\
    \            factors.append(k)\n            factors.append(k)\n            factors.append(k)\n\
    \            factors.append(k)\n            factors.append(k)\n            factors.append(k)\n\
    \            factors.append(k)\n            factors.append(k)\n            factors.append(k)\n\
    \            factors.append(k)\n            factors.append(k)\n            factors.append(k)\n\
    \            factors.append(k)\n            factors.append(k)\n            factors.append(k)\n\
    \            factors.append(k)\n            \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp74l2z563.swift:138:38: error: expected '}' at end of brace statement\n\
    assert(factorize(n: 18) == [2, 3, 3])\n                                     ^\n\
    /tmp/tmp74l2z563.swift:20:18: note: to match this opening '{'\n    while i <=\
    \ k {\n                 ^\n/tmp/tmp74l2z563.swift:138:38: error: expected '}'\
    \ at end of brace statement\nassert(factorize(n: 18) == [2, 3, 3])\n         \
    \                            ^\n/tmp/tmp74l2z563.swift:11:33: note: to match this\
    \ opening '{'\nfunc factorize(n: Int) -> [Int] {\n                           \
    \     ^\n/tmp/tmp74l2z563.swift:119:6: error: operator functions can only be declared\
    \ at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n     ^\n/tmp/tmp74l2z563.swift:16:9: warning: initialization of variable\
    \ 'factorization' was never used; consider replacing with assignment to '_' or\
    \ removing it\n    var factorization = [Int]()\n    ~~~~^~~~~~~~~~~~~\n    _\n\
    /tmp/tmp74l2z563.swift:17:9: warning: variable 'i' was never mutated; consider\
    \ changing to 'let' constant\n    var i = 2\n    ~~~ ^\n    let\n/tmp/tmp74l2z563.swift:18:9:\
    \ warning: variable 'j' was never mutated; consider changing to 'let' constant\n\
    \    var j = 1\n    ~~~ ^\n    let\n/tmp/tmp74l2z563.swift:19:9: warning: variable\
    \ 'k' was never mutated; consider changing to 'let' constant\n    var k = n\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            factorization[factorization.count]\
    \ = i\n            n /= i\n        } else {\n            i += 1\n        }\n \
    \   }\n    if n > 1 {\n        factorization[factorization.count] = n\n    }\n\
    \    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp2r18mxsh.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            factors.append(i)\n\
    \            n /= i\n        } else {\n            i += 1\n        }\n    }\n\
    \    if n > 1 {\n        factors.append(n)\n    }\n    return factors\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpv1s4fi4v.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var primeFactorization: [Int] = []\n    var primeFactorizationCount = 0\n\
    \    var factorizationCount = 0\n    var primeFactorizationIndex = 0\n    var\
    \ factorizationIndex = 0\n    var isPrime = true\n    var isPrimeCount = 0\n \
    \   var isPrimeIndex = 0\n    var isPrimeFactorization = false\n    var isPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationIndex = 0\n    var isPrimeFactorizationPrime\
    \ = false\n    var isPrimeFactorizationPrimeCount = 0\n    var isPrimeFactorizationPrimeIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorization = false\n    var isPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationIndex = 0\n    var isPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeCount = 0\n    var\
    \ isPrimeFactorizationPrimeFactorizationPrimeIndex = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex =\
    \ 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime = false\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeCount =\
    \ 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPri\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpmyd75yfm.swift:43:9: error: invalid redeclaration of 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n        ^\n/tmp/tmpmyd75yfm.swift:40:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n        ^\n/tmp/tmpmyd75yfm.swift:48:9: error: type annotation missing\
    \ in pattern\n    var isPri\n        ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: -4
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    if n < 2 {\n        return []\n \
    \   }\n    var factorization: [Int] = []\n    var factor = 2\n    var remainder\
    \ = n\n    while remainder > 1 {\n        if remainder % factor == 0 {\n     \
    \       factorization[factor] = factor\n            remainder /= factor\n    \
    \    } else {\n            factor += 1\n        }\n    }\n    factorization[factor]\
    \ = remainder\n    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:613: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b34b417dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b34b3e74561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b34b3e74286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b34b3e7413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b34b3e73bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b34b3c737ec <unavailable> + 186348

    6    tmpxgxhvhiu                        0x0000561f992b5d71 <unavailable> + 7537

    7    tmpxgxhvhiu                        0x0000561f992b539b <unavailable> + 5019

    8    libc.so.6                          0x00002b34b4369460 __libc_start_main +
    245

    9    tmpxgxhvhiu                        0x0000561f992b50b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var factorization\
    \ = factorizationOfNumber(n)\n    var primeFactorization = factorizationOfNumber(n)\n\
    \    var primeFactorizationIndex = 0\n    var factorizationIndex = 0\n    var\
    \ factorizationIndex2 = 0\n    var factorizationIndex3 = 0\n    var factorizationIndex4\
    \ = 0\n    var factorizationIndex5 = 0\n    var factorizationIndex6 = 0\n    var\
    \ factorizationIndex7 = 0\n    var factorizationIndex8 = 0\n    var factorizationIndex9\
    \ = 0\n    var factorizationIndex10 = 0\n    var factorizationIndex11 = 0\n  \
    \  var factorizationIndex12 = 0\n    var factorizationIndex13 = 0\n    var factorizationIndex14\
    \ = 0\n    var factorizationIndex15 = 0\n    var factorizationIndex16 = 0\n  \
    \  var factorizationIndex17 = 0\n    var factorizationIndex18 = 0\n    var factorizationIndex19\
    \ = 0\n    var factorizationIndex20 = 0\n    var factorizationIndex21 = 0\n  \
    \  var factorizationIndex22 = 0\n    var factorizationIndex23 = 0\n    var factorizationIndex24\
    \ = 0\n    var factorizationIndex25 = 0\n    var factorizationIndex26 = 0\n  \
    \  var factorizationIndex27 = 0\n    var factorizationIndex28 = 0\n    var factorizationIndex29\
    \ = 0\n    var factorizationIndex30 = 0\n    var factorizationIndex31 = 0\n  \
    \  var factorizationIndex32 = 0\n    var factorizationIndex33 = 0\n    var factorizationIndex34\
    \ = 0\n    var factorizationIndex35 = 0\n    var factorizationIndex36 = 0\n  \
    \  var factorizationIndex37 = 0\n    var factorizationIndex38 = 0\n    var factorizationIndex39\
    \ = 0\n    var factorizationIndex40 = 0\n    var factorizationIndex41 = 0\n  \
    \  var factorizationIndex42 = 0\n    var factorizationIndex43 = 0\n    var factorizationIndex44\
    \ = 0\n    var factorizationIndex45 = 0\n    var factorizationIndex46 = 0\n  \
    \  var factorizationIndex47 = 0\n    var factorizationIndex48 = 0\n    var factorizationIndex49\
    \ = 0\n    var factorizationIndex50 = 0\n    var factorizationIndex51 = 0\n  \
    \  var factorizationIndex52 = 0\n    var factorizationIndex53 = 0\n    var factorizationIndex54\
    \ = 0\n    var factorizationIndex55 = 0\n    var factorizationIndex56 = 0\n  \
    \  var factorizationIndex57 = 0\n    var factorizationIndex58 = 0\n    var factorizationIndex59\
    \ = 0\n    var factorizationIndex60 = 0\n    var factorizationIndex61 = 0\n  \
    \  var factorizationIndex62 = 0\n    var factorizationIndex63 = 0\n    var factorizationIndex64\
    \ = 0\n    var factorizationIndex65 = 0\n    var factorizationIndex66 = 0\n  \
    \  var factorizationIndex67 = 0\n    var factorizationIndex68 = 0\n    var factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpswf7t7_6.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpswf7t7_6.swift:14:30: error: cannot find\
    \ 'factorizationOfNumber' in scope\n    var primeFactorization = factorizationOfNumber(n)\n\
    \                             ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpswf7t7_6.swift:84:9:\
    \ error: type annotation missing in pattern\n    var factor\n        ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            factorization[factorization.count]\
    \ = i\n            n /= i\n        } else {\n            i += 1\n        }\n \
    \   }\n    if n > 1 {\n        factorization[factorization.count] = n\n    }\n\
    \    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp2r18mxsh.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var factorizationCount = 0\n    var factorizationIndex = 0\n    var isPrime\
    \ = true\n    var isDivisibleBy2 = false\n    var isDivisibleBy3 = false\n   \
    \ var isDivisibleBy5 = false\n    var isDivisibleBy7 = false\n    var isDivisibleBy11\
    \ = false\n    var isDivisibleBy13 = false\n    var isDivisibleBy17 = false\n\
    \    var isDivisibleBy19 = false\n    var isDivisibleBy23 = false\n    var isDivisibleBy29\
    \ = false\n    var isDivisibleBy31 = false\n    var isDivisibleBy37 = false\n\
    \    var isDivisibleBy43 = false\n    var isDivisibleBy47 = false\n    var isDivisibleBy53\
    \ = false\n    var isDivisibleBy59 = false\n    var isDivisibleBy61 = false\n\
    \    var isDivisibleBy67 = false\n    var isDivisibleBy73 = false\n    var isDivisibleBy79\
    \ = false\n    var isDivisibleBy81 = false\n    var isDivisibleBy87 = false\n\
    \    var isDivisibleBy93 = false\n    var isDivisibleBy101 = false\n    var isDivisibleBy107\
    \ = false\n    var isDivisibleBy113 = false\n    var isDivisibleBy119 = false\n\
    \    var isDivisibleBy121 = false\n    var isDivisibleBy127 = false\n    var isDivisibleBy131\
    \ = false\n    var isDivisibleBy137 = false\n    var isDivisibleBy143 = false\n\
    \    var isDivisibleBy145 = false\n    var isDivisibleBy151 = false\n    var isDivisibleBy157\
    \ = false\n    var isDivisibleBy163 = false\n    var isDivisibleBy167 = false\n\
    \    var isDivisibleBy173 = false\n    var isDivisibleBy175 = false\n    var isDivisibleBy181\
    \ = false\n    var isDivisibleBy187 = false\n    var isDivisibleBy193 = false\n\
    \    var isDivisibleBy195 = false\n    var isDivisibleBy197 = false\n    var isDivisibleBy203\
    \ = false\n    var isDivisibleBy205 = false\n    var isDivisibleBy211 = false\n\
    \    var isDivisibleBy217 = false\n    var isDivisibleBy223 = false\n    var isDivisibleBy227\
    \ = false\n    var isDivisibleBy233 = false\n    var isDivisibleBy237 = false\n\
    \    var isDivisibleBy243 = false\n    var isDivisibleBy245 = false\n    var isDivisibleBy251\
    \ = false\n    var isDivisibleBy257 = false\n    var isDivisibleBy263 = false\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp5ff70ja8.swift:12:9: warning: initialization of variable 'factorization'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorization = [Int]()\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmp5ff70ja8.swift:13:9:\
    \ warning: initialization of variable 'factorizationCount' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorizationCount\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp5ff70ja8.swift:14:9: warning:\
    \ initialization of variable 'factorizationIndex' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var factorizationIndex = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmp5ff70ja8.swift:15:9: warning: initialization of variable 'isPrime'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrime = true\n    ~~~~^~~~~~~\n    _\n/tmp/tmp5ff70ja8.swift:16:9: warning:\
    \ initialization of variable 'isDivisibleBy2' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var isDivisibleBy2 = false\n    ~~~~^~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmp5ff70ja8.swift:17:9: warning: initialization of variable 'isDivisibleBy3'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isDivisibleBy3 = false\n    ~~~~^~~~~~~~~~~~~~\n    _\n/tmp/tmp5ff70ja8.swift:18:9:\
    \ warning: initialization of variable 'isDivisibleBy5' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var isDivisibleBy5 = false\n\
    \    ~~~~^~~~~~~~~~~~~~\n    _\n/tmp/tmp5ff70ja8.swift:19:9: warning: initialization\
    \ of variable 'isDivisibleBy7' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var isDivisibleBy7 = false\n    ~~~~^~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmp5ff70ja8.swift:20:9: warning: initialization of variable 'isDivisibleBy11'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isDivisibleBy11 = false\n    ~~~~^~~~~~~~~~~~~~~\n    _\n/tmp/tmp5ff70ja8.swift:21:9:\
    \ warning: initialization of variable 'isDivisibleBy13' was never used; consider\
    \ replacing"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var primeFactorization = [Int]()\n    var primeFactorizationIndex = 0\n    var\
    \ primeFactorizationCount = 0\n    var isPrime = true\n    var isPrimeIndex =\
    \ 0\n    var isPrimeCount = 0\n    var isPrimeFactorization = true\n    var isPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationCount = 0\n    var isPrimePrime = true\n  \
    \  var isPrimePrimeIndex = 0\n    var isPrimePrimeCount = 0\n    var isPrimePrimeFactorization\
    \ = true\n    var isPrimePrimeFactorizationIndex = 0\n    var isPrimePrimeFactorizationCount\
    \ = 0\n    var isPrimePrimePrime = true\n    var isPrimePrimePrimeIndex = 0\n\
    \    var isPrimePrimePrimeCount = 0\n    var isPrimePrimePrimeFactorization =\
    \ true\n    var isPrimePrimePrimeFactorizationIndex = 0\n    var isPrimePrimePrimeFactorizationCount\
    \ = 0\n    var isPrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimeIndex\
    \ = 0\n    var isPrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimeFactorization\
    \ = true\n    var isPrimePrimePrimePrimeFactorizationIndex = 0\n    var isPrimePrimePrimePrimeFactorizationCount\
    \ = 0\n    var isPrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimeIndex\
    \ = 0\n    var isPrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimeFactorization\
    \ = true\n    var isPrimePrimePrimePrimePrimeFactorizationIndex = 0\n    var isPrimePrimePrimePrimePrimeFactorizationCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimeIndex\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimeFactorization\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimeFactorizationIndex = 0\n   \
    \ var isPrimePrimePrimePrimePrimePrimeFactorizationCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePri\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpprp0yw2a.swift:53:9: error: type annotation missing in pattern\n\
    \    var isPrimePrimePri\n        ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: -4
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n    var\
    \ i = 2\n    var factor: Int\n    while i < n {\n        factor = 0\n        while\
    \ i < n && n % i == 0 {\n            factor += 1\n            i += 1\n       \
    \ }\n        factors.append(factor)\n        i += 1\n    }\n    return factors\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmp0vgkmvli/tmp0vgkmvli.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2e40aacc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2e407a3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2e407a3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2e407a27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0vgkmvli                        0x0000559b341e7462 <unavailable> + 5218

    5    libc.so.6                          0x00002b2e40c98460 __libc_start_main +
    245

    6    tmp0vgkmvli                        0x0000559b341e70b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    var factor = 1\n    while i <= n {\n        while n % i == 0 {\n  \
    \          n /= i\n            factors.append(factor)\n            factor = 1\n\
    \        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(factor)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp5y5bl34v.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n    var\
    \ i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            factors.append(i)\n\
    \            n /= i\n        } else {\n            i += 1\n        }\n    }\n\
    \    if n != 1 {\n        factors.append(n)\n    }\n    return factors\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpdnd393m4.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var primeFactorization = [Int]()\n    var primeFactorizationIndex = 0\n    var\
    \ factorizationIndex = 0\n    var isPrime = true\n    var isPrimeIndex = 0\n \
    \   var isPrimeFactorization = false\n    var isPrimeFactorizationIndex = 0\n\
    \    var isPrimePrimeFactorization = false\n    var isPrimePrimeFactorizationIndex\
    \ = 0\n    var isPrimePrimeFactorizationPrimeFactorization = false\n    var isPrimePrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorization =\
    \ false\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = false\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = false\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = false\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = false\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = false\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = false\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = false\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = false\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = false\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPri\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpmi19kl6u.swift:31:9: error: invalid redeclaration of 'isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization'\n\
    \    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = false\n        ^\n/tmp/tmpmi19kl6u.swift:30:9: note: 'isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization'\
    \ previously declared here\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = false\n        ^\n/tmp/tmpmi19kl6u.swift:33:9: error: invalid redeclaration\
    \ of 'isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization'\n\
    \    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = false\n        ^\n/tmp/tmpmi19kl6u.swift:32:9: note: 'isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization'\
    \ previously declared here\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = false\n        ^\n/tmp/tmpmi19kl6u.swift:34:9: error: invalid redeclaration\
    \ of 'isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization'\n\
    \    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = false\n        ^\n/tmp/tmpmi19kl6u.swift:32:9: note: 'isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization'\
    \ previously declared here\n    var isPrimePrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var primeFactorization: [Int] = []\n    var isPrime: Bool = false\n    var\
    \ isPrimeFactorization: Bool = false\n    var isPrimePrimeFactorization: Bool\
    \ = false\n    var isPrimePrimePrimeFactorization: Bool = false\n    var isPrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimeFactorization: Bool = false\n\
    \    var isPrimePrimePrimePrimePrimePrimeFactorization: Bool = false\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimeFactorization: Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePri\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp228w_avz.swift:22:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimeFactorization'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeFactorization: Bool = false\n  \
    \      ^\n/tmp/tmp228w_avz.swift:21:9: note: 'isPrimePrimePrimePrimePrimePrimePrimeFactorization'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n        ^\n/tmp/tmp228w_avz.swift:26:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization'\n   \
    \ var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization: Bool\
    \ = false\n        ^\n/tmp/tmp228w_avz.swift:25:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n        ^\n/tmp/tmp228w_avz.swift:27:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization'\n   \
    \ var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization: Bool\
    \ = false\n        ^\n/tmp/tmp228w_avz.swift:25:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n        ^\n/tmp/tmp228w_avz.swift:30:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n        ^\n/tmp/tmp228w_avz.swift:29:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n        ^\n/tmp/tmp228w_avz.swift:32:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization:\
    \ Bool = false\n        ^"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            factorization[factorization.count]\
    \ = i\n            n /= i\n        } else {\n            i += 1\n        }\n \
    \   }\n    if n != 1 {\n        factorization[factorization.count] = n\n    }\n\
    \    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpxdstd1ou.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var factorizationCount = 0\n    var factorizationIndex = 0\n    var isPrime\
    \ = true\n    var isPrimeIndex = 0\n    var isPrimeCount = 0\n    var isPrimeIndex2\
    \ = 0\n    var isPrimeCount2 = 0\n    var isPrimeIndex3 = 0\n    var isPrimeCount3\
    \ = 0\n    var isPrimeIndex4 = 0\n    var isPrimeCount4 = 0\n    var isPrimeIndex5\
    \ = 0\n    var isPrimeCount5 = 0\n    var isPrimeIndex6 = 0\n    var isPrimeCount6\
    \ = 0\n    var isPrimeIndex7 = 0\n    var isPrimeCount7 = 0\n    var isPrimeIndex8\
    \ = 0\n    var isPrimeCount8 = 0\n    var isPrimeIndex9 = 0\n    var isPrimeCount9\
    \ = 0\n    var isPrimeIndex10 = 0\n    var isPrimeCount10 = 0\n    var isPrimeIndex11\
    \ = 0\n    var isPrimeCount11 = 0\n    var isPrimeIndex12 = 0\n    var isPrimeCount12\
    \ = 0\n    var isPrimeIndex13 = 0\n    var isPrimeCount13 = 0\n    var isPrimeIndex14\
    \ = 0\n    var isPrimeCount14 = 0\n    var isPrimeIndex15 = 0\n    var isPrimeCount15\
    \ = 0\n    var isPrimeIndex16 = 0\n    var isPrimeCount16 = 0\n    var isPrimeIndex17\
    \ = 0\n    var isPrimeCount17 = 0\n    var isPrimeIndex18 = 0\n    var isPrimeCount18\
    \ = 0\n    var isPrimeIndex19 = 0\n    var isPrimeCount19 = 0\n    var isPrimeIndex20\
    \ = 0\n    var isPrimeCount20 = 0\n    var isPrimeIndex21 = 0\n    var isPrimeCount21\
    \ = 0\n    var isPrimeIndex22 = 0\n    var isPrimeCount22 = 0\n    var isPrimeIndex23\
    \ = 0\n    var isPrimeCount23 = 0\n    var isPrimeIndex24 = 0\n    var isPrimeCount24\
    \ = 0\n    var isPrimeIndex25 = 0\n    var isPrimeCount25 = 0\n    var isPrimeIndex26\
    \ = 0\n    var isPrimeCount26 = 0\n    var isPrimeIndex27 = 0\n    var isPrimeCount27\
    \ = 0\n    var isPrimeIndex28 = 0\n    var isPrimeCount28 = 0\n    var isPrimeIndex29\
    \ = 0\n    var isPrimeCount29 = 0\n    var isPrimeIndex30 = 0\n    var isPrimeCount30\
    \ = 0\n    var isPrimeIndex31 = 0\n    var \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpndbm2qq6.swift:77:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpndbm2qq6.swift:12:9: warning: variable 'factorization' was never\
    \ used; consider replacing with '_' or removing it\n    var factorization: [Int]\
    \ = []\n        ^~~~~~~~~~~~~\n        _\n/tmp/tmpndbm2qq6.swift:13:9: warning:\
    \ initialization of variable 'factorizationCount' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var factorizationCount = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpndbm2qq6.swift:14:9: warning: initialization of variable 'factorizationIndex'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorizationIndex = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpndbm2qq6.swift:15:9:\
    \ warning: initialization of variable 'isPrime' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var isPrime = true\n    ~~~~^~~~~~~\n\
    \    _\n/tmp/tmpndbm2qq6.swift:16:9: warning: initialization of variable 'isPrimeIndex'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeIndex = 0\n    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmpndbm2qq6.swift:17:9:\
    \ warning: initialization of variable 'isPrimeCount' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var isPrimeCount = 0\n\
    \    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmpndbm2qq6.swift:18:9: warning: initialization\
    \ of variable 'isPrimeIndex2' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var isPrimeIndex2 = 0\n    ~~~~^~~~~~~~~~~~~\n  \
    \  _\n/tmp/tmpndbm2qq6.swift:19:9: warning: initialization of variable 'isPrimeCount2'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeCount2 = 0\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmpndbm2qq6.swift:20:9:\
    \ warning: initialization of variable 'isPrimeIndex3' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var isPrimeIndex3 = 0\n\
    \    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmpndbm2qq6.swift:21:9: warning: initialization\
    \ of variable 'isPrimeCount3' was never used; consider replacing "
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var factorizationCount = 0\n    var factorizationIndex = 0\n    var factorizationIndexMax\
    \ = Int(ceil(sqrt(Double(n))))\n    var factorizationIndexMax2 = factorizationIndexMax\
    \ * factorizationIndexMax\n    var factorizationIndexMax3 = factorizationIndexMax2\
    \ * factorizationIndexMax\n    var factorizationIndexMax4 = factorizationIndexMax3\
    \ * factorizationIndexMax\n    var factorizationIndexMax5 = factorizationIndexMax4\
    \ * factorizationIndexMax\n    var factorizationIndexMax6 = factorizationIndexMax5\
    \ * factorizationIndexMax\n    var factorizationIndexMax7 = factorizationIndexMax6\
    \ * factorizationIndexMax\n    var factorizationIndexMax8 = factorizationIndexMax7\
    \ * factorizationIndexMax\n    var factorizationIndexMax9 = factorizationIndexMax8\
    \ * factorizationIndexMax\n    var factorizationIndexMax10 = factorizationIndexMax9\
    \ * factorizationIndexMax\n    var factorizationIndexMax11 = factorizationIndexMax10\
    \ * factorizationIndexMax\n    var factorizationIndexMax12 = factorizationIndexMax11\
    \ * factorizationIndexMax\n    var factorizationIndexMax13 = factorizationIndexMax12\
    \ * factorizationIndexMax\n    var factorizationIndexMax14 = factorizationIndexMax13\
    \ * factorizationIndexMax\n    var factorizationIndexMax15 = factorizationIndexMax14\
    \ * factorizationIndexMax\n    var factorizationIndexMax16 = factorizationIndexMax15\
    \ * factorizationIndexMax\n    var factorizationIndexMax17 = factorizationIndexMax16\
    \ * factorizationIndexMax\n    var factorizationIndexMax18 = factorizationIndexMax17\
    \ * factorizationIndexMax\n    var factorizationIndexMax19 = factorizationIndexMax18\
    \ * factorizationIndexMax\n    var factorizationIndexMax20 = factorizationIndexMax19\
    \ * factorizationIndexMax\n    var factorizationIndexMax21 = factorizationIndexMax20\
    \ * factorizationIndexMax\n    var factorizationIndexMax22 = factorizationIndexMax21\
    \ * factorizationIndexMax\n    var factorizationIndexMax23 = factorizationIndexMax22\
    \ * factorizationIndexMax\n    var factorizationIndexMax24 = factorizationIndexMax23\
    \ * factorizationIndexMax\n    var factorizationIndexMax25 = factorizationIndexMax24\
    \ * factorizationIndexMax\n    var factorizationIndexMax26 = factorizationIndexMax25\
    \ * factorizationIndexMax\n    var factorizationIndexMax27 = factorizationIndexMax26\
    \ * factorizationIndexMax\n    var factorizationIndexMax28 = factorizationIndexMax27\
    \ * factorizationIndexMax\n    var factorizationIndexMax29 = factorizationIndexMax28\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpxz25s06p.swift:15:37: error: cannot find 'ceil' in scope\n    var\
    \ factorizationIndexMax = Int(ceil(sqrt(Double(n))))\n                       \
    \             ^~~~\n/tmp/tmpxz25s06p.swift:15:42: error: cannot find 'sqrt' in\
    \ scope\n    var factorizationIndexMax = Int(ceil(sqrt(Double(n))))\n        \
    \                                 ^~~~\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var i = 2\n    while i <= n {\n        if n % i == 0 {\n            factorization\
    \ = factorization + [i]\n            n /= i\n        } else {\n            i +=\
    \ 1\n        }\n    }\n    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpg1wt7n8y.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var factorization\
    \ = factorizationOfNumber(n)\n    for factor in factorization {\n        factors.append(factor)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpaaj3z1xc.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var factorization\
    \ = factorizationOfNumber(n)\n    for factor in factorization {\n        factors.append(factor)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpaaj3z1xc.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var factor = 2\n    var factorizationCount = 0\n    var isPrime = true\n \
    \   var isPrimeCount = 0\n    var isPrimeFactorization = false\n    var isPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrime = false\n    var isPrimeFactorizationPrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactor = false\n    var isPrimeFactorizationPrimeFactorCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorization = false\n    var isPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrime = false\n    var isPrimeFactorizationPrimeFactorizationPrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactor = false\n   \
    \ var isPrimeFactorizationPrimeFactorizationPrimeFactorCount = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime =\
    \ false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactor\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorization\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpmsudu4le.swift:38:9: error: invalid redeclaration of 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n        ^\n/tmp/tmpmsudu4le.swift:36:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n        ^\n/tmp/tmpmsudu4le.swift:39:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n        ^\n/tmp/tmpmsudu4le.swift:37:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n        ^\n/tmp/tmpmsudu4le.swift:40:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n        ^\n/tmp/tmpmsudu4le.swift:36:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n        ^\n/tmp/tmpmsudu4le.swift:41:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n        ^\n/tmp/tmpmsudu4le.swift:37:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n        ^\n/tmp/tmpmsudu4le.swift:42:9: error: invalid redeclaration\
    \ of 'isPrimeFactori"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    var factor = 1\n    while i < n {\n        while n % i == 0 {\n   \
    \         factors.append(factor)\n            n /= i\n        }\n        i +=\
    \ 1\n        factor = 1\n    }\n    if n > 1 {\n        factors.append(n)\n  \
    \  }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpn7i6wb8r.swift:18:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    if n < 2 {\n        return []\n \
    \   }\n    var factors = [Int]()\n    var i = 2\n    var j = 1\n    var factorization\
    \ = [Int]()\n    while i < n {\n        while j < n && n % i == 0 {\n        \
    \    factors.append(i)\n            factors.append(j)\n            factors.append(n\
    \ / i)\n            factors.append(n / j)\n            factors.append(n / i /\
    \ j)\n            factors.append(n / i / j / i)\n            factors.append(n\
    \ / i / j / i / j)\n            factors.append(n / i / j / i / j / i)\n      \
    \      factors.append(n / i / j / i / j / i / j)\n            factors.append(n\
    \ / i / j / i / j / i / j / i)\n            factors.append(n / i / j / i / j /\
    \ i / j / i / j)\n            factors.append(n / i / j / i / j / i / j / i / j\
    \ / i)\n            factors.append(n / i / j / i / j / i / j / i / j / i / j)\n\
    \            factors.append(n / i / j / i / j / i / j / i / j / i / j / i)\n \
    \           factors.append(n / i / j / i / j / i / j / i / j / i / j / i / j)\n\
    \            factors.append(n / i / j / i / j / i / j / i / j / i / j / i / j\
    \ / i)\n            factors.append(n / i / j / i / j / i / j / i / j / i / j /\
    \ i / j / j)\n            factors.append(n / i / j / i / j / i / j / i / j / i\
    \ / j / i / j / j / i)\n            factors.append(n / i / j / i / j / i / j /\
    \ i / j / i / j / i / j / j / j)\n            factors.append(n / i / j / i / j\
    \ / i / j / i / j / i / j / i / j / j / j / i)\n            factors.append(n /\
    \ i / j / i / j / i / j / i / j / i / j / i / j / j / j / j)\n            factors.append(n\
    \ / i / j / i / j / i / j / i / j / i / j / i / j / j / j / j / i)\n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpvuck9avu.swift:66:38: error: expected '}' at end of brace statement\n\
    assert(factorize(n: 18) == [2, 3, 3])\n                                     ^\n\
    /tmp/tmpvuck9avu.swift:19:17: note: to match this opening '{'\n    while i < n\
    \ {\n                ^\n/tmp/tmpvuck9avu.swift:66:38: error: expected '}' at end\
    \ of brace statement\nassert(factorize(n: 18) == [2, 3, 3])\n                \
    \                     ^\n/tmp/tmpvuck9avu.swift:11:33: note: to match this opening\
    \ '{'\nfunc factorize(n: Int) -> [Int] {\n                                ^\n\
    /tmp/tmpvuck9avu.swift:47:6: error: operator functions can only be declared at\
    \ global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n     ^\n/tmp/tmpvuck9avu.swift:16:9: warning: variable 'i' was never\
    \ mutated; consider changing to 'let' constant\n    var i = 2\n    ~~~ ^\n   \
    \ let\n/tmp/tmpvuck9avu.swift:17:9: warning: variable 'j' was never mutated; consider\
    \ changing to 'let' constant\n    var j = 1\n    ~~~ ^\n    let\n/tmp/tmpvuck9avu.swift:18:9:\
    \ warning: initialization of variable 'factorization' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorization = [Int]()\n\
    \    ~~~~^~~~~~~~~~~~~\n    _\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var factorizationCount = [Int]()\n    var primeFactorization = [Int]()\n   \
    \ var primeFactorizationCount = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeCount\
    \ = [Int]()\n    var isPrimePrime = [Bool]()\n    var isPrimePrimeCount = [Int]()\n\
    \    var isPrimePrimePrime = [Bool]()\n    var isPrimePrimePrimeCount = [Int]()\n\
    \    var isPrimePrimePrimePrime = [Bool]()\n    var isPrimePrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimePrimePrimePrimePrime = [Bool]()\n    var isPrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimePrimePrimePrimePrimePrime = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimePrimePrimePrimePrimePrimePrime = [Bool]()\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimeCount = [Int]()\n    var isPrimePrimePrimePrimePrimePrimePrime\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimeCount = [Int]()\n \
    \   var isPrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n \
    \   var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = [Int]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrime\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = [Int]()\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n\
    \    var \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpwlmv0kvm.swift:41:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpwlmv0kvm.swift:30:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrime = [Bool]()\n        ^\n/tmp/tmpwlmv0kvm.swift:28:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrime' previously declared here\n   \
    \ var isPrimePrimePrimePrimePrimePrimePrime = [Bool]()\n        ^\n/tmp/tmpwlmv0kvm.swift:31:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = [Int]()\n        ^\n/tmp/tmpwlmv0kvm.swift:29:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimeCount' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = [Int]()\n        ^\n/tmp/tmpwlmv0kvm.swift:34:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n        ^\n/tmp/tmpwlmv0kvm.swift:32:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimePrime' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n        ^\n/tmp/tmpwlmv0kvm.swift:35:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = [Int]()\n        ^\n\
    /tmp/tmpwlmv0kvm.swift:33:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n        ^\n/tmp/tmpwlmv0kvm.swift:36:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrimePrimePrime'\n    var isPrimePrimePrimePrimePrimePrimePrimePrime\
    \ = [Bool]()\n        ^\n/tmp/tmpwlmv0kvm.swift:32:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrime\
    \ = [Bool]()\n        ^\n/tmp/tmpwlmv0kvm.swift:37:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount'\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n        ^\n/tmp/tmpwlmv0kvm.sw"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var factorizationCount = [Int]()\n    var primeFactorization = [Int]()\n   \
    \ var primeFactorizationCount = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeCount\
    \ = [Bool]()\n    var isPrimeFactorization = [Bool]()\n    var isPrimeFactorizationCount\
    \ = [Bool]()\n    var isPrimePrimeFactorization = [Bool]()\n    var isPrimePrimeFactorizationCount\
    \ = [Bool]()\n    var isPrimePrimePrimeFactorization = [Bool]()\n    var isPrimePrimePrimeFactorizationCount\
    \ = [Bool]()\n    var isPrimePrimePrimePrimeFactorization = [Bool]()\n    var\
    \ isPrimePrimePrimePrimeFactorizationCount = [Bool]()\n    var isPrimePrimePrimePrimePrimeFactorization\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimeFactorizationCount = [Bool]()\n\
    \    var isPrimePrimePrimePrimePrimePrimeFactorization = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimeFactorizationCount\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimeFactorization = [Bool]()\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeFactorizationCount = [Bool]()\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimeFactorization = [Bool]()\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimeFactorizationCount = [Bool]()\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization = [Bool]()\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorizationCount = [Bool]()\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization = [Bool]()\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorizationCount\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrime\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpmc_65mvl.swift:38:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization = [Bool]()\n\
    \        ^\n/tmp/tmpmc_65mvl.swift:36:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = [Bool]()\n        ^\n/tmp/tmpmc_65mvl.swift:39:9: error: type annotation missing\
    \ in pattern\n    var isPrimePrimePrimePrimePrimePrimePrimePrime\n        ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var primeFactorization: [Int] = []\n    var factorizationCount = 0\n    var\
    \ primeFactorizationCount = 0\n    var factorizationPrimeCount = 0\n    var primeFactorizationPrimeCount\
    \ = 0\n    var isPrime = true\n    var isPrimePrime = true\n    var isPrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n  \
    \  var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime =\
    \ true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpscp8kmxj.swift:30:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n\
    \        ^\n/tmp/tmpscp8kmxj.swift:29:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmpscp8kmxj.swift:34:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmpscp8kmxj.swift:33:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmpscp8kmxj.swift:35:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmpscp8kmxj.swift:33:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmpscp8kmxj.swift:37:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmpscp8kmxj.swift:36:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n        ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var factorizationCount = 0\n    var currentFactorizationCount = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmps6qx_bv5.swift:16:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:17:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmps6qx_bv5.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:18:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmps6qx_bv5.swift:19:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:20:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmps6qx_bv5.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:21:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmps6qx_bv5.swift:22:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:23:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmps6qx_bv5.swift:15:9: note: 'currentFactorization' previously declar"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    if n < 2 {\n        return []\n \
    \   }\n    var factors = [Int]()\n    var i = 2\n    var p = 2\n    while i *\
    \ p <= n {\n        if n % i == 0 {\n            factors.append(i)\n         \
    \   n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpr1r3n8mo.swift:21:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var primes\
    \ = factors\n    var primeFactorization = factors\n    var isPrime = true\n  \
    \  var isPrimeFactorization = true\n    var isPrimeFactorizationPrime = true\n\
    \    var isPrimeFactorizationPrimePrime = true\n    var isPrimeFactorizationPrimePrimePrime\
    \ = true\n    var isPrimeFactorizationPrimePrimePrimePrime = true\n    var isPrimeFactorizationPrimePrimePrimePrimePrime\
    \ = true\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrime = true\n\
    \    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrime = true\n    var\
    \ isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrime = true\n    var\
    \ isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n \
    \   var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimeFactorizationPrimePrimePrimePri\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp51zj15a8.swift:28:9: error: invalid redeclaration of 'isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmp51zj15a8.swift:27:9: note: 'isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmp51zj15a8.swift:30:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmp51zj15a8.swift:29:9: note: 'isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmp51zj15a8.swift:32:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmp51zj15a8.swift:31:9: note: 'isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmp51zj15a8.swift:33:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmp51zj15a8.swift:31:9: note: 'isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var i = 2\n    var j = 1\n    var k = 0\n    while i * j <= n {\n        if\
    \ n % i == 0 {\n            factorization[k] += i\n            n /= i\n      \
    \      j += 1\n            k += 1\n        }\n        i += 1\n    }\n    if n\
    \ > 1 {\n        factorization[k] += n\n    }\n    return factorization\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpl8xuro7v.swift:19:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var factorizationCount = 0\n    var factorizationIndex = 0\n    var factorizationMax\
    \ = Int(sqrt(Double(n)))\n    var factorizationMin = factorizationMax\n    var\
    \ factorizationMaxInt = Int(factorizationMax)\n    var factorizationMinInt = Int(factorizationMin)\n\
    \    var factorizationMaxDouble = Double(factorizationMax)\n    var factorizationMinDouble\
    \ = Double(factorizationMin)\n    var factorizationMaxDoubleInt = Int(factorizationMaxDouble)\n\
    \    var factorizationMinDoubleInt = Int(factorizationMinDouble)\n    var factorizationMaxDoubleDouble\
    \ = Double(factorizationMaxDouble)\n    var factorizationMinDoubleDouble = Double(factorizationMinDouble)\n\
    \    var factorizationMaxDoubleDoubleInt = Int(factorizationMaxDoubleDouble)\n\
    \    var factorizationMinDoubleDoubleInt = Int(factorizationMinDoubleDouble)\n\
    \    var factorizationMaxDoubleDoubleDouble = Double(factorizationMaxDoubleDouble)\n\
    \    var factorizationMinDoubleDoubleDouble = Double(factorizationMinDoubleDoubleDouble)\n\
    \    var factorizationMaxDoubleDoubleDoubleInt = Int(factorizationMaxDoubleDoubleDouble)\n\
    \    var factorizationMinDoubleDoubleDoubleInt = Int(factorizationMinDoubleDoubleDouble)\n\
    \    var factorizationMaxDoubleDoubleDoubleDouble = Double(factorizationMaxDoubleDoubleDouble)\n\
    \    var factorizationMinDoubleDoubleDoubleDouble = Double(factorizationMinDoubleDoubleDoubleDouble)\n\
    \    var factorizationMaxDoubleDoubleDoubleDoubleInt = Int(factorizationMaxDoubleDoubleDoubleDouble)\n\
    \    var factorizationMinDoubleDoubleDoubleDoubleInt = Int(factorizationMinDoubleDoubleDoubleDouble)\n\
    \    var factorizationMaxDoubleDoubleDoubleDoubleDouble = Double(factorizationMaxDoubleDoubleDoubleDoubleDouble)\n\
    \    var factorizationMinDoubleDoubleDoubleDoubleDouble = Double(factorizationMinDoubleDoubleDoubleDoubleDouble)\n\
    \    var factorizationMaxDoubleDoubleDoubleDoubleDoubleInt = Int(factorizationMaxDoubleDoubleDoubleDoubleDouble)\n\
    \    var factorizationMinDoubleDoubleDoubleDoubleDoubleInt = Int(factorizationMinDoubleDoubleDoubleDoubleDouble)\n\
    \    var factorizationMaxDoubleDoubleDoubleDoubleDoubleDouble = Double(factorizationMaxDoubleDoubleDoubleDoubleDoubleDouble)\n\
    \    var factorizationMinDoubleDoubleDoubleDoubleDoubleDouble = Double(factorizationMinDoubleDoubleDoubleDoubleDoubleDouble)\n\
    \    var factorizationMaxDoubleDoubleDoubleDoubleDoubleDoubleInt = Int(factorizationMaxDoubleDoubleDoubleDoubleDoubleDouble)\n\
    \    var factorizationMinDoubleDoubleDoubleDoubleDoubleDoubleInt = Int(factorizationMinDoubleDoubleDoubleDoubleDoubleDouble)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpe55ku_9f.swift:15:32: error: cannot find 'sqrt' in scope\n    var\
    \ factorizationMax = Int(sqrt(Double(n)))\n                               ^~~~\n\
    /tmp/tmpe55ku_9f.swift:28:53: error: use of local variable 'factorizationMinDoubleDoubleDouble'\
    \ before its declaration\n    var factorizationMinDoubleDoubleDouble = Double(factorizationMinDoubleDoubleDouble)\n\
    \                                                    ^\n/tmp/tmpe55ku_9f.swift:28:9:\
    \ note: 'factorizationMinDoubleDoubleDouble' declared here\n    var factorizationMinDoubleDoubleDouble\
    \ = Double(factorizationMinDoubleDoubleDouble)\n        ^\n/tmp/tmpe55ku_9f.swift:32:59:\
    \ error: use of local variable 'factorizationMinDoubleDoubleDoubleDouble' before\
    \ its declaration\n    var factorizationMinDoubleDoubleDoubleDouble = Double(factorizationMinDoubleDoubleDoubleDouble)\n\
    \                                                          ^\n/tmp/tmpe55ku_9f.swift:32:9:\
    \ note: 'factorizationMinDoubleDoubleDoubleDouble' declared here\n    var factorizationMinDoubleDoubleDoubleDouble\
    \ = Double(factorizationMinDoubleDoubleDoubleDouble)\n        ^\n/tmp/tmpe55ku_9f.swift:35:65:\
    \ error: use of local variable 'factorizationMaxDoubleDoubleDoubleDoubleDouble'\
    \ before its declaration\n    var factorizationMaxDoubleDoubleDoubleDoubleDouble\
    \ = Double(factorizationMaxDoubleDoubleDoubleDoubleDouble)\n                 \
    \                                               ^\n/tmp/tmpe55ku_9f.swift:35:9:\
    \ note: 'factorizationMaxDoubleDoubleDoubleDoubleDouble' declared here\n    var\
    \ factorizationMaxDoubleDoubleDoubleDoubleDouble = Double(factorizationMaxDoubleDoubleDoubleDoubleDouble)\n\
    \        ^\n/tmp/tmpe55ku_9f.swift:36:65: error: use of local variable 'factorizationMinDoubleDoubleDoubleDoubleDouble'\
    \ before its declaration\n    var factorizationMinDoubleDoubleDoubleDoubleDouble\
    \ = Double(factorizationMinDoubleDoubleDoubleDoubleDouble)\n                 \
    \                                               ^\n/tmp/tmpe55ku_9f.swift:36:9:\
    \ note: 'factorizationMinDoubleDoubleDoubleDoubleDouble' declared here\n    var\
    \ factorizationMinDoubleD"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var factor: Int\n    var i: Int\n    var j: Int\n    var factorsCount: Int\n\
    \    var isPrime: Bool\n    var isPrime2: Bool\n    var isPrime3: Bool\n    var\
    \ isPrime4: Bool\n    var isPrime5: Bool\n    var isPrime6: Bool\n    var isPrime7:\
    \ Bool\n    var isPrime8: Bool\n    var isPrime9: Bool\n    var isPrime10: Bool\n\
    \    var isPrime11: Bool\n    var isPrime12: Bool\n    var isPrime13: Bool\n \
    \   var isPrime14: Bool\n    var isPrime15: Bool\n    var isPrime16: Bool\n  \
    \  var isPrime17: Bool\n    var isPrime18: Bool\n    var isPrime19: Bool\n   \
    \ var isPrime20: Bool\n    var isPrime21: Bool\n    var isPrime22: Bool\n    var\
    \ isPrime23: Bool\n    var isPrime24: Bool\n    var isPrime25: Bool\n    var isPrime26:\
    \ Bool\n    var isPrime27: Bool\n    var isPrime28: Bool\n    var isPrime29: Bool\n\
    \    var isPrime30: Bool\n    var isPrime31: Bool\n    var isPrime32: Bool\n \
    \   var isPrime33: Bool\n    var isPrime34: Bool\n    var isPrime35: Bool\n  \
    \  var isPrime36: Bool\n    var isPrime37: Bool\n    var isPrime38: Bool\n   \
    \ var isPrime39: Bool\n    var isPrime40: Bool\n    var isPrime41: Bool\n    var\
    \ isPrime42: Bool\n    var isPrime43: Bool\n    var isPrime44: Bool\n    var isPrime45:\
    \ Bool\n    var isPrime46: Bool\n    var isPrime47: Bool\n    var isPrime48: Bool\n\
    \    var isPrime49: Bool\n    var isPrime50: Bool\n    var isPrime51: Bool\n \
    \   var isPrime52: Bool\n    var isPrime53: Bool\n    var isPrime54: Bool\n  \
    \  var isPrime55: Bool\n    var isPrime56: Bool\n    var isPrime57: Bool\n   \
    \ var isPrime58: Bool\n    var isPrime59: Bool\n    var isPrime60: Bool\n    var\
    \ isPrime61: Bool\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpb4vc6n3c.swift:78:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpb4vc6n3c.swift:12:9: warning: variable 'factorization' was never\
    \ used; consider replacing with '_' or removing it\n    var factorization: [Int]\
    \ = []\n        ^~~~~~~~~~~~~\n        _\n/tmp/tmpb4vc6n3c.swift:13:9: warning:\
    \ variable 'factor' was never used; consider replacing with '_' or removing it\n\
    \    var factor: Int\n        ^~~~~~\n        _\n/tmp/tmpb4vc6n3c.swift:14:9:\
    \ warning: variable 'i' was never used; consider replacing with '_' or removing\
    \ it\n    var i: Int\n        ^\n        _\n/tmp/tmpb4vc6n3c.swift:15:9: warning:\
    \ variable 'j' was never used; consider replacing with '_' or removing it\n  \
    \  var j: Int\n        ^\n        _\n/tmp/tmpb4vc6n3c.swift:16:9: warning: variable\
    \ 'factorsCount' was never used; consider replacing with '_' or removing it\n\
    \    var factorsCount: Int\n        ^~~~~~~~~~~~\n        _\n/tmp/tmpb4vc6n3c.swift:17:9:\
    \ warning: variable 'isPrime' was never used; consider replacing with '_' or removing\
    \ it\n    var isPrime: Bool\n        ^~~~~~~\n        _\n/tmp/tmpb4vc6n3c.swift:18:9:\
    \ warning: variable 'isPrime2' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime2: Bool\n        ^~~~~~~~\n        _\n/tmp/tmpb4vc6n3c.swift:19:9:\
    \ warning: variable 'isPrime3' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime3: Bool\n        ^~~~~~~~\n        _\n/tmp/tmpb4vc6n3c.swift:20:9:\
    \ warning: variable 'isPrime4' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime4: Bool\n        ^~~~~~~~\n        _\n/tmp/tmpb4vc6n3c.swift:21:9:\
    \ warning: variable 'isPrime5' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime5: Bool\n        ^~~~~~~~\n        _\n/tmp/tmpb4vc6n3c.swift:22:9:\
    \ warning: variable 'isPrime6' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime6: Bool\n        ^~~~~~~~\n        _\n/tmp/tmpb4vc6n3c.swift:23:9:\
    \ warning: variable 'isPrime7' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime7: Bool\n        ^~~~~~~~\n     "
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var factorization\
    \ = [Int]()\n    var factorizationCount = 1\n    var factorizationIndex = 0\n\
    \    var isPrime = true\n    var isPrimeIndex = 0\n    var isPrimeFactorization\
    \ = false\n    var isPrimeFactorizationIndex = 0\n    var isPrimeFactorizationCount\
    \ = 1\n    var isPrimeFactorizationPrime = false\n    var isPrimeFactorizationPrimeIndex\
    \ = 0\n    var isPrimeFactorizationPrimeCount = 1\n    var isPrimeFactorizationPrimeFactorization\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationIndex = 0\n    var isPrimeFactorizationPrimeFactorizationCount\
    \ = 1\n    var isPrimeFactorizationPrimeFactorizationPrime = false\n    var isPrimeFactorizationPrimeFactorizationPrimeIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeCount = 1\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationCount =\
    \ 1\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime = false\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeIndex =\
    \ 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeCount\
    \ = 1\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 1\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 1\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 1\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorization\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp0_ajxyd7.swift:40:9: error: invalid redeclaration of 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n        ^\n/tmp/tmp0_ajxyd7.swift:37:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n        ^\n/tmp/tmp0_ajxyd7.swift:41:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 1\n        ^\n/tmp/tmp0_ajxyd7.swift:38:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 1\n        ^\n/tmp/tmp0_ajxyd7.swift:42:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n        ^\n/tmp/tmp0_ajxyd7.swift:39:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n        ^\n/tmp/tmp0_ajxyd7.swift:43:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n        ^\n/tmp/tmp0_ajxyd7.swift:37:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationIndex\
    \ = 0\n        ^\n/tmp/tmp0_ajxyd7.swift:44:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationPr"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var primeFactors\
    \ = [Int]()\n    var primeFactorsCount = 0\n    var isPrime = true\n    var isPrimeCount\
    \ = 0\n    var isPrimePrime = true\n    var isPrimePrimeCount = 0\n    var isPrimePrimePrime\
    \ = true\n    var isPrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrime =\
    \ true\n    var isPrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n \
    \   var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePri\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpfvk09q9t.swift:32:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpfvk09q9t.swift:30:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount' previously declared\
    \ here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n\
    /tmp/tmpfvk09q9t.swift:41:9: error: type annotation missing in pattern\n    var\
    \ isPrimePrimePrimePrimePri\n        ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var factorizationCount = 0\n    var currentFactorizationCount = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmps6qx_bv5.swift:16:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:17:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmps6qx_bv5.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:18:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmps6qx_bv5.swift:19:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:20:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmps6qx_bv5.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:21:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmps6qx_bv5.swift:22:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:23:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmps6qx_bv5.swift:15:9: note: 'currentFactorization' previously declar"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            factors.append(i)\n\
    \            n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n      \
    \  factors.append(n)\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpi1tj22_o.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    if n < 2 {\n        return []\n \
    \   }\n    var factorization = [Int]()\n    var factor = 2\n    var factorizationCount\
    \ = 0\n    while factor <= n {\n        if n % factor == 0 {\n            factorizationCount\
    \ += 1\n            factorization.append(factor)\n            n /= factor\n  \
    \      } else {\n            factor++\n        }\n    }\n    if n > 1 {\n    \
    \    factorizationCount += 1\n        factorization.append(n)\n    }\n    return\
    \ factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmphdrpzkvb.swift:22:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= factor\n            ~ ^\n\
    /tmp/tmphdrpzkvb.swift:24:19: error: cannot find operator '++' in scope; did you\
    \ mean '+= 1'?\n            factor++\n                  ^~\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    var factor = 1\n    var factorization = [1]\n    while i <= n {\n \
    \       if n % i == 0 {\n            factors.append(i)\n            factors.append(factor)\n\
    \            factors.append(factorization[0])\n            factorization[0]++\n\
    \            factor = 1\n        } else {\n            factor *= i\n         \
    \   factorization[0]++\n        }\n        i += 1\n    }\n    return factors\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpcnhwz3b9.swift:21:29: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            factorization[0]++\n                     \
    \       ^~\n/tmp/tmpcnhwz3b9.swift:25:29: error: cannot find operator '++' in\
    \ scope; did you mean '+= 1'?\n            factorization[0]++\n              \
    \              ^~\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var factorizationCount = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeCount\
    \ = [Int]()\n    var isPrimeIndex = [Int]()\n    var isPrimeIndexCount = [Int]()\n\
    \    var isPrimeIndexStart = [Int]()\n    var isPrimeIndexEnd = [Int]()\n    var\
    \ isPrimeIndexStartCount = [Int]()\n    var isPrimeIndexEndCount = [Int]()\n \
    \   var isPrimeIndexStartPrime = [Int]()\n    var isPrimeIndexEndPrime = [Int]()\n\
    \    var isPrimeIndexStartPrimeCount = [Int]()\n    var isPrimeIndexEndPrimeCount\
    \ = [Int]()\n    var isPrimeIndexStartPrimePrime = [Int]()\n    var isPrimeIndexEndPrimePrime\
    \ = [Int]()\n    var isPrimeIndexStartPrimePrimeCount = [Int]()\n    var isPrimeIndexEndPrimePrimeCount\
    \ = [Int]()\n    var isPrimeIndexStartPrimePrimePrimeCount = [Int]()\n    var\
    \ isPrimeIndexEndPrimePrimeCount = [Int]()\n    var isPrimeIndexStartPrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimeIndexEndPrimePrimeCount = [Int]()\n    var isPrimeIndexStartPrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimeIndexEndPrimePrimeCount = [Int]()\n    var isPrimeIndexStartPrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimeIndexEndPrimePrimeCount = [Int]()\n    var isPrimeIndexStartPrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimeIndexEndPrimePrimeCount = [Int]()\n    var isPrimeIndexStartPrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimeIndexEndPrimePrimeCount = [Int]()\n    var isPrimeIndexStartPrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimeIndexEndPrimePrimeCount = [Int]()\n    var isPrimeIndexStartPrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimeIndexEndPrimePrimeCount = [Int]()\n    var isPrimeIndexStartPrimePrimePrimeCount\
    \ = [Int]()\n    var isPri\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp7axghcl8.swift:31:9: error: invalid redeclaration of 'isPrimeIndexEndPrimePrimeCount'\n\
    \    var isPrimeIndexEndPrimePrimeCount = [Int]()\n        ^\n/tmp/tmp7axghcl8.swift:29:9:\
    \ note: 'isPrimeIndexEndPrimePrimeCount' previously declared here\n    var isPrimeIndexEndPrimePrimeCount\
    \ = [Int]()\n        ^\n/tmp/tmp7axghcl8.swift:32:9: error: invalid redeclaration\
    \ of 'isPrimeIndexStartPrimePrimePrimeCount'\n    var isPrimeIndexStartPrimePrimePrimeCount\
    \ = [Int]()\n        ^\n/tmp/tmp7axghcl8.swift:30:9: note: 'isPrimeIndexStartPrimePrimePrimeCount'\
    \ previously declared here\n    var isPrimeIndexStartPrimePrimePrimeCount = [Int]()\n\
    \        ^\n/tmp/tmp7axghcl8.swift:33:9: error: invalid redeclaration of 'isPrimeIndexEndPrimePrimeCount'\n\
    \    var isPrimeIndexEndPrimePrimeCount = [Int]()\n        ^\n/tmp/tmp7axghcl8.swift:29:9:\
    \ note: 'isPrimeIndexEndPrimePrimeCount' previously declared here\n    var isPrimeIndexEndPrimePrimeCount\
    \ = [Int]()\n        ^\n/tmp/tmp7axghcl8.swift:34:9: error: invalid redeclaration\
    \ of 'isPrimeIndexStartPrimePrimePrimeCount'\n    var isPrimeIndexStartPrimePrimePrimeCount\
    \ = [Int]()\n        ^\n/tmp/tmp7axghcl8.swift:30:9: note: 'isPrimeIndexStartPrimePrimePrimeCount'\
    \ previously declared here\n    var isPrimeIndexStartPrimePrimePrimeCount = [Int]()\n\
    \        ^\n/tmp/tmp7axghcl8.swift:35:9: error: invalid redeclaration of 'isPrimeIndexEndPrimePrimeCount'\n\
    \    var isPrimeIndexEndPrimePrimeCount = [Int]()\n        ^\n/tmp/tmp7axghcl8.swift:29:9:\
    \ note: 'isPrimeIndexEndPrimePrimeCount' previously declared here\n    var isPrimeIndexEndPrimePrimeCount\
    \ = [Int]()\n        ^\n/tmp/tmp7axghcl8.swift:36:9: error: invalid redeclaration\
    \ of 'isPrimeIndexStartPrimePrimePrimeCount'\n    var isPrimeIndexStartPrimePrimePrimeCount\
    \ = [Int]()\n        ^\n/tmp/tmp7axghcl8.swift:30:9: note: 'isPrimeIndexStartPrimePrimePrimeCount'\
    \ previously declared here\n    var isPrimeIndexStartPrimePrimePrimeCount = [Int]()\n\
    \        ^\n/tmp/tmp7axghcl8.swift:37:9: error: invalid redeclaration of 'isPrimeIndexEndPrimePrimeCount'\n\
    \    var isPrimeIndexEndPrimePrimeCount ="
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var primeFactorization: [Int] = []\n    var primeFactorizationCount = 0\n\
    \    var isPrime = true\n    var isPrimeCount = 0\n    var isPrimePrime = true\n\
    \    var isPrimePrimeCount = 0\n    var isPrimePrimePrime = true\n    var isPrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount =\
    \ 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount =\
    \ 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePri\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpq9r7uwao.swift:32:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpq9r7uwao.swift:30:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount' previously declared\
    \ here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n\
    /tmp/tmpq9r7uwao.swift:41:9: error: type annotation missing in pattern\n    var\
    \ isPrimePrimePrimePrimePri\n        ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    var j = 1\n    var k = n\n\n    while i < k {\n        if n % i ==\
    \ 0 {\n            factors.append(i)\n            n /= i\n        } else {\n \
    \           i += 1\n        }\n    }\n\n    if n != 1 {\n        factors.append(n)\n\
    \    }\n\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp7y7ob7gg.swift:20:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var primeFactorization: [Int] = []\n    var isPrime: [Bool] = []\n    var\
    \ isPrimeCount: [Int] = []\n    var isPrimeCountMax: Int = 1\n    var isPrimeCountMaxIndex:\
    \ Int = 0\n    var isPrimeCountMaxIndex2: Int = 0\n    var isPrimeCountMaxIndex3:\
    \ Int = 0\n    var isPrimeCountMaxIndex4: Int = 0\n    var isPrimeCountMaxIndex5:\
    \ Int = 0\n    var isPrimeCountMaxIndex6: Int = 0\n    var isPrimeCountMaxIndex7:\
    \ Int = 0\n    var isPrimeCountMaxIndex8: Int = 0\n    var isPrimeCountMaxIndex9:\
    \ Int = 0\n    var isPrimeCountMaxIndex10: Int = 0\n    var isPrimeCountMaxIndex11:\
    \ Int = 0\n    var isPrimeCountMaxIndex12: Int = 0\n    var isPrimeCountMaxIndex13:\
    \ Int = 0\n    var isPrimeCountMaxIndex14: Int = 0\n    var isPrimeCountMaxIndex15:\
    \ Int = 0\n    var isPrimeCountMaxIndex16: Int = 0\n    var isPrimeCountMaxIndex17:\
    \ Int = 0\n    var isPrimeCountMaxIndex18: Int = 0\n    var isPrimeCountMaxIndex19:\
    \ Int = 0\n    var isPrimeCountMaxIndex20: Int = 0\n    var isPrimeCountMaxIndex21:\
    \ Int = 0\n    var isPrimeCountMaxIndex22: Int = 0\n    var isPrimeCountMaxIndex23:\
    \ Int = 0\n    var isPrimeCountMaxIndex24: Int = 0\n    var isPrimeCountMaxIndex25:\
    \ Int = 0\n    var isPrimeCountMaxIndex26: Int = 0\n    var isPrimeCountMaxIndex27:\
    \ Int = 0\n    var isPrimeCountMaxIndex28: Int = 0\n    var isPrimeCountMaxIndex29:\
    \ Int = 0\n    var isPrimeCountMaxIndex30: Int = 0\n    var isPrimeCountMaxIndex31:\
    \ Int = 0\n    var isPrimeCountMaxIndex32: Int = 0\n    var isPrimeCountMaxIndex33:\
    \ Int = 0\n    var isPrimeCountMaxIndex34: Int = 0\n    var isPrimeCountMaxIndex35:\
    \ Int = 0\n    var isPrimeCountMaxIndex36: Int = 0\n    var isPrimeCountMaxIndex37:\
    \ Int = 0\n    var isPrimeCountMaxIndex38: Int = 0\n    var isPrimeCountMaxIndex39:\
    \ Int = 0\n    var isPrimeCountMax\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpk_lksgz_.swift:56:9: error: type annotation missing in pattern\n\
    \    var isPrimeCountMax\n        ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var primeFactorization = [Int]()\n    var primeFactorizationCount = [Int]()\n\
    \    var isPrime = [Bool]()\n    var isPrimeCount = [Int]()\n    var isPrimeCountMax\
    \ = Int(arc4random_uniform(UInt32(UInt32.max)))\n    var isPrimeCountMin = Int(arc4random_uniform(UInt32(UInt32.min)))\n\
    \    var isPrimeCountMin2 = Int(arc4random_uniform(UInt32(UInt32.min)))\n    var\
    \ isPrimeCountMin3 = Int(arc4random_uniform(UInt32(UInt32.min)))\n    var isPrimeCountMin4\
    \ = Int(arc4random_uniform(UInt32(UInt32.min)))\n    var isPrimeCountMin5 = Int(arc4random_uniform(UInt32(UInt32.min)))\n\
    \    var isPrimeCountMin6 = Int(arc4random_uniform(UInt32(UInt32.min)))\n    var\
    \ isPrimeCountMin7 = Int(arc4random_uniform(UInt32(UInt32.min)))\n    var isPrimeCountMin8\
    \ = Int(arc4random_uniform(UInt32(UInt32.min)))\n    var isPrimeCountMin9 = Int(arc4random_uniform(UInt32(UInt32.min)))\n\
    \    var isPrimeCountMin10 = Int(arc4random_uniform(UInt32(UInt32.min)))\n   \
    \ var isPrimeCountMin11 = Int(arc4random_uniform(UInt32(UInt32.min)))\n    var\
    \ isPrimeCountMin12 = Int(arc4random_uniform(UInt32(UInt32.min)))\n    var isPrimeCountMin13\
    \ = Int(arc4random_uniform(UInt32(UInt32.min)))\n    var isPrimeCountMin14 = Int(arc4random_uniform(UInt32(UInt32.min)))\n\
    \    var isPrimeCountMin15 = Int(arc4random_uniform(UInt32(UInt32.min)))\n   \
    \ var isPrimeCountMin16 = Int(arc4random_uniform(UInt32(UInt32.min)))\n    var\
    \ isPrimeCountMin17 = Int(arc4random_uniform(UInt32(UInt32.min)))\n    var isPrimeCountMin18\
    \ = Int(arc4random_uniform(UInt32(UInt32.min)))\n    var isPrimeCountMin19 = Int(arc4random_uniform(UInt32(UInt32.min)))\n\
    \    var isPrimeCountMin20 = Int(arc4random_uniform(UInt32(UInt32.min)))\n   \
    \ var isPrimeCountMin21 = Int(arc4random_uniform(UInt32(UInt32.min)))\n    var\
    \ isPrimeCountMin22 = Int(arc4random_uniform(UInt32(UInt\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpvw52ni57.swift:40:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpvw52ni57.swift:39:58: note: to match this opening '('\n    var isPrimeCountMin22\
    \ = Int(arc4random_uniform(UInt32(UInt\n                                     \
    \                    ^\n/tmp/tmpvw52ni57.swift:17:31: error: cannot find 'arc4random_uniform'\
    \ in scope\n    var isPrimeCountMax = Int(arc4random_uniform(UInt32(UInt32.max)))\n\
    \                              ^~~~~~~~~~~~~~~~~~\n/tmp/tmpvw52ni57.swift:18:31:\
    \ error: cannot find 'arc4random_uniform' in scope\n    var isPrimeCountMin =\
    \ Int(arc4random_uniform(UInt32(UInt32.min)))\n                              ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpvw52ni57.swift:19:32: error: cannot find 'arc4random_uniform' in scope\n\
    \    var isPrimeCountMin2 = Int(arc4random_uniform(UInt32(UInt32.min)))\n    \
    \                           ^~~~~~~~~~~~~~~~~~\n/tmp/tmpvw52ni57.swift:20:32:\
    \ error: cannot find 'arc4random_uniform' in scope\n    var isPrimeCountMin3 =\
    \ Int(arc4random_uniform(UInt32(UInt32.min)))\n                              \
    \ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpvw52ni57.swift:21:32: error: cannot find 'arc4random_uniform'\
    \ in scope\n    var isPrimeCountMin4 = Int(arc4random_uniform(UInt32(UInt32.min)))\n\
    \                               ^~~~~~~~~~~~~~~~~~\n/tmp/tmpvw52ni57.swift:22:32:\
    \ error: cannot find 'arc4random_uniform' in scope\n    var isPrimeCountMin5 =\
    \ Int(arc4random_uniform(UInt32(UInt32.min)))\n                              \
    \ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpvw52ni57.swift:23:32: error: cannot find 'arc4random_uniform'\
    \ in scope\n    var isPrimeCountMin6 = Int(arc4random_uniform(UInt32(UInt32.min)))\n\
    \                               ^~~~~~~~~~~~~~~~~~\n/tmp/tmpvw52ni57.swift:24:32:\
    \ error: cannot find 'arc4random_uniform' in scope\n    var isPrimeCountMin7 =\
    \ Int(arc4random_uniform(UInt32(UInt32.min)))\n                              \
    \ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpvw52ni57.swift:25:32: error: cannot find 'arc4random_uniform'\
    \ in scope\n    var isPrimeCountMin8 = Int(arc4random_uniform(UInt32(UInt32.min)))\n\
    \                               ^~~~~~~~~~~~~~~"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var primes\
    \ = [Int]()\n    var maxFactor = Int(sqrt(Double(n)))\n    var maxPrime = Int(sqrt(Double(n)))\n\
    \    var maxPrimeIndex = -1\n    var maxPrimeFactor = Int(sqrt(Double(n)))\n \
    \   var maxPrimeFactorIndex = -1\n    var maxPrimeFactorIndex = -1\n    var maxPrimeFactorIndex\
    \ = -1\n    var maxPrimeFactorIndex = -1\n    var maxPrimeFactorIndex = -1\n \
    \   var maxPrimeFactorIndex = -1\n    var maxPrimeFactorIndex = -1\n    var maxPrimeFactorIndex\
    \ = -1\n    var maxPrimeFactorIndex = -1\n    var maxPrimeFactorIndex = -1\n \
    \   var maxPrimeFactorIndex = -1\n    var maxPrimeFactorIndex = -1\n    var maxPrimeFactorIndex\
    \ = -1\n    var maxPrimeFactorIndex = -1\n    var maxPrimeFactorIndex = -1\n \
    \   var maxPrimeFactorIndex = -1\n    var maxPrimeFactorIndex = -1\n    var maxPrimeFactorIndex\
    \ = -1\n    var maxPrimeFactorIndex = -1\n    var maxPrimeFactorIndex = -1\n \
    \   var maxPrimeFactorIndex = -1\n    var maxPrimeFactorIndex = -1\n    var maxPrimeFactorIndex\
    \ = -1\n    var maxPrimeFactorIndex = -1\n    var maxPrimeFactorIndex = -1\n \
    \   var maxPrimeFactorIndex = -1\n    var maxPrimeFactorIndex = -1\n    var maxPrimeFactorIndex\
    \ = -1\n    var maxPrimeFactorIndex = -1\n    var maxPrimeFactorIndex = -1\n \
    \   var maxPrimeFactorIndex = -1\n    var maxPrimeFactorIndex = -1\n    var maxPrimeFactorIndex\
    \ = -1\n    var maxPrimeFactorIndex = -1\n    var maxPrimeFactorIndex = -1\n \
    \   var maxPrimeFactorIndex = -1\n    var maxPrimeFactorIndex = -1\n    var maxPrimeFactorIndex\
    \ = -1\n    var maxPrimeFactorIndex = -1\n    var maxPrimeFactorIndex = -1\n \
    \   var maxPrimeFactorIndex = -1\n    var maxPrimeFactorIndex = -1\n    var maxPrimeFactorIndex\
    \ = -1\n    var maxPrimeFactorIndex = -1\n    var maxPrimeFactorIndex = -1\n \
    \   var maxPrimeFactorIndex = -1\n    var maxPrimeFactorIndex = -1\n    var maxPrimeFactorIndex\
    \ = -1\n    var maxPrimeFactorIndex = -1\n    var maxPrimeFactorIndex = -1\n \
    \   var maxPrimeFactorIndex = -1\n    var maxPrimeFactorIndex = -1\n    var maxPrimeFactorIndex\
    \ = -1\n    var maxPrimeFactorIndex = -1\n    var maxPrimeFactorIndex = -1\n \
    \   var maxPrimeFactorIndex = -1\n    var maxPrimeFactorIndex = -1\n    var max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpawdikovq.swift:14:25: error: cannot find 'sqrt' in scope\n    var\
    \ maxFactor = Int(sqrt(Double(n)))\n                        ^~~~\n/tmp/tmpawdikovq.swift:15:24:\
    \ error: cannot find 'sqrt' in scope\n    var maxPrime = Int(sqrt(Double(n)))\n\
    \                       ^~~~\n/tmp/tmpawdikovq.swift:17:30: error: cannot find\
    \ 'sqrt' in scope\n    var maxPrimeFactor = Int(sqrt(Double(n)))\n           \
    \                  ^~~~\n/tmp/tmpawdikovq.swift:19:9: error: invalid redeclaration\
    \ of 'maxPrimeFactorIndex'\n    var maxPrimeFactorIndex = -1\n        ^\n/tmp/tmpawdikovq.swift:18:9:\
    \ note: 'maxPrimeFactorIndex' previously declared here\n    var maxPrimeFactorIndex\
    \ = -1\n        ^\n/tmp/tmpawdikovq.swift:20:9: error: invalid redeclaration of\
    \ 'maxPrimeFactorIndex'\n    var maxPrimeFactorIndex = -1\n        ^\n/tmp/tmpawdikovq.swift:18:9:\
    \ note: 'maxPrimeFactorIndex' previously declared here\n    var maxPrimeFactorIndex\
    \ = -1\n        ^\n/tmp/tmpawdikovq.swift:21:9: error: invalid redeclaration of\
    \ 'maxPrimeFactorIndex'\n    var maxPrimeFactorIndex = -1\n        ^\n/tmp/tmpawdikovq.swift:18:9:\
    \ note: 'maxPrimeFactorIndex' previously declared here\n    var maxPrimeFactorIndex\
    \ = -1\n        ^\n/tmp/tmpawdikovq.swift:22:9: error: invalid redeclaration of\
    \ 'maxPrimeFactorIndex'\n    var maxPrimeFactorIndex = -1\n        ^\n/tmp/tmpawdikovq.swift:18:9:\
    \ note: 'maxPrimeFactorIndex' previously declared here\n    var maxPrimeFactorIndex\
    \ = -1\n        ^\n/tmp/tmpawdikovq.swift:23:9: error: invalid redeclaration of\
    \ 'maxPrimeFactorIndex'\n    var maxPrimeFactorIndex = -1\n        ^\n/tmp/tmpawdikovq.swift:18:9:\
    \ note: 'maxPrimeFactorIndex' previously declared here\n    var maxPrimeFactorIndex\
    \ = -1\n        ^\n/tmp/tmpawdikovq.swift:24:9: error: invalid redeclaration of\
    \ 'maxPrimeFactorIndex'\n    var maxPrimeFactorIndex = -1\n        ^\n/tmp/tmpawdikovq.swift:18:9:\
    \ note: 'maxPrimeFactorIndex' previously declared here\n    var maxPrimeFactorIndex\
    \ = -1\n        ^\n/tmp/tmpawdikovq.swift:25:9: error: invalid redeclaration of\
    \ 'maxPrimeFactorIndex'\n    var maxPrimeFactorIndex = -1\n        ^\n/tm"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    var p = 2\n    while i <= n {\n        while n % i == 0 {\n       \
    \     factors.append(i)\n            n /= i\n        }\n        i += 1\n    }\n\
    \    if n > 1 {\n        factors.append(n)\n    }\n    return factors\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp_2qtdo69.swift:18:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            factors.append(i)\n\
    \            n /= i\n        } else {\n            i += 1\n        }\n    }\n\
    \    if n > 1 {\n        factors.append(n)\n    }\n    return factors\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpv1s4fi4v.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var factorizationCount = 0\n    var isPrime = true\n    var isPrimeCount =\
    \ 0\n    var isPrimeDivisor = true\n    var isPrimeDivisorCount = 0\n    var isPrimeDivisorDivisor\
    \ = true\n    var isPrimeDivisorDivisorCount = 0\n    var isPrimeDivisorDivisorDivisor\
    \ = true\n    var isPrimeDivisorDivisorDivisorCount = 0\n    var isPrimeDivisorDivisorDivisorDivisor\
    \ = true\n    var isPrimeDivisorDivisorDivisorDivisorCount = 0\n    var isPrimeDivisorDivisorDivisorDivisorDivisor\
    \ = true\n    var isPrimeDivisorDivisorDivisorDivisorDivisorCount = 0\n    var\
    \ isPrimeDivisorDivisorDivisorDivisorDivisorDivisor = true\n    var isPrimeDivisorDivisorDivisorDivisorDivisorDivisorCount\
    \ = 0\n    var isPrimeDivisorDivisorDivisorDivisorDivisorDivisorDivisor = true\n\
    \    var isPrimeDivisorDivisorDivisorDivisorDivisorDivisorDivisorCount = 0\n \
    \   var isPrimeDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisor = true\n\
    \    var isPrimeDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorCount\
    \ = 0\n    var isPrimeDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisor\
    \ = true\n    var isPrimeDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorCount\
    \ = 0\n    var isPrimeDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisor\
    \ = true\n    var isPrimeDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorCount\
    \ = 0\n    var isPrimeDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisor\
    \ = true\n    var isPrimeDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorCount\
    \ = 0\n    var isPrimeDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisor\
    \ = true\n    var isPrimeDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorCount\
    \ = 0\n    var isPrimeDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisor\
    \ = true\n    var isPrimeDivisorDivisorDivisor\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp8j6i_wj2.swift:34:9: error: invalid redeclaration of 'isPrimeDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisor'\n\
    \    var isPrimeDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisor\
    \ = true\n        ^\n/tmp/tmp8j6i_wj2.swift:32:9: note: 'isPrimeDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisor'\
    \ previously declared here\n    var isPrimeDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisor\
    \ = true\n        ^\n/tmp/tmp8j6i_wj2.swift:35:9: error: invalid redeclaration\
    \ of 'isPrimeDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorCount'\n\
    \    var isPrimeDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorCount\
    \ = 0\n        ^\n/tmp/tmp8j6i_wj2.swift:33:9: note: 'isPrimeDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorCount'\
    \ previously declared here\n    var isPrimeDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorCount\
    \ = 0\n        ^\n/tmp/tmp8j6i_wj2.swift:37:9: error: invalid redeclaration of\
    \ 'isPrimeDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorCount'\n\
    \    var isPrimeDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorCount\
    \ = 0\n        ^\n/tmp/tmp8j6i_wj2.swift:33:9: note: 'isPrimeDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorCount'\
    \ previously declared here\n    var isPrimeDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorCount\
    \ = 0\n        ^\n/tmp/tmp8j6i_wj2.swift:38:9: error: invalid redeclaration of\
    \ 'isPrimeDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisor'\n\
    \    var isPrimeDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisor\
    \ = true\n        ^\n/tmp/tmp8j6i_wj2.swift:36:9: note: 'isPrimeDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisor'\
    \ previously declared here\n    var isPrimeDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisor\
    \ = true\n        ^\n/tmp/tmp8j6i_wj2.swift:40:9: error: invalid redeclaration\
    \ of 'isPrimeDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisorDivisor'\n\
    \    var isPrime"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var factorizationCount = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeCount\
    \ = [Int]()\n    var isPrimeSum = [Int]()\n    var isPrimeSumCount = [Int]()\n\
    \    var isPrimeSumPrime = [Int]()\n    var isPrimeSumPrimeCount = [Int]()\n \
    \   var isPrimeSumPrimePrime = [Int]()\n    var isPrimeSumPrimePrimeCount = [Int]()\n\
    \    var isPrimeSumPrimePrimePrime = [Int]()\n    var isPrimeSumPrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimeSumPrimePrimePrimePrime = [Int]()\n    var isPrimeSumPrimePrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimeSumPrimePrimePrimePrimePrime = [Int]()\n    var isPrimeSumPrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimeSumPrimePrimePrimePrimePrimePrime = [Int]()\n    var\
    \ isPrimeSumPrimePrimePrimePrimePrimeCount = [Int]()\n    var isPrimeSumPrimePrimePrimePrimePrimePrime\
    \ = [Int]()\n    var isPrimeSumPrimePrimePrimePrimePrimePrimeCount = [Int]()\n\
    \    var isPrimeSumPrimePrimePrimePrimePrimePrimePrime = [Int]()\n    var isPrimeSumPrimePrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimeSumPrimePrimePrimePrimePrimePrimePrime = [Int]()\n\
    \    var isPrimeSumPrimePrimePrimePrimePrimePrimeCount = [Int]()\n    var isPrimeSumPrimePrimePrimePrimePrimePrimePrime\
    \ = [Int]()\n    var isPrimeSumPrimePrimePrimePrimePrimePrimeCount = [Int]()\n\
    \    var isPrimeSumPrimePrimePrimePrimePrimePrimePrime = [Int]()\n    var isPrimeSumPrimePrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimeSumPrimePrimePrimePrimePri\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp2xnww2xe.swift:29:9: error: invalid redeclaration of 'isPrimeSumPrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimeSumPrimePrimePrimePrimePrimeCount = [Int]()\n        ^\n/tmp/tmp2xnww2xe.swift:27:9:\
    \ note: 'isPrimeSumPrimePrimePrimePrimePrimeCount' previously declared here\n\
    \    var isPrimeSumPrimePrimePrimePrimePrimeCount = [Int]()\n        ^\n/tmp/tmp2xnww2xe.swift:30:9:\
    \ error: invalid redeclaration of 'isPrimeSumPrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimeSumPrimePrimePrimePrimePrimePrime = [Int]()\n        ^\n/tmp/tmp2xnww2xe.swift:28:9:\
    \ note: 'isPrimeSumPrimePrimePrimePrimePrimePrime' previously declared here\n\
    \    var isPrimeSumPrimePrimePrimePrimePrimePrime = [Int]()\n        ^\n/tmp/tmp2xnww2xe.swift:33:9:\
    \ error: invalid redeclaration of 'isPrimeSumPrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimeSumPrimePrimePrimePrimePrimePrimeCount = [Int]()\n        ^\n\
    /tmp/tmp2xnww2xe.swift:31:9: note: 'isPrimeSumPrimePrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n    var isPrimeSumPrimePrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n        ^\n/tmp/tmp2xnww2xe.swift:34:9: error: invalid redeclaration\
    \ of 'isPrimeSumPrimePrimePrimePrimePrimePrimePrime'\n    var isPrimeSumPrimePrimePrimePrimePrimePrimePrime\
    \ = [Int]()\n        ^\n/tmp/tmp2xnww2xe.swift:32:9: note: 'isPrimeSumPrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimeSumPrimePrimePrimePrimePrimePrimePrime\
    \ = [Int]()\n        ^\n/tmp/tmp2xnww2xe.swift:35:9: error: invalid redeclaration\
    \ of 'isPrimeSumPrimePrimePrimePrimePrimePrimeCount'\n    var isPrimeSumPrimePrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n        ^\n/tmp/tmp2xnww2xe.swift:31:9: note: 'isPrimeSumPrimePrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n    var isPrimeSumPrimePrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n        ^\n/tmp/tmp2xnww2xe.swift:36:9: error: invalid redeclaration\
    \ of 'isPrimeSumPrimePrimePrimePrimePrimePrimePrime'\n    var isPrimeSumPrimePrimePrimePrimePrimePrimePrime\
    \ = [Int]()\n        ^\n/tmp/tmp2xnww2xe.swift:32:9: note: 'isPrimeSumPrimePrimePrimePrimePrimePrimePrim"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    var j = 1\n    var k = 0\n    var factor = 1\n    while i <= n {\n\
    \        while n % i == 0 {\n            factors.append(i)\n            n /= i\n\
    \        }\n        i += 1\n    }\n    while n > 1 {\n        k += 1\n       \
    \ while n % j == 0 {\n            factors.append(j)\n            n /= j\n    \
    \    }\n        j += 1\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpkeo8mrt8.swift:20:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n/tmp/tmpkeo8mrt8.swift:28:15:\
    \ error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n\
    \            n /= j\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var i = 2\n    while i < n {\n        if n % i == 0 {\n            factorization\
    \ = append(factorization, i)\n            n /= i\n        } else {\n         \
    \   i += 1\n        }\n    }\n    if n != 1 {\n        factorization = append(factorization,\
    \ n)\n    }\n    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpikqti92n.swift:16:29: error: cannot find 'append' in scope\n  \
    \          factorization = append(factorization, i)\n                        \
    \    ^~~~~~\n/tmp/tmpikqti92n.swift:17:15: error: left side of mutating operator\
    \ isn't mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n\
    /tmp/tmpikqti92n.swift:23:25: error: cannot find 'append' in scope\n        factorization\
    \ = append(factorization, n)\n                        ^~~~~~\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var primeFactorization: [Int] = []\n    var primeFactorizationCount = 0\n\
    \    var isPrime = true\n    var isPrimeCount = 0\n    var isPrimePrime = true\n\
    \    var isPrimePrimeCount = 0\n    var isPrimePrimePrime = true\n    var isPrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount =\
    \ 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount =\
    \ 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePri\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpq9r7uwao.swift:32:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpq9r7uwao.swift:30:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount' previously declared\
    \ here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n\
    /tmp/tmpq9r7uwao.swift:41:9: error: type annotation missing in pattern\n    var\
    \ isPrimePrimePrimePrimePri\n        ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            factors.append(i)\n\
    \            n /= i\n        } else {\n            i += 1\n        }\n    }\n\
    \    if n > 1 {\n        factors.append(n)\n    }\n    return factors\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpv1s4fi4v.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: -4
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    var factor = 1\n    while i <= n {\n        if n % i == 0 {\n     \
    \       factor *= i\n            factors.append(factor)\n            factor =\
    \ 1\n        }\n        i += 1\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmpp1jr8i6s/tmpp1jr8i6s.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b69afb55c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b69af84cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b69af84c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b69af84b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp1jr8i6s                        0x0000561bcbb0559f <unavailable> + 5535

    5    libc.so.6                          0x00002b69afd41460 __libc_start_main +
    245

    6    tmpp1jr8i6s                        0x0000561bcbb05119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var primeFactorization = [Int]()\n    var primeFactorizationIndex = 0\n    var\
    \ factorizationIndex = 0\n    var isPrime = true\n    var isPrimeIndex = -1\n\
    \    var isPrimeIndex2 = -1\n    var isPrimeIndex3 = -1\n    var isPrimeIndex4\
    \ = -1\n    var isPrimeIndex5 = -1\n    var isPrimeIndex6 = -1\n    var isPrimeIndex7\
    \ = -1\n    var isPrimeIndex8 = -1\n    var isPrimeIndex9 = -1\n    var isPrimeIndex10\
    \ = -1\n    var isPrimeIndex11 = -1\n    var isPrimeIndex12 = -1\n    var isPrimeIndex13\
    \ = -1\n    var isPrimeIndex14 = -1\n    var isPrimeIndex15 = -1\n    var isPrimeIndex16\
    \ = -1\n    var isPrimeIndex17 = -1\n    var isPrimeIndex18 = -1\n    var isPrimeIndex19\
    \ = -1\n    var isPrimeIndex20 = -1\n    var isPrimeIndex21 = -1\n    var isPrimeIndex22\
    \ = -1\n    var isPrimeIndex23 = -1\n    var isPrimeIndex24 = -1\n    var isPrimeIndex25\
    \ = -1\n    var isPrimeIndex26 = -1\n    var isPrimeIndex27 = -1\n    var isPrimeIndex28\
    \ = -1\n    var isPrimeIndex29 = -1\n    var isPrimeIndex30 = -1\n    var isPrimeIndex31\
    \ = -1\n    var isPrimeIndex32 = -1\n    var isPrimeIndex33 = -1\n    var isPrimeIndex34\
    \ = -1\n    var isPrimeIndex35 = -1\n    var isPrimeIndex36 = -1\n    var isPrimeIndex37\
    \ = -1\n    var isPrimeIndex38 = -1\n    var isPrimeIndex39 = -1\n    var isPrimeIndex40\
    \ = -1\n    var isPrimeIndex41 = -1\n    var isPrimeIndex42 = -1\n    var isPrimeIndex43\
    \ = -1\n    var isPrimeIndex44 = -1\n    var isPrimeIndex45 = -1\n    var isPrimeIndex46\
    \ = -1\n    var isPrimeIndex47 = -1\n    var isPrimeIndex48 = -1\n    var isPrimeIndex49\
    \ = -1\n    var isPrimeIndex50 = -1\n    var isPrimeIndex51 = -1\n    var isPrimeIndex52\
    \ = -1\n    var isPrimeIndex53 = -1\n    var isPrimeIndex54 = -1\n    var isPrimeIndex55\
    \ = -1\n    var isPrimeIndex56 = -1\n    var isPrimeIndex57 = -1\n    var isPrimeIndex58\
    \ = -1\n    var isPri\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp1vmfpjpe.swift:75:9: error: type annotation missing in pattern\n\
    \    var isPri\n        ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var i = 2\n    var factor = 1\n    while i <= n {\n        if n % i == 0 {\n\
    \            factorization[factor] = i\n            factor += 1\n            n\
    \ /= i\n        } else {\n            i += 1\n        }\n    }\n    factorization[factor]\
    \ = n\n    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp7i8pyxrc.swift:19:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    if n < 2 {\n        return []\n \
    \   }\n    var factors = [Int]()\n    var primes = primeFactors(n)\n    for prime\
    \ in primes {\n        if n % prime == 0 {\n            factors.append(prime)\n\
    \            n /= prime\n        }\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpp6nytz7s.swift:16:18: error: cannot find 'primeFactors' in scope\n\
    \    var primes = primeFactors(n)\n                 ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    var j = 1\n    while i * j <= n {\n        if n % i == 0 {\n      \
    \      factors.append(i)\n            n /= i\n        }\n        if n % j == 0\
    \ {\n            factors.append(j)\n            n /= j\n        }\n        i +=\
    \ 1\n        j += 1\n    }\n    if n != 1 {\n        factors.append(n)\n    }\n\
    \    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpgnue4fsk.swift:18:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n/tmp/tmpgnue4fsk.swift:22:15:\
    \ error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n\
    \            n /= j\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var factorization\
    \ = factorizationOfNumber(n)\n    for factor in factorization {\n        if factors.contains(factor)\
    \ {\n            factors[factor] += 1\n        } else {\n            factors.append(factor)\n\
    \        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp00xc2sbq.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var primes\
    \ = [Int]()\n    var primeFactors = [Int]()\n    var factorization = [Int]()\n\
    \    var primeFactorization = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeFactorization\
    \ = [Bool]()\n    var isPrimeFactorization2 = [Bool]()\n    var isPrimeFactorization3\
    \ = [Bool]()\n    var isPrimeFactorization4 = [Bool]()\n    var isPrimeFactorization5\
    \ = [Bool]()\n    var isPrimeFactorization6 = [Bool]()\n    var isPrimeFactorization7\
    \ = [Bool]()\n    var isPrimeFactorization8 = [Bool]()\n    var isPrimeFactorization9\
    \ = [Bool]()\n    var isPrimeFactorization10 = [Bool]()\n    var isPrimeFactorization11\
    \ = [Bool]()\n    var isPrimeFactorization12 = [Bool]()\n    var isPrimeFactorization13\
    \ = [Bool]()\n    var isPrimeFactorization14 = [Bool]()\n    var isPrimeFactorization15\
    \ = [Bool]()\n    var isPrimeFactorization16 = [Bool]()\n    var isPrimeFactorization17\
    \ = [Bool]()\n    var isPrimeFactorization18 = [Bool]()\n    var isPrimeFactorization19\
    \ = [Bool]()\n    var isPrimeFactorization20 = [Bool]()\n    var isPrimeFactorization21\
    \ = [Bool]()\n    var isPrimeFactorization22 = [Bool]()\n    var isPrimeFactorization23\
    \ = [Bool]()\n    var isPrimeFactorization24 = [Bool]()\n    var isPrimeFactorization25\
    \ = [Bool]()\n    var isPrimeFactorization26 = [Bool]()\n    var isPrimeFactorization27\
    \ = [Bool]()\n    var isPrimeFactorization28 = [Bool]()\n    var isPrimeFactorization29\
    \ = [Bool]()\n    var isPrimeFactorization30 = [Bool]()\n    var isPrimeFactorization31\
    \ = [Bool]()\n    var isPrimeFactorization32 = [Bool]()\n    var isPrimeFactorization33\
    \ = [Bool]()\n    var isPrimeFactorization34 = [Bool]()\n    var isPrimeFactorization35\
    \ = [Bool]()\n    var isPrimeFactorization36 = [Bool]()\n    var isPrimeFactorization37\
    \ = [Bool]()\n    var isPrimeFactorization38 = [Bool]()\n    var isPrimeFactorization39\
    \ = [\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: '/tmp/tmpb2cu2bg3.swift:57:1: error: expected expression in container literal

    }

    ^

    '
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var factorizationCount = 0\n    var factorizationIndex = 0\n    var factorizationNumber:\
    \ Int = 0\n    var factorizationNumberIndex = 0\n    var factorizationNumberIndex2\
    \ = 0\n    var factorizationNumberIndex3 = 0\n    var factorizationNumberIndex4\
    \ = 0\n    var factorizationNumberIndex5 = 0\n    var factorizationNumberIndex6\
    \ = 0\n    var factorizationNumberIndex7 = 0\n    var factorizationNumberIndex8\
    \ = 0\n    var factorizationNumberIndex9 = 0\n    var factorizationNumberIndex10\
    \ = 0\n    var factorizationNumberIndex11 = 0\n    var factorizationNumberIndex12\
    \ = 0\n    var factorizationNumberIndex13 = 0\n    var factorizationNumberIndex14\
    \ = 0\n    var factorizationNumberIndex15 = 0\n    var factorizationNumberIndex16\
    \ = 0\n    var factorizationNumberIndex17 = 0\n    var factorizationNumberIndex18\
    \ = 0\n    var factorizationNumberIndex19 = 0\n    var factorizationNumberIndex20\
    \ = 0\n    var factorizationNumberIndex21 = 0\n    var factorizationNumberIndex22\
    \ = 0\n    var factorizationNumberIndex23 = 0\n    var factorizationNumberIndex24\
    \ = 0\n    var factorizationNumberIndex25 = 0\n    var factorizationNumberIndex26\
    \ = 0\n    var factorizationNumberIndex27 = 0\n    var factorizationNumberIndex28\
    \ = 0\n    var factorizationNumberIndex29 = 0\n    var factorizationNumberIndex30\
    \ = 0\n    var factorizationNumberIndex31 = 0\n    var factorizationNumberIndex32\
    \ = 0\n    var factorizationNumberIndex33 = 0\n    var factorizationNumberIndex34\
    \ = 0\n    var factorizationNumberIndex35 = 0\n    var factorizationNumberIndex36\
    \ = 0\n    var factorizationNumberIndex37 = 0\n    var factorizationNumberIndex38\
    \ = 0\n    var factorizationNumberIndex39 = 0\n    var factorizationNumberIndex40\
    \ = 0\n    var factorizationNumberIndex41 = 0\n    var factorizationNumberIndex42\
    \ = 0\n    var factorizationNumberIndex43 = 0\n    var factorizationNumberIndex44\
    \ = 0\n    var factorizationNumberIndex45 = 0\n    var factorizationNumberIndex46\
    \ = 0\n    var factorizationNumberIndex47 = 0\n    var factorizationNumberIndex48\
    \ = 0\n    var factorizationNumberIndex49 = 0\n    var factorizationNumberIndex50\
    \ = 0\n    var factorizationNumberIndex51 = 0\n    var factorizationNumberIndex52\
    \ = 0\n    var factorizationNumberIndex53 = 0\n    var factorizationNumberIndex54\
    \ = 0\n    var factorizationNumberIndex55 = 0\n    var factorizationNumberIndex56\
    \ = 0\n    var factorizationNumberIndex57 = 0\n    var factorizationNumberIndex58\
    \ = 0\n    var factorizationNumberIndex59 = 0\n    var factorizationNumberIndex60\
    \ = 0\n    var factorizationNumberIndex61\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp_58fb99z.swift:76:9: error: type annotation missing in pattern\n\
    \    var factorizationNumberIndex61\n        ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var factorization\
    \ = factorizationOfNumber(n)\n    for factor in factorization {\n        if factors.contains(factor)\
    \ {\n            factors[factor] += 1\n        } else {\n            factors.append(factor)\n\
    \        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp00xc2sbq.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    var factor = 1\n    while i <= n {\n        while n % i == 0 {\n  \
    \          factors.append(factor)\n            n /= i\n            factor = 1\n\
    \        }\n        i += 1\n        factor *= i + 1\n    }\n    if n > 1 {\n \
    \       factors.append(factor)\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpason2t09.swift:18:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var primeFactorization: [Int] = []\n    var isPrime: [Bool] = []\n    var\
    \ isPrimeCount: [Int] = []\n    var isPrimeCountMax: Int = 1\n    var isPrimeCountMin:\
    \ Int = 1\n    var isPrimeCountMinMax: Int = 1\n    var isPrimeCountMinMaxMax:\
    \ Int = 1\n    var isPrimeCountMinMaxMaxMax: Int = 1\n    var isPrimeCountMinMaxMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMax: Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMax: Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n    var\
    \ isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n\
    \    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n    var\
    \ isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int\
    \ = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int\
    \ = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int\
    \ = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int\
    \ = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int\
    \ = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmppoky7qxc.swift:25:9: error: invalid redeclaration of 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMax'\n\
    \    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMax: Int = 1\n        ^\n/tmp/tmppoky7qxc.swift:24:9:\
    \ note: 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMax' previously declared here\n    var\
    \ isPrimeCountMinMaxMaxMaxMaxMaxMaxMax: Int = 1\n        ^\n/tmp/tmppoky7qxc.swift:28:9:\
    \ error: invalid redeclaration of 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax'\n\
    \    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n        ^\n/tmp/tmppoky7qxc.swift:27:9:\
    \ note: 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax' previously declared here\n\
    \    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n        ^\n/tmp/tmppoky7qxc.swift:30:9:\
    \ error: invalid redeclaration of 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax'\n\
    \    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n        ^\n/tmp/tmppoky7qxc.swift:29:9:\
    \ note: 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax' previously declared here\n\
    \    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n        ^\n/tmp/tmppoky7qxc.swift:33:9:\
    \ error: invalid redeclaration of 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax'\n\
    \    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n      \
    \  ^\n/tmp/tmppoky7qxc.swift:32:9: note: 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax'\
    \ previously declared here\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax:\
    \ Int = 1\n        ^\n/tmp/tmppoky7qxc.swift:34:9: error: invalid redeclaration\
    \ of 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax'\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax:\
    \ Int = 1\n        ^\n/tmp/tmppoky7qxc.swift:32:9: note: 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax'\
    \ previously declared here\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax:\
    \ Int = 1\n        ^\n/tmp/tmppoky7qxc.swift:37:9: error: invalid redeclaration\
    \ of 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax'\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax:\
    \ Int = 1\n        ^\n/tmp/tmppoky7qxc.swift:36:9"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var i = 2\n    var factor = 2\n    while i <= n {\n        while n % i ==\
    \ 0 {\n            factorization[factor] = i\n            n /= i\n           \
    \ factor++\n        }\n        i += 1\n    }\n    if n > 1 {\n        factorization[factor]\
    \ = n\n    }\n    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpj9bmitt0.swift:18:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n/tmp/tmpj9bmitt0.swift:19:19:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  factor++\n                  ^~\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var primes\
    \ = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeCount = [Int]()\n    var\
    \ isPrimeCountMax = Int()\n    var isPrimeCountMaxIndex = Int()\n    var isPrimeCountMaxValue\
    \ = Int()\n    var isPrimeCountMaxIndexValue = Int()\n    var isPrimeCountMaxValueIndex\
    \ = Int()\n    var isPrimeCountMaxValueValue = Int()\n    var isPrimeCountMaxValueIndexValue\
    \ = Int()\n    var isPrimeCountMaxValueValueIndex = Int()\n    var isPrimeCountMaxValueValueValue\
    \ = Int()\n    var isPrimeCountMaxValueIndexValueIndex = Int()\n    var isPrimeCountMaxValueValueValue\
    \ = Int()\n    var isPrimeCountMaxValueIndexValueValue = Int()\n    var isPrimeCountMaxValueValueIndexValue\
    \ = Int()\n    var isPrimeCountMaxValueValueIndexValueIndex = Int()\n    var isPrimeCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeCountMaxValueValueValueIndex = Int()\n    var isPrimeCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeCountMaxValueValueValueIndex = Int()\n    var isPrimeCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeCountMaxValueValueValueIndex = Int()\n    var isPrimeCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeCountMaxValueValueValueIndex = Int()\n    var isPrimeCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeCountMaxValueValueValueIndex = Int()\n    var isPrimeCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeCountMaxValueValueValueIndex = Int()\n    var isPrimeCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeCountMaxValueValueValueIndex = Int()\n    var isPrimeCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeCountMaxValueValueValueIndex = Int()\n    var isPrimeCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeCountMaxValueValueValueIndex = Int()\n    var isPrimeCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeCountMaxValueValueValueIndex = Int()\n    var isPrimeCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeCountMaxValueValueValueIndex = Int()\n    var isPrimeCountMaxValueValueValueIndex\
    \ = Int()\n    var isPrimeCountMaxValueValueValueIndex = Int()\n    var isPri\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpp1ri7z9o.swift:26:9: error: invalid redeclaration of 'isPrimeCountMaxValueValueValue'\n\
    \    var isPrimeCountMaxValueValueValue = Int()\n        ^\n/tmp/tmpp1ri7z9o.swift:24:9:\
    \ note: 'isPrimeCountMaxValueValueValue' previously declared here\n    var isPrimeCountMaxValueValueValue\
    \ = Int()\n        ^\n/tmp/tmpp1ri7z9o.swift:31:9: error: invalid redeclaration\
    \ of 'isPrimeCountMaxValueValueValueIndex'\n    var isPrimeCountMaxValueValueValueIndex\
    \ = Int()\n        ^\n/tmp/tmpp1ri7z9o.swift:30:9: note: 'isPrimeCountMaxValueValueValueIndex'\
    \ previously declared here\n    var isPrimeCountMaxValueValueValueIndex = Int()\n\
    \        ^\n/tmp/tmpp1ri7z9o.swift:32:9: error: invalid redeclaration of 'isPrimeCountMaxValueValueValueIndex'\n\
    \    var isPrimeCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmpp1ri7z9o.swift:30:9:\
    \ note: 'isPrimeCountMaxValueValueValueIndex' previously declared here\n    var\
    \ isPrimeCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmpp1ri7z9o.swift:33:9:\
    \ error: invalid redeclaration of 'isPrimeCountMaxValueValueValueIndex'\n    var\
    \ isPrimeCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmpp1ri7z9o.swift:30:9:\
    \ note: 'isPrimeCountMaxValueValueValueIndex' previously declared here\n    var\
    \ isPrimeCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmpp1ri7z9o.swift:34:9:\
    \ error: invalid redeclaration of 'isPrimeCountMaxValueValueValueIndex'\n    var\
    \ isPrimeCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmpp1ri7z9o.swift:30:9:\
    \ note: 'isPrimeCountMaxValueValueValueIndex' previously declared here\n    var\
    \ isPrimeCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmpp1ri7z9o.swift:35:9:\
    \ error: invalid redeclaration of 'isPrimeCountMaxValueValueValueIndex'\n    var\
    \ isPrimeCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmpp1ri7z9o.swift:30:9:\
    \ note: 'isPrimeCountMaxValueValueValueIndex' previously declared here\n    var\
    \ isPrimeCountMaxValueValueValueIndex = Int()\n        ^\n/tmp/tmpp1ri7z9o.swift:36:9:\
    \ error: invalid redeclaration of 'isPrimeCountMaxValueValueValueIndex'\n    var\
    \ isPrimeCountMaxValueValueValueIndex"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var primeFactorization = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeCount\
    \ = 0\n    var isPrimeSum = 0\n    var isPrimeSumCount = 0\n    var isPrimeSumCountMax\
    \ = 0\n    var isPrimeSumCountMaxCount = 0\n    var isPrimeSumCountMaxCountMax\
    \ = 0\n    var isPrimeSumCountMaxCountMax = 0\n    var isPrimeSumCountMaxCountMaxMax\
    \ = 0\n    var isPrimeSumCountMaxCountMaxMax = 0\n    var isPrimeSumCountMaxCountMaxMaxMax\
    \ = 0\n    var isPrimeSumCountMaxCountMaxMaxMax = 0\n    var isPrimeSumCountMaxCountMaxMaxMax\
    \ = 0\n    var isPrimeSumCountMaxCountMaxMaxMax = 0\n    var isPrimeSumCountMaxCountMaxMaxMax\
    \ = 0\n    var isPrimeSumCountMaxCountMaxMaxMax = 0\n    var isPrimeSumCountMaxCountMaxMaxMax\
    \ = 0\n    var isPrimeSumCountMaxCountMaxMaxMax = 0\n    var isPrimeSumCountMaxCountMaxMaxMax\
    \ = 0\n    var isPrimeSumCountMaxCountMaxMaxMax = 0\n    var isPrimeSumCountMaxCountMaxMaxMax\
    \ = 0\n    var isPrimeSumCountMaxCountMaxMaxMax = 0\n    var isPrimeSumCountMaxCountMaxMaxMax\
    \ = 0\n    var isPrimeSumCountMaxCountMaxMaxMax = 0\n    var isPrimeSumCountMaxCountMaxMaxMax\
    \ = 0\n    var isPrimeSumCountMaxCountMaxMaxMax = 0\n    var isPrimeSumCountMaxCountMaxMaxMax\
    \ = 0\n    var isPrimeSumCountMaxCountMaxMaxMax = 0\n    var isPrimeSumCountMaxCountMaxMaxMax\
    \ = 0\n    var isPrimeSumCountMaxCountMaxMaxMax = 0\n    var isPrimeSumCountMaxCountMaxMaxMax\
    \ = 0\n    var isPrimeSumCountMaxCountMaxMaxMax = 0\n    var isPrimeSumCountMaxCountMaxMaxMax\
    \ = 0\n    var isPrimeSumCountMaxCountMaxMaxMax = 0\n    var isPrimeSumCountMaxCountMaxMaxMax\
    \ = 0\n    var isPrimeSumCountMaxCountMaxMaxMax = 0\n    var isPrimeSumCountMaxCountMaxMaxMax\
    \ = 0\n    var isPrimeSumCountMaxCountMaxMaxMax = 0\n    var isPrimeSumCountMaxCountMaxMaxMax\
    \ = 0\n    var isPrimeSumCountMaxCountMaxMaxMax = 0\n    var isPrimeSumCountMaxCountMax\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpuboc8yjy.swift:21:9: error: invalid redeclaration of 'isPrimeSumCountMaxCountMax'\n\
    \    var isPrimeSumCountMaxCountMax = 0\n        ^\n/tmp/tmpuboc8yjy.swift:20:9:\
    \ note: 'isPrimeSumCountMaxCountMax' previously declared here\n    var isPrimeSumCountMaxCountMax\
    \ = 0\n        ^\n/tmp/tmpuboc8yjy.swift:23:9: error: invalid redeclaration of\
    \ 'isPrimeSumCountMaxCountMaxMax'\n    var isPrimeSumCountMaxCountMaxMax = 0\n\
    \        ^\n/tmp/tmpuboc8yjy.swift:22:9: note: 'isPrimeSumCountMaxCountMaxMax'\
    \ previously declared here\n    var isPrimeSumCountMaxCountMaxMax = 0\n      \
    \  ^\n/tmp/tmpuboc8yjy.swift:25:9: error: invalid redeclaration of 'isPrimeSumCountMaxCountMaxMaxMax'\n\
    \    var isPrimeSumCountMaxCountMaxMaxMax = 0\n        ^\n/tmp/tmpuboc8yjy.swift:24:9:\
    \ note: 'isPrimeSumCountMaxCountMaxMaxMax' previously declared here\n    var isPrimeSumCountMaxCountMaxMaxMax\
    \ = 0\n        ^\n/tmp/tmpuboc8yjy.swift:26:9: error: invalid redeclaration of\
    \ 'isPrimeSumCountMaxCountMaxMaxMax'\n    var isPrimeSumCountMaxCountMaxMaxMax\
    \ = 0\n        ^\n/tmp/tmpuboc8yjy.swift:24:9: note: 'isPrimeSumCountMaxCountMaxMaxMax'\
    \ previously declared here\n    var isPrimeSumCountMaxCountMaxMaxMax = 0\n   \
    \     ^\n/tmp/tmpuboc8yjy.swift:27:9: error: invalid redeclaration of 'isPrimeSumCountMaxCountMaxMaxMax'\n\
    \    var isPrimeSumCountMaxCountMaxMaxMax = 0\n        ^\n/tmp/tmpuboc8yjy.swift:24:9:\
    \ note: 'isPrimeSumCountMaxCountMaxMaxMax' previously declared here\n    var isPrimeSumCountMaxCountMaxMaxMax\
    \ = 0\n        ^\n/tmp/tmpuboc8yjy.swift:28:9: error: invalid redeclaration of\
    \ 'isPrimeSumCountMaxCountMaxMaxMax'\n    var isPrimeSumCountMaxCountMaxMaxMax\
    \ = 0\n        ^\n/tmp/tmpuboc8yjy.swift:24:9: note: 'isPrimeSumCountMaxCountMaxMaxMax'\
    \ previously declared here\n    var isPrimeSumCountMaxCountMaxMaxMax = 0\n   \
    \     ^\n/tmp/tmpuboc8yjy.swift:29:9: error: invalid redeclaration of 'isPrimeSumCountMaxCountMaxMaxMax'\n\
    \    var isPrimeSumCountMaxCountMaxMaxMax = 0\n        ^\n/tmp/tmpuboc8yjy.swift:24:9:\
    \ note: 'isPrimeSumCountMaxCountMaxMaxMax' previously declared here\n    var isPrimeSumCountMaxCountM"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var primes = [Int]()\n    var primeFactorization = [Int]()\n    var isPrime\
    \ = [Bool]()\n    var isPrimeFactorization = [Bool]()\n    var isPrimeFactorizationInOrder\
    \ = [Bool]()\n    var isPrimeFactorizationInOrderInReverse = [Bool]()\n    var\
    \ isPrimeFactorizationInOrderInReverseInOrder = [Bool]()\n    var isPrimeFactorizationInOrderInReverseInOrderInReverse\
    \ = [Bool]()\n    var isPrimeFactorizationInOrderInReverseInOrderInReverseInOrder\
    \ = [Bool]()\n    var isPrimeFactorizationInOrderInReverseInOrderInReverseInOrderInReverse\
    \ = [Bool]()\n    var isPrimeFactorizationInOrderInReverseInOrderInReverseInOrderInReverseInOrder\
    \ = [Bool]()\n    var isPrimeFactorizationInOrderInReverseInOrderInReverseInOrderInReverseInOrderInReverse\
    \ = [Bool]()\n    var isPrimeFactorizationInOrderInReverseInOrderInReverseInOrderInReverseInOrderInReverseInOrder\
    \ = [Bool]()\n    var isPrimeFactorizationInOrderInReverseInOrderInReverseInOrderInReverseInOrderInReverseInOrderInReverse\
    \ = [Bool]()\n    var isPrimeFactorizationInOrderInReverseInOrderInReverseInOrderInReverseInOrderInReverseInOrderInReverseInOrder\
    \ = [Bool]()\n    var isPrimeFactorizationInOrderInReverseInOrderInReverseInOrderInReverseInOrderInReverseInOrderInReverseInOrderInReverse\
    \ = [Bool]()\n    var isPrimeFactorizationInOrderInReverseInOrderInReverseInOrderInReverseInOrderInReverseInOrderInReverseInOrderInReverseInOrder\
    \ = [Bool]()\n    var isPrimeFactorizationInOrderInReverseInOrderInReverseInOrderInReverseInOrderInReverseInOrderInReverseInOrderInReverseInOrderInReverse\
    \ = [Bool]()\n    var isPrimeFactorizationInOrderInReverseInOrderInReverseInOrderInReverseInOrderInReverseInOrderInReverseInOrderInReverseInOrderInReverseInOrder\
    \ = [Bool]()\n    var isPrimeFactorizationInOrderInReverseInOrderInReverseInOrderInReverseInOrderInReverseInOrderInReverseInOrderInReverseInOrderInReverseInOrderInReverse\
    \ = [Bool]()\n    var isPrimeFactorizationInOrderInReverseInOrderInReverseInOrderInReverseInOrder\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpbl30fowe.swift:33:9: error: type annotation missing in pattern\n\
    \    var isPrimeFactorizationInOrderInReverseInOrderInReverseInOrderInReverseInOrder\n\
    \        ^\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var factorizationCount = 0\n    var currentFactorizationCount = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmps6qx_bv5.swift:16:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:17:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmps6qx_bv5.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:18:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmps6qx_bv5.swift:19:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:20:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmps6qx_bv5.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:21:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmps6qx_bv5.swift:22:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:23:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmps6qx_bv5.swift:15:9: note: 'currentFactorization' previously declar"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var factorization\
    \ = factorizationOfNumber(n)\n    for factor in factorization {\n        if factors.contains(factor)\
    \ {\n            factors[factor] += 1\n        } else {\n            factors.append(factor)\n\
    \        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp00xc2sbq.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var factorizationCount = 0\n    var currentFactorizationCount = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmps6qx_bv5.swift:16:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:17:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmps6qx_bv5.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:18:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmps6qx_bv5.swift:19:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:20:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmps6qx_bv5.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:21:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmps6qx_bv5.swift:22:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:23:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmps6qx_bv5.swift:15:9: note: 'currentFactorization' previously declar"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var factorization\
    \ = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeCount = 0\n    var isPrimeSum\
    \ = 0\n    var isPrimeSumCount = 0\n    var isPrimeSumCountMax = 1000\n    var\
    \ isPrimeSumCountMaxInt = 1000\n    var isPrimeSumCountMaxIntInt = 1000\n    var\
    \ isPrimeSumCountMaxInt64 = 1000\n    var isPrimeSumCountMaxInt64Int = 1000\n\
    \    var isPrimeSumCountMaxInt6464 = 1000\n    var isPrimeSumCountMaxInt6464Int\
    \ = 1000\n    var isPrimeSumCountMaxInt646464 = 1000\n    var isPrimeSumCountMaxInt646464Int\
    \ = 1000\n    var isPrimeSumCountMaxInt646464Int = 1000\n    var isPrimeSumCountMaxInt646464Int\
    \ = 1000\n    var isPrimeSumCountMaxInt646464Int = 1000\n    var isPrimeSumCountMaxInt646464IntInt\
    \ = 1000\n    var isPrimeSumCountMaxInt646464IntIntInt = 1000\n    var isPrimeSumCountMaxInt646464IntIntIntInt\
    \ = 1000\n    var isPrimeSumCountMaxInt646464IntIntIntIntInt = 1000\n    var isPrimeSumCountMaxInt646464IntIntIntIntIntInt\
    \ = 1000\n    var isPrimeSumCountMaxInt646464IntIntIntIntIntIntInt = 1000\n  \
    \  var isPrimeSumCountMaxInt646464IntIntIntIntIntIntIntInt = 1000\n    var isPrimeSumCountMaxInt646464IntIntIntIntIntIntIntIntInt\
    \ = 1000\n    var isPrimeSumCountMaxInt646464IntIntIntIntIntIntIntIntIntInt =\
    \ 1000\n    var isPrimeSumCountMaxInt646464IntIntIntIntIntIntIntIntIntIntInt =\
    \ 1000\n    var isPrimeSumCountMaxInt646464IntIntIntIntIntIntIntIntIntIntIntInt\
    \ = 1000\n    var isPrimeSumCountMaxInt646464IntIntIntIntIntIntIntIntIntIntIntInt\
    \ = 1000\n    var isPrimeSumCountMaxInt646464IntIntIntIntIntIntIntIntIntIntIntIntInt\
    \ = 1000\n    var isPrimeSumCountMaxInt646464IntIntIntIntIntIntIntIntIntIntIntInt\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpo26pwqi0.swift:27:9: error: invalid redeclaration of 'isPrimeSumCountMaxInt646464Int'\n\
    \    var isPrimeSumCountMaxInt646464Int = 1000\n        ^\n/tmp/tmpo26pwqi0.swift:26:9:\
    \ note: 'isPrimeSumCountMaxInt646464Int' previously declared here\n    var isPrimeSumCountMaxInt646464Int\
    \ = 1000\n        ^\n/tmp/tmpo26pwqi0.swift:28:9: error: invalid redeclaration\
    \ of 'isPrimeSumCountMaxInt646464Int'\n    var isPrimeSumCountMaxInt646464Int\
    \ = 1000\n        ^\n/tmp/tmpo26pwqi0.swift:26:9: note: 'isPrimeSumCountMaxInt646464Int'\
    \ previously declared here\n    var isPrimeSumCountMaxInt646464Int = 1000\n  \
    \      ^\n/tmp/tmpo26pwqi0.swift:29:9: error: invalid redeclaration of 'isPrimeSumCountMaxInt646464Int'\n\
    \    var isPrimeSumCountMaxInt646464Int = 1000\n        ^\n/tmp/tmpo26pwqi0.swift:26:9:\
    \ note: 'isPrimeSumCountMaxInt646464Int' previously declared here\n    var isPrimeSumCountMaxInt646464Int\
    \ = 1000\n        ^\n/tmp/tmpo26pwqi0.swift:41:9: error: invalid redeclaration\
    \ of 'isPrimeSumCountMaxInt646464IntIntIntIntIntIntIntIntIntIntIntInt'\n    var\
    \ isPrimeSumCountMaxInt646464IntIntIntIntIntIntIntIntIntIntIntInt = 1000\n   \
    \     ^\n/tmp/tmpo26pwqi0.swift:40:9: note: 'isPrimeSumCountMaxInt646464IntIntIntIntIntIntIntIntIntIntIntInt'\
    \ previously declared here\n    var isPrimeSumCountMaxInt646464IntIntIntIntIntIntIntIntIntIntIntInt\
    \ = 1000\n        ^\n/tmp/tmpo26pwqi0.swift:43:9: error: type annotation missing\
    \ in pattern\n    var isPrimeSumCountMaxInt646464IntIntIntIntIntIntIntIntIntIntIntInt\n\
    \        ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    var factor = 1\n    while i < n {\n        if n % i == 0 {\n      \
    \      factor *= i\n            factors.append(factor)\n            n /= i\n \
    \       } else {\n            i += 1\n        }\n    }\n    if n > 1 {\n     \
    \   factors.append(n)\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp6ady9h6u.swift:19:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var factorizationCount = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeCount\
    \ = [Int]()\n    var isPrimeIndex = 0\n    var isPrimeIndexCount = 0\n    var\
    \ isPrimeIndexMax = 0\n    var isPrimeIndexMaxCount = 0\n    var isPrimeIndexMaxValue\
    \ = 0\n    var isPrimeIndexMaxValueCount = 0\n    var isPrimeIndexMaxValueIndex\
    \ = 0\n    var isPrimeIndexMaxValueIndexCount = 0\n    var isPrimeIndexMaxValueIndexMax\
    \ = 0\n    var isPrimeIndexMaxValueIndexMaxCount = 0\n    var isPrimeIndexMaxValueIndexMaxValue\
    \ = 0\n    var isPrimeIndexMaxValueIndexMaxValueCount = 0\n    var isPrimeIndexMaxValueIndexMaxValueIndex\
    \ = 0\n    var isPrimeIndexMaxValueIndexMaxValueIndexCount = 0\n    var isPrimeIndexMaxValueIndexMaxValueIndexMax\
    \ = 0\n    var isPrimeIndexMaxValueIndexMaxValueIndexMaxCount = 0\n    var isPrimeIndexMaxValueIndexMaxValueIndexMaxValue\
    \ = 0\n    var isPrimeIndexMaxValueIndexMaxValueIndexMaxValueCount = 0\n    var\
    \ isPrimeIndexMaxValueIndexMaxValueIndexMaxValueIndex = 0\n    var isPrimeIndexMaxValueIndexMaxValueIndexMaxValueIndexCount\
    \ = 0\n    var isPrimeIndexMaxValueIndexMaxValueIndexMaxValueIndexMax = 0\n  \
    \  var isPrimeIndexMaxValueIndexMaxValueIndexMaxValueIndexMaxCount = 0\n    var\
    \ isPrimeIndexMaxValueIndexMaxValueIndexMaxValueIndexMaxValue = 0\n    var isPrimeIndexMaxValueIndexMaxValueIndexMaxValueIndexMaxValueCount\
    \ = 0\n    var isPrimeIndexMaxValueIndexMaxValueIndexMaxValueIndexMaxValueIndex\
    \ = 0\n    var isPrimeIndexMaxValueIndexMaxValueIndexMaxValueIndexMaxValueIndexCount\
    \ = 0\n    var isPrimeIndexMaxValueIndexMaxValueIndexMaxValueIndexMaxValueIndexMaxValue\
    \ = 0\n    var isPrimeIndexMaxValueIndexMaxValueIndexMaxValueIndexMaxValueIndexMaxValueCount\
    \ = 0\n    var isPrimeIndexMaxValueIndexMaxValueIndexMaxValueIndexMaxValueIndexMaxValueIndex\
    \ = 0\n    var isPrimeIndexMaxValueIndexMaxValueIndexMaxValueIndexMaxValueIndexMaxValueIndexCount\
    \ = 0\n    var isPrimeIndexMaxValueIndexMaxValueIndexMaxValueIndexMaxValueIndexMaxValueIndexMaxValue\
    \ = 0\n    var isPrimeIndexMaxValueIndexMaxValueIndexMaxValue\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp6f6vv2it.swift:47:9: error: type annotation missing in pattern\n\
    \    var isPrimeIndexMaxValueIndexMaxValueIndexMaxValue\n        ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var factor = 2\n    while factor <= n {\n        if n % factor == 0 {\n  \
    \          factorization = factorization + [factor]\n            n /= factor\n\
    \        } else {\n            factor += 1\n        }\n    }\n    if n > 1 {\n\
    \        factorization = factorization + [n]\n    }\n    return factorization\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp2u1auhgu.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= factor\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var primeFactorization = [Int]()\n    var primeFactorizationCount = [Int]()\n\
    \    var factorizationCount = 0\n    var primeFactorizationCount = 0\n    var\
    \ isPrime = true\n    var isPrimeCount = 0\n    var isPrimePrime = true\n    var\
    \ isPrimePrimeCount = 0\n    var isPrimePrimePrime = true\n    var isPrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrime\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp7lltgj4q.swift:16:9: error: invalid redeclaration of 'primeFactorizationCount'\n\
    \    var primeFactorizationCount = 0\n        ^\n/tmp/tmp7lltgj4q.swift:14:9:\
    \ note: 'primeFactorizationCount' previously declared here\n    var primeFactorizationCount\
    \ = [Int]()\n        ^\n/tmp/tmp7lltgj4q.swift:42:9: error: type annotation missing\
    \ in pattern\n    var isPrimePrimePrime\n        ^\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var factorization\
    \ = factorizationOfNumber(n)\n    var factorizationCount = 1\n    for factor in\
    \ factorization {\n        if factorizationCount == 1 {\n            factors.append(factor)\n\
    \        } else {\n            if factor != 1 {\n                factors.append(factor)\n\
    \                factorizationCount *= factor\n            }\n        }\n    }\n\
    \    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmptc8riqrg.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var factorizationCount = [Int]()\n    var factorizationIndex = 0\n    var factorizationCount\
    \ = 1\n    var factorizationIndex = 0\n    var factorizationCount = 1\n    var\
    \ factorizationIndex = 0\n    var factorizationCount = 1\n    var factorizationIndex\
    \ = 0\n    var factorizationCount = 1\n    var factorizationIndex = 0\n    var\
    \ factorizationCount = 1\n    var factorizationIndex = 0\n    var factorizationCount\
    \ = 1\n    var factorizationIndex = 0\n    var factorizationCount = 1\n    var\
    \ factorizationIndex = 0\n    var factorizationCount = 1\n    var factorizationIndex\
    \ = 0\n    var factorizationCount = 1\n    var factorizationIndex = 0\n    var\
    \ factorizationCount = 1\n    var factorizationIndex = 0\n    var factorizationCount\
    \ = 1\n    var factorizationIndex = 0\n    var factorizationCount = 1\n    var\
    \ factorizationIndex = 0\n    var factorizationCount = 1\n    var factorizationIndex\
    \ = 0\n    var factorizationCount = 1\n    var factorizationIndex = 0\n    var\
    \ factorizationCount = 1\n    var factorizationIndex = 0\n    var factorizationCount\
    \ = 1\n    var factorizationIndex = 0\n    var factorizationCount = 1\n    var\
    \ factorizationIndex = 0\n    var factorizationCount = 1\n    var factorizationIndex\
    \ = 0\n    var factorizationCount = 1\n    var factorizationIndex = 0\n    var\
    \ factorizationCount = 1\n    var factorizationIndex = 0\n    var factorizationCount\
    \ = 1\n    var factorizationIndex = 0\n    var factorizationCount = 1\n    var\
    \ factorizationIndex = 0\n    var factorizationCount = 1\n    var factorizationIndex\
    \ = 0\n    var factorizationCount = 1\n    var factorizationIndex = 0\n    var\
    \ factorizationCount = 1\n    var factorizationIndex = 0\n    var factorizationCount\
    \ = 1\n    var factorizationIndex = 0\n    var factorizationCount = 1\n    var\
    \ factorizationIndex = 0\n    var factorizationCount = 1\n    var factorizationIndex\
    \ = 0\n    var factorizationCount = 1\n    var factorizationIndex = 0\n    var\
    \ factorizationCount = 1\n    var factorizationIndex = 0\n    var factorizationCount\
    \ = 1\n    var factorizationIndex = 0\n    var factorizationCount = 1\n    var\
    \ factorizationIndex = 0\n    var factorizationCount = 1\n    var factorizationIndex\
    \ = 0\n    var factorizationCount = 1\n    var factorizationIndex = 0\n    var\
    \ factorizationCount = 1\n    var factorizationIndex = 0\n    var factorizationCount\
    \ = 1\n    var factorizationIndex = 0\n    var factorizationCount = 1\n    var\
    \ factorizationIndex = 0\n    var factorizationCount = 1\n    var factorizationIndex\
    \ = 0\n    var factorizationCount = 1\n    var factorizationIndex = 0\n    var\
    \ factorizationCount = 1\n    var factorizationIndex = 0\n    var factorizationCount\
    \ = 1\n    var factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpe88hawui.swift:15:9: error: invalid redeclaration of 'factorizationCount'\n\
    \    var factorizationCount = 1\n        ^\n/tmp/tmpe88hawui.swift:13:9: note:\
    \ 'factorizationCount' previously declared here\n    var factorizationCount =\
    \ [Int]()\n        ^\n/tmp/tmpe88hawui.swift:16:9: error: invalid redeclaration\
    \ of 'factorizationIndex'\n    var factorizationIndex = 0\n        ^\n/tmp/tmpe88hawui.swift:14:9:\
    \ note: 'factorizationIndex' previously declared here\n    var factorizationIndex\
    \ = 0\n        ^\n/tmp/tmpe88hawui.swift:17:9: error: invalid redeclaration of\
    \ 'factorizationCount'\n    var factorizationCount = 1\n        ^\n/tmp/tmpe88hawui.swift:13:9:\
    \ note: 'factorizationCount' previously declared here\n    var factorizationCount\
    \ = [Int]()\n        ^\n/tmp/tmpe88hawui.swift:18:9: error: invalid redeclaration\
    \ of 'factorizationIndex'\n    var factorizationIndex = 0\n        ^\n/tmp/tmpe88hawui.swift:14:9:\
    \ note: 'factorizationIndex' previously declared here\n    var factorizationIndex\
    \ = 0\n        ^\n/tmp/tmpe88hawui.swift:19:9: error: invalid redeclaration of\
    \ 'factorizationCount'\n    var factorizationCount = 1\n        ^\n/tmp/tmpe88hawui.swift:13:9:\
    \ note: 'factorizationCount' previously declared here\n    var factorizationCount\
    \ = [Int]()\n        ^\n/tmp/tmpe88hawui.swift:20:9: error: invalid redeclaration\
    \ of 'factorizationIndex'\n    var factorizationIndex = 0\n        ^\n/tmp/tmpe88hawui.swift:14:9:\
    \ note: 'factorizationIndex' previously declared here\n    var factorizationIndex\
    \ = 0\n        ^\n/tmp/tmpe88hawui.swift:21:9: error: invalid redeclaration of\
    \ 'factorizationCount'\n    var factorizationCount = 1\n        ^\n/tmp/tmpe88hawui.swift:13:9:\
    \ note: 'factorizationCount' previously declared here\n    var factorizationCount\
    \ = [Int]()\n        ^\n/tmp/tmpe88hawui.swift:22:9: error: invalid redeclaration\
    \ of 'factorizationIndex'\n    var factorizationIndex = 0\n        ^\n/tmp/tmpe88hawui.swift:14:9:\
    \ note: 'factorizationIndex' previously declared here\n    var factorizationIndex\
    \ = 0\n        ^\n/tmp/tmpe88hawui.swift:23:9: error: invalid redeclaration of\
    \ 'fa"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var factorizationCount = 0\n    var currentFactorizationCount = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmps6qx_bv5.swift:16:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:17:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmps6qx_bv5.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:18:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmps6qx_bv5.swift:19:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:20:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmps6qx_bv5.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:21:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmps6qx_bv5.swift:22:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:23:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmps6qx_bv5.swift:15:9: note: 'currentFactorization' previously declar"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var factorizationCount = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeCount\
    \ = [Int]()\n    var isPrimeSum = [Int]()\n    var isPrimeSumCount = [Int]()\n\
    \    var isPrimeSumPrime = [Int]()\n    var isPrimeSumPrimeCount = [Int]()\n \
    \   var isPrimeSumPrimePrime = [Int]()\n    var isPrimeSumPrimePrimeCount = [Int]()\n\
    \    var isPrimeSumPrimePrimePrime = [Int]()\n    var isPrimeSumPrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimeSumPrimePrimePrimePrime = [Int]()\n    var isPrimeSumPrimePrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimeSumPrimePrimePrimePrimePrime = [Int]()\n    var isPrimeSumPrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimeSumPrimePrimePrimePrimePrimePrime = [Int]()\n    var\
    \ isPrimeSumPrimePrimePrimePrimePrimeCount = [Int]()\n    var isPrimeSumPrimePrimePrimePrimePrimePrime\
    \ = [Int]()\n    var isPrimeSumPrimePrimePrimePrimePrimePrimeCount = [Int]()\n\
    \    var isPrimeSumPrimePrimePrimePrimePrimePrimePrime = [Int]()\n    var isPrimeSumPrimePrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimeSumPrimePrimePrimePrimePrimePrimePrime = [Int]()\n\
    \    var isPrimeSumPrimePrimePrimePrimePrimePrimeCount = [Int]()\n    var isPrimeSumPrimePrimePrimePrimePrimePrimePrime\
    \ = [Int]()\n    var isPrimeSumPrimePrimePrimePrimePrimePrimeCount = [Int]()\n\
    \    var isPrimeSumPrimePrimePrimePrimePrimePrimePrime = [Int]()\n    var isPrimeSumPrimePrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimeSumPrimePrimePrimePrimePri\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp2xnww2xe.swift:29:9: error: invalid redeclaration of 'isPrimeSumPrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimeSumPrimePrimePrimePrimePrimeCount = [Int]()\n        ^\n/tmp/tmp2xnww2xe.swift:27:9:\
    \ note: 'isPrimeSumPrimePrimePrimePrimePrimeCount' previously declared here\n\
    \    var isPrimeSumPrimePrimePrimePrimePrimeCount = [Int]()\n        ^\n/tmp/tmp2xnww2xe.swift:30:9:\
    \ error: invalid redeclaration of 'isPrimeSumPrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimeSumPrimePrimePrimePrimePrimePrime = [Int]()\n        ^\n/tmp/tmp2xnww2xe.swift:28:9:\
    \ note: 'isPrimeSumPrimePrimePrimePrimePrimePrime' previously declared here\n\
    \    var isPrimeSumPrimePrimePrimePrimePrimePrime = [Int]()\n        ^\n/tmp/tmp2xnww2xe.swift:33:9:\
    \ error: invalid redeclaration of 'isPrimeSumPrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimeSumPrimePrimePrimePrimePrimePrimeCount = [Int]()\n        ^\n\
    /tmp/tmp2xnww2xe.swift:31:9: note: 'isPrimeSumPrimePrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n    var isPrimeSumPrimePrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n        ^\n/tmp/tmp2xnww2xe.swift:34:9: error: invalid redeclaration\
    \ of 'isPrimeSumPrimePrimePrimePrimePrimePrimePrime'\n    var isPrimeSumPrimePrimePrimePrimePrimePrimePrime\
    \ = [Int]()\n        ^\n/tmp/tmp2xnww2xe.swift:32:9: note: 'isPrimeSumPrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimeSumPrimePrimePrimePrimePrimePrimePrime\
    \ = [Int]()\n        ^\n/tmp/tmp2xnww2xe.swift:35:9: error: invalid redeclaration\
    \ of 'isPrimeSumPrimePrimePrimePrimePrimePrimeCount'\n    var isPrimeSumPrimePrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n        ^\n/tmp/tmp2xnww2xe.swift:31:9: note: 'isPrimeSumPrimePrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n    var isPrimeSumPrimePrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n        ^\n/tmp/tmp2xnww2xe.swift:36:9: error: invalid redeclaration\
    \ of 'isPrimeSumPrimePrimePrimePrimePrimePrimePrime'\n    var isPrimeSumPrimePrimePrimePrimePrimePrimePrime\
    \ = [Int]()\n        ^\n/tmp/tmp2xnww2xe.swift:32:9: note: 'isPrimeSumPrimePrimePrimePrimePrimePrimePrim"
  stdout: ''
  timestamp: 1659824951
- exit_code: -4
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            i += 1\n \
    \           factors.append(i)\n        }\n    }\n    return factors\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmpmggmt8_v/tmpmggmt8_v.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b052b571c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b052b268b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b052b268988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b052b2677b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmggmt8_v                        0x000055909d3d44c2 <unavailable> + 5314

    5    libc.so.6                          0x00002b052b75d460 __libc_start_main +
    245

    6    tmpmggmt8_v                        0x000055909d3d4119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    var factor = 1\n    var isPrime = true\n    while i < n {\n       \
    \ if n % i == 0 {\n            factors.append(factor)\n            n /= i\n  \
    \          factor = 1\n        } else {\n            factor *= i\n        }\n\
    \        i += 1\n    }\n    if n > 1 {\n        factors.append(factor)\n    }\n\
    \    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp6i5shi0p.swift:19:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    var j = 1\n    var k = 0\n    var m = 1\n    var n = n\n    var primes\
    \ = [Int]()\n    var primeFactors = [Int]()\n    var primeFactorsCount = [Int]()\n\
    \    var isPrime = [Bool]()\n    var isPrimeCount = [Int]()\n    var isPrimeFactor\
    \ = [Bool]()\n    var isPrimeFactorCount = [Int]()\n    var isPrimeFactorsCount\
    \ = [Int]()\n    var isPrimeFactorsCount2 = [Int]()\n    var isPrimeFactorsCount3\
    \ = [Int]()\n    var isPrimeFactorsCount4 = [Int]()\n    var isPrimeFactorsCount5\
    \ = [Int]()\n    var isPrimeFactorsCount6 = [Int]()\n    var isPrimeFactorsCount7\
    \ = [Int]()\n    var isPrimeFactorsCount8 = [Int]()\n    var isPrimeFactorsCount9\
    \ = [Int]()\n    var isPrimeFactorsCount10 = [Int]()\n    var isPrimeFactorsCount11\
    \ = [Int]()\n    var isPrimeFactorsCount12 = [Int]()\n    var isPrimeFactorsCount13\
    \ = [Int]()\n    var isPrimeFactorsCount14 = [Int]()\n    var isPrimeFactorsCount15\
    \ = [Int]()\n    var isPrimeFactorsCount16 = [Int]()\n    var isPrimeFactorsCount17\
    \ = [Int]()\n    var isPrimeFactorsCount18 = [Int]()\n    var isPrimeFactorsCount19\
    \ = [Int]()\n    var isPrimeFactorsCount20 = [Int]()\n    var isPrimeFactorsCount21\
    \ = [Int]()\n    var isPrimeFactorsCount22 = [Int]()\n    var isPrimeFactorsCount23\
    \ = [Int]()\n    var isPrimeFactorsCount24 = [Int]()\n    var isPrimeFactorsCount25\
    \ = [Int]()\n    var isPrimeFactorsCount26 = [Int]()\n    var isPrimeFactorsCount27\
    \ = [Int]()\n    var isPrimeFactorsCount28 = [Int]()\n    var isPrimeFactorsCount29\
    \ = [Int]()\n    var isPrimeFactorsCount30 = [Int]()\n    var isPrimeFactorsCount31\
    \ = [Int]()\n    var isPrimeFactorsCount32 = [Int]()\n    var isPrime\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpujp4t1qb.swift:57:9: error: type annotation missing in pattern\n\
    \    var isPrime\n        ^\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var factorizationCount = 0\n    var factorizationMax = 0\n    var factorizationMin\
    \ = Int64(Int.max)\n    var factorizationSum = Int64(Int.max)\n    var factorizationSumOfSquares\
    \ = 0\n    var factorizationSumOfSquaresMax = 0\n    var factorizationSumOfSquaresMin\
    \ = Int64(Int.max)\n    var factorizationSumOfSquaresSum = Int64(Int.max)\n  \
    \  var factorizationSumOfSquaresSumOfSquares = 0\n    var factorizationSumOfSquaresSumOfSquaresMax\
    \ = 0\n    var factorizationSumOfSquaresSumOfSquaresMin = Int64(Int.max)\n   \
    \ var factorizationSumOfSquaresSumOfSquaresSum = Int64(Int.max)\n    var factorizationSumOfSquaresSumOfSquaresSumOfSquares\
    \ = 0\n    var factorizationSumOfSquaresSumOfSquaresSumOfSquaresMax = 0\n    var\
    \ factorizationSumOfSquaresSumOfSquaresSumOfSquaresMin = Int64(Int.max)\n    var\
    \ factorizationSumOfSquaresSumOfSquaresSumOfSquaresSum = Int64(Int.max)\n    var\
    \ factorizationSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquares = 0\n    var factorizationSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresMax\
    \ = 0\n    var factorizationSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresMin\
    \ = Int64(Int.max)\n    var factorizationSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSum\
    \ = Int64(Int.max)\n    var factorizationSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquares\
    \ = 0\n    var factorizationSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresMax\
    \ = 0\n    var factorizationSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresMin\
    \ = Int64(Int.max)\n    var factorizationSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSum\
    \ = Int64(Int.max)\n    var factorizationSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquares\
    \ = 0\n    var factorizationSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresMax\
    \ = 0\n    var factorizationSumOfSquaresSumOfSquaresSumOf\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp8ab0e5d2.swift:39:9: error: type annotation missing in pattern\n\
    \    var factorizationSumOfSquaresSumOfSquaresSumOf\n        ^\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var primeFactorization: [Int] = []\n    var isPrime: [Bool] = []\n    var\
    \ isPrimeCount: [Int] = []\n    var isPrimeCountMax: Int = 1\n    var isPrimeCountMin:\
    \ Int = 1\n    var isPrimeCountMinMax: Int = 1\n    var isPrimeCountMaxMin: Int\
    \ = 1\n    var isPrimeCountMaxMinMax: Int = 1\n    var isPrimeCountMaxMinMaxMin:\
    \ Int = 1\n    var isPrimeCountMaxMinMaxMinMax: Int = 1\n    var isPrimeCountMaxMinMaxMinMaxMin:\
    \ Int = 1\n    var isPrimeCountMaxMinMaxMinMaxMinMax: Int = 1\n    var isPrimeCountMaxMinMaxMinMaxMinMaxMin:\
    \ Int = 1\n    var isPrimeCountMaxMinMaxMinMaxMinMaxMinMax: Int = 1\n    var isPrimeCountMaxMinMaxMinMaxMinMaxMinMaxMin:\
    \ Int = 1\n    var isPrimeCountMaxMinMaxMinMaxMinMaxMinMaxMinMax: Int = 1\n  \
    \  var isPrimeCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMax: Int = 1\n    var isPrimeCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMax:\
    \ Int = 1\n    var isPrimeCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMax: Int = 1\n\
    \    var isPrimeCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMax: Int = 1\n   \
    \ var isPrimeCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMax: Int = 1\n    var\
    \ isPrimeCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMax: Int = 1\n    var isPrimeCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMax:\
    \ Int = 1\n    var isPrimeCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax:\
    \ Int = 1\n    var isPrimeCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMax:\
    \ Int = 1\n    var isPrimeCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMax:\
    \ Int = 1\n    var isPrimeCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMax:\
    \ Int = 1\n    var isPrimeCountMaxMinMaxMinMaxMinMaxMinMaxMinMax\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp67y3ypu7.swift:30:9: error: invalid redeclaration of 'isPrimeCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMax'\n\
    \    var isPrimeCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMax: Int = 1\n        ^\n\
    /tmp/tmp67y3ypu7.swift:29:9: note: 'isPrimeCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMax'\
    \ previously declared here\n    var isPrimeCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMax:\
    \ Int = 1\n        ^\n/tmp/tmp67y3ypu7.swift:31:9: error: invalid redeclaration\
    \ of 'isPrimeCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMax'\n    var isPrimeCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMax:\
    \ Int = 1\n        ^\n/tmp/tmp67y3ypu7.swift:29:9: note: 'isPrimeCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMax'\
    \ previously declared here\n    var isPrimeCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMax:\
    \ Int = 1\n        ^\n/tmp/tmp67y3ypu7.swift:33:9: error: invalid redeclaration\
    \ of 'isPrimeCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMax'\n    var isPrimeCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMax:\
    \ Int = 1\n        ^\n/tmp/tmp67y3ypu7.swift:32:9: note: 'isPrimeCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMax'\
    \ previously declared here\n    var isPrimeCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMax:\
    \ Int = 1\n        ^\n/tmp/tmp67y3ypu7.swift:34:9: error: invalid redeclaration\
    \ of 'isPrimeCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMax'\n    var isPrimeCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMax:\
    \ Int = 1\n        ^\n/tmp/tmp67y3ypu7.swift:32:9: note: 'isPrimeCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMax'\
    \ previously declared here\n    var isPrimeCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMax:\
    \ Int = 1\n        ^\n/tmp/tmp67y3ypu7.swift:35:9: error: invalid redeclaration\
    \ of 'isPrimeCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMax'\n    var isPrimeCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMax:\
    \ Int = 1\n        ^\n/tmp/tmp67y3ypu7.swift:32:9: note: 'isPrimeCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMax'\
    \ previously declared here\n    var isPrimeCountMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMax:\
    \ Int = 1\n        ^\n/tmp/tmp67y3ypu7.swift:38:9: error: invalid redeclaration\
    \ of 'isPrimeCountMaxMinMaxMinMaxMinMaxMinMax"
  stdout: ''
  timestamp: 1659824952
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    var p = n\n    while p > 1 {\n        while p % i == 0 {\n        \
    \    factors.append(i)\n            p /= i\n        }\n        i += 1\n    }\n\
    \    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var factor = 2\n    var factorizationCount = 0\n    var isPrime = true\n \
    \   while factorizationCount < n {\n        while factorizationCount < n && factor\
    \ <= n {\n            factorizationCount += 1\n            if isPrime {\n    \
    \            if n % factor == 0 {\n                    factorizationCount += 1\n\
    \                    factorization.append(factor)\n                    n /= factor\n\
    \                } else {\n                    isPrime = false\n             \
    \   }\n            } else {\n                if n % (factor * factor) == 0 {\n\
    \                    factorizationCount += 1\n                    factorization.append(factor)\n\
    \                    n /= (factor * factor)\n                } else {\n      \
    \              isPrime = true\n                }\n            }\n            factor\
    \ += 1\n        }\n        if n == 1 {\n            factorizationCount += 1\n\
    \            factorization.append(1)\n            n = 2\n        } else {\n  \
    \          factorizationCount += 1\n            factorization.append(n)\n    \
    \        n = 1\n        }\n    }\n    return factorization\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp3jyf0cw0.swift:23:23: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n                    n /= factor\n        \
    \            ~ ^\n/tmp/tmp3jyf0cw0.swift:31:23: error: left side of mutating operator\
    \ isn't mutable: 'n' is a 'let' constant\n                    n /= (factor * factor)\n\
    \                    ~ ^\n/tmp/tmp3jyf0cw0.swift:41:13: error: cannot assign to\
    \ value: 'n' is a 'let' constant\n            n = 2\n            ^\n/tmp/tmp3jyf0cw0.swift:45:13:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n            n = 1\n\
    \            ^\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var factorizationCount = 0\n    var factorizationSum = 0\n    var factorizationSum2\
    \ = 0\n    var factorizationSum3 = 0\n    var factorizationSum4 = 0\n    var factorizationSum5\
    \ = 0\n    var factorizationSum6 = 0\n    var factorizationSum7 = 0\n    var factorizationSum8\
    \ = 0\n    var factorizationSum9 = 0\n    var factorizationSum10 = 0\n    var\
    \ factorizationSum11 = 0\n    var factorizationSum12 = 0\n    var factorizationSum13\
    \ = 0\n    var factorizationSum14 = 0\n    var factorizationSum15 = 0\n    var\
    \ factorizationSum16 = 0\n    var factorizationSum17 = 0\n    var factorizationSum18\
    \ = 0\n    var factorizationSum19 = 0\n    var factorizationSum20 = 0\n    var\
    \ factorizationSum21 = 0\n    var factorizationSum22 = 0\n    var factorizationSum23\
    \ = 0\n    var factorizationSum24 = 0\n    var factorizationSum25 = 0\n    var\
    \ factorizationSum26 = 0\n    var factorizationSum27 = 0\n    var factorizationSum28\
    \ = 0\n    var factorizationSum29 = 0\n    var factorizationSum30 = 0\n    var\
    \ factorizationSum31 = 0\n    var factorizationSum32 = 0\n    var factorizationSum33\
    \ = 0\n    var factorizationSum34 = 0\n    var factorizationSum35 = 0\n    var\
    \ factorizationSum36 = 0\n    var factorizationSum37 = 0\n    var factorizationSum38\
    \ = 0\n    var factorizationSum39 = 0\n    var factorizationSum40 = 0\n    var\
    \ factorizationSum41 = 0\n    var factorizationSum42 = 0\n    var factorizationSum43\
    \ = 0\n    var factorizationSum44 = 0\n    var factorizationSum45 = 0\n    var\
    \ factorizationSum46 = 0\n    var factorizationSum47 = 0\n    var factorizationSum48\
    \ = 0\n    var factorizationSum49 = 0\n    var factorizationSum50 = 0\n    var\
    \ factorizationSum51 = 0\n    var factorizationSum52 = 0\n    var factorizationSum53\
    \ = 0\n    var factorizationSum54 = 0\n    var factorizationSum55 = 0\n    var\
    \ factorizationSum56 = 0\n    var factorizationSum57 = 0\n    var factorizationSum58\
    \ = 0\n    var factorizationSum59 = 0\n    var factorizationSum60 = 0\n    var\
    \ factorizationSum61 = 0\n    var factorizationSum62 = 0\n    var factorizationSum63\
    \ = 0\n    var factorizationSum64 = 0\n    var factorizationSum65 = 0\n    var\
    \ factorizationSum66 = 0\n    var factorizationSum67 = 0\n    var factorizationSum68\
    \ = 0\n    var factorizationSum69 = 0\n    var factorizationSum70 = 0\n    var\
    \ factorizationSum71 = 0\n    var factorization\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpnjuxyg73.swift:85:9: error: type annotation missing in pattern\n\
    \    var factorization\n        ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var factorizationCount = [Int]()\n    var primeFactorization = [Int]()\n   \
    \ var primeFactorizationCount = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeCount\
    \ = [Int]()\n    var isPrimeCount2 = [Int]()\n    var isPrimeCount3 = [Int]()\n\
    \    var isPrimeCount4 = [Int]()\n    var isPrimeCount5 = [Int]()\n    var isPrimeCount6\
    \ = [Int]()\n    var isPrimeCount7 = [Int]()\n    var isPrimeCount8 = [Int]()\n\
    \    var isPrimeCount9 = [Int]()\n    var isPrimeCount10 = [Int]()\n    var isPrimeCount11\
    \ = [Int]()\n    var isPrimeCount12 = [Int]()\n    var isPrimeCount13 = [Int]()\n\
    \    var isPrimeCount14 = [Int]()\n    var isPrimeCount15 = [Int]()\n    var isPrimeCount16\
    \ = [Int]()\n    var isPrimeCount17 = [Int]()\n    var isPrimeCount18 = [Int]()\n\
    \    var isPrimeCount19 = [Int]()\n    var isPrimeCount20 = [Int]()\n    var isPrimeCount21\
    \ = [Int]()\n    var isPrimeCount22 = [Int]()\n    var isPrimeCount23 = [Int]()\n\
    \    var isPrimeCount24 = [Int]()\n    var isPrimeCount25 = [Int]()\n    var isPrimeCount26\
    \ = [Int]()\n    var isPrimeCount27 = [Int]()\n    var isPrimeCount28 = [Int]()\n\
    \    var isPrimeCount29 = [Int]()\n    var isPrimeCount30 = [Int]()\n    var isPrimeCount31\
    \ = [Int]()\n    var isPrimeCount32 = [Int]()\n    var isPrimeCount33 = [Int]()\n\
    \    var isPrimeCount34 = [Int]()\n    var isPrimeCount35 = [Int]()\n    var isPrimeCount36\
    \ = [Int]()\n    var isPrimeCount37 = [Int]()\n    var isPrimeCount38 = [Int]()\n\
    \    var isPrimeCount39 = [Int]()\n    var isPrimeCount40 = [Int]()\n    var isPrimeCount41\
    \ = [Int]()\n    var isPrimeCount42 = [Int]()\n    var isPrime\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp2wq70wvt.swift:59:9: error: type annotation missing in pattern\n\
    \    var isPrime\n        ^\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    if n < 2 {\n        return []\n \
    \   }\n    var factors = [Int]()\n    var primes = [Int]()\n    var factorization\
    \ = factorizationOfNumber(n)\n    for factor in factorization {\n        if factor\
    \ > 1 {\n            factors.append(factor)\n        }\n    }\n    for factor\
    \ in factors {\n        if factor > 1 {\n            primes.append(factor)\n \
    \       }\n    }\n    return primes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp8_j4r769.swift:17:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var primeFactorization: [Int] = []\n    var isPrime: [Bool] = []\n    var\
    \ isPrimeCount: [Int] = []\n    var isPrimeCountMax: Int = 1\n    var isPrimeCountMin:\
    \ Int = 2\n    var isPrimeCountMinMax: Int = 2\n    var isPrimeCountMaxMin: Int\
    \ = 2\n    var isPrimeCountMinMaxMax: Int = 2\n    var isPrimeCountMinMaxMaxMax:\
    \ Int = 2\n    var isPrimeCountMinMaxMaxMaxMax: Int = 2\n    var isPrimeCountMinMaxMaxMaxMax:\
    \ Int = 2\n    var isPrimeCountMinMaxMaxMaxMaxMax: Int = 2\n    var isPrimeCountMinMaxMaxMaxMaxMaxMax:\
    \ Int = 2\n    var isPrimeCountMinMaxMaxMaxMaxMaxMax: Int = 2\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMax:\
    \ Int = 2\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMax: Int = 2\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMax:\
    \ Int = 2\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 2\n    var\
    \ isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 2\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax:\
    \ Int = 2\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 2\n\
    \    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 2\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax:\
    \ Int = 2\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 2\n\
    \    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 2\n    var\
    \ isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 2\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax:\
    \ Int = 2\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int\
    \ = 2\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 2\n\
    \    var isPrime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp1c51uexd.swift:23:9: error: invalid redeclaration of 'isPrimeCountMinMaxMaxMaxMax'\n\
    \    var isPrimeCountMinMaxMaxMaxMax: Int = 2\n        ^\n/tmp/tmp1c51uexd.swift:22:9:\
    \ note: 'isPrimeCountMinMaxMaxMaxMax' previously declared here\n    var isPrimeCountMinMaxMaxMaxMax:\
    \ Int = 2\n        ^\n/tmp/tmp1c51uexd.swift:26:9: error: invalid redeclaration\
    \ of 'isPrimeCountMinMaxMaxMaxMaxMaxMax'\n    var isPrimeCountMinMaxMaxMaxMaxMaxMax:\
    \ Int = 2\n        ^\n/tmp/tmp1c51uexd.swift:25:9: note: 'isPrimeCountMinMaxMaxMaxMaxMaxMax'\
    \ previously declared here\n    var isPrimeCountMinMaxMaxMaxMaxMaxMax: Int = 2\n\
    \        ^\n/tmp/tmp1c51uexd.swift:29:9: error: invalid redeclaration of 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMax'\n\
    \    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMax: Int = 2\n        ^\n/tmp/tmp1c51uexd.swift:28:9:\
    \ note: 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMax' previously declared here\n \
    \   var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMax: Int = 2\n        ^\n/tmp/tmp1c51uexd.swift:31:9:\
    \ error: invalid redeclaration of 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax'\n\
    \    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 2\n        ^\n/tmp/tmp1c51uexd.swift:30:9:\
    \ note: 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax' previously declared here\n\
    \    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 2\n        ^\n/tmp/tmp1c51uexd.swift:34:9:\
    \ error: invalid redeclaration of 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax'\n\
    \    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 2\n        ^\n\
    /tmp/tmp1c51uexd.swift:33:9: note: 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax'\
    \ previously declared here\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax:\
    \ Int = 2\n        ^\n/tmp/tmp1c51uexd.swift:35:9: error: invalid redeclaration\
    \ of 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax'\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax:\
    \ Int = 2\n        ^\n/tmp/tmp1c51uexd.swift:33:9: note: 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax'\
    \ previously declared here\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax:\
    \ Int = 2\n        ^\n/t"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    if n < 2 {\n        return []\n \
    \   }\n    var factors: [Int] = []\n    var factorization: [Int] = [1]\n    var\
    \ i = 2\n    var j = 1\n    var k = 0\n    while i < n {\n        if n % i ==\
    \ 0 {\n            factors.append(i)\n            factorization[k] += 1\n    \
    \        n /= i\n            i += 1\n        } else {\n            j += 1\n  \
    \          factors.append(j)\n            factorization[k] += 1\n        }\n \
    \       k += 1\n    }\n    if n != 1 {\n        factors.append(n)\n        factorization[k]\
    \ += 1\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpz48mzxjv.swift:24:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var primeFactors\
    \ = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeCount = 0\n    var isPrimeIndex\
    \ = 0\n    var isPrimeCountMax = Int(sqrt(Double(n)))\n    var isPrimeIndexMax\
    \ = Int(sqrt(Double(n)))\n    var isPrimeMax = Int(sqrt(Double(n)))\n    var isPrimeIndexMax\
    \ = Int(sqrt(Double(n)))\n    var isPrimeMax = Int(sqrt(Double(n)))\n    var isPrimeIndexMax\
    \ = Int(sqrt(Double(n)))\n    var isPrimeMax = Int(sqrt(Double(n)))\n    var isPrimeIndexMax\
    \ = Int(sqrt(Double(n)))\n    var isPrimeMax = Int(sqrt(Double(n)))\n    var isPrimeIndexMax\
    \ = Int(sqrt(Double(n)))\n    var isPrimeMax = Int(sqrt(Double(n)))\n    var isPrimeIndexMax\
    \ = Int(sqrt(Double(n)))\n    var isPrimeMax = Int(sqrt(Double(n)))\n    var isPrimeIndexMax\
    \ = Int(sqrt(Double(n)))\n    var isPrimeMax = Int(sqrt(Double(n)))\n    var isPrimeIndexMax\
    \ = Int(sqrt(Double(n)))\n    var isPrimeMax = Int(sqrt(Double(n)))\n    var isPrimeIndexMax\
    \ = Int(sqrt(Double(n)))\n    var isPrimeMax = Int(sqrt(Double(n)))\n    var isPrimeIndexMax\
    \ = Int(sqrt(Double(n)))\n    var isPrimeMax = Int(sqrt(Double(n)))\n    var isPrimeIndexMax\
    \ = Int(sqrt(Double(n)))\n    var isPrimeMax = Int(sqrt(Double(n)))\n    var isPrimeIndexMax\
    \ = Int(sqrt(Double(n)))\n    var isPrimeMax = Int(sqrt(Double(n)))\n    var isPrimeIndexMax\
    \ = Int(sqrt(Double(n)))\n    var isPrimeMax = Int(sqrt(Double(n)))\n    var isPrimeIndexMax\
    \ = Int(sqrt(Double(n)))\n    var isPrimeMax = Int(sqrt(Double(n)))\n    var isPrimeIndexMax\
    \ = Int(sqrt(Double(n)))\n    var isPrimeMax = Int(sqrt(Double(n)))\n    var isPrimeIndexMax\
    \ = Int(sqrt(Double(n)))\n    var isPrimeMax = Int(sqrt(Double(n)))\n    var isPrimeIndexMax\
    \ = Int(sqrt(Double(n)))\n    var isPrimeMax = Int(sqrt(Double(n)))\n    var isPrimeIndexMax\
    \ = Int(sqrt(Double(n)))\n    var isPrimeMax = Int(sqrt(Double(n)))\n    var isPrimeIndexMax\
    \ = Int(sqrt(Double(n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpmmuujb1e.swift:55:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpmmuujb1e.swift:54:42: note: to match this opening '('\n    var isPrimeIndexMax\
    \ = Int(sqrt(Double(n\n                                         ^\n/tmp/tmpmmuujb1e.swift:17:31:\
    \ error: cannot find 'sqrt' in scope\n    var isPrimeCountMax = Int(sqrt(Double(n)))\n\
    \                              ^~~~\n/tmp/tmpmmuujb1e.swift:18:31: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeIndexMax = Int(sqrt(Double(n)))\n     \
    \                         ^~~~\n/tmp/tmpmmuujb1e.swift:19:26: error: cannot find\
    \ 'sqrt' in scope\n    var isPrimeMax = Int(sqrt(Double(n)))\n               \
    \          ^~~~\n/tmp/tmpmmuujb1e.swift:20:31: error: cannot find 'sqrt' in scope\n\
    \    var isPrimeIndexMax = Int(sqrt(Double(n)))\n                            \
    \  ^~~~\n/tmp/tmpmmuujb1e.swift:21:26: error: cannot find 'sqrt' in scope\n  \
    \  var isPrimeMax = Int(sqrt(Double(n)))\n                         ^~~~\n/tmp/tmpmmuujb1e.swift:22:31:\
    \ error: cannot find 'sqrt' in scope\n    var isPrimeIndexMax = Int(sqrt(Double(n)))\n\
    \                              ^~~~\n/tmp/tmpmmuujb1e.swift:23:26: error: cannot\
    \ find 'sqrt' in scope\n    var isPrimeMax = Int(sqrt(Double(n)))\n          \
    \               ^~~~\n/tmp/tmpmmuujb1e.swift:24:31: error: cannot find 'sqrt'\
    \ in scope\n    var isPrimeIndexMax = Int(sqrt(Double(n)))\n                 \
    \             ^~~~\n/tmp/tmpmmuujb1e.swift:25:26: error: cannot find 'sqrt' in\
    \ scope\n    var isPrimeMax = Int(sqrt(Double(n)))\n                         ^~~~\n\
    /tmp/tmpmmuujb1e.swift:26:31: error: cannot find 'sqrt' in scope\n    var isPrimeIndexMax\
    \ = Int(sqrt(Double(n)))\n                              ^~~~\n/tmp/tmpmmuujb1e.swift:27:26:\
    \ error: cannot find 'sqrt' in scope\n    var isPrimeMax = Int(sqrt(Double(n)))\n\
    \                         ^~~~\n/tmp/tmpmmuujb1e.swift:28:31: error: cannot find\
    \ 'sqrt' in scope\n    var isPrimeIndexMax = Int(sqrt(Double(n)))\n          \
    \                    ^~~~\n/tmp/tmpmmuujb1e.swift:29:26: error: cannot find 'sqrt'\
    \ in scope\n    var isPrimeMax = Int(sqrt(Double(n)))\n      "
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            factors.append(i)\n\
    \            n /= i\n        } else {\n            i += 1\n        }\n    }\n\
    \    if n > 1 {\n        factors.append(n)\n    }\n    return factors\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpv1s4fi4v.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var primeFactorization = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeCount\
    \ = 0\n    var isPrimeSum = 0\n    var isPrimeSumCount = 0\n    var isPrimeSumPrimeCount\
    \ = 0\n    var isPrimeSumPrime = 0\n    var isPrimeSumPrimeCountPrime = 0\n  \
    \  var isPrimeSumPrimePrimeCountPrime = 0\n    var isPrimeSumPrimePrimeCountPrimePrime\
    \ = 0\n    var isPrimeSumPrimePrimePrimeCountPrimePrime = 0\n    var isPrimeSumPrimePrimePrimeCountPrimePrimePrime\
    \ = 0\n    var isPrimeSumPrimePrimePrimeCountPrimePrimePrime = 0\n    var isPrimeSumPrimePrimePrimeCountPrimePrimePrimePrime\
    \ = 0\n    var isPrimeSumPrimePrimePrimeCountPrimePrimePrimePrime = 0\n    var\
    \ isPrimeSumPrimePrimePrimeCountPrimePrimePrimePrimePrime = 0\n    var isPrimeSumPrimePrimePrimeCountPrimePrimePrimePrimePrime\
    \ = 0\n    var isPrimeSumPrimePrimePrimeCountPrimePrimePrimePrimePrime = 0\n \
    \   var isPrimeSumPrimePrimePrimeCountPrimePrimePrimePrimePrimePrime = 0\n   \
    \ var isPrimeSumPrimePrimePrimeCountPrimePrimePrimePrimePrimePrime = 0\n    var\
    \ isPrimeSumPrimePrimePrimeCountPrimePrimePrimePrimePrimePrime = 0\n    var isPrimeSumPrimePrimePrimeCountPrimePrimePrimePrimePrimePrime\
    \ = 0\n    var isPrimeSumPrimePrimePrimeCountPrimePrimePrimePrimePrimePrime =\
    \ 0\n    var isPrimeSumPrimePrimePrimeCountPrimePrimePrimePrimePrimePrime = 0\n\
    \    var isPrimeSumPrimePrimePrimeCountPrimePrimePrimePrimePrimePrime = 0\n  \
    \  var isPrimeSumPrimePrimePrimeCountPrimePrimePrimePrimePrimePrime = 0\n    var\
    \ isPrimeSumPrimePrimePrimeCountPrimePrimePrimePrimePri\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp04gxofiu.swift:25:9: error: invalid redeclaration of 'isPrimeSumPrimePrimePrimeCountPrimePrimePrime'\n\
    \    var isPrimeSumPrimePrimePrimeCountPrimePrimePrime = 0\n        ^\n/tmp/tmp04gxofiu.swift:24:9:\
    \ note: 'isPrimeSumPrimePrimePrimeCountPrimePrimePrime' previously declared here\n\
    \    var isPrimeSumPrimePrimePrimeCountPrimePrimePrime = 0\n        ^\n/tmp/tmp04gxofiu.swift:27:9:\
    \ error: invalid redeclaration of 'isPrimeSumPrimePrimePrimeCountPrimePrimePrimePrime'\n\
    \    var isPrimeSumPrimePrimePrimeCountPrimePrimePrimePrime = 0\n        ^\n/tmp/tmp04gxofiu.swift:26:9:\
    \ note: 'isPrimeSumPrimePrimePrimeCountPrimePrimePrimePrime' previously declared\
    \ here\n    var isPrimeSumPrimePrimePrimeCountPrimePrimePrimePrime = 0\n     \
    \   ^\n/tmp/tmp04gxofiu.swift:29:9: error: invalid redeclaration of 'isPrimeSumPrimePrimePrimeCountPrimePrimePrimePrimePrime'\n\
    \    var isPrimeSumPrimePrimePrimeCountPrimePrimePrimePrimePrime = 0\n       \
    \ ^\n/tmp/tmp04gxofiu.swift:28:9: note: 'isPrimeSumPrimePrimePrimeCountPrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimeSumPrimePrimePrimeCountPrimePrimePrimePrimePrime\
    \ = 0\n        ^\n/tmp/tmp04gxofiu.swift:30:9: error: invalid redeclaration of\
    \ 'isPrimeSumPrimePrimePrimeCountPrimePrimePrimePrimePrime'\n    var isPrimeSumPrimePrimePrimeCountPrimePrimePrimePrimePrime\
    \ = 0\n        ^\n/tmp/tmp04gxofiu.swift:28:9: note: 'isPrimeSumPrimePrimePrimeCountPrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimeSumPrimePrimePrimeCountPrimePrimePrimePrimePrime\
    \ = 0\n        ^\n/tmp/tmp04gxofiu.swift:32:9: error: invalid redeclaration of\
    \ 'isPrimeSumPrimePrimePrimeCountPrimePrimePrimePrimePrimePrime'\n    var isPrimeSumPrimePrimePrimeCountPrimePrimePrimePrimePrimePrime\
    \ = 0\n        ^\n/tmp/tmp04gxofiu.swift:31:9: note: 'isPrimeSumPrimePrimePrimeCountPrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimeSumPrimePrimePrimeCountPrimePrimePrimePrimePrimePrime\
    \ = 0\n        ^\n/tmp/tmp04gxofiu.swift:33:9: error: invalid redeclaration of\
    \ 'isPrimeSumPrimePrimePrimeCountPrimePrimePrimePrimePrimePrime'"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var i = 2\n    var factor = 2\n    var factorCount = 0\n    while i < n {\n\
    \        while n % i == 0 {\n            factorization[factorCount] = i\n    \
    \        factorCount += 1\n            n /= i\n        }\n        i += 1\n   \
    \ }\n    if n > 1 {\n        factorization[factorCount] = n\n    }\n    return\
    \ factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpa4pexgz3.swift:20:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var factor = 2\n    var primeFactorization: [Int] = []\n    var primeFactor\
    \ = 2\n    var isPrime = true\n    var isPrimeFactorization = true\n    var isPrimePrimeFactorization\
    \ = true\n    var isPrimePrimeFactorizationPrime = true\n    var isPrimePrimeFactorizationPrimePrime\
    \ = true\n    var isPrimePrimeFactorizationPrimePrimePrime = true\n    var isPrimePrimeFactorizationPrimePrimePrimePrime\
    \ = true\n    var isPrimePrimeFactorizationPrimePrimePrimePrimePrime = true\n\
    \    var isPrimePrimeFactorizationPrimePrimePrimePrimePrime = true\n    var isPrimePrimeFactorizationPrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrime = true\n\
    \    var isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrime = true\n    var\
    \ isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimePrime = true\n    var\
    \ isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimePrime = true\n    var\
    \ isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimePrime = true\n    var\
    \ isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrime = true\n \
    \   var isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrime = true\n\
    \    var isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimeFactorization\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpop3vg9z7.swift:24:9: error: invalid redeclaration of 'isPrimePrimeFactorizationPrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimeFactorizationPrimePrimePrimePrimePrime = true\n        ^\n\
    /tmp/tmpop3vg9z7.swift:23:9: note: 'isPrimePrimeFactorizationPrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimePrimeFactorizationPrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmpop3vg9z7.swift:25:9: error: invalid redeclaration\
    \ of 'isPrimePrimeFactorizationPrimePrimePrimePrimePrime'\n    var isPrimePrimeFactorizationPrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmpop3vg9z7.swift:23:9: note: 'isPrimePrimeFactorizationPrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimePrimeFactorizationPrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmpop3vg9z7.swift:27:9: error: invalid redeclaration\
    \ of 'isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrime'\n    var isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmpop3vg9z7.swift:26:9: note: 'isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmpop3vg9z7.swift:29:9: error: invalid redeclaration\
    \ of 'isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimePrime'\n    var isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmpop3vg9z7.swift:28:9: note: 'isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmpop3vg9z7.swift:30:9: error: invalid redeclaration\
    \ of 'isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimePrime'\n    var isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmpop3vg9z7.swift:28:9: note: 'isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmpop3vg9z7.swift:32:9: error: invalid redeclara"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var primes\
    \ = [Int]()\n    var primeFactors = [Int]()\n    var isPrime = [Bool]()\n    var\
    \ isPrimeFactors = [Bool]()\n    var isPrimeFactorsCount = [Int]()\n    var isPrimeFactorsCountMax\
    \ = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n    var isPrimeFactorsCountMaxValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueIndex = Int()\n    var isPrimeFactorsCountMaxValueValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueIndex = Int()\n    var isPrimeFactorsCountMaxValueValueValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndex = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValueValue = Int()\n \
    \   var isPrimeFactorsCountMaxValueValueValueValueIndex = Int()\n    var isPrimeFactorsCountMaxValueValueValueValueValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValueIndex = Int()\n \
    \   var isPrimeFactorsCountMaxValueValueValueValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValueValue = Int()\n \
    \   var isPrimeFactorsCountMaxValueValueValueValueIndex = Int()\n    var isPrimeFactorsCountMaxValueValueValueValueValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValueIndex = Int()\n \
    \   var isPrimeFactorsCountMaxValueValueValueValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValueValue = Int()\n \
    \   var isPrimeFactorsCountMaxValueValueValueValueIndex = Int()\n    var isPrimeFactorsCountMaxValueValueValueValueValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValueIndex = Int()\n \
    \   var isPrimeFactorsCountMaxValueValueValueValueValue = Int()\n    var isPrimeFactorsCountMaxValueValueValueValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueValueValue = Int()\n \
    \   var isPrimeFactorsCountMaxValueValueValueValueIndex = Int()\n    var isPri\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpuwfnsm9d.swift:29:9: error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueValueValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueValueIndex = Int()\n        ^\n\
    /tmp/tmpuwfnsm9d.swift:27:9: note: 'isPrimeFactorsCountMaxValueValueValueValueIndex'\
    \ previously declared here\n    var isPrimeFactorsCountMaxValueValueValueValueIndex\
    \ = Int()\n        ^\n/tmp/tmpuwfnsm9d.swift:30:9: error: invalid redeclaration\
    \ of 'isPrimeFactorsCountMaxValueValueValueValueValue'\n    var isPrimeFactorsCountMaxValueValueValueValueValue\
    \ = Int()\n        ^\n/tmp/tmpuwfnsm9d.swift:28:9: note: 'isPrimeFactorsCountMaxValueValueValueValueValue'\
    \ previously declared here\n    var isPrimeFactorsCountMaxValueValueValueValueValue\
    \ = Int()\n        ^\n/tmp/tmpuwfnsm9d.swift:31:9: error: invalid redeclaration\
    \ of 'isPrimeFactorsCountMaxValueValueValueValueIndex'\n    var isPrimeFactorsCountMaxValueValueValueValueIndex\
    \ = Int()\n        ^\n/tmp/tmpuwfnsm9d.swift:27:9: note: 'isPrimeFactorsCountMaxValueValueValueValueIndex'\
    \ previously declared here\n    var isPrimeFactorsCountMaxValueValueValueValueIndex\
    \ = Int()\n        ^\n/tmp/tmpuwfnsm9d.swift:32:9: error: invalid redeclaration\
    \ of 'isPrimeFactorsCountMaxValueValueValueValueValue'\n    var isPrimeFactorsCountMaxValueValueValueValueValue\
    \ = Int()\n        ^\n/tmp/tmpuwfnsm9d.swift:28:9: note: 'isPrimeFactorsCountMaxValueValueValueValueValue'\
    \ previously declared here\n    var isPrimeFactorsCountMaxValueValueValueValueValue\
    \ = Int()\n        ^\n/tmp/tmpuwfnsm9d.swift:33:9: error: invalid redeclaration\
    \ of 'isPrimeFactorsCountMaxValueValueValueValueIndex'\n    var isPrimeFactorsCountMaxValueValueValueValueIndex\
    \ = Int()\n        ^\n/tmp/tmpuwfnsm9d.swift:27:9: note: 'isPrimeFactorsCountMaxValueValueValueValueIndex'\
    \ previously declared here\n    var isPrimeFactorsCountMaxValueValueValueValueIndex\
    \ = Int()\n        ^\n/tmp/tmpuwfnsm9d.swift:34:9: error: invalid redeclaration\
    \ of 'isPrimeFactorsCountMaxValueValueValueValueValue'\n    var isPrimeFactorsCountMaxValueValueValueValueValue\
    \ = Int()\n        ^\n/tmp/tmpuwfnsm9d.s"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var primeFactorization = [Int]()\n    var primeFactorizationIndex = 0\n    var\
    \ isPrime = true\n    var isPrimeIndex = 0\n    var isPrimeFactorization = false\n\
    \    var isPrimeFactorizationIndex = 0\n    var isPrimePrimeFactorization = false\n\
    \    var isPrimePrimeFactorizationIndex = 0\n    var isPrimePrimeFactorizationPrime\
    \ = false\n    var isPrimePrimeFactorizationPrimeIndex = 0\n    var isPrimePrimeFactorizationPrimePrime\
    \ = false\n    var isPrimePrimeFactorizationPrimePrimeIndex = 0\n    var isPrimePrimeFactorizationPrimePrimePrime\
    \ = false\n    var isPrimePrimeFactorizationPrimePrimePrimeIndex = 0\n    var\
    \ isPrimePrimeFactorizationPrimePrimePrimePrime = false\n    var isPrimePrimeFactorizationPrimePrimePrimePrimeIndex\
    \ = 0\n    var isPrimePrimeFactorizationPrimePrimePrimePrimePrime = false\n  \
    \  var isPrimePrimeFactorizationPrimePrimePrimePrimePrimeIndex = 0\n    var isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrime\
    \ = false\n    var isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrime = false\n\
    \    var isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimePrime = false\n\
    \    var isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimePrime = false\n\
    \    var isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrime = false\n\
    \    var isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrime = false\n\
    \    var isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrime = false\n\
    \    var isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrime = false\n\
    \    var isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = false\n    var isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = false\n    var isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrime\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpcor_k1oa.swift:32:9: error: invalid redeclaration of 'isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrime = false\n   \
    \     ^\n/tmp/tmpcor_k1oa.swift:31:9: note: 'isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrime\
    \ = false\n        ^\n/tmp/tmpcor_k1oa.swift:34:9: error: invalid redeclaration\
    \ of 'isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimePrime'\n    var isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimePrime\
    \ = false\n        ^\n/tmp/tmpcor_k1oa.swift:33:9: note: 'isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimePrime\
    \ = false\n        ^\n/tmp/tmpcor_k1oa.swift:36:9: error: invalid redeclaration\
    \ of 'isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrime'\n   \
    \ var isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrime = false\n\
    \        ^\n/tmp/tmpcor_k1oa.swift:35:9: note: 'isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrime\
    \ = false\n        ^\n/tmp/tmpcor_k1oa.swift:37:9: error: invalid redeclaration\
    \ of 'isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrime'\n   \
    \ var isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrime = false\n\
    \        ^\n/tmp/tmpcor_k1oa.swift:35:9: note: 'isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrime\
    \ = false\n        ^\n/tmp/tmpcor_k1oa.swift:38:9: error: invalid redeclaration\
    \ of 'isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrime'\n   \
    \ var isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrime = false\n\
    \        ^\n/tmp/tmpcor_k1oa.swift:35:9: note: 'isPrimePrimeFactorizationPrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared "
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var factorizationCount = 0\n    var currentFactorizationCount = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmps6qx_bv5.swift:16:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:17:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmps6qx_bv5.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:18:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmps6qx_bv5.swift:19:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:20:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmps6qx_bv5.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:21:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmps6qx_bv5.swift:22:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:23:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmps6qx_bv5.swift:15:9: note: 'currentFactorization' previously declar"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var factor: Int\n    var i: Int\n    var j: Int\n    var k: Int\n    var count:\
    \ Int\n    for i = 2; i <= n / 2; i += 1 {\n        factorization = factorization\
    \ + [Int]()\n        for j = i; j <= n / i; j += 1 {\n            factor = j\n\
    \            count = 0\n            for k = i + 1; k <= n / i; k += 1 {\n    \
    \            if k == i {\n                    continue\n                }\n  \
    \              if factor % k == 0 {\n                    count += 1\n        \
    \        }\n            }\n            if count == i {\n                factorization\
    \ = factorization + [Int]()\n                factorization = factorization + [factor]\n\
    \            }\n        }\n    }\n    return factorization\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpwe49djp_.swift:18:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for i = 2; i <= n / 2; i += 1 {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpwe49djp_.swift:20:9: error: C-style for statement has been removed in\
    \ Swift 3\n        for j = i; j <= n / i; j += 1 {\n        ^   ~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpwe49djp_.swift:23:13: error: C-style for statement has been removed in\
    \ Swift 3\n            for k = i + 1; k <= n / i; k += 1 {\n            ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            factorization\
    \ = append(factorization, i)\n            n /= i\n        } else {\n         \
    \   i += 1\n        }\n    }\n    if n > 1 {\n        factorization = append(factorization,\
    \ n)\n    }\n    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpjbfb27fp.swift:16:29: error: cannot find 'append' in scope\n  \
    \          factorization = append(factorization, i)\n                        \
    \    ^~~~~~\n/tmp/tmpjbfb27fp.swift:17:15: error: left side of mutating operator\
    \ isn't mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n\
    /tmp/tmpjbfb27fp.swift:23:25: error: cannot find 'append' in scope\n        factorization\
    \ = append(factorization, n)\n                        ^~~~~~\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var primes\
    \ = [Int]()\n    var i = 2\n    var isPrime = true\n    var factorization = [Int]()\n\
    \    var factorizationIndex = 0\n    var isPrimeIndex = 0\n    var isPrimeIndex2\
    \ = 0\n    var isPrimeIndex3 = 0\n    var isPrimeIndex4 = 0\n    var isPrimeIndex5\
    \ = 0\n    var isPrimeIndex6 = 0\n    var isPrimeIndex7 = 0\n    var isPrimeIndex8\
    \ = 0\n    var isPrimeIndex9 = 0\n    var isPrimeIndex10 = 0\n    var isPrimeIndex11\
    \ = 0\n    var isPrimeIndex12 = 0\n    var isPrimeIndex13 = 0\n    var isPrimeIndex14\
    \ = 0\n    var isPrimeIndex15 = 0\n    var isPrimeIndex16 = 0\n    var isPrimeIndex17\
    \ = 0\n    var isPrimeIndex18 = 0\n    var isPrimeIndex19 = 0\n    var isPrimeIndex20\
    \ = 0\n    var isPrimeIndex21 = 0\n    var isPrimeIndex22 = 0\n    var isPrimeIndex23\
    \ = 0\n    var isPrimeIndex24 = 0\n    var isPrimeIndex25 = 0\n    var isPrimeIndex26\
    \ = 0\n    var isPrimeIndex27 = 0\n    var isPrimeIndex28 = 0\n    var isPrimeIndex29\
    \ = 0\n    var isPrimeIndex30 = 0\n    var isPrimeIndex31 = 0\n    var isPrimeIndex32\
    \ = 0\n    var isPrimeIndex33 = 0\n    var isPrimeIndex34 = 0\n    var isPrimeIndex35\
    \ = 0\n    var isPrimeIndex36 = 0\n    var isPrimeIndex37 = 0\n    var isPrimeIndex38\
    \ = 0\n    var isPrimeIndex39 = 0\n    var isPrimeIndex40 = 0\n    var isPrimeIndex41\
    \ = 0\n    var isPrimeIndex42 = 0\n    var isPrimeIndex43 = 0\n    var isPrimeIndex44\
    \ = 0\n    var isPrimeIndex45 = 0\n    var isPrimeIndex46 = 0\n    var isPrimeIndex47\
    \ = 0\n    var isPrimeIndex48 = 0\n    var isPrimeIndex49 = 0\n    var isPrimeIndex50\
    \ = 0\n    var isPrimeIndex51 = 0\n    var isPrimeIndex52 = 0\n    var isPrimeIndex53\
    \ = 0\n    var isPrimeIndex54 = 0\n    var isPrimeIndex55 = 0\n    var isPrimeIndex56\
    \ = 0\n    var isPrimeIndex57 = 0\n    var isPrimeIndex58 = 0\n    var isPrimeIndex59\
    \ = 0\n    var isPri\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpfq7w77oj.swift:77:9: error: type annotation missing in pattern\n\
    \    var isPri\n        ^\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    if n < 2 {\n        return []\n \
    \   }\n    var factors = [Int]()\n    var factorization = [Int]()\n    var current\
    \ = 0\n    var factorizationIndex = 0\n    var isPrime = true\n    var isFactorization\
    \ = false\n    var isPrimeIndex = 0\n    var isPrimeIndex2 = 0\n    var isPrimeIndex3\
    \ = 0\n    var isPrimeIndex4 = 0\n    var isPrimeIndex5 = 0\n    var isPrimeIndex6\
    \ = 0\n    var isPrimeIndex7 = 0\n    var isPrimeIndex8 = 0\n    var isPrimeIndex9\
    \ = 0\n    var isPrimeIndex10 = 0\n    var isPrimeIndex11 = 0\n    var isPrimeIndex12\
    \ = 0\n    var isPrimeIndex13 = 0\n    var isPrimeIndex14 = 0\n    var isPrimeIndex15\
    \ = 0\n    var isPrimeIndex16 = 0\n    var isPrimeIndex17 = 0\n    var isPrimeIndex18\
    \ = 0\n    var isPrimeIndex19 = 0\n    var isPrimeIndex20 = 0\n    var isPrimeIndex21\
    \ = 0\n    var isPrimeIndex22 = 0\n    var isPrimeIndex23 = 0\n    var isPrimeIndex24\
    \ = 0\n    var isPrimeIndex25 = 0\n    var isPrimeIndex26 = 0\n    var isPrimeIndex27\
    \ = 0\n    var isPrimeIndex28 = 0\n    var isPrimeIndex29 = 0\n    var isPrimeIndex30\
    \ = 0\n    var isPrimeIndex31 = 0\n    var isPrimeIndex32 = 0\n    var isPrimeIndex33\
    \ = 0\n    var isPrimeIndex34 = 0\n    var isPrimeIndex35 = 0\n    var isPrimeIndex36\
    \ = 0\n    var isPrimeIndex37 = 0\n    var isPrimeIndex38 = 0\n    var isPrimeIndex39\
    \ = 0\n    var isPrimeIndex40 = 0\n    var isPrimeIndex41 = 0\n    var isPrimeIndex42\
    \ = 0\n    var isPrimeIndex43 = 0\n    var isPrimeIndex44 = 0\n    var isPrimeIndex45\
    \ = 0\n    var isPrimeIndex46 = 0\n    var isPrimeIndex47 = 0\n    var isPrimeIndex48\
    \ = 0\n    var isPrimeIndex49 = 0\n    var isPrimeIndex50 = 0\n    var isPrimeIndex51\
    \ = 0\n    var isPrimeIndex52 = 0\n    var isPrimeIndex53 = 0\n    var isPrimeIndex54\
    \ = 0\n    var isPrimeIndex55 = 0\n    var isPrimeIndex56 = 0\n    var isPrimeIndex57\
    \ = 0\n    var isPrimeIndex58 = 0\n    var isPrime\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpih7a9ndh.swift:79:9: error: type annotation missing in pattern\n\
    \    var isPrime\n        ^\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var primeFactorization: [Int] = []\n    var isPrime: [Bool] = []\n    var\
    \ isPrimeCount: [Int] = []\n    var isPrimeCountMax: Int = 1\n    var isPrimeCountMin:\
    \ Int = 2\n    var isPrimeCountMaxMin: Int = 2\n    var isPrimeCountMaxMinMin:\
    \ Int = 2\n    var isPrimeCountMaxMinMin2: Int = 2\n    var isPrimeCountMaxMinMin3:\
    \ Int = 2\n    var isPrimeCountMaxMinMin4: Int = 2\n    var isPrimeCountMaxMinMin5:\
    \ Int = 2\n    var isPrimeCountMaxMinMin6: Int = 2\n    var isPrimeCountMaxMinMin7:\
    \ Int = 2\n    var isPrimeCountMaxMinMin8: Int = 2\n    var isPrimeCountMaxMinMin9:\
    \ Int = 2\n    var isPrimeCountMaxMinMin10: Int = 2\n    var isPrimeCountMaxMinMin11:\
    \ Int = 2\n    var isPrimeCountMaxMinMin12: Int = 2\n    var isPrimeCountMaxMinMin13:\
    \ Int = 2\n    var isPrimeCountMaxMinMin14: Int = 2\n    var isPrimeCountMaxMinMin15:\
    \ Int = 2\n    var isPrimeCountMaxMinMin16: Int = 2\n    var isPrimeCountMaxMinMin17:\
    \ Int = 2\n    var isPrimeCountMaxMinMin18: Int = 2\n    var isPrimeCountMaxMinMin19:\
    \ Int = 2\n    var isPrimeCountMaxMinMin20: Int = 2\n    var isPrimeCountMaxMinMin21:\
    \ Int = 2\n    var isPrimeCountMaxMinMin22: Int = 2\n    var isPrimeCountMaxMinMin23:\
    \ Int = 2\n    var isPrimeCountMaxMinMin24: Int = 2\n    var isPrimeCountMaxMinMin25:\
    \ Int = 2\n    var isPrimeCountMaxMinMin26: Int = 2\n    var isPrimeCountMaxMinMin27:\
    \ Int = 2\n    var isPrimeCountMaxMinMin28: Int = 2\n    var isPrimeCountMaxMinMin29:\
    \ Int = 2\n    var isPrimeCountMaxMinMin30: Int = 2\n    var isPrimeCountMaxMinMin31:\
    \ Int = 2\n    var isPrimeCountMaxMinMin32: Int = 2\n    var isPri\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmppe8ppwun.swift:51:9: error: type annotation missing in pattern\n\
    \    var isPri\n        ^\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    var j = 1\n    var k = n\n    while i <= k {\n        while k % i ==\
    \ 0 {\n            factors.append(i)\n            k /= i\n        }\n        i\
    \ += 1\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n    var\
    \ primeFactors = factorization(n)\n    for factor in primeFactors {\n        factors.append(factor)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp1no5nqr4.swift:13:24: error: cannot find 'factorization' in scope\n\
    \    var primeFactors = factorization(n)\n                       ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    var j = 0\n    var isPrime = true\n    var isDivisor = true\n    var\
    \ isFactor = true\n    var isPrimeDivisor = true\n    var isPrimeFactor = true\n\
    \    var isPrimeDivisorFactor = true\n    var isPrimeFactorDivisor = true\n  \
    \  var isPrimeFactorDivisorDivisor = true\n    var isPrimeFactorDivisorFactor\
    \ = true\n    var isPrimeFactorDivisorDivisorFactor = true\n    var isPrimeFactorDivisorFactorDivisor\
    \ = true\n    var isPrimeFactorDivisorDivisorFactor = true\n    var isPrimeFactorDivisorFactorDivisor\
    \ = true\n    var isPrimeFactorDivisorDivisorFactor = true\n    var isPrimeFactorDivisorFactorDivisor\
    \ = true\n    var isPrimeFactorDivisorDivisorFactor = true\n    var isPrimeFactorDivisorFactorDivisor\
    \ = true\n    var isPrimeFactorDivisorDivisorFactor = true\n    var isPrimeFactorDivisorFactorDivisor\
    \ = true\n    var isPrimeFactorDivisorDivisorFactor = true\n    var isPrimeFactorDivisorFactorDivisor\
    \ = true\n    var isPrimeFactorDivisorDivisorFactor = true\n    var isPrimeFactorDivisorFactorDivisor\
    \ = true\n    var isPrimeFactorDivisorDivisorFactor = true\n    var isPrimeFactorDivisorFactorDivisor\
    \ = true\n    var isPrimeFactorDivisorDivisorFactor = true\n    var isPrimeFactorDivisorFactorDivisor\
    \ = true\n    var isPrimeFactorDivisorDivisorFactor = true\n    var isPrimeFactorDivisorFactorDivisor\
    \ = true\n    var isPrimeFactorDivisorDivisorFactor = true\n    var isPrimeFactorDivisorFactorDivisor\
    \ = true\n    var isPrimeFactorDivisorDivisorFactor = true\n    var isPrimeFactorDivisorFactorDivisor\
    \ = true\n    var isPrimeFactorDivisorDivisorFactor = true\n    var isPrimeFactorDivisorFactorDivisor\
    \ = true\n    var isPrimeFactorDivisorDivisorFactor = true\n    var isPrimeFactorDivisorFactorDivisor\
    \ = true\n    var isPrimeFactorDivisorDivisorFactor = true\n    var isPrimeFactorDivisorFactorDivisor\
    \ = true\n    var isPrimeFactorDivisorDivisorFactor = true\n    var isPrimeFactorDivisorFactorDivisor\
    \ = true\n    var isPrimeFactorDivisorDivisorFactor = true\n    var isPrimeFactorDivisorFactorDivisor\
    \ = true\n    var isPrimeFactorDivisorDivisorFactor = true\n    var isPrimeFactorDi\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpq1ckerre.swift:26:9: error: invalid redeclaration of 'isPrimeFactorDivisorDivisorFactor'\n\
    \    var isPrimeFactorDivisorDivisorFactor = true\n        ^\n/tmp/tmpq1ckerre.swift:24:9:\
    \ note: 'isPrimeFactorDivisorDivisorFactor' previously declared here\n    var\
    \ isPrimeFactorDivisorDivisorFactor = true\n        ^\n/tmp/tmpq1ckerre.swift:27:9:\
    \ error: invalid redeclaration of 'isPrimeFactorDivisorFactorDivisor'\n    var\
    \ isPrimeFactorDivisorFactorDivisor = true\n        ^\n/tmp/tmpq1ckerre.swift:25:9:\
    \ note: 'isPrimeFactorDivisorFactorDivisor' previously declared here\n    var\
    \ isPrimeFactorDivisorFactorDivisor = true\n        ^\n/tmp/tmpq1ckerre.swift:28:9:\
    \ error: invalid redeclaration of 'isPrimeFactorDivisorDivisorFactor'\n    var\
    \ isPrimeFactorDivisorDivisorFactor = true\n        ^\n/tmp/tmpq1ckerre.swift:24:9:\
    \ note: 'isPrimeFactorDivisorDivisorFactor' previously declared here\n    var\
    \ isPrimeFactorDivisorDivisorFactor = true\n        ^\n/tmp/tmpq1ckerre.swift:29:9:\
    \ error: invalid redeclaration of 'isPrimeFactorDivisorFactorDivisor'\n    var\
    \ isPrimeFactorDivisorFactorDivisor = true\n        ^\n/tmp/tmpq1ckerre.swift:25:9:\
    \ note: 'isPrimeFactorDivisorFactorDivisor' previously declared here\n    var\
    \ isPrimeFactorDivisorFactorDivisor = true\n        ^\n/tmp/tmpq1ckerre.swift:30:9:\
    \ error: invalid redeclaration of 'isPrimeFactorDivisorDivisorFactor'\n    var\
    \ isPrimeFactorDivisorDivisorFactor = true\n        ^\n/tmp/tmpq1ckerre.swift:24:9:\
    \ note: 'isPrimeFactorDivisorDivisorFactor' previously declared here\n    var\
    \ isPrimeFactorDivisorDivisorFactor = true\n        ^\n/tmp/tmpq1ckerre.swift:31:9:\
    \ error: invalid redeclaration of 'isPrimeFactorDivisorFactorDivisor'\n    var\
    \ isPrimeFactorDivisorFactorDivisor = true\n        ^\n/tmp/tmpq1ckerre.swift:25:9:\
    \ note: 'isPrimeFactorDivisorFactorDivisor' previously declared here\n    var\
    \ isPrimeFactorDivisorFactorDivisor = true\n        ^\n/tmp/tmpq1ckerre.swift:32:9:\
    \ error: invalid redeclaration of 'isPrimeFactorDivisorDivisorFactor'\n    var\
    \ isPrimeFactorDivisorDivisorFactor = true\n        ^\n/tmp/tmpq1ckerre.swift:24:"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var primeFactorization = [Int]()\n    var primeFactorizationCount = [Int]()\n\
    \    var isPrime = [Bool]()\n    var isPrimeCount = [Int]()\n    var isPrimeCountMax\
    \ = Int()\n    var isPrimeCountMaxIndex = Int()\n    var isPrimeCountMin = Int()\n\
    \    var isPrimeCountMinIndex = Int()\n    var isPrimeCountSum = Int()\n    var\
    \ isPrimeCountSumIndex = Int()\n    var isPrimeCountSumMax = Int()\n    var isPrimeCountSumMaxIndex\
    \ = Int()\n    var isPrimeCountSumMin = Int()\n    var isPrimeCountSumMinIndex\
    \ = Int()\n    var isPrimeCountSumSum = Int()\n    var isPrimeCountSumSumIndex\
    \ = Int()\n    var isPrimeCountSumSumMax = Int()\n    var isPrimeCountSumSumMaxIndex\
    \ = Int()\n    var isPrimeCountSumSumMin = Int()\n    var isPrimeCountSumSumMinIndex\
    \ = Int()\n    var isPrimeCountSumSumSum = Int()\n    var isPrimeCountSumSumSumIndex\
    \ = Int()\n    var isPrimeCountSumSumSumMax = Int()\n    var isPrimeCountSumSumSumMaxIndex\
    \ = Int()\n    var isPrimeCountSumSumSumMin = Int()\n    var isPrimeCountSumSumSumMinIndex\
    \ = Int()\n    var isPrimeCountSumSumSumSum = Int()\n    var isPrimeCountSumSumSumSumIndex\
    \ = Int()\n    var isPrimeCountSumSumSumSumMax = Int()\n    var isPrimeCountSumSumSumSumMaxIndex\
    \ = Int()\n    var isPrimeCountSumSumSumSumMin = Int()\n    var isPrimeCountSumSumSumSumMinIndex\
    \ = Int()\n    var isPrimeCountSumSumSumSumSum = Int()\n    var isPrimeCountSumSumSumSumSumIndex\
    \ = Int()\n    var isPrimeCountSumSumSumSumSumMax = Int()\n    var isPrimeCountSumSumSumSumSumMaxIndex\
    \ = Int()\n    var isPrimeCountSumSumSumSumSumMin = Int()\n    var isPrimeCountSumSumSumSumSumMinIndex\
    \ = Int()\n    var isPrimeCountSumSumSumSumSumSum = Int()\n    var isPrimeCountSumSumSumSumSumSumIndex\
    \ = Int()\n    var isPrimeCountSumSumSumSumSumSumMax = Int()\n\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp4r8jzr1_.swift:12:9: warning: initialization of variable 'factorization'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorization = [Int]()\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmp4r8jzr1_.swift:13:9:\
    \ warning: initialization of variable 'primeFactorization' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var primeFactorization\
    \ = [Int]()\n    ~~~~^~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp4r8jzr1_.swift:14:9: warning:\
    \ initialization of variable 'primeFactorizationCount' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var primeFactorizationCount\
    \ = [Int]()\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp4r8jzr1_.swift:15:9:\
    \ warning: initialization of variable 'isPrime' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var isPrime = [Bool]()\n    ~~~~^~~~~~~\n\
    \    _\n/tmp/tmp4r8jzr1_.swift:16:9: warning: initialization of variable 'isPrimeCount'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeCount = [Int]()\n    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmp4r8jzr1_.swift:17:9:\
    \ warning: initialization of variable 'isPrimeCountMax' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var isPrimeCountMax = Int()\n\
    \    ~~~~^~~~~~~~~~~~~~~\n    _\n/tmp/tmp4r8jzr1_.swift:18:9: warning: initialization\
    \ of variable 'isPrimeCountMaxIndex' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var isPrimeCountMaxIndex = Int()\n    ~~~~^~~~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmp4r8jzr1_.swift:19:9: warning: initialization of variable 'isPrimeCountMin'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeCountMin = Int()\n    ~~~~^~~~~~~~~~~~~~~\n    _\n/tmp/tmp4r8jzr1_.swift:20:9:\
    \ warning: initialization of variable 'isPrimeCountMinIndex' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var isPrimeCountMinIndex\
    \ = Int()\n    ~~~~^~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp4r8jzr1_.swift:21:9: warning:\
    \ initializatio"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var factorizationCount = [Int]()\n    var factorizationSum = 0\n    var isPrime\
    \ = true\n    var isPrimeSum = 0\n    var isPrimeSum2 = 0\n    var isPrimeSum3\
    \ = 0\n    var isPrimeSum4 = 0\n    var isPrimeSum5 = 0\n    var isPrimeSum6 =\
    \ 0\n    var isPrimeSum7 = 0\n    var isPrimeSum8 = 0\n    var isPrimeSum9 = 0\n\
    \    var isPrimeSum10 = 0\n    var isPrimeSum11 = 0\n    var isPrimeSum12 = 0\n\
    \    var isPrimeSum13 = 0\n    var isPrimeSum14 = 0\n    var isPrimeSum15 = 0\n\
    \    var isPrimeSum16 = 0\n    var isPrimeSum17 = 0\n    var isPrimeSum18 = 0\n\
    \    var isPrimeSum19 = 0\n    var isPrimeSum20 = 0\n    var isPrimeSum21 = 0\n\
    \    var isPrimeSum22 = 0\n    var isPrimeSum23 = 0\n    var isPrimeSum24 = 0\n\
    \    var isPrimeSum25 = 0\n    var isPrimeSum26 = 0\n    var isPrimeSum27 = 0\n\
    \    var isPrimeSum28 = 0\n    var isPrimeSum29 = 0\n    var isPrimeSum30 = 0\n\
    \    var isPrimeSum31 = 0\n    var isPrimeSum32 = 0\n    var isPrimeSum33 = 0\n\
    \    var isPrimeSum34 = 0\n    var isPrimeSum35 = 0\n    var isPrimeSum36 = 0\n\
    \    var isPrimeSum37 = 0\n    var isPrimeSum38 = 0\n    var isPrimeSum39 = 0\n\
    \    var isPrimeSum40 = 0\n    var isPrimeSum41 = 0\n    var isPrimeSum42 = 0\n\
    \    var isPrimeSum43 = 0\n    var isPrimeSum44 = 0\n    var isPrimeSum45 = 0\n\
    \    var isPrimeSum46 = 0\n    var isPrimeSum47 = 0\n    var isPrimeSum48 = 0\n\
    \    var isPrimeSum49 = 0\n    var isPrimeSum50 = 0\n    var isPrimeSum51 = 0\n\
    \    var isPrimeSum52 = 0\n    var isPrimeSum53 = 0\n    var isPrimeSum54 = 0\n\
    \    var isPrimeSum55 = 0\n    var isPrimeSum56 = 0\n    var isPrimeSum57 = 0\n\
    \    var isPrimeSum58 = 0\n    var isPrimeSum59 = 0\n    var isPrimeSum60 = 0\n\
    \    var isPrime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpuzku77as.swift:76:9: error: type annotation missing in pattern\n\
    \    var isPrime\n        ^\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            factors.append(i)\n\
    \            n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n      \
    \  factors.append(n)\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpi1tj22_o.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: -4
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    var factor = 1\n    while i <= n {\n        if n % i == 0 {\n     \
    \       factors.append(factor)\n            factor = 1\n        } else {\n   \
    \         factor *= i\n        }\n        i += 1\n    }\n    factors.append(factor)\n\
    \    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmpoqj7j_w8/tmpoqj7j_w8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5fd0381c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5fd0078b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5fd0078988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5fd00777b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoqj7j_w8                        0x000055a7dadef4c2 <unavailable> + 5314

    5    libc.so.6                          0x00002b5fd056d460 __libc_start_main +
    245

    6    tmpoqj7j_w8                        0x000055a7dadef119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var factorizationCount = [Int]()\n    var factorizationIndex = 0\n    var factorizationValue\
    \ = 1\n    var factorizationValueCount = 0\n    var factorizationValueIndex =\
    \ 0\n    var factorizationValueCountMax = 0\n    var factorizationValueCountMaxIndex\
    \ = 0\n    var factorizationValueCountMin = 0\n    var factorizationValueCountMinIndex\
    \ = 0\n    var factorizationValueCountMaxIndex = 0\n    var factorizationValueCountMinIndex\
    \ = 0\n    var factorizationValueCountMaxIndex = 0\n    var factorizationValueCountMinIndex\
    \ = 0\n    var factorizationValueCountMaxIndex = 0\n    var factorizationValueCountMinIndex\
    \ = 0\n    var factorizationValueCountMaxIndex = 0\n    var factorizationValueCountMinIndex\
    \ = 0\n    var factorizationValueCountMaxIndex = 0\n    var factorizationValueCountMinIndex\
    \ = 0\n    var factorizationValueCountMaxIndex = 0\n    var factorizationValueCountMinIndex\
    \ = 0\n    var factorizationValueCountMaxIndex = 0\n    var factorizationValueCountMinIndex\
    \ = 0\n    var factorizationValueCountMaxIndex = 0\n    var factorizationValueCountMinIndex\
    \ = 0\n    var factorizationValueCountMaxIndex = 0\n    var factorizationValueCountMinIndex\
    \ = 0\n    var factorizationValueCountMaxIndex = 0\n    var factorizationValueCountMinIndex\
    \ = 0\n    var factorizationValueCountMaxIndex = 0\n    var factorizationValueCountMinIndex\
    \ = 0\n    var factorizationValueCountMaxIndex = 0\n    var factorizationValueCountMinIndex\
    \ = 0\n    var factorizationValueCountMaxIndex = 0\n    var factorizationValueCountMinIndex\
    \ = 0\n    var factorizationValueCountMaxIndex = 0\n    var factorizationValueCountMinIndex\
    \ = 0\n    var factorizationValueCountMaxIndex = 0\n    var factorizationValueCountMinIndex\
    \ = 0\n    var factorizationValueCountMaxIndex = 0\n    var factorizationValueCountMinIndex\
    \ = 0\n    var factorizationValueCountMaxIndex = 0\n    var factorizationValueCountMinIndex\
    \ = 0\n    var factorizationValueCountMaxIndex = 0\n    var factorizationValueCountMinIndex\
    \ = 0\n    var factorizationValueCountMaxIndex = 0\n    var factorizationValueCountMinIndex\
    \ = 0\n    var factorizationValueCountMaxIndex = 0\n    var factorizationValueCountMinIndex\
    \ = 0\n    var factorizationValueCountMaxIndex = 0\n    var factorizationValueCountMinIndex\
    \ = 0\n    var factorizationValueCountMaxIndex = 0\n    var factorizationValueCountMinIndex\
    \ = 0\n    var factorizationValueCountMaxIndex = 0\n    var factorizationValueCountMinIndex\
    \ = 0\n    var factorizationValueCountMaxIndex = 0\n    var factorizationValueCountMinIndex\
    \ = 0\n    var factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp9_4d1ayg.swift:22:9: error: invalid redeclaration of 'factorizationValueCountMaxIndex'\n\
    \    var factorizationValueCountMaxIndex = 0\n        ^\n/tmp/tmp9_4d1ayg.swift:19:9:\
    \ note: 'factorizationValueCountMaxIndex' previously declared here\n    var factorizationValueCountMaxIndex\
    \ = 0\n        ^\n/tmp/tmp9_4d1ayg.swift:23:9: error: invalid redeclaration of\
    \ 'factorizationValueCountMinIndex'\n    var factorizationValueCountMinIndex =\
    \ 0\n        ^\n/tmp/tmp9_4d1ayg.swift:21:9: note: 'factorizationValueCountMinIndex'\
    \ previously declared here\n    var factorizationValueCountMinIndex = 0\n    \
    \    ^\n/tmp/tmp9_4d1ayg.swift:24:9: error: invalid redeclaration of 'factorizationValueCountMaxIndex'\n\
    \    var factorizationValueCountMaxIndex = 0\n        ^\n/tmp/tmp9_4d1ayg.swift:19:9:\
    \ note: 'factorizationValueCountMaxIndex' previously declared here\n    var factorizationValueCountMaxIndex\
    \ = 0\n        ^\n/tmp/tmp9_4d1ayg.swift:25:9: error: invalid redeclaration of\
    \ 'factorizationValueCountMinIndex'\n    var factorizationValueCountMinIndex =\
    \ 0\n        ^\n/tmp/tmp9_4d1ayg.swift:21:9: note: 'factorizationValueCountMinIndex'\
    \ previously declared here\n    var factorizationValueCountMinIndex = 0\n    \
    \    ^\n/tmp/tmp9_4d1ayg.swift:26:9: error: invalid redeclaration of 'factorizationValueCountMaxIndex'\n\
    \    var factorizationValueCountMaxIndex = 0\n        ^\n/tmp/tmp9_4d1ayg.swift:19:9:\
    \ note: 'factorizationValueCountMaxIndex' previously declared here\n    var factorizationValueCountMaxIndex\
    \ = 0\n        ^\n/tmp/tmp9_4d1ayg.swift:27:9: error: invalid redeclaration of\
    \ 'factorizationValueCountMinIndex'\n    var factorizationValueCountMinIndex =\
    \ 0\n        ^\n/tmp/tmp9_4d1ayg.swift:21:9: note: 'factorizationValueCountMinIndex'\
    \ previously declared here\n    var factorizationValueCountMinIndex = 0\n    \
    \    ^\n/tmp/tmp9_4d1ayg.swift:28:9: error: invalid redeclaration of 'factorizationValueCountMaxIndex'\n\
    \    var factorizationValueCountMaxIndex = 0\n        ^\n/tmp/tmp9_4d1ayg.swift:19:9:\
    \ note: 'factorizationValueCountMaxIndex' previously declared here\n    var factorizationVa"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var primeFactorization: [Int] = []\n    var isPrime: [Bool] = []\n    var\
    \ isPrimeCount: [Int] = []\n    var isPrimeCountMax: Int = 1\n    var isPrimeCountMin:\
    \ Int = 1\n    var isPrimeCountMinMax: Int = 1\n    var isPrimeCountMaxMin: Int\
    \ = 1\n    var isPrimeCountMinMaxMax: Int = 1\n    var isPrimeCountMinMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMinMaxMaxMaxMax: Int = 1\n    var isPrimeCountMinMaxMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMax: Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMax: Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n    var\
    \ isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n\
    \    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int =\
    \ 1\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n\
    \    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n   \
    \ var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n   \
    \ var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n   \
    \ var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = \n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp5wxz7r4r.swift:41:73: error: expected initial value after '='\n\
    \    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = \n \
    \                                                                       ^\n/tmp/tmp5wxz7r4r.swift:23:9:\
    \ error: invalid redeclaration of 'isPrimeCountMinMaxMaxMaxMax'\n    var isPrimeCountMinMaxMaxMaxMax:\
    \ Int = 1\n        ^\n/tmp/tmp5wxz7r4r.swift:22:9: note: 'isPrimeCountMinMaxMaxMaxMax'\
    \ previously declared here\n    var isPrimeCountMinMaxMaxMaxMax: Int = 1\n   \
    \     ^\n/tmp/tmp5wxz7r4r.swift:26:9: error: invalid redeclaration of 'isPrimeCountMinMaxMaxMaxMaxMaxMax'\n\
    \    var isPrimeCountMinMaxMaxMaxMaxMaxMax: Int = 1\n        ^\n/tmp/tmp5wxz7r4r.swift:25:9:\
    \ note: 'isPrimeCountMinMaxMaxMaxMaxMaxMax' previously declared here\n    var\
    \ isPrimeCountMinMaxMaxMaxMaxMaxMax: Int = 1\n        ^\n/tmp/tmp5wxz7r4r.swift:29:9:\
    \ error: invalid redeclaration of 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMax'\n\
    \    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n        ^\n/tmp/tmp5wxz7r4r.swift:28:9:\
    \ note: 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMax' previously declared here\n \
    \   var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n        ^\n/tmp/tmp5wxz7r4r.swift:31:9:\
    \ error: invalid redeclaration of 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax'\n\
    \    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n        ^\n/tmp/tmp5wxz7r4r.swift:30:9:\
    \ note: 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax' previously declared here\n\
    \    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n        ^\n/tmp/tmp5wxz7r4r.swift:34:9:\
    \ error: invalid redeclaration of 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax'\n\
    \    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n        ^\n\
    /tmp/tmp5wxz7r4r.swift:33:9: note: 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax'\
    \ previously declared here\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax:\
    \ Int = 1\n        ^\n/tmp/tmp5wxz7r4r.swift:35:9: error: invalid redeclaration\
    \ of 'isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax'\n    var isPrimeCountMinMaxMaxMaxMaxMaxMaxMaxMax"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    if n == 1 {\n        return [1]\n\
    \    }\n    var factors = [Int]()\n    var i = 2\n    var j = 1\n    while i *\
    \ j <= n {\n        if n % i == 0 {\n            factors.append(i)\n         \
    \   n /= i\n        }\n        if n % j == 0 {\n            factors.append(j)\n\
    \            n /= j\n        }\n        i += 1\n        j += 1\n    }\n    if\
    \ n > 1 {\n        factors.append(n)\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmptc0za96m.swift:21:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n/tmp/tmptc0za96m.swift:25:15:\
    \ error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n\
    \            n /= j\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var factorizationCount = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeCount\
    \ = [Int]()\n    var isPrimeSum = 0\n    var isPrimeSumCount = 0\n    var isPrimeSum2\
    \ = 0\n    var isPrimeSum2Count = 0\n    var isPrimeSum3 = 0\n    var isPrimeSum3Count\
    \ = 0\n    var isPrimeSum4 = 0\n    var isPrimeSum4Count = 0\n    var isPrimeSum5\
    \ = 0\n    var isPrimeSum5Count = 0\n    var isPrimeSum6 = 0\n    var isPrimeSum6Count\
    \ = 0\n    var isPrimeSum7 = 0\n    var isPrimeSum7Count = 0\n    var isPrimeSum8\
    \ = 0\n    var isPrimeSum8Count = 0\n    var isPrimeSum9 = 0\n    var isPrimeSum9Count\
    \ = 0\n    var isPrimeSum10 = 0\n    var isPrimeSum10Count = 0\n    var isPrimeSum11\
    \ = 0\n    var isPrimeSum11Count = 0\n    var isPrimeSum12 = 0\n    var isPrimeSum12Count\
    \ = 0\n    var isPrimeSum13 = 0\n    var isPrimeSum13Count = 0\n    var isPrimeSum14\
    \ = 0\n    var isPrimeSum14Count = 0\n    var isPrimeSum15 = 0\n    var isPrimeSum15Count\
    \ = 0\n    var isPrimeSum16 = 0\n    var isPrimeSum16Count = 0\n    var isPrimeSum17\
    \ = 0\n    var isPrimeSum17Count = 0\n    var isPrimeSum18 = 0\n    var isPrimeSum18Count\
    \ = 0\n    var isPrimeSum19 = 0\n    var isPrimeSum19Count = 0\n    var isPrimeSum20\
    \ = 0\n    var isPrimeSum20Count = 0\n    var isPrimeSum21 = 0\n    var isPrimeSum21Count\
    \ = 0\n    var isPrimeSum22 = 0\n    var isPrimeSum22Count = 0\n    var isPrimeSum23\
    \ = 0\n    var isPrimeSum23Count = 0\n    var isPrimeSum24 = 0\n    var isPrimeSum24Count\
    \ = 0\n    var isPrimeSum25 = 0\n    var isPrimeSum25Count = 0\n    var isPrimeSum26\
    \ = 0\n    var isPrimeSum26Count = 0\n    var isPrimeSum27 = 0\n    var isPrimeSum27Count\
    \ = 0\n    var isPrimeSum28 = 0\n    var isPrimeSum28Count = 0\n    var is\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpgxl6b0xy.swift:72:9: error: expected pattern\n    var is\n    \
    \    ^\n/tmp/tmpgxl6b0xy.swift:12:9: warning: initialization of variable 'factorization'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorization = [Int]()\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmpgxl6b0xy.swift:13:9:\
    \ warning: initialization of variable 'factorizationCount' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorizationCount\
    \ = [Int]()\n    ~~~~^~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpgxl6b0xy.swift:14:9: warning:\
    \ initialization of variable 'isPrime' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var isPrime = [Bool]()\n    ~~~~^~~~~~~\n\
    \    _\n/tmp/tmpgxl6b0xy.swift:15:9: warning: initialization of variable 'isPrimeCount'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeCount = [Int]()\n    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmpgxl6b0xy.swift:16:9:\
    \ warning: initialization of variable 'isPrimeSum' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var isPrimeSum = 0\n    ~~~~^~~~~~~~~~\n\
    \    _\n/tmp/tmpgxl6b0xy.swift:17:9: warning: initialization of variable 'isPrimeSumCount'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeSumCount = 0\n    ~~~~^~~~~~~~~~~~~~~\n    _\n/tmp/tmpgxl6b0xy.swift:18:9:\
    \ warning: initialization of variable 'isPrimeSum2' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var isPrimeSum2 = 0\n    ~~~~^~~~~~~~~~~\n\
    \    _\n/tmp/tmpgxl6b0xy.swift:19:9: warning: initialization of variable 'isPrimeSum2Count'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeSum2Count = 0\n    ~~~~^~~~~~~~~~~~~~~~\n    _\n/tmp/tmpgxl6b0xy.swift:20:9:\
    \ warning: initialization of variable 'isPrimeSum3' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var isPrimeSum3 = 0\n    ~~~~^~~~~~~~~~~\n\
    \    _\n/tmp/tmpgxl6b0xy.swift:21:9: warning: initialization of variable 'isPrimeSum3Count'\
    \ was n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var factorizationCount = 0\n    var isPrime = true\n    var isPrimeCount =\
    \ 0\n    var isPrimeFactorization = false\n    var isPrimeFactorizationCount =\
    \ 0\n    var isPrimeFactorizationPrime = false\n    var isPrimeFactorizationPrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorization = false\n    var isPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrime = false\n    var isPrimeFactorizationPrimeFactorizationPrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorization = false\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationCount = 0\n \
    \   var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime = false\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeCount =\
    \ 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeCount\
    \ = 0\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorization\
    \ = false\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorization\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp53qp9v5z.swift:31:9: error: invalid redeclaration of 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n        ^\n/tmp/tmp53qp9v5z.swift:29:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n        ^\n/tmp/tmp53qp9v5z.swift:32:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n        ^\n/tmp/tmp53qp9v5z.swift:30:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n        ^\n/tmp/tmp53qp9v5z.swift:37:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n        ^\n/tmp/tmp53qp9v5z.swift:35:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationCount\
    \ = 0\n        ^\n/tmp/tmp53qp9v5z.swift:38:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime'\n\
    \    var isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime\
    \ = false\n        ^\n/tmp/tmp53qp9v5z.swift:36:9: note: 'isPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrimeFactorizationPrime'\
    \ previously declared here\n    var isPrimeFactorizationPrimeFactorizationPrimeFacto"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            factorization\
    \ = append(factorization, i)\n            n /= i\n        }\n        i += 1\n\
    \    }\n    if n > 1 {\n        factorization = append(factorization, n)\n   \
    \ }\n    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp20t4ffw0.swift:16:29: error: cannot find 'append' in scope\n  \
    \          factorization = append(factorization, i)\n                        \
    \    ^~~~~~\n/tmp/tmp20t4ffw0.swift:17:15: error: left side of mutating operator\
    \ isn't mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n\
    /tmp/tmp20t4ffw0.swift:22:25: error: cannot find 'append' in scope\n        factorization\
    \ = append(factorization, n)\n                        ^~~~~~\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var factorization\
    \ = factorizationOfNumber(n)\n    for factor in factorization {\n        if factors.contains(factor)\
    \ {\n            factors[factor] += 1\n        } else {\n            factors.append(factor)\n\
    \        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp00xc2sbq.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var factorizationCount = [Int]()\n    var primeFactorization = [Int]()\n   \
    \ var primeFactorizationCount = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeCount\
    \ = [Int]()\n    var isPrimePrime = [Bool]()\n    var isPrimePrimeCount = [Int]()\n\
    \    var isPrimePrimePrime = [Bool]()\n    var isPrimePrimePrimeCount = [Int]()\n\
    \    var isPrimePrimePrimePrime = [Bool]()\n    var isPrimePrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimePrimePrimePrimePrime = [Bool]()\n    var isPrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimePrimePrimePrimePrimePrime = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimePrimePrimePrimePrimePrimePrime = [Bool]()\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimeCount = [Int]()\n    var isPrimePrimePrimePrimePrimePrimePrime\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimeCount = [Int]()\n \
    \   var isPrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n \
    \   var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = [Int]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrime\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = [Int]()\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = [Int]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n\
    \    var isPri\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpxq6wljpo.swift:30:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrime = [Bool]()\n        ^\n/tmp/tmpxq6wljpo.swift:28:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrime' previously declared here\n   \
    \ var isPrimePrimePrimePrimePrimePrimePrime = [Bool]()\n        ^\n/tmp/tmpxq6wljpo.swift:31:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = [Int]()\n        ^\n/tmp/tmpxq6wljpo.swift:29:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimeCount' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = [Int]()\n        ^\n/tmp/tmpxq6wljpo.swift:33:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = [Int]()\n        ^\n/tmp/tmpxq6wljpo.swift:29:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimeCount' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = [Int]()\n        ^\n/tmp/tmpxq6wljpo.swift:34:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n        ^\n/tmp/tmpxq6wljpo.swift:32:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimePrime' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n        ^\n/tmp/tmpxq6wljpo.swift:36:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n        ^\n/tmp/tmpxq6wljpo.swift:32:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimePrime' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrime = [Bool]()\n        ^\n/tmp/tmpxq6wljpo.swift:37:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = [Int]()\n        ^\n\
    /tmp/tmpxq6wljpo.swift:35:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: -4
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var i = 2\n    var factor = 2\n    while i <= n {\n        if n % i == 0 {\n\
    \            factorization[factor] = i\n            factor += 1\n        }\n \
    \       i += 1\n    }\n    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:613: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b286ecd0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b286e9c7561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b286e9c7286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b286e9c713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b286e9c6bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b286e7c67ec <unavailable> + 186348

    6    tmptrvo746d                        0x000055eb875dfd36 <unavailable> + 7478

    7    tmptrvo746d                        0x000055eb875df39b <unavailable> + 5019

    8    libc.so.6                          0x00002b286eebc460 __libc_start_main +
    245

    9    tmptrvo746d                        0x000055eb875df0b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    var p = 2\n    while i <= n {\n        if n % i == 0 {\n          \
    \  factors.append(i)\n            n /= i\n        } else {\n            i += 1\n\
    \        }\n    }\n    if n > 1 {\n        factors.append(n)\n    }\n    return\
    \ factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmphqpcxny6.swift:18:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    var j = 1\n    var k = n\n\n    while i <= k {\n        while k % i\
    \ == 0 {\n            factors.append(i)\n            k /= i\n        }\n     \
    \   i += 1\n    }\n\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var primes\
    \ = [Int]()\n    var primeFactorization = [Int]()\n    var primeFactorizationIndex\
    \ = 0\n    var primeFactorizationCount = 0\n    var factorizationIndex = 0\n \
    \   var factorizationCount = 0\n    var factorization = [1]\n    var factorizationIndex\
    \ = 0\n    var factorizationCount = 0\n    var factorization = [1]\n    var factorizationIndex\
    \ = 0\n    var factorizationCount = 0\n    var factorization = [1]\n    var factorizationIndex\
    \ = 0\n    var factorizationCount = 0\n    var factorization = [1]\n    var factorizationIndex\
    \ = 0\n    var factorizationCount = 0\n    var factorization = [1]\n    var factorizationIndex\
    \ = 0\n    var factorizationCount = 0\n    var factorization = [1]\n    var factorizationIndex\
    \ = 0\n    var factorizationCount = 0\n    var factorization = [1]\n    var factorizationIndex\
    \ = 0\n    var factorizationCount = 0\n    var factorization = [1]\n    var factorizationIndex\
    \ = 0\n    var factorizationCount = 0\n    var factorization = [1]\n    var factorizationIndex\
    \ = 0\n    var factorizationCount = 0\n    var factorization = [1]\n    var factorizationIndex\
    \ = 0\n    var factorizationCount = 0\n    var factorization = [1]\n    var factorizationIndex\
    \ = 0\n    var factorizationCount = 0\n    var factorization = [1]\n    var factorizationIndex\
    \ = 0\n    var factorizationCount = 0\n    var factorization = [1]\n    var factorizationIndex\
    \ = 0\n    var factorizationCount = 0\n    var factorization = [1]\n    var factorizationIndex\
    \ = 0\n    var factorizationCount = 0\n    var factorization = [1]\n    var factorizationIndex\
    \ = 0\n    var factorizationCount = 0\n    var factorization = [1]\n    var factorizationIndex\
    \ = 0\n    var factorizationCount = 0\n    var factorization = [1]\n    var factorizationIndex\
    \ = 0\n    var factorizationCount = 0\n    var factorization = [1]\n    var factorizationIndex\
    \ = 0\n    var factorizationCount = 0\n    var factorization = [1]\n    var factorizationIndex\
    \ = 0\n    var factorizationCount = 0\n    var factorization = [1]\n    var factorizationIndex\
    \ = 0\n    var factorizationCount = 0\n    var factorization = [1]\n    var factorizationIndex\
    \ = 0\n    var factorizationCount = 0\n    var factorization = [1]\n    var factorizationIndex\
    \ = 0\n    var factorizationCount = 0\n    var factorization = [1]\n    var factorizationIndex\
    \ = 0\n    var factorizationCount = 0\n    var factorization = [1]\n    var factorizationIndex\
    \ = 0\n    var factorizationCount = 0\n    var factorization = [1]\n    var factorizationIndex\
    \ = 0\n    var factorizationCount = 0\n    var factorization = [1]\n    var factorizationIndex\
    \ = 0\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpknv2n9v1.swift:96:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpknv2n9v1.swift:20:9: error: invalid redeclaration of 'factorizationIndex'\n\
    \    var factorizationIndex = 0\n        ^\n/tmp/tmpknv2n9v1.swift:17:9: note:\
    \ 'factorizationIndex' previously declared here\n    var factorizationIndex =\
    \ 0\n        ^\n/tmp/tmpknv2n9v1.swift:21:9: error: invalid redeclaration of 'factorizationCount'\n\
    \    var factorizationCount = 0\n        ^\n/tmp/tmpknv2n9v1.swift:18:9: note:\
    \ 'factorizationCount' previously declared here\n    var factorizationCount =\
    \ 0\n        ^\n/tmp/tmpknv2n9v1.swift:22:9: error: invalid redeclaration of 'factorization'\n\
    \    var factorization = [1]\n        ^\n/tmp/tmpknv2n9v1.swift:19:9: note: 'factorization'\
    \ previously declared here\n    var factorization = [1]\n        ^\n/tmp/tmpknv2n9v1.swift:23:9:\
    \ error: invalid redeclaration of 'factorizationIndex'\n    var factorizationIndex\
    \ = 0\n        ^\n/tmp/tmpknv2n9v1.swift:17:9: note: 'factorizationIndex' previously\
    \ declared here\n    var factorizationIndex = 0\n        ^\n/tmp/tmpknv2n9v1.swift:24:9:\
    \ error: invalid redeclaration of 'factorizationCount'\n    var factorizationCount\
    \ = 0\n        ^\n/tmp/tmpknv2n9v1.swift:18:9: note: 'factorizationCount' previously\
    \ declared here\n    var factorizationCount = 0\n        ^\n/tmp/tmpknv2n9v1.swift:25:9:\
    \ error: invalid redeclaration of 'factorization'\n    var factorization = [1]\n\
    \        ^\n/tmp/tmpknv2n9v1.swift:19:9: note: 'factorization' previously declared\
    \ here\n    var factorization = [1]\n        ^\n/tmp/tmpknv2n9v1.swift:26:9: error:\
    \ invalid redeclaration of 'factorizationIndex'\n    var factorizationIndex =\
    \ 0\n        ^\n/tmp/tmpknv2n9v1.swift:17:9: note: 'factorizationIndex' previously\
    \ declared here\n    var factorizationIndex = 0\n        ^\n/tmp/tmpknv2n9v1.swift:27:9:\
    \ error: invalid redeclaration of 'factorizationCount'\n    var factorizationCount\
    \ = 0\n        ^\n/tmp/tmpknv2n9v1.swift:18:9: note: 'factorizationCount' previously\
    \ declared here\n    var factorizationCount = 0\n        ^\n/tmp/tmpknv2n9v1.swift:28:9:\
    \ error: invalid redec"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var primeFactors\
    \ = [Int]()\n    var primeFactorsCount = 0\n    var isPrime = true\n    var isPrimeCount\
    \ = 0\n    var isPrimePrime = true\n    var isPrimePrimeCount = 0\n    var isPrimePrimePrime\
    \ = true\n    var isPrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrime =\
    \ true\n    var isPrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n \
    \   var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePri\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpfvk09q9t.swift:32:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpfvk09q9t.swift:30:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount' previously declared\
    \ here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n\
    /tmp/tmpfvk09q9t.swift:41:9: error: type annotation missing in pattern\n    var\
    \ isPrimePrimePrimePrimePri\n        ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var factorizationCount = 0\n    var factorizationIndex = 0\n    var factorizationMax\
    \ = Int(sqrt(Double(n)))\n    var factorizationMin = factorizationMax\n    var\
    \ factorizationMaxIndex = 0\n    var factorizationMinIndex = 0\n    var factorizationMaxCount\
    \ = 0\n    var factorizationMinCount = 0\n    var factorizationMaxSum = 0\n  \
    \  var factorizationMinSum = 0\n    var factorizationSum = 0\n    var factorizationSumCount\
    \ = 0\n    var factorizationSumIndex = 0\n    var factorizationSumMax = 0\n  \
    \  var factorizationSumMin = 0\n    var factorizationSumMaxIndex = 0\n    var\
    \ factorizationSumMinIndex = 0\n    var factorizationSumMaxCount = 0\n    var\
    \ factorizationSumMinCount = 0\n    var factorizationSumMaxSum = 0\n    var factorizationSumMinSum\
    \ = 0\n    var factorizationSumSum = 0\n    var factorizationSumSumCount = 0\n\
    \    var factorizationSumSumIndex = 0\n    var factorizationSumSumMax = 0\n  \
    \  var factorizationSumSumMin = 0\n    var factorizationSumSumMaxIndex = 0\n \
    \   var factorizationSumSumMinIndex = 0\n    var factorizationSumSumMaxCount =\
    \ 0\n    var factorizationSumSumMinCount = 0\n    var factorizationSumSumMaxSum\
    \ = 0\n    var factorizationSumSumMinSum = 0\n    var factorizationSumSumSum =\
    \ 0\n    var factorizationSumSumSumCount = 0\n    var factorizationSumSumSumIndex\
    \ = 0\n    var factorizationSumSumSumMax = 0\n    var factorizationSumSumSumMin\
    \ = 0\n    var factorizationSumSumSumMaxIndex = 0\n    var factorizationSumSumSumMinIndex\
    \ = 0\n    var factorizationSumSumSumMaxCount = 0\n    var factorizationSumSumSumMinCount\
    \ = 0\n    var factorizationSumSumSumMaxSum = 0\n    var factorizationSumSumSumMinSum\
    \ = 0\n    var factorizationSumSumSumSum = 0\n    var factorizationSumSumSumSumCount\
    \ = 0\n    var factorizationSumSumSumSumIndex = 0\n    var factorizationSumSumSumSumMax\
    \ = 0\n    var factorizationSumSumSumSumMin = 0\n    var factorizationSumSumSumSumMaxIndex\
    \ = 0\n    var factorizationSumSumSumSumMinIndex = 0\n    var factorizationSumSumSumMaxCount\
    \ = 0\n    var factorizationSumSumSumMinCount = 0\n    var factorizationSumSumSumMaxSum\
    \ = 0\n    var factorizationSumSumSumMinSum = 0\n    var factorizationSumSumSumSum\
    \ = 0\n    var factorizationSumSumSumSumCount = 0\n    var factorizationSumSumSumSumIndex\
    \ = 0\n    var factorizationSumSumSumSumMax = 0\n    var factor\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpol7cngbx.swift:15:32: error: cannot find 'sqrt' in scope\n    var\
    \ factorizationMax = Int(sqrt(Double(n)))\n                               ^~~~\n\
    /tmp/tmpol7cngbx.swift:63:9: error: invalid redeclaration of 'factorizationSumSumSumMaxCount'\n\
    \    var factorizationSumSumSumMaxCount = 0\n        ^\n/tmp/tmpol7cngbx.swift:52:9:\
    \ note: 'factorizationSumSumSumMaxCount' previously declared here\n    var factorizationSumSumSumMaxCount\
    \ = 0\n        ^\n/tmp/tmpol7cngbx.swift:64:9: error: invalid redeclaration of\
    \ 'factorizationSumSumSumMinCount'\n    var factorizationSumSumSumMinCount = 0\n\
    \        ^\n/tmp/tmpol7cngbx.swift:53:9: note: 'factorizationSumSumSumMinCount'\
    \ previously declared here\n    var factorizationSumSumSumMinCount = 0\n     \
    \   ^\n/tmp/tmpol7cngbx.swift:65:9: error: invalid redeclaration of 'factorizationSumSumSumMaxSum'\n\
    \    var factorizationSumSumSumMaxSum = 0\n        ^\n/tmp/tmpol7cngbx.swift:54:9:\
    \ note: 'factorizationSumSumSumMaxSum' previously declared here\n    var factorizationSumSumSumMaxSum\
    \ = 0\n        ^\n/tmp/tmpol7cngbx.swift:66:9: error: invalid redeclaration of\
    \ 'factorizationSumSumSumMinSum'\n    var factorizationSumSumSumMinSum = 0\n \
    \       ^\n/tmp/tmpol7cngbx.swift:55:9: note: 'factorizationSumSumSumMinSum' previously\
    \ declared here\n    var factorizationSumSumSumMinSum = 0\n        ^\n/tmp/tmpol7cngbx.swift:67:9:\
    \ error: invalid redeclaration of 'factorizationSumSumSumSum'\n    var factorizationSumSumSumSum\
    \ = 0\n        ^\n/tmp/tmpol7cngbx.swift:56:9: note: 'factorizationSumSumSumSum'\
    \ previously declared here\n    var factorizationSumSumSumSum = 0\n        ^\n\
    /tmp/tmpol7cngbx.swift:68:9: error: invalid redeclaration of 'factorizationSumSumSumSumCount'\n\
    \    var factorizationSumSumSumSumCount = 0\n        ^\n/tmp/tmpol7cngbx.swift:57:9:\
    \ note: 'factorizationSumSumSumSumCount' previously declared here\n    var factorizationSumSumSumSumCount\
    \ = 0\n        ^\n/tmp/tmpol7cngbx.swift:69:9: error: invalid redeclaration of\
    \ 'factorizationSumSumSumSumIndex'\n    var factorizationSumSumSumSumIndex = 0\n\
    \        ^\n/tmp/tmpol7cngbx.swift:58:9: n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var i = 2\n    var j = 1\n    var factor = 1\n    while i <= n {\n        while\
    \ n % i == 0 {\n            factorization[j] = i\n            n /= i\n       \
    \     j++\n        }\n        i += 1\n    }\n    if n > 1 {\n        factorization[j]\
    \ = n\n    }\n    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmperej_zpn.swift:19:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n/tmp/tmperej_zpn.swift:20:14:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  j++\n             ^~\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var factors = [1]\n    var i = 2\n    while i * i <= n {\n        if n % i ==\
    \ 0 {\n            factors.append(i)\n            factors.append(n / i)\n    \
    \        factorization = factorization[..<factorization.count]\n            factorization[factorization.count\
    \ - 1] = factorization[factorization.count - 1] * factors[factors.count - 1]\n\
    \            factors = factors[..<factors.count]\n            factors.append(1)\n\
    \            factors.append(n / i)\n            factorization = factorization[..<factorization.count]\n\
    \            factorization[factorization.count - 1] = factorization[factorization.count\
    \ - 1] * factors[factors.count - 1]\n            factors = factors[..<factors.count]\n\
    \            factors.append(1)\n            factors.append(1)\n            factorization\
    \ = factorization[..<factorization.count]\n            factorization[factorization.count\
    \ - 1] = factorization[factorization.count - 1] * factors[factors.count - 1]\n\
    \            factors = factors[..<factors.count]\n            factors.append(1)\n\
    \            factors.append(1)\n            factorization = factorization[..<factorization.count]\n\
    \            factorization[factorization.count - 1] = factorization[factorization.count\
    \ - 1] * factors[factors.count - 1]\n            factors = factors[..<factors.count]\n\
    \            factors.append(1)\n            factors.append(1)\n            factorization\
    \ = factorization[..<factorization.count]\n            factorization[factorization.count\
    \ - 1] = factorization[factorization.count - 1] * factors[factors.count - 1]\n\
    \            factors = factors[..<factors.count]\n            factors.append(1)\n\
    \            factors.append(1)\n            factorization = factorization[..<factorization.count]\n\
    \            factorization[factorization.count - 1] = factorization[factorization.count\
    \ - 1] * factors[factors.count - 1]\n            factors = factors[..<factors.count]\n\
    \            factors.append(1)\n            factors.append(1)\n            factorization\
    \ = factorization[..<factorization.count]\n            factorization[factorization.count\
    \ - 1] = factorization[factorization.count - 1] * factors[factors.count - 1]\n\
    \            factors = factors[..<factors.count]\n            factors.append(1)\n\
    \            factors.append(1)\n            factorization = factorization[..<factorization.count]\n\
    \            factorization[factorization.count - 1] = factorization[factorization.count\
    \ - 1] * factors[factors.\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpord4fhqg.swift:55:110: error: expected member name following '.'\n\
    \            factorization[factorization.count - 1] = factorization[factorization.count\
    \ - 1] * factors[factors.\n                                                  \
    \                                                           ^\n/tmp/tmpord4fhqg.swift:56:1:\
    \ error: expected ']' in expression list\n}\n^\n/tmp/tmpord4fhqg.swift:55:102:\
    \ note: to match this opening '['\n            factorization[factorization.count\
    \ - 1] = factorization[factorization.count - 1] * factors[factors.\n         \
    \                                                                            \
    \                ^\n/tmp/tmpord4fhqg.swift:78:38: error: expected '}' at end of\
    \ brace statement\nassert(factorize(n: 18) == [2, 3, 3])\n                   \
    \                  ^\n/tmp/tmpord4fhqg.swift:15:22: note: to match this opening\
    \ '{'\n    while i * i <= n {\n                     ^\n/tmp/tmpord4fhqg.swift:78:38:\
    \ error: expected '}' at end of brace statement\nassert(factorize(n: 18) == [2,\
    \ 3, 3])\n                                     ^\n/tmp/tmpord4fhqg.swift:11:33:\
    \ note: to match this opening '{'\nfunc factorize(n: Int) -> [Int] {\n       \
    \                         ^\n/tmp/tmpord4fhqg.swift:19:42: error: cannot assign\
    \ value of type 'ArraySlice<Int>' to type '[Int]'\n            factorization =\
    \ factorization[..<factorization.count]\n                            ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpord4fhqg.swift:21:30: error: cannot assign value of type 'ArraySlice<Int>'\
    \ to type '[Int]'\n            factors = factors[..<factors.count]\n         \
    \             ~~~~~~~^~~~~~~~~~~~~~~~~~\n/tmp/tmpord4fhqg.swift:24:42: error:\
    \ cannot assign value of type 'ArraySlice<Int>' to type '[Int]'\n            factorization\
    \ = factorization[..<factorization.count]\n                            ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpord4fhqg.swift:26:30: error: cannot assign value of type 'ArraySlice<Int>'\
    \ to type '[Int]'\n            factors = factors[..<factors.count]\n         \
    \             ~~~~~~~^~~~~~~~~~~~~~~~~~\n/tmp/tmp"
  stdout: ''
  timestamp: 1659824953
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    var j = 1\n    while i * j <= n {\n        if n % i == 0 {\n      \
    \      factors.append(i)\n            n /= i\n        }\n        if n % j == 0\
    \ {\n            factors.append(j)\n            n /= j\n        }\n        i +=\
    \ 1\n        j += 1\n    }\n    if n > 1 {\n        factors.append(n)\n    }\n\
    \    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp5r81h9nu.swift:18:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n/tmp/tmp5r81h9nu.swift:22:15:\
    \ error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n\
    \            n /= j\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var primes = [Int]()\n    var primeFactorization = [Int]()\n    var isPrime\
    \ = [Bool]()\n    var isPrimeFactorization = [Bool]()\n    var isPrimeFactorizationInOrder\
    \ = [Bool]()\n    var isPrimeFactorizationInOrderInOrder = [Bool]()\n    var isPrimeFactorizationInOrderInOrderInOrder\
    \ = [Bool]()\n    var isPrimeFactorizationInOrderInOrderInOrderInOrder = [Bool]()\n\
    \    var isPrimeFactorizationInOrderInOrderInOrderInOrderInOrder = [Bool]()\n\
    \    var isPrimeFactorizationInOrderInOrderInOrderInOrderInOrderInOrder = [Bool]()\n\
    \    var isPrimeFactorizationInOrderInOrderInOrderInOrderInOrderInOrderInOrder\
    \ = [Bool]()\n    var isPrimeFactorizationInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrder\
    \ = [Bool]()\n    var isPrimeFactorizationInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrder\
    \ = [Bool]()\n    var isPrimeFactorizationInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrder\
    \ = [Bool]()\n    var isPrimeFactorizationInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrder\
    \ = [Bool]()\n    var isPrimeFactorizationInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrder\
    \ = [Bool]()\n    var isPrimeFactorizationInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrder\
    \ = [Bool]()\n    var isPrimeFactorizationInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrder\
    \ = [Bool]()\n    var isPrimeFactorizationInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrder\
    \ = [Bool]()\n    var isPrimeFactorizationInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrder\
    \ = [Bool]()\n    var isPrimeFactorizationInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrder\
    \ = [Bool]()\n    var isPrimeFactorizationInOrderInOrderInOrderIn\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpex_ttf24.swift:27:9: error: invalid redeclaration of 'isPrimeFactorizationInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrder'\n\
    \    var isPrimeFactorizationInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrder\
    \ = [Bool]()\n        ^\n/tmp/tmpex_ttf24.swift:26:9: note: 'isPrimeFactorizationInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrder'\
    \ previously declared here\n    var isPrimeFactorizationInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrder\
    \ = [Bool]()\n        ^\n/tmp/tmpex_ttf24.swift:29:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrder'\n\
    \    var isPrimeFactorizationInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrder\
    \ = [Bool]()\n        ^\n/tmp/tmpex_ttf24.swift:28:9: note: 'isPrimeFactorizationInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrder'\
    \ previously declared here\n    var isPrimeFactorizationInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrder\
    \ = [Bool]()\n        ^\n/tmp/tmpex_ttf24.swift:30:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrder'\n\
    \    var isPrimeFactorizationInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrder\
    \ = [Bool]()\n        ^\n/tmp/tmpex_ttf24.swift:28:9: note: 'isPrimeFactorizationInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrder'\
    \ previously declared here\n    var isPrimeFactorizationInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrder\
    \ = [Bool]()\n        ^\n/tmp/tmpex_ttf24.swift:31:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrder'\n\
    \    var isPrimeFactorizationInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrderInOrder\
    \ = [Bool]()\n        ^\n/tmp/tmpex_ttf24.swift:28:9: note: 'isPrimeFactorizationInOrder"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var i = 2\n    var factor = 1\n    while i < n {\n        while n % i == 0\
    \ {\n            factor *= i\n            factorization.append(factor)\n     \
    \       n /= i\n        }\n        i += 1\n    }\n    if n != 1 {\n        factorization.append(n)\n\
    \    }\n    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpl752oay9.swift:19:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            factors.append(i)\n\
    \            n /= i\n        }\n        i += 1\n    }\n    if n != 1 {\n     \
    \   factors.append(n)\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp981gk_1q.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var factorizationCount = 1\n    var isPrime = true\n    var isPrimeCount = 0\n\
    \    var isPrimePrime = true\n    var isPrimePrimeCount = 0\n    var isPrimePrimePrime\
    \ = true\n    var isPrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrime =\
    \ true\n    var isPrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount =\
    \ 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount =\
    \ 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePri\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp0czjtqpo.swift:31:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmp0czjtqpo.swift:29:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount' previously declared\
    \ here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n\
    /tmp/tmp0czjtqpo.swift:32:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrime'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n        ^\n/tmp/tmp0czjtqpo.swift:30:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrime' previously declared\
    \ here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n     \
    \   ^\n/tmp/tmp0czjtqpo.swift:41:9: error: type annotation missing in pattern\n\
    \    var isPrimePri\n        ^\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var factorizationCount = 0\n    var factorizationIndex = 0\n    var factorizationMax\
    \ = 0\n    var factorizationMin = 0\n    var factorizationSum = 0\n    var factorizationProduct\
    \ = 1\n    var factorizationProductMax = 0\n    var factorizationProductMin =\
    \ 0\n    var factorizationProductSum = 0\n    var factorizationProductProduct\
    \ = 1\n    var factorizationProductProductMax = 0\n    var factorizationProductProductMin\
    \ = 0\n    var factorizationProductProductSum = 0\n    var factorizationProductProductProduct\
    \ = 1\n    var factorizationProductProductProductMax = 0\n    var factorizationProductProductProductMin\
    \ = 0\n    var factorizationProductProductProductSum = 0\n    var factorizationProductProductProductProduct\
    \ = 1\n    var factorizationProductProductProductProductMax = 0\n    var factorizationProductProductProductProductMin\
    \ = 0\n    var factorizationProductProductProductProductSum = 0\n    var factorizationProductProductProductProduct\
    \ = 1\n    var factorizationProductProductProductProductMax = 0\n    var factorizationProductProductProductProductMin\
    \ = 0\n    var factorizationProductProductProductProductSum = 0\n    var factorizationProductProductProductProductProduct\
    \ = 1\n    var factorizationProductProductProductProductProductMax = 0\n    var\
    \ factorizationProductProductProductProductProductMin = 0\n    var factorizationProductProductProductProductProductSum\
    \ = 0\n    var factorizationProductProductProductProductProductProduct = 1\n \
    \   var factorizationProductProductProductProductProductMax = 0\n    var factorizationProductProductProductProductProductMin\
    \ = 0\n    var factorizationProductProductProductProductProductSum = 0\n    var\
    \ factorizationProductProductProductProductProductProduct = 1\n    var factorizationProductProductProductProductProductMax\
    \ = 0\n    var factorizationProductProductProductProductProductMin = 0\n    var\
    \ factorizationProductProductProductProductProductSum = 0\n    var factorizationProductProductProductProductProductProduct\
    \ = 1\n    var factorizationProductProductProductProductProductMax = 0\n    var\
    \ factorizationProductProductProductProductProductMin = 0\n    var factorizationProductProductProductProductProductSum\
    \ = 0\n    var factorizationProductProductProductProductProductProduct = 1\n \
    \   var factorizationProductProductProductProductProductMax = 0\n    var factorizationProductProductProductProductProductMin\
    \ = 0\n    var factorizationProductProductProductProductProductSum = 0\n    var\
    \ factorizationProductProductProductProductProductProduct = 1\n    var factorizationProductProductProductProductProductMax\
    \ = 0\n    var factorizationProductProductProductProductProductMin = 0\n    var\
    \ factorizationProductProductProductProductProductSum = 0\n    var factorizationProductProductProductProductProductProduct\
    \ = 1\n    var factorizationProductProductProductProductProductMax = 0\n    var\
    \ factorizationProductProductProductProductProductMin = 0\n    var factorizationProductProductProductProductProduct\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpiun8392h.swift:34:9: error: invalid redeclaration of 'factorizationProductProductProductProduct'\n\
    \    var factorizationProductProductProductProduct = 1\n        ^\n/tmp/tmpiun8392h.swift:30:9:\
    \ note: 'factorizationProductProductProductProduct' previously declared here\n\
    \    var factorizationProductProductProductProduct = 1\n        ^\n/tmp/tmpiun8392h.swift:35:9:\
    \ error: invalid redeclaration of 'factorizationProductProductProductProductMax'\n\
    \    var factorizationProductProductProductProductMax = 0\n        ^\n/tmp/tmpiun8392h.swift:31:9:\
    \ note: 'factorizationProductProductProductProductMax' previously declared here\n\
    \    var factorizationProductProductProductProductMax = 0\n        ^\n/tmp/tmpiun8392h.swift:36:9:\
    \ error: invalid redeclaration of 'factorizationProductProductProductProductMin'\n\
    \    var factorizationProductProductProductProductMin = 0\n        ^\n/tmp/tmpiun8392h.swift:32:9:\
    \ note: 'factorizationProductProductProductProductMin' previously declared here\n\
    \    var factorizationProductProductProductProductMin = 0\n        ^\n/tmp/tmpiun8392h.swift:37:9:\
    \ error: invalid redeclaration of 'factorizationProductProductProductProductSum'\n\
    \    var factorizationProductProductProductProductSum = 0\n        ^\n/tmp/tmpiun8392h.swift:33:9:\
    \ note: 'factorizationProductProductProductProductSum' previously declared here\n\
    \    var factorizationProductProductProductProductSum = 0\n        ^\n/tmp/tmpiun8392h.swift:43:9:\
    \ error: invalid redeclaration of 'factorizationProductProductProductProductProductMax'\n\
    \    var factorizationProductProductProductProductProductMax = 0\n        ^\n\
    /tmp/tmpiun8392h.swift:39:9: note: 'factorizationProductProductProductProductProductMax'\
    \ previously declared here\n    var factorizationProductProductProductProductProductMax\
    \ = 0\n        ^\n/tmp/tmpiun8392h.swift:44:9: error: invalid redeclaration of\
    \ 'factorizationProductProductProductProductProductMin'\n    var factorizationProductProductProductProductProductMin\
    \ = 0\n        ^\n/tmp/tmpiun8392h.swift:40:9: note: 'factorizationProductProductProductProductProductMin'\
    \ previousl"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var factorizationCount = 0\n    var factorizationIndex = 0\n    var factorizationMax\
    \ = 0\n    var factorizationMin = Int64(Int.max)\n    var factorizationSum = Int64(Int.max)\n\
    \    var factorizationProduct = Int64(Int.max)\n    var factorizationProductMin\
    \ = Int64(Int.max)\n    var factorizationProductMax = Int64(Int.max)\n    var\
    \ factorizationProductSum = Int64(Int.max)\n    var factorizationProductSumMin\
    \ = Int64(Int.max)\n    var factorizationProductSumMax = Int64(Int.max)\n    var\
    \ factorizationProductSumMinMax = Int64(Int.max)\n    var factorizationProductSumMinMaxSum\
    \ = Int64(Int.max)\n    var factorizationProductSumMinMaxSumMin = Int64(Int.max)\n\
    \    var factorizationProductSumMinMaxSumMinMax = Int64(Int.max)\n    var factorizationProductSumMinMaxSumMinMaxSum\
    \ = Int64(Int.max)\n    var factorizationProductSumMinMaxSumMinMaxSumMin = Int64(Int.max)\n\
    \    var factorizationProductSumMinMaxSumMinMaxSumMinMax = Int64(Int.max)\n  \
    \  var factorizationProductSumMinMaxSumMinMaxSumMinMaxSum = Int64(Int.max)\n \
    \   var factorizationProductSumMinMaxSumMinMaxSumMinMaxSumMin = Int64(Int.max)\n\
    \    var factorizationProductSumMinMaxSumMinMaxSumMinMaxSumMinMax = Int64(Int.max)\n\
    \    var factorizationProductSumMinMaxSumMinMaxSumMinMaxSumMinMaxSum = Int64(Int.max)\n\
    \    var factorizationProductSumMinMaxSumMinMaxSumMinMaxSumMinMaxSumMin = Int64(Int.max)\n\
    \    var factorizationProductSumMinMaxSumMinMaxSumMinMaxSumMinMaxSumMinMax = Int64(Int.max)\n\
    \    var factorizationProductSumMinMaxSumMinMaxSumMinMaxSumMinMaxSumMinMaxSum\
    \ = Int64(Int.max)\n    var factorizationProductSumMinMaxSumMinMaxSumMinMaxSumMinMaxSumMinMaxSumMin\
    \ = Int64(Int.max)\n    var factorizationProductSumMinMaxSumMinMaxSumMinMaxSumMinMaxSumMinMaxSumMinMax\
    \ = Int64(Int.max)\n    var factorizationProductSumMinMaxSumMinMaxSumMinMaxSumMinMaxSumMinMaxSumMinMaxSum\
    \ = Int64(Int.max)\n    var factorizationProductSumMinMaxSumMinMaxSumMinMaxSumMinMaxSumMin\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpwmqdu4ta.swift:41:9: error: type annotation missing in pattern\n\
    \    var factorizationProductSumMinMaxSumMinMaxSumMinMaxSumMinMaxSumMin\n    \
    \    ^\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var primeFactorization = [Int]()\n    var primeFactorizationCount = [Int]()\n\
    \    var isPrime = [Bool]()\n    var isPrimeCount = [Int]()\n    var isPrimeCountMax\
    \ = Int()\n    var isPrimeCountMaxIndex = Int()\n    var isPrimeCountMin = Int()\n\
    \    var isPrimeCountMinIndex = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMinIndex = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMinIndex = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMinIndex = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMinIndex = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMinIndex = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMinIndex = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMinIndex = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMinIndex = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMinIndex = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMinIndex = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMinIndex = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMinIndex = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMinIndex = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMinIndex = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMinIndex = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMinIndex = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMinIndex = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMinIndex = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMinIndex = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMinIndex = Int()\n    var isPrimeCountMaxIndex = Int()\n\
    \    var isPrimeCountMinIndex = Int()\n    var isPrimeCountMax\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpib7icnxe.swift:21:9: error: invalid redeclaration of 'isPrimeCountMaxIndex'\n\
    \    var isPrimeCountMaxIndex = Int()\n        ^\n/tmp/tmpib7icnxe.swift:18:9:\
    \ note: 'isPrimeCountMaxIndex' previously declared here\n    var isPrimeCountMaxIndex\
    \ = Int()\n        ^\n/tmp/tmpib7icnxe.swift:22:9: error: invalid redeclaration\
    \ of 'isPrimeCountMinIndex'\n    var isPrimeCountMinIndex = Int()\n        ^\n\
    /tmp/tmpib7icnxe.swift:20:9: note: 'isPrimeCountMinIndex' previously declared\
    \ here\n    var isPrimeCountMinIndex = Int()\n        ^\n/tmp/tmpib7icnxe.swift:23:9:\
    \ error: invalid redeclaration of 'isPrimeCountMaxIndex'\n    var isPrimeCountMaxIndex\
    \ = Int()\n        ^\n/tmp/tmpib7icnxe.swift:18:9: note: 'isPrimeCountMaxIndex'\
    \ previously declared here\n    var isPrimeCountMaxIndex = Int()\n        ^\n\
    /tmp/tmpib7icnxe.swift:24:9: error: invalid redeclaration of 'isPrimeCountMinIndex'\n\
    \    var isPrimeCountMinIndex = Int()\n        ^\n/tmp/tmpib7icnxe.swift:20:9:\
    \ note: 'isPrimeCountMinIndex' previously declared here\n    var isPrimeCountMinIndex\
    \ = Int()\n        ^\n/tmp/tmpib7icnxe.swift:25:9: error: invalid redeclaration\
    \ of 'isPrimeCountMaxIndex'\n    var isPrimeCountMaxIndex = Int()\n        ^\n\
    /tmp/tmpib7icnxe.swift:18:9: note: 'isPrimeCountMaxIndex' previously declared\
    \ here\n    var isPrimeCountMaxIndex = Int()\n        ^\n/tmp/tmpib7icnxe.swift:26:9:\
    \ error: invalid redeclaration of 'isPrimeCountMinIndex'\n    var isPrimeCountMinIndex\
    \ = Int()\n        ^\n/tmp/tmpib7icnxe.swift:20:9: note: 'isPrimeCountMinIndex'\
    \ previously declared here\n    var isPrimeCountMinIndex = Int()\n        ^\n\
    /tmp/tmpib7icnxe.swift:27:9: error: invalid redeclaration of 'isPrimeCountMaxIndex'\n\
    \    var isPrimeCountMaxIndex = Int()\n        ^\n/tmp/tmpib7icnxe.swift:18:9:\
    \ note: 'isPrimeCountMaxIndex' previously declared here\n    var isPrimeCountMaxIndex\
    \ = Int()\n        ^\n/tmp/tmpib7icnxe.swift:28:9: error: invalid redeclaration\
    \ of 'isPrimeCountMinIndex'\n    var isPrimeCountMinIndex = Int()\n        ^\n\
    /tmp/tmpib7icnxe.swift:20:9: note: 'isPrimeCountMinIndex' previously declared\
    \ here\n    var"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var primes\
    \ = [Int]()\n    var primeFactorization = [Int]()\n    var factorization = [Int]()\n\
    \    var primeFactorizationIndex = 0\n    var factorizationIndex = 0\n    var\
    \ isPrime = true\n    var isPrimeIndex = 0\n    var isPrimeFactorization = false\n\
    \    var isPrimeFactorizationIndex = 0\n    var isPrimeFactorizationPrime = false\n\
    \    var isPrimeFactorizationPrimeIndex = 0\n    var isPrimeFactorizationFactorization\
    \ = false\n    var isPrimeFactorizationFactorizationIndex = 0\n    var isPrimeFactorizationFactorizationPrime\
    \ = false\n    var isPrimeFactorizationFactorizationPrimeIndex = 0\n    var isPrimeFactorizationFactorizationFactorization\
    \ = false\n    var isPrimeFactorizationFactorizationFactorizationIndex = 0\n \
    \   var isPrimeFactorizationFactorizationFactorizationPrime = false\n    var isPrimeFactorizationFactorizationFactorizationPrimeIndex\
    \ = 0\n    var isPrimeFactorizationFactorizationFactorizationFactorization = false\n\
    \    var isPrimeFactorizationFactorizationFactorizationFactorizationIndex = 0\n\
    \    var isPrimeFactorizationFactorizationFactorizationFactorizationPrime = false\n\
    \    var isPrimeFactorizationFactorizationFactorizationFactorizationPrimeIndex\
    \ = 0\n    var isPrimeFactorizationFactorizationFactorizationFactorizationFactorization\
    \ = false\n    var isPrimeFactorizationFactorizationFactorizationFactorizationFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationFactorizationFactorizationFactorizationFactorizationPrime\
    \ = false\n    var isPrimeFactorizationFactorizationFactorizationFactorizationFactorizationPrimeIndex\
    \ = 0\n    var isPrimeFactorizationFactorizationFactorizationFactorizationFactorizationFactorization\
    \ = false\n    var isPrimeFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationPrime\
    \ = false\n    var isPrimeFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationPrimeIndex\
    \ = 0\n    var isPrimeFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationFactorization\
    \ = false\n    var isPrimeFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationIndex\
    \ = 0\n    var isPrimeFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationPrime\
    \ = false\n    var isPrimeFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationPrimeIndex\
    \ = 0\n    var isPrimeFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationFactorization\
    \ = false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpftzmaiwp.swift:12:9: warning: initialization of variable 'factors'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factors = [Int]()\n    ~~~~^~~~~~~\n    _\n/tmp/tmpftzmaiwp.swift:13:9:\
    \ warning: initialization of variable 'primes' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var primes = [Int]()\n    ~~~~^~~~~~\n\
    \    _\n/tmp/tmpftzmaiwp.swift:14:9: warning: initialization of variable 'primeFactorization'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var primeFactorization = [Int]()\n    ~~~~^~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpftzmaiwp.swift:15:9:\
    \ warning: initialization of variable 'factorization' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorization = [Int]()\n\
    \    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmpftzmaiwp.swift:16:9: warning: initialization\
    \ of variable 'primeFactorizationIndex' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var primeFactorizationIndex = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpftzmaiwp.swift:17:9: warning: initialization of variable 'factorizationIndex'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorizationIndex = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpftzmaiwp.swift:18:9:\
    \ warning: initialization of variable 'isPrime' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var isPrime = true\n    ~~~~^~~~~~~\n\
    \    _\n/tmp/tmpftzmaiwp.swift:19:9: warning: initialization of variable 'isPrimeIndex'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrimeIndex = 0\n    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmpftzmaiwp.swift:20:9:\
    \ warning: initialization of variable 'isPrimeFactorization' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var isPrimeFactorization\
    \ = false\n    ~~~~^~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpftzmaiwp.swift:21:9: warning:\
    \ initialization of variable 'isPrimeFactorizationIndex' was never used; consider\
    \ replac"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            factors.append(i)\n\
    \            n /= i\n        }\n        i += 1\n    }\n    if n != 1 {\n     \
    \   factors.append(n)\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp981gk_1q.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var primes\
    \ = [Int]()\n    var primeFactors = [Int]()\n    var isPrime = [Bool]()\n    var\
    \ isPrimeFactors = [Bool]()\n    var isPrimeFactorsCount = [Int]()\n    var isPrimeFactorsCountMax\
    \ = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n    var isPrimeFactorsCountMaxValue\
    \ = Int()\n    var isPrimeFactorsCountMaxIndexValue = Int()\n    var isPrimeFactorsCountMaxValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValue = Int()\n    var isPrimeFactorsCountMaxValueIndexValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueIndex = Int()\n    var isPrimeFactorsCountMaxValueValueValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueIndexValueValue = Int()\n    var\
    \ isPrimeFactorsCountMaxValueValueIndexValue = Int()\n    var isPrimeFactorsCountMaxValueValueIndexValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndexValue = Int()\n \
    \   var isPrimeFactorsCountMaxValueValueIndexValueIndex = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndexValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndexValueIndexValue =\
    \ Int()\n    var isPrimeFactorsCountMaxValueValueValueIndexValueIndexValue = Int()\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndexValueIndexValueIndex = Int()\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndexValueIndexValueIndex = Int()\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndexValueIndexValueIndexValue =\
    \ Int()\n    var isPrimeFactorsCountMaxValueValueValueIndexValueIndexValueIndexValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndexValueIndexValueIndexValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndexValueIndexValueIndexValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndexValueIndexValueIndexValueIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndexValueIndexValueIndexValueIndexValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndexValueIndexValueIndexValueIndexValue\
    \ = Int()\n    var isPrimeFactorsCountMaxValueValueValueIndexValueIndexValueIndexValueIndexValueIndex\
    \ = Int()\n    var isPri\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpiqc75act.swift:31:9: error: invalid redeclaration of 'isPrimeFactorsCountMaxValueValueIndexValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueIndexValueIndex = Int()\n        ^\n\
    /tmp/tmpiqc75act.swift:29:9: note: 'isPrimeFactorsCountMaxValueValueIndexValueIndex'\
    \ previously declared here\n    var isPrimeFactorsCountMaxValueValueIndexValueIndex\
    \ = Int()\n        ^\n/tmp/tmpiqc75act.swift:34:9: error: invalid redeclaration\
    \ of 'isPrimeFactorsCountMaxValueValueValueIndexValueIndexValue'\n    var isPrimeFactorsCountMaxValueValueValueIndexValueIndexValue\
    \ = Int()\n        ^\n/tmp/tmpiqc75act.swift:33:9: note: 'isPrimeFactorsCountMaxValueValueValueIndexValueIndexValue'\
    \ previously declared here\n    var isPrimeFactorsCountMaxValueValueValueIndexValueIndexValue\
    \ = Int()\n        ^\n/tmp/tmpiqc75act.swift:36:9: error: invalid redeclaration\
    \ of 'isPrimeFactorsCountMaxValueValueValueIndexValueIndexValueIndex'\n    var\
    \ isPrimeFactorsCountMaxValueValueValueIndexValueIndexValueIndex = Int()\n   \
    \     ^\n/tmp/tmpiqc75act.swift:35:9: note: 'isPrimeFactorsCountMaxValueValueValueIndexValueIndexValueIndex'\
    \ previously declared here\n    var isPrimeFactorsCountMaxValueValueValueIndexValueIndexValueIndex\
    \ = Int()\n        ^\n/tmp/tmpiqc75act.swift:38:9: error: invalid redeclaration\
    \ of 'isPrimeFactorsCountMaxValueValueValueIndexValueIndexValueIndexValue'\n \
    \   var isPrimeFactorsCountMaxValueValueValueIndexValueIndexValueIndexValue =\
    \ Int()\n        ^\n/tmp/tmpiqc75act.swift:37:9: note: 'isPrimeFactorsCountMaxValueValueValueIndexValueIndexValueIndexValue'\
    \ previously declared here\n    var isPrimeFactorsCountMaxValueValueValueIndexValueIndexValueIndexValue\
    \ = Int()\n        ^\n/tmp/tmpiqc75act.swift:40:9: error: invalid redeclaration\
    \ of 'isPrimeFactorsCountMaxValueValueValueIndexValueIndexValueIndexValueIndex'\n\
    \    var isPrimeFactorsCountMaxValueValueValueIndexValueIndexValueIndexValueIndex\
    \ = Int()\n        ^\n/tmp/tmpiqc75act.swift:39:9: note: 'isPrimeFactorsCountMaxValueValueValueIndexValueIndexValueIndexValueIndex'\
    \ previously declared here\n    var isPrimeFactors"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    var j = 1\n    while i * j <= n {\n        if n % i == 0 {\n      \
    \      factors.append(i)\n            n /= i\n        } else {\n            j\
    \ += 1\n        }\n        i += 1\n    }\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpjplw48zr.swift:18:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var factorization\
    \ = [Int]()\n    var product = n * n\n    var divisor = 2\n    var divisorCount\
    \ = 0\n    var factorCount = 0\n    var isPrime = true\n    while divisor <= product\
    \ {\n        if product % divisor == 0 {\n            factors.append(divisor)\n\
    \            factorCount += 1\n            divisorCount += 1\n            product\
    \ /= divisor\n        } else {\n            divisorCount += 1\n            divisor\
    \ *= 2\n        }\n    }\n    if product != 1 {\n        factors.append(product)\n\
    \        factorCount += 1\n    }\n    if factorCount > 1 {\n        factorization\
    \ = factors.reverse()\n    } else {\n        factorization = factors\n    }\n\
    \    if divisorCount > 1 {\n        factorization = factorization.reverse()\n\
    \    }\n    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpqbm7o5_q.swift:35:33: error: cannot assign value of type '()' to\
    \ type '[Int]'\n        factorization = factors.reverse()\n                  \
    \      ~~~~~~~~^~~~~~~~~\n/tmp/tmpqbm7o5_q.swift:40:39: error: cannot assign value\
    \ of type '()' to type '[Int]'\n        factorization = factorization.reverse()\n\
    \                        ~~~~~~~~~~~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var primeFactorization: [Int] = []\n    var primeFactorizationCount = 0\n\
    \    var isPrime = true\n    var isPrimeCount = 0\n    var isPrimePrime = true\n\
    \    var isPrimePrimeCount = 0\n    var isPrimePrimePrime = true\n    var isPrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount =\
    \ 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePri\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpw26_4aga.swift:32:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmpw26_4aga.swift:30:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimePrimeCount' previously declared\
    \ here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n\
    /tmp/tmpw26_4aga.swift:36:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n     \
    \   ^\n/tmp/tmpw26_4aga.swift:34:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n        ^\n/tmp/tmpw26_4aga.swift:37:9: error: invalid redeclaration of\
    \ 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmpw26_4aga.swift:35:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\
    \ = true\n        ^\n/tmp/tmpw26_4aga.swift:41:9: error: type annotation missing\
    \ in pattern\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePri\n   \
    \     ^\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var factorizationCount = 0\n    var factorizationIndex = 0\n    var isPrime\
    \ = true\n    var isPrimeIndex = 0\n    var isPrimeCount = 0\n    var isPrimeFactorizationCount\
    \ = 0\n    var isPrimeFactorizationIndex = 0\n    var isPrimeFactorization = true\n\
    \    var isPrimeFactorizationIndex = 0\n    var isPrimeFactorization = true\n\
    \    var isPrimeFactorizationIndex = 0\n    var isPrimeFactorization = true\n\
    \    var isPrimeFactorizationIndex = 0\n    var isPrimeFactorization = true\n\
    \    var isPrimeFactorizationIndex = 0\n    var isPrimeFactorization = true\n\
    \    var isPrimeFactorizationIndex = 0\n    var isPrimeFactorization = true\n\
    \    var isPrimeFactorizationIndex = 0\n    var isPrimeFactorization = true\n\
    \    var isPrimeFactorizationIndex = 0\n    var isPrimeFactorization = true\n\
    \    var isPrimeFactorizationIndex = 0\n    var isPrimeFactorization = true\n\
    \    var isPrimeFactorizationIndex = 0\n    var isPrimeFactorization = true\n\
    \    var isPrimeFactorizationIndex = 0\n    var isPrimeFactorization = true\n\
    \    var isPrimeFactorizationIndex = 0\n    var isPrimeFactorization = true\n\
    \    var isPrimeFactorizationIndex = 0\n    var isPrimeFactorization = true\n\
    \    var isPrimeFactorizationIndex = 0\n    var isPrimeFactorization = true\n\
    \    var isPrimeFactorizationIndex = 0\n    var isPrimeFactorization = true\n\
    \    var isPrimeFactorizationIndex = 0\n    var isPrimeFactorization = true\n\
    \    var isPrimeFactorizationIndex = 0\n    var isPrimeFactorization = true\n\
    \    var isPrimeFactorizationIndex = 0\n    var isPrimeFactorization = true\n\
    \    var isPrimeFactorizationIndex = 0\n    var isPrimeFactorization = true\n\
    \    var isPrimeFactorizationIndex = 0\n    var isPrimeFactorization = true\n\
    \    var isPrimeFactorizationIndex = 0\n    var isPrimeFactorization = true\n\
    \    var isPrimeFactorizationIndex = 0\n    var isPrimeFactorization = true\n\
    \    var isPrimeFactorizationIndex = 0\n    var isPrimeFactorization = true\n\
    \    var isPrimeFactorizationIndex = 0\n    var isPrimeFactorization = true\n\
    \    var isPrimeFactorizationIndex = 0\n    var isPrimeFactorization = true\n\
    \    var isPrimeFactorizationIndex = 0\n    var isPrimeFactorization = true\n\
    \    var isPrimeFactorizationIndex = 0\n    var isPrimeFactorization = true\n\
    \    var isPrimeFactor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp12rq7848.swift:21:9: error: invalid redeclaration of 'isPrimeFactorizationIndex'\n\
    \    var isPrimeFactorizationIndex = 0\n        ^\n/tmp/tmp12rq7848.swift:19:9:\
    \ note: 'isPrimeFactorizationIndex' previously declared here\n    var isPrimeFactorizationIndex\
    \ = 0\n        ^\n/tmp/tmp12rq7848.swift:22:9: error: invalid redeclaration of\
    \ 'isPrimeFactorization'\n    var isPrimeFactorization = true\n        ^\n/tmp/tmp12rq7848.swift:20:9:\
    \ note: 'isPrimeFactorization' previously declared here\n    var isPrimeFactorization\
    \ = true\n        ^\n/tmp/tmp12rq7848.swift:23:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationIndex'\n    var isPrimeFactorizationIndex = 0\n    \
    \    ^\n/tmp/tmp12rq7848.swift:19:9: note: 'isPrimeFactorizationIndex' previously\
    \ declared here\n    var isPrimeFactorizationIndex = 0\n        ^\n/tmp/tmp12rq7848.swift:24:9:\
    \ error: invalid redeclaration of 'isPrimeFactorization'\n    var isPrimeFactorization\
    \ = true\n        ^\n/tmp/tmp12rq7848.swift:20:9: note: 'isPrimeFactorization'\
    \ previously declared here\n    var isPrimeFactorization = true\n        ^\n/tmp/tmp12rq7848.swift:25:9:\
    \ error: invalid redeclaration of 'isPrimeFactorizationIndex'\n    var isPrimeFactorizationIndex\
    \ = 0\n        ^\n/tmp/tmp12rq7848.swift:19:9: note: 'isPrimeFactorizationIndex'\
    \ previously declared here\n    var isPrimeFactorizationIndex = 0\n        ^\n\
    /tmp/tmp12rq7848.swift:26:9: error: invalid redeclaration of 'isPrimeFactorization'\n\
    \    var isPrimeFactorization = true\n        ^\n/tmp/tmp12rq7848.swift:20:9:\
    \ note: 'isPrimeFactorization' previously declared here\n    var isPrimeFactorization\
    \ = true\n        ^\n/tmp/tmp12rq7848.swift:27:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationIndex'\n    var isPrimeFactorizationIndex = 0\n    \
    \    ^\n/tmp/tmp12rq7848.swift:19:9: note: 'isPrimeFactorizationIndex' previously\
    \ declared here\n    var isPrimeFactorizationIndex = 0\n        ^\n/tmp/tmp12rq7848.swift:28:9:\
    \ error: invalid redeclaration of 'isPrimeFactorization'\n    var isPrimeFactorization\
    \ = true\n        ^\n/tmp/tmp12rq7848.swift:20:9: note: 'isPrimeFactor"
  stdout: ''
  timestamp: 1659824952
- exit_code: -4
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    var factor = 1\n    while i <= n {\n        if n % i == 0 {\n     \
    \       factors.append(factor)\n            factor = 1\n        } else {\n   \
    \         factor *= i\n        }\n        i += 1\n    }\n    factors.append(factor)\n\
    \    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmpoqj7j_w8/tmpoqj7j_w8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5fd0381c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5fd0078b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5fd0078988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5fd00777b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoqj7j_w8                        0x000055a7dadef4c2 <unavailable> + 5314

    5    libc.so.6                          0x00002b5fd056d460 __libc_start_main +
    245

    6    tmpoqj7j_w8                        0x000055a7dadef119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    if n < 2 {\n        return []\n \
    \   }\n    var factors = [Int]()\n    var primes = [Int]()\n    var primeFactors\
    \ = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeFactors = [Bool]()\n \
    \   var isPrimeFactorsCount = [Int]()\n    var isPrimeFactorsCountMax = Int()\n\
    \    var isPrimeFactorsCountMaxIndex = Int()\n    var isPrimeFactorsCountMaxIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n    var isPrimeFactorsCountMaxIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n    var isPrimeFactorsCountMaxIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n    var isPrimeFactorsCountMaxIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n    var isPrimeFactorsCountMaxIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n    var isPrimeFactorsCountMaxIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n    var isPrimeFactorsCountMaxIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n    var isPrimeFactorsCountMaxIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n    var isPrimeFactorsCountMaxIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n    var isPrimeFactorsCountMaxIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n    var isPrimeFactorsCountMaxIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n    var isPrimeFactorsCountMaxIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n    var isPrimeFactorsCountMaxIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n    var isPrimeFactorsCountMaxIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n    var isPrimeFactorsCountMaxIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n    var isPrimeFactorsCountMaxIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n    var isPrimeFactorsCountMaxIndex\
    \ = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n    var isPrimeFactorsCountMaxIndex\
    \ = Int()\n    var isPrimeFactorsCount\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmppka5t5jq.swift:23:9: error: invalid redeclaration of 'isPrimeFactorsCountMaxIndex'\n\
    \    var isPrimeFactorsCountMaxIndex = Int()\n        ^\n/tmp/tmppka5t5jq.swift:22:9:\
    \ note: 'isPrimeFactorsCountMaxIndex' previously declared here\n    var isPrimeFactorsCountMaxIndex\
    \ = Int()\n        ^\n/tmp/tmppka5t5jq.swift:24:9: error: invalid redeclaration\
    \ of 'isPrimeFactorsCountMaxIndex'\n    var isPrimeFactorsCountMaxIndex = Int()\n\
    \        ^\n/tmp/tmppka5t5jq.swift:22:9: note: 'isPrimeFactorsCountMaxIndex' previously\
    \ declared here\n    var isPrimeFactorsCountMaxIndex = Int()\n        ^\n/tmp/tmppka5t5jq.swift:25:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxIndex'\n    var isPrimeFactorsCountMaxIndex\
    \ = Int()\n        ^\n/tmp/tmppka5t5jq.swift:22:9: note: 'isPrimeFactorsCountMaxIndex'\
    \ previously declared here\n    var isPrimeFactorsCountMaxIndex = Int()\n    \
    \    ^\n/tmp/tmppka5t5jq.swift:26:9: error: invalid redeclaration of 'isPrimeFactorsCountMaxIndex'\n\
    \    var isPrimeFactorsCountMaxIndex = Int()\n        ^\n/tmp/tmppka5t5jq.swift:22:9:\
    \ note: 'isPrimeFactorsCountMaxIndex' previously declared here\n    var isPrimeFactorsCountMaxIndex\
    \ = Int()\n        ^\n/tmp/tmppka5t5jq.swift:27:9: error: invalid redeclaration\
    \ of 'isPrimeFactorsCountMaxIndex'\n    var isPrimeFactorsCountMaxIndex = Int()\n\
    \        ^\n/tmp/tmppka5t5jq.swift:22:9: note: 'isPrimeFactorsCountMaxIndex' previously\
    \ declared here\n    var isPrimeFactorsCountMaxIndex = Int()\n        ^\n/tmp/tmppka5t5jq.swift:28:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxIndex'\n    var isPrimeFactorsCountMaxIndex\
    \ = Int()\n        ^\n/tmp/tmppka5t5jq.swift:22:9: note: 'isPrimeFactorsCountMaxIndex'\
    \ previously declared here\n    var isPrimeFactorsCountMaxIndex = Int()\n    \
    \    ^\n/tmp/tmppka5t5jq.swift:29:9: error: invalid redeclaration of 'isPrimeFactorsCountMaxIndex'\n\
    \    var isPrimeFactorsCountMaxIndex = Int()\n        ^\n/tmp/tmppka5t5jq.swift:22:9:\
    \ note: 'isPrimeFactorsCountMaxIndex' previously declared here\n    var isPrimeFactorsCountMaxIndex\
    \ = Int()\n        ^\n/tmp/tmppka5t5jq.swift:30"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var factorizationCount = 0\n    var currentFactorizationCount = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization: Int = 0\n    var\
    \ currentFactorization: Int = 0\n    var currentFactorization\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmps6qx_bv5.swift:16:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:17:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmps6qx_bv5.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:18:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmps6qx_bv5.swift:19:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:20:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmps6qx_bv5.swift:15:9: note: 'currentFactorization' previously declared\
    \ here\n    var currentFactorization: Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:21:9:\
    \ error: invalid redeclaration of 'currentFactorization'\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:15:9: note: 'currentFactorization'\
    \ previously declared here\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmps6qx_bv5.swift:22:9: error: invalid redeclaration of 'currentFactorization'\n\
    \    var currentFactorization: Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:15:9:\
    \ note: 'currentFactorization' previously declared here\n    var currentFactorization:\
    \ Int = 0\n        ^\n/tmp/tmps6qx_bv5.swift:23:9: error: invalid redeclaration\
    \ of 'currentFactorization'\n    var currentFactorization: Int = 0\n        ^\n\
    /tmp/tmps6qx_bv5.swift:15:9: note: 'currentFactorization' previously declar"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var factorizationCount = 0\n    var factorizationSum = 0\n    var factorizationSum2\
    \ = 0\n    var factorizationSum3 = 0\n    var factorizationSum4 = 0\n    var factorizationSum5\
    \ = 0\n    var factorizationSum6 = 0\n    var factorizationSum7 = 0\n    var factorizationSum8\
    \ = 0\n    var factorizationSum9 = 0\n    var factorizationSum10 = 0\n    var\
    \ factorizationSum11 = 0\n    var factorizationSum12 = 0\n    var factorizationSum13\
    \ = 0\n    var factorizationSum14 = 0\n    var factorizationSum15 = 0\n    var\
    \ factorizationSum16 = 0\n    var factorizationSum17 = 0\n    var factorizationSum18\
    \ = 0\n    var factorizationSum19 = 0\n    var factorizationSum20 = 0\n    var\
    \ factorizationSum21 = 0\n    var factorizationSum22 = 0\n    var factorizationSum23\
    \ = 0\n    var factorizationSum24 = 0\n    var factorizationSum25 = 0\n    var\
    \ factorizationSum26 = 0\n    var factorizationSum27 = 0\n    var factorizationSum28\
    \ = 0\n    var factorizationSum29 = 0\n    var factorizationSum30 = 0\n    var\
    \ factorizationSum31 = 0\n    var factorizationSum32 = 0\n    var factorizationSum33\
    \ = 0\n    var factorizationSum34 = 0\n    var factorizationSum35 = 0\n    var\
    \ factorizationSum36 = 0\n    var factorizationSum37 = 0\n    var factorizationSum38\
    \ = 0\n    var factorizationSum39 = 0\n    var factorizationSum40 = 0\n    var\
    \ factorizationSum41 = 0\n    var factorizationSum42 = 0\n    var factorizationSum43\
    \ = 0\n    var factorizationSum44 = 0\n    var factorizationSum45 = 0\n    var\
    \ factorizationSum46 = 0\n    var factorizationSum47 = 0\n    var factorizationSum48\
    \ = 0\n    var factorizationSum49 = 0\n    var factorizationSum50 = 0\n    var\
    \ factorizationSum51 = 0\n    var factorizationSum52 = 0\n    var factorizationSum53\
    \ = 0\n    var factorizationSum54 = 0\n    var factorizationSum55 = 0\n    var\
    \ factorizationSum56 = 0\n    var factorizationSum57 = 0\n    var factorizationSum58\
    \ = 0\n    var factorizationSum59 = 0\n    var factorizationSum60 = 0\n    var\
    \ factorizationSum61 = 0\n    var factorizationSum62 = 0\n    var factorizationSum63\
    \ = 0\n    var factorizationSum64 = 0\n    var factorizationSum65 = 0\n    var\
    \ factorizationSum66 = 0\n    var factorizationSum67 = 0\n    var factorizationSum68\
    \ = 0\n    var factorizationSum69 = 0\n    var factorizationSum70 = 0\n    var\
    \ factorizationSum71 = 0\n    var factor\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp6dw3ntlz.swift:85:9: error: type annotation missing in pattern\n\
    \    var factor\n        ^\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n    var\
    \ primeFactors = 2\n    var factorization = [Int]()\n    var factorizationCount\
    \ = 0\n    var isPrime = true\n    var isFactorization = false\n    var isPrimeFactorization\
    \ = false\n    var isPrimeFactorizationCount = 0\n    var isPrimeFactorizationPrime\
    \ = true\n    var isPrimeFactorizationFactorization = false\n    var isPrimeFactorizationFactorizationCount\
    \ = 0\n    var isPrimeFactorizationFactorizationPrime = true\n    var isPrimeFactorizationFactorizationFactorization\
    \ = false\n    var isPrimeFactorizationFactorizationFactorizationCount = 0\n \
    \   var isPrimeFactorizationFactorizationFactorizationPrime = true\n    var isPrimeFactorizationFactorizationFactorizationFactorization\
    \ = false\n    var isPrimeFactorizationFactorizationFactorizationFactorizationCount\
    \ = 0\n    var isPrimeFactorizationFactorizationFactorizationFactorizationPrime\
    \ = true\n    var isPrimeFactorizationFactorizationFactorizationFactorizationFactorization\
    \ = false\n    var isPrimeFactorizationFactorizationFactorizationFactorizationFactorizationCount\
    \ = 0\n    var isPrimeFactorizationFactorizationFactorizationFactorizationFactorizationPrime\
    \ = true\n    var isPrimeFactorizationFactorizationFactorizationFactorizationFactorizationFactorization\
    \ = false\n    var isPrimeFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationCount\
    \ = 0\n    var isPrimeFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationPrime\
    \ = true\n    var isPrimeFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationFactorization\
    \ = false\n    var isPrimeFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationCount\
    \ = 0\n    var isPrimeFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationPrime\
    \ = true\n    var isPrimeFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationFactorization\
    \ = false\n    var isPrimeFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationCount\
    \ = 0\n    var isPrimeFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationPrime\
    \ = true\n    var isPrimeFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationFactorization\
    \ = false\n    var isPrimeFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationCount\
    \ = 0\n    var isPrimeFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationPrime\
    \ = true\n    var isPrimeFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationFactorization\
    \ = false\n    var isPrimeFactorizationFactor\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpob5sji3e.swift:40:9: error: invalid redeclaration of 'isPrimeFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationCount'\n\
    \    var isPrimeFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationCount\
    \ = 0\n        ^\n/tmp/tmpob5sji3e.swift:37:9: note: 'isPrimeFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationCount'\
    \ previously declared here\n    var isPrimeFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationCount\
    \ = 0\n        ^\n/tmp/tmpob5sji3e.swift:41:9: error: invalid redeclaration of\
    \ 'isPrimeFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationPrime'\n\
    \    var isPrimeFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationPrime\
    \ = true\n        ^\n/tmp/tmpob5sji3e.swift:38:9: note: 'isPrimeFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationPrime'\
    \ previously declared here\n    var isPrimeFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationPrime\
    \ = true\n        ^\n/tmp/tmpob5sji3e.swift:42:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationFactorization'\n\
    \    var isPrimeFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationFactorization\
    \ = false\n        ^\n/tmp/tmpob5sji3e.swift:39:9: note: 'isPrimeFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationFactorization'\
    \ previously declared here\n    var isPrimeFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationFactorization\
    \ = false\n        ^\n/tmp/tmpob5sji3e.swift:43:9: error: invalid redeclaration\
    \ of 'isPrimeFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationFactorizationCount'\n\
    \    var isPrimeFactorizationFactorizationFactorizationFactorizationFactorization"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var factorization\
    \ = factorizationOfNumber(n)\n    var factorizationCount = 1\n    for factor in\
    \ factorization {\n        if factorizationCount > factors.count {\n         \
    \   factors.append(factor)\n        } else {\n            factors[factors.count]\
    \ = factor\n        }\n        factorizationCount *= factor\n    }\n    return\
    \ factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpizy2yjvm.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    var factor = 1\n    var isPrime = true\n    while i <= n {\n      \
    \  if n % i == 0 {\n            isPrime = false\n            factors.append(i)\n\
    \            n /= i\n        } else {\n            i += 1\n        }\n    }\n\
    \    if n > 1 {\n        factors.append(n)\n    }\n    if isPrime {\n        factors.append(n)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpgwihxwc6.swift:20:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: -1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var primeFactors\
    \ = factorize(n: n)\n    var factorsCount = 1\n    for prime in primeFactors {\n\
    \        if factorsCount > prime {\n            factorsCount *= prime\n      \
    \  } else {\n            factors.append(factorsCount)\n            factorsCount\
    \ = prime\n        }\n    }\n    factors.append(factorsCount)\n    return factors\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824958
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var primeFactorization = [Int]()\n    var isPrime = [Bool]()\n    var isPrimeFactorization\
    \ = [Bool]()\n    var isPrimePrimeFactorization = [Bool]()\n    var isPrimePrimePrimeFactorization\
    \ = [Bool]()\n    var isPrimePrimePrimePrimeFactorization = [Bool]()\n    var\
    \ isPrimePrimePrimePrimePrimeFactorization = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimeFactorization\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimeFactorization = [Bool]()\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeFactorization = [Bool]()\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimeFactorization = [Bool]()\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization = [Bool]()\n  \
    \  var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization = [Bool]()\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization = [Bool]()\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = [Bool]()\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmphnjygcp_.swift:22:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimeFactorization'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeFactorization = [Bool]()\n     \
    \   ^\n/tmp/tmphnjygcp_.swift:21:9: note: 'isPrimePrimePrimePrimePrimePrimePrimeFactorization'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = [Bool]()\n        ^\n/tmp/tmphnjygcp_.swift:26:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization'\n   \
    \ var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization = [Bool]()\n\
    \        ^\n/tmp/tmphnjygcp_.swift:25:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = [Bool]()\n        ^\n/tmp/tmphnjygcp_.swift:31:9: error: invalid redeclaration\
    \ of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = [Bool]()\n        ^\n/tmp/tmphnjygcp_.swift:30:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorization\
    \ = [Bool]()\n        ^\n/tmp/tmphnjygcp_.swift:33:9: error: type annotation missing\
    \ in pattern\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\n \
    \       ^\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var factorization\
    \ = factorizationOfNumber(n)\n    var factorizationCount = 1\n    for factor in\
    \ factorization {\n        factors.append(factor)\n        factorizationCount\
    \ *= factor\n    }\n    var factorizationCount2 = 1\n    for factor in factorization\
    \ {\n        factors.append(factor)\n        factorizationCount2 *= factor\n \
    \   }\n    if factorizationCount != factorizationCount2 {\n        factors.append(factorizationCount)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpidpo2bn8.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var primes\
    \ = primeFactors(n)\n    for prime in primes {\n        factors.append(prime)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp_8dsy97h.swift:13:18: error: cannot find 'primeFactors' in scope\n\
    \    var primes = primeFactors(n)\n                 ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 0
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    var p = n\n    while p > 1 {\n        while p % i == 0 {\n        \
    \    factors.append(i)\n            p /= i\n        }\n        i += 1\n    }\n\
    \    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var factorization\
    \ = factorizationOfNumber(n)\n    for factor in factorization {\n        factors.append(factor)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpaaj3z1xc.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var factor = 2\n    var remainder: Int = 0\n    while n > 1 {\n        remainder\
    \ = n % factor\n        factorization[factor] = factorization[factor] + 1\n  \
    \      n = remainder\n        factor++\n    }\n    return factorization\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpwewig_kl.swift:18:9: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n        n = remainder\n        ^\n/tmp/tmpwewig_kl.swift:19:15: error:\
    \ cannot find operator '++' in scope; did you mean '+= 1'?\n        factor++\n\
    \              ^~\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var factorizationCount = 0\n    var factorizationIndex = 0\n    var factorizationNumber\
    \ = 0\n    var factorizationNumberIndex = 0\n    var factorizationNumberIndex2\
    \ = 0\n    var factorizationNumberIndex3 = 0\n    var factorizationNumberIndex4\
    \ = 0\n    var factorizationNumberIndex5 = 0\n    var factorizationNumberIndex6\
    \ = 0\n    var factorizationNumberIndex7 = 0\n    var factorizationNumberIndex8\
    \ = 0\n    var factorizationNumberIndex9 = 0\n    var factorizationNumberIndex10\
    \ = 0\n    var factorizationNumberIndex11 = 0\n    var factorizationNumberIndex12\
    \ = 0\n    var factorizationNumberIndex13 = 0\n    var factorizationNumberIndex14\
    \ = 0\n    var factorizationNumberIndex15 = 0\n    var factorizationNumberIndex16\
    \ = 0\n    var factorizationNumberIndex17 = 0\n    var factorizationNumberIndex18\
    \ = 0\n    var factorizationNumberIndex19 = 0\n    var factorizationNumberIndex20\
    \ = 0\n    var factorizationNumberIndex21 = 0\n    var factorizationNumberIndex22\
    \ = 0\n    var factorizationNumberIndex23 = 0\n    var factorizationNumberIndex24\
    \ = 0\n    var factorizationNumberIndex25 = 0\n    var factorizationNumberIndex26\
    \ = 0\n    var factorizationNumberIndex27 = 0\n    var factorizationNumberIndex28\
    \ = 0\n    var factorizationNumberIndex29 = 0\n    var factorizationNumberIndex30\
    \ = 0\n    var factorizationNumberIndex31 = 0\n    var factorizationNumberIndex32\
    \ = 0\n    var factorizationNumberIndex33 = 0\n    var factorizationNumberIndex34\
    \ = 0\n    var factorizationNumberIndex35 = 0\n    var factorizationNumberIndex36\
    \ = 0\n    var factorizationNumberIndex37 = 0\n    var factorizationNumberIndex38\
    \ = 0\n    var factorizationNumberIndex39 = 0\n    var factorizationNumberIndex40\
    \ = 0\n    var factorizationNumberIndex41 = 0\n    var factorizationNumberIndex42\
    \ = 0\n    var factorizationNumberIndex43 = 0\n    var factorizationNumberIndex44\
    \ = 0\n    var factorizationNumberIndex45 = 0\n    var factorizationNumberIndex46\
    \ = 0\n    var factorizationNumberIndex47 = 0\n    var factorizationNumberIndex48\
    \ = 0\n    var factorizationNumberIndex49 = 0\n    var factorizationNumberIndex50\
    \ = 0\n    var factorizationNumberIndex51 = 0\n    var factorizationNumberIndex52\
    \ = 0\n    var factorizationNumberIndex53 = 0\n    var factorizationNumberIndex54\
    \ = 0\n    var factorizationNumberIndex55 = 0\n    var factorizationNumberIndex56\
    \ = 0\n    var factorizationNumberIndex57 = 0\n    var factorizationNumberIndex58\
    \ = 0\n    var factorizationNumberIndex59 = 0\n    var factorizationNumberIndex60\
    \ = 0\n    var factorizationNumberIndex61 = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmps94tm703.swift:12:9: warning: variable 'factorization' was never\
    \ used; consider replacing with '_' or removing it\n    var factorization: [Int]\
    \ = []\n        ^~~~~~~~~~~~~\n        _\n/tmp/tmps94tm703.swift:13:9: warning:\
    \ initialization of variable 'factorizationCount' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var factorizationCount = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmps94tm703.swift:14:9: warning: initialization of variable 'factorizationIndex'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var factorizationIndex = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmps94tm703.swift:15:9:\
    \ warning: initialization of variable 'factorizationNumber' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorizationNumber\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmps94tm703.swift:16:9: warning:\
    \ initialization of variable 'factorizationNumberIndex' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorizationNumberIndex\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmps94tm703.swift:17:9: warning:\
    \ initialization of variable 'factorizationNumberIndex2' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var factorizationNumberIndex2\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmps94tm703.swift:18:9:\
    \ warning: initialization of variable 'factorizationNumberIndex3' was never used;\
    \ consider replacing with assignment to '_' or removing it\n    var factorizationNumberIndex3\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmps94tm703.swift:19:9:\
    \ warning: initialization of variable 'factorizationNumberIndex4' was never used;\
    \ consider replacing with assignment to '_' or removing it\n    var factorizationNumberIndex4\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmps94tm703.swift:20:9:\
    \ warning: initialization of variable 'factorizationNumberIndex5' was never used;\
    \ consider replacing with assignment to '_' or removing it\n    var factorizationNumberIndex5\
    \ = 0\n    ~~~~^~~"
  stdout: ''
  timestamp: 1659824952
- exit_code: -4
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            i += 1\n \
    \           factors.append(i)\n        }\n        i += 1\n    }\n    return factors\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmpp6xz5aiv/tmpp6xz5aiv.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b087d41fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b087d116b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b087d116988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b087d1157b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp6xz5aiv                        0x000055f5a852d4c2 <unavailable> + 5314

    5    libc.so.6                          0x00002b087d60b460 __libc_start_main +
    245

    6    tmpp6xz5aiv                        0x000055f5a852d119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            factors.append(i)\n\
    \            n /= i\n        }\n        i += 1\n    }\n    if n != 1 {\n     \
    \   factors.append(n)\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp981gk_1q.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var primes\
    \ = [Int]()\n    var primeFactors = [1]\n    var isPrime = true\n    var isFactor\
    \ = true\n    var factor = 2\n    var factorCount = 0\n    var primeFactorCount\
    \ = 0\n    var primeFactorsCount = 0\n    var isPrimeCount = 0\n    var isFactorCount\
    \ = 0\n    var isPrimeFactorCount = 0\n    var isPrimePrimeCount = 0\n    var\
    \ isPrimePrimeFactorCount = 0\n    var isPrimePrimePrimeCount = 0\n    var isPrimePrimePrimeFactorCount\
    \ = 0\n    var isPrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimeFactorCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimeFactorCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimeFactorCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimeFactorCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimeFactorCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimeFactorCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorCount = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorCount\
    \ = 0\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorCount = 0\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var\
    \ isPrimePrimePrime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmph8am4tmg.swift:36:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmph8am4tmg.swift:34:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimeCount' previously declared here\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeCount = 0\n        ^\n/tmp/tmph8am4tmg.swift:37:9:\
    \ error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimeFactorCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimeFactorCount = 0\n        ^\n/tmp/tmph8am4tmg.swift:35:9:\
    \ note: 'isPrimePrimePrimePrimePrimePrimePrimeFactorCount' previously declared\
    \ here\n    var isPrimePrimePrimePrimePrimePrimePrimeFactorCount = 0\n       \
    \ ^\n/tmp/tmph8am4tmg.swift:44:9: error: invalid redeclaration of 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n     \
    \   ^\n/tmp/tmph8am4tmg.swift:42:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n        ^\n/tmp/tmph8am4tmg.swift:45:9: error: invalid redeclaration of\
    \ 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorCount'\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorCount\
    \ = 0\n        ^\n/tmp/tmph8am4tmg.swift:43:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorCount'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactorCount\
    \ = 0\n        ^\n/tmp/tmph8am4tmg.swift:46:9: error: invalid redeclaration of\
    \ 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount'\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n        ^\n/tmp/tmph8am4tmg.swift:42:9: note: 'isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n    var isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n        ^\n/tmp/tmph8am4tmg.swift:47:9: error: type annotation missing\
    \ in pattern\n    var isPrimePrimePrime\n        ^\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    var p = 2\n    while i <= n {\n        if n % i == 0 {\n          \
    \  factors.append(i)\n            n /= i\n        } else {\n            i += 1\n\
    \        }\n    }\n    if n != 1 {\n        factors.append(n)\n    }\n    return\
    \ factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp37uj75i2.swift:18:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var primes\
    \ = [Int]()\n    var primeFactors = [Int]()\n    var isPrime = [Bool]()\n    var\
    \ isPrimeFactors = [Bool]()\n    var isPrimeFactorsCount = [Int]()\n    var isPrimeFactorsCountMax\
    \ = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n    var isPrimeFactorsCountMaxValue\
    \ = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n    var isPrimeFactorsCountMaxValue\
    \ = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n    var isPrimeFactorsCountMaxValue\
    \ = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n    var isPrimeFactorsCountMaxValue\
    \ = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n    var isPrimeFactorsCountMaxValue\
    \ = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n    var isPrimeFactorsCountMaxValue\
    \ = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n    var isPrimeFactorsCountMaxValue\
    \ = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n    var isPrimeFactorsCountMaxValue\
    \ = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n    var isPrimeFactorsCountMaxValue\
    \ = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n    var isPrimeFactorsCountMaxValue\
    \ = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n    var isPrimeFactorsCountMaxValue\
    \ = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n    var isPrimeFactorsCountMaxValue\
    \ = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n    var isPrimeFactorsCountMaxValue\
    \ = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n    var isPrimeFactorsCountMaxValue\
    \ = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n    var isPrimeFactorsCountMaxValue\
    \ = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n    var isPrimeFactorsCountMaxValue\
    \ = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n    var isPrimeFactorsCountMaxValue\
    \ = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n    var isPrimeFactorsCountMaxValue\
    \ = Int()\n    var isPrimeFactorsCountMaxIndex = Int()\n    var isPri\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp5h5wc1ni.swift:21:9: error: invalid redeclaration of 'isPrimeFactorsCountMaxIndex'\n\
    \    var isPrimeFactorsCountMaxIndex = Int()\n        ^\n/tmp/tmp5h5wc1ni.swift:19:9:\
    \ note: 'isPrimeFactorsCountMaxIndex' previously declared here\n    var isPrimeFactorsCountMaxIndex\
    \ = Int()\n        ^\n/tmp/tmp5h5wc1ni.swift:22:9: error: invalid redeclaration\
    \ of 'isPrimeFactorsCountMaxValue'\n    var isPrimeFactorsCountMaxValue = Int()\n\
    \        ^\n/tmp/tmp5h5wc1ni.swift:20:9: note: 'isPrimeFactorsCountMaxValue' previously\
    \ declared here\n    var isPrimeFactorsCountMaxValue = Int()\n        ^\n/tmp/tmp5h5wc1ni.swift:23:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxIndex'\n    var isPrimeFactorsCountMaxIndex\
    \ = Int()\n        ^\n/tmp/tmp5h5wc1ni.swift:19:9: note: 'isPrimeFactorsCountMaxIndex'\
    \ previously declared here\n    var isPrimeFactorsCountMaxIndex = Int()\n    \
    \    ^\n/tmp/tmp5h5wc1ni.swift:24:9: error: invalid redeclaration of 'isPrimeFactorsCountMaxValue'\n\
    \    var isPrimeFactorsCountMaxValue = Int()\n        ^\n/tmp/tmp5h5wc1ni.swift:20:9:\
    \ note: 'isPrimeFactorsCountMaxValue' previously declared here\n    var isPrimeFactorsCountMaxValue\
    \ = Int()\n        ^\n/tmp/tmp5h5wc1ni.swift:25:9: error: invalid redeclaration\
    \ of 'isPrimeFactorsCountMaxIndex'\n    var isPrimeFactorsCountMaxIndex = Int()\n\
    \        ^\n/tmp/tmp5h5wc1ni.swift:19:9: note: 'isPrimeFactorsCountMaxIndex' previously\
    \ declared here\n    var isPrimeFactorsCountMaxIndex = Int()\n        ^\n/tmp/tmp5h5wc1ni.swift:26:9:\
    \ error: invalid redeclaration of 'isPrimeFactorsCountMaxValue'\n    var isPrimeFactorsCountMaxValue\
    \ = Int()\n        ^\n/tmp/tmp5h5wc1ni.swift:20:9: note: 'isPrimeFactorsCountMaxValue'\
    \ previously declared here\n    var isPrimeFactorsCountMaxValue = Int()\n    \
    \    ^\n/tmp/tmp5h5wc1ni.swift:27:9: error: invalid redeclaration of 'isPrimeFactorsCountMaxIndex'\n\
    \    var isPrimeFactorsCountMaxIndex = Int()\n        ^\n/tmp/tmp5h5wc1ni.swift:19:9:\
    \ note: 'isPrimeFactorsCountMaxIndex' previously declared here\n    var isPrimeFactorsCountMaxIndex\
    \ = Int()\n        ^\n/tmp/tmp5h5wc1ni.swift:28"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var i = 2\n    var j = 1\n    var k = 0\n    while i * j <= n {\n        if\
    \ n % i == 0 {\n            factorization[k] += 1\n            n /= i\n      \
    \      j = 1\n        } else {\n            j += 1\n        }\n        k += 1\n\
    \    }\n    if n > 1 {\n        factorization[k] += 1\n    }\n    return factorization\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpf4n_p9kb.swift:19:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var factor = 2\n    var remainder: Int\n    while factor <= n {\n        remainder\
    \ = n % factor\n        if remainder == 0 {\n            factorization.append(factor)\n\
    \            n /= factor\n        } else {\n            factor *= remainder\n\
    \        }\n    }\n    if n > 1 {\n        factorization.append(n)\n    }\n  \
    \  return factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpqc4j7a_6.swift:19:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= factor\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    while i * i <= n {\n        if n % i == 0 {\n            factors.append(i)\n\
    \            n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n      \
    \  factors.append(n)\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpi1tj22_o.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824951
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var primeFactorization: [Int] = []\n    var isPrime: [Bool] = []\n    var\
    \ isPrimeCount: Int = 0\n    var isPrimeIndex: Int = 0\n    var isPrimeCountIndex:\
    \ Int = 0\n    var isPrimeCountMax: Int = 0\n    var isPrimeCountMaxIndex: Int\
    \ = 0\n    var isPrimeMax: Int = 0\n    var isPrimeMaxIndex: Int = 0\n    var\
    \ isPrimeMaxCount: Int = 0\n    var isPrimeMaxCountIndex: Int = 0\n    var isPrimeMaxCountMax:\
    \ Int = 0\n    var isPrimeMaxCountMaxIndex: Int = 0\n    var isPrimeMaxCountMaxIndex2:\
    \ Int = 0\n    var isPrimeMaxCountMaxIndex3: Int = 0\n    var isPrimeMaxCountMaxIndex4:\
    \ Int = 0\n    var isPrimeMaxCountMaxIndex5: Int = 0\n    var isPrimeMaxCountMaxIndex6:\
    \ Int = 0\n    var isPrimeMaxCountMaxIndex7: Int = 0\n    var isPrimeMaxCountMaxIndex8:\
    \ Int = 0\n    var isPrimeMaxCountMaxIndex9: Int = 0\n    var isPrimeMaxCountMaxIndex10:\
    \ Int = 0\n    var isPrimeMaxCountMaxIndex11: Int = 0\n    var isPrimeMaxCountMaxIndex12:\
    \ Int = 0\n    var isPrimeMaxCountMaxIndex13: Int = 0\n    var isPrimeMaxCountMaxIndex14:\
    \ Int = 0\n    var isPrimeMaxCountMaxIndex15: Int = 0\n    var isPrimeMaxCountMaxIndex16:\
    \ Int = 0\n    var isPrimeMaxCountMaxIndex17: Int = 0\n    var isPrimeMaxCountMaxIndex18:\
    \ Int = 0\n    var isPrimeMaxCountMaxIndex19: Int = 0\n    var isPrimeMaxCountMaxIndex20:\
    \ Int = 0\n    var isPrimeMaxCountMaxIndex21: Int = 0\n    var isPrimeMaxCountMaxIndex22:\
    \ Int = 0\n    var isPrimeMaxCountMaxIndex23: Int = 0\n    var isPrimeMaxCountMaxIndex24:\
    \ Int = 0\n    var isPrimeMaxCountMaxIndex25: Int = 0\n    var isPrimeMaxCountMaxIndex26:\
    \ Int = 0\n    var isPrimeMaxCountMaxIndex27: Int = 0\n    var isPrimeMaxCountMaxIndex28:\
    \ Int = 0\n    var isPrimeMaxCountMaxIndex29: Int = 0\n    var isPrimeMaxCountMaxIndex30:\
    \ Int = 0\n    var isPrime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpyckog8x1.swift:55:9: error: type annotation missing in pattern\n\
    \    var isPrime\n        ^\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var i\
    \ = 2\n    var factor = 1\n    while i <= n {\n        while n % i == 0 {\n  \
    \          factors.append(factor)\n            n /= i\n            factor = 1\n\
    \        }\n        i += 1\n        factor *= i\n    }\n    if n > 1 {\n     \
    \   factors.append(factor)\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpph2hzsss.swift:18:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var primeFactorization = [Int]()\n    var primeFactorizationCount = [Int]()\n\
    \    var primeFactorizationIndex = [Int]()\n    var isPrime = [Bool]()\n    var\
    \ isPrimeCount = [Bool]()\n    var isPrimeIndex = [Bool]()\n    var isPrimeCountIndex\
    \ = [Bool]()\n    var isPrimeIndexCount = [Bool]()\n    var isPrimeCountIndexCount\
    \ = [Bool]()\n    var isPrimeIndexCountIndex = [Bool]()\n    var isPrimeCountIndexCountIndex\
    \ = [Bool]()\n    var isPrimeIndexCountIndexCountIndex = [Bool]()\n    var isPrimeCountIndexCountIndexCountIndex\
    \ = [Bool]()\n    var isPrimeIndexCountIndexCountIndexCountIndex = [Bool]()\n\
    \    var isPrimeCountIndexCountIndexCountIndexCountIndex = [Bool]()\n    var isPrimeIndexCountIndexCountIndexCountIndexCountIndex\
    \ = [Bool]()\n    var isPrimeCountIndexCountIndexCountIndexCountIndexCountIndex\
    \ = [Bool]()\n    var isPrimeIndexCountIndexCountIndexCountIndexCountIndexCountIndex\
    \ = [Bool]()\n    var isPrimeCountIndexCountIndexCountIndexCountIndexCountIndexCountIndex\
    \ = [Bool]()\n    var isPrimeIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndex\
    \ = [Bool]()\n    var isPrimeCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndex\
    \ = [Bool]()\n    var isPrimeIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndex\
    \ = [Bool]()\n    var isPrimeCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndex\
    \ = [Bool]()\n    var isPrimeIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndex\
    \ = [Bool]()\n    var isPrimeCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndex\
    \ = [Bool]()\n    var isPrimeIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndex\
    \ = [Bool]()\n    var isPrimeCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndex\
    \ = [Bool]()\n    var isPrimeIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndex\
    \ = [Bool]()\n    var isPrimeCountIndexCountIndexCountIndexCountIndexCount\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpcoq7z_86.swift:41:9: error: type annotation missing in pattern\n\
    \    var isPrimeCountIndexCountIndexCountIndexCountIndexCount\n        ^\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var primes = [Int]()\n    var primeFactorization = [Int]()\n    var primeFactors\
    \ = [Int]()\n    var primeFactorsCount = [Int]()\n    var primeFactorsSum = [Int]()\n\
    \    var primeFactorsSumCount = [Int]()\n    var primeFactorsSumCount2 = [Int]()\n\
    \    var primeFactorsSumCount3 = [Int]()\n    var primeFactorsSumCount4 = [Int]()\n\
    \    var primeFactorsSumCount5 = [Int]()\n    var primeFactorsSumCount6 = [Int]()\n\
    \    var primeFactorsSumCount7 = [Int]()\n    var primeFactorsSumCount8 = [Int]()\n\
    \    var primeFactorsSumCount9 = [Int]()\n    var primeFactorsSumCount10 = [Int]()\n\
    \    var primeFactorsSumCount11 = [Int]()\n    var primeFactorsSumCount12 = [Int]()\n\
    \    var primeFactorsSumCount13 = [Int]()\n    var primeFactorsSumCount14 = [Int]()\n\
    \    var primeFactorsSumCount15 = [Int]()\n    var primeFactorsSumCount16 = [Int]()\n\
    \    var primeFactorsSumCount17 = [Int]()\n    var primeFactorsSumCount18 = [Int]()\n\
    \    var primeFactorsSumCount19 = [Int]()\n    var primeFactorsSumCount20 = [Int]()\n\
    \    var primeFactorsSumCount21 = [Int]()\n    var primeFactorsSumCount22 = [Int]()\n\
    \    var primeFactorsSumCount23 = [Int]()\n    var primeFactorsSumCount24 = [Int]()\n\
    \    var primeFactorsSumCount25 = [Int]()\n    var primeFactorsSumCount26 = [Int]()\n\
    \    var primeFactorsSumCount27 = [Int]()\n    var primeFactorsSumCount28 = [Int]()\n\
    \    var primeFactorsSumCount29 = [Int]()\n    var primeFactorsSumCount30 = [Int]()\n\
    \    var primeFactorsSumCount31 = [Int]()\n    var primeFactorsSumCount32 = [Int]()\n\
    \    var primeFactorsSumCount33 = [Int]()\n    var primeFactorsSumCount34 = [Int]()\n\
    \    var primeFactorsSumCount35 = [Int]()\n    var primeFactorsSumCount36 = [Int]()\n\
    \    var primeFactorsSumCount37 = [Int]()\n    var primeFactorsSumCount38 = [Int]()\n\
    \    var primeFactors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpi1dpf3g3.swift:56:9: error: type annotation missing in pattern\n\
    \    var primeFactors\n        ^\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int] = []\n \
    \   var primeFactorization: [Int] = []\n    var isPrime: [Bool] = []\n    var\
    \ isPrimeCount: [Int] = []\n    var isPrimeCountMax: Int = 1\n    var isPrimeCountMin:\
    \ Int = 1\n    var isPrimeCountMinMax: Int = 1\n    var isPrimeCountMaxMin: Int\
    \ = 1\n    var isPrimeCountMaxMinMax: Int = 1\n    var isPrimeCountMaxMinMaxMax:\
    \ Int = 1\n    var isPrimeCountMaxMinMaxMaxMax: Int = 1\n    var isPrimeCountMaxMinMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMaxMinMaxMaxMaxMax: Int = 1\n    var isPrimeCountMaxMinMaxMaxMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMaxMinMaxMaxMaxMaxMax: Int = 1\n    var isPrimeCountMaxMinMaxMaxMaxMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMaxMinMaxMaxMaxMaxMaxMax: Int = 1\n    var isPrimeCountMaxMinMaxMaxMaxMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMaxMinMaxMaxMaxMaxMaxMaxMax: Int = 1\n    var isPrimeCountMaxMinMaxMaxMaxMaxMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMaxMinMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n    var\
    \ isPrimeCountMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n    var isPrimeCountMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n  \
    \  var isPrimeCountMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n    var isPrimeCountMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax:\
    \ Int = 1\n    var isPrimeCountMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int =\
    \ 1\n    var isPrimeCountMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n  \
    \  var isPrimeCountMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n    var\
    \ isPrimeCountMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n    var isPrimeCountMaxMinMaxMaxMaxMaxMaxMax\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp6vvwg453.swift:23:9: error: invalid redeclaration of 'isPrimeCountMaxMinMaxMaxMax'\n\
    \    var isPrimeCountMaxMinMaxMaxMax: Int = 1\n        ^\n/tmp/tmp6vvwg453.swift:22:9:\
    \ note: 'isPrimeCountMaxMinMaxMaxMax' previously declared here\n    var isPrimeCountMaxMinMaxMaxMax:\
    \ Int = 1\n        ^\n/tmp/tmp6vvwg453.swift:26:9: error: invalid redeclaration\
    \ of 'isPrimeCountMaxMinMaxMaxMaxMaxMax'\n    var isPrimeCountMaxMinMaxMaxMaxMaxMax:\
    \ Int = 1\n        ^\n/tmp/tmp6vvwg453.swift:25:9: note: 'isPrimeCountMaxMinMaxMaxMaxMaxMax'\
    \ previously declared here\n    var isPrimeCountMaxMinMaxMaxMaxMaxMax: Int = 1\n\
    \        ^\n/tmp/tmp6vvwg453.swift:28:9: error: invalid redeclaration of 'isPrimeCountMaxMinMaxMaxMaxMaxMaxMax'\n\
    \    var isPrimeCountMaxMinMaxMaxMaxMaxMaxMax: Int = 1\n        ^\n/tmp/tmp6vvwg453.swift:27:9:\
    \ note: 'isPrimeCountMaxMinMaxMaxMaxMaxMaxMax' previously declared here\n    var\
    \ isPrimeCountMaxMinMaxMaxMaxMaxMaxMax: Int = 1\n        ^\n/tmp/tmp6vvwg453.swift:29:9:\
    \ error: invalid redeclaration of 'isPrimeCountMaxMinMaxMaxMaxMaxMaxMax'\n   \
    \ var isPrimeCountMaxMinMaxMaxMaxMaxMaxMax: Int = 1\n        ^\n/tmp/tmp6vvwg453.swift:27:9:\
    \ note: 'isPrimeCountMaxMinMaxMaxMaxMaxMaxMax' previously declared here\n    var\
    \ isPrimeCountMaxMinMaxMaxMaxMaxMaxMax: Int = 1\n        ^\n/tmp/tmp6vvwg453.swift:31:9:\
    \ error: invalid redeclaration of 'isPrimeCountMaxMinMaxMaxMaxMaxMaxMaxMax'\n\
    \    var isPrimeCountMaxMinMaxMaxMaxMaxMaxMaxMax: Int = 1\n        ^\n/tmp/tmp6vvwg453.swift:30:9:\
    \ note: 'isPrimeCountMaxMinMaxMaxMaxMaxMaxMaxMax' previously declared here\n \
    \   var isPrimeCountMaxMinMaxMaxMaxMaxMaxMaxMax: Int = 1\n        ^\n/tmp/tmp6vvwg453.swift:34:9:\
    \ error: invalid redeclaration of 'isPrimeCountMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMax'\n\
    \    var isPrimeCountMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n        ^\n/tmp/tmp6vvwg453.swift:33:9:\
    \ note: 'isPrimeCountMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMax' previously declared here\n\
    \    var isPrimeCountMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMax: Int = 1\n        ^\n/tmp/tmp6vvwg453.swift:35:9:\
    \ error: invalid redeclaration of 'isPrimeCountMaxMinMaxMax"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var factorization\
    \ = factorizationOf(n)\n    for factor in factorization {\n        factors.append(factor)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp2wh08yas.swift:13:25: error: cannot find 'factorizationOf' in scope\n\
    \    var factorization = factorizationOf(n)\n                        ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n    var factorization\
    \ = factorizationOfNumber(n)\n    for i in 0..<factorization.count {\n       \
    \ factors.append(factorization[i])\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpwjfxnu2v.swift:13:25: error: cannot find 'factorizationOfNumber'\
    \ in scope\n    var factorization = factorizationOfNumber(n)\n               \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824952
- exit_code: 1
  program: "\n/// Return list of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(8)\n/// [2,\
    \ 2, 2]\n/// >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5,\
    \ 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n   \
    \ var factorizationCount = 1\n    var factorizationIndex = 0\n    var factorizationFactor\
    \ = 1\n    var factorizationFactorIndex = 0\n    var factorizationFactorIndexMax\
    \ = Int(sqrt(Double(n)))\n    var factorizationFactorIndexMaxMinus1 = factorizationFactorIndexMax\
    \ - 1\n    var factorizationFactorIndexMaxMinus2 = factorizationFactorIndexMaxMinus1\
    \ - 1\n    var factorizationFactorIndexMaxMinus3 = factorizationFactorIndexMaxMinus2\
    \ - 1\n    var factorizationFactorIndexMaxMinus4 = factorizationFactorIndexMaxMinus3\
    \ - 1\n    var factorizationFactorIndexMaxMinus5 = factorizationFactorIndexMaxMinus4\
    \ - 1\n    var factorizationFactorIndexMaxMinus6 = factorizationFactorIndexMaxMinus5\
    \ - 1\n    var factorizationFactorIndexMaxMinus7 = factorizationFactorIndexMaxMinus6\
    \ - 1\n    var factorizationFactorIndexMaxMinus8 = factorizationFactorIndexMaxMinus7\
    \ - 1\n    var factorizationFactorIndexMaxMinus9 = factorizationFactorIndexMaxMinus8\
    \ - 1\n    var factorizationFactorIndexMaxMinus10 = factorizationFactorIndexMaxMinus9\
    \ - 1\n    var factorizationFactorIndexMaxMinus11 = factorizationFactorIndexMaxMinus10\
    \ - 1\n    var factorizationFactorIndexMaxMinus12 = factorizationFactorIndexMaxMinus11\
    \ - 1\n    var factorizationFactorIndexMaxMinus13 = factorizationFactorIndexMaxMinus12\
    \ - 1\n    var factorizationFactorIndexMaxMinus14 = factorizationFactorIndexMaxMinus13\
    \ - 1\n    var factorizationFactorIndexMaxMinus15 = factorizationFactorIndexMaxMinus14\
    \ - 1\n    var factorizationFactorIndexMaxMinus16 = factorizationFactorIndexMaxMinus15\
    \ - 1\n    var factorizationFactorIndexMaxMinus17 = factorizationFactorIndexMaxMinus16\
    \ - 1\n    var factorizationFactorIndexMaxMinus18 = factorizationFactorIndexMaxMinus17\
    \ - 1\n    var factorizationFactorIndexMaxMinus19 = factorizationFactorIndexMaxMinus18\
    \ - 1\n    var factorizationFactorIndexMaxMinus20 = factorizationFactorIndexMaxMinus19\
    \ - 1\n    var factorizationFactorIndexMaxMinus21 = factorizationFactorIndexMaxMinus20\
    \ - 1\n    var factorizationFactorIndexMaxMinus22 = factorizationFactorIndexMaxMinus21\
    \ - 1\n    var factorizationFactorIndexMaxMinus23 = factorizationFactorIndexMaxMinus22\
    \ - 1\n    var factorizationFactorIndexMaxMinus24 = factorizationFactorIndexMaxMinus23\
    \ - 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp3_0wl32g.swift:17:43: error: cannot find 'sqrt' in scope\n    var\
    \ factorizationFactorIndexMax = Int(sqrt(Double(n)))\n                       \
    \                   ^~~~\n"
  stdout: ''
  timestamp: 1659824952
