language: swift
name: HumanEval_14_all_prefixes
results:
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        if c == currentPrefix {\n           \
    \ prefixes.append(currentPrefix)\n        } else {\n            currentPrefix\
    \ = currentPrefix + c\n            prefixes.append(currentPrefix)\n        }\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp0keb8e_.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmpp0keb8e_.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmpp0keb8e_.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var current = string\n\
    \    while current != \"\" {\n        current = current.prefix(string)\n     \
    \   prefixes.append(current)\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpbv5iwncj.swift:9:34: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        current = current.prefix(string)\n\
    \                                 ^\n/tmp/tmpbv5iwncj.swift:9:27: error: no 'prefix'\
    \ candidates produce the expected contextual result type 'String'\n        current\
    \ = current.prefix(string)\n                          ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequence<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> PrefixSequence<Self>\n                                       ^\nSwift.Collection:6:40:\
    \ note: 'prefix' produces 'String.SubSequence' (aka 'Substring'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func prefix(_\
    \ maxLength: Int) -> Self.SubSequence\n                                      \
    \ ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        if character == currentPrefix[currentPrefix.startIndex]\
    \ {\n            currentPrefix = currentPrefix.substringToIndex(currentPrefix.startIndex\
    \ + 1)\n        } else {\n            prefixes.append(currentPrefix)\n       \
    \     currentPrefix = String(character)\n        }\n    }\n    prefixes.append(currentPrefix)\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp6rc379ip.swift:10:74: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n            currentPrefix = currentPrefix.substringToIndex(currentPrefix.startIndex\
    \ + 1)\n                                                                     \
    \    ^\n/tmp/tmp6rc379ip.swift:10:43: error: value of type 'String' has no member\
    \ 'substringToIndex'\n            currentPrefix = currentPrefix.substringToIndex(currentPrefix.startIndex\
    \ + 1)\n                            ~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        currentPrefix = String(currentPrefix)\
    \ + String(character)\n        prefixes.append(currentPrefix)\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    for c in string {\n\
    \        prefixes.append(string[..<string.index(before: c)])\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_t3v_oyy.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmp_t3v_oyy.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        if c == currentPrefix {\n           \
    \ prefixes.append(currentPrefix)\n        } else {\n            currentPrefix\
    \ = currentPrefix + c\n            prefixes.append(currentPrefix)\n        }\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp0keb8e_.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmpp0keb8e_.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmpp0keb8e_.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        currentPrefix = String(currentPrefix)\
    \ + String(character)\n        prefixes.append(currentPrefix)\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        currentPrefix = currentPrefix + c\n \
    \       if currentPrefix.count > prefixes.count {\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp86rl5_gm.swift:9:41: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        currentPrefix = currentPrefix +\
    \ c\n                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: -4
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var current = string\n\
    \    var longest = string\n    for _ in 0..<string.count {\n        current =\
    \ longest\n        longest = \"\"\n        for _ in 0..<string.count {\n     \
    \       current = current + string\n            if current.hasPrefix(string) {\n\
    \                longest = current\n                break\n            }\n   \
    \     }\n        prefixes.append(longest)\n    }\n    return prefixes\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: Exception
  stderr: 'tmp1mdopyjv/tmp1mdopyjv.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b83f08ecc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b83f05e3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b83f05e3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b83f05e27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1mdopyjv                        0x0000557740c68998 <unavailable> + 6552

    5    libc.so.6                          0x00002b83f0ad8460 __libc_start_main +
    245

    6    tmp1mdopyjv                        0x0000557740c683f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1660014230
- exit_code: -1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var current = string\n\
    \    while current != \"\" {\n        prefixes.append(current)\n        current\
    \ = prefixes.last!\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014235
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix = \"\"\n\
    \    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpz5pdtb79.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        if character == currentPrefix[currentPrefix.count]\
    \ {\n            prefixes.append(currentPrefix)\n        }\n        currentPrefix\
    \ = currentPrefix + character\n    }\n    prefixes.append(currentPrefix)\n   \
    \ return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp5f7tednz.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp5f7tednz.swift:12:41:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        currentPrefix = currentPrefix + character\n                         \
    \               ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        if c == currentPrefix {\n           \
    \ prefixes.append(currentPrefix)\n        } else {\n            currentPrefix\
    \ = currentPrefix + c\n        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0w4a8mib.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmp0w4a8mib.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmp0w4a8mib.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        currentPrefix = currentPrefix + c\n \
    \       prefixes.append(currentPrefix)\n    }\n    return prefixes\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp6thv23g.swift:9:41: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        currentPrefix = currentPrefix +\
    \ c\n                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    for c in string {\n\
    \        prefixes.append(string[..<string.index(before: c)])\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_t3v_oyy.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmp_t3v_oyy.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        currentPrefix = currentPrefix\
    \ + String(character)\n        prefixes.append(currentPrefix)\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var current = string\n\
    \    while current != \"\" {\n        current = current.prefix(string)\n     \
    \   prefixes.append(current)\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpbv5iwncj.swift:9:34: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        current = current.prefix(string)\n\
    \                                 ^\n/tmp/tmpbv5iwncj.swift:9:27: error: no 'prefix'\
    \ candidates produce the expected contextual result type 'String'\n        current\
    \ = current.prefix(string)\n                          ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequence<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> PrefixSequence<Self>\n                                       ^\nSwift.Collection:6:40:\
    \ note: 'prefix' produces 'String.SubSequence' (aka 'Substring'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func prefix(_\
    \ maxLength: Int) -> Self.SubSequence\n                                      \
    \ ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        if c == currentPrefix {\n           \
    \ prefixes.append(currentPrefix)\n        } else {\n            currentPrefix\
    \ = currentPrefix + c\n            prefixes.append(currentPrefix)\n        }\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp0keb8e_.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmpp0keb8e_.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmpp0keb8e_.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        if c == currentPrefix {\n           \
    \ prefixes.append(currentPrefix)\n        } else {\n            currentPrefix\
    \ = currentPrefix + c\n            prefixes.append(currentPrefix)\n        }\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp0keb8e_.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmpp0keb8e_.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmpp0keb8e_.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        currentPrefix = currentPrefix + c\n \
    \       prefixes.append(currentPrefix)\n    }\n    return prefixes\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp6thv23g.swift:9:41: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        currentPrefix = currentPrefix +\
    \ c\n                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        if c == currentPrefix {\n           \
    \ prefixes.append(currentPrefix)\n        } else {\n            currentPrefix\
    \ = currentPrefix + c\n            prefixes.append(currentPrefix)\n        }\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp0keb8e_.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmpp0keb8e_.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmpp0keb8e_.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        currentPrefix = currentPrefix\
    \ + String(character)\n        prefixes.append(currentPrefix)\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    for s in string.split(separator:\
    \ \"\") {\n        prefixes.append(s)\n    }\n    return prefixes\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9ihic89c.swift:8:18: error: no exact matches in call to instance\
    \ method 'append'\n        prefixes.append(s)\n                 ^\nSwift.Array:6:37:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'String.SubSequence'\
    \ (aka 'Substring'))\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Element)\n                                    ^\nSwift.RangeReplaceableCollection:4:37:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'String.SubSequence'\
    \ (aka 'Substring'))\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Self.Element)\n                                    ^\n/tmp/tmp9ihic89c.swift:8:18:\
    \ note: found candidate with type '(__owned String.SubSequence) -> ()' (aka '(__owned\
    \ Substring) -> ()')\n        prefixes.append(s)\n                 ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        if character == currentPrefix[currentPrefix.count]\
    \ {\n            currentPrefix = currentPrefix + character\n        } else {\n\
    \            prefixes.append(currentPrefix)\n            currentPrefix = character\n\
    \        }\n    }\n    prefixes.append(currentPrefix)\n    return prefixes\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq83pq_yl.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpq83pq_yl.swift:10:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + character\n                     \
    \                       ^\n/tmp/tmpq83pq_yl.swift:13:29: error: cannot assign\
    \ value of type 'Character' to type 'String'\n            currentPrefix = character\n\
    \                            ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix = \"\"\n\
    \    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \        prefix = \"\"\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpd7yozare.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        if c == currentPrefix {\n           \
    \ prefixes.append(currentPrefix)\n        } else {\n            currentPrefix\
    \ = currentPrefix + c\n            prefixes.append(currentPrefix)\n        }\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp0keb8e_.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmpp0keb8e_.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmpp0keb8e_.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        if c == currentPrefix {\n           \
    \ prefixes.append(currentPrefix)\n        } else {\n            currentPrefix\
    \ = currentPrefix + c\n            prefixes.append(currentPrefix)\n        }\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp0keb8e_.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmpp0keb8e_.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmpp0keb8e_.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix: String\
    \ = \"\"\n    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpumasloxf.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: -1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var current = string\n\
    \    while current != \"\" {\n        prefixes.append(current)\n        current\
    \ = prefixes.last!\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014235
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    for s in string.split(separator:\
    \ \"\") {\n        prefixes.append(s)\n    }\n    return prefixes\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9ihic89c.swift:8:18: error: no exact matches in call to instance\
    \ method 'append'\n        prefixes.append(s)\n                 ^\nSwift.Array:6:37:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'String.SubSequence'\
    \ (aka 'Substring'))\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Element)\n                                    ^\nSwift.RangeReplaceableCollection:4:37:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'String.SubSequence'\
    \ (aka 'Substring'))\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Self.Element)\n                                    ^\n/tmp/tmp9ihic89c.swift:8:18:\
    \ note: found candidate with type '(__owned String.SubSequence) -> ()' (aka '(__owned\
    \ Substring) -> ()')\n        prefixes.append(s)\n                 ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix = \"\"\n\
    \    for c in string {\n        if c == prefix {\n            prefixes.append(prefix)\n\
    \            prefix = \"\"\n        } else {\n            prefix += c\n      \
    \  }\n    }\n    prefixes.append(prefix)\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjgmjwavd.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == prefix {\n   \
    \        ~ ^  ~~~~~~\n/tmp/tmpjgmjwavd.swift:9:14: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n        if c == prefix {\n             ^\n/tmp/tmpjgmjwavd.swift:13:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prefix += c\n                      ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        currentPrefix = currentPrefix + c\n \
    \       prefixes.append(currentPrefix)\n    }\n    return prefixes\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp6thv23g.swift:9:41: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        currentPrefix = currentPrefix +\
    \ c\n                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        if c == currentPrefix {\n           \
    \ prefixes.append(c)\n        } else {\n            currentPrefix = c\n      \
    \  }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpqgoj4r4n.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmpqgoj4r4n.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmpqgoj4r4n.swift:10:29:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prefixes.append(c)\n                            ^\n/tmp/tmpqgoj4r4n.swift:12:29:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \  currentPrefix = c\n                            ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var current = string\n\
    \    var i = 0\n    while i < len(current) {\n        current = current[i..<string.count]\n\
    \        prefixes.append(current)\n        i += 1\n    }\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpqnzg9kc4.swift:9:15: error: cannot find 'len' in scope\n    while\
    \ i < len(current) {\n              ^~~\n/tmp/tmpqnzg9kc4.swift:10:19: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an integer range,\
    \ use a String.Index range instead.\n        current = current[i..<string.count]\n\
    \                  ^~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript<R>(bounds:\
    \ R) -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    for c in string {\n\
    \        prefixes.append(string[..<string.index(before: c)])\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_t3v_oyy.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmp_t3v_oyy.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var current = string\n\
    \    while current != \"\" {\n        current = current.prefix(string.count)\n\
    \        prefixes.append(current)\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpywyeh2ed.swift:9:27: error: no 'prefix' candidates produce the\
    \ expected contextual result type 'String'\n        current = current.prefix(string.count)\n\
    \                          ^\nSwift.Sequence:7:40: note: 'prefix' produces 'PrefixSequence<String>',\
    \ not the expected contextual result type 'String'\n    @inlinable public __consuming\
    \ func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n                    \
    \                   ^\nSwift.Sequence:7:40: note: 'prefix' produces 'PrefixSequence<String>',\
    \ not the expected contextual result type 'String'\n    @inlinable public __consuming\
    \ func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n                    \
    \                   ^\nSwift.Collection:6:40: note: 'prefix' produces 'String.SubSequence'\
    \ (aka 'Substring'), not the expected contextual result type 'String'\n    @inlinable\
    \ public __consuming func prefix(_ maxLength: Int) -> Self.SubSequence\n     \
    \                                  ^\nSwift.Collection:6:40: note: 'prefix' produces\
    \ 'String.SubSequence' (aka 'Substring'), not the expected contextual result type\
    \ 'String'\n    @inlinable public __consuming func prefix(_ maxLength: Int) ->\
    \ Self.SubSequence\n                                       ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: -4
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        if character == currentPrefix[currentPrefix.startIndex]\
    \ {\n            prefixes.append(currentPrefix)\n        } else {\n          \
    \  currentPrefix = String(character) + currentPrefix\n        }\n    }\n    prefixes.append(currentPrefix)\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: Exception
  stderr: 'tmpl9l8yi7_/tmpl9l8yi7_.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5a7f731c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5a7f428b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5a7f428988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5a7f4277b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9l8yi7_                        0x000055a17ce2778e <unavailable> + 6030

    5    libc.so.6                          0x00002b5a7f91d460 __libc_start_main +
    245

    6    tmpl9l8yi7_                        0x000055a17ce273d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    for s in string.characters\
    \ {\n        prefixes = append(prefixes, String(s))\n    }\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpto79lbze.swift:7:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for s in string.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpto79lbze.swift:8:20:\
    \ error: cannot find 'append' in scope\n        prefixes = append(prefixes, String(s))\n\
    \                   ^~~~~~\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        if character == currentPrefix\
    \ {\n            prefixes.append(currentPrefix)\n        } else {\n          \
    \  currentPrefix = String(character) + currentPrefix\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpchj1eeni.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpchj1eeni.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix = \"\"\n\
    \    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \        prefix = \"\"\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpd7yozare.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        if character == currentPrefix\
    \ {\n            prefixes.append(currentPrefix)\n        } else {\n          \
    \  currentPrefix = String(character) + currentPrefix\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpchj1eeni.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpchj1eeni.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: -4
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var current = string\n\
    \    var prefix: String = \"\"\n    while current != \"\" {\n        prefix =\
    \ current + prefix\n        current = prefixes.last!\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: Exception
  stderr: 'tmpc98u9l74/tmpc98u9l74.swift:11: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002ac013bbbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac0138b2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac0138b2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac0138b213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac0138b1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpc98u9l74                        0x00005640083dddcf <unavailable> + 7631

    6    tmpc98u9l74                        0x00005640083dd737 <unavailable> + 5943

    7    libc.so.6                          0x00002ac013da7460 __libc_start_main +
    245

    8    tmpc98u9l74                        0x00005640083dd359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        if c == currentPrefix {\n           \
    \ prefixes.append(currentPrefix)\n        } else {\n            currentPrefix\
    \ = currentPrefix + c\n            prefixes.append(currentPrefix)\n        }\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp0keb8e_.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmpp0keb8e_.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmpp0keb8e_.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        currentPrefix = currentPrefix + c\n \
    \       if currentPrefix.hasPrefix(string) {\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpc14v55de.swift:9:41: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        currentPrefix = currentPrefix +\
    \ c\n                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        currentPrefix = currentPrefix + c\n \
    \       if currentPrefix.hasPrefix(string) {\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpc14v55de.swift:9:41: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        currentPrefix = currentPrefix +\
    \ c\n                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix: String\
    \ = \"\"\n    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpumasloxf.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        currentPrefix = currentPrefix + c\n \
    \       prefixes.append(currentPrefix)\n    }\n    return prefixes\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp6thv23g.swift:9:41: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        currentPrefix = currentPrefix +\
    \ c\n                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        if c == currentPrefix {\n           \
    \ prefixes.append(currentPrefix)\n        } else {\n            currentPrefix\
    \ = currentPrefix + c\n            prefixes.append(currentPrefix)\n        }\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp0keb8e_.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmpp0keb8e_.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmpp0keb8e_.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        if character == currentPrefix\
    \ {\n            prefixes.append(currentPrefix)\n        } else {\n          \
    \  currentPrefix = String(character) + currentPrefix\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpchj1eeni.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpchj1eeni.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        currentPrefix = String(currentPrefix)\
    \ + String(character)\n        prefixes.append(currentPrefix)\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var current = string\n\
    \    while current != \"\" {\n        current = current.prefix(string)\n     \
    \   prefixes.append(current)\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpbv5iwncj.swift:9:34: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        current = current.prefix(string)\n\
    \                                 ^\n/tmp/tmpbv5iwncj.swift:9:27: error: no 'prefix'\
    \ candidates produce the expected contextual result type 'String'\n        current\
    \ = current.prefix(string)\n                          ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequence<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> PrefixSequence<Self>\n                                       ^\nSwift.Collection:6:40:\
    \ note: 'prefix' produces 'String.SubSequence' (aka 'Substring'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func prefix(_\
    \ maxLength: Int) -> Self.SubSequence\n                                      \
    \ ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix = \"\"\n\
    \    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpz5pdtb79.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        if character == currentPrefix\
    \ {\n            prefixes.append(currentPrefix)\n        } else {\n          \
    \  currentPrefix = String(character) + currentPrefix\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpchj1eeni.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpchj1eeni.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    for c in string {\n\
    \        prefixes.append(string[..<string.index(before: c)])\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_t3v_oyy.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmp_t3v_oyy.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        if character == currentPrefix[currentPrefix.count]\
    \ {\n            currentPrefix = currentPrefix[currentPrefix.startIndex..<currentPrefix.endIndex]\n\
    \        } else {\n            prefixes.append(currentPrefix)\n            currentPrefix\
    \ = character\n        }\n    }\n    prefixes.append(currentPrefix)\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp3ddx48u.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpp3ddx48u.swift:10:42:\
    \ error: cannot assign value of type 'Substring' to type 'String'\n          \
    \  currentPrefix = currentPrefix[currentPrefix.startIndex..<currentPrefix.endIndex]\n\
    \                            ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \                            String(                                         \
    \                )\n/tmp/tmpp3ddx48u.swift:13:29: error: cannot assign value of\
    \ type 'Character' to type 'String'\n            currentPrefix = character\n \
    \                           ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        if character == currentPrefix[currentPrefix.count]\
    \ {\n            prefixes.append(currentPrefix)\n        } else {\n          \
    \  currentPrefix = currentPrefix + character\n        }\n    }\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpnt6b10fj.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpnt6b10fj.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + character\n                     \
    \                       ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        currentPrefix = currentPrefix + c\n \
    \       if currentPrefix.hasPrefix(string) {\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpc14v55de.swift:9:41: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        currentPrefix = currentPrefix +\
    \ c\n                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix = \"\"\n\
    \    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpz5pdtb79.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    for c in string {\n\
    \        prefixes.append(string[..<string.index(before: c)])\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_t3v_oyy.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmp_t3v_oyy.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix = \"\"\n\
    \    for c in string {\n        if c == prefix {\n            prefixes.append(prefix)\n\
    \        } else {\n            prefix = prefix + c\n            prefixes.append(prefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3ri5olu3.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == prefix {\n   \
    \        ~ ^  ~~~~~~\n/tmp/tmp3ri5olu3.swift:9:14: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n        if c == prefix {\n             ^\n/tmp/tmp3ri5olu3.swift:12:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prefix = prefix + c\n                              ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        currentPrefix = String(currentPrefix)\
    \ + String(character)\n        prefixes.append(currentPrefix)\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    for c in string {\n\
    \        prefixes.append(string[..<string.index(before: c)])\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_t3v_oyy.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmp_t3v_oyy.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: -1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var current = string\n\
    \    while current != \"\" {\n        prefixes.append(current)\n        current\
    \ = prefixes.last!\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014235
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        currentPrefix = String(currentPrefix)\
    \ + String(character)\n        prefixes.append(currentPrefix)\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    for c in string {\n\
    \        prefixes.append(string[..<string.index(before: c)])\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_t3v_oyy.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmp_t3v_oyy.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix = \"\"\n\
    \    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpz5pdtb79.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        currentPrefix = String(currentPrefix)\
    \ + String(character)\n        prefixes.append(currentPrefix)\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        if c == currentPrefix {\n           \
    \ prefixes.append(currentPrefix)\n        } else {\n            currentPrefix\
    \ = currentPrefix + c\n            prefixes.append(currentPrefix)\n        }\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp0keb8e_.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmpp0keb8e_.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmpp0keb8e_.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix = \"\"\n\
    \    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpz5pdtb79.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix = \"\"\n\
    \    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \        prefix = \"\"\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpd7yozare.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        if character == currentPrefix[currentPrefix.count]\
    \ {\n            prefixes.append(currentPrefix)\n        }\n        currentPrefix\
    \ = currentPrefix + character\n    }\n    prefixes.append(currentPrefix)\n   \
    \ return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp5f7tednz.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp5f7tednz.swift:12:41:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        currentPrefix = currentPrefix + character\n                         \
    \               ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        currentPrefix = currentPrefix + c\n \
    \       prefixes.append(currentPrefix)\n    }\n    return prefixes\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp6thv23g.swift:9:41: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        currentPrefix = currentPrefix +\
    \ c\n                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    for s in string.split(separator:\
    \ \"\") {\n        prefixes.append(s)\n    }\n    return prefixes\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9ihic89c.swift:8:18: error: no exact matches in call to instance\
    \ method 'append'\n        prefixes.append(s)\n                 ^\nSwift.Array:6:37:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'String.SubSequence'\
    \ (aka 'Substring'))\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Element)\n                                    ^\nSwift.RangeReplaceableCollection:4:37:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'String.SubSequence'\
    \ (aka 'Substring'))\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Self.Element)\n                                    ^\n/tmp/tmp9ihic89c.swift:8:18:\
    \ note: found candidate with type '(__owned String.SubSequence) -> ()' (aka '(__owned\
    \ Substring) -> ()')\n        prefixes.append(s)\n                 ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    for c in string {\n\
    \        for p in prefixes {\n            if c == p {\n                break\n\
    \            }\n        }\n        if p != nil {\n            prefixes.append(p)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3_8lgl7h.swift:9:18: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if c == p {\n    \
    \           ~ ^  ~\n/tmp/tmp3_8lgl7h.swift:9:18: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n            if c == p {\n                 ^\n/tmp/tmp3_8lgl7h.swift:13:12:\
    \ error: cannot find 'p' in scope\n        if p != nil {\n           ^\n/tmp/tmp3_8lgl7h.swift:14:29:\
    \ error: cannot find 'p' in scope\n            prefixes.append(p)\n          \
    \                  ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix = \"\"\n\
    \    for c in string {\n        prefix += c\n        if prefixes.contains(prefix)\
    \ {\n            prefixes.append(prefix)\n        }\n    }\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpmjm162b6.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        if c == currentPrefix {\n           \
    \ prefixes.append(currentPrefix)\n        } else {\n            currentPrefix\
    \ = currentPrefix + c\n            prefixes.append(currentPrefix)\n        }\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp0keb8e_.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmpp0keb8e_.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmpp0keb8e_.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    for s in string.split(separator:\
    \ \"\") {\n        prefixes.append(s)\n    }\n    return prefixes\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9ihic89c.swift:8:18: error: no exact matches in call to instance\
    \ method 'append'\n        prefixes.append(s)\n                 ^\nSwift.Array:6:37:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'String.SubSequence'\
    \ (aka 'Substring'))\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Element)\n                                    ^\nSwift.RangeReplaceableCollection:4:37:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'String.SubSequence'\
    \ (aka 'Substring'))\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Self.Element)\n                                    ^\n/tmp/tmp9ihic89c.swift:8:18:\
    \ note: found candidate with type '(__owned String.SubSequence) -> ()' (aka '(__owned\
    \ Substring) -> ()')\n        prefixes.append(s)\n                 ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        currentPrefix = currentPrefix\
    \ + String(character)\n        prefixes.append(currentPrefix)\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        currentPrefix = currentPrefix + c\n \
    \       prefixes.append(currentPrefix)\n    }\n    return prefixes\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp6thv23g.swift:9:41: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        currentPrefix = currentPrefix +\
    \ c\n                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix: String\
    \ = \"\"\n    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpumasloxf.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    for c in string {\n\
    \        prefixes.append(string[..<string.index(before: c)])\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_t3v_oyy.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmp_t3v_oyy.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix = \"\"\n\
    \    for c in string {\n        if c == prefix {\n            prefixes.append(prefix)\n\
    \        } else {\n            prefix = prefix + c\n            prefixes.append(prefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3ri5olu3.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == prefix {\n   \
    \        ~ ^  ~~~~~~\n/tmp/tmp3ri5olu3.swift:9:14: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n        if c == prefix {\n             ^\n/tmp/tmp3ri5olu3.swift:12:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prefix = prefix + c\n                              ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    for c in string {\n\
    \        for p in prefixes {\n            if c == p {\n                break\n\
    \            }\n        }\n        if p != nil {\n            prefixes.append(p)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3_8lgl7h.swift:9:18: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if c == p {\n    \
    \           ~ ^  ~\n/tmp/tmp3_8lgl7h.swift:9:18: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n            if c == p {\n                 ^\n/tmp/tmp3_8lgl7h.swift:13:12:\
    \ error: cannot find 'p' in scope\n        if p != nil {\n           ^\n/tmp/tmp3_8lgl7h.swift:14:29:\
    \ error: cannot find 'p' in scope\n            prefixes.append(p)\n          \
    \                  ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    for c in string {\n\
    \        prefixes.append(string[..<string.index(before: c)])\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_t3v_oyy.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmp_t3v_oyy.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    for c in string {\n\
    \        prefixes.append(string[..<string.index(before: c)])\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_t3v_oyy.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmp_t3v_oyy.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        if character == currentPrefix[currentPrefix.count-1]\
    \ {\n            currentPrefix = currentPrefix[currentPrefix.count-1] + character\n\
    \        } else {\n            prefixes.append(currentPrefix)\n            currentPrefix\
    \ = character\n        }\n    }\n    prefixes.append(currentPrefix)\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpmxksmx6a.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpmxksmx6a.swift:10:68:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix[currentPrefix.count-1] + character\n\
    \                                                                   ^\n/tmp/tmpmxksmx6a.swift:10:42:\
    \ error: no exact matches in call to subscript \n            currentPrefix = currentPrefix[currentPrefix.count-1]\
    \ + character\n                                         ^\n/tmp/tmpmxksmx6a.swift:10:42:\
    \ note: candidate has partially matching parameter list (Range<String.Index>)\n\
    \            currentPrefix = currentPrefix[currentPrefix.count-1] + character\n\
    \                                         ^\n/tmp/tmpmxksmx6a.swift:10:42: note:\
    \ candidate has partially matching parameter list ((UnboundedRange_) -> ())\n\
    \            currentPrefix = currentPrefix[currentPrefix.count-1] + character\n\
    \                                         ^\n/tmp/tmpmxksmx6a.swift:13:29: error:\
    \ cannot assign value of type 'Character' to type 'String'\n            currentPrefix\
    \ = character\n                            ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix = \"\"\n\
    \    for c in string {\n        prefix += c\n        if prefixes.contains(prefix)\
    \ {\n            prefixes.append(prefix)\n        }\n    }\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpmjm162b6.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix = \"\"\n\
    \    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpz5pdtb79.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        if character == currentPrefix\
    \ {\n            prefixes.append(currentPrefix)\n        } else {\n          \
    \  currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmps61zxf2z.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmps61zxf2z.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: -1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var current = string\n\
    \    while current != \"\" {\n        prefixes.append(current)\n        current\
    \ = prefixes.last!\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014235
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        if character == currentPrefix[currentPrefix.count]\
    \ {\n            prefixes.append(currentPrefix)\n        } else {\n          \
    \  currentPrefix = currentPrefix + character\n        }\n    }\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpnt6b10fj.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpnt6b10fj.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + character\n                     \
    \                       ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix = \"\"\n\
    \    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpz5pdtb79.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    for c in string {\n\
    \        prefixes.append(string[..<string.index(before: c)])\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_t3v_oyy.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmp_t3v_oyy.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix = \"\"\n\
    \    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpz5pdtb79.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    for c in string {\n\
    \        prefixes.append(string[..<string.index(before: c)])\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_t3v_oyy.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmp_t3v_oyy.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        if character == currentPrefix[currentPrefix.count]\
    \ {\n            prefixes.append(currentPrefix)\n        } else {\n          \
    \  currentPrefix = currentPrefix + character\n        }\n    }\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpnt6b10fj.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpnt6b10fj.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + character\n                     \
    \                       ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix = \"\"\n\
    \    for c in string {\n        if c == prefix {\n            prefixes.append(prefix)\n\
    \        } else {\n            prefix = prefix + c\n        }\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpo_m30sjc.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == prefix {\n   \
    \        ~ ^  ~~~~~~\n/tmp/tmpo_m30sjc.swift:9:14: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n        if c == prefix {\n             ^\n/tmp/tmpo_m30sjc.swift:12:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prefix = prefix + c\n                              ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    for c in string {\n\
    \        prefixes.append(string[..<string.index(before: c)])\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_t3v_oyy.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmp_t3v_oyy.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix = \"\"\n\
    \    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpz5pdtb79.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix = \"\"\n\
    \    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpz5pdtb79.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        if character == currentPrefix[currentPrefix.count-1]\
    \ {\n            currentPrefix = currentPrefix + character\n        } else {\n\
    \            prefixes.append(currentPrefix)\n            currentPrefix = character\n\
    \        }\n    }\n    prefixes.append(currentPrefix)\n    return prefixes\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpkt9qiqri.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpkt9qiqri.swift:10:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + character\n                     \
    \                       ^\n/tmp/tmpkt9qiqri.swift:13:29: error: cannot assign\
    \ value of type 'Character' to type 'String'\n            currentPrefix = character\n\
    \                            ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix = \"\"\n\
    \    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpz5pdtb79.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    for c in string {\n\
    \        prefixes.append(string[..<string.index(before: c)])\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_t3v_oyy.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmp_t3v_oyy.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix: String\
    \ = \"\"\n    for c in string {\n        prefix += c\n        if prefixes.contains(prefix)\
    \ {\n            prefixes.append(prefix)\n        }\n    }\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpdi8ajkyw.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var current = string\n\
    \    while !current.isEmpty {\n        prefixes.append(current)\n        current\
    \ = current.prefix(string.count)\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp42htok3d.swift:10:27: error: no 'prefix' candidates produce the\
    \ expected contextual result type 'String'\n        current = current.prefix(string.count)\n\
    \                          ^\nSwift.Sequence:7:40: note: 'prefix' produces 'PrefixSequence<String>',\
    \ not the expected contextual result type 'String'\n    @inlinable public __consuming\
    \ func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n                    \
    \                   ^\nSwift.Sequence:7:40: note: 'prefix' produces 'PrefixSequence<String>',\
    \ not the expected contextual result type 'String'\n    @inlinable public __consuming\
    \ func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n                    \
    \                   ^\nSwift.Collection:6:40: note: 'prefix' produces 'String.SubSequence'\
    \ (aka 'Substring'), not the expected contextual result type 'String'\n    @inlinable\
    \ public __consuming func prefix(_ maxLength: Int) -> Self.SubSequence\n     \
    \                                  ^\nSwift.Collection:6:40: note: 'prefix' produces\
    \ 'String.SubSequence' (aka 'Substring'), not the expected contextual result type\
    \ 'String'\n    @inlinable public __consuming func prefix(_ maxLength: Int) ->\
    \ Self.SubSequence\n                                       ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    for c in string {\n\
    \        prefixes.append(string[..<string.index(before: c)])\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_t3v_oyy.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmp_t3v_oyy.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var current = string\n\
    \    while current != \"\" {\n        current = current.prefix(string)\n     \
    \   prefixes.append(current)\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpbv5iwncj.swift:9:34: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        current = current.prefix(string)\n\
    \                                 ^\n/tmp/tmpbv5iwncj.swift:9:27: error: no 'prefix'\
    \ candidates produce the expected contextual result type 'String'\n        current\
    \ = current.prefix(string)\n                          ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequence<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> PrefixSequence<Self>\n                                       ^\nSwift.Collection:6:40:\
    \ note: 'prefix' produces 'String.SubSequence' (aka 'Substring'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func prefix(_\
    \ maxLength: Int) -> Self.SubSequence\n                                      \
    \ ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: -4
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        if character == currentPrefix[currentPrefix.startIndex]\
    \ {\n            prefixes.append(currentPrefix)\n        }\n        currentPrefix\
    \ = String(character) + currentPrefix\n    }\n    prefixes.append(currentPrefix)\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: Exception
  stderr: 'tmpee06_jx2/tmpee06_jx2.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7ce3882c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7ce3579b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7ce3579988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7ce35787b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpee06_jx2                        0x0000562658b7778e <unavailable> + 6030

    5    libc.so.6                          0x00002b7ce3a6e460 __libc_start_main +
    245

    6    tmpee06_jx2                        0x0000562658b773d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        if character == currentPrefix[currentPrefix.count]\
    \ {\n            prefixes.append(currentPrefix)\n        }\n        currentPrefix\
    \ = currentPrefix + character\n    }\n    prefixes.append(currentPrefix)\n   \
    \ return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp5f7tednz.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp5f7tednz.swift:12:41:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        currentPrefix = currentPrefix + character\n                         \
    \               ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        currentPrefix = currentPrefix + c\n \
    \       prefixes.append(currentPrefix)\n    }\n    return prefixes\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp6thv23g.swift:9:41: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        currentPrefix = currentPrefix +\
    \ c\n                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix = \"\"\n\
    \    for c in string {\n        if c == prefix {\n            prefixes.append(prefix)\n\
    \            prefix = \"\"\n        } else {\n            prefix += c\n      \
    \  }\n    }\n    prefixes.append(prefix)\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjgmjwavd.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == prefix {\n   \
    \        ~ ^  ~~~~~~\n/tmp/tmpjgmjwavd.swift:9:14: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n        if c == prefix {\n             ^\n/tmp/tmpjgmjwavd.swift:13:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prefix += c\n                      ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        currentPrefix = String(currentPrefix)\
    \ + String(character)\n        prefixes.append(currentPrefix)\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        currentPrefix = currentPrefix + c\n \
    \       prefixes.append(currentPrefix)\n    }\n    return prefixes\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp6thv23g.swift:9:41: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        currentPrefix = currentPrefix +\
    \ c\n                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix = \"\"\n\
    \    for c in string {\n        if c == prefix {\n            prefixes.append(prefix)\n\
    \            prefix = \"\"\n        } else {\n            prefix += c\n      \
    \  }\n    }\n    prefixes.append(prefix)\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjgmjwavd.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == prefix {\n   \
    \        ~ ^  ~~~~~~\n/tmp/tmpjgmjwavd.swift:9:14: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n        if c == prefix {\n             ^\n/tmp/tmpjgmjwavd.swift:13:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prefix += c\n                      ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        currentPrefix = currentPrefix + c\n \
    \       prefixes.append(currentPrefix)\n    }\n    return prefixes\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp6thv23g.swift:9:41: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        currentPrefix = currentPrefix +\
    \ c\n                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        if c == currentPrefix {\n           \
    \ prefixes.append(currentPrefix)\n        } else {\n            currentPrefix\
    \ = currentPrefix + c\n            prefixes.append(currentPrefix)\n        }\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp0keb8e_.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmpp0keb8e_.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmpp0keb8e_.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: -4
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        currentPrefix = currentPrefix\
    \ + String(character)\n        if currentPrefix.hasPrefix(string) {\n        \
    \    prefixes.append(currentPrefix)\n        }\n    }\n    return prefixes\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: Exception
  stderr: 'tmpwp1rtp8k/tmpwp1rtp8k.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae66b2c9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae66afc0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae66afc0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae66afbf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwp1rtp8k                        0x000055d2ca6878d8 <unavailable> + 6360

    5    libc.so.6                          0x00002ae66b4b5460 __libc_start_main +
    245

    6    tmpwp1rtp8k                        0x000055d2ca687339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        if character == currentPrefix[currentPrefix.count]\
    \ {\n            prefixes.append(currentPrefix)\n        } else {\n          \
    \  currentPrefix = currentPrefix + character\n        }\n    }\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpnt6b10fj.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpnt6b10fj.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + character\n                     \
    \                       ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    for c in string {\n\
    \        prefixes.append(string[..<string.index(before: c)])\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_t3v_oyy.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmp_t3v_oyy.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        currentPrefix = String(currentPrefix)\
    \ + String(character)\n        prefixes.append(currentPrefix)\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        if character == currentPrefix[currentPrefix.count]\
    \ {\n            prefixes.append(currentPrefix)\n        }\n        currentPrefix\
    \ = currentPrefix + character\n    }\n    prefixes.append(currentPrefix)\n   \
    \ return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp5f7tednz.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp5f7tednz.swift:12:41:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        currentPrefix = currentPrefix + character\n                         \
    \               ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        currentPrefix = String(currentPrefix)\
    \ + String(character)\n        prefixes.append(currentPrefix)\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    for c in string {\n\
    \        prefixes.append(string[..<string.index(before: c)])\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_t3v_oyy.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmp_t3v_oyy.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    for c in string {\n\
    \        prefixes.append(string[..<string.index(before: c)])\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_t3v_oyy.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmp_t3v_oyy.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        currentPrefix = currentPrefix + c\n \
    \       prefixes.append(currentPrefix)\n    }\n    return prefixes\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp6thv23g.swift:9:41: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        currentPrefix = currentPrefix +\
    \ c\n                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    for s in string.split(separator:\
    \ \"\") {\n        prefixes.append(s)\n    }\n    return prefixes\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9ihic89c.swift:8:18: error: no exact matches in call to instance\
    \ method 'append'\n        prefixes.append(s)\n                 ^\nSwift.Array:6:37:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'String.SubSequence'\
    \ (aka 'Substring'))\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Element)\n                                    ^\nSwift.RangeReplaceableCollection:4:37:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'String.SubSequence'\
    \ (aka 'Substring'))\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Self.Element)\n                                    ^\n/tmp/tmp9ihic89c.swift:8:18:\
    \ note: found candidate with type '(__owned String.SubSequence) -> ()' (aka '(__owned\
    \ Substring) -> ()')\n        prefixes.append(s)\n                 ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        if c == currentPrefix {\n           \
    \ prefixes.append(currentPrefix)\n        } else {\n            currentPrefix\
    \ = currentPrefix + c\n            prefixes.append(currentPrefix)\n        }\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp0keb8e_.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmpp0keb8e_.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmpp0keb8e_.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        if character == currentPrefix[currentPrefix.count-1]\
    \ {\n            prefixes.append(currentPrefix)\n        } else {\n          \
    \  currentPrefix = currentPrefix + String(character)\n        }\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpvxgccx70.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    for c in string {\n\
    \        prefixes.append(string[..<string.index(before: c)])\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_t3v_oyy.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmp_t3v_oyy.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var current = string\n\
    \    while current != \"\" {\n        current = current.prefix(string)\n     \
    \   prefixes.append(current)\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpbv5iwncj.swift:9:34: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        current = current.prefix(string)\n\
    \                                 ^\n/tmp/tmpbv5iwncj.swift:9:27: error: no 'prefix'\
    \ candidates produce the expected contextual result type 'String'\n        current\
    \ = current.prefix(string)\n                          ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequence<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> PrefixSequence<Self>\n                                       ^\nSwift.Collection:6:40:\
    \ note: 'prefix' produces 'String.SubSequence' (aka 'Substring'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func prefix(_\
    \ maxLength: Int) -> Self.SubSequence\n                                      \
    \ ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix: String\
    \ = \"\"\n    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpumasloxf.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        if c == currentPrefix {\n           \
    \ prefixes.append(currentPrefix)\n        } else {\n            currentPrefix\
    \ = currentPrefix + c\n            prefixes.append(currentPrefix)\n        }\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp0keb8e_.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmpp0keb8e_.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmpp0keb8e_.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        if c == currentPrefix {\n           \
    \ prefixes.append(currentPrefix)\n        } else {\n            currentPrefix\
    \ = currentPrefix + c\n            prefixes.append(currentPrefix)\n        }\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp0keb8e_.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmpp0keb8e_.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmpp0keb8e_.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        currentPrefix = currentPrefix + c\n \
    \       prefixes.append(currentPrefix)\n    }\n    return prefixes\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp6thv23g.swift:9:41: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        currentPrefix = currentPrefix +\
    \ c\n                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix = \"\"\n\
    \    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpz5pdtb79.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        if character == currentPrefix[currentPrefix.count]\
    \ {\n            prefixes.append(currentPrefix)\n        }\n        currentPrefix\
    \ = currentPrefix + character\n    }\n    prefixes.append(currentPrefix)\n   \
    \ return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp5f7tednz.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp5f7tednz.swift:12:41:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        currentPrefix = currentPrefix + character\n                         \
    \               ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        if character == currentPrefix[currentPrefix.count-1]\
    \ {\n            currentPrefix = currentPrefix + character\n        } else {\n\
    \            prefixes.append(currentPrefix)\n            currentPrefix = character\n\
    \        }\n    }\n    prefixes.append(currentPrefix)\n    return prefixes\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpkt9qiqri.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpkt9qiqri.swift:10:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + character\n                     \
    \                       ^\n/tmp/tmpkt9qiqri.swift:13:29: error: cannot assign\
    \ value of type 'Character' to type 'String'\n            currentPrefix = character\n\
    \                            ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        if c == currentPrefix {\n           \
    \ prefixes.append(currentPrefix)\n        } else {\n            currentPrefix\
    \ = currentPrefix + c\n            prefixes.append(currentPrefix)\n        }\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp0keb8e_.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmpp0keb8e_.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmpp0keb8e_.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    for c in string {\n\
    \        for p in prefixes {\n            if c == p {\n                break\n\
    \            }\n        }\n        if p != nil {\n            prefixes.append(p)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3_8lgl7h.swift:9:18: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if c == p {\n    \
    \           ~ ^  ~\n/tmp/tmp3_8lgl7h.swift:9:18: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n            if c == p {\n                 ^\n/tmp/tmp3_8lgl7h.swift:13:12:\
    \ error: cannot find 'p' in scope\n        if p != nil {\n           ^\n/tmp/tmp3_8lgl7h.swift:14:29:\
    \ error: cannot find 'p' in scope\n            prefixes.append(p)\n          \
    \                  ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix = \"\"\n\
    \    for c in string {\n        if c == prefix {\n            prefixes.append(prefix)\n\
    \        } else {\n            prefix = prefix + c\n        }\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpo_m30sjc.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == prefix {\n   \
    \        ~ ^  ~~~~~~\n/tmp/tmpo_m30sjc.swift:9:14: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n        if c == prefix {\n             ^\n/tmp/tmpo_m30sjc.swift:12:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prefix = prefix + c\n                              ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        currentPrefix = String(currentPrefix)\
    \ + String(character)\n        prefixes.append(currentPrefix)\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        if character == currentPrefix\
    \ {\n            prefixes.append(currentPrefix)\n        } else {\n          \
    \  currentPrefix = String(character)\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmps61zxf2z.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmps61zxf2z.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        if character == currentPrefix[currentPrefix.count]\
    \ {\n            prefixes.append(currentPrefix)\n            currentPrefix = \"\
    \"\n        } else {\n            currentPrefix = currentPrefix + character\n\
    \        }\n    }\n    prefixes.append(currentPrefix)\n    return prefixes\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpy939nsq6.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpy939nsq6.swift:13:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + character\n                     \
    \                       ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var current = string\n\
    \    var longest = 0\n    while current != \"\" {\n        current = current.prefix(string)\n\
    \        if current != \"\" {\n            longest = longest.max(current)\n  \
    \          prefixes.append(current)\n        }\n    }\n    return prefixes\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpo_g2s053.swift:10:34: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        current = current.prefix(string)\n\
    \                                 ^\n/tmp/tmpo_g2s053.swift:10:27: error: no 'prefix'\
    \ candidates produce the expected contextual result type 'String'\n        current\
    \ = current.prefix(string)\n                          ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequence<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> PrefixSequence<Self>\n                                       ^\nSwift.Collection:6:40:\
    \ note: 'prefix' produces 'String.SubSequence' (aka 'Substring'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func prefix(_\
    \ maxLength: Int) -> Self.SubSequence\n                                      \
    \ ^\n/tmp/tmpo_g2s053.swift:12:31: error: cannot call value of non-function type\
    \ 'Int'\n            longest = longest.max(current)\n                        \
    \      ^\n/tmp/tmpo_g2s053.swift:12:23: error: static member 'max' cannot be used\
    \ on instance of type 'Int'\n            longest = longest.max(current)\n    \
    \                  ^~~~~~~\n                      Int\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var current = string\n\
    \    for _ in 0..<string.count {\n        current = current[1..<current.count]\n\
    \        prefixes.append(current)\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp8256pvo8.swift:9:19: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an integer range, use a String.Index range instead.\n\
    \        current = current[1..<current.count]\n                  ^~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:5:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        currentPrefix = currentPrefix + c\n \
    \       prefixes.append(currentPrefix)\n    }\n    return prefixes\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp6thv23g.swift:9:41: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        currentPrefix = currentPrefix +\
    \ c\n                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    for c in string {\n\
    \        prefixes = append(prefixes, string[prefixes.endIndex..<string.endIndex])\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpy74dnlsb.swift:8:20: error: cannot find 'append' in scope\n   \
    \     prefixes = append(prefixes, string[prefixes.endIndex..<string.endIndex])\n\
    \                   ^~~~~~\n/tmp/tmpy74dnlsb.swift:8:53: error: cannot convert\
    \ value of type 'Int' to expected argument type 'String.Index'\n        prefixes\
    \ = append(prefixes, string[prefixes.endIndex..<string.endIndex])\n          \
    \                                          ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        currentPrefix = currentPrefix + c\n \
    \       prefixes.append(currentPrefix)\n    }\n    return prefixes\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp6thv23g.swift:9:41: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        currentPrefix = currentPrefix +\
    \ c\n                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix: String\
    \ = \"\"\n    for c in string {\n        prefix += c\n        if prefix != \"\"\
    \ {\n            prefixes.append(prefix)\n            prefix = \"\"\n        }\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp088b6_o_.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix = \"\"\n\
    \    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpz5pdtb79.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix = \"\"\n\
    \    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpz5pdtb79.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var current = string\n\
    \    var longest = string\n    while current != \"\" {\n        current = current.prefix(string)\n\
    \        longest = longest.prefix(string)\n        prefixes.append(current)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpt1m7zby8.swift:10:34: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        current = current.prefix(string)\n\
    \                                 ^\n/tmp/tmpt1m7zby8.swift:10:27: error: no 'prefix'\
    \ candidates produce the expected contextual result type 'String'\n        current\
    \ = current.prefix(string)\n                          ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequence<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> PrefixSequence<Self>\n                                       ^\nSwift.Collection:6:40:\
    \ note: 'prefix' produces 'String.SubSequence' (aka 'Substring'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func prefix(_\
    \ maxLength: Int) -> Self.SubSequence\n                                      \
    \ ^\n/tmp/tmpt1m7zby8.swift:11:34: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        longest = longest.prefix(string)\n\
    \                                 ^\n/tmp/tmpt1m7zby8.swift:11:27: error: no 'prefix'\
    \ candidates produce the expected contextual result type 'String'\n        longest\
    \ = longest.prefix(string)\n                          ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequence<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> PrefixSequence<Self>\n                                       ^\nSwift.Collection:6:40:\
    \ note: 'prefix' produces 'String.SubSequence' (aka 'Substring'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func prefix(_\
    \ maxLength: Int) -> Self.SubSequence\n                                      \
    \ ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        currentPrefix = currentPrefix + c\n \
    \       if currentPrefix.hasPrefix(string) {\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpc14v55de.swift:9:41: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        currentPrefix = currentPrefix +\
    \ c\n                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix: String\
    \ = \"\"\n    for c in string {\n        prefix += c\n        if prefix != \"\"\
    \ {\n            prefixes.append(prefix)\n            prefix = \"\"\n        }\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp088b6_o_.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        if character == currentPrefix[currentPrefix.count]\
    \ {\n            prefixes.append(currentPrefix)\n        } else {\n          \
    \  currentPrefix = currentPrefix + character\n        }\n    }\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpnt6b10fj.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpnt6b10fj.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + character\n                     \
    \                       ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        if c == currentPrefix {\n           \
    \ prefixes.append(currentPrefix)\n        } else {\n            currentPrefix\
    \ = currentPrefix + c\n            prefixes.append(currentPrefix)\n        }\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp0keb8e_.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmpp0keb8e_.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmpp0keb8e_.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    for c in string {\n\
    \        prefixes.append(string[..<string.index(before: c)])\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_t3v_oyy.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmp_t3v_oyy.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    for c in string {\n\
    \        prefixes.append(string[..<string.index(before: c)])\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_t3v_oyy.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmp_t3v_oyy.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        if c == currentPrefix {\n           \
    \ prefixes.append(currentPrefix)\n        } else {\n            currentPrefix\
    \ = currentPrefix + c\n            prefixes.append(currentPrefix)\n        }\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp0keb8e_.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmpp0keb8e_.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmpp0keb8e_.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        currentPrefix = currentPrefix + c\n \
    \       prefixes.append(currentPrefix)\n    }\n    return prefixes\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp6thv23g.swift:9:41: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        currentPrefix = currentPrefix +\
    \ c\n                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix: String\
    \ = \"\"\n    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpumasloxf.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        if character == currentPrefix\
    \ {\n            prefixes.append(currentPrefix)\n        } else {\n          \
    \  currentPrefix = String(character) + currentPrefix\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpchj1eeni.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == currentPrefix\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpchj1eeni.swift:9:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        if character == currentPrefix {\n    \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var current = string\n\
    \    var longest = 0\n    for c in current {\n        if longest < len(current)\
    \ {\n            longest = len(current)\n        }\n        current = current[longest..<longest+longest]\n\
    \        prefixes.append(current)\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpb2am3skt.swift:10:22: error: cannot find 'len' in scope\n     \
    \   if longest < len(current) {\n                     ^~~\n/tmp/tmpb2am3skt.swift:11:23:\
    \ error: cannot find 'len' in scope\n            longest = len(current)\n    \
    \                  ^~~\n/tmp/tmpb2am3skt.swift:13:19: error: 'subscript(_:)' is\
    \ unavailable: cannot subscript String with an integer range, use a String.Index\
    \ range instead.\n        current = current[longest..<longest+longest]\n     \
    \             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript<R>(bounds:\
    \ R) -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var current = string\n\
    \    var currentLength = current.characters.count\n    while currentLength > 0\
    \ {\n        prefixes.append(current)\n        currentLength = current.characters.count\n\
    \        current = String(current.characters.suffix(currentLength))\n    }\n \
    \   return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpf1n9dpz9.swift:8:33: error: 'characters' is unavailable: Please\
    \ use String directly\n    var currentLength = current.characters.count\n    \
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpf1n9dpz9.swift:11:33: error: 'characters' is unavailable:\
    \ Please use String directly\n        currentLength = current.characters.count\n\
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpf1n9dpz9.swift:12:34: error: 'characters' is unavailable:\
    \ Please use String directly\n        current = String(current.characters.suffix(currentLength))\n\
    \                                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var current = string\n\
    \    var longest = string\n    while current != \"\" {\n        current = current.prefix(string)\n\
    \        if current == \"\" {\n            break\n        }\n        prefixes.append(current)\n\
    \        longest = longest.prefix(current)\n    }\n    return prefixes\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp10n6_is2.swift:10:34: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        current = current.prefix(string)\n\
    \                                 ^\n/tmp/tmp10n6_is2.swift:10:27: error: no 'prefix'\
    \ candidates produce the expected contextual result type 'String'\n        current\
    \ = current.prefix(string)\n                          ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequence<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> PrefixSequence<Self>\n                                       ^\nSwift.Collection:6:40:\
    \ note: 'prefix' produces 'String.SubSequence' (aka 'Substring'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func prefix(_\
    \ maxLength: Int) -> Self.SubSequence\n                                      \
    \ ^\n/tmp/tmp10n6_is2.swift:15:34: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        longest = longest.prefix(current)\n\
    \                                 ^\n/tmp/tmp10n6_is2.swift:15:27: error: no 'prefix'\
    \ candidates produce the expected contextual result type 'String'\n        longest\
    \ = longest.prefix(current)\n                          ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequence<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> PrefixSequence<Self>\n                                       ^\nSwift.Collection:6:40:\
    \ note: 'prefix' produces 'String.SubSequence' (aka 'Substring'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func prefix(_\
    \ maxLength: Int) -> Self.SubSequence\n                                      \
    \ ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var current = string\n\
    \    while current != \"\" {\n        current = current.prefix(string)\n     \
    \   prefixes.append(current)\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpbv5iwncj.swift:9:34: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        current = current.prefix(string)\n\
    \                                 ^\n/tmp/tmpbv5iwncj.swift:9:27: error: no 'prefix'\
    \ candidates produce the expected contextual result type 'String'\n        current\
    \ = current.prefix(string)\n                          ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequence<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> PrefixSequence<Self>\n                                       ^\nSwift.Collection:6:40:\
    \ note: 'prefix' produces 'String.SubSequence' (aka 'Substring'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func prefix(_\
    \ maxLength: Int) -> Self.SubSequence\n                                      \
    \ ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        if character == currentPrefix[currentPrefix.count]\
    \ {\n            prefixes.append(currentPrefix)\n        } else {\n          \
    \  currentPrefix = currentPrefix + character\n        }\n    }\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpnt6b10fj.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpnt6b10fj.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + character\n                     \
    \                       ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        if c == currentPrefix {\n           \
    \ prefixes.append(currentPrefix)\n        } else {\n            currentPrefix\
    \ = currentPrefix + c\n            prefixes.append(currentPrefix)\n        }\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp0keb8e_.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmpp0keb8e_.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmpp0keb8e_.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        currentPrefix = String(currentPrefix)\
    \ + String(character)\n        prefixes.append(currentPrefix)\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix = \"\"\n\
    \    for c in string {\n        prefix += c\n        if prefixes.contains(prefix)\
    \ {\n            prefixes.append(prefix)\n        }\n    }\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpmjm162b6.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix = \"\"\n\
    \    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpz5pdtb79.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        if c == currentPrefix {\n           \
    \ prefixes.append(currentPrefix)\n        } else {\n            currentPrefix\
    \ = currentPrefix + c\n            prefixes.append(currentPrefix)\n        }\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp0keb8e_.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == currentPrefix\
    \ {\n           ~ ^  ~~~~~~~~~~~~~\n/tmp/tmpp0keb8e_.swift:9:14: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == currentPrefix {\n             ^\n/tmp/tmpp0keb8e_.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + c\n                             \
    \               ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var current = string\n\
    \    while current != \"\" {\n        prefixes.append(current)\n        current\
    \ = current[current.startIndex..<current.endIndex]\n    }\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpevzk4dnc.swift:10:26: error: cannot assign value of type 'Substring'\
    \ to type 'String'\n        current = current[current.startIndex..<current.endIndex]\n\
    \                  ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n          \
    \        String(                                       )\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix: String\
    \ = \"\"\n    for c in string {\n        if prefix != \"\" {\n            prefixes.append(prefix)\n\
    \        }\n        prefix = prefix + c\n    }\n    prefixes.append(prefix)\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpa4rl0nau.swift:12:27: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix = prefix + c\n          \
    \                ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var current = string\n\
    \    var last = \"\"\n    while current != \"\" {\n        current = last\n  \
    \      last = current[current.startIndex]\n        prefixes.append(last)\n   \
    \ }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpgci_w2k0.swift:11:23: error: cannot assign value of type 'Character'\
    \ to type 'String'\n        last = current[current.startIndex]\n             \
    \  ~~~~~~~^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var current = string\n\
    \    while current != \"\" {\n        current = current.prefix(string)\n     \
    \   prefixes.append(current)\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpbv5iwncj.swift:9:34: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        current = current.prefix(string)\n\
    \                                 ^\n/tmp/tmpbv5iwncj.swift:9:27: error: no 'prefix'\
    \ candidates produce the expected contextual result type 'String'\n        current\
    \ = current.prefix(string)\n                          ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequence<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> PrefixSequence<Self>\n                                       ^\nSwift.Collection:6:40:\
    \ note: 'prefix' produces 'String.SubSequence' (aka 'Substring'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func prefix(_\
    \ maxLength: Int) -> Self.SubSequence\n                                      \
    \ ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        currentPrefix = String(currentPrefix)\
    \ + String(character)\n        prefixes.append(currentPrefix)\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        currentPrefix = currentPrefix + c\n \
    \       if currentPrefix.hasPrefix(string) {\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpc14v55de.swift:9:41: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        currentPrefix = currentPrefix +\
    \ c\n                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var current = string\n\
    \    var last = \"\"\n    while current != \"\" {\n        current = current.prefix(string)\n\
    \        prefixes.append(current)\n        last = current\n    }\n    prefixes.append(last)\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp04kl93n6.swift:10:34: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        current = current.prefix(string)\n\
    \                                 ^\n/tmp/tmp04kl93n6.swift:10:27: error: no 'prefix'\
    \ candidates produce the expected contextual result type 'String'\n        current\
    \ = current.prefix(string)\n                          ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequence<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> PrefixSequence<Self>\n                                       ^\nSwift.Collection:6:40:\
    \ note: 'prefix' produces 'String.SubSequence' (aka 'Substring'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func prefix(_\
    \ maxLength: Int) -> Self.SubSequence\n                                      \
    \ ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix: String\
    \ = \"\"\n    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpumasloxf.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        if character == currentPrefix[currentPrefix.count]\
    \ {\n            prefixes.append(currentPrefix)\n        }\n        currentPrefix\
    \ = currentPrefix + character\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp4gkkbnci.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp4gkkbnci.swift:12:41:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        currentPrefix = currentPrefix + character\n                         \
    \               ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        currentPrefix = currentPrefix + c\n \
    \       prefixes.append(currentPrefix)\n    }\n    return prefixes\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp6thv23g.swift:9:41: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        currentPrefix = currentPrefix +\
    \ c\n                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var current = string\n\
    \    var i = 0\n    while i < len(current) {\n        prefixes.append(current[i..<i+1])\n\
    \        i += 1\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmprf8g08wu.swift:9:15: error: cannot find 'len' in scope\n    while\
    \ i < len(current) {\n              ^~~\n/tmp/tmprf8g08wu.swift:10:25: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an integer range,\
    \ use a String.Index range instead.\n        prefixes.append(current[i..<i+1])\n\
    \                        ^~~~~~~~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript<R>(bounds:\
    \ R) -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        currentPrefix = currentPrefix + c\n \
    \       if currentPrefix.hasPrefix(string) {\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpc14v55de.swift:9:41: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        currentPrefix = currentPrefix +\
    \ c\n                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 0
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        currentPrefix = String(currentPrefix)\
    \ + String(character)\n        prefixes.append(currentPrefix)\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    for c in string {\n\
    \        prefixes.append(string[..<string.index(before: c)])\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_t3v_oyy.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmp_t3v_oyy.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    for c in string {\n\
    \        prefixes.append(string[..<string.index(before: c)])\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_t3v_oyy.swift:8:31: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        prefixes.append(string[..<string.index(before:\
    \ c)])\n                              ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmp_t3v_oyy.swift:8:56: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        prefixes.append(string[..<string.index(before: c)])\n               \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var current = string\n\
    \    while current != \"\" {\n        prefixes.append(current)\n        current\
    \ = current[current.startIndex..<current.endIndex]\n    }\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpevzk4dnc.swift:10:26: error: cannot assign value of type 'Substring'\
    \ to type 'String'\n        current = current[current.startIndex..<current.endIndex]\n\
    \                  ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n          \
    \        String(                                       )\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix = \"\"\n\
    \    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpz5pdtb79.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix = \"\"\n\
    \    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpz5pdtb79.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var current = string\n\
    \    for _ in 0..<string.count {\n        current = current[1..<current.count]\n\
    \        prefixes.append(current)\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp8256pvo8.swift:9:19: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an integer range, use a String.Index range instead.\n\
    \        current = current[1..<current.count]\n                  ^~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:5:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        if character == currentPrefix[currentPrefix.count-1]\
    \ {\n            prefixes.append(currentPrefix)\n        } else {\n          \
    \  currentPrefix = currentPrefix + character\n        }\n    }\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpmn2cqllj.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if character\
    \ == currentPrefix[currentPrefix.count-1] {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpmn2cqllj.swift:12:45:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            currentPrefix = currentPrefix + character\n                     \
    \                       ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix = \"\"\n\
    \    for c in string {\n        if c == prefix {\n            prefixes.append(prefix)\n\
    \        } else {\n            prefix = prefix + c\n            prefixes.append(prefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3ri5olu3.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == prefix {\n   \
    \        ~ ^  ~~~~~~\n/tmp/tmp3ri5olu3.swift:9:14: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n        if c == prefix {\n             ^\n/tmp/tmp3ri5olu3.swift:12:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prefix = prefix + c\n                              ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix: String\
    \ = \"\"\n    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpumasloxf.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix = \"\"\n\
    \    for c in string {\n        if c == prefix {\n            prefixes.append(prefix)\n\
    \            prefix = \"\"\n        } else {\n            prefix += c\n      \
    \  }\n    }\n    prefixes.append(prefix)\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjgmjwavd.swift:9:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == prefix {\n   \
    \        ~ ^  ~~~~~~\n/tmp/tmpjgmjwavd.swift:9:14: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Character, Character), (String,\
    \ String)\n        if c == prefix {\n             ^\n/tmp/tmpjgmjwavd.swift:13:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prefix += c\n                      ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for c in string {\n        currentPrefix = currentPrefix + c\n \
    \       if currentPrefix.hasPrefix(string) {\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpc14v55de.swift:9:41: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        currentPrefix = currentPrefix +\
    \ c\n                                        ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix = \"\"\n\
    \    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \        prefix = \"\"\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpd7yozare.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var prefix = \"\"\n\
    \    for c in string {\n        prefix += c\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpz5pdtb79.swift:9:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += c\n                  ^\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var currentPrefix\
    \ = \"\"\n    for character in string {\n        if character == currentPrefix[currentPrefix.startIndex]\
    \ {\n            currentPrefix = currentPrefix.substringToIndex(currentPrefix.startIndex\
    \ + 1)\n        } else {\n            prefixes.append(currentPrefix)\n       \
    \     currentPrefix = String(character)\n        }\n    }\n    prefixes.append(currentPrefix)\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp6rc379ip.swift:10:74: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n            currentPrefix = currentPrefix.substringToIndex(currentPrefix.startIndex\
    \ + 1)\n                                                                     \
    \    ^\n/tmp/tmp6rc379ip.swift:10:43: error: value of type 'String' has no member\
    \ 'substringToIndex'\n            currentPrefix = currentPrefix.substringToIndex(currentPrefix.startIndex\
    \ + 1)\n                            ~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014230
- exit_code: 1
  program: "\n/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfunc all_prefixes(string:\
    \ String) -> [String] {\n    var prefixes = [String]()\n    var current = string\n\
    \    var last = \"\"\n    for _ in 0..<string.count {\n        current = last\n\
    \        last = string[string.index(string.startIndex, offsetBy: 1)]\n       \
    \ prefixes.append(current)\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq_ct1vz9.swift:11:22: error: cannot assign value of type 'Character'\
    \ to type 'String'\n        last = string[string.index(string.startIndex, offsetBy:\
    \ 1)]\n               ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014230
