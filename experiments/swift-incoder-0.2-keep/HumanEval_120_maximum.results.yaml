language: swift
name: HumanEval_120_maximum
results:
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    precondition(k\
    \ <= arr.count, \"k is out of range\")\n    var result = [Int]()\n    var max\
    \ = 0\n    for element in arr {\n        if element > max {\n            max =\
    \ element\n        }\n    }\n    for element in arr {\n        if element == max\
    \ {\n            result.append(element)\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmp0l5co4_5/tmp0l5co4_5.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0beeed9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0beebd0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0beebd0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0beebcf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0l5co4_5                        0x000055745f0396c9 <unavailable> + 5833

    5    libc.so.6                          0x00002b0bef0c5460 __libc_start_main +
    245

    6    tmp0l5co4_5                        0x000055745f0392c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || k\
    \ > arr.count {\n        return arr\n    }\n    \n    var max = [Int]()\n    \n\
    \    for index in 0..<k {\n        if arr[index] > max[0] {\n            max =\
    \ [arr[index]]\n        } else if arr[index] == max[0] {\n            max.append(arr[index])\n\
    \        }\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8c59c0dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8c59904561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8c59904286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8c5990413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8c59903bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8c59703e83 <unavailable> + 188035

    6    tmpurqtw_v5                        0x000055e1b08b7649 <unavailable> + 9801

    7    tmpurqtw_v5                        0x000055e1b08b65d9 <unavailable> + 5593

    8    libc.so.6                          0x00002b8c59df9460 __libc_start_main +
    245

    9    tmpurqtw_v5                        0x000055e1b08b62b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    return arr.sorted\
    \ { $0 > $1 }.prefix(k)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpgkcsuxmh.swift:18:35: error: cannot convert return expression of\
    \ type 'ArraySlice<Int>' to return type '[Int]'\n    return arr.sorted { $0 >\
    \ $1 }.prefix(k)\n           ~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    var max = [Int]()\n\
    \    var maxIndex = 0\n    for index in 0..<arr.count {\n        if arr[index]\
    \ > max[maxIndex] {\n            max[maxIndex] = arr[index]\n            maxIndex\
    \ = index\n        }\n    }\n    return max[maxIndex..<maxIndex+k]\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp_pdtrh2w.swift:26:15: error: no 'subscript' candidates produce\
    \ the expected contextual result type '[Int]'\n    return max[maxIndex..<maxIndex+k]\n\
    \              ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    var max = [Int]()\n\
    \    for x in arr {\n        if x < 0 {\n            max = append(max, -x)\n \
    \       } else {\n            max = append(max, x)\n        }\n    }\n    max\
    \ = maximumSort(max, k)\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpe2lnnjsw.swift:21:19: error: cannot find 'append' in scope\n  \
    \          max = append(max, -x)\n                  ^~~~~~\n/tmp/tmpe2lnnjsw.swift:23:19:\
    \ error: cannot find 'append' in scope\n            max = append(max, x)\n   \
    \               ^~~~~~\n/tmp/tmpe2lnnjsw.swift:26:11: error: cannot find 'maximumSort'\
    \ in scope\n    max = maximumSort(max, k)\n          ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || arr.isEmpty\
    \ {\n        return arr\n    }\n    \n    var max = [Int]()\n    var maxIndex\
    \ = 0\n    \n    for i in 0..<k {\n        if arr[i] > max[k-1] {\n          \
    \  max[k-1] = arr[i]\n            maxIndex = k-1\n        }\n    }\n    \n   \
    \ for i in 0..<k {\n        if arr[i] > max[k-1] {\n            max[k-1] = arr[i]\n\
    \            maxIndex = k-1\n        }\n    }\n    \n    for i in 0..<k {\n  \
    \      if arr[i] > max[k-1] {\n            max[k-1] = arr[i]\n            maxIndex\
    \ = k-1\n        }\n    }\n    \n    for i in 0..<k {\n        if arr[i] > max[k-1]\
    \ {\n            max[k-1] = arr[i]\n            maxIndex = k-1\n        }\n  \
    \  }\n    \n    for i in 0..<k {\n        if arr[i] > max[k-1] {\n           \
    \ max[k-1] = arr[i]\n            maxIndex = k-1\n        }\n    }\n    \n    for\
    \ i in 0..<k {\n        if arr[i] > max[k-1] {\n            max[k-1] = arr[i]\n\
    \            maxIndex = k-1\n        }\n    }\n    \n    for i in 0..<k {\n  \
    \      if arr[i] > max[k-1] {\n            max[k-1] = arr[i]\n            maxIndex\
    \ = k-1\n        }\n    }\n    \n    for i in 0..<k {\n        if arr[i] > max[k-1]\
    \ {\n            max[k-1] = arr[i]\n            maxIndex = k-1\n        }\n  \
    \  }\n    \n    for i in 0..<k {\n        if arr[i] > max[k-1] {\n           \
    \ max[k-1] = arr[i]\n            maxIndex = k-1\n        }\n    }\n    \n    for\
    \ i in 0..<k {\n        if arr[i] > max[k-1] {\n            max[k-1] = arr[i]\n\
    \            maxIndex = k-1\n        }\n    }\n    \n    for i in 0..<k {\n  \
    \      if arr[i] > max[k-1] {\n            max[k-1] = arr[i]\n            maxIndex\
    \ = k-1\n        }\n    }\n    \n    for i in 0..<k {\n        if arr[i] > max[k-1]\
    \ {\n            max[k-1] = arr[i]\n            maxIndex = k-1\n        }\n  \
    \  }\n    \n    for i in 0..<k {\n        if arr[i] > max[k-1] {\n           \
    \ max[k-1] = arr[i]\n            maxIndex = k-1\n        }\n    }\n    \n    for\
    \ i in 0..<k {\n        if arr[i] > max[k-1] {\n            max[k-1] = arr[i]\n\
    \            maxIndex = k-1\n        }\n    }\n    \n    for i in 0..<k {\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmprwew8s1z.swift:149:72: error: expected '}' at end of brace statement\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])\n    \
    \                                                                   ^\n/tmp/tmprwew8s1z.swift:17:43:\
    \ note: to match this opening '{'\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n\
    \                                          ^\n/tmp/tmprwew8s1z.swift:127:6: error:\
    \ operator functions can only be declared at global or in type scope\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmprwew8s1z.swift:23:9:\
    \ warning: variable 'maxIndex' was written to, but never read\n    var maxIndex\
    \ = 0\n        ^\n/tmp/tmprwew8s1z.swift:123:9: warning: immutable value 'i' was\
    \ never used; consider replacing with '_' or removing it\n    for i in 0..<k {\n\
    \        ^\n        _\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    var max\
    \ = [Int]()\n    \n    if arr.count > k {\n        max = arr[k..<arr.count]\n\
    \    } else {\n        max = arr\n    }\n    \n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp7pwwktyu.swift:22:18: error: cannot assign value of type 'ArraySlice<Int>'\
    \ to type '[Int]'\n        max = arr[k..<arr.count]\n              ~~~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    // write\
    \ your code here\n    \n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpnr56wemo/tmpnr56wemo.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b48eae22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48eab19b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b48eab19988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b48eab187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnr56wemo                        0x00005580aee853c9 <unavailable> + 5065

    5    libc.so.6                          0x00002b48eb00e460 __libc_start_main +
    245

    6    tmpnr56wemo                        0x00005580aee84fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || arr.isEmpty()\
    \ {\n        return arr\n    }\n    \n    var max = [Int]()\n    var maxIndex\
    \ = 0\n    \n    for index in 0..<arr.count {\n        if arr[index] > max[maxIndex]\
    \ {\n            max[maxIndex] = arr[index]\n            maxIndex = index\n  \
    \      }\n    }\n    \n    return max[maxIndex..<maxIndex+k]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpe8c392ai.swift:18:22: error: cannot call value of non-function\
    \ type 'Bool'\n    if k == 0 || arr.isEmpty() {\n                     ^      ~~\n\
    \                            \n/tmp/tmpe8c392ai.swift:32:15: error: no 'subscript'\
    \ candidates produce the expected contextual result type '[Int]'\n    return max[maxIndex..<maxIndex+k]\n\
    \              ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    return arr.sorted\
    \ { $0 > $1 }.prefix(k)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpgkcsuxmh.swift:18:35: error: cannot convert return expression of\
    \ type 'ArraySlice<Int>' to return type '[Int]'\n    return arr.sorted { $0 >\
    \ $1 }.prefix(k)\n           ~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    var max\
    \ = [Int]()\n    \n    for x in arr {\n        if x > max[0] {\n            max[0]\
    \ = x\n        }\n    }\n    \n    for x in arr {\n        if x > max[1] {\n \
    \           max[1] = x\n        }\n    }\n    \n    for x in arr {\n        if\
    \ x > max[2] {\n            max[2] = x\n        }\n    }\n    \n    return max[k..<3]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpb_lci6sb.swift:39:15: error: no 'subscript' candidates produce\
    \ the expected contextual result type '[Int]'\n    return max[k..<3]\n       \
    \       ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    var max = [Int]()\n\
    \    var maxIndex = 0\n    for index in 0..<arr.count {\n        if arr[index]\
    \ > max[maxIndex] {\n            max[maxIndex] = arr[index]\n            maxIndex\
    \ = index\n        }\n    }\n    return max[maxIndex..<maxIndex+k]\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp_pdtrh2w.swift:26:15: error: no 'subscript' candidates produce\
    \ the expected contextual result type '[Int]'\n    return max[maxIndex..<maxIndex+k]\n\
    \              ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    var max\
    \ = [Int]()\n    \n    for x in arr {\n        if x > max[0] {\n            max[0]\
    \ = x\n        }\n    }\n    \n    for x in arr {\n        if x == max[0] {\n\
    \            for y in max {\n                if y > x {\n                    max[1]\
    \ = y\n                }\n            }\n        }\n    }\n    \n    for x in\
    \ arr {\n        if x == max[1] {\n            for y in max {\n              \
    \  if y > x {\n                    max[2] = y\n                }\n           \
    \ }\n        }\n    }\n    \n    return max[k..<3]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp0kwnbeiu.swift:47:15: error: no 'subscript' candidates produce\
    \ the expected contextual result type '[Int]'\n    return max[k..<3]\n       \
    \       ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    var max\
    \ = [Int]()\n    \n    for x in arr {\n        if x < 0 {\n            continue\n\
    \        }\n        \n        if k == 0 {\n            max = append(max, x)\n\
    \            continue\n        }\n        \n        if x > max[k-1] {\n      \
    \      max[k-1] = x\n        }\n        \n        k--\n    }\n    \n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(maximum(arr: [-3, -4, 5],\
    \ k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20,\
    \ 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2,\
    \ -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0],\
    \ k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10],\
    \ k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp_ka5dtp0.swift:27:19: error: cannot find 'append' in scope\n  \
    \          max = append(max, x)\n                  ^~~~~~\n/tmp/tmp_ka5dtp0.swift:35:10:\
    \ error: cannot find operator '--' in scope; did you mean '-= 1'?\n        k--\n\
    \         ^~\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    var max\
    \ = [Int]()\n    \n    for x in arr {\n        if x < 0 {\n            continue\n\
    \        }\n        if k == 0 {\n            max = append(max, x)\n          \
    \  continue\n        }\n        if x > max[k] {\n            max[k] = x\n    \
    \    }\n        k--\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpje0_ym3o.swift:26:19: error: cannot find 'append' in scope\n  \
    \          max = append(max, x)\n                  ^~~~~~\n/tmp/tmpje0_ym3o.swift:32:10:\
    \ error: cannot find operator '--' in scope; did you mean '-= 1'?\n        k--\n\
    \         ^~\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || arr.isEmpty\
    \ {\n        return arr\n    }\n    \n    var max = [Int]()\n    var maxIndex\
    \ = 0\n    \n    for index in 0..<arr.count {\n        if arr[index] > max[maxIndex]\
    \ {\n            max[maxIndex] = arr[index]\n            maxIndex = index\n  \
    \      }\n    }\n    \n    return max[maxIndex..<k].sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8909292c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8908f89561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8908f89286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8908f8913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8908f88bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8908d88e83 <unavailable> + 188035

    6    tmp3m7e8sto                        0x00005613fe5088c5 <unavailable> + 10437

    7    tmp3m7e8sto                        0x00005613fe5077f9 <unavailable> + 6137

    8    libc.so.6                          0x00002b890947e460 __libc_start_main +
    245

    9    tmp3m7e8sto                        0x00005613fe5074d9 <unavailable> + 5337

    '
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    var result = [Int]()\n\
    \    var max = 0\n    for element in arr {\n        if element > max {\n     \
    \       max = element\n        }\n    }\n    for element in arr {\n        if\
    \ element == max {\n            result.append(element)\n        }\n    }\n   \
    \ if k == result.count {\n        return result\n    }\n    if k > result.count\
    \ {\n        return result\n    }\n    for element in arr {\n        if element\
    \ > max {\n            result.append(element)\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpr5inm4lw/tmpr5inm4lw.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2e36b53c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2e3684ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2e3684a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2e368497b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr5inm4lw                        0x000055c1b97ff639 <unavailable> + 5689

    5    libc.so.6                          0x00002b2e36d3f460 __libc_start_main +
    245

    6    tmpr5inm4lw                        0x000055c1b97ff239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k > arr.count\
    \ {\n        return arr\n    }\n    \n    var max = [Int]()\n    var maxIndex\
    \ = 0\n    \n    for index in 0..<k {\n        if arr[index] > max[maxIndex] {\n\
    \            max[maxIndex] = arr[index]\n            maxIndex = index\n      \
    \  }\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae667e05c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae667afc561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae667afc286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae667afc13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae667afbbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae6678fbe83 <unavailable> + 188035

    6    tmpeufw1o22                        0x000055a84e210603 <unavailable> + 9731

    7    tmpeufw1o22                        0x000055a84e20f5c9 <unavailable> + 5577

    8    libc.so.6                          0x00002ae667ff1460 __libc_start_main +
    245

    9    tmpeufw1o22                        0x000055a84e20f2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || arr.isEmpty\
    \ {\n        return arr\n    }\n    \n    var max = [Int]()\n    var maxIndex\
    \ = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > max[maxIndex] {\n\
    \            max[maxIndex] = arr[i]\n            maxIndex = i\n        }\n   \
    \ }\n    \n    return max[maxIndex..<k+1]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpwdgoodtf.swift:32:15: error: no 'subscript' candidates produce\
    \ the expected contextual result type '[Int]'\n    return max[maxIndex..<k+1]\n\
    \              ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    var result = [Int]()\n\
    \    var max = 0\n    for x in arr {\n        if x > max {\n            max =\
    \ x\n        }\n    }\n    for x in arr {\n        if x == max {\n           \
    \ result.append(x)\n        }\n    }\n    for x in arr {\n        if x < max {\n\
    \            result.append(x)\n        }\n    }\n    if k == result.count {\n\
    \        return result\n    }\n    if k > result.count {\n        return result\n\
    \    }\n    if k == 0 {\n        return result\n    }\n    if k == 1 {\n     \
    \   return result\n    }\n    if k == result.count - 1 {\n        return result\n\
    \    }\n    if k == result.count - 2 {\n        return result\n    }\n    if k\
    \ == result.count - 3 {\n        return result\n    }\n    if k == result.count\
    \ - 4 {\n        return result\n    }\n    if k == result.count - 5 {\n      \
    \  return result\n    }\n    if k == result.count - 6 {\n        return result\n\
    \    }\n    if k == result.count - 7 {\n        return result\n    }\n    if k\
    \ == result.count - 8 {\n        return result\n    }\n    if k == result.count\
    \ - 9 {\n        return result\n    }\n    if k == result.count - 10 {\n     \
    \   return result\n    }\n    if k == result.count - 11 {\n        return result\n\
    \    }\n    if k == result.count - 12 {\n        return result\n    }\n    if\
    \ k == result.count - 13 {\n        return result\n    }\n    if k == result.count\
    \ - 14 {\n        return result\n    }\n    if k == result.count - 15 {\n    \
    \    return result\n    }\n    if k == result.count - 16 {\n        return result\n\
    \    }\n    if k == result.count - 17 {\n        return result\n    }\n    if\
    \ k == result.count - 18 {\n        return result\n    }\n    if k == result.count\
    \ - 19 {\n        return result\n    }\n    if k == result.count - 20 {\n    \
    \    return result\n    }\n    if k == result.count - 21 {\n        return result\n\
    \    }\n    if k == result.count - 22 {\n        return result\n    }\n    if\
    \ k == result.count - 23 {\n        return result\n    }\n    if k == result.count\
    \ - 24 {\n        return result\n    }\n    if k == result.count - 25 {\n    \
    \    return result\n    }\n    if k == result.count - 26 {\n        return result\n\
    \    }\n    if k == result.count - 27 {\n        return result\n    }\n    if\
    \ k == result.count - 28 {\n        return result\n    }\n    if k == result.count\
    \ - 29 {\n        return result\n    }\n    if k == result.count - 30 {\n    \
    \    return result\n    }\n    if k == result.count - 31 {\n        return result\n\
    \    }\n    if k == result.count - 32 {\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpg0bu7io2.swift:166:72: error: expected '}' at end of brace statement\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])\n    \
    \                                                                   ^\n/tmp/tmpg0bu7io2.swift:17:43:\
    \ note: to match this opening '{'\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n\
    \                                          ^\n/tmp/tmpg0bu7io2.swift:144:6: error:\
    \ operator functions can only be declared at global or in type scope\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    // write\
    \ your code here\n    \n    var max = [Int]()\n    \n    for var i = 0; i < k;\
    \ i++ {\n        if arr[i] > max[0] {\n            max[0] = arr[i]\n        }\n\
    \    }\n    \n    for var i = 0; i < k; i++ {\n        if arr[i] > max[1] {\n\
    \            max[1] = arr[i]\n        }\n    }\n    \n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpjny9w_5n.swift:23:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for var i = 0; i < k; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpjny9w_5n.swift:29:5: error: C-style for statement has been removed in\
    \ Swift 3\n    for var i = 0; i < k; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    return arr.sorted\
    \ { $0 > $1 }.prefix(k)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpgkcsuxmh.swift:18:35: error: cannot convert return expression of\
    \ type 'ArraySlice<Int>' to return type '[Int]'\n    return arr.sorted { $0 >\
    \ $1 }.prefix(k)\n           ~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    precondition(k\
    \ <= arr.count, \"k should be less than or equal to the length of arr\")\n   \
    \ var max = [Int]()\n    var maxIndex = 0\n    for index in 0..<k {\n        if\
    \ arr[index] > max[maxIndex] {\n            max[maxIndex] = arr[index]\n     \
    \       maxIndex = index\n        }\n    }\n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b23e019fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b23dfe96561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b23dfe96286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b23dfe9613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b23dfe95bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b23dfc95e83 <unavailable> + 188035

    6    tmpsv4o1oyp                        0x0000556f7ec91711 <unavailable> + 10001

    7    tmpsv4o1oyp                        0x0000556f7ec90659 <unavailable> + 5721

    8    libc.so.6                          0x00002b23e038b460 __libc_start_main +
    245

    9    tmpsv4o1oyp                        0x0000556f7ec90339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    var max\
    \ = [Int]()\n    \n    for index in 0..<k {\n        if arr[index] > max[index]\
    \ {\n            max = [Int](repeatElement(arr[index], count: k - 1))\n      \
    \  }\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ada77eb7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ada77bae561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ada77bae286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ada77bae13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ada77badbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ada779ade83 <unavailable> + 188035

    6    tmpxxkrpj2j                        0x000055b3d452067e <unavailable> + 9854

    7    tmpxxkrpj2j                        0x000055b3d451f689 <unavailable> + 5769

    8    libc.so.6                          0x00002ada780a3460 __libc_start_main +
    245

    9    tmpxxkrpj2j                        0x000055b3d451f369 <unavailable> + 4969

    '
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    var result = Array<Int>()\n\
    \    var max = 0\n    for element in arr {\n        if element > max {\n     \
    \       max = element\n        }\n    }\n    for element in arr {\n        if\
    \ element == max {\n            result.append(element)\n        }\n    }\n   \
    \ for element in arr {\n        if element > max {\n            result.append(element)\n\
    \        }\n    }\n    for element in arr {\n        if element == max {\n   \
    \         result.append(element)\n        }\n    }\n    for element in arr {\n\
    \        if element > max {\n            result.append(element)\n        }\n \
    \   }\n    for element in arr {\n        if element == max {\n            result.append(element)\n\
    \        }\n    }\n    for element in arr {\n        if element > max {\n    \
    \        result.append(element)\n        }\n    }\n    for element in arr {\n\
    \        if element == max {\n            result.append(element)\n        }\n\
    \    }\n    for element in arr {\n        if element > max {\n            result.append(element)\n\
    \        }\n    }\n    for element in arr {\n        if element == max {\n   \
    \         result.append(element)\n        }\n    }\n    for element in arr {\n\
    \        if element > max {\n            result.append(element)\n        }\n \
    \   }\n    for element in arr {\n        if element == max {\n            result.append(element)\n\
    \        }\n    }\n    for element in arr {\n        if element > max {\n    \
    \        result.append(element)\n        }\n    }\n    for element in arr {\n\
    \        if element == max {\n            result.append(element)\n        }\n\
    \    }\n    for element in arr {\n        if element > max {\n            result.append(element)\n\
    \        }\n    }\n    for element in arr {\n        if element == max {\n   \
    \         result.append(element)\n        }\n    }\n    for element in arr {\n\
    \        if element > max {\n            result.append(element)\n        }\n \
    \   }\n    for element in arr {\n        if element == max {\n            result.append(element)\n\
    \        }\n    }\n    for element in arr {\n        if element > max {\n    \
    \        result.append(element)\n        }\n    }\n    for element in arr {\n\
    \        if element == max {\n            result.append(element)\n        }\n\
    \    }\n    for element in arr {\n        if element > max {\n            result.append(element)\n\
    \        }\n    }\n    for element in arr {\n        if element == max {\n   \
    \         result.append(element)\n        }\n    }\n    for element in arr {\n\
    \        if element > max {\n            result.append(element)\n        }\n \
    \   }\n    for element in arr {\n        if element == max {\n            result.append(element)\n\
    \        }\n    }\n    for element in arr {\n        if element > max {\n    \
    \        result.append(element)\n        }\n    }\n    for element in arr {\n\
    \        if element == max {\n            result.append(element)\n        }\n\
    \    }\n    for element in arr {\n        if element \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpf4bg16mt.swift:151:19: error: expected '{' after 'if' condition\n\
    \        if element \n                  ^\n/tmp/tmpf4bg16mt.swift:177:72: error:\
    \ expected '}' at end of brace statement\nassert(maximum(arr: [1, 2, 3, -23, 243,\
    \ -400, 0], k: 0) == [] as [Int])\n                                          \
    \                             ^\n/tmp/tmpf4bg16mt.swift:17:43: note: to match\
    \ this opening '{'\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n            \
    \                              ^\n/tmp/tmpf4bg16mt.swift:151:12: error: type 'Int'\
    \ cannot be used as a boolean; test for '!= 0' instead\n        if element \n\
    \           ^\n           (       != 0)\n/tmp/tmpf4bg16mt.swift:155:6: error:\
    \ operator functions can only be declared at global or in type scope\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    // write\
    \ your code here\n    \n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpnr56wemo/tmpnr56wemo.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b48eae22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48eab19b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b48eab19988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b48eab187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnr56wemo                        0x00005580aee853c9 <unavailable> + 5065

    5    libc.so.6                          0x00002b48eb00e460 __libc_start_main +
    245

    6    tmpnr56wemo                        0x00005580aee84fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    return maximumHelper(arr,\
    \ k)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k:\
    \ 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20,\
    \ 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2,\
    \ -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0],\
    \ k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10],\
    \ k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp6fbb0nhi.swift:18:12: error: cannot find 'maximumHelper' in scope\n\
    \    return maximumHelper(arr, k)\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    var result = [Int]()\n\
    \    var max = 0\n    for element in arr {\n        if element > max {\n     \
    \       max = element\n        }\n    }\n    for element in arr {\n        if\
    \ element == max {\n            result.append(element)\n        }\n    }\n   \
    \ for _ in 0..<k {\n        result.append(max!)\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpkpxm0gql.swift:31:26: error: cannot force unwrap value of non-optional\
    \ type 'Int'\n        result.append(max!)\n                      ~~~^\n      \
    \                   \n"
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    let maxArray\
    \ = Array(arr)\n    \n    if k == 1 {\n        return maxArray\n    }\n    \n\
    \    if k > maxArray.count {\n        return maxArray\n    }\n    \n    var maxArrayCopy\
    \ = maxArray\n    \n    for _ in 0..<k-1 {\n        maxArrayCopy = maxArrayCopy.sorted()\n\
    \    }\n    \n    return maxArrayCopy\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpwqotm1pj/tmpwqotm1pj.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b33716cec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b33713c5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b33713c5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b33713c47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwqotm1pj                        0x00005623949677dd <unavailable> + 6109

    5    libc.so.6                          0x00002b33718ba460 __libc_start_main +
    245

    6    tmpwqotm1pj                        0x00005623949672b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    // write\
    \ your code here\n    \n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpnr56wemo/tmpnr56wemo.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b48eae22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48eab19b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b48eab19988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b48eab187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnr56wemo                        0x00005580aee853c9 <unavailable> + 5065

    5    libc.so.6                          0x00002b48eb00e460 __libc_start_main +
    245

    6    tmpnr56wemo                        0x00005580aee84fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    // write\
    \ your code here\n    \n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpnr56wemo/tmpnr56wemo.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b48eae22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48eab19b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b48eab19988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b48eab187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnr56wemo                        0x00005580aee853c9 <unavailable> + 5065

    5    libc.so.6                          0x00002b48eb00e460 __libc_start_main +
    245

    6    tmpnr56wemo                        0x00005580aee84fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    var result = Array<Int>()\n\
    \    var max = 0\n    for element in arr {\n        if element > max {\n     \
    \       max = element\n        }\n    }\n    for element in arr {\n        if\
    \ element == max {\n            result.insert(element, at: 0)\n        }\n   \
    \ }\n    result.sort(by: {$0 > $1})\n    return result[k..<result.count]\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpwya5wban.swift:31:18: error: no 'subscript' candidates produce\
    \ the expected contextual result type '[Int]'\n    return result[k..<result.count]\n\
    \                 ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript(bounds: Range<Int>) -> ArraySlice<Element> { get set }\n  \
    \                    ^\nSwift.Collection:2:23: note: 'subscript(_:)' produces\
    \ 'ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get }\n                      ^\nSwift.MutableCollection:2:23: note:\
    \ 'subscript(_:)' produces '@lvalue ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get set }\n             \
    \         ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    // write\
    \ your code here\n    \n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpnr56wemo/tmpnr56wemo.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b48eae22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48eab19b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b48eab19988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b48eab187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnr56wemo                        0x00005580aee853c9 <unavailable> + 5065

    5    libc.so.6                          0x00002b48eb00e460 __libc_start_main +
    245

    6    tmpnr56wemo                        0x00005580aee84fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k > arr.count\
    \ {\n        return arr\n    }\n    \n    var max = [Int](repeating: 0, count:\
    \ k)\n    var maxIndex = 0\n    \n    for i in 0..<arr.count {\n        if arr[i]\
    \ > max[maxIndex] {\n            max[maxIndex] = arr[i]\n            maxIndex\
    \ = maxIndex + 1\n        }\n    }\n    \n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmppvayiin0/tmppvayiin0.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4a9fb05c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4a9f7fcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4a9f7fc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4a9f7fb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppvayiin0                        0x00005624863846c9 <unavailable> + 5833

    5    libc.so.6                          0x00002b4a9fcf1460 __libc_start_main +
    245

    6    tmppvayiin0                        0x00005624863842c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    // write\
    \ your code here\n    \n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpnr56wemo/tmpnr56wemo.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b48eae22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48eab19b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b48eab19988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b48eab187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnr56wemo                        0x00005580aee853c9 <unavailable> + 5065

    5    libc.so.6                          0x00002b48eb00e460 __libc_start_main +
    245

    6    tmpnr56wemo                        0x00005580aee84fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k > arr.count\
    \ {\n        return arr\n    }\n    var result = arr\n    var maxIndex = k\n \
    \   for index in stride(from: 0, to: arr.count, by: k) {\n        if result[index]\
    \ > result[index+k] {\n            result[index] = result[index+k]\n         \
    \   maxIndex = index\n        }\n    }\n    return result.prefix(maxIndex)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmph95h1ssg.swift:29:19: error: no 'prefix' candidates produce the\
    \ expected contextual result type '[Int]'\n    return result.prefix(maxIndex)\n\
    \                  ^\nSwift.Sequence:7:40: note: 'prefix' produces 'PrefixSequence<[Int]>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public __consuming\
    \ func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n                    \
    \                   ^\nSwift.Collection:6:40: note: 'prefix' produces 'ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public __consuming\
    \ func prefix(_ maxLength: Int) -> Self.SubSequence\n                        \
    \               ^\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    var max\
    \ = [Int]()\n    var maxIndex = 0\n    \n    for index in 0..<arr.count {\n  \
    \      if arr[index] > max[maxIndex] {\n            max[maxIndex] = arr[index]\n\
    \            maxIndex = index\n        }\n    }\n    \n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad173364c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad17305b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad17305b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad17305b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad17305abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad172e5ae83 <unavailable> + 188035

    6    tmpnig1_uwj                        0x00005623a7c435e6 <unavailable> + 9702

    7    tmpnig1_uwj                        0x00005623a7c425c9 <unavailable> + 5577

    8    libc.so.6                          0x00002ad173550460 __libc_start_main +
    245

    9    tmpnig1_uwj                        0x00005623a7c422a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || arr.isEmpty\
    \ {\n        return arr\n    }\n    var result = arr\n    var maxIndex = -1\n\
    \    for index in 0..<k {\n        if result[index] > result[index+1] {\n    \
    \        result[index], result[index+1] = result[index+1], result[index]\n   \
    \     }\n        if maxIndex < 0 || result[index] > result[maxIndex] {\n     \
    \       maxIndex = index\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpk8ih9dl8.swift:25:26: error: consecutive statements on a line must\
    \ be separated by ';'\n            result[index], result[index+1] = result[index+1],\
    \ result[index]\n                         ^\n                         ;\n/tmp/tmpk8ih9dl8.swift:25:26:\
    \ error: expected expression\n            result[index], result[index+1] = result[index+1],\
    \ result[index]\n                         ^\n/tmp/tmpk8ih9dl8.swift:25:19: warning:\
    \ subscript is accessed but result is unused\n            result[index], result[index+1]\
    \ = result[index+1], result[index]\n            ~~~~~~^~~~~~~\n/tmp/tmpk8ih9dl8.swift:21:9:\
    \ warning: variable 'result' was never mutated; consider changing to 'let' constant\n\
    \    var result = arr\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    // 1. Sort\
    \ arr\n    arr.sort()\n    \n    // 2. Return arr[k..<arr.count]\n    return arr[k..<arr.count]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp6urs6mnk.swift:20:9: error: cannot use mutating member on immutable\
    \ value: 'arr' is a 'let' constant\n    arr.sort()\n    ~~~ ^\n/tmp/tmp6urs6mnk.swift:23:15:\
    \ error: cannot convert return expression of type 'ArraySlice<Int>' to return\
    \ type '[Int]'\n    return arr[k..<arr.count]\n           ~~~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || arr.isEmpty\
    \ {\n        return arr\n    }\n    \n    var max = [Int]()\n    var maxIndex\
    \ = 0\n    \n    for index in 0..<arr.count {\n        if arr[index] > max[maxIndex]\
    \ {\n            max[maxIndex] = arr[index]\n            maxIndex = index\n  \
    \      }\n    }\n    \n    return max[maxIndex..<maxIndex+k]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmppue7yspu.swift:32:15: error: no 'subscript' candidates produce\
    \ the expected contextual result type '[Int]'\n    return max[maxIndex..<maxIndex+k]\n\
    \              ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    var max\
    \ = [Int]()\n    \n    for index in 0..<arr.count {\n        if arr.count > k\
    \ {\n            break\n        }\n        \n        if arr[index] > max[0] {\n\
    \            max = [arr[index]]\n        } else {\n            max = append(max,\
    \ arr[index])\n        }\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpnjvju6as.swift:29:19: error: cannot find 'append' in scope\n  \
    \          max = append(max, arr[index])\n                  ^~~~~~\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    // write\
    \ your code here\n    \n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpnr56wemo/tmpnr56wemo.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b48eae22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48eab19b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b48eab19988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b48eab187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnr56wemo                        0x00005580aee853c9 <unavailable> + 5065

    5    libc.so.6                          0x00002b48eb00e460 __libc_start_main +
    245

    6    tmpnr56wemo                        0x00005580aee84fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    return arr.sorted\
    \ { $0 < $1 }.prefix(k)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpnok65ofg.swift:18:35: error: cannot convert return expression of\
    \ type 'ArraySlice<Int>' to return type '[Int]'\n    return arr.sorted { $0 <\
    \ $1 }.prefix(k)\n           ~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    var result = Array(repeating:\
    \ 0, count: k)\n    var max = 0\n    for element in arr {\n        if element\
    \ > max {\n            max = element\n        }\n    }\n    for element in arr\
    \ {\n        if element == max {\n            result[element - max] = element\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpb9f583zl/tmpb9f583zl.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b24987c6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b24984bdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b24984bd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b24984bc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb9f583zl                        0x0000561ad2afa5f9 <unavailable> + 5625

    5    libc.so.6                          0x00002b24989b2460 __libc_start_main +
    245

    6    tmpb9f583zl                        0x0000561ad2afa1f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || arr.isEmpty\
    \ {\n        return arr\n    }\n    \n    var max = [Int]()\n    var maxIndex\
    \ = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > max[maxIndex] {\n\
    \            max[maxIndex] = arr[i]\n            maxIndex = i\n        }\n   \
    \ }\n    \n    return max[k..<maxIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp1xfou45p.swift:32:15: error: no 'subscript' candidates produce\
    \ the expected contextual result type '[Int]'\n    return max[k..<maxIndex]\n\
    \              ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    var max\
    \ = [Int]()\n    \n    for x in arr {\n        if x > max[0] {\n            max[0]\
    \ = x\n        }\n    }\n    \n    for x in arr {\n        if x > max[1] {\n \
    \           max[1] = x\n        }\n    }\n    \n    for x in arr {\n        if\
    \ x > max[2] {\n            max[2] = x\n        }\n    }\n    \n    return max[k..<3]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpb_lci6sb.swift:39:15: error: no 'subscript' candidates produce\
    \ the expected contextual result type '[Int]'\n    return max[k..<3]\n       \
    \       ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    var max\
    \ = [Int]()\n    \n    for x in arr {\n        if x > max[0] {\n            max[0]\
    \ = x\n        }\n    }\n    \n    for x in arr {\n        if x > max[1] {\n \
    \           max[1] = x\n        }\n    }\n    \n    return max[k..<arr.count]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpb2mhpnkl.swift:33:15: error: no 'subscript' candidates produce\
    \ the expected contextual result type '[Int]'\n    return max[k..<arr.count]\n\
    \              ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\nSwift.Array:17:23: note: 'subscript(_:)'\
    \ produces '@lvalue ArraySlice<Int>', not the expected contextual result type\
    \ '[Int]'\n    @inlinable public subscript(bounds: Range<Int>) -> ArraySlice<Element>\
    \ { get set }\n                      ^\nSwift.Collection:2:23: note: 'subscript(_:)'\
    \ produces 'ArraySlice<Int>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression,\
    \ Self.Index == R.Bound { get }\n                      ^\nSwift.MutableCollection:2:23:\
    \ note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get set }\n             \
    \         ^\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    let result\
    \ = Array(repeating: 0, count: k)\n    \n    for i in 0..<arr.count {\n      \
    \  result[i] = max(arr[i], result[i])\n    }\n    \n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp003m9j62.swift:22:15: error: cannot assign through subscript: 'result'\
    \ is a 'let' constant\n        result[i] = max(arr[i], result[i])\n        ~~~~~~^\n\
    /tmp/tmp003m9j62.swift:19:5: note: change 'let' to 'var' to make it mutable\n\
    \    let result = Array(repeating: 0, count: k)\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    // write\
    \ your code here\n    \n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpnr56wemo/tmpnr56wemo.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b48eae22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48eab19b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b48eab19988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b48eab187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnr56wemo                        0x00005580aee853c9 <unavailable> + 5065

    5    libc.so.6                          0x00002b48eb00e460 __libc_start_main +
    245

    6    tmpnr56wemo                        0x00005580aee84fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    return arr.sorted().prefix(k)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpu94z98f6.swift:18:25: error: no 'prefix' candidates produce the\
    \ expected contextual result type '[Int]'\n    return arr.sorted().prefix(k)\n\
    \                        ^\nSwift.Sequence:7:40: note: 'prefix' produces 'PrefixSequence<[Int]>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public __consuming\
    \ func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n                    \
    \                   ^\nSwift.Collection:6:40: note: 'prefix' produces 'ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public __consuming\
    \ func prefix(_ maxLength: Int) -> Self.SubSequence\n                        \
    \               ^\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || k\
    \ > arr.count {\n        return arr\n    }\n    \n    var max = [Int](repeating:\
    \ -Int.max, count: k)\n    \n    for i in 0..<k {\n        max[i] = max(arr[i],\
    \ max[i])\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpzkvg2vzq.swift:25:18: error: cannot call value of non-function\
    \ type '[Int]'\n        max[i] = max(arr[i], max[i])\n                 ^\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    var max\
    \ = [Int]()\n    \n    for element in arr {\n        if element > max[0] {\n \
    \           max[0] = element\n        }\n    }\n    \n    for element in arr {\n\
    \        if element > max[1] {\n            max[1] = element\n        }\n    }\n\
    \    \n    for element in arr {\n        if element > max[2] {\n            max[2]\
    \ = element\n        }\n    }\n    \n    return max[k..<3]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp7s7e830u.swift:39:15: error: no 'subscript' candidates produce\
    \ the expected contextual result type '[Int]'\n    return max[k..<3]\n       \
    \       ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    return arr.sorted\
    \ { $0 > $1 }.prefix(k)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpgkcsuxmh.swift:18:35: error: cannot convert return expression of\
    \ type 'ArraySlice<Int>' to return type '[Int]'\n    return arr.sorted { $0 >\
    \ $1 }.prefix(k)\n           ~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    return arr.sorted\
    \ { $0 > $1 }.prefix(k)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpgkcsuxmh.swift:18:35: error: cannot convert return expression of\
    \ type 'ArraySlice<Int>' to return type '[Int]'\n    return arr.sorted { $0 >\
    \ $1 }.prefix(k)\n           ~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    let result\
    \ = Array(repeating: 0, count: k)\n    \n    if arr.count > 0 {\n        \n  \
    \      if k == 1 {\n            \n            for i in 0..<arr.count {\n     \
    \           result[i] = arr[i]\n            }\n            \n        } else {\n\
    \            \n            for i in 0..<arr.count {\n                \n      \
    \          if arr[i] > result[result.count - k] {\n                    result[result.count\
    \ - k] = arr[i]\n                }\n            }\n        }\n    }\n    \n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(maximum(arr: [-3,\
    \ -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) == [4,\
    \ 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4pqqjc8z.swift:26:23: error: cannot assign through subscript: 'result'\
    \ is a 'let' constant\n                result[i] = arr[i]\n                ~~~~~~^\n\
    /tmp/tmp4pqqjc8z.swift:19:5: note: change 'let' to 'var' to make it mutable\n\
    \    let result = Array(repeating: 0, count: k)\n    ^~~\n    var\n/tmp/tmp4pqqjc8z.swift:34:27:\
    \ error: cannot assign through subscript: 'result' is a 'let' constant\n     \
    \               result[result.count - k] = arr[i]\n                    ~~~~~~^\n\
    /tmp/tmp4pqqjc8z.swift:19:5: note: change 'let' to 'var' to make it mutable\n\
    \    let result = Array(repeating: 0, count: k)\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    var max = [Int]()\n\
    \    for x in arr {\n        if max < x {\n            max = x\n        }\n  \
    \  }\n    for x in arr {\n        if x == max {\n            max.append(x)\n \
    \       }\n    }\n    return max[k..<arr.count]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpc4e0hmxx.swift:20:12: error: cannot convert value of type '[Int]'\
    \ to expected argument type 'Int'\n        if max < x {\n           ^\n/tmp/tmpc4e0hmxx.swift:21:19:\
    \ error: cannot assign value of type 'Int' to type '[Int]'\n            max =\
    \ x\n                  ^\n/tmp/tmpc4e0hmxx.swift:25:14: error: binary operator\
    \ '==' cannot be applied to operands of type 'Int' and '[Int]'\n        if x ==\
    \ max {\n           ~ ^  ~~~\n/tmp/tmpc4e0hmxx.swift:25:14: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Int, Int)\n     \
    \   if x == max {\n             ^\n/tmp/tmpc4e0hmxx.swift:29:15: error: no 'subscript'\
    \ candidates produce the expected contextual result type '[Int]'\n    return max[k..<arr.count]\n\
    \              ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\nSwift.Array:17:23: note: 'subscript(_:)'\
    \ produces '@lvalue ArraySlice<Int>', not the expected contextual result type\
    \ '[Int]'\n    @inlinable public subscript(bounds: Range<Int>) -> ArraySlice<Element>\
    \ { get set }\n                      ^\nSwift.Collection:2:23: note: 'subscript(_:)'\
    \ produces 'ArraySlice<Int>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression,\
    \ Self.Index == R.Bound { get }\n                      ^\nSwift.MutableCollection:2:23"
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    // write\
    \ your code here\n    \n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpnr56wemo/tmpnr56wemo.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b48eae22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48eab19b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b48eab19988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b48eab187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnr56wemo                        0x00005580aee853c9 <unavailable> + 5065

    5    libc.so.6                          0x00002b48eb00e460 __libc_start_main +
    245

    6    tmpnr56wemo                        0x00005580aee84fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    var max = [Int]()\n\
    \    for x in arr {\n        if x < 0 {\n            continue\n        }\n   \
    \     if k == 0 {\n            max = append(max, x)\n            continue\n  \
    \      }\n        if x > max[k-1] {\n            max[k-1] = x\n        }\n   \
    \ }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(maximum(arr: [-3,\
    \ -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) == [4,\
    \ 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpecjbm2rz.swift:24:19: error: cannot find 'append' in scope\n  \
    \          max = append(max, x)\n                  ^~~~~~\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if arr.count <\
    \ k {\n        return arr\n    }\n    \n    var max = [Int](repeating: -Int.max,\
    \ count: k)\n    \n    for i in 0..<arr.count {\n        if arr[i] > max[k-1]\
    \ {\n            max[k-1] = arr[i]\n        }\n    }\n    \n    return max\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpzti4fiqm/tmpzti4fiqm.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b62bc5fcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b62bc2f3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b62bc2f3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b62bc2f27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzti4fiqm                        0x000055b30f30d6c9 <unavailable> + 5833

    5    libc.so.6                          0x00002b62bc7e8460 __libc_start_main +
    245

    6    tmpzti4fiqm                        0x000055b30f30d2c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    var max\
    \ = [Int]()\n    \n    for element in arr {\n        if element > max[0] {\n \
    \           max[0] = element\n        }\n    }\n    \n    for element in arr {\n\
    \        if element > max[1] {\n            max[1] = element\n        }\n    }\n\
    \    \n    for element in arr {\n        if element > max[2] {\n            max[2]\
    \ = element\n        }\n    }\n    \n    return max[k..<3]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp7s7e830u.swift:39:15: error: no 'subscript' candidates produce\
    \ the expected contextual result type '[Int]'\n    return max[k..<3]\n       \
    \       ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || arr.isEmpty\
    \ {\n        return arr\n    }\n    \n    var max = [Int]()\n    var maxIndex\
    \ = 0\n    \n    for index in 0..<arr.count {\n        if arr[index] > max[maxIndex]\
    \ {\n            max[maxIndex] = arr[index]\n            maxIndex = index\n  \
    \      }\n    }\n    \n    return max[maxIndex..<maxIndex+k]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmppue7yspu.swift:32:15: error: no 'subscript' candidates produce\
    \ the expected contextual result type '[Int]'\n    return max[maxIndex..<maxIndex+k]\n\
    \              ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || arr.isEmpty\
    \ {\n        return arr\n    }\n    \n    var max = [Int](repeating: -Int.max,\
    \ count: k)\n    var maxIndex = 0\n    \n    for i in 0..<arr.count {\n      \
    \  if arr[i] > max[maxIndex] {\n            max[maxIndex] = arr[i]\n         \
    \   maxIndex = maxIndex + 1\n        }\n    }\n    \n    return max\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmporsk5_dg/tmporsk5_dg.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba585a43c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba58573ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba58573a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5857397b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmporsk5_dg                        0x00005594c3f6b759 <unavailable> + 5977

    5    libc.so.6                          0x00002ba585c2f460 __libc_start_main +
    245

    6    tmporsk5_dg                        0x00005594c3f6b359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    let result\
    \ = Array(repeating: 0, count: k)\n    \n    for i in 0..<arr.count {\n      \
    \  result[i] = max(arr[i], result[i])\n    }\n    \n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp003m9j62.swift:22:15: error: cannot assign through subscript: 'result'\
    \ is a 'let' constant\n        result[i] = max(arr[i], result[i])\n        ~~~~~~^\n\
    /tmp/tmp003m9j62.swift:19:5: note: change 'let' to 'var' to make it mutable\n\
    \    let result = Array(repeating: 0, count: k)\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    var max\
    \ = [Int]()\n    \n    for element in arr {\n        if element > max[0] {\n \
    \           max[0] = element\n        }\n    }\n    \n    for element in arr {\n\
    \        if element > max[0] {\n            max[0] = element\n        }\n    }\n\
    \    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1445558c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b144524f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b144524f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b144524f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b144524ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b144504ee83 <unavailable> + 188035

    6    tmp_m_q57mw                        0x0000559616a69531 <unavailable> + 9521

    7    tmp_m_q57mw                        0x0000559616a68559 <unavailable> + 5465

    8    libc.so.6                          0x00002b1445744460 __libc_start_main +
    245

    9    tmp_m_q57mw                        0x0000559616a68239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824590
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    var max\
    \ = [Int]()\n    \n    if arr.count < k {\n        return max\n    }\n    \n \
    \   for index in 0..<k {\n        if arr[index] > max[index] {\n            max[index]\
    \ = arr[index]\n        }\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8d53a47c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8d5373e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8d5373e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8d5373e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8d5373dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8d5353de83 <unavailable> + 188035

    6    tmp811q97jy                        0x000055bd0b344602 <unavailable> + 9730

    7    tmp811q97jy                        0x000055bd0b3435c9 <unavailable> + 5577

    8    libc.so.6                          0x00002b8d53c33460 __libc_start_main +
    245

    9    tmp811q97jy                        0x000055bd0b3432a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || arr.isEmpty()\
    \ {\n        return arr\n    }\n    \n    var max = [Int]()\n    var maxIndex\
    \ = 0\n    \n    for index in 0..<arr.count {\n        if arr[index] > max[maxIndex]\
    \ {\n            max[maxIndex] = arr[index]\n            maxIndex = index\n  \
    \      }\n    }\n    \n    return max[maxIndex..<k].sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpltfgz35q.swift:18:22: error: cannot call value of non-function\
    \ type 'Bool'\n    if k == 0 || arr.isEmpty() {\n                     ^      ~~\n\
    \                            \n"
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    var result = Array<Int>()\n\
    \    var max = 0\n    for element in arr {\n        if element > max {\n     \
    \       max = element\n        }\n    }\n    for element in arr {\n        if\
    \ element == max {\n            result.append(element)\n        }\n    }\n   \
    \ for element in arr {\n        if element > max {\n            result.append(element)\n\
    \        }\n    }\n    return result[k..<result.count]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpgv6hl2e6.swift:35:18: error: no 'subscript' candidates produce\
    \ the expected contextual result type '[Int]'\n    return result[k..<result.count]\n\
    \                 ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript(bounds: Range<Int>) -> ArraySlice<Element> { get set }\n  \
    \                    ^\nSwift.Collection:2:23: note: 'subscript(_:)' produces\
    \ 'ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get }\n                      ^\nSwift.MutableCollection:2:23: note:\
    \ 'subscript(_:)' produces '@lvalue ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get set }\n             \
    \         ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    var max\
    \ = [Int]()\n    \n    if arr.count > k {\n        return arr\n    }\n    \n \
    \   for i in 0..<k {\n        if arr[i] > max[0] {\n            max = [arr[i]]\n\
    \        } else {\n            max.append(arr[i])\n        }\n    }\n    \n  \
    \  return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(maximum(arr: [-3,\
    \ -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) == [4,\
    \ 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad7eafb0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad7eaca7561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad7eaca7286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad7eaca713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad7eaca6bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad7eaaa6e83 <unavailable> + 188035

    6    tmpixqdsu45                        0x00005617b6d6360b <unavailable> + 9739

    7    tmpixqdsu45                        0x00005617b6d625d9 <unavailable> + 5593

    8    libc.so.6                          0x00002ad7eb19c460 __libc_start_main +
    245

    9    tmpixqdsu45                        0x00005617b6d622b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824590
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || arr.isEmpty\
    \ {\n        return arr\n    }\n    var max = [Int]()\n    var maxIndex = 0\n\
    \    for index in 0..<arr.count {\n        if arr[index] > max[maxIndex] {\n \
    \           max[maxIndex] = arr[index]\n            maxIndex = index\n       \
    \ }\n    }\n    return max[maxIndex..<k].sorted()\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b3c1badbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3c1b7d2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3c1b7d2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3c1b7d213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3c1b7d1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b3c1b5d1e83 <unavailable> + 188035

    6    tmpa2jpppwy                        0x00005590f41ee8c5 <unavailable> + 10437

    7    tmpa2jpppwy                        0x00005590f41ed7f9 <unavailable> + 6137

    8    libc.so.6                          0x00002b3c1bcc7460 __libc_start_main +
    245

    9    tmpa2jpppwy                        0x00005590f41ed4d9 <unavailable> + 5337

    '
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    var result = [Int]()\n\
    \    var max = 0\n    for x in arr {\n        if x > max {\n            max =\
    \ x\n        }\n    }\n    for x in arr {\n        if x == max {\n           \
    \ result.append(x)\n        }\n    }\n    if result.count > k {\n        result\
    \ = result[k..<result.count]\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpdemoj1kl.swift:31:24: error: cannot assign value of type 'ArraySlice<Int>'\
    \ to type '[Int]'\n        result = result[k..<result.count]\n               \
    \  ~~~~~~^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || arr.isEmpty()\
    \ {\n        return arr\n    }\n    \n    var max = [Int]()\n    var maxIndex\
    \ = 0\n    \n    for index in 0..<arr.count {\n        if arr[index] > max[maxIndex]\
    \ {\n            max[maxIndex] = arr[index]\n            maxIndex = index\n  \
    \      }\n    }\n    \n    return max[maxIndex..<maxIndex+k]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpe8c392ai.swift:18:22: error: cannot call value of non-function\
    \ type 'Bool'\n    if k == 0 || arr.isEmpty() {\n                     ^      ~~\n\
    \                            \n/tmp/tmpe8c392ai.swift:32:15: error: no 'subscript'\
    \ candidates produce the expected contextual result type '[Int]'\n    return max[maxIndex..<maxIndex+k]\n\
    \              ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    // write\
    \ your code here\n    \n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpnr56wemo/tmpnr56wemo.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b48eae22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48eab19b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b48eab19988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b48eab187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnr56wemo                        0x00005580aee853c9 <unavailable> + 5065

    5    libc.so.6                          0x00002b48eb00e460 __libc_start_main +
    245

    6    tmpnr56wemo                        0x00005580aee84fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    var result = [Int]()\n\
    \    var max = 0\n    for element in arr {\n        if element > max {\n     \
    \       max = element\n        }\n    }\n    for element in arr {\n        if\
    \ element == max {\n            result.append(element)\n        }\n    }\n   \
    \ for _ in 0..<k {\n        result.remove(at: 0)\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/Array.swift:1331: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b306fd56c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b306fa4d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b306fa4d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b306fa4d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b306fa4cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002b306fa3a018 <unavailable> + 1355800

    6    tmpuncz_eud                        0x000055d92fd068a8 <unavailable> + 10408

    7    tmpuncz_eud                        0x000055d92fd056e9 <unavailable> + 5865

    8    libc.so.6                          0x00002b306ff42460 __libc_start_main +
    245

    9    tmpuncz_eud                        0x000055d92fd053c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1659824590
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    var max\
    \ = [Int]()\n    \n    if arr.count > 0 {\n        \n        if k == 1 {\n   \
    \         \n            for i in 0..<arr.count {\n                \n         \
    \       if arr[i] > max[0] {\n                    \n                    max[0]\
    \ = arr[i]\n                }\n            }\n            \n        } else {\n\
    \            \n            for i in 0..<k {\n                \n              \
    \  if arr[i] > max[0] {\n                    \n                    max[0] = arr[i]\n\
    \                }\n            }\n            \n            for i in 1..<arr.count\
    \ {\n                \n                if arr[i] > max[0] {\n                \
    \    \n                    max[0] = arr[i]\n                }\n            }\n\
    \        }\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9a25a96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9a2578d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9a2578d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9a2578d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9a2578cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9a2558ce83 <unavailable> + 188035

    6    tmpyyqfepbf                        0x0000564b9ba0180c <unavailable> + 10252

    7    tmpyyqfepbf                        0x0000564b9ba005c9 <unavailable> + 5577

    8    libc.so.6                          0x00002b9a25c82460 __libc_start_main +
    245

    9    tmpyyqfepbf                        0x0000564b9ba002a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    return Array(arr).sorted().prefix(k)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmphf6y24w4.swift:18:32: error: no 'prefix' candidates produce the\
    \ expected contextual result type '[Int]'\n    return Array(arr).sorted().prefix(k)\n\
    \                               ^\nSwift.Sequence:7:40: note: 'prefix' produces\
    \ 'PrefixSequence<[Int]>', not the expected contextual result type '[Int]'\n \
    \   @inlinable public __consuming func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n\
    \                                       ^\nSwift.Collection:6:40: note: 'prefix'\
    \ produces 'ArraySlice<Int>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public __consuming func prefix(_ maxLength: Int) -> Self.SubSequence\n\
    \                                       ^\nSwift.Sequence:7:40: note: 'prefix'\
    \ produces 'PrefixSequence<[Int]>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public __consuming func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n\
    \                                       ^\nSwift.Collection:6:40: note: 'prefix'\
    \ produces 'ArraySlice<Int>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public __consuming func prefix(_ maxLength: Int) -> Self.SubSequence\n\
    \                                       ^\nSwift.Sequence:7:40: note: 'prefix'\
    \ produces 'PrefixSequence<[Int]>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public __consuming func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n\
    \                                       ^\nSwift.Collection:6:40: note: 'prefix'\
    \ produces 'ArraySlice<Int>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public __consuming func prefix(_ maxLength: Int) -> Self.SubSequence\n\
    \                                       ^\nSwift.Sequence:7:40: note: 'prefix'\
    \ produces 'PrefixSequence<[Int]>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public __consuming func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n\
    \                                       ^\nSwift.Collection:6:40: note: 'prefix'\
    \ produces 'ArraySlice<Int>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public __consuming func pref"
  stdout: ''
  timestamp: 1659824590
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || arr.isEmpty\
    \ {\n        return arr\n    }\n    \n    var max = [Int]()\n    var maxIndex\
    \ = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > max[k] {\n    \
    \        maxIndex = i\n            max = [arr[i]]\n        } else if arr[i] ==\
    \ max[k] {\n            max.append(arr[i])\n        }\n    }\n    \n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(maximum(arr: [-3, -4, 5],\
    \ k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20,\
    \ 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2,\
    \ -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0],\
    \ k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10],\
    \ k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0dd9b5cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0dd9853561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0dd9853286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0dd985313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0dd9852bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0dd9652e83 <unavailable> + 188035

    6    tmpqv8_3yrs                        0x000055bf0ced472c <unavailable> + 10028

    7    tmpqv8_3yrs                        0x000055bf0ced3669 <unavailable> + 5737

    8    libc.so.6                          0x00002b0dd9d48460 __libc_start_main +
    245

    9    tmpqv8_3yrs                        0x000055bf0ced3349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1659824590
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    // Write\
    \ your code here\n    \n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpeeq4i61_/tmpeeq4i61_.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8daf1b1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8daeea8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8daeea8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8daeea77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpeeq4i61_                        0x0000556a7e6a73c9 <unavailable> + 5065

    5    libc.so.6                          0x00002b8daf39d460 __libc_start_main +
    245

    6    tmpeeq4i61_                        0x0000556a7e6a6fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    var max\
    \ = [Int]()\n    var maxIndex = 0\n    \n    for index in 0..<arr.count {\n  \
    \      if arr[index] > max[maxIndex] {\n            max[maxIndex] = arr[index]\n\
    \            maxIndex = index\n        }\n    }\n    \n    return max[0..<k] \n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpwhnh4mf0.swift:29:15: error: no 'subscript' candidates produce\
    \ the expected contextual result type '[Int]'\n    return max[0..<k] \n      \
    \        ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824590
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k > arr.count\
    \ {\n        return []\n    }\n    \n    var max = [Int](repeating: -Int.max,\
    \ count: k)\n    \n    for i in 0..<arr.count {\n        if arr[i] > max[k-1]\
    \ {\n            max[k-1] = arr[i]\n        }\n    }\n    \n    return max\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmplelb7ucz/tmplelb7ucz.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1acfb0fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1acf806b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1acf806988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1acf8057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplelb7ucz                        0x00005600a66476c9 <unavailable> + 5833

    5    libc.so.6                          0x00002b1acfcfb460 __libc_start_main +
    245

    6    tmplelb7ucz                        0x00005600a66472c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824590
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || arr.isEmpty\
    \ {\n        return arr\n    }\n    \n    var max = [Int](repeating: -Int.max,\
    \ count: k)\n    var maxIndex = 0\n    \n    for i in 0..<arr.count {\n      \
    \  if arr[i] > max[maxIndex] {\n            max[maxIndex] = arr[i]\n         \
    \   maxIndex = maxIndex + 1\n        }\n    }\n    \n    return max\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmporsk5_dg/tmporsk5_dg.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba585a43c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba58573ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba58573a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5857397b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmporsk5_dg                        0x00005594c3f6b759 <unavailable> + 5977

    5    libc.so.6                          0x00002ba585c2f460 __libc_start_main +
    245

    6    tmporsk5_dg                        0x00005594c3f6b359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    var result = Array<Int>()\n\
    \    var max = 0\n    for element in arr {\n        if element > max {\n     \
    \       max = element\n        }\n    }\n    for element in arr {\n        if\
    \ element == max {\n            result.insert(element, at: 0)\n        }\n   \
    \ }\n    if result.count > k {\n        result = result[k..<result.count]\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp0xxlxpes.swift:31:24: error: cannot assign value of type 'ArraySlice<Int>'\
    \ to type '[Int]'\n        result = result[k..<result.count]\n               \
    \  ~~~~~~^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824590
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    // Write\
    \ your code here\n    \n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpeeq4i61_/tmpeeq4i61_.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8daf1b1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8daeea8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8daeea8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8daeea77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpeeq4i61_                        0x0000556a7e6a73c9 <unavailable> + 5065

    5    libc.so.6                          0x00002b8daf39d460 __libc_start_main +
    245

    6    tmpeeq4i61_                        0x0000556a7e6a6fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659824590
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    // 1. Your\
    \ code here\n    \n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmphmnzl8cg/tmphmnzl8cg.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6afd9c4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6afd6bbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6afd6bb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6afd6ba7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphmnzl8cg                        0x00005618b22af3c9 <unavailable> + 5065

    5    libc.so.6                          0x00002b6afdbb0460 __libc_start_main +
    245

    6    tmphmnzl8cg                        0x00005618b22aefc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659824590
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    var result = Array(repeating:\
    \ 0, count: k)\n    var max = 0\n    for element in arr {\n        if element\
    \ > max {\n            max = element\n        }\n    }\n    for element in arr\
    \ {\n        if element == max {\n            result[element - max] = element\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpb9f583zl/tmpb9f583zl.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b24987c6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b24984bdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b24984bd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b24984bc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb9f583zl                        0x0000561ad2afa5f9 <unavailable> + 5625

    5    libc.so.6                          0x00002b24989b2460 __libc_start_main +
    245

    6    tmpb9f583zl                        0x0000561ad2afa1f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    var max = [Int]()\n\
    \    for x in arr {\n        if x > max[0] {\n            max[0] = x\n       \
    \ }\n    }\n    for x in arr {\n        if x == max[0] {\n            for y in\
    \ max {\n                if y > x {\n                    max[1] = y\n        \
    \            break\n                }\n            }\n        }\n    }\n    return\
    \ max[k..<arr.count]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmph3nyc5xw.swift:34:15: error: no 'subscript' candidates produce\
    \ the expected contextual result type '[Int]'\n    return max[k..<arr.count]\n\
    \              ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\nSwift.Array:17:23: note: 'subscript(_:)'\
    \ produces '@lvalue ArraySlice<Int>', not the expected contextual result type\
    \ '[Int]'\n    @inlinable public subscript(bounds: Range<Int>) -> ArraySlice<Element>\
    \ { get set }\n                      ^\nSwift.Collection:2:23: note: 'subscript(_:)'\
    \ produces 'ArraySlice<Int>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression,\
    \ Self.Index == R.Bound { get }\n                      ^\nSwift.MutableCollection:2:23:\
    \ note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get set }\n             \
    \         ^\n"
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || arr.isEmpty()\
    \ {\n        return arr\n    }\n    \n    var max = [Int]()\n    var maxIndex\
    \ = 0\n    \n    for index in 0..<arr.count {\n        if arr[index] > max[maxIndex]\
    \ {\n            max[maxIndex] = arr[index]\n            maxIndex = index\n  \
    \      }\n    }\n    \n    return max[maxIndex..<maxIndex+k]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpe8c392ai.swift:18:22: error: cannot call value of non-function\
    \ type 'Bool'\n    if k == 0 || arr.isEmpty() {\n                     ^      ~~\n\
    \                            \n/tmp/tmpe8c392ai.swift:32:15: error: no 'subscript'\
    \ candidates produce the expected contextual result type '[Int]'\n    return max[maxIndex..<maxIndex+k]\n\
    \              ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    var max = [Int]()\n\
    \    for x in arr {\n        if x > max[0] {\n            max[0] = x\n       \
    \ }\n        if x > max[1] {\n            max[1] = x\n        }\n    }\n    return\
    \ max[k..<arr.count]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpqougzz_f.swift:27:15: error: no 'subscript' candidates produce\
    \ the expected contextual result type '[Int]'\n    return max[k..<arr.count]\n\
    \              ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\nSwift.Array:17:23: note: 'subscript(_:)'\
    \ produces '@lvalue ArraySlice<Int>', not the expected contextual result type\
    \ '[Int]'\n    @inlinable public subscript(bounds: Range<Int>) -> ArraySlice<Element>\
    \ { get set }\n                      ^\nSwift.Collection:2:23: note: 'subscript(_:)'\
    \ produces 'ArraySlice<Int>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression,\
    \ Self.Index == R.Bound { get }\n                      ^\nSwift.MutableCollection:2:23:\
    \ note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get set }\n             \
    \         ^\n"
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    return arr.sorted\
    \ { $0 > $1 }.prefix(k)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpgkcsuxmh.swift:18:35: error: cannot convert return expression of\
    \ type 'ArraySlice<Int>' to return type '[Int]'\n    return arr.sorted { $0 >\
    \ $1 }.prefix(k)\n           ~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    var max\
    \ = [Int]()\n    \n    if arr.count > 0 {\n        \n        for i in 0..<k {\n\
    \            \n            if arr[i] > max[0] {\n                \n          \
    \      max = [arr[i]]\n                \n            } else {\n              \
    \  \n                max = [max[0]...arr[i]]\n            }\n        }\n    }\n\
    \    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpocvmhg5n.swift:31:30: error: cannot convert value of type 'ClosedRange<Int>'\
    \ to expected element type 'Int'\n                max = [max[0]...arr[i]]\n  \
    \                           ^\n"
  stdout: ''
  timestamp: 1659824590
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    var max = [Int]()\n\
    \    var maxIndex = 0\n    for index in 0..<arr.count {\n        if arr[index]\
    \ > max[maxIndex] {\n            max[maxIndex] = arr[index]\n            maxIndex\
    \ = index\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b387e4f9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b387e1f0561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b387e1f0286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b387e1f013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b387e1efbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b387dfefe83 <unavailable> + 188035

    6    tmptmuqmfui                        0x000055db7c2a45e6 <unavailable> + 9702

    7    tmptmuqmfui                        0x000055db7c2a35c9 <unavailable> + 5577

    8    libc.so.6                          0x00002b387e6e5460 __libc_start_main +
    245

    9    tmptmuqmfui                        0x000055db7c2a32a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824590
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k > arr.count\
    \ {\n        return arr\n    }\n    \n    var max = [Int](repeating: -Int.max,\
    \ count: k)\n    \n    for i in 0..<k {\n        if arr[i] > max[i] {\n      \
    \      max[i] = arr[i]\n        }\n    }\n    \n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpddw5ssty/tmpddw5ssty.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0bf766dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0bf7364b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0bf7364988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0bf73637b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpddw5ssty                        0x000055e1483d26c9 <unavailable> + 5833

    5    libc.so.6                          0x00002b0bf7859460 __libc_start_main +
    245

    6    tmpddw5ssty                        0x000055e1483d22c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824590
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    var max\
    \ = [Int]()\n    var maxIndex = 0\n    \n    for index in 0..<arr.count {\n  \
    \      if arr[index] > max[maxIndex] {\n            max[maxIndex] = arr[index]\n\
    \            maxIndex = index\n        }\n    }\n    \n    if maxIndex < k {\n\
    \        for index in maxIndex..<k {\n            max.append(arr[index])\n   \
    \     }\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3ea8bdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3ea5b4561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac3ea5b4286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac3ea5b413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac3ea5b3bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ac3ea3b3e83 <unavailable> + 188035

    6    tmp7rrpeh98                        0x000055bf16949675 <unavailable> + 9845

    7    tmp7rrpeh98                        0x000055bf16948629 <unavailable> + 5673

    8    libc.so.6                          0x00002ac3eaaa9460 __libc_start_main +
    245

    9    tmp7rrpeh98                        0x000055bf16948309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1659824590
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || arr.isEmpty\
    \ {\n        return arr\n    }\n    var max = [Int](repeating: -Int.max, count:\
    \ k)\n    var maxIndex = 0\n    for index in 0..<arr.count {\n        if arr[index]\
    \ > max[k-1] {\n            max[k-1] = arr[index]\n            maxIndex = k-1\n\
    \        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpzmulaytk/tmpzmulaytk.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad1f6f59c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad1f6c50b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad1f6c50988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad1f6c4f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzmulaytk                        0x0000560765d4c759 <unavailable> + 5977

    5    libc.so.6                          0x00002ad1f7145460 __libc_start_main +
    245

    6    tmpzmulaytk                        0x0000560765d4c359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || arr.isEmpty\
    \ {\n        return arr\n    }\n    \n    var max = [Int]()\n    var maxIndex\
    \ = 0\n    \n    for index in 0..<arr.count {\n        if arr[index] > max[maxIndex]\
    \ {\n            max[maxIndex] = arr[index]\n            maxIndex = index\n  \
    \      }\n    }\n    \n    return max[maxIndex..<maxIndex+k]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmppue7yspu.swift:32:15: error: no 'subscript' candidates produce\
    \ the expected contextual result type '[Int]'\n    return max[maxIndex..<maxIndex+k]\n\
    \              ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    return arr.sorted\
    \ { $0 > $1 }.prefix(k)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpgkcsuxmh.swift:18:35: error: cannot convert return expression of\
    \ type 'ArraySlice<Int>' to return type '[Int]'\n    return arr.sorted { $0 >\
    \ $1 }.prefix(k)\n           ~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    return arr.sorted\
    \ { $0 > $1 }.prefix(k)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpgkcsuxmh.swift:18:35: error: cannot convert return expression of\
    \ type 'ArraySlice<Int>' to return type '[Int]'\n    return arr.sorted { $0 >\
    \ $1 }.prefix(k)\n           ~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    // 1. Create\
    \ a result array\n    var result = [Int]()\n    \n    // 2. Create a variable\
    \ to hold the maximum value\n    var maxVal = arr[0]\n    \n    // 3. Create a\
    \ variable to hold the index of the maximum value\n    var maxIndex = 0\n    \n\
    \    // 4. Traverse the array and find the maximum value\n    for i in 1..<arr.count\
    \ {\n        if arr[i] > maxVal {\n            maxVal = arr[i]\n            maxIndex\
    \ = i\n        }\n    }\n    \n    // 5. Copy the maximum value to the result\
    \ array\n    result.append(maxVal)\n    \n    // 6. Copy the maximum value to\
    \ the result array\n    result.append(arr[maxIndex])\n    \n    // 7. Copy the\
    \ remaining elements to the result array\n    for i in maxIndex+1..<arr.count\
    \ {\n        result.append(arr[i])\n    }\n    \n    // 8. Sort the result array\n\
    \    result.sort()\n    \n    // 9. Return the result array\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpt1ymcc5c/tmpt1ymcc5c.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5c7efc2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5c7ecb9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5c7ecb9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5c7ecb87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt1ymcc5c                        0x000055e262a367d9 <unavailable> + 6105

    5    libc.so.6                          0x00002b5c7f1ae460 __libc_start_main +
    245

    6    tmpt1ymcc5c                        0x000055e262a363d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || arr.isEmpty()\
    \ {\n        return arr\n    }\n    var max = [Int]()\n    var maxIndex = 0\n\
    \    for index in 0..<arr.count {\n        if arr[index] > max[maxIndex] {\n \
    \           max[maxIndex] = arr[index]\n            maxIndex = index\n       \
    \ }\n    }\n    return max[0..<k-1]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpzt0yttf4.swift:18:22: error: cannot call value of non-function\
    \ type 'Bool'\n    if k == 0 || arr.isEmpty() {\n                     ^      ~~\n\
    \                            \n/tmp/tmpzt0yttf4.swift:29:15: error: no 'subscript'\
    \ candidates produce the expected contextual result type '[Int]'\n    return max[0..<k-1]\n\
    \              ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || arr.isEmpty\
    \ {\n        return arr\n    }\n    \n    var max = [Int]()\n    var maxIndex\
    \ = -1\n    \n    for i in 0..<arr.count {\n        if arr[i] > max[0] {\n   \
    \         maxIndex = i\n            max = [arr[i]]\n        } else if arr[i] ==\
    \ max[0] {\n            max.append(arr[i])\n        }\n    }\n    \n    if maxIndex\
    \ == -1 {\n        return arr\n    }\n    \n    var maxIndex = -1\n    \n    for\
    \ i in 0..<arr.count {\n        if arr[i] > max[0] {\n            maxIndex = i\n\
    \            max = [arr[i]]\n        } else if arr[i] == max[0] {\n          \
    \  max.append(arr[i])\n        }\n    }\n    \n    if maxIndex == -1 {\n     \
    \   return arr\n    }\n    \n    var maxIndex = -1\n    \n    for i in 0..<arr.count\
    \ {\n        if arr[i] > max[0] {\n            maxIndex = i\n            max =\
    \ [arr[i]]\n        } else if arr[i] == max[0] {\n            max.append(arr[i])\n\
    \        }\n    }\n    \n    if maxIndex == -1 {\n        return arr\n    }\n\
    \    \n    for i in 0..<arr.count {\n        if arr[i] > max[0] {\n          \
    \  maxIndex = i\n            max = [arr[i]]\n        } else if arr[i] == max[0]\
    \ {\n            max.append(arr[i])\n        }\n    }\n    \n    if maxIndex ==\
    \ -1 {\n        return arr\n    }\n    \n    for i in 0..<arr.count {\n      \
    \  if arr[i] > max[0] {\n            maxIndex = i\n            max = [arr[i]]\n\
    \        } else if arr[i] == max[0] {\n            max.append(arr[i])\n      \
    \  }\n    }\n    \n    if maxIndex == -1 {\n        return arr\n    }\n    \n\
    \    for i in 0..<arr.count {\n        if arr[i] > max[0] {\n            maxIndex\
    \ = i\n            max = [arr[i]]\n        } else if arr[i] == max[0] {\n    \
    \        max.append(arr[i])\n        }\n    }\n    \n    if maxIndex == -1 {\n\
    \        return arr\n    }\n    \n    for i in 0..<arr.count {\n        if arr[i]\
    \ > max[0] {\n            maxIndex = i\n            max = [arr[i]]\n        }\
    \ else if arr[i] == max[0] {\n            max.append(arr[i])\n        }\n    }\n\
    \    \n    if maxIndex == -1 {\n        return arr\n    }\n    \n    for i in\
    \ 0..<arr.count {\n        if arr[i] > max[0] {\n            maxIndex = i\n  \
    \          max = [arr[i]]\n        } else if arr[i] == max[0] {\n            max.append(arr[i])\n\
    \        }\n    }\n    \n    if \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmph3lv2nyh.swift:129:7: error: expected expression, var, or let in\
    \ 'if' condition\n    if \n      ^\n/tmp/tmph3lv2nyh.swift:38:9: error: invalid\
    \ redeclaration of 'maxIndex'\n    var maxIndex = -1\n        ^\n/tmp/tmph3lv2nyh.swift:23:9:\
    \ note: 'maxIndex' previously declared here\n    var maxIndex = -1\n        ^\n\
    /tmp/tmph3lv2nyh.swift:53:9: error: invalid redeclaration of 'maxIndex'\n    var\
    \ maxIndex = -1\n        ^\n/tmp/tmph3lv2nyh.swift:23:9: note: 'maxIndex' previously\
    \ declared here\n    var maxIndex = -1\n        ^\n"
  stdout: ''
  timestamp: 1659824590
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || k\
    \ > arr.count {\n        return arr\n    }\n    \n    var max = [Int]()\n    var\
    \ maxIndex = 0\n    \n    for i in 0..<k {\n        if arr[i] > max[maxIndex]\
    \ {\n            max[maxIndex] = arr[i]\n            maxIndex = i\n        }\n\
    \    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9237418c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b923710f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b923710f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b923710f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b923710ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9236f0ee83 <unavailable> + 188035

    6    tmparnwki__                        0x000055b927f24651 <unavailable> + 9809

    7    tmparnwki__                        0x000055b927f235c9 <unavailable> + 5577

    8    libc.so.6                          0x00002b9237604460 __libc_start_main +
    245

    9    tmparnwki__                        0x000055b927f232a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || k\
    \ > arr.count {\n        return arr\n    }\n    \n    var max = [Int]()\n    var\
    \ maxIndex = 0\n    \n    for index in 0..<arr.count {\n        if arr[index]\
    \ > max[maxIndex] {\n            max[maxIndex] = arr[index]\n            maxIndex\
    \ = index\n        }\n    }\n    \n    return max[maxIndex..<k+1]\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpib32puhs.swift:32:15: error: no 'subscript' candidates produce\
    \ the expected contextual result type '[Int]'\n    return max[maxIndex..<k+1]\n\
    \              ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    return arr.sorted().prefix(k)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpu94z98f6.swift:18:25: error: no 'prefix' candidates produce the\
    \ expected contextual result type '[Int]'\n    return arr.sorted().prefix(k)\n\
    \                        ^\nSwift.Sequence:7:40: note: 'prefix' produces 'PrefixSequence<[Int]>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public __consuming\
    \ func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n                    \
    \                   ^\nSwift.Collection:6:40: note: 'prefix' produces 'ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public __consuming\
    \ func prefix(_ maxLength: Int) -> Self.SubSequence\n                        \
    \               ^\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    return arr.sorted\
    \ { $0 < $1 }.prefix(k)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpnok65ofg.swift:18:35: error: cannot convert return expression of\
    \ type 'ArraySlice<Int>' to return type '[Int]'\n    return arr.sorted { $0 <\
    \ $1 }.prefix(k)\n           ~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || arr.isEmpty()\
    \ {\n        return arr\n    }\n    var max = [Int]()\n    var maxIndex = 0\n\
    \    for index in 0..<arr.count {\n        if arr[index] > max[maxIndex] {\n \
    \           max[maxIndex] = arr[index]\n            maxIndex = index\n       \
    \ }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpfqnf25xp.swift:18:22: error: cannot call value of non-function\
    \ type 'Bool'\n    if k == 0 || arr.isEmpty() {\n                     ^      ~~\n\
    \                            \n"
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    var max = [Int]()\n\
    \    var maxIndex = 0\n    for index in 0..<arr.count {\n        if arr[index]\
    \ > max[maxIndex] {\n            max[maxIndex] = arr[index]\n            maxIndex\
    \ = index\n        }\n    }\n    return max[maxIndex..<maxIndex+k]\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp_pdtrh2w.swift:26:15: error: no 'subscript' candidates produce\
    \ the expected contextual result type '[Int]'\n    return max[maxIndex..<maxIndex+k]\n\
    \              ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    return arr.sorted\
    \ { $0 > $1 }.prefix(k)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpgkcsuxmh.swift:18:35: error: cannot convert return expression of\
    \ type 'ArraySlice<Int>' to return type '[Int]'\n    return arr.sorted { $0 >\
    \ $1 }.prefix(k)\n           ~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    precondition(k\
    \ <= arr.count, \"k should be less than or equal to arr.count\")\n    \n    var\
    \ max = [Int]()\n    var maxIndex = 0\n    \n    for index in 0..<k {\n      \
    \  if arr[index] > max[maxIndex] {\n            max[maxIndex] = arr[index]\n \
    \           maxIndex = index\n        }\n    }\n    \n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b822faf6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b822f7ed561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b822f7ed286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b822f7ed13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b822f7ecbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b822f5ece83 <unavailable> + 188035

    6    tmpupgot2sc                        0x000055c401ccb711 <unavailable> + 10001

    7    tmpupgot2sc                        0x000055c401cca659 <unavailable> + 5721

    8    libc.so.6                          0x00002b822fce2460 __libc_start_main +
    245

    9    tmpupgot2sc                        0x000055c401cca339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    var max\
    \ = [Int]()\n    \n    for x in arr {\n        if x > max[0] {\n            max[0]\
    \ = x\n        }\n    }\n    \n    for x in arr {\n        if x > max[1] {\n \
    \           max[1] = x\n        }\n    }\n    \n    return max[k..<k.count]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpehq_jnwr.swift:33:15: error: no 'subscript' candidates produce\
    \ the expected contextual result type '[Int]'\n    return max[k..<k.count]\n \
    \             ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\n/tmp/tmpehq_jnwr.swift:33:22:\
    \ error: value of type 'Int' has no member 'count'\n    return max[k..<k.count]\n\
    \                   ~ ^~~~~\n"
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    var max\
    \ = [Int]()\n    \n    for x in arr {\n        if x < 0 {\n            max = append(max,\
    \ 0)\n        } else {\n            max = append(max, x)\n        }\n    }\n \
    \   \n    if k == 1 {\n        return max\n    }\n    \n    if k == len(max) {\n\
    \        return max\n    }\n    \n    var maxIndex = 0\n    \n    for x in max\
    \ {\n        if x > max[maxIndex] {\n            maxIndex = maxIndex\n       \
    \ }\n    }\n    \n    var maxIndex2 = 0\n    \n    for x in max {\n        if\
    \ x > max[maxIndex2] {\n            maxIndex2 = maxIndex2\n        }\n    }\n\
    \    \n    var maxIndex3 = 0\n    \n    for x in max {\n        if x > max[maxIndex3]\
    \ {\n            maxIndex3 = maxIndex3\n        }\n    }\n    \n    var maxIndex4\
    \ = 0\n    \n    for x in max {\n        if x > max[maxIndex4] {\n           \
    \ maxIndex4 = maxIndex4\n        }\n    }\n    \n    var maxIndex5 = 0\n    \n\
    \    for x in max {\n        if x > max[maxIndex5] {\n            maxIndex5 =\
    \ maxIndex5\n        }\n    }\n    \n    var maxIndex6 = 0\n    \n    for x in\
    \ max {\n        if x > max[maxIndex6] {\n            maxIndex6 = maxIndex6\n\
    \        }\n    }\n    \n    var maxIndex7 = 0\n    \n    for x in max {\n   \
    \     if x > max[maxIndex7] {\n            maxIndex7 = maxIndex7\n        }\n\
    \    }\n    \n    var maxIndex8 = 0\n    \n    for x in max {\n        if x >\
    \ max[maxIndex8] {\n            maxIndex8 = maxIndex8\n        }\n    }\n    \n\
    \    var maxIndex9 = 0\n    \n    for x in max {\n        if x > max[maxIndex9]\
    \ {\n            maxIndex9 = maxIndex9\n        }\n    }\n    \n    var maxIndex10\
    \ = 0\n    \n    for x in max {\n        if x > max[maxIndex10] {\n          \
    \  maxIndex10 = maxIndex10\n        }\n    }\n    \n    var maxIndex11 = 0\n \
    \   \n    for x in max {\n        if x > max[maxIndex11] {\n            maxIndex11\
    \ = maxIndex11\n        }\n    }\n    \n    var maxIndex12 = 0\n    \n    for\
    \ x in max {\n        if x > max[maxIndex12] {\n            maxIndex12 = maxIndex12\n\
    \        }\n    }\n    \n    var maxIndex13 = 0\n    \n    for x in max {\n  \
    \      if x > max[maxIndex13] {\n            maxIndex13 = maxIndex13\n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpeh6k9sga.swift:164:72: error: expected '}' at end of brace statement\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])\n    \
    \                                                                   ^\n/tmp/tmpeh6k9sga.swift:135:18:\
    \ note: to match this opening '{'\n    for x in max {\n                 ^\n/tmp/tmpeh6k9sga.swift:164:72:\
    \ error: expected '}' at end of brace statement\nassert(maximum(arr: [1, 2, 3,\
    \ -23, 243, -400, 0], k: 0) == [] as [Int])\n                                \
    \                                       ^\n/tmp/tmpeh6k9sga.swift:17:43: note:\
    \ to match this opening '{'\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n   \
    \                                       ^\n/tmp/tmpeh6k9sga.swift:23:19: error:\
    \ cannot find 'append' in scope\n            max = append(max, 0)\n          \
    \        ^~~~~~\n/tmp/tmpeh6k9sga.swift:25:19: error: cannot find 'append' in\
    \ scope\n            max = append(max, x)\n                  ^~~~~~\n/tmp/tmpeh6k9sga.swift:33:13:\
    \ error: cannot find 'len' in scope\n    if k == len(max) {\n            ^~~\n\
    /tmp/tmpeh6k9sga.swift:41:22: error: assigning a variable to itself\n        \
    \    maxIndex = maxIndex\n            ~~~~~~~~ ^ ~~~~~~~~\n/tmp/tmpeh6k9sga.swift:49:23:\
    \ error: assigning a variable to itself\n            maxIndex2 = maxIndex2\n \
    \           ~~~~~~~~~ ^ ~~~~~~~~~\n/tmp/tmpeh6k9sga.swift:57:23: error: assigning\
    \ a variable to itself\n            maxIndex3 = maxIndex3\n            ~~~~~~~~~\
    \ ^ ~~~~~~~~~\n/tmp/tmpeh6k9sga.swift:65:23: error: assigning a variable to itself\n\
    \            maxIndex4 = maxIndex4\n            ~~~~~~~~~ ^ ~~~~~~~~~\n/tmp/tmpeh6k9sga.swift:73:23:\
    \ error: assigning a variable to itself\n            maxIndex5 = maxIndex5\n \
    \           ~~~~~~~~~ ^ ~~~~~~~~~\n/tmp/tmpeh6k9sga.swift:81:23: error: assigning\
    \ a variable to itself\n            maxIndex6 = maxIndex6\n            ~~~~~~~~~\
    \ ^ ~~~~~~~~~\n/tmp/tmpeh6k9sga.swift:89:23: error: assigning a variable to itself\n\
    \            maxIndex7 = maxIndex7\n            ~~~~~~~~~ ^ ~~~~~~~~~\n/tmp/tmpeh6k9sga.swift:97:23:\
    \ error: assigning a var"
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    var max\
    \ = [Int]()\n    var maxIndex = 0\n    \n    for index in 0..<arr.count {\n  \
    \      if arr[index] > max[maxIndex] {\n            max[maxIndex] = arr[index]\n\
    \            maxIndex = index\n        }\n    }\n    \n    return max[maxIndex..<maxIndex+k]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpqkz14zt7.swift:29:15: error: no 'subscript' candidates produce\
    \ the expected contextual result type '[Int]'\n    return max[maxIndex..<maxIndex+k]\n\
    \              ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    return arr.sorted\
    \ { $0 > $1 }.prefix(k)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpgkcsuxmh.swift:18:35: error: cannot convert return expression of\
    \ type 'ArraySlice<Int>' to return type '[Int]'\n    return arr.sorted { $0 >\
    \ $1 }.prefix(k)\n           ~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    // write\
    \ your code here\n    \n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpnr56wemo/tmpnr56wemo.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b48eae22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48eab19b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b48eab19988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b48eab187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnr56wemo                        0x00005580aee853c9 <unavailable> + 5065

    5    libc.so.6                          0x00002b48eb00e460 __libc_start_main +
    245

    6    tmpnr56wemo                        0x00005580aee84fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || k\
    \ > arr.count {\n        return arr\n    }\n    \n    var max = [Int]()\n    \n\
    \    for index in 0..<k {\n        if arr[index] > max[0] {\n            max =\
    \ [arr[index]]\n        } else if arr[index] == max[0] {\n            max.append(arr[index])\n\
    \        }\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8c59c0dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8c59904561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8c59904286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8c5990413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8c59903bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8c59703e83 <unavailable> + 188035

    6    tmpurqtw_v5                        0x000055e1b08b7649 <unavailable> + 9801

    7    tmpurqtw_v5                        0x000055e1b08b65d9 <unavailable> + 5593

    8    libc.so.6                          0x00002b8c59df9460 __libc_start_main +
    245

    9    tmpurqtw_v5                        0x000055e1b08b62b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || arr.isEmpty()\
    \ {\n        return arr\n    }\n    \n    var max = [Int]()\n    var maxIndex\
    \ = 0\n    \n    for index in 0..<arr.count {\n        if arr[index] > max[index]\
    \ {\n            maxIndex = index\n            max = [arr[index]]\n        } else\
    \ if arr[index] == max[index] {\n            max.append(arr[index])\n        }\n\
    \    }\n    \n    return max[0 ..< k].sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpif5y88la.swift:18:22: error: cannot call value of non-function\
    \ type 'Bool'\n    if k == 0 || arr.isEmpty() {\n                     ^      ~~\n\
    \                            \n"
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    return arr.sorted\
    \ { $0 > $1 }.prefix(k)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpgkcsuxmh.swift:18:35: error: cannot convert return expression of\
    \ type 'ArraySlice<Int>' to return type '[Int]'\n    return arr.sorted { $0 >\
    \ $1 }.prefix(k)\n           ~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    // write\
    \ your code here\n    \n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpnr56wemo/tmpnr56wemo.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b48eae22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48eab19b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b48eab19988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b48eab187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnr56wemo                        0x00005580aee853c9 <unavailable> + 5065

    5    libc.so.6                          0x00002b48eb00e460 __libc_start_main +
    245

    6    tmpnr56wemo                        0x00005580aee84fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || k\
    \ > arr.count {\n        return arr\n    }\n    \n    var max = [Int]()\n    var\
    \ maxIndex = 0\n    \n    for i in 0..<k {\n        if arr[i] > max[0] {\n   \
    \         maxIndex = i\n            max = [arr[i]]\n        } else if arr[i] >\
    \ max[0] {\n            max = append(max, arr[i])\n        }\n    }\n    \n  \
    \  return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(maximum(arr: [-3,\
    \ -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) == [4,\
    \ 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpvkd2j60c.swift:30:19: error: cannot find 'append' in scope\n  \
    \          max = append(max, arr[i])\n                  ^~~~~~\n"
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || arr.isEmpty()\
    \ {\n        return arr\n    }\n    \n    var max = [Int]()\n    var maxIndex\
    \ = 0\n    \n    for index in 0..<arr.count {\n        if arr[index] > max[maxIndex]\
    \ {\n            max[maxIndex] = arr[index]\n            maxIndex = index\n  \
    \      }\n    }\n    \n    return max[0..<maxIndex]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp2rv7tdnj.swift:18:22: error: cannot call value of non-function\
    \ type 'Bool'\n    if k == 0 || arr.isEmpty() {\n                     ^      ~~\n\
    \                            \n/tmp/tmp2rv7tdnj.swift:32:15: error: no 'subscript'\
    \ candidates produce the expected contextual result type '[Int]'\n    return max[0..<maxIndex]\n\
    \              ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || arr.isEmpty\
    \ {\n        return arr\n    }\n    \n    var max = [Int]()\n    var maxIndex\
    \ = 0\n    \n    for index in 0..<arr.count {\n        if arr[index] > max[maxIndex]\
    \ {\n            max[maxIndex] = arr[index]\n            maxIndex = index\n  \
    \      }\n    }\n    \n    return max[maxIndex..<maxIndex+k]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmppue7yspu.swift:32:15: error: no 'subscript' candidates produce\
    \ the expected contextual result type '[Int]'\n    return max[maxIndex..<maxIndex+k]\n\
    \              ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    // write\
    \ your code here\n    \n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpnr56wemo/tmpnr56wemo.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b48eae22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48eab19b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b48eab19988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b48eab187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnr56wemo                        0x00005580aee853c9 <unavailable> + 5065

    5    libc.so.6                          0x00002b48eb00e460 __libc_start_main +
    245

    6    tmpnr56wemo                        0x00005580aee84fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    var max\
    \ = [Int]()\n    \n    for element in arr {\n        if element > max[0] {\n \
    \           max[0] = element\n        }\n    }\n    \n    for element in arr {\n\
    \        if element > max[k] {\n            max[k] = element\n        }\n    }\n\
    \    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ac93b77ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac93b471561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac93b471286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac93b47113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac93b470bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ac93b270e83 <unavailable> + 188035

    6    tmphm3u9wvx                        0x000055820d550531 <unavailable> + 9521

    7    tmphm3u9wvx                        0x000055820d54f559 <unavailable> + 5465

    8    libc.so.6                          0x00002ac93b966460 __libc_start_main +
    245

    9    tmphm3u9wvx                        0x000055820d54f239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || arr.isEmpty\
    \ {\n        return arr\n    }\n    \n    var max = [Int]()\n    var maxIndex\
    \ = 0\n    \n    for index in 0..<arr.count {\n        if arr[index] > max[maxIndex]\
    \ {\n            max[maxIndex] = arr[index]\n            maxIndex = index\n  \
    \      }\n    }\n    \n    return max[maxIndex..<maxIndex+k]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmppue7yspu.swift:32:15: error: no 'subscript' candidates produce\
    \ the expected contextual result type '[Int]'\n    return max[maxIndex..<maxIndex+k]\n\
    \              ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    // 1. Sort\
    \ arr\n    arr.sort()\n    \n    // 2. Return arr[k..<arr.count] \n    return\
    \ arr[k..<arr.count]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpqrp2qy_m.swift:20:9: error: cannot use mutating member on immutable\
    \ value: 'arr' is a 'let' constant\n    arr.sort()\n    ~~~ ^\n/tmp/tmpqrp2qy_m.swift:23:15:\
    \ error: cannot convert return expression of type 'ArraySlice<Int>' to return\
    \ type '[Int]'\n    return arr[k..<arr.count]\n           ~~~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || arr.isEmpty\
    \ {\n        return arr\n    }\n    \n    var max = [Int]()\n    var maxIndex\
    \ = -1\n    \n    for i in 0..<arr.count {\n        if arr[i] > max[maxIndex]\
    \ {\n            maxIndex = i\n            max = [arr[i]]\n        } else if arr[i]\
    \ == max[maxIndex] {\n            max.append(arr[i])\n        }\n    }\n    \n\
    \    return max[0..<k - 1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp3aqktx6z.swift:34:15: error: no 'subscript' candidates produce\
    \ the expected contextual result type '[Int]'\n    return max[0..<k - 1]\n   \
    \           ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    return arr.sorted\
    \ { $0 < $1 }.prefix(k)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpnok65ofg.swift:18:35: error: cannot convert return expression of\
    \ type 'ArraySlice<Int>' to return type '[Int]'\n    return arr.sorted { $0 <\
    \ $1 }.prefix(k)\n           ~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    precondition(k\
    \ <= arr.count, \"k should be less than or equal to arr.count\")\n    var max\
    \ = [Int](repeating: 0, count: k)\n    for index in 0..<arr.count {\n        if\
    \ arr[index] > max[index] {\n            max[index] = arr[index]\n        }\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpjj50d22t/tmpjj50d22t.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad2f536bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad2f5062b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad2f5062988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad2f50617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjj50d22t                        0x000055da4081a749 <unavailable> + 5961

    5    libc.so.6                          0x00002ad2f5557460 __libc_start_main +
    245

    6    tmpjj50d22t                        0x000055da4081a349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    var max\
    \ = [Int]()\n    var maxIndex = 0\n    \n    for index in 0..<arr.count {\n  \
    \      if arr[index] > max[maxIndex] {\n            max[maxIndex] = arr[index]\n\
    \            maxIndex = index\n        }\n    }\n    \n    return max[maxIndex..<maxIndex+k]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpqkz14zt7.swift:29:15: error: no 'subscript' candidates produce\
    \ the expected contextual result type '[Int]'\n    return max[maxIndex..<maxIndex+k]\n\
    \              ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    precondition(k\
    \ <= arr.count, \"k must be less than or equal to the length of the array\")\n\
    \    var max = [Int]()\n    for index in 0..<k {\n        if arr[index] > max[index]\
    \ {\n            max = [Int](repeatElement(arr[index], k))\n        }\n    }\n\
    \    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(maximum(arr: [-3,\
    \ -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) == [4,\
    \ 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbcylbtzp.swift:22:38: error: missing argument label 'count:' in\
    \ call\n            max = [Int](repeatElement(arr[index], k))\n              \
    \                       ^\n                                                  count:\
    \ \n"
  stdout: ''
  timestamp: 1659824590
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || arr.isEmpty\
    \ {\n        return arr\n    }\n    \n    var max = [Int]()\n    var maxIndex\
    \ = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > max[maxIndex] {\n\
    \            max[maxIndex] = arr[i]\n            maxIndex = i\n        }\n   \
    \ }\n    \n    return max[maxIndex..<k].sorted()\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1136ef2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1136be9561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1136be9286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b1136be913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1136be8bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b11369e8e83 <unavailable> + 188035

    6    tmpqbknj90l                        0x000055ee723718c5 <unavailable> + 10437

    7    tmpqbknj90l                        0x000055ee723707f9 <unavailable> + 6137

    8    libc.so.6                          0x00002b11370de460 __libc_start_main +
    245

    9    tmpqbknj90l                        0x000055ee723704d9 <unavailable> + 5337

    '
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    return Array(arr).sorted().prefix(k)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmphf6y24w4.swift:18:32: error: no 'prefix' candidates produce the\
    \ expected contextual result type '[Int]'\n    return Array(arr).sorted().prefix(k)\n\
    \                               ^\nSwift.Sequence:7:40: note: 'prefix' produces\
    \ 'PrefixSequence<[Int]>', not the expected contextual result type '[Int]'\n \
    \   @inlinable public __consuming func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n\
    \                                       ^\nSwift.Collection:6:40: note: 'prefix'\
    \ produces 'ArraySlice<Int>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public __consuming func prefix(_ maxLength: Int) -> Self.SubSequence\n\
    \                                       ^\nSwift.Sequence:7:40: note: 'prefix'\
    \ produces 'PrefixSequence<[Int]>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public __consuming func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n\
    \                                       ^\nSwift.Collection:6:40: note: 'prefix'\
    \ produces 'ArraySlice<Int>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public __consuming func prefix(_ maxLength: Int) -> Self.SubSequence\n\
    \                                       ^\nSwift.Sequence:7:40: note: 'prefix'\
    \ produces 'PrefixSequence<[Int]>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public __consuming func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n\
    \                                       ^\nSwift.Collection:6:40: note: 'prefix'\
    \ produces 'ArraySlice<Int>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public __consuming func prefix(_ maxLength: Int) -> Self.SubSequence\n\
    \                                       ^\nSwift.Sequence:7:40: note: 'prefix'\
    \ produces 'PrefixSequence<[Int]>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public __consuming func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n\
    \                                       ^\nSwift.Collection:6:40: note: 'prefix'\
    \ produces 'ArraySlice<Int>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public __consuming func pref"
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || arr.isEmpty\
    \ {\n        return arr\n    }\n    \n    var max = [Int]()\n    var maxIndex\
    \ = -1\n    \n    for index in 0..<arr.count {\n        if arr[index] > max[maxIndex]\
    \ {\n            max[maxIndex] = arr[index]\n            maxIndex = index\n  \
    \      }\n    }\n    \n    return max[maxIndex..<maxIndex+k]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmph0z02ect.swift:32:15: error: no 'subscript' candidates produce\
    \ the expected contextual result type '[Int]'\n    return max[maxIndex..<maxIndex+k]\n\
    \              ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k > arr.count\
    \ {\n        return arr\n    }\n    \n    var max = [Int](repeating: -1000, count:\
    \ k)\n    \n    for i in 0..<k {\n        max[i] = max(arr[i], max[i])\n    }\n\
    \    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4rnejc0b.swift:25:18: error: cannot call value of non-function\
    \ type '[Int]'\n        max[i] = max(arr[i], max[i])\n                 ^\n"
  stdout: ''
  timestamp: 1659824590
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    var max\
    \ = [Int]()\n    var maxIndex = 0\n    \n    for index in 0..<arr.count {\n  \
    \      if arr[index] > max[maxIndex] {\n            max[maxIndex] = arr[index]\n\
    \            maxIndex = index\n        }\n    }\n    \n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad173364c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad17305b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad17305b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad17305b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad17305abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad172e5ae83 <unavailable> + 188035

    6    tmpnig1_uwj                        0x00005623a7c435e6 <unavailable> + 9702

    7    tmpnig1_uwj                        0x00005623a7c425c9 <unavailable> + 5577

    8    libc.so.6                          0x00002ad173550460 __libc_start_main +
    245

    9    tmpnig1_uwj                        0x00005623a7c422a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    var max = [Int]()\n\
    \    for x in arr {\n        if x > max[0] {\n            max[0] = x\n       \
    \ }\n        if x > max[1] {\n            max[1] = x\n        }\n    }\n    return\
    \ max[k..<arr.count]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpqougzz_f.swift:27:15: error: no 'subscript' candidates produce\
    \ the expected contextual result type '[Int]'\n    return max[k..<arr.count]\n\
    \              ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\nSwift.Array:17:23: note: 'subscript(_:)'\
    \ produces '@lvalue ArraySlice<Int>', not the expected contextual result type\
    \ '[Int]'\n    @inlinable public subscript(bounds: Range<Int>) -> ArraySlice<Element>\
    \ { get set }\n                      ^\nSwift.Collection:2:23: note: 'subscript(_:)'\
    \ produces 'ArraySlice<Int>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression,\
    \ Self.Index == R.Bound { get }\n                      ^\nSwift.MutableCollection:2:23:\
    \ note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get set }\n             \
    \         ^\n"
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    var result = Array<Int>()\n\
    \    var maxNum = arr[0]\n    for num in arr {\n        if num > maxNum {\n  \
    \          maxNum = num\n        }\n    }\n    for num in arr {\n        if num\
    \ == maxNum {\n            result.insert(num, at: 0)\n        }\n    }\n    if\
    \ result.count > k {\n        result = result[k..<result.count]\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(maximum(arr: [-3, -4,\
    \ 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\n\
    assert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4ouif7pt.swift:31:24: error: cannot assign value of type 'ArraySlice<Int>'\
    \ to type '[Int]'\n        result = result[k..<result.count]\n               \
    \  ~~~~~~^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    return arr.sorted\
    \ { $0 > $1 }.prefix(k)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpgkcsuxmh.swift:18:35: error: cannot convert return expression of\
    \ type 'ArraySlice<Int>' to return type '[Int]'\n    return arr.sorted { $0 >\
    \ $1 }.prefix(k)\n           ~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    let maxCount\
    \ = arr.count\n    \n    if maxCount == 0 {\n        return arr\n    }\n    \n\
    \    if maxCount == 1 {\n        return arr\n    }\n    \n    if k == 1 {\n  \
    \      return arr\n    }\n    \n    if k == maxCount {\n        return arr\n \
    \   }\n    \n    var maxArr = [Int]()\n    \n    for i in 0..<maxCount {\n   \
    \     if arr[i] > arr[i+1] {\n            maxArr.append(arr[i])\n        } else\
    \ {\n            maxArr.append(arr[i+1])\n        }\n    }\n    \n    return maxArr\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpnyby6lzh/tmpnyby6lzh.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b394b0a3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b394ad9ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b394ad9a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b394ad997b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnyby6lzh                        0x0000563ab09666b9 <unavailable> + 5817

    5    libc.so.6                          0x00002b394b28f460 __libc_start_main +
    245

    6    tmpnyby6lzh                        0x0000563ab09662b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    return Array(arr).sorted().prefix(k)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmphf6y24w4.swift:18:32: error: no 'prefix' candidates produce the\
    \ expected contextual result type '[Int]'\n    return Array(arr).sorted().prefix(k)\n\
    \                               ^\nSwift.Sequence:7:40: note: 'prefix' produces\
    \ 'PrefixSequence<[Int]>', not the expected contextual result type '[Int]'\n \
    \   @inlinable public __consuming func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n\
    \                                       ^\nSwift.Collection:6:40: note: 'prefix'\
    \ produces 'ArraySlice<Int>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public __consuming func prefix(_ maxLength: Int) -> Self.SubSequence\n\
    \                                       ^\nSwift.Sequence:7:40: note: 'prefix'\
    \ produces 'PrefixSequence<[Int]>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public __consuming func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n\
    \                                       ^\nSwift.Collection:6:40: note: 'prefix'\
    \ produces 'ArraySlice<Int>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public __consuming func prefix(_ maxLength: Int) -> Self.SubSequence\n\
    \                                       ^\nSwift.Sequence:7:40: note: 'prefix'\
    \ produces 'PrefixSequence<[Int]>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public __consuming func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n\
    \                                       ^\nSwift.Collection:6:40: note: 'prefix'\
    \ produces 'ArraySlice<Int>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public __consuming func prefix(_ maxLength: Int) -> Self.SubSequence\n\
    \                                       ^\nSwift.Sequence:7:40: note: 'prefix'\
    \ produces 'PrefixSequence<[Int]>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public __consuming func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n\
    \                                       ^\nSwift.Collection:6:40: note: 'prefix'\
    \ produces 'ArraySlice<Int>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public __consuming func pref"
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || arr.isEmpty\
    \ {\n        return arr\n    }\n    var max = [Int]()\n    var maxIndex = 0\n\
    \    for i in 0..<k {\n        if arr[i] > max[k-1] {\n            maxIndex =\
    \ k-1\n            max = [Int]()\n        }\n        if arr[i] > max[k-1] {\n\
    \            max = append(max, arr[i])\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpphsfoz8n.swift:29:19: error: cannot find 'append' in scope\n  \
    \          max = append(max, arr[i])\n                  ^~~~~~\n"
  stdout: ''
  timestamp: 1659824590
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || arr.isEmpty\
    \ {\n        return arr\n    }\n    \n    var max = [Int]()\n    var maxIndex\
    \ = 0\n    \n    for i in 0..<k {\n        if arr[i] > max[maxIndex] {\n     \
    \       max[maxIndex] = arr[i]\n            maxIndex = i\n        }\n    }\n \
    \   \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b823c3d1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b823c0c8561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b823c0c8286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b823c0c813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b823c0c7bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b823bec7e83 <unavailable> + 188035

    6    tmpqnwi0aj1                        0x000055b02a7316b6 <unavailable> + 9910

    7    tmpqnwi0aj1                        0x000055b02a730609 <unavailable> + 5641

    8    libc.so.6                          0x00002b823c5bd460 __libc_start_main +
    245

    9    tmpqnwi0aj1                        0x000055b02a7302e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1659824590
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    // write\
    \ your code here\n    \n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpnr56wemo/tmpnr56wemo.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b48eae22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48eab19b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b48eab19988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b48eab187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnr56wemo                        0x00005580aee853c9 <unavailable> + 5065

    5    libc.so.6                          0x00002b48eb00e460 __libc_start_main +
    245

    6    tmpnr56wemo                        0x00005580aee84fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    var result = [Int]()\n\
    \    var max = 0\n    for element in arr {\n        if element > max {\n     \
    \       max = element\n        }\n    }\n    for element in arr {\n        if\
    \ element == max {\n            result.append(element)\n        }\n    }\n   \
    \ if result.count < k {\n        for _ in 0..<k - result.count {\n           \
    \ result.append(0)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmphrg1tin2/tmphrg1tin2.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8965cc2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b89659b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b89659b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b89659b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphrg1tin2                        0x000055d4105da7c9 <unavailable> + 6089

    5    libc.so.6                          0x00002b8965eae460 __libc_start_main +
    245

    6    tmphrg1tin2                        0x000055d4105da3c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    return arr.sorted\
    \ { $0 > $1 }.prefix(k)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpgkcsuxmh.swift:18:35: error: cannot convert return expression of\
    \ type 'ArraySlice<Int>' to return type '[Int]'\n    return arr.sorted { $0 >\
    \ $1 }.prefix(k)\n           ~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    precondition(k\
    \ <= arr.count, \"k should be less than or equal to arr.count\")\n    \n    var\
    \ max = [Int]()\n    var maxIndex = 0\n    \n    for index in 0..<k {\n      \
    \  if arr[index] > max[maxIndex] {\n            max[maxIndex] = arr[index]\n \
    \           maxIndex = index\n        }\n    }\n    \n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b822faf6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b822f7ed561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b822f7ed286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b822f7ed13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b822f7ecbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b822f5ece83 <unavailable> + 188035

    6    tmpupgot2sc                        0x000055c401ccb711 <unavailable> + 10001

    7    tmpupgot2sc                        0x000055c401cca659 <unavailable> + 5721

    8    libc.so.6                          0x00002b822fce2460 __libc_start_main +
    245

    9    tmpupgot2sc                        0x000055c401cca339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824590
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    precondition(k\
    \ <= arr.count, \"k should be less than or equal to arr.count\")\n    \n    var\
    \ max = [Int]()\n    var maxIndex = 0\n    \n    for index in 0..<k {\n      \
    \  if arr[index] > max[maxIndex] {\n            max[maxIndex] = arr[index]\n \
    \           maxIndex = index\n        }\n    }\n    \n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b822faf6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b822f7ed561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b822f7ed286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b822f7ed13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b822f7ecbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b822f5ece83 <unavailable> + 188035

    6    tmpupgot2sc                        0x000055c401ccb711 <unavailable> + 10001

    7    tmpupgot2sc                        0x000055c401cca659 <unavailable> + 5721

    8    libc.so.6                          0x00002b822fce2460 __libc_start_main +
    245

    9    tmpupgot2sc                        0x000055c401cca339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824590
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    // 1. Your\
    \ code here\n    \n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmphmnzl8cg/tmphmnzl8cg.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6afd9c4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6afd6bbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6afd6bb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6afd6ba7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphmnzl8cg                        0x00005618b22af3c9 <unavailable> + 5065

    5    libc.so.6                          0x00002b6afdbb0460 __libc_start_main +
    245

    6    tmphmnzl8cg                        0x00005618b22aefc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    var max\
    \ = [Int]()\n    \n    for x in arr {\n        if x > max[0] {\n            max[0]\
    \ = x\n        }\n    }\n    \n    for x in arr {\n        if x > max[1] {\n \
    \           max[1] = x\n        }\n    }\n    \n    return max[k..<arr.count]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpb2mhpnkl.swift:33:15: error: no 'subscript' candidates produce\
    \ the expected contextual result type '[Int]'\n    return max[k..<arr.count]\n\
    \              ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\nSwift.Array:17:23: note: 'subscript(_:)'\
    \ produces '@lvalue ArraySlice<Int>', not the expected contextual result type\
    \ '[Int]'\n    @inlinable public subscript(bounds: Range<Int>) -> ArraySlice<Element>\
    \ { get set }\n                      ^\nSwift.Collection:2:23: note: 'subscript(_:)'\
    \ produces 'ArraySlice<Int>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression,\
    \ Self.Index == R.Bound { get }\n                      ^\nSwift.MutableCollection:2:23:\
    \ note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get set }\n             \
    \         ^\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    var result\
    \ = [Int]()\n    \n    if arr.count < k {\n        return result\n    }\n    \n\
    \    if k == 1 {\n        return arr\n    }\n    \n    if k == 2 {\n        if\
    \ arr[0] > arr[1] {\n            return arr\n        } else {\n            return\
    \ [arr[0], arr[1]]\n        }\n    }\n    \n    if k == 3 {\n        if arr[0]\
    \ > arr[1] {\n            if arr[0] > arr[2] {\n                return arr\n \
    \           } else {\n                return [arr[0], arr[2], arr[1]]\n      \
    \      }\n        } else {\n            if arr[1] > arr[2] {\n               \
    \ return arr\n            } else {\n                return [arr[1], arr[0], arr[2]]\n\
    \            }\n        }\n    }\n    \n    if k == 4 {\n        if arr[0] > arr[1]\
    \ {\n            if arr[0] > arr[2] {\n                if arr[0] > arr[3] {\n\
    \                    return arr\n                } else {\n                  \
    \  return [arr[0], arr[3], arr[2], arr[1]]\n                }\n            } else\
    \ {\n                if arr[1] > arr[2] {\n                    if arr[1] > arr[3]\
    \ {\n                        return arr\n                    } else {\n      \
    \                  return [arr[1], arr[3], arr[0], arr[2]]\n                 \
    \   }\n                } else {\n                    if arr[2] > arr[3] {\n  \
    \                      return arr\n                    } else {\n            \
    \            return [arr[2], arr[3], arr[0], arr[1]]\n                    }\n\
    \                }\n            }\n        } else {\n            if arr[1] > arr[2]\
    \ {\n                if arr[1] > arr[3] {\n                    if arr[1] > arr[4]\
    \ {\n                        return arr\n                    } else {\n      \
    \                  return [arr[1], arr[4], arr[0], arr[3], arr[2]]\n         \
    \           }\n                } else {\n                    if arr[2] > arr[3]\
    \ {\n                        if arr[2] > arr[4] {\n                          \
    \  return arr\n                        } else {\n                            return\
    \ [arr[2], arr[4], arr[0], arr[3], arr[1]]\n                        }\n      \
    \              } else {\n                        if arr[3] > arr[4] {\n      \
    \                      return arr\n                        } else {\n        \
    \                    return [arr[3], arr[4], arr[0], arr[1], arr[2]]\n       \
    \                 }\n                    }\n                }\n            } else\
    \ {\n                if arr[2] > arr[3] {\n                    if arr[2] > arr[4]\
    \ {\n                        if arr[2] > arr[5] {\n                          \
    \  return arr\n                        } else {\n                            return\
    \ [arr[2], arr[5], arr[0], arr[3], arr[1], arr[4]]\n                        }\n\
    \                    } else {\n                        if arr[3] > arr[4] {\n\
    \                            if arr[3] > arr[5] {\n                          \
    \      return arr\n                            } else {\n                    \
    \            return [arr[3], arr[5], arr[0], arr[1], arr[4], arr[2]]\n       \
    \                     }\n                        } else {\n                  \
    \          if arr[4] > arr[5] {\n                                return arr\n\
    \                            } else {\n                                return\
    \ [arr[4], arr[5], arr[0], arr[1], arr[3], \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmph0fwhzrc.swift:119:1: error: expected expression in container literal\n\
    }\n^\n/tmp/tmph0fwhzrc.swift:144:72: error: expected '}' at end of brace statement\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])\n    \
    \                                                                   ^\n/tmp/tmph0fwhzrc.swift:114:32:\
    \ note: to match this opening '{'\n                        } else {\n        \
    \                       ^\n/tmp/tmph0fwhzrc.swift:144:72: error: expected '}'\
    \ at end of brace statement\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])\n                                                    \
    \                   ^\n/tmp/tmph0fwhzrc.swift:107:28: note: to match this opening\
    \ '{'\n                    } else {\n                           ^\n/tmp/tmph0fwhzrc.swift:144:72:\
    \ error: expected '}' at end of brace statement\nassert(maximum(arr: [1, 2, 3,\
    \ -23, 243, -400, 0], k: 0) == [] as [Int])\n                                \
    \                                       ^\n/tmp/tmph0fwhzrc.swift:100:36: note:\
    \ to match this opening '{'\n                if arr[2] > arr[3] {\n          \
    \                         ^\n/tmp/tmph0fwhzrc.swift:144:72: error: expected '}'\
    \ at end of brace statement\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])\n                                                    \
    \                   ^\n/tmp/tmph0fwhzrc.swift:99:20: note: to match this opening\
    \ '{'\n            } else {\n                   ^\n/tmp/tmph0fwhzrc.swift:144:72:\
    \ error: expected '}' at end of brace statement\nassert(maximum(arr: [1, 2, 3,\
    \ -23, 243, -400, 0], k: 0) == [] as [Int])\n                                \
    \                                       ^\n/tmp/tmph0fwhzrc.swift:76:16: note:\
    \ to match this opening '{'\n        } else {\n               ^\n/tmp/tmph0fwhzrc.swift:144:72:\
    \ error: expected '}' at end of brace statement\nassert(maximum(arr: [1, 2, 3,\
    \ -23, 243, -400, 0], k: 0) == [] as [Int])\n                                \
    \                                       ^\n/tmp/tmph0fwhzrc.swift:53:15: note:\
    \ to match th"
  stdout: ''
  timestamp: 1659824590
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    // write\
    \ your code here\n    \n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpnr56wemo/tmpnr56wemo.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b48eae22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48eab19b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b48eab19988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b48eab187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnr56wemo                        0x00005580aee853c9 <unavailable> + 5065

    5    libc.so.6                          0x00002b48eb00e460 __libc_start_main +
    245

    6    tmpnr56wemo                        0x00005580aee84fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    var max\
    \ = [Int]()\n    var maxIndex = 0\n    \n    for index in 0..<arr.count {\n  \
    \      if arr[index] > max[maxIndex] {\n            max[maxIndex] = arr[index]\n\
    \            maxIndex = index\n        }\n    }\n    \n    return max[maxIndex..<maxIndex+k]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpqkz14zt7.swift:29:15: error: no 'subscript' candidates produce\
    \ the expected contextual result type '[Int]'\n    return max[maxIndex..<maxIndex+k]\n\
    \              ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    return arr.sorted\
    \ { $0 > $1 }.prefix(k)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpgkcsuxmh.swift:18:35: error: cannot convert return expression of\
    \ type 'ArraySlice<Int>' to return type '[Int]'\n    return arr.sorted { $0 >\
    \ $1 }.prefix(k)\n           ~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    // write\
    \ your code here\n    \n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpnr56wemo/tmpnr56wemo.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b48eae22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48eab19b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b48eab19988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b48eab187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnr56wemo                        0x00005580aee853c9 <unavailable> + 5065

    5    libc.so.6                          0x00002b48eb00e460 __libc_start_main +
    245

    6    tmpnr56wemo                        0x00005580aee84fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    // write\
    \ your code here\n    \n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpnr56wemo/tmpnr56wemo.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b48eae22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48eab19b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b48eab19988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b48eab187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnr56wemo                        0x00005580aee853c9 <unavailable> + 5065

    5    libc.so.6                          0x00002b48eb00e460 __libc_start_main +
    245

    6    tmpnr56wemo                        0x00005580aee84fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || arr.isEmpty\
    \ {\n        return arr\n    }\n    \n    var max = [Int](repeating: -Int.max,\
    \ count: k)\n    \n    for i in 0..<arr.count {\n        if max[k-1] < arr[i]\
    \ {\n            max[k-1] = arr[i]\n        }\n    }\n    \n    return max\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmplftrii2y/tmplftrii2y.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac523513c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac52320ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac52320a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac5232097b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplftrii2y                        0x00005648c039c759 <unavailable> + 5977

    5    libc.so.6                          0x00002ac5236ff460 __libc_start_main +
    245

    6    tmplftrii2y                        0x00005648c039c359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    var result = [Int]()\n\
    \    var max = 0\n    for x in arr {\n        if x > max {\n            max =\
    \ x\n        }\n    }\n    for x in arr {\n        if x == max {\n           \
    \ result.append(x)\n        }\n    }\n    if result.count > k {\n        result\
    \ = result[k..<result.count]\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpdemoj1kl.swift:31:24: error: cannot assign value of type 'ArraySlice<Int>'\
    \ to type '[Int]'\n        result = result[k..<result.count]\n               \
    \  ~~~~~~^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824590
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    var max\
    \ = [Int]()\n    \n    if arr.count < k {\n        return max\n    }\n    \n \
    \   for i in 0..<k {\n        if arr[i] > max[0] {\n            max[0] = arr[i]\n\
    \        }\n    }\n    \n    for i in 0..<k {\n        if arr[i] > max[1] {\n\
    \            max[1] = arr[i]\n        }\n    }\n    \n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002af86353ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af863231561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002af863231286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002af86323113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002af863230bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002af863030e83 <unavailable> + 188035

    6    tmpcq6xg1hm                        0x0000555f8b6d262e <unavailable> + 9774

    7    tmpcq6xg1hm                        0x0000555f8b6d15c9 <unavailable> + 5577

    8    libc.so.6                          0x00002af863726460 __libc_start_main +
    245

    9    tmpcq6xg1hm                        0x0000555f8b6d12a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824590
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    // Write\
    \ your code here\n    \n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpeeq4i61_/tmpeeq4i61_.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8daf1b1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8daeea8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8daeea8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8daeea77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpeeq4i61_                        0x0000556a7e6a73c9 <unavailable> + 5065

    5    libc.so.6                          0x00002b8daf39d460 __libc_start_main +
    245

    6    tmpeeq4i61_                        0x0000556a7e6a6fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || arr\
    \ == nil || arr.isEmpty {\n        return arr\n    }\n    \n    var max = [Int]()\n\
    \    var maxIndex = 0\n    \n    for index in 0..<arr.count {\n        if arr[index]\
    \ > max[maxIndex] {\n            max[maxIndex] = arr[index]\n            maxIndex\
    \ = index\n        }\n    }\n    \n    return max[maxIndex..<maxIndex+k]\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpzwldzu6q.swift:18:22: warning: comparing non-optional value of\
    \ type '[Int]' to 'nil' always returns false\n    if k == 0 || arr == nil || arr.isEmpty\
    \ {\n                 ~~~ ^  ~~~\n/tmp/tmpzwldzu6q.swift:32:15: error: no 'subscript'\
    \ candidates produce the expected contextual result type '[Int]'\n    return max[maxIndex..<maxIndex+k]\n\
    \              ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824590
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if arr.count <\
    \ k {\n        return arr\n    }\n    var max = [Int]()\n    var maxIndex = 0\n\
    \    for index in 0..<arr.count {\n        if arr[index] > max[maxIndex] {\n \
    \           max[maxIndex] = arr[index]\n            maxIndex = index\n       \
    \ }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b2547708c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b25473ff561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b25473ff286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b25473ff13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b25473febb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b25471fee83 <unavailable> + 188035

    6    tmpjr3vgs74                        0x00005634a549f616 <unavailable> + 9750

    7    tmpjr3vgs74                        0x00005634a549e5c9 <unavailable> + 5577

    8    libc.so.6                          0x00002b25478f4460 __libc_start_main +
    245

    9    tmpjr3vgs74                        0x00005634a549e2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    var max\
    \ = [Int]()\n    \n    for x in arr {\n        if max < x {\n            max =\
    \ x\n        }\n    }\n    \n    for x in arr {\n        if x == max {\n     \
    \       max.append(x)\n        }\n    }\n    \n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp0t9g07ue.swift:22:12: error: cannot convert value of type '[Int]'\
    \ to expected argument type 'Int'\n        if max < x {\n           ^\n/tmp/tmp0t9g07ue.swift:23:19:\
    \ error: cannot assign value of type 'Int' to type '[Int]'\n            max =\
    \ x\n                  ^\n/tmp/tmp0t9g07ue.swift:28:14: error: binary operator\
    \ '==' cannot be applied to operands of type 'Int' and '[Int]'\n        if x ==\
    \ max {\n           ~ ^  ~~~\n/tmp/tmp0t9g07ue.swift:28:14: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Int, Int)\n     \
    \   if x == max {\n             ^\n"
  stdout: ''
  timestamp: 1659824590
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    var max\
    \ = [Int]()\n    \n    if arr.count < k {\n        return max\n    }\n    \n \
    \   for i in 0..<k {\n        if arr[i] > max[0] {\n            max[0] = arr[i]\n\
    \        }\n    }\n    \n    for i in 1..<arr.count {\n        if arr[i] > max[0]\
    \ {\n            max[0] = arr[i]\n        }\n    }\n    \n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aadc6111c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aadc5e08561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aadc5e08286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aadc5e0813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aadc5e07bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aadc5c07e83 <unavailable> + 188035

    6    tmpz6eoyztw                        0x000056340e5ce62e <unavailable> + 9774

    7    tmpz6eoyztw                        0x000056340e5cd5c9 <unavailable> + 5577

    8    libc.so.6                          0x00002aadc62fd460 __libc_start_main +
    245

    9    tmpz6eoyztw                        0x000056340e5cd2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    var result\
    \ = arr\n    \n    if k > result.count {\n        return result\n    }\n    \n\
    \    if k == result.count {\n        return result\n    }\n    \n    if k == 1\
    \ {\n        return result.sorted()\n    }\n    \n    if k == 2 {\n        return\
    \ result.sorted().prefix(2)\n    }\n    \n    if k == 3 {\n        return result.sorted().prefix(3)\n\
    \    }\n    \n    if k == 4 {\n        return result.sorted().prefix(4)\n    }\n\
    \    \n    if k == 5 {\n        return result.sorted().prefix(5)\n    }\n    \n\
    \    if k == 6 {\n        return result.sorted().prefix(6)\n    }\n    \n    if\
    \ k == 7 {\n        return result.sorted().prefix(7)\n    }\n    \n    if k ==\
    \ 8 {\n        return result.sorted().prefix(8)\n    }\n    \n    if k == 9 {\n\
    \        return result.sorted().prefix(9)\n    }\n    \n    if k == 10 {\n   \
    \     return result.sorted().prefix(10)\n    }\n    \n    if k == 11 {\n     \
    \   return result.sorted().prefix(11)\n    }\n    \n    if k == 12 {\n       \
    \ return result.sorted().prefix(12)\n    }\n    \n    if k == 13 {\n        return\
    \ result.sorted().prefix(13)\n    }\n    \n    if k == 14 {\n        return result.sorted().prefix(14)\n\
    \    }\n    \n    if k == 15 {\n        return result.sorted().prefix(15)\n  \
    \  }\n    \n    if k == 16 {\n        return result.sorted().prefix(16)\n    }\n\
    \    \n    if k == 17 {\n        return result.sorted().prefix(17)\n    }\n  \
    \  \n    if k == 18 {\n        return result.sorted().prefix(18)\n    }\n    \n\
    \    if k == 19 {\n        return result.sorted().prefix(19)\n    }\n    \n  \
    \  if k == 20 {\n        return result.sorted().prefix(20)\n    }\n    \n    if\
    \ k == 21 {\n        return result.sorted().prefix(21)\n    }\n    \n    if k\
    \ == 22 {\n        return result.sorted().prefix(22)\n    }\n    \n    if k ==\
    \ 23 {\n        return result.sorted().prefix(23)\n    }\n    \n    if k == 24\
    \ {\n        return result.sorted().prefix(24)\n    }\n    \n    if k == 25 {\n\
    \        return result.sorted().prefix(25)\n    }\n    \n    if k == 26 {\n  \
    \      return result.sorted().prefix(26)\n    }\n    \n    if k == 27 {\n    \
    \    return result.sorted().prefix(27)\n    }\n    \n    if k == 28 {\n      \
    \  return result.\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(maximum(arr: [-3,\
    \ -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) == [4,\
    \ 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpgvugrmof.swift:138:22: error: expected member name following '.'\n\
    \        return result.\n                     ^\n/tmp/tmpgvugrmof.swift:164:72:\
    \ error: expected '}' at end of brace statement\nassert(maximum(arr: [1, 2, 3,\
    \ -23, 243, -400, 0], k: 0) == [] as [Int])\n                                \
    \                                       ^\n/tmp/tmpgvugrmof.swift:17:43: note:\
    \ to match this opening '{'\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n   \
    \                                       ^\n/tmp/tmpgvugrmof.swift:34:32: error:\
    \ no 'prefix' candidates produce the expected contextual result type '[Int]'\n\
    \        return result.sorted().prefix(2)\n                               ^\n\
    Swift.Sequence:7:40: note: 'prefix' produces 'PrefixSequence<[Int]>', not the\
    \ expected contextual result type '[Int]'\n    @inlinable public __consuming func\
    \ prefix(_ maxLength: Int) -> PrefixSequence<Self>\n                         \
    \              ^\nSwift.Collection:6:40: note: 'prefix' produces 'ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public __consuming\
    \ func prefix(_ maxLength: Int) -> Self.SubSequence\n                        \
    \               ^\n/tmp/tmpgvugrmof.swift:38:32: error: no 'prefix' candidates\
    \ produce the expected contextual result type '[Int]'\n        return result.sorted().prefix(3)\n\
    \                               ^\nSwift.Sequence:7:40: note: 'prefix' produces\
    \ 'PrefixSequence<[Int]>', not the expected contextual result type '[Int]'\n \
    \   @inlinable public __consuming func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n\
    \                                       ^\nSwift.Collection:6:40: note: 'prefix'\
    \ produces 'ArraySlice<Int>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public __consuming func prefix(_ maxLength: Int) -> Self.SubSequence\n\
    \                                       ^\n/tmp/tmpgvugrmof.swift:42:32: error:\
    \ no 'prefix' candidates produce the expected contextual result type '[Int]'\n\
    \        return result.sorted().prefix(4)\n                               ^\n\
    Swift.Sequence:7:40: note: "
  stdout: ''
  timestamp: 1659824590
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    // write\
    \ your code here\n    \n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpnr56wemo/tmpnr56wemo.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b48eae22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48eab19b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b48eab19988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b48eab187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnr56wemo                        0x00005580aee853c9 <unavailable> + 5065

    5    libc.so.6                          0x00002b48eb00e460 __libc_start_main +
    245

    6    tmpnr56wemo                        0x00005580aee84fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    var max = [Int]()\n\
    \    var maxIndex = 0\n    for index in 0..<arr.count {\n        if arr[index]\
    \ > max[maxIndex] {\n            max[maxIndex] = arr[index]\n            maxIndex\
    \ = index\n        }\n    }\n    return max[0..<k]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpaveji1df.swift:26:15: error: no 'subscript' candidates produce\
    \ the expected contextual result type '[Int]'\n    return max[0..<k]\n       \
    \       ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824590
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    // write\
    \ your code here\n    \n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpnr56wemo/tmpnr56wemo.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b48eae22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48eab19b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b48eab19988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b48eab187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnr56wemo                        0x00005580aee853c9 <unavailable> + 5065

    5    libc.so.6                          0x00002b48eb00e460 __libc_start_main +
    245

    6    tmpnr56wemo                        0x00005580aee84fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    return arr.sorted\
    \ { $0 > $1 }.prefix(k)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpgkcsuxmh.swift:18:35: error: cannot convert return expression of\
    \ type 'ArraySlice<Int>' to return type '[Int]'\n    return arr.sorted { $0 >\
    \ $1 }.prefix(k)\n           ~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || k\
    \ > arr.count {\n        return arr\n    }\n    var max = [Int]()\n    var maxIndex\
    \ = -1\n    for index in 0..<arr.count {\n        if arr[index] > max[index] {\n\
    \            maxIndex = index\n            max = [arr[index]]\n        } else\
    \ if arr[index] == max[index] {\n            max.append(arr[index])\n        }\n\
    \    }\n    return max[0 ..< k - 1]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpqjds0znw.swift:31:15: error: no 'subscript' candidates produce\
    \ the expected contextual result type '[Int]'\n    return max[0 ..< k - 1]\n \
    \             ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || arr.isEmpty\
    \ {\n        return arr\n    }\n    \n    var max = [Int]()\n    var maxIndex\
    \ = 0\n    \n    for index in 0..<arr.count {\n        if arr[index] > max[maxIndex]\
    \ {\n            max[maxIndex] = arr[index]\n            maxIndex = index\n  \
    \      }\n    }\n    \n    return max[maxIndex..<maxIndex+k]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmppue7yspu.swift:32:15: error: no 'subscript' candidates produce\
    \ the expected contextual result type '[Int]'\n    return max[maxIndex..<maxIndex+k]\n\
    \              ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    var max\
    \ = [Int]()\n    var maxIndex = 0\n    \n    for index in 0..<arr.count {\n  \
    \      if arr[index] > max[maxIndex] {\n            max[maxIndex] = arr[index]\n\
    \            maxIndex = index\n        }\n    }\n    \n    return max[maxIndex..<maxIndex+k]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpqkz14zt7.swift:29:15: error: no 'subscript' candidates produce\
    \ the expected contextual result type '[Int]'\n    return max[maxIndex..<maxIndex+k]\n\
    \              ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824590
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    var max\
    \ = [Int]()\n    var maxIndex = 0\n    \n    for index in 0..<arr.count {\n  \
    \      if arr[index] > max[maxIndex] {\n            max[maxIndex] = arr[index]\n\
    \            maxIndex = index\n        }\n    }\n    \n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad173364c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad17305b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad17305b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad17305b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad17305abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad172e5ae83 <unavailable> + 188035

    6    tmpnig1_uwj                        0x00005623a7c435e6 <unavailable> + 9702

    7    tmpnig1_uwj                        0x00005623a7c425c9 <unavailable> + 5577

    8    libc.so.6                          0x00002ad173550460 __libc_start_main +
    245

    9    tmpnig1_uwj                        0x00005623a7c422a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || k\
    \ > arr.count {\n        return arr\n    }\n    var max = [Int]()\n    var maxIndex\
    \ = 0\n    for index in 0..<k {\n        if arr[index] > max[maxIndex] {\n   \
    \         max[maxIndex] = arr[index]\n            maxIndex = index\n        }\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b27dc569c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b27dc260561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b27dc260286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b27dc26013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b27dc25fbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b27dc05fe83 <unavailable> + 188035

    6    tmp4t3v2l_8                        0x0000558a57cf8651 <unavailable> + 9809

    7    tmp4t3v2l_8                        0x0000558a57cf75c9 <unavailable> + 5577

    8    libc.so.6                          0x00002b27dc755460 __libc_start_main +
    245

    9    tmp4t3v2l_8                        0x0000558a57cf72a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    let result\
    \ = Array(repeating: 0, count: k)\n    \n    for element in arr {\n        result[element\
    \ > result[0] ? 1 : 0] += 1\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpj_b4skf0.swift:22:45: error: left side of mutating operator isn't\
    \ mutable: 'result' is a 'let' constant\n        result[element > result[0] ?\
    \ 1 : 0] += 1\n        ~~~~~~                              ^\n/tmp/tmpj_b4skf0.swift:19:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let result = Array(repeating:\
    \ 0, count: k)\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1659824590
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || arr.isEmpty\
    \ {\n        return arr\n    }\n    \n    var max = [Int]()\n    var maxIndex\
    \ = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > max[maxIndex] {\n\
    \            max[maxIndex] = arr[i]\n            maxIndex = i\n        }\n   \
    \ }\n    \n    return max[maxIndex..<k].sorted()\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1136ef2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1136be9561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1136be9286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b1136be913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1136be8bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b11369e8e83 <unavailable> + 188035

    6    tmpqbknj90l                        0x000055ee723718c5 <unavailable> + 10437

    7    tmpqbknj90l                        0x000055ee723707f9 <unavailable> + 6137

    8    libc.so.6                          0x00002b11370de460 __libc_start_main +
    245

    9    tmpqbknj90l                        0x000055ee723704d9 <unavailable> + 5337

    '
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    let result\
    \ = Array(repeating: 0, count: k)\n    \n    for x in arr {\n        result[result.count-1]\
    \ = x \n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4ld66j2v.swift:22:15: error: cannot assign through subscript: 'result'\
    \ is a 'let' constant\n        result[result.count-1] = x \n        ~~~~~~^\n\
    /tmp/tmp4ld66j2v.swift:19:5: note: change 'let' to 'var' to make it mutable\n\
    \    let result = Array(repeating: 0, count: k)\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    var result = Array<Int>()\n\
    \    var max = 0\n    for x in arr {\n        if x > max {\n            max =\
    \ x\n        }\n    }\n    for x in arr {\n        if x == max {\n           \
    \ result.append(x)\n        }\n    }\n    if result.count > k {\n        result\
    \ = result[k..<result.count]\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmps714i8sk.swift:31:24: error: cannot assign value of type 'ArraySlice<Int>'\
    \ to type '[Int]'\n        result = result[k..<result.count]\n               \
    \  ~~~~~~^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    var max\
    \ = [Int]()\n    \n    for x in arr {\n        if x > max[0] {\n            max[0]\
    \ = x\n        }\n    }\n    \n    for x in arr {\n        if x > max[1] {\n \
    \           max[1] = x\n        }\n    }\n    \n    return max[k..<arr.count]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpb2mhpnkl.swift:33:15: error: no 'subscript' candidates produce\
    \ the expected contextual result type '[Int]'\n    return max[k..<arr.count]\n\
    \              ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\nSwift.Array:17:23: note: 'subscript(_:)'\
    \ produces '@lvalue ArraySlice<Int>', not the expected contextual result type\
    \ '[Int]'\n    @inlinable public subscript(bounds: Range<Int>) -> ArraySlice<Element>\
    \ { get set }\n                      ^\nSwift.Collection:2:23: note: 'subscript(_:)'\
    \ produces 'ArraySlice<Int>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression,\
    \ Self.Index == R.Bound { get }\n                      ^\nSwift.MutableCollection:2:23:\
    \ note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get set }\n             \
    \         ^\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || arr.isEmpty()\
    \ {\n        return arr\n    }\n    \n    var max = [Int]()\n    var maxIndex\
    \ = 0\n    \n    for index in 0..<arr.count {\n        if arr[index] > max[maxIndex]\
    \ {\n            max[maxIndex] = arr[index]\n            maxIndex = index\n  \
    \      }\n    }\n    \n    return max[0..<k - 1]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmprgsn5_le.swift:18:22: error: cannot call value of non-function\
    \ type 'Bool'\n    if k == 0 || arr.isEmpty() {\n                     ^      ~~\n\
    \                            \n/tmp/tmprgsn5_le.swift:32:15: error: no 'subscript'\
    \ candidates produce the expected contextual result type '[Int]'\n    return max[0..<k\
    \ - 1]\n              ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript(bounds: Range<Int>) -> ArraySlice<Element> { get set }\n  \
    \                    ^\nSwift.Collection:2:23: note: 'subscript(_:)' produces\
    \ 'ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get }\n                      ^\nSwift.MutableCollection:2:23: note:\
    \ 'subscript(_:)' produces '@lvalue ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get set }\n             \
    \         ^\n"
  stdout: ''
  timestamp: 1659824590
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    var max\
    \ = [Int]()\n    var maxIndex = 0\n    \n    for index in 0..<arr.count {\n  \
    \      if arr[index] > max[maxIndex] {\n            max[maxIndex] = arr[index]\n\
    \            maxIndex = index\n        }\n    }\n    \n    var result = [Int]()\n\
    \    \n    for index in 0..<k {\n        result.append(max[index])\n    }\n  \
    \  \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b2703d10c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2703a07561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b2703a07286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b2703a0713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b2703a06bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b2703806e83 <unavailable> + 188035

    6    tmp_rb_60yd                        0x000056527fa11685 <unavailable> + 9861

    7    tmp_rb_60yd                        0x000056527fa10629 <unavailable> + 5673

    8    libc.so.6                          0x00002b2703efc460 __libc_start_main +
    245

    9    tmp_rb_60yd                        0x000056527fa10309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1659824591
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    // write\
    \ your code here\n    \n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpnr56wemo/tmpnr56wemo.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b48eae22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48eab19b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b48eab19988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b48eab187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnr56wemo                        0x00005580aee853c9 <unavailable> + 5065

    5    libc.so.6                          0x00002b48eb00e460 __libc_start_main +
    245

    6    tmpnr56wemo                        0x00005580aee84fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    // write\
    \ your code here\n    \n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpnr56wemo/tmpnr56wemo.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b48eae22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48eab19b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b48eab19988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b48eab187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnr56wemo                        0x00005580aee853c9 <unavailable> + 5065

    5    libc.so.6                          0x00002b48eb00e460 __libc_start_main +
    245

    6    tmpnr56wemo                        0x00005580aee84fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    // write\
    \ your code here\n    \n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpnr56wemo/tmpnr56wemo.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b48eae22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48eab19b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b48eab19988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b48eab187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnr56wemo                        0x00005580aee853c9 <unavailable> + 5065

    5    libc.so.6                          0x00002b48eb00e460 __libc_start_main +
    245

    6    tmpnr56wemo                        0x00005580aee84fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    // write\
    \ your code here\n    \n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpnr56wemo/tmpnr56wemo.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b48eae22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48eab19b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b48eab19988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b48eab187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnr56wemo                        0x00005580aee853c9 <unavailable> + 5065

    5    libc.so.6                          0x00002b48eb00e460 __libc_start_main +
    245

    6    tmpnr56wemo                        0x00005580aee84fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if arr.count <\
    \ k {\n        return arr\n    }\n    var max = [Int](repeating: 0, count: k)\n\
    \    for index in 0..<arr.count {\n        if arr[index] > max[index] {\n    \
    \        max[index] = arr[index]\n        }\n    }\n    return max\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmp7lbc7148/tmp7lbc7148.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afd75ec4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afd75bbbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afd75bbb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afd75bba7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7lbc7148                        0x0000563e4b98c6c9 <unavailable> + 5833

    5    libc.so.6                          0x00002afd760b0460 __libc_start_main +
    245

    6    tmp7lbc7148                        0x0000563e4b98c2c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824591
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    var max\
    \ = [Int]()\n    \n    if arr.count < k {\n        return max\n    }\n    \n \
    \   for index in 0..<k {\n        if arr[index] > max[0] {\n            max[0]\
    \ = arr[index]\n        }\n    }\n    \n    for index in 1..<arr.count {\n   \
    \     if arr[index] > max[0] {\n            if arr[index] > max[1] {\n       \
    \         max[1] = arr[index]\n            } else {\n                max[0] =\
    \ arr[index]\n            }\n        }\n    }\n    \n    return max\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b19ea741c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b19ea438561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b19ea438286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b19ea43813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b19ea437bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b19ea237e83 <unavailable> + 188035

    6    tmpjadzjj7y                        0x000055aac128062e <unavailable> + 9774

    7    tmpjadzjj7y                        0x000055aac127f5c9 <unavailable> + 5577

    8    libc.so.6                          0x00002b19ea92d460 __libc_start_main +
    245

    9    tmpjadzjj7y                        0x000055aac127f2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824591
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || k\
    \ > arr.count {\n        return arr\n    }\n    \n    var max = [Int]()\n    var\
    \ maxIndex = 0\n    \n    for index in 0..<k {\n        if arr[index] > max[maxIndex]\
    \ {\n            max[maxIndex] = arr[index]\n            maxIndex = index\n  \
    \      }\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9b217bbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9b214b2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9b214b2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9b214b213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9b214b1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9b212b1e83 <unavailable> + 188035

    6    tmp61vax5hd                        0x0000563134a40651 <unavailable> + 9809

    7    tmp61vax5hd                        0x0000563134a3f5c9 <unavailable> + 5577

    8    libc.so.6                          0x00002b9b219a7460 __libc_start_main +
    245

    9    tmp61vax5hd                        0x0000563134a3f2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824591
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || arr.isEmpty\
    \ {\n        return arr\n    }\n    \n    var max = [Int]()\n    var maxIndex\
    \ = 0\n    \n    for i in 0..<arr.count {\n        if arr[i] > max[maxIndex] {\n\
    \            max[maxIndex] = arr[i]\n            maxIndex = i\n        }\n   \
    \ }\n    \n    return max[maxIndex..<k]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpd1y4_4ap.swift:32:15: error: no 'subscript' candidates produce\
    \ the expected contextual result type '[Int]'\n    return max[maxIndex..<k]\n\
    \              ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824591
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    return maximumHelper(arr,\
    \ k, 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(maximum(arr: [-3, -4, 5],\
    \ k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20,\
    \ 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2,\
    \ -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0],\
    \ k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10],\
    \ k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp7_pjs8ao.swift:18:12: error: cannot find 'maximumHelper' in scope\n\
    \    return maximumHelper(arr, k, 0)\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824590
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || arr.isEmpty\
    \ {\n        return arr\n    }\n    \n    var max = [Int]()\n    var maxIndex\
    \ = 0\n    \n    for index in 0..<arr.count {\n        if arr[index] > max[maxIndex]\
    \ {\n            max[maxIndex] = arr[index]\n            maxIndex = index\n  \
    \      }\n    }\n    \n    return max[0..<k - 1]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpxanhp4bf.swift:32:15: error: no 'subscript' candidates produce\
    \ the expected contextual result type '[Int]'\n    return max[0..<k - 1]\n   \
    \           ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824590
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || arr.isEmpty\
    \ {\n        return arr\n    }\n    var max = [Int]()\n    var maxIndex = 0\n\
    \    for i in 0..<k {\n        if arr[i] > max[k-1] {\n            maxIndex =\
    \ k-1\n            max = [Int]()\n        }\n        if arr[i] > max[k] {\n  \
    \          max[k-1] = arr[i]\n        }\n        if arr[i] > max[maxIndex] {\n\
    \            maxIndex = k\n        }\n    }\n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002abe57a92c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abe57789561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002abe57789286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002abe5778913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002abe57788bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002abe57588e83 <unavailable> + 188035

    6    tmpybqe3a4y                        0x00005602399ae6d8 <unavailable> + 9944

    7    tmpybqe3a4y                        0x00005602399ad609 <unavailable> + 5641

    8    libc.so.6                          0x00002abe57c7e460 __libc_start_main +
    245

    9    tmpybqe3a4y                        0x00005602399ad2e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1659824591
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    // write\
    \ your code here\n    \n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4,\
    \ -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\
    \ == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20,\
    \ 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpnr56wemo/tmpnr56wemo.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b48eae22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48eab19b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b48eab19988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b48eab187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnr56wemo                        0x00005580aee853c9 <unavailable> + 5065

    5    libc.so.6                          0x00002b48eb00e460 __libc_start_main +
    245

    6    tmpnr56wemo                        0x00005580aee84fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659824589
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    precondition(k\
    \ <= arr.count, \"k should be less than or equal to arr.count\")\n    var max\
    \ = [Int](repeating: -1000, count: k)\n    for x in arr {\n        if x > max[k-1]\
    \ {\n            max[k-1] = x\n        }\n    }\n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'tmpb4nrrucp/tmpb4nrrucp.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaf8c3b1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaf8c0a8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaf8c0a8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaf8c0a77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb4nrrucp                        0x000055f789c24729 <unavailable> + 5929

    5    libc.so.6                          0x00002aaf8c59d460 __libc_start_main +
    245

    6    tmpb4nrrucp                        0x000055f789c24329 <unavailable> + 4905

    '
  stdout: ''
  timestamp: 1659824591
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    var max = [Int]()\n\
    \    for x in arr {\n        if x > max[0] {\n            max[0] = x\n       \
    \ }\n    }\n    for x in arr {\n        if x > max[1] {\n            max[1] =\
    \ x\n        }\n    }\n    for x in arr {\n        if x > max[k] {\n         \
    \   max[k] = x\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ab7233cbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab7230c2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ab7230c2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ab7230c213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ab7230c1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ab722ec1e83 <unavailable> + 188035

    6    tmp5rl9wo6z                        0x00005634e074d557 <unavailable> + 9559

    7    tmp5rl9wo6z                        0x00005634e074c559 <unavailable> + 5465

    8    libc.so.6                          0x00002ab7235b7460 __libc_start_main +
    245

    9    tmp5rl9wo6z                        0x00005634e074c239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824591
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    var result = arr\n\
    \    if k > result.count {\n        return result\n    }\n    if k == 0 {\n  \
    \      return result\n    }\n    if k == 1 {\n        return result.sorted()\n\
    \    }\n    \n    var maxIndex = result.count - 1\n    var maxValue = result[0]\n\
    \    \n    for i in 1..k {\n        if result[i] > maxValue {\n            maxValue\
    \ = result[i]\n            maxIndex = i\n        }\n    }\n    \n    result.remove(at:\
    \ maxIndex)\n    result.append(maxValue)\n    \n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp3dpil3xz.swift:32:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..k {\n              ^~\n              ...\n"
  stdout: ''
  timestamp: 1659824591
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    return arr.reduce([],\
    \ { (res, cur) -> [Int] in\n        if res.count < k {\n            res.append(cur)\n\
    \        } else if res.count == k {\n            if cur > res[0] {\n         \
    \       res[0] = cur\n            }\n        }\n        return res\n    })\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpzmzdre1m.swift:20:17: error: cannot use mutating member on immutable\
    \ value: 'res' is a 'let' constant\n            res.append(cur)\n            ~~~\
    \ ^\n"
  stdout: ''
  timestamp: 1659824591
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || arr.isEmpty()\
    \ {\n        return arr\n    }\n    var result = Array(repeating: 0, count: k)\n\
    \    var max = 0\n    var maxIndex = 0\n    for index in 0..<arr.count {\n   \
    \     if arr[index] > max {\n            max = arr[index]\n            maxIndex\
    \ = index\n        }\n    }\n    result[maxIndex] = max\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\n\
    assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2,\
    \ 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2,\
    \ -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k:\
    \ 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) ==\
    \ [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
    \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpdm1pyot6.swift:18:22: error: cannot call value of non-function\
    \ type 'Bool'\n    if k == 0 || arr.isEmpty() {\n                     ^      ~~\n\
    \                            \n"
  stdout: ''
  timestamp: 1659824591
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    return arr.sorted\
    \ { $0 > $1 }.prefix(k)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpgkcsuxmh.swift:18:35: error: cannot convert return expression of\
    \ type 'ArraySlice<Int>' to return type '[Int]'\n    return arr.sorted { $0 >\
    \ $1 }.prefix(k)\n           ~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824589
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    \n    // write\
    \ your code here\n    var max = [Int]()\n    \n    for element in arr {\n    \
    \    if max < element {\n            max = element\n        }\n    }\n    \n \
    \   for element in arr {\n        if element > max[k] {\n            max[k] =\
    \ element\n        }\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpuq4p8vso.swift:23:12: error: cannot convert value of type '[Int]'\
    \ to expected argument type 'Int'\n        if max < element {\n           ^\n\
    /tmp/tmpuq4p8vso.swift:24:19: error: cannot assign value of type 'Int' to type\
    \ '[Int]'\n            max = element\n                  ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824591
- exit_code: -4
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || arr\
    \ == nil || arr.isEmpty {\n        return arr\n    }\n    \n    var max = [Int]()\n\
    \    var maxIndex = 0\n    \n    for i in 0..<k {\n        if arr[i] > max[k-1]\
    \ {\n            maxIndex = k-1\n            max = [Int](repeating: arr[i], count:\
    \ k-1)\n        } else if arr[i] > max[k] {\n            maxIndex = k\n      \
    \      max = [Int](repeating: arr[i], count: k)\n        }\n    }\n    \n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(maximum(arr: [-3, -4, 5],\
    \ k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr:\
    \ [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20,\
    \ 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2,\
    \ -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0],\
    \ k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10],\
    \ k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
    \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
    assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b6959704c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b69593fb561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b69593fb286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b69593fb13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b69593fabb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b69591fae83 <unavailable> + 188035

    6    tmprvgeyk54                        0x0000563510d93791 <unavailable> + 10129

    7    tmprvgeyk54                        0x0000563510d92619 <unavailable> + 5657

    8    libc.so.6                          0x00002b69598f0460 __libc_start_main +
    245

    9    tmprvgeyk54                        0x0000563510d922f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1659824591
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || arr.isEmpty()\
    \ {\n        return arr\n    }\n    var max = [Int]()\n    var maxIndex = -1\n\
    \    for index in 0..<arr.count {\n        if arr[index] > max[maxIndex] {\n \
    \           maxIndex = index\n            max = [arr[index]]\n        } else if\
    \ arr[index] == max[maxIndex] {\n            max.append(arr[index])\n        }\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr:\
    \ [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) ==\
    \ [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr:\
    \ [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123,\
    \ 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3,\
    \ -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0,\
    \ 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) ==\
    \ [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10,\
    \ 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0],\
    \ k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpsdwqgr2f.swift:18:22: error: cannot call value of non-function\
    \ type 'Bool'\n    if k == 0 || arr.isEmpty() {\n                     ^      ~~\n\
    \                            \n"
  stdout: ''
  timestamp: 1659824591
- exit_code: 1
  program: "\n/// Given an array arr of integers and a positive integer k, return\
    \ a sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 || k\
    \ > arr.count {\n        return arr\n    }\n    var max = [Int]()\n    var maxIndex\
    \ = 0\n    for index in 0..<arr.count {\n        if arr[index] > max[maxIndex]\
    \ {\n            max[maxIndex] = arr[index]\n            maxIndex = index\n  \
    \      }\n    }\n    return max[0 ..< k - 1]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr:\
    \ [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1],\
    \ k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2,\
    \ 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\n\
    assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5,\
    \ 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr:\
    \ [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\n\
    assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2,\
    \ 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmptkb1t_a7.swift:29:15: error: no 'subscript' candidates produce\
    \ the expected contextual result type '[Int]'\n    return max[0 ..< k - 1]\n \
    \             ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824591
