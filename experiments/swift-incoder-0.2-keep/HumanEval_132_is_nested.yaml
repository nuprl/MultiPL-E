name: HumanEval_132_is_nested
language: swift
prompt: "\n/// Create a function that takes a string as input which contains only\
  \ square brackets.\n/// The function should return True if and only if there is\
  \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
  \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
  \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E False\n\
  /// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\nfunc is_nested(string:\
  \ String) -> Bool {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
  \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
  assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
  ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
  \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
  \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
  \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
  \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
completions: ["    var stack = [String]()\n    var openBrackets = 0\n    var closeBrackets\
    \ = 0\n    for symbol in string {\n        switch symbol {\n        case \"[\"\
    : openBrackets += 1\n        case \"[\": closeBrackets += 1\n        case \"(\"\
    : openBrackets += 1\n        case \")\": closeBrackets += 1\n        default:\
    \ break\n        }\n        stack.append(symbol)\n    }\n    if openBrackets ==\
    \ closeBrackets {\n        return true\n    }\n    return false", "    let stack\
    \ = Stack()\n    for char in string {\n        if char == '[' {\n            stack.push(char)\n\
    \        } else if char == ']' {\n            if stack.count > 0 {\n         \
    \       if stack.peek() == '[' {\n                    stack.pop()\n          \
    \      } else {\n                    return false\n                }\n       \
    \     } else {\n                return false\n            }\n        }\n    }\n\
    \    return stack.count == 0", "    var stack = [String]()\n    var openingBrackets\
    \ = 0\n    for char in string {\n        if char == '[' {\n            openingBrackets\
    \ += 1\n        } else if char == ']' {\n            openingBrackets -= 1\n  \
    \      } else if char == '[' && openingBrackets == 0 {\n            stack.append(char)\n\
    \        } else if char == ']' && openingBrackets > 0 {\n            if stack[stack.count\
    \ - 1] == '[' {\n                stack.removeLast()\n            } else {\n  \
    \              return false\n            }\n        }\n    }\n    return openingBrackets\
    \ == 0", "    guard let openBracket = string.rangeOfString(\"[\", options: .LiteralSearch,\
    \ range: nil, locale: nil) else {\n        return false\n    }\n    guard let\
    \ closeBracket = string.rangeOfString(\"]\", options: .LiteralSearch, range: nil,\
    \ locale: nil) else {\n        return false\n    }\n    guard openBracket.location\
    \ != closeBracket.location else {\n        return false\n    }\n    guard openBracket.location\
    \ != string.endIndex else {\n        return false\n    }\n    guard closeBracket.location\
    \ != string.startIndex else {\n        return false\n    }\n    guard openBracket.location\
    \ != string.startIndex else {\n        return false\n    }\n    guard closeBracket.location\
    \ != string.endIndex else {\n        return false\n    }\n    guard openBracket.location\
    \ != string.endIndex else {\n        return false\n    }\n    return true", " \
    \   let stack = Stack()\n    for char in string {\n        if char == '[' {\n\
    \            stack.push(char)\n        } else if char == ']' {\n            if\
    \ stack.top() == '[' {\n                stack.pop()\n            } else {\n  \
    \              return false\n            }\n        } else {\n            return\
    \ false\n        }\n    }\n    return stack.empty()", "    \n    let stack = Stack()\n\
    \    \n    for character in string {\n        \n        if character == '[' {\n\
    \            stack.push(character)\n        }\n        \n        if character\
    \ == ']' {\n            \n            if stack.count > 0 {\n                \n\
    \                if stack.peek() == '[' {\n                    stack.pop()\n \
    \               } else {\n                    return false\n                }\n\
    \            }\n        }\n    }\n    \n    return stack.count == 0", "    \n\
    \    let brackets = string.replacingOccurrences(of: \"[\", with: \"\").replacingOccurrences(of:\
    \ \"]\", with: \"\")\n    \n    if brackets.count < 2 {\n        return false\n\
    \    }\n    \n    let openingBrackets = brackets.replacingOccurrences(of: \"[\"\
    , with: \"\").replacingOccurrences(of: \"]\", with: \"\")\n    \n    if openingBrackets.count\
    \ < 2 {\n        return false\n    }\n    \n    let closingBrackets = brackets.replacingOccurrences(of:\
    \ \"[\", with: \"\").replacingOccurrences(of: \"]\", with: \"\")\n    \n    if\
    \ closingBrackets.count < 2 {\n        return false\n    }\n    \n    let openingBracketsCount\
    \ = openingBrackets.count\n    let closingBracketsCount = closingBrackets.count\n\
    \    \n    if openingBracketsCount != closingBracketsCount {\n        return false\n\
    \    }\n    \n    let openingBracketsArray = openingBrackets.characters\n    let\
    \ closingBracketsArray = closingBrackets.characters\n    \n    let openingBracketsArrayCount\
    \ = openingBracketsArray.count\n    let closingBracketsArrayCount = closingBracketsArray.count\n\
    \    \n    if openingBracketsArrayCount != closingBracketsArrayCount {\n     \
    \   return false\n    }\n    \n    let openingBracketsArrayIndex = 0\n    let\
    \ closingBracketsArrayIndex = 0\n    \n    while openingBracketsArrayIndex < openingBracketsArrayCount\
    \ && closingBracketsArrayIndex < closingBracketsArrayCount {\n        \n     \
    \   let openingBracket = openingBracketsArray[openingBracketsArrayIndex]\n   \
    \     let closingBracket = closingBracketsArray[closingBracketsArrayIndex]\n \
    \       \n        if openingBracket != closingBracket {\n            return false\n\
    \        }\n        \n        openingBracketsArrayIndex += 1\n        closingBracketsArrayIndex\
    \ += 1\n    }\n    \n    return true", "    var stack = [String]()\n    var open\
    \ = 0\n    var close = 0\n    for i := 0; i < len(string); i++ {\n        if string[i]\
    \ == '[' {\n            open++\n            stack.append(string[i])\n        }\
    \ else if string[i] == ']' {\n            close++\n            if open > close\
    \ {\n                return false\n            }\n            open--\n       \
    \ }\n    }\n    return open > close", "    let brackets = string.unicodeScalars\n\
    \        .filter { $0 != brackets.first }\n        .map { $0 }\n        .filter\
    \ { $0 != brackets.last }\n        .map { $0 }\n        .filter { $0 != brackets.first\
    \ }\n        .map { $0 }\n        .filter { $0 != brackets.last }\n        .map\
    \ { $0 }\n        .filter { $0 != brackets.first }\n        .map { $0 }\n    \
    \    .filter { $0 != brackets.last }\n        .map { $0 }\n        .filter { $0\
    \ != brackets.first }\n        .map { $0 }\n        .filter { $0 != brackets.last\
    \ }\n        .map { $0 }\n        .filter { $0 != brackets.first }\n        .map\
    \ { $0 }\n        .filter { $0 != brackets.last }\n        .map { $0 }\n     \
    \   .filter { $0 != brackets.first }\n        .map { $0 }\n        .filter { $0\
    \ != brackets.last }\n        .map { $0 }\n        .filter { $0 != brackets.first\
    \ }\n        .map { $0 }\n        .filter { $0 != brackets.last }\n        .map\
    \ { $0 }\n        .filter { $0 != brackets.first }\n        .map { $0 }\n    \
    \    .filter { $0 != brackets.last }\n        .map { $0 }\n        .filter { $0\
    \ != brackets.first }\n        .map { $0 }\n        .filter { $0 != brackets.last\
    \ }\n        .map { $0 }\n        .filter { $0 != brackets.first }\n        .map\
    \ { $0 }\n        .filter { $0 != brackets.last }\n        .map { $0 }\n     \
    \   .filter { $0 != brackets.first }\n        .map { $0 }\n        .filter { $0\
    \ != brackets.last }\n        .map { $0 }\n        .filter { $0 != brackets.first\
    \ }\n        .map { $0 }\n        .filter { $0 != brackets.last }\n        .map\
    \ { $0 }\n        .filter { $0 != brackets.first }\n        .map { $0 }\n    \
    \    .filter { $0 != brackets.last }\n        .map { $0 }\n        .filter { $0\
    \ != brackets.first }\n        .map { $0 }\n        .filter { $0 != brackets.last\
    \ }\n        .map { $0 }\n", "    guard let open = string.range(of: \"[\"),\n\
    \        let close = string.range(of: \"]\"),\n        open != nil && close !=\
    \ nil else {\n        return false\n    }\n    \n    let openCount = string.distance(from:\
    \ open.upperBound, to: open.lowerBound)\n    let closeCount = string.distance(from:\
    \ close.upperBound, to: close.lowerBound)\n    \n    return openCount == closeCount",
  "    \n    // Your code here\n    \n    return true", "    let openingBrackets =\
    \ string.unicodeScalars.filter({ $0.isOpen })\n    let closingBrackets = string.unicodeScalars.filter({\
    \ $0.isClosing })\n    \n    if openingBrackets.count != closingBrackets.count\
    \ {\n        return false\n    }\n    \n    let openingBracketsCount = openingBrackets.count\n\
    \    let closingBracketsCount = closingBrackets.count\n    \n    if openingBracketsCount\
    \ == 0 {\n        return true\n    }\n    \n    if openingBracketsCount == 1 {\n\
    \        return closingBrackets.first!.isNested == openingBrackets.first!.isNested\n\
    \    }\n    \n    let openingBracketsIndex = openingBrackets.first!.index\n  \
    \  let closingBracketsIndex = closingBrackets.first!.index\n    \n    let openingBracketsString\
    \ = string.substring(from: openingBracketsIndex)\n    let closingBracketsString\
    \ = string.substring(from: closingBracketsIndex)\n    \n    let openingBracketsStringCount\
    \ = openingBracketsString.unicodeScalars.filter({ $0.isOpen }).count\n    let\
    \ closingBracketsStringCount = closingBracketsString.unicodeScalars.filter({ $0.isClosing\
    \ }).count\n    \n    if openingBracketsStringCount != closingBracketsStringCount\
    \ {\n        return false\n    }\n    \n    let openingBracketsStringIndex = openingBracketsString.unicodeScalars.filter({\
    \ $0.isOpen }).first!.index\n    let closingBracketsStringIndex = closingBracketsString.unicodeScalars.filter({\
    \ $0.isClosing }).first!.index\n    \n    let openingBracketsStringCount = openingBracketsString.unicodeScalars.filter({\
    \ $0.isOpen }).count\n    let closingBracketsStringCount = closingBracketsString.unicodeScalars.filter({\
    \ $0.isClosing }).count\n    \n    if openingBracketsStringCount != closingBracketsStringCount\
    \ {\n        return false\n    }\n    \n    let openingBracketsStringIndex = openingBracketsString.unicodeScalars.filter({\
    \ $0.isOpen }).first!.index\n    let closingBracketsStringIndex = closingBracketsString.unicodeScalars.filter({\
    \ $0.isClosing }).first!.index\n    \n    let openingBracketsStringCount = openingBracketsString.unicodeScalars.filter({\
    \ $0.isOpen }).count\n    let closingBracket", "    guard let start = string.index(of:\
    \ \"[\"), let end = string.index(of: \"]\") else {\n        return false\n   \
    \ }\n    \n    var stack = [String]()\n    stack.append(string[start..<end])\n\
    \    \n    for _ in 0..<string.count {\n        guard let start = string.index(of:\
    \ \"[\"), let end = string.index(of: \"]\") else {\n            return false\n\
    \        }\n        \n        if start < end {\n            stack.append(string[start..<end])\n\
    \        }\n    }\n    \n    return stack.count > 1", "    var stack = [String]()\n\
    \    var opening = false\n    for char in string {\n        if char == '[' {\n\
    \            stack.append(char)\n            opening = true\n        } else if\
    \ char == ']' {\n            if opening {\n                opening = false\n \
    \           } else {\n                return false\n            }\n        } else\
    \ {\n            if opening {\n                stack.removeLast()\n          \
    \  }\n        }\n    }\n    return stack.count == 0", "    let stack = Stack()\n\
    \    for character in string {\n        if character == '[' {\n            stack.push(character)\n\
    \        } else if character == ']' {\n            if stack.top() == '[' {\n \
    \               stack.pop()\n            } else {\n                return false\n\
    \            }\n        } else {\n            return false\n        }\n    }\n\
    \    return stack.empty()", "    \n    // Initialize a stack to store brackets\n\
    \    var stack = [String]()\n    \n    // Initialize a counter to keep track of\
    \ how many brackets are in the string\n    var count = 0\n    \n    // Iterate\
    \ through the string and add each character to the stack\n    for char in string\
    \ {\n        \n        // If the character is a bracket, add it to the stack\n\
    \        if char == \"[\" || char == \"]\" {\n            stack.append(char)\n\
    \            count += 1\n            \n        // If the character is a closing\
    \ bracket, pop the stack\n        } else if char == \"]\" {\n            \n  \
    \          // If the stack is empty, return False\n            if stack.count\
    \ == 0 {\n                return false\n            }\n            \n        \
    \    // Pop the last element from the stack\n            stack.removeLast()\n\
    \            \n            // If the stack is empty, return False\n          \
    \  if stack.count == 0 {\n                return false\n            }\n      \
    \      \n            // Increment the counter\n            count += 1\n      \
    \  }\n    }\n    \n    // If the stack is empty, return False\n    if stack.count\
    \ == 0 {\n        return false\n    }\n    \n    // If the stack is not empty,\
    \ return True\n    return true", "\tlet openBracketsCount = string.count(\"[\"\
    )\n\tlet closeBracketsCount = string.count(\"]\")\n\t\n\tif openBracketsCount\
    \ != closeBracketsCount {\n\t\treturn false\n\t}\n\t\n\tlet openBracketsIndex\
    \ = 0\n\tlet closeBracketsIndex = 0\n\t\n\twhile openBracketsIndex < openBracketsCount\
    \ {\n\t\tlet openBracket = string[openBracketsIndex]\n\t\t\n\t\tif openBracket\
    \ == \"[\" {\n\t\t\topenBracketsIndex += 1\n\t\t} else if openBracket == \"]\"\
    \ {\n\t\t\tcloseBracketsIndex += 1\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t\
    }\n\t\n\treturn true", "    let stack = Stack()\n    for char in string {\n  \
    \      if char == '[' {\n            stack.push(char)\n        } else if char\
    \ == ']' {\n            if stack.top() == '[' {\n                stack.pop()\n\
    \            } else {\n                return false\n            }\n        }\
    \ else {\n            return false\n        }\n    }\n    return stack.empty()",
  "\tlet stack = Stack()\n\tlet openBrackets = Set<Character>()\n\tlet closeBrackets\
    \ = Set<Character>()\n\tlet openBracketsCount = 1\n\tlet closeBracketsCount =\
    \ 1\n\t\n\tfor char in string.characters {\n\t\tif char == '[' {\n\t\t\topenBrackets.insert(char)\n\
    \t\t\topenBracketsCount += 1\n\t\t} else if char == ']' {\n\t\t\tcloseBrackets.insert(char)\n\
    \t\t\tcloseBracketsCount += 1\n\t\t} else if char == '{' {\n\t\t\topenBracketsCount\
    \ += 1\n\t\t} else if char == '}' {\n\t\t\tcloseBracketsCount += 1\n\t\t}\n\t\t\
    \n\t\tif openBracketsCount == closeBracketsCount {\n\t\t\tstack.push(char)\n\t\
    \t}\n\t}\n\t\n\treturn stack.count == 0", "    guard let range = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil) else {\n        return\
    \ false\n    }\n    guard let start = range.lowerBound else {\n        return\
    \ false\n    }\n    guard let end = string.rangeOfString(\"]\", options: .LiteralSearch,\
    \ range: nil, locale: nil)?.upperBound else {\n        return false\n    }\n \
    \   return start < end", "    guard let start = string.index(of: \"[\"),\n   \
    \     let end = string.index(of: \"]\"),\n        start != end,\n        let start\
    \ = string.index(of: \"[\", range: start..<end),\n        let end = string.index(of:\
    \ \"]\", range: start..<end),\n        start != end,\n        let start = string.index(of:\
    \ \"[\", range: start..<end),\n        let end = string.index(of: \"]\", range:\
    \ start..<end),\n        start != end,\n        let start = string.index(of: \"\
    [\", range: start..<end),\n        let end = string.index(of: \"]\", range: start..<end),\n\
    \        start != end,\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        start\
    \ != end,\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        start\
    \ != end,\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        start\
    \ != end,\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        start\
    \ != end,\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        start\
    \ != end,\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        start\
    \ != end,\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        start\
    \ != end,\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        start\
    \ != end,\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        start\
    \ != end,\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<", "    guard let openBracket\
    \ = string.rangeOfString(\"[\", options: .BackwardsSearch) else { return false\
    \ }\n    guard let closeBracket = string.rangeOfString(\"]\", options: .BackwardsSearch)\
    \ else { return false }\n    return openBracket.location != closeBracket.location",
  "    \n    var stack = [String]()\n    var open = 0\n    var close = 0\n    \n \
    \   for _ in string.unicodeScalars {\n        if let c = string.unicodeScalars.next()\
    \ {\n            switch c {\n            case .OpenSquareBracket:\n          \
    \      open++\n            case .CloseSquareBracket:\n                close++\n\
    \            case .OpenParenthesis:\n                stack.append(c)\n       \
    \     case .CloseParenthesis:\n                open--\n                if open\
    \ < 0 {\n                    return false\n                }\n               \
    \ close--\n            }\n        }\n    }\n    \n    return open >= 0 && close\
    \ >= 0", "\tlet stack = Array<String>()\n\tlet openingBrackets = Array<String>()\n\
    \tlet closingBrackets = Array<String>()\n\tlet openingBracketIndex = -1\n\tlet\
    \ closingBracketIndex = -1\n\t\n\tlet openingBracketCount = 1\n\tlet closingBracketCount\
    \ = 1\n\t\n\tlet openingBracket = string[openingBracketIndex]\n\tlet closingBracket\
    \ = string[closingBracketIndex]\n\t\n\twhile openingBracket != \"\" {\n\t\t\n\t\
    \tif openingBracket == \"[\" {\n\t\t\topeningBracketCount += 1\n\t\t\topeningBracketIndex\
    \ = string.index(openingBracket, offsetBy: 1)\n\t\t\topeningBracket = string[openingBracketIndex]\n\
    \t\t}\n\t\t\n\t\tif openingBracket == \"]\" {\n\t\t\topeningBracketCount -= 1\n\
    \t\t\topeningBracketIndex = string.index(openingBracket, offsetBy: 1)\n\t\t\t\
    openingBracket = string[openingBracketIndex]\n\t\t}\n\t\t\n\t\tif openingBracketCount\
    \ < 0 {\n\t\t\topeningBracketIndex = string.index(openingBracket, offsetBy: 1)\n\
    \t\t\topeningBracket = string[openingBracketIndex]\n\t\t\topeningBracketCount\
    \ = 1\n\t\t}\n\t\t\n\t\tif closingBracket == \"[\" {\n\t\t\tclosingBracketCount\
    \ += 1\n\t\t\tclosingBracketIndex = string.index(closingBracket, offsetBy: 1)\n\
    \t\t\tclosingBracket = string[closingBracketIndex]\n\t\t}\n\t\t\n\t\tif closingBracket\
    \ == \"]\" {\n\t\t\tclosingBracketCount -= 1\n\t\t\tclosingBracketIndex = string.index(closingBracket,\
    \ offsetBy: 1)\n\t\t\tclosingBracket = string[closingBracketIndex]\n\t\t}\n\t\t\
    \n\t\tif closingBracketCount < 0 {\n\t\t\tclosingBracketIndex = string.index(closingBracket,\
    \ offsetBy: 1)\n\t\t\tclosingBracket = string[closingBracketIndex]\n\t\t\tclosingBracketCount\
    \ = 1\n\t\t}\n\t\t\n\t\tif openingBracketCount > 0 && closingBracketCount == 0\
    \ {\n\t\t\tstack.append(openingBracket)\n\t\t}\n\t\t\n\t\tif closingBracketCount\
    \ > 0 && openingBracketCount == 0 {\n\t\t\tstack.append(closingBracket)\n\t\t\
    }\n\t\t\n\t\tif openingBracketCount > 0 && closingBracketCount > 0 {\n\t\t\topeningBracketIndex\
    \ = string.index(openingBracket, offsetBy: 1)\n\t\t\tclosingBracketIndex = string.index(closing",
  "    guard let start = string.index(of: \"[\"),\n        let end = string.index(of:\
    \ \"]\"),\n        start != end,\n        start < string.endIndex,\n        end\
    \ < string.endIndex,\n        start < end else { return false }\n    let startIndex\
    \ = string.index(before: start)\n    let endIndex = string.index(before: end)\n\
    \    let subsequence = string[startIndex..<endIndex]\n    return subsequence.contains(\"\
    [\")", "\tlet brackets = string.replacingOccurrences(of: \"[\", with: \"\").replacingOccurrences(of:\
    \ \"]\", with: \"\")\n\tlet openBrackets = brackets.replacingOccurrences(of: \"\
    (\", with: \"\").replacingOccurrences(of: \")\", with: \"\")\n\tlet closeBrackets\
    \ = brackets.replacingOccurrences(of: \"{\", with: \"\").replacingOccurrences(of:\
    \ \"}\", with: \"\")\n\tlet openBracketsCount = openBrackets.characters.count\n\
    \tlet closeBracketsCount = closeBrackets.characters.count\n\tlet openBracketsCount\
    \ = openBracketsCount + closeBracketsCount - 1\n\tlet closeBracketsCount = openBracketsCount\
    \ + closeBracketsCount - 1\n\treturn openBracketsCount % 2 == 0 && closeBracketsCount\
    \ % 2 == 0", "    guard let open = string.range(of: \"[\"),\n        let close\
    \ = string.range(of: \"]\"),\n        let open2 = string.range(of: \"[\", options:\
    \ .backwards),\n        let close2 = string.range(of: \"]\", options: .backwards)\
    \ else { return false }\n    return open != nil && close != nil && open2 != nil\
    \ && close2 != nil && open2.lowerBound < close2.lowerBound", "    guard let start\
    \ = string.index(of: \"[\"),\n        let end = string.index(of: \"]\"),\n   \
    \     let start = string.index(of: \"[\", range: start..<end),\n        let end\
    \ = string.index(of: \"]\", range: start..<end),\n        let start = string.index(of:\
    \ \"[\", range: start..<end),\n        let end = string.index(of: \"]\", range:\
    \ start..<end),\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        let start\
    \ = string.index(of: \"[\", range: start..<end),\n        let end = string.index(of:\
    \ \"]\", range: start..<end),\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n        let end = string.index(of: \"]\", range: start..<end),\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        let start = string.index(of:\
    \ \"[\", range: start..<end),\n        let end = string.index(of: \"]\", range:\
    \ start..<end),\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        let start\
    \ = string.index(of: \"[\", range: start..<end),\n        let end = string.index(of:\
    \ \"]\", range: start..<end),\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n        let end = string.index(of: \"]\", range: start..<end),\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        let start = string.index(of:\
    \ \"[\", range: start..<end),\n        let end = string.index(of: \"]\", range:\
    \ start..<end),\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        let start\
    \ = string.index(of: \"[\", range: start..<end),\n        let end = string.index(of:\
    \ \"]\", range: start..<end),\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n        let end = string.index(of: \"]\", range: start..<end),\n\
    \        let start = string.index(of: \"[\", range: start.", "    guard let index\
    \ = string.index(of: \"[\"),\n        let end = string.index(of: \"]\", from:\
    \ index) else {\n        return false\n    }\n    guard let start = string.index(of:\
    \ \"[\", from: index),\n        let end = string.index(of: \"]\", from: end) else\
    \ {\n        return false\n    }\n    return string.distance(from: index, to:\
    \ end) == 1 &&\n        string.distance(from: start, to: end) == 1 &&\n      \
    \  string.distance(from: start, to: index) == 1 &&\n        string.distance(from:\
    \ end, to: index) == 1", "    let brackets = string.unicodeScalars.filter({ $0.isBr\
    \ })\n    guard brackets.count > 0 else { return false }\n    let openBrackets\
    \ = brackets.filter({ $0.isBr })\n    guard openBrackets.count > 0 else { return\
    \ false }\n    let closeBrackets = brackets.filter({ !$0.isBr })\n    guard closeBrackets.count\
    \ > 0 else { return false }\n    let openBracketsCount = openBrackets.count\n\
    \    let closeBracketsCount = closeBrackets.count\n    let openBracketsNesting\
    \ = (openBracketsCount - closeBracketsCount) > 0\n    let closeBracketsNesting\
    \ = (openBracketsCount - closeBracketsCount) < 0\n    return openBracketsNesting\
    \ && closeBracketsNesting", "    guard let openBracket = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil) else {\n        return\
    \ false\n    }\n    guard let closeBracket = string.rangeOfString(\"]\", options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n        return false\n    }\n\
    \    guard openBracket.location != closeBracket.location else {\n        return\
    \ false\n    }\n    guard openBracket.location != string.endIndex else {\n   \
    \     return false\n    }\n    guard closeBracket.location != string.startIndex\
    \ else {\n        return false\n    }\n    guard openBracket.location < closeBracket.location\
    \ else {\n        return false\n    }\n    guard openBracket.location <= closeBracket.location\
    \ else {\n        return false\n    }\n    guard openBracket.location + 1 < closeBracket.location\
    \ else {\n        return false\n    }\n    guard openBracket.location + 1 == closeBracket.location\
    \ + 1 else {\n        return false\n    }\n    guard openBracket.location + 2\
    \ < closeBracket.location else {\n        return false\n    }\n    guard openBracket.location\
    \ + 2 == closeBracket.location + 2 else {\n        return false\n    }\n    guard\
    \ openBracket.location + 3 < closeBracket.location else {\n        return false\n\
    \    }\n    guard openBracket.location + 3 == closeBracket.location + 3 else {\n\
    \        return false\n    }\n    guard openBracket.location + 4 < closeBracket.location\
    \ else {\n        return false\n    }\n    guard openBracket.location + 4 == closeBracket.location\
    \ + 4 else {\n        return false\n    }\n    guard openBracket.location + 5\
    \ < closeBracket.location else {\n        return false\n    }\n    guard openBracket.location\
    \ + 5 == closeBracket.location + 5 else {\n        return false\n    }\n    guard\
    \ openBracket.location + 6 < closeBracket.location else {\n        return false\n\
    \    }\n    guard openBracket.location + 6 == closeBracket.location + 6 else {\n\
    \        return false\n    }\n    guard openBracket.location + 7 < closeBracket.location\
    \ else {\n        return false\n    }\n    guard openBracket.location + 7 == closeBracket.location\
    \ + 7 else {\n        return false\n    }\n    guard openBracket.location + 8\
    \ < closeBra", "    guard let start = string.index(of: \"[\"),\n        let end\
    \ = string.index(of: \"]\"),\n        start < end else {\n            return false\n\
    \    }\n    \n    var stack = [String]()\n    stack.append(string[start..<end])\n\
    \    \n    while let top = stack.removeLast() {\n        if let next = stack.removeLast()\
    \ {\n            if next == \"[\" {\n                stack.append(next)\n    \
    \        } else if next == \"]\" {\n                if stack.isEmpty {\n     \
    \               return false\n                }\n                stack.append(next)\n\
    \            } else {\n                return false\n            }\n        }\
    \ else {\n            return false\n        }\n    }\n    \n    return stack.isEmpty",
  "\tlet openingBrackets = string.rangeOfString(\"[\")\n\tlet closingBrackets = string.rangeOfString(\"\
    ]\")\n\t\n\tif openingBrackets == nil || closingBrackets == nil {\n\t\treturn\
    \ false\n\t}\n\t\n\tlet openingBracketsCount = openingBrackets?.endIndex - openingBrackets?.startIndex\n\
    \tlet closingBracketsCount = closingBrackets?.endIndex - closingBrackets?.startIndex\n\
    \t\n\tif openingBracketsCount != closingBracketsCount {\n\t\treturn false\n\t\
    }\n\t\n\tlet openingBracketsString = string.substringWithRange(openingBrackets!)\n\
    \tlet closingBracketsString = string.substringWithRange(closingBrackets!)\n\t\n\
    \treturn openingBracketsString.rangeOfString(\"[\", options: .BackwardsSearch)\
    \ != nil", "    var stack = [String]()\n    var openBrackets = 0\n    var openBracketsCount\
    \ = 0\n    var openBracketsCountMax = 1000\n    var openBracketsCountMax2 = 1000\n\
    \    var openBracketsCountMax3 = 1000\n    var openBracketsCountMax4 = 1000\n\
    \    var openBracketsCountMax5 = 1000\n    var openBracketsCountMax6 = 1000\n\
    \    var openBracketsCountMax7 = 1000\n    var openBracketsCountMax8 = 1000\n\
    \    var openBracketsCountMax9 = 1000\n    var openBracketsCountMax10 = 1000\n\
    \    var openBracketsCountMax11 = 1000\n    var openBracketsCountMax12 = 1000\n\
    \    var openBracketsCountMax13 = 1000\n    var openBracketsCountMax14 = 1000\n\
    \    var openBracketsCountMax15 = 1000\n    var openBracketsCountMax16 = 1000\n\
    \    var openBracketsCountMax17 = 1000\n    var openBracketsCountMax18 = 1000\n\
    \    var openBracketsCountMax19 = 1000\n    var openBracketsCountMax20 = 1000\n\
    \    var openBracketsCountMax21 = 1000\n    var openBracketsCountMax22 = 1000\n\
    \    var openBracketsCountMax23 = 1000\n    var openBracketsCountMax24 = 1000\n\
    \    var openBracketsCountMax25 = 1000\n    var openBracketsCountMax26 = 1000\n\
    \    var openBracketsCountMax27 = 1000\n    var openBracketsCountMax28 = 1000\n\
    \    var openBracketsCountMax29 = 1000\n    var openBracketsCountMax30 = 1000\n\
    \    var openBracketsCountMax31 = 1000\n    var openBracketsCountMax32 = 1000\n\
    \    var openBracketsCountMax33 = 1000\n    var openBracketsCountMax34 = 1000\n\
    \    var openBracketsCountMax35 = 1000\n    var openBracketsCountMax36 = 1000\n\
    \    var openBracketsCountMax37 = 1000\n    var openBracketsCountMax38 = 1000\n\
    \    var openBracketsCountMax39 = 1000\n    var openBracketsCountMax40 = 1000\n\
    \    var openBracketsCountMax41 = 1000\n    var openBracketsCountMax42 = 1000\n\
    \    var openBracketsCountMax43 = 1000\n    var openBracketsCountMax44 = 1000\n\
    \    var openBracketsCountMax45 = 1000\n    var openBracketsCountMax4", "    let\
    \ stack = Stack()\n    for char in string {\n        if char == '[' {\n      \
    \      stack.push(char)\n        } else if char == ']' {\n            if stack.top()\
    \ == '[' {\n                stack.pop()\n            } else {\n              \
    \  return false\n            }\n        } else {\n            return false\n \
    \       }\n    }\n    return stack.empty()", "    var stack = [String]()\n   \
    \ var openBrackets = 0\n    for char in string {\n        if char == '[' {\n \
    \           stack.append(char)\n            openBrackets += 1\n        } else\
    \ if char == ']' {\n            if openBrackets > 0 {\n                openBrackets\
    \ -= 1\n            } else {\n                return false\n            }\n  \
    \      } else {\n            if openBrackets > 0 {\n                return false\n\
    \            }\n        }\n    }\n    return openBrackets == 0", "    guard let\
    \ open = string.rangeOfString(\"[\", options: .LiteralSearch, range: nil, locale:\
    \ nil),\n        let close = string.rangeOfString(\"]\", options: .LiteralSearch,\
    \ range: nil, locale: nil) else {\n            return false\n    }\n    let start\
    \ = open.location\n    let end = close.location\n    let range = start..<end\n\
    \    let nested = string.rangeOfString(\"[\", options: .LiteralSearch, range:\
    \ range, locale: nil)\n    return nested != nil", "    var stack = [String]()\n\
    \    var openingBrackets = 0\n    var closingBrackets = 0\n    for char in string\
    \ {\n        if char == '[' {\n            openingBrackets += 1\n            stack.append(char)\n\
    \        } else if char == ']' {\n            closingBrackets += 1\n         \
    \   if closingBrackets > openingBrackets {\n                stack.removeLast()\n\
    \            }\n        } else if char == '[' {\n            openingBrackets +=\
    \ 1\n        } else if char == ']' {\n            closingBrackets += 1\n     \
    \   }\n    }\n    return openingBrackets == closingBrackets", "    let brackets\
    \ = string.unicodeScalars\n        .filter({$0.isASCII})\n        .filter({$0.isNotASCII})\n\
    \        .filter({$0.isIn(\"[]\")})\n        .filter({$0.isNotIn(\"[]\")})\n \
    \       .filter({$0.isIn(\"()\")})\n        .filter({$0.isNotIn(\"()\")})\n  \
    \      .filter({$0.isIn(\"{}\")})\n        .filter({$0.isNotIn(\"{}\")})\n   \
    \     .filter({$0.isIn(\"<>\")})\n        .filter({$0.isNotIn(\"<>\")})\n    \
    \    .filter({$0.isIn(\"()<>\")})\n        .filter({$0.isNotIn(\"()<>\")})\n \
    \       .filter({$0.isIn(\"{}<>\")})\n        .filter({$0.isNotIn(\"{}<>\")})\n\
    \        .filter({$0.isIn(\"[]<>\")})\n        .filter({$0.isNotIn(\"[]<>\")})\n\
    \        .filter({$0.isIn(\"()[]<>\")})\n        .filter({$0.isNotIn(\"()[]<>\"\
    )})\n        .filter({$0.isIn(\"{}[]<>\")})\n        .filter({$0.isNotIn(\"{}[]<>\"\
    )})\n        .filter({$0.isIn(\"<>[]\")})\n        .filter({$0.isNotIn(\"<>[]\"\
    )})\n        .filter({$0.isIn(\"()<>[]\")})\n        .filter({$0.isNotIn(\"()<>[]\"\
    )})\n        .filter({$0.isIn(\"{}<>[]\")})\n        .filter({$0.isNotIn(\"{}<>[]\"\
    )})\n        .filter({$0.isIn(\"[][]<>\")})\n        .filter({$0.isNotIn(\"[][]<>\"\
    )})\n        .filter({$0.isIn(\"()[][]<>\")})\n        .filter({$0.isNotIn(\"\
    ()[][]<>\")})\n        .filter({$0.isIn(\"{}[][]<>\")})\n        .filter({$0.isNotIn(\"\
    {}[][]<>\")})\n        .filter({$0.isIn(\"<>{}\")})\n        .filter({$0.isNotIn(\"\
    <>{}\")})\n        .filter({$0.isIn(\"()<>{}\")})\n        .filter({$0.isNotIn(\"\
    ()<>{}\")})\n        .filter({$0.isIn(\"{}<>{}\")})\n", "    \n    // Your code\
    \ here\n    \n    return true", "    \n    // Your code here\n    \n    return\
    \ true", "    guard let start = string.index(of: \"[\"),\n        let end = string.index(of:\
    \ \"]\", in: start) else {\n            return false\n    }\n    guard let nested\
    \ = string.substring(from: start + 1, to: end) else {\n        return false\n\
    \    }\n    guard let nested2 = string.substring(from: start + 1, to: nested)\
    \ else {\n        return false\n    }\n    return is_nested(nested2)", "    var\
    \ stack = [String]()\n    var opening = false\n    for char in string {\n    \
    \    if char == '[' {\n            opening = true\n        } else if char == ']'\
    \ {\n            opening = false\n        } else if opening {\n            stack.append(char)\n\
    \        }\n    }\n    return stack.count == 0", "    var stack = [String]()\n\
    \    var openingBrackets = 0\n    for index in 0..<string.characters.count {\n\
    \        let character = string.characters[index]\n        if character == '['\
    \ {\n            stack.append(character)\n            openingBrackets += 1\n \
    \       } else if character == ']' {\n            openingBrackets -= 1\n     \
    \       if openingBrackets == 0 {\n                stack.removeLast()\n      \
    \      }\n        }\n    }\n    return openingBrackets == 0", "    \n    // Your\
    \ code here\n    \n    return false", "    var stack = [String]()\n    var openBrackets\
    \ = 0\n    var closeBrackets = 0\n    for character in string {\n        if character\
    \ == '[' {\n            openBrackets += 1\n            stack.append(character)\n\
    \        } else if character == ']' {\n            closeBrackets += 1\n      \
    \      if openBrackets == closeBrackets {\n                stack.removeLast()\n\
    \            }\n        } else if openBrackets > closeBrackets {\n           \
    \ return false\n        }\n    }\n    return openBrackets == closeBrackets", " \
    \   guard let open = string.rangeOfString(\"[\", options: .LiteralSearch, range:\
    \ nil, locale: nil),\n        let close = string.rangeOfString(\"]\", options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n            return false\n\
    \    }\n    return open.location == close && close.location == open.location +\
    \ 1", "    \n    // Your code here\n    \n    return true", "    guard let index\
    \ = string.index(of: \"[\"),\n        let end = string.index(of: \"]\", from:\
    \ index) else {\n        return false\n    }\n    let start = index + 1\n    let\
    \ end = string.index(of: \"]\", from: end)\n    let subsequence = string.substring(from:\
    \ start, to: end)\n    return subsequence.contains(\"[\")", "\tlet openingBrackets\
    \ = string.unicodeScalars.filter({ $0.isOpen })\n\tlet closingBrackets = string.unicodeScalars.filter({\
    \ $0.isClosing })\n\t\n\tguard openingBrackets.count > 0 && closingBrackets.count\
    \ > 0 else {\n\t\treturn false\n\t}\n\t\n\tlet openingBracketsCount = openingBrackets.count\n\
    \tlet closingBracketsCount = closingBrackets.count\n\t\n\tguard openingBracketsCount\
    \ == closingBracketsCount else {\n\t\treturn false\n\t}\n\t\n\tlet openingBracketsIndex\
    \ = openingBrackets.firstIndex(where: { $0.isOpen })\n\tlet closingBracketsIndex\
    \ = closingBrackets.firstIndex(where: { $0.isClosing })\n\t\n\tguard openingBracketsIndex\
    \ != closingBracketsIndex else {\n\t\treturn false\n\t}\n\t\n\tlet openingBracketsString\
    \ = openingBrackets[openingBracketsIndex].value\n\tlet closingBracketsString =\
    \ closingBrackets[closingBracketsIndex].value\n\t\n\tlet openingBracketsStringRange\
    \ = string.unicodeScalars.filter({ $0.isOpen }).first(where: { $0.value == openingBracketsString\
    \ })\n\tlet closingBracketsStringRange = string.unicodeScalars.filter({ $0.isClosing\
    \ }).first(where: { $0.value == closingBracketsString })\n\t\n\tguard openingBracketsStringRange\
    \ != nil && closingBracketsStringRange != nil else {\n\t\treturn false\n\t}\n\t\
    \n\tlet openingBracketsStringRangeIndex = openingBracketsStringRange.index\n\t\
    let closingBracketsStringRangeIndex = closingBracketsStringRange.index\n\t\n\t\
    guard openingBracketsStringRangeIndex != closingBracketsStringRangeIndex else\
    \ {\n\t\treturn false\n\t}\n\t\n\treturn true", "    var stack = [String]()\n\
    \    var openingBrackets = 0\n    for char in string {\n        if char == '['\
    \ {\n            stack.append(char)\n            openingBrackets += 1\n      \
    \  } else if char == ']' {\n            openingBrackets -= 1\n            if openingBrackets\
    \ == 0 {\n                stack.removeLast()\n            }\n        } else if\
    \ char == '[' && openingBrackets > 0 {\n            stack.removeLast()\n     \
    \   }\n    }\n    return stack.count > 0", "    var index = 0\n    var openCount\
    \ = 0\n    var closeCount = 0\n    var openBracketCount = 0\n    var closeBracketCount\
    \ = 0\n    var openBracketNestingCount = 0\n    var closeBracketNestingCount =\
    \ 0\n    var openBracketNesting = 0\n    var closeBracketNesting = 0\n    var\
    \ openBracketNestingCount = 0\n    var closeBracketNestingCount = 0\n    var openBracketNestingCount\
    \ = 0\n    var closeBracketNestingCount = 0\n    var openBracketNestingCount =\
    \ 0\n    var closeBracketNestingCount = 0\n    var openBracketNestingCount = 0\n\
    \    var closeBracketNestingCount = 0\n    var openBracketNestingCount = 0\n \
    \   var closeBracketNestingCount = 0\n    var openBracketNestingCount = 0\n  \
    \  var closeBracketNestingCount = 0\n    var openBracketNestingCount = 0\n   \
    \ var closeBracketNestingCount = 0\n    var openBracketNestingCount = 0\n    var\
    \ closeBracketNestingCount = 0\n    var openBracketNestingCount = 0\n    var closeBracketNestingCount\
    \ = 0\n    var openBracketNestingCount = 0\n    var closeBracketNestingCount =\
    \ 0\n    var openBracketNestingCount = 0\n    var closeBracketNestingCount = 0\n\
    \    var openBracketNestingCount = 0\n    var closeBracketNestingCount = 0\n \
    \   var openBracketNestingCount = 0\n    var closeBracketNestingCount = 0\n  \
    \  var openBracketNestingCount = 0\n    var closeBracketNestingCount = 0\n   \
    \ var openBracketNestingCount = 0\n    var closeBracketNestingCount = 0\n    var\
    \ openBracketNestingCount = 0\n    var closeBracketNestingCount = 0\n    var openBracketNestingCount\
    \ = 0\n    var closeBracketNestingCount = 0\n    var openBracketNestingCount =\
    \ 0\n    var closeBracketNestingCount = 0\n    var openBracketNestingCount = 0\n\
    \    var closeBracketNestingCount = 0\n    var openBracketNestingCount = 0\n \
    \   var closeBracketNestingCount = 0\n    var openBracketNestingCount = 0\n  \
    \  var closeBracketNestingCount = 0\n    var openBracketNestingCount = 0\n   \
    \ var closeBracketNestingCount = 0\n    var openBracketNest", "    guard let start\
    \ = string.index(of: \"[\"),\n        let end = string.index(of: \"]\"),\n   \
    \     start < end else {\n            return false\n    }\n    let nested = string.substring(from:\
    \ start + 1, to: end - 1)\n    return nested.characters.count > 0", "    \n  \
    \  // Initialize a stack of brackets\n    var stack = [Bracket]()\n    \n    //\
    \ Iterate over the string and add brackets to the stack\n    for char in string\
    \ {\n        switch char {\n        case '[':\n            stack.append(Bracket.Open)\n\
    \        case '[':\n            stack.append(Bracket.Close)\n        case ']':\n\
    \            stack.append(Bracket.Close)\n        case ']':\n            stack.append(Bracket.Open)\n\
    \        default:\n            // If stack is empty, return false\n          \
    \  if stack.count == 0 {\n                return false\n            }\n      \
    \      // If stack is not empty, return true if the stack is balanced\n      \
    \      if stack.count == 1 {\n                return true\n            }\n   \
    \         // Otherwise, return false if the stack is not balanced\n          \
    \  return false\n        }\n    }\n    \n    // If stack is empty, return false\n\
    \    if stack.count == 0 {\n        return false\n    }\n    \n    // If stack\
    \ is not empty, return true if the stack is balanced\n    if stack.count == 1\
    \ {\n        return true\n    }\n    \n    // Otherwise, return false if the stack\
    \ is not balanced\n    return false", "    let stack = Stack()\n    for character\
    \ in string {\n        if character == '[' {\n            stack.push(character)\n\
    \        } else if character == ']' {\n            if stack.top() == '[' {\n \
    \               stack.pop()\n            } else {\n                return false\n\
    \            }\n        }\n    }\n    return stack.top() == nil", "    guard let\
    \ openBracket = string.rangeOfString(\"[\", options: .BackwardsSearch) else {\
    \ return false }\n    guard let closeBracket = string.rangeOfString(\"]\", options:\
    \ .BackwardsSearch) else { return false }\n    guard openBracket.location < closeBracket.location\
    \ else { return false }\n    guard openBracket.location > 0 else { return false\
    \ }\n    guard closeBracket.location < string.count else { return false }\n  \
    \  \n    let openBracketIndex = string.startIndex.advancedBy(openBracket.location)\n\
    \    let closeBracketIndex = string.startIndex.advancedBy(closeBracket.location)\n\
    \    \n    let openBracketString = string.substringWithRange(openBracketIndex)\n\
    \    let closeBracketString = string.substringWithRange(closeBracketIndex)\n \
    \   \n    if openBracketString == closeBracketString {\n        return true\n\
    \    }\n    \n    return false", "    \n    let stack = Stack()\n    \n    for\
    \ char in string {\n        \n        if char == '[' {\n            stack.push(char)\n\
    \        }\n        \n        if char == ']' {\n            \n            if stack.count\
    \ > 0 {\n                \n                if stack.pop() == '[' {\n         \
    \           \n                    return true\n                }\n           \
    \ }\n        }\n    }\n    \n    return false", "    guard let openBracket = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil),\n        let closeBracket\
    \ = string.rangeOfString(\"]\", options: .LiteralSearch, range: nil, locale: nil)\
    \ else {\n            return false\n    }\n    return openBracket.location !=\
    \ closeBracket.location", "    guard let openingBracket = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil) else {\n        return\
    \ false\n    }\n    guard let closingBracket = string.rangeOfString(\"]\", options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n        return false\n    }\n\
    \    guard let openingBracketIndex = string.index(of: openingBracket, options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n        return false\n    }\n\
    \    guard let closingBracketIndex = string.index(of: closingBracket, options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n        return false\n    }\n\
    \    guard let openingBracketIndex = string.index(of: openingBracket, options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n        return false\n    }\n\
    \    guard let closingBracketIndex = string.index(of: closingBracket, options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n        return false\n    }\n\
    \    guard let openingBracketIndex = string.index(of: openingBracket, options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n        return false\n    }\n\
    \    guard let closingBracketIndex = string.index(of: closingBracket, options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n        return false\n    }\n\
    \    guard let openingBracketIndex = string.index(of: openingBracket, options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n        return false\n    }\n\
    \    guard let closingBracketIndex = string.index(of: closingBracket, options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n        return false\n    }\n\
    \    guard let openingBracketIndex = string.index(of: openingBracket, options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n        return false\n    }\n\
    \    guard let closingBracketIndex = string.index(of: closingBracket, options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n        return false\n    }\n\
    \    guard let openingBracketIndex = string.index(of: openingBracket, options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n        return false\n    }\n\
    \    guard let closingBracketIndex = string.index(of: closingBracket, options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n        return false\n    }",
  "    \n    let stack = Stack()\n    \n    for char in string {\n        \n     \
    \   if char == '[' {\n            stack.push(char)\n        } else if char ==\
    \ ']' {\n            if stack.count > 0 {\n                stack.pop()\n     \
    \       } else {\n                return false\n            }\n        }\n   \
    \ }\n    \n    return stack.count == 0", "    var openingBrackets = 0 // number\
    \ of opening brackets\n    var closingBrackets = 0 // number of closing brackets\n\
    \    var openingBracketsStack = [String]() // stack of opening brackets\n    var\
    \ closingBracketsStack = [String]() // stack of closing brackets\n    var openingBracketsStackCount\
    \ = 1 // number of opening brackets in the stack\n    var closingBracketsStackCount\
    \ = 1 // number of closing brackets in the stack\n    var openingBracketsStackLastIndex\
    \ = -1 // index of the last opening bracket in the stack\n    var closingBracketsStackLastIndex\
    \ = -1 // index of the last closing bracket in the stack\n    var openingBracketsStackLastBracket\
    \ = nil // last bracket in the stack\n    var closingBracketsStackLastBracket\
    \ = nil // last bracket in the stack\n    var openingBracketsStackLastBracketIndex\
    \ = -1 // index of the last opening bracket in the stack\n    var closingBracketsStackLastBracketIndex\
    \ = -1 // index of the last closing bracket in the stack\n    var openingBracketsStackLastBracketIndex\
    \ = -1 // index of the last opening bracket in the stack\n    var closingBracketsStackLastBracketIndex\
    \ = -1 // index of the last closing bracket in the stack\n    var openingBracketsStackLastBracketIndex\
    \ = -1 // index of the last opening bracket in the stack\n    var closingBracketsStackLastBracketIndex\
    \ = -1 // index of the last closing bracket in the stack\n    var openingBracketsStackLastBracketIndex\
    \ = -1 // index of the last opening bracket in the stack\n    var closingBracketsStackLastBracketIndex\
    \ = -1 // index of the last closing bracket in the stack\n    var openingBracketsStackLastBracketIndex\
    \ = -1 // index of the last opening bracket in the stack\n    var closingBracketsStackLastBracketIndex\
    \ = -1 // index of the last closing bracket in the stack\n    var openingBracketsStackLastBracketIndex\
    \ = -1 // index of the last opening bracket in the stack\n    var closingBracketsStackLastBracketIndex\
    \ = -1 // index of the last closing bracket in the stack\n    var openingBracketsStackLastBracketIndex\
    \ = -1 // index of the last opening bracket in the stack\n    var closingBracketsStackLastBracketIndex\
    \ = -1 // index of the last closing bracket in the stack\n    var openingBracketsStackLastBracketIndex\
    \ = -1 // index of the last opening bracket in the stack\n    var closingBracketsStackLastBracketIndex\
    \ = -1 // index of the last closing bracket in the stack\n    var openingBracketsStackLastBracketIndex\
    \ = -1 // index of the last opening bracket in the ", "    guard let openBracket\
    \ = string.rangeOfString(\"[\", options: .BackwardsSearch) else { return false\
    \ }\n    guard let closeBracket = string.rangeOfString(\"]\", options: .BackwardsSearch)\
    \ else { return false }\n    guard openBracket.location == closeBracket.location\
    \ else { return false }\n    guard openBracket.location > 0 else { return false\
    \ }\n    guard closeBracket.location < string.count else { return false }\n  \
    \  \n    let openBracketIndex = string.index(openBracket.location, offsetBy: 1)\n\
    \    let closeBracketIndex = string.index(closeBracket.location, offsetBy: 1)\n\
    \    \n    guard openBracketIndex < closeBracketIndex else { return false }\n\
    \    \n    let openBracketString = string[openBracketIndex..<closeBracketIndex]\n\
    \    \n    guard openBracketString.rangeOfString(\"[\", options: .BackwardsSearch)\
    \ == nil else { return false }\n    guard openBracketString.rangeOfString(\"]\"\
    , options: .BackwardsSearch) == nil else { return false }\n    \n    return true",
  "    var stack = [String]()\n    var open = 0\n    var close = 0\n    for i := 0;\
    \ i < len(string); i++ {\n        if string[i] == '[' {\n            open++\n\
    \            stack.append(string[i])\n        } else if string[i] == ']' {\n \
    \           close++\n            if open > close {\n                return false\n\
    \            }\n            open--\n        }\n    }\n    return open > close",
  "    let openBrackets = string.count(\"[\")\n    let closeBrackets = string.count(\"\
    ]\")\n    let openBracketsNesting = openBrackets > closeBrackets\n    let closeBracketsNesting\
    \ = closeBrackets > openBrackets\n    return openBracketsNesting && closeBracketsNesting",
  "    \n    // Your code here\n    \n    return true", "    guard let start = string.index(of:\
    \ \"[\"),\n        let end = string.index(of: \"]\", in: start) else {\n     \
    \       return false\n    }\n    let subsequence = string[start..<end]\n    return\
    \ subsequence.contains(\"[\")", "    guard let index = string.index(of: \"[\"\
    ),\n        let end = string.index(of: \"]\", in: index),\n        let start =\
    \ string.index(of: \"[\", in: end),\n        let end = string.index(of: \"]\"\
    , in: start) else {\n            return false\n    }\n    return start < end",
  "    var stack = [String]()\n    var openBrackets = 0\n    for c in string {\n \
    \       if c == '[' {\n            stack.append(c)\n            openBrackets +=\
    \ 1\n        } else if c == '[' {\n            openBrackets -= 1\n           \
    \ if openBrackets == 0 {\n                stack.removeLast()\n            }\n\
    \        } else if c == ']' {\n            if openBrackets == 0 {\n          \
    \      return false\n            }\n            openBrackets -= 1\n        }\n\
    \    }\n    return openBrackets == 0", "    let brackets = string.unicodeScalars\n\
    \        .filter { $0 != brackets.first }\n        .map { $0 }\n        .filter\
    \ { $0 != brackets.last }\n        .map { $0 }\n        .filter { $0 != brackets.first\
    \ }\n        .map { $0 }\n        .filter { $0 != brackets.last }\n        .map\
    \ { $0 }\n        .filter { $0 != brackets.first }\n        .map { $0 }\n    \
    \    .filter { $0 != brackets.last }\n        .map { $0 }\n        .filter { $0\
    \ != brackets.first }\n        .map { $0 }\n        .filter { $0 != brackets.last\
    \ }\n        .map { $0 }\n        .filter { $0 != brackets.first }\n        .map\
    \ { $0 }\n        .filter { $0 != brackets.last }\n        .map { $0 }\n     \
    \   .filter { $0 != brackets.first }\n        .map { $0 }\n        .filter { $0\
    \ != brackets.last }\n        .map { $0 }\n        .filter { $0 != brackets.first\
    \ }\n        .map { $0 }\n        .filter { $0 != brackets.last }\n        .map\
    \ { $0 }\n        .filter { $0 != brackets.first }\n        .map { $0 }\n    \
    \    .filter { $0 != brackets.last }\n        .map { $0 }\n        .filter { $0\
    \ != brackets.first }\n        .map { $0 }\n        .filter { $0 != brackets.last\
    \ }\n        .map { $0 }\n        .filter { $0 != brackets.first }\n        .map\
    \ { $0 }\n        .filter { $0 != brackets.last }\n        .map { $0 }\n     \
    \   .filter { $0 != brackets.first }\n        .map { $0 }\n        .filter { $0\
    \ != brackets.last }\n        .map { $0 }\n        .filter { $0 != brackets.first\
    \ }\n        .map { $0 }\n        .filter { $0 != brackets.last }\n        .map\
    \ { $0 }\n        .filter { $0 != brackets.first }\n        .map { $0 }\n    \
    \    .filter { $0 != brackets.last }\n        .map { $0 }\n        .filter { $0\
    \ != brackets.first }\n        .map { $0 }\n        .filter { $0 != brackets.last\
    \ }\n        .map { $0 }\n", "    \n    // Your code here\n    \n    return true",
  "    \n    // Your code here\n    \n    return true", "    var stack = [String]()\n\
    \    for c in string {\n        if c == '[' {\n            stack.append(c)\n \
    \       } else if c == ']' {\n            if stack.count > 0 {\n             \
    \   stack.removeLast()\n            } else {\n                return false\n \
    \           }\n        }\n    }\n    return stack.count == 0", "    guard let\
    \ openBracket = string.rangeOfString(\"[\", options: .LiteralSearch, range: nil,\
    \ locale: nil) else {\n        return false\n    }\n    guard let closeBracket\
    \ = string.rangeOfString(\"]\", options: .LiteralSearch, range: nil, locale: nil)\
    \ else {\n        return false\n    }\n    guard openBracket.location != closeBracket.location\
    \ else {\n        return false\n    }\n    guard openBracket.location > closeBracket.location\
    \ else {\n        return false\n    }\n    guard openBracket.location < string.endIndex\
    \ else {\n        return false\n    }\n    guard closeBracket.location > string.endIndex\
    \ else {\n        return false\n    }\n    guard closeBracket.location < openBracket.location\
    \ else {\n        return false\n    }\n    guard let openBracketIndex = string.index(openBracket,\
    \ offsetBy: 1) {\n        return false\n    }\n    guard let closeBracketIndex\
    \ = string.index(closeBracket, offsetBy: 1) {\n        return false\n    }\n \
    \   guard openBracketIndex < closeBracketIndex else {\n        return false\n\
    \    }\n    guard let openBracket = string.substring(to: openBracketIndex),\n\
    \        let closeBracket = string.substring(to: closeBracketIndex),\n       \
    \ let openBracketRange = string.range(of: openBracket, options: .LiteralSearch,\
    \ range: nil, locale: nil),\n        let closeBracketRange = string.range(of:\
    \ closeBracket, options: .LiteralSearch, range: nil, locale: nil)\n    else {\n\
    \        return false\n    }\n    return openBracketRange.lowerBound < closeBracketRange.lowerBound",
  "    let stack = Stack()\n    for char in string {\n        if char == '[' {\n \
    \           stack.push(char)\n        } else if char == ']' {\n            if\
    \ stack.top() == '[' {\n                stack.pop()\n            } else {\n  \
    \              return false\n            }\n        }\n    }\n    return stack.top()\
    \ == nil", "    guard let start = string.index(of: \"[\"),\n        let end =\
    \ string.index(of: \"]\"),\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n        let end = string.index(of: \"]\", range: start..<end),\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        let start = string.index(of:\
    \ \"[\", range: start..<end),\n        let end = string.index(of: \"]\", range:\
    \ start..<end),\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        let start\
    \ = string.index(of: \"[\", range: start..<end),\n        let end = string.index(of:\
    \ \"]\", range: start..<end),\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n        let end = string.index(of: \"]\", range: start..<end),\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        let start = string.index(of:\
    \ \"[\", range: start..<end),\n        let end = string.index(of: \"]\", range:\
    \ start..<end),\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        let start\
    \ = string.index(of: \"[\", range: start..<end),\n        let end = string.index(of:\
    \ \"]\", range: start..<end),\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n        let end = string.index(of: \"]\", range: start..<end),\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        let start = string.index(of:\
    \ \"[\", range: start..<end),\n        let end = string.index(of: \"]\", range:\
    \ start..<end),\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        let start\
    \ = string.index(of: \"[\", range: start..<end),\n        let end = string.index(of:\
    \ \"]\", range: start..<end),\n        let start = string.index(of: \"[\", range:\
    \ start.", "    var stack = [String]()\n    var open = 0\n    var close = 0\n\
    \    for i := 0; i < len(string); i++ {\n        if string[i] == '[' {\n     \
    \       open++\n            stack.append(string[i])\n        } else if string[i]\
    \ == ']' {\n            close++\n            if open > close {\n             \
    \   return false\n            }\n            open--\n            stack.pop()\n\
    \        }\n    }\n    return open > close", "    let brackets = string.unicodeScalars.filter({\
    \ $0.value > 0 })\n    \n    if brackets.count < 1 {\n        return false\n \
    \   }\n    \n    let openingBrackets = brackets.filter({ $0.value == 1 })\n  \
    \  \n    if openingBrackets.count < 1 {\n        return false\n    }\n    \n \
    \   let closingBrackets = brackets.filter({ $0.value == -1 })\n    \n    if closingBrackets.count\
    \ < 1 {\n        return false\n    }\n    \n    let nestedBrackets = openingBrackets.reduce(into:\
    \ [String](), { $0.append($0.last!) })\n    \n    return closingBrackets.reduce(into:\
    \ [String](), { $0.append($0.last!) }).contains(nestedBrackets)", "    guard let\
    \ index = string.index(of: \"[\"),\n        let end = string.index(of: \"]\",\
    \ range: start..<string.endIndex),\n        string.distance(from: start, to: end)\
    \ == 1 else {\n        return false\n    }\n    return is_nested(string[start..<end])",
  "    let stack = Stack()\n    for char in string {\n        if char == '[' {\n \
    \           stack.push(char)\n        } else if char == ']' {\n            if\
    \ stack.isEmpty {\n                return false\n            }\n            let\
    \ top = stack.top()\n            if top == '[' {\n                stack.pop()\n\
    \            } else {\n                return false\n            }\n        }\n\
    \    }\n    return stack.isEmpty", "    guard let start = string.index(of: \"\
    [\"), let end = string.index(of: \"]\") else {\n        return false\n    }\n\
    \    let range = start..<end\n    let openBrackets = string.components(separatedBy:\
    \ \"]\").filter({ $0.contains(\"[\") })\n    let closeBrackets = string.components(separatedBy:\
    \ \"]\").filter({ $0.contains(\"[\") }).reversed()\n    let openBracketsCount\
    \ = openBrackets.count\n    let closeBracketsCount = closeBrackets.count\n   \
    \ let openBracketsNesting = (openBracketsCount - closeBracketsCount) > 0\n   \
    \ let closeBracketsNesting = (closeBracketsCount - openBracketsCount) > 0\n  \
    \  return openBracketsNesting && closeBracketsNesting", "    guard let openBracket\
    \ = string.rangeOfString(\"[\", options: .LiteralSearch, range: nil, locale: nil)\
    \ else {\n        return false\n    }\n    guard let closeBracket = string.rangeOfString(\"\
    ]\", options: .LiteralSearch, range: nil, locale: nil) else {\n        return\
    \ false\n    }\n    guard openBracket.location != closeBracket.location else {\n\
    \        return false\n    }\n    guard openBracket.location != string.endIndex\
    \ else {\n        return false\n    }\n    guard closeBracket.location != string.startIndex\
    \ else {\n        return false\n    }\n    let openBracketIndex = string.startIndex\n\
    \    let closeBracketIndex = openBracketIndex + closeBracket.location - openBracket.location\n\
    \    guard openBracketIndex <= closeBracketIndex else {\n        return false\n\
    \    }\n    let openBracketCount = string.distance(from: openBracketIndex, to:\
    \ closeBracketIndex)\n    let closeBracketCount = string.distance(from: openBracketIndex,\
    \ to: closeBracketIndex + 1)\n    return openBracketCount == closeBracketCount",
  "    var openingBracketCount = 0\n    var closingBracketCount = 0\n    var openingBracket\
    \ = String()\n    var closingBracket = String()\n    for i := 0; i < len(string);\
    \ i++ {\n        if string[i] == '[' {\n            openingBracketCount++\n  \
    \          openingBracket = openingBracket.stringByAppendingString(string[i])\n\
    \        } else if string[i] == ']' {\n            closingBracketCount++\n   \
    \         closingBracket = closingBracket.stringByAppendingString(string[i])\n\
    \        } else if openingBracketCount > 0 && closingBracketCount > 0 {\n    \
    \        if openingBracketCount < closingBracketCount {\n                if openingBracket.rangeOfString(closingBracket)\
    \ != nil {\n                    return true\n                }\n            }\
    \ else {\n                if openingBracket.rangeOfString(closingBracket) == nil\
    \ {\n                    return true\n                }\n            }\n     \
    \       openingBracketCount = 0\n            closingBracketCount = 0\n       \
    \     openingBracket = String()\n            closingBracket = String()\n     \
    \   }\n    }\n    return false", "    let stack = Stack<String>()\n    for character\
    \ in string {\n        if character == '[' {\n            stack.push(character)\n\
    \        } else if character == ']' {\n            if stack.count > 0 {\n    \
    \            stack.pop()\n            } else {\n                return false\n\
    \            }\n        }\n    }\n    return stack.count == 0", "    guard let\
    \ openingBracket = string.rangeOfString(\"[\", options: .LiteralSearch, range:\
    \ nil, locale: nil) else {\n        return false\n    }\n    guard let closingBracket\
    \ = string.rangeOfString(\"]\", options: .LiteralSearch, range: nil, locale: nil)\
    \ else {\n        return false\n    }\n    guard openingBracket.location != closingBracket.location\
    \ else {\n        return false\n    }\n    guard openingBracket.location > 0 else\
    \ {\n        return false\n    }\n    guard closingBracket.location < string.count\
    \ else {\n        return false\n    }\n    guard let openingBracketIndex = string.index(string.startIndex,\
    \ offsetBy: openingBracket.location),\n        let closingBracketIndex = string.index(string.startIndex,\
    \ offsetBy: closingBracket.location),\n        openingBracketIndex < closingBracketIndex\
    \ + 1 else {\n        return false\n    }\n    let openingBracket = string[openingBracketIndex].unicodeScalars.first!\n\
    \    let closingBracket = string[closingBracketIndex].unicodeScalars.first!\n\
    \    guard openingBracket == closingBracket else {\n        return false\n   \
    \ }\n    return true", "    guard let start = string.index(of: \"[\"),\n     \
    \   let end = string.index(of: \"]\"),\n        start < end else {\n         \
    \   return false\n    }\n    \n    let stack = Array<Character>()\n    stack.append(contentsOf:\
    \ string.unicodeScalars)\n    \n    var openingBrackets = 0\n    var closingBrackets\
    \ = 0\n    \n    for scalar in stack {\n        if scalar == Character(\"[\")\
    \ {\n            openingBrackets += 1\n        }\n        if scalar == Character(\"\
    ]\") {\n            closingBrackets += 1\n        }\n    }\n    \n    return openingBrackets\
    \ == closingBrackets", "    if string == \"\" {\n        return false\n    }\n\
    \    var open = 0\n    var close = 0\n    var openCount = 0\n    var closeCount\
    \ = 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == '[' {\n\
    \            openCount++\n        }\n        if string[i] == ']' {\n         \
    \   closeCount++\n        }\n        if string[i] == '[' && openCount > closeCount\
    \ {\n            open++\n        }\n        if string[i] == ']' && openCount >\
    \ closeCount {\n            close++\n        }\n    }\n    return open > close",
  "    var stack = [String]()\n    var openBrackets = 0\n    for char in string {\n\
    \        if char == '[' {\n            stack.append(char)\n            openBrackets\
    \ += 1\n        } else if char == ']' {\n            if openBrackets > 0 {\n \
    \               openBrackets -= 1\n            } else {\n                return\
    \ false\n            }\n        }\n    }\n    return openBrackets == 0", "   \
    \ guard let openingBracket = string.rangeOfString(\"[\", options: .LiteralSearch,\
    \ range: nil, locale: nil) else {\n        return false\n    }\n    guard let\
    \ closingBracket = string.rangeOfString(\"]\", options: .LiteralSearch, range:\
    \ nil, locale: nil) else {\n        return false\n    }\n    guard let openingBracketIndex\
    \ = string.rangeOfString(\"[\", options: .LiteralSearch, range: nil, locale: nil)?.lowerBound\
    \ else {\n        return false\n    }\n    guard let closingBracketIndex = string.rangeOfString(\"\
    ]\", options: .LiteralSearch, range: nil, locale: nil)?.upperBound else {\n  \
    \      return false\n    }\n    guard openingBracketIndex <= closingBracketIndex\
    \ else {\n        return false\n    }\n    guard openingBracketIndex == openingBracket.lowerBound\
    \ else {\n        return false\n    }\n    guard closingBracketIndex == closingBracket.upperBound\
    \ else {\n        return false\n    }\n    guard openingBracketIndex == openingBracket.upperBound\
    \ else {\n        return false\n    }\n    guard closingBracketIndex == closingBracket.lowerBound\
    \ else {\n        return false\n    }\n    return true", "    \n    // Your code\
    \ here\n    \n    return true", "    guard let openingBracket = string.firstIndex(of:\
    \ \"[\"),\n        let closingBracket = string.lastIndex(of: \"]\") else {\n \
    \           return false\n    }\n    \n    let openingBracketIndex = string.index(openingBracket,\
    \ offsetBy: 1)\n    let closingBracketIndex = string.index(closingBracket, offsetBy:\
    \ -1)\n    \n    return openingBracketIndex != closingBracketIndex", "\tlet stack\
    \ = Stack<String>()\n\tlet openBrackets = Set<String>()\n\tlet closeBrackets =\
    \ Set<String>()\n\tlet openBracketsCount = 1\n\tlet closeBracketsCount = 1\n\t\
    \n\tlet openBracketsString = \"[\"\n\tlet closeBracketsString = \"[\"\n\t\n\t\
    let openBracketsCount = string.characters.filter({ openBracketsString.contains($0)\
    \ }).count\n\tlet closeBracketsCount = string.characters.filter({ closeBracketsString.contains($0)\
    \ }).count\n\t\n\tlet openBracketsStringCount = string.characters.filter({ openBracketsString.contains($0)\
    \ }).count\n\tlet closeBracketsStringCount = string.characters.filter({ closeBracketsString.contains($0)\
    \ }).count\n\t\n\tlet openBracketsStringCount2 = string.characters.filter({ openBracketsString.contains($0)\
    \ }).count\n\tlet closeBracketsStringCount2 = string.characters.filter({ closeBracketsString.contains($0)\
    \ }).count\n\t\n\tlet openBracketsStringCount3 = string.characters.filter({ openBracketsString.contains($0)\
    \ }).count\n\tlet closeBracketsStringCount3 = string.characters.filter({ closeBracketsString.contains($0)\
    \ }).count\n\t\n\tlet openBracketsStringCount4 = string.characters.filter({ openBracketsString.contains($0)\
    \ }).count\n\tlet closeBracketsStringCount4 = string.characters.filter({ closeBracketsString.contains($0)\
    \ }).count\n\t\n\tlet openBracketsStringCount5 = string.characters.filter({ openBracketsString.contains($0)\
    \ }).count\n\tlet closeBracketsStringCount5 = string.characters.filter({ closeBracketsString.contains($0)\
    \ }).count\n\t\n\tlet openBracketsStringCount6 = string.characters.filter({ openBracketsString.contains($0)\
    \ }).count\n\tlet closeBracketsStringCount6 = string.characters.filter({ closeBracketsString.contains($0)\
    \ }).count\n\t\n\tlet openBracketsStringCount7 = string.characters.filter({ openBracketsString.contains($0)\
    \ }).count\n\tlet closeBracketsStringCount7 = string.characters.filter({ closeBracketsString.contains($0)\
    \ }).count\n\t\n\tlet openBracketsStringCount8 = string.characters.filter({ openBracketsString.contains($0)\
    \ }).count\n\tlet closeBracketsStringCount8 = string.characters.filter({ closeBracketsString.",
  "    \n    let stack = Stack()\n    \n    for char in string {\n        \n     \
    \   if char == '[' {\n            stack.push(char)\n        } else if char ==\
    \ ']' {\n            if stack.count > 0 {\n                stack.pop()\n     \
    \       } else {\n                return false\n            }\n        }\n   \
    \ }\n    \n    return stack.count == 0", "    let stack = Stack()\n    for char\
    \ in string {\n        if char == '[' {\n            stack.push(char)\n      \
    \  } else if char == ']' {\n            if stack.count > 0 {\n               \
    \ stack.pop()\n            } else {\n                return false\n          \
    \  }\n        }\n    }\n    return stack.count == 0", "    \n    let brackets\
    \ = string.unicodeScalars\n    \n    var openingBracketCount = 0\n    var closingBracketCount\
    \ = 0\n    \n    for bracket in brackets {\n        \n        switch bracket {\n\
    \            \n        case .LeftBracket:\n            openingBracketCount +=\
    \ 1\n            \n        case .RightBracket:\n            closingBracketCount\
    \ += 1\n            \n        default:\n            \n            if openingBracketCount\
    \ > closingBracketCount {\n                return false\n            }\n     \
    \   }\n    }\n    \n    return openingBracketCount == closingBracketCount", " \
    \   guard let pattern = try? NSRegularExpression(pattern: \"\\\\[\\\\[\\\\]\\\\\
    ]\\\\]\", options: .CaseInsensitive) else {\n        return false\n    }\n   \
    \ \n    let range = NSMakeRange(0, string.characters.count)\n    \n    return\
    \ pattern.firstMatchInString(string, options: .CaseInsensitive, range: range)\
    \ != nil", "    guard let open = string.range(of: \"[\"),\n        let close =\
    \ string.range(of: \"]\"),\n        let open2 = string.range(of: \"[\", options:\
    \ .backwards),\n        let close2 = string.range(of: \"]\", options: .backwards)\
    \ else { return false }\n    return open != nil && close != nil && open2 != nil\
    \ && close2 != nil && open2.lowerBound < close2.lowerBound", "    var stack =\
    \ [String]()\n    for char in string {\n        if char == '[' {\n           \
    \ stack.append(char)\n        } else if char == ']' {\n            if stack.count\
    \ > 0 {\n                stack.removeLast()\n            } else {\n          \
    \      return false\n            }\n        }\n    }\n    return stack.count ==\
    \ 0", "    guard let openingBracketIndex = string.index(of: \"[\"),\n        let\
    \ closingBracketIndex = string.index(of: \"]\"),\n        openingBracketIndex\
    \ != closingBracketIndex else {\n            return false\n    }\n    let openingBracket\
    \ = string[openingBracketIndex..<openingBracketIndex.advanced(by: 1)]\n    let\
    \ closingBracket = string[closingBracketIndex..<closingBracketIndex.advanced(by:\
    \ 1)]\n    return openingBracket.count > 0 && closingBracket.count > 0 && openingBracket\
    \ == closingBracket", "    guard let openBracketIndex = string.firstIndex(of:\
    \ \"[\"),\n        let closeBracketIndex = string.lastIndex(of: \"]\"),\n    \
    \    openBracketIndex != closeBracketIndex,\n        let openBracket = string[openBracketIndex],\n\
    \        let closeBracket = string[closeBracketIndex],\n        let openBracketCount\
    \ = string.distance(from: openBracketIndex, to: closeBracketIndex),\n        openBracketCount\
    \ > 0 else {\n        return false\n    }\n    \n    let openBracketsCount = openBracket.count\n\
    \    let closeBracketsCount = closeBracket.count\n    \n    if openBracketsCount\
    \ == closeBracketsCount {\n        return true\n    }\n    \n    let openBracketsCount\
    \ = openBracket.count\n    let closeBracketsCount = closeBracket.count\n    \n\
    \    if openBracketsCount > closeBracketsCount {\n        return false\n    }\n\
    \    \n    let openBracketsCount = openBracket.count\n    let closeBracketsCount\
    \ = closeBracket.count\n    \n    if openBracketsCount < closeBracketsCount {\n\
    \        return true\n    }\n    \n    let openBracketsCount = openBracket.count\n\
    \    let closeBracketsCount = closeBracket.count\n    \n    if openBracketsCount\
    \ > closeBracketsCount {\n        return false\n    }\n    \n    let openBracketsCount\
    \ = openBracket.count\n    let closeBracketsCount = closeBracket.count\n    \n\
    \    if openBracketsCount < closeBracketsCount {\n        return true\n    }\n\
    \    \n    let openBracketsCount = openBracket.count\n    let closeBracketsCount\
    \ = closeBracket.count\n    \n    if openBracketsCount > closeBracketsCount {\n\
    \        return false\n    }\n    \n    let openBracketsCount = openBracket.count\n\
    \    let closeBracketsCount = closeBracket.count\n    \n    if openBracketsCount\
    \ < closeBracketsCount {\n        return true\n    }\n    \n    let openBracketsCount\
    \ = openBracket.count\n    let closeBracketsCount = closeBracket.count\n    \n\
    \    if openBracketsCount > closeBracketsCount {\n        return false\n    }\n\
    \    \n    let openBracketsCount = openBracket.count\n    let closeBracketsCount\
    \ = closeBracket.count\n    \n    if openBracketsCount ", "    \n    let stack\
    \ = Stack()\n    \n    for character in string {\n        \n        if character\
    \ == '[' {\n            stack.push(character)\n        }\n        \n        if\
    \ character == ']' {\n            \n            if stack.count > 0 {\n       \
    \         \n                if stack.peek() == '[' {\n                    stack.pop()\n\
    \                } else {\n                    return false\n                }\n\
    \            } else {\n                return false\n            }\n        }\n\
    \    }\n    \n    return stack.count == 0", "    let brackets = string.unicodeScalars\n\
    \        .filter { $0 != brackets.first }\n        .map { $0.value }\n       \
    \ .reduce(into: []) { $0.append($1); $0.append($1); $0.append($1) }\n    \n  \
    \  return brackets.count >= 2", "    if string == \"\" {\n        return false\n\
    \    }\n    var openBrackets = 0\n    var closeBrackets = 0\n    var openBracketsStack\
    \ = [String]()\n    var closeBracketsStack = [String]()\n    for char in string\
    \ {\n        if char == \"[\" {\n            openBracketsStack.append(char)\n\
    \            openBrackets++\n        } else if char == \"]\" {\n            closeBracketsStack.append(char)\n\
    \            closeBrackets++\n        } else if char == \"]\" && openBrackets\
    \ > 0 && closeBrackets == 0 {\n            openBracketsStack.removeLast()\n  \
    \          openBrackets--\n        } else if char == \"[\" && openBrackets ==\
    \ 0 && closeBrackets > 0 {\n            closeBracketsStack.removeLast()\n    \
    \        closeBrackets--\n        }\n    }\n    return openBrackets == 0 && closeBrackets\
    \ == 0", "    let stack = Stack()\n    for char in string {\n        if char ==\
    \ '[' {\n            stack.push(char)\n        } else if char == ']' {\n     \
    \       if stack.top() == '[' {\n                stack.pop()\n            } else\
    \ {\n                return false\n            }\n        } else {\n         \
    \   return false\n        }\n    }\n    return stack.empty()", "    guard let\
    \ start = string.index(of: \"[\"),\n        let end = string.index(of: \"]\"),\n\
    \        start != end,\n        start < string.endIndex,\n        end < string.endIndex,\n\
    \        start < end else {\n        return false\n    }\n    \n    let stack\
    \ = Stack()\n    stack.push(start)\n    \n    var open = 0\n    var close = 0\n\
    \    \n    while open < string.count {\n        if let index = string.index(of:\
    \ \"[\", range: start..<end) {\n            stack.push(index)\n            open\
    \ += 1\n        }\n        \n        if let index = string.index(of: \"]\", range:\
    \ start..<end) {\n            close += 1\n            \n            if stack.count\
    \ > 0 {\n                let top = stack.pop()\n                if top == index\
    \ {\n                    return true\n                }\n            }\n     \
    \   }\n    }\n    \n    return false", "    guard let start = string.index(of:\
    \ \"[\"), let end = string.index(of: \"]\"), let start = string.index(of: \"[\"\
    , offset: start), let end = string.index(of: \"]\", offset: end) else {\n    \
    \    return false\n    }\n    return start < end", "    guard let openBracket\
    \ = string.index(of: \"[\"),\n        let closeBracket = string.index(of: \"]\"\
    ),\n        openBracket != closeBracket else { return false }\n    \n    let openBracketIndex\
    \ = string.index(of: \"[\", offsetBy: openBracket)\n    let closeBracketIndex\
    \ = string.index(of: \"]\", offsetBy: closeBracket)\n    \n    return openBracketIndex\
    \ != nil && closeBracketIndex != nil && openBracketIndex! < closeBracketIndex!",
  "    let stack = Stack()\n    for char in string {\n        if char == '[' {\n \
    \           stack.push(char)\n        } else if char == ']' {\n            if\
    \ stack.top() == '[' {\n                stack.pop()\n            } else {\n  \
    \              return false\n            }\n        }\n    }\n    return stack.empty()",
  "\tlet stack = Stack()\n\tlet openBrackets = Stack()\n\tlet closeBrackets = Stack()\n\
    \tlet openBracketsCount = Stack()\n\tlet closeBracketsCount = Stack()\n\tlet openBracketsCount2\
    \ = Stack()\n\tlet closeBracketsCount2 = Stack()\n\tlet openBracketsCount3 = Stack()\n\
    \tlet closeBracketsCount3 = Stack()\n\tlet openBracketsCount4 = Stack()\n\tlet\
    \ closeBracketsCount4 = Stack()\n\tlet openBracketsCount5 = Stack()\n\tlet closeBracketsCount5\
    \ = Stack()\n\tlet openBracketsCount6 = Stack()\n\tlet closeBracketsCount6 = Stack()\n\
    \tlet openBracketsCount7 = Stack()\n\tlet closeBracketsCount7 = Stack()\n\tlet\
    \ openBracketsCount8 = Stack()\n\tlet closeBracketsCount8 = Stack()\n\tlet openBracketsCount9\
    \ = Stack()\n\tlet closeBracketsCount9 = Stack()\n\tlet openBracketsCount10 =\
    \ Stack()\n\tlet closeBracketsCount10 = Stack()\n\tlet openBracketsCount11 = Stack()\n\
    \tlet closeBracketsCount11 = Stack()\n\tlet openBracketsCount12 = Stack()\n\t\
    let closeBracketsCount12 = Stack()\n\tlet openBracketsCount13 = Stack()\n\tlet\
    \ closeBracketsCount13 = Stack()\n\tlet openBracketsCount14 = Stack()\n\tlet closeBracketsCount14\
    \ = Stack()\n\tlet openBracketsCount15 = Stack()\n\tlet closeBracketsCount15 =\
    \ Stack()\n\tlet openBracketsCount16 = Stack()\n\tlet closeBracketsCount16 = Stack()\n\
    \tlet openBracketsCount17 = Stack()\n\tlet closeBracketsCount17 = Stack()\n\t\
    let openBracketsCount18 = Stack()\n\tlet closeBracketsCount18 = Stack()\n\tlet\
    \ openBracketsCount19 = Stack()\n\tlet closeBracketsCount19 = Stack()\n\tlet openBracketsCount20\
    \ = Stack()\n\tlet closeBracketsCount20 = Stack()\n\tlet openBracketsCount21 =\
    \ Stack()\n\tlet closeBracketsCount21 = Stack()\n\tlet openBracketsCount22 = ",
  "    let brackets = string.unicodeScalars\n        .filter { $0 != '[' }\n     \
    \   .filter { $0 != ']' }\n        .filter { $0 != '{' }\n        .filter { $0\
    \ != '}' }\n        .filter { $0 != '(' }\n        .filter { $0 != ')' }\n   \
    \ return brackets.count > 0", "    if string == \"\" {\n        return false\n\
    \    }\n    var openBrackets = 0\n    var closeBrackets = 0\n    var openBracketsStack\
    \ = [String]()\n    var closeBracketsStack = [String]()\n    for char in string\
    \ {\n        if char == \"[\" {\n            openBracketsStack.append(char)\n\
    \            openBrackets++\n        } else if char == \"]\" {\n            closeBracketsStack.append(char)\n\
    \            closeBrackets++\n        } else if char == \"]\" && openBrackets\
    \ > 0 && closeBrackets == 0 {\n            closeBracketsStack.removeLast()\n \
    \           closeBrackets--\n            if openBrackets == 0 {\n            \
    \    openBracketsStack.removeLast()\n                openBrackets--\n        \
    \    }\n        }\n    }\n    return openBrackets == 0 && closeBrackets == 0",
  "    var openBracketCount = 0\n    var closeBracketCount = 0\n    var openBracketCountStack\
    \ = [Int]()\n    var closeBracketCountStack = [Int]()\n    for char in string\
    \ {\n        switch char {\n        case '[':\n            openBracketCountStack.append(openBracketCount)\n\
    \            openBracketCount++\n        case ']':\n            closeBracketCountStack.append(closeBracketCount)\n\
    \            closeBracketCount++\n        default:\n            if openBracketCount\
    \ > closeBracketCount {\n                return false\n            }\n       \
    \     if openBracketCount == closeBracketCount {\n                openBracketCountStack.removeLast()\n\
    \                closeBracketCountStack.removeLast()\n            }\n        }\n\
    \    }\n    if openBracketCount != closeBracketCount {\n        return false\n\
    \    }\n    for openBracketCount in openBracketCountStack {\n        if openBracketCount\
    \ != closeBracketCount {\n            return false\n        }\n    }\n    return\
    \ true", "    \n    // Your code here\n    \n    return false", "    var stack\
    \ = [String]()\n    var opening = false\n    for c in string {\n        if c ==\
    \ '[' {\n            stack.append(c)\n            opening = true\n        } else\
    \ if c == ']' {\n            if opening{\n                opening = false\n  \
    \          } else {\n                return false\n            }\n        } else\
    \ {\n            if opening{\n                stack.removeLast()\n           \
    \ }\n        }\n    }\n    return stack.count == 0", "    guard let openBracketIndex\
    \ = string.index(of: \"[\"),\n        let closeBracketIndex = string.index(of:\
    \ \"]\"),\n        openBracketIndex != closeBracketIndex else {\n            return\
    \ false\n    }\n    \n    let openBracketCount = 1\n    let closeBracketCount\
    \ = 1\n    \n    var openBracketIndex: String.Index?\n    var closeBracketIndex:\
    \ String.Index?\n    \n    for index in string.indices {\n        if let openBracketIndex\
    \ = string.index(of: \"[\", range: index..<string.endIndex),\n            let\
    \ closeBracketIndex = string.index(of: \"]\", range: openBracketIndex..<string.endIndex),\n\
    \            openBracketIndex != closeBracketIndex {\n                openBracketCount\
    \ += 1\n                closeBracketCount += 1\n        }\n    }\n    \n    return\
    \ openBracketCount == closeBracketCount", "\tlet brackets = string.unicodeScalars\n\
    \tlet openingBrackets = brackets.filter({ $0.isOpen })\n\tlet closingBrackets\
    \ = brackets.filter({ $0.isClosing })\n\t\n\treturn openingBrackets.count > 0\
    \ && closingBrackets.count > 0", "    guard let open = string.range(of: \"[\"\
    ),\n        let close = string.range(of: \"]\"),\n        let open2 = string.range(of:\
    \ \"[\", options: .backwards),\n        let close2 = string.range(of: \"]\", options:\
    \ .backwards) else {\n            return false\n    }\n    return open < close\
    \ && open2 < close2", "    guard let openingBracketIndex = string.index(of: \"\
    [\"),\n        let closingBracketIndex = string.index(of: \"]\"),\n        openingBracketIndex\
    \ != closingBracketIndex else {\n            return false\n    }\n    let openingBracket\
    \ = string[openingBracketIndex..<closingBracketIndex]\n    let closingBracket\
    \ = string[closingBracketIndex..<string.endIndex]\n    let openingBracketCount\
    \ = openingBracket.count\n    let closingBracketCount = closingBracket.count\n\
    \    if openingBracketCount > closingBracketCount {\n        return false\n  \
    \  }\n    let openingBracketIndex = string.index(of: \"[\", offsetBy: 1)\n   \
    \ let closingBracketIndex = string.index(of: \"]\", offsetBy: 1)\n    let openingBracket\
    \ = string[openingBracketIndex..<closingBracketIndex]\n    let closingBracket\
    \ = string[closingBracketIndex..<string.endIndex]\n    let openingBracketCount\
    \ = openingBracket.count\n    let closingBracketCount = closingBracket.count\n\
    \    if openingBracketCount > closingBracketCount {\n        return false\n  \
    \  }\n    return true", "    let brackets = string.unicodeScalars\n        .filter({$0\
    \ >= 0x5B && $0 <= 0x5D})\n        .filter({$0 >= 0x7B && $0 <= 0x7D})\n     \
    \   .filter({$0 >= 0x5B && $0 <= 0x5D})\n        .filter({$0 >= 0x7B && $0 <=\
    \ 0x7D})\n        .filter({$0 >= 0x5B && $0 <= 0x5D})\n        .filter({$0 >=\
    \ 0x7B && $0 <= 0x7D})\n        .filter({$0 >= 0x5B && $0 <= 0x5D})\n        .filter({$0\
    \ >= 0x7B && $0 <= 0x7D})\n        .filter({$0 >= 0x5B && $0 <= 0x5D})\n     \
    \   .filter({$0 >= 0x7B && $0 <= 0x7D})\n        .filter({$0 >= 0x5B && $0 <=\
    \ 0x5D})\n        .filter({$0 >= 0x7B && $0 <= 0x7D})\n        .filter({$0 >=\
    \ 0x5B && $0 <= 0x5D})\n        .filter({$0 >= 0x7B && $0 <= 0x7D})\n        .filter({$0\
    \ >= 0x5B && $0 <= 0x5D})\n        .filter({$0 >= 0x7B && $0 <= 0x7D})\n     \
    \   .filter({$0 >= 0x5B && $0 <= 0x5D})\n        .filter({$0 >= 0x7B && $0 <=\
    \ 0x7D})\n        .filter({$0 >= 0x5B && $0 <= 0x5D})\n        .filter({$0 >=\
    \ 0x7B && $0 <= 0x7D})\n        .filter({$0 >= 0x5B && $0 <= 0x5D})\n        .filter({$0\
    \ >= 0x7B && $0 <= 0x7D})\n        .filter({$0 >= 0x5B && $0 <= 0x5D})\n     \
    \   .filter({$0 >= 0x7B && $0 <= 0x7D})\n        .filter({$0 >= 0x5B && $0 <=\
    \ 0x5D})\n        .filter({$0 >= 0x7B && $0 <= 0x7D})\n        .filter({$0 >=\
    \ 0x5B && $0 <= 0x5D})\n        .filter({$0 >= 0x7B && $0 <= 0x7D})\n        .filter({$0\
    \ >= 0x5B && $0 <= 0x5D})\n        .filter({$0 >= 0x7B && $0 <= 0x7D})\n     \
    \   .filter({$0 >= 0x5B && $0 <= 0x5D})\n        .filter({$0 >= 0x7B && $0 <=\
    \ 0x7D})\n        .filter({$0 >= 0x5B && $0 <= 0x5D})\n        .filter({$0 >=\
    \ 0x7B && ", "    \n    let stack = Stack()\n    \n    for char in string {\n\
    \        \n        if char == '[' {\n            stack.push(char)\n        }\n\
    \        \n        if char == ']' {\n            \n            if stack.count\
    \ > 0 {\n                \n                if stack.peek() == '[' {\n        \
    \            stack.pop()\n                } else {\n                    return\
    \ false\n                }\n            } else {\n                return false\n\
    \            }\n        }\n    }\n    \n    return stack.count == 0", "    let\
    \ stack = Stack()\n    for char in string {\n        if char == '[' {\n      \
    \      stack.push(char)\n        } else if char == ']' {\n            if stack.count\
    \ > 0 {\n                stack.pop()\n            } else {\n                return\
    \ false\n            }\n        }\n    }\n    return stack.count == 0", "    let\
    \ stack = Stack<String>()\n    stack.push(string)\n    \n    while stack.count\
    \ > 0 {\n        let top = stack.pop()\n        \n        if top == \"[\" || top\
    \ == \"{\" || top == \"(\" || top == \"<\" {\n            return true\n      \
    \  }\n        \n        if top == \"]\" || top == \"]}\" || top == \"]>\" || top\
    \ == \">\" {\n            return false\n        }\n        \n        if top ==\
    \ \"}\" || top == \"}>\" || top == \">}\" {\n            return false\n      \
    \  }\n        \n        if top == \"]>\" || top == \">>\" {\n            return\
    \ false\n        }\n        \n        if top == \"[\" || top == \"{\" || top ==\
    \ \"(\" || top == \"<\" {\n            return false\n        }\n        \n   \
    \     if top == \"]\" || top == \"]}\" || top == \"]>\" || top == \">\" {\n  \
    \          return false\n        }\n        \n        if top == \"}\" || top ==\
    \ \"}>\" || top == \">}\" {\n            return false\n        }\n        \n \
    \       if top == \"]>\" || top == \">>\" {\n            return false\n      \
    \  }\n        \n        if top == \"<\" || top == \"<}\" || top == \"<<\" {\n\
    \            return false\n        }\n        \n        if top == \">\" || top\
    \ == \">>\" {\n            return false\n        }\n        \n        if top ==\
    \ \"{\" || top == \"}\" || top == \"}\" || top == \"}\" {\n            return\
    \ false\n        }\n        \n        if top == \"(\" || top == \"(}\" || top\
    \ == \"(>\" || top == \"(>}\" {\n            return false\n        }\n       \
    \ \n        if top == \"<\" || top == \"<}\" || top == \"<<\" {\n            return\
    \ false\n        }\n        \n        if top == \">\" || top == \">>\" {\n   \
    \         return false\n        }\n        \n        if top == \"[\" || top ==\
    \ \"[}\" || top == \"[>\" || top == \"[>}\" {\n            return false\n    \
    \    }\n        \n        if top == \"{\" || top == \"}\" || top == \"}\" || top\
    \ == \"}\" {\n            return false\n        }\n        \n        if top ==\
    \ \"(\" || top == \"(}\" || top == \"(>\" || top == \"(>}\" {\n            return\
    \ false\n        }\n        \n        if top == \"<\" || top == \"<}\" || top\
    \ == \"<<\" {\n            return false\n        }\n        \n        if top ==\
    \ \">\" || top == \">>\" {\n            return false\n        }\n        \n  \
    \      if top == \"[\" || top == \"[}\" || top == \"[>\" || top == \"[>}\" {\n\
    \            return false\n        }\n        ", "    guard let start = string.index(of:\
    \ \"[\"),\n        let end = string.index(of: \"]\"),\n        start != end,\n\
    \        start != string.endIndex,\n        end != string.startIndex,\n      \
    \  start < end else { return false }\n    \n    var open = 0\n    var close =\
    \ 0\n    var nesting = 0\n    \n    for index in string.indices {\n        guard\
    \ let c = string[index],\n            open == close else { continue }\n      \
    \  \n        switch c {\n        case \"[\": open += 1\n        case \"]\": close\
    \ += 1\n        default: nesting += 1\n        }\n    }\n    \n    return nesting\
    \ == 1", "    guard let index = string.index(of: \"[\"),\n        let end = string.index(of:\
    \ \"]\", from: index) else {\n            return false\n    }\n    \n    let start\
    \ = index + 1\n    let end = string.index(of: \"]\", from: index)\n    \n    return\
    \ start < end", "    guard let open = string.rangeOfString(\"[\", options: .LiteralSearch,\
    \ range: nil, locale: nil),\n        let close = string.rangeOfString(\"]\", options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n            return false\n\
    \    }\n    return open < close", "\tlet stack = Stack()\n\tlet openingBrackets\
    \ = string.unicodeScalars.filter({ $0.isOpen })\n\tlet closingBrackets = string.unicodeScalars.filter({\
    \ $0.isClosing })\n\t\n\topeningBrackets.forEach { stack.push(it) }\n\tclosingBrackets.forEach\
    \ { stack.push(it) }\n\t\n\treturn stack.count == 0", "    guard let openBracket\
    \ = string.rangeOfString(\"[\", options: .BackwardsSearch) else {\n        return\
    \ false\n    }\n    guard let closeBracket = string.rangeOfString(\"]\", options:\
    \ .BackwardsSearch) else {\n        return false\n    }\n    guard openBracket.location\
    \ < closeBracket.location else {\n        return false\n    }\n    guard openBracket.location\
    \ != string.startIndex else {\n        return false\n    }\n    guard closeBracket.location\
    \ != string.endIndex else {\n        return false\n    }\n    guard openBracket.location\
    \ < closeBracket.location else {\n        return false\n    }\n    guard openBracket.location\
    \ != string.startIndex else {\n        return false\n    }\n    guard closeBracket.location\
    \ != string.endIndex else {\n        return false\n    }\n    guard openBracket.location\
    \ < closeBracket.location else {\n        return false\n    }\n    guard openBracket.location\
    \ != string.startIndex else {\n        return false\n    }\n    guard closeBracket.location\
    \ != string.endIndex else {\n        return false\n    }\n    guard openBracket.location\
    \ < closeBracket.location else {\n        return false\n    }\n    guard openBracket.location\
    \ != string.startIndex else {\n        return false\n    }\n    guard closeBracket.location\
    \ != string.endIndex else {\n        return false\n    }\n    guard openBracket.location\
    \ < closeBracket.location else {\n        return false\n    }\n    guard openBracket.location\
    \ != string.startIndex else {\n        return false\n    }\n    guard closeBracket.location\
    \ != string.endIndex else {\n        return false\n    }\n    guard openBracket.location\
    \ < closeBracket.location else {\n        return false\n    }\n    guard openBracket.location\
    \ != string.startIndex else {\n        return false\n    }\n    guard closeBracket.location\
    \ != string.endIndex else {\n        return false\n    }\n    guard openBracket.location\
    \ < closeBracket.location else {\n        return false\n    }\n    guard openBracket.location\
    \ != string.startIndex else {\n        return false\n    }\n    guard closeBracket.location\
    \ != string.endIndex else {\n        return false\n    }\n    guard openBracket.location\
    \ < closeBracket.location else {\n        return false\n    }\n    guard openBracket.location\
    \ != string.startIndex else {\n        return false\n    }\n    guard ", "   \
    \ let openingBrackets = string.unicodeScalars.filter({ $0.isOpen })\n    let closingBrackets\
    \ = string.unicodeScalars.filter({ $0.isClosing })\n    \n    return openingBrackets.count\
    \ >= closingBrackets.count", "    let stack = Stack()\n    for char in string\
    \ {\n        if char == '[' {\n            stack.push(char)\n        } else if\
    \ char == ']' {\n            if stack.count > 0 {\n                stack.pop()\n\
    \            } else {\n                return false\n            }\n        }\n\
    \    }\n    return stack.count == 0", "    guard let openBracketIndex = string.firstIndex(of:\
    \ \"[\"),\n        let closeBracketIndex = string.lastIndex(of: \"]\"),\n    \
    \    openBracketIndex != closeBracketIndex else {\n            return false\n\
    \    }\n    let openBracket = string[openBracketIndex..<closeBracketIndex]\n \
    \   let closeBracket = string[closeBracketIndex..<string.endIndex]\n    return\
    \ openBracket.count > 0 && closeBracket.count > 0 && openBracket == closeBracket",
  "\tlet stack = Stack<String>()\n\tlet openingBrackets = Set<String>()\n\tlet closingBrackets\
    \ = Set<String>()\n\tlet openingBracketsCount = stack.count\n\tlet closingBracketsCount\
    \ = stack.count\n\t\n\tlet openingBracketsString = stack.last!\n\tlet closingBracketsString\
    \ = stack.last!\n\t\n\tlet openingBracketsStringCount = openingBracketsString.count\n\
    \tlet closingBracketsStringCount = closingBracketsString.count\n\t\n\tlet openingBracketsStringLastIndex\
    \ = openingBracketsString.last!.characters.count\n\tlet closingBracketsStringLastIndex\
    \ = closingBracketsString.last!.characters.count\n\t\n\tlet openingBracketsStringLastIndexCount\
    \ = openingBracketsStringLastIndex\n\tlet closingBracketsStringLastIndexCount\
    \ = closingBracketsStringLastIndex\n\t\n\tlet openingBracketsStringLastIndexLastIndex\
    \ = openingBracketsStringLastIndex\n\tlet closingBracketsStringLastIndexLastIndex\
    \ = closingBracketsStringLastIndex\n\t\n\tlet openingBracketsStringLastIndexLastIndexCount\
    \ = openingBracketsStringLastIndexLastIndex\n\tlet closingBracketsStringLastIndexLastIndexCount\
    \ = closingBracketsStringLastIndexLastIndex\n\t\n\tlet openingBracketsStringLastIndexLastIndexLastIndexCount\
    \ = openingBracketsStringLastIndexLastIndexLastIndex\n\tlet closingBracketsStringLastIndexLastIndexLastIndexCount\
    \ = closingBracketsStringLastIndexLastIndexLastIndex\n\t\n\tlet openingBracketsStringLastIndexLastIndexLastIndexLastIndexCount\
    \ = openingBracketsStringLastIndexLastIndexLastIndexLastIndex\n\tlet closingBracketsStringLastIndexLastIndexLastIndexLastIndexCount\
    \ = closingBracketsStringLastIndexLastIndexLastIndexLastIndex\n\t\n\tlet openingBracketsStringLastIndexLastIndexLastIndexLastIndexLastIndexCount\
    \ = openingBracketsStringLastIndexLastIndexLastIndexLastIndexLastIndex\n\tlet\
    \ closingBracketsStringLastIndexLastIndexLastIndexLastIndexCount = closingBracketsStringLastIndexLastIndexLastIndexLastIndex\n\
    \t\n\tlet openingBracketsStringLastIndexLastIndexLastIndexLastIndexLastIndexCount\
    \ = openingBracketsStringLastIndexLastIndexLastIndexLastIndex", "    guard let\
    \ openingBracket = string.rangeOfString(\"[\"),\n        let closingBracket =\
    \ string.rangeOfString(\"]\") else {\n            return false\n    }\n    let\
    \ openingBracketIndex = string.index(openingBracket, offsetBy: 1)\n    let closingBracketIndex\
    \ = string.index(closingBracket, offsetBy: 1)\n    let openingBracketLength =\
    \ openingBracketIndex.distanceTo(openingBracket)\n    let closingBracketLength\
    \ = closingBracketIndex.distanceTo(closingBracket)\n    let openingBracketsCount\
    \ = openingBracketLength / 2\n    let closingBracketsCount = closingBracketLength\
    \ / 2\n    let openingBracketsCountInMiddle = openingBracketsCount - closingBracketsCount\n\
    \    let closingBracketsCountInMiddle = closingBracketsCount - openingBracketsCount\n\
    \    if openingBracketsCountInMiddle == closingBracketsCountInMiddle {\n     \
    \   return true\n    }\n    return false", "    guard let start = string.index(of:\
    \ \"[\"),\n        let end = string.index(of: \"]\"),\n        start < end else\
    \ { return false }\n    let nested = string.substring(from: start + 1, to: end\
    \ - 1)\n    return nested.characters.count >= 2", "    let brackets = string.unicodeScalars\n\
    \        .filter { $0 >= 0x5B && $0 <= 0x5D }\n        .filter { $0 != 0x5D }\n\
    \        .filter { $0 != 0x5C }\n        .filter { $0 != 0x5B }\n        .map\
    \ { String($0) }\n        .reduce(\"\") { $0 + String($1) + String($2) }\n   \
    \ return brackets.rangeOfString(\"[[\", options: .BackwardsSearch) != nil", " \
    \   let brackets = string.unicodeScalars\n        .filter { $0 != '[' }\n    \
    \    .filter { $0 != ']' }\n        .filter { $0 != '{' }\n        .filter { $0\
    \ != '}' }\n        .filter { $0 != '(' }\n        .filter { $0 != ')' }\n   \
    \ return brackets.count > 0", "\tlet openBrackets = string.rangeOfString(\"[\"\
    )\n\tlet closeBrackets = string.rangeOfString(\"]\")\n\t\n\tif openBrackets ==\
    \ nil || closeBrackets == nil {\n\t\treturn false\n\t}\n\t\n\tlet openBracketsCount\
    \ = openBrackets!.location - openBrackets!.startIndex\n\tlet closeBracketsCount\
    \ = closeBrackets!.location - closeBrackets!.startIndex\n\t\n\tif openBracketsCount\
    \ < closeBracketsCount {\n\t\treturn false\n\t}\n\t\n\tlet openBracketsString\
    \ = string.substringWithRange(openBrackets!)\n\tlet closeBracketsString = string.substringWithRange(closeBrackets!)\n\
    \t\n\treturn openBracketsString.rangeOfString(closeBracketsString) != nil", " \
    \   if string == \"\" {\n        return false\n    }\n    var stack = [String]()\n\
    \    var openBrackets = 0\n    var closeBrackets = 0\n    for char in string {\n\
    \        if char == '[' {\n            openBrackets += 1\n            stack.append(char)\n\
    \        } else if char == ']' {\n            closeBrackets += 1\n           \
    \ if openBrackets > closeBrackets {\n                return false\n          \
    \  }\n            openBrackets -= 1\n            stack.removeLast()\n        }\
    \ else if char == ']' && openBrackets == closeBrackets {\n            return true\n\
    \        }\n    }\n    return false", "\tlet openBrackets = string.count(\"[\"\
    )\n\tlet closeBrackets = string.count(\"]\")\n\t\n\tif openBrackets == closeBrackets\
    \ {\n\t\treturn true\n\t}\n\t\n\treturn false", "    let stack = Stack()\n   \
    \ for char in string {\n        if char == '[' {\n            stack.push(char)\n\
    \        } else if char == ']' {\n            if stack.isEmpty {\n           \
    \     return false\n            }\n            let top = stack.top()\n       \
    \     if top != '[' {\n                return false\n            }\n         \
    \   stack.pop()\n        } else {\n            return false\n        }\n    }\n\
    \    return stack.isEmpty", "    guard let start = string.index(of: \"[\"),\n\
    \        let end = string.index(of: \"]\"),\n        start != end,\n        let\
    \ start = string.index(of: \"[\", range: start..<end),\n        let end = string.index(of:\
    \ \"]\", range: start..<end),\n        start != end,\n        let start = string.index(of:\
    \ \"[\", range: start..<end),\n        let end = string.index(of: \"]\", range:\
    \ start..<end),\n        start != end,\n        let start = string.index(of: \"\
    [\", range: start..<end),\n        let end = string.index(of: \"]\", range: start..<end),\n\
    \        start != end,\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        start\
    \ != end,\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        start\
    \ != end,\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        start\
    \ != end,\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        start\
    \ != end,\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        start\
    \ != end,\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        start\
    \ != end,\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        start\
    \ != end,\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        start\
    \ != end,\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        start\
    \ != end,\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<", "    guard let start\
    \ = string.index(of: \"[\"),\n        let end = string.index(of: \"]\"),\n   \
    \     start < end else {\n            return false\n    }\n    let start = string.index(before:\
    \ start)\n    let end = string.index(before: end)\n    let nested = string[start..<end]\n\
    \    return nested.contains(\"[\")", "    guard let start = string.index(of: \"\
    [\"),\n        let end = string.index(of: \"]\"),\n        let start = string.index(of:\
    \ \"[\", range: start...end),\n        let end = string.index(of: \"]\", range:\
    \ start...end),\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        let start\
    \ = string.index(of: \"[\", range: start..<end),\n        let end = string.index(of:\
    \ \"]\", range: start..<end),\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n        let end = string.index(of: \"]\", range: start..<end),\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        let start = string.index(of:\
    \ \"[\", range: start..<end),\n        let end = string.index(of: \"]\", range:\
    \ start..<end),\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        let start\
    \ = string.index(of: \"[\", range: start..<end),\n        let end = string.index(of:\
    \ \"]\", range: start..<end),\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n        let end = string.index(of: \"]\", range: start..<end),\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        let start = string.index(of:\
    \ \"[\", range: start..<end),\n        let end = string.index(of: \"]\", range:\
    \ start..<end),\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        let start\
    \ = string.index(of: \"[\", range: start..<end),\n        let end = string.index(of:\
    \ \"]\", range: start..<end),\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n        let end = string.index(of: \"]\", range: start..<end),\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        let start = string.index(of:\
    \ \"[\", range: start..<", "    \n    // Your code here\n    \n    return true",
  "    guard let openingBracket = string.firstIndex(of: \"[\"),\n        let closingBracket\
    \ = string.lastIndex(of: \"]\"),\n        openingBracket != closingBracket else\
    \ {\n            return false\n    }\n    let openingBracketIndex = string.index(string.startIndex,\
    \ offsetBy: openingBracket)\n    let closingBracketIndex = string.index(string.startIndex,\
    \ offsetBy: closingBracket + 1)\n    let nestedBrackets = string.substring(from:\
    \ openingBracketIndex, to: closingBracketIndex).count\n    return nestedBrackets\
    \ > 0", "    var openingBracketCount = 0\n    var closingBracketCount = 0\n  \
    \  var openingBracketCountStack = [Int]()\n    var closingBracketCountStack =\
    \ [Int]()\n    for ch in string {\n        switch ch {\n        case '[':\n  \
    \          openingBracketCountStack.append(openingBracketCount)\n            openingBracketCount++\n\
    \        case ']':\n            closingBracketCountStack.append(closingBracketCount)\n\
    \            closingBracketCount++\n        default:\n            if openingBracketCount\
    \ > 0 && closingBracketCount > 0 {\n                if openingBracketCount > closingBracketCount\
    \ {\n                    return false\n                }\n                if openingBracketCountStack.last\
    \ < closingBracketCountStack.last {\n                    return false\n      \
    \          }\n            }\n        }\n    }\n    return openingBracketCount\
    \ == closingBracketCount", "    if string == \"\" {\n        return false\n  \
    \  }\n    var openBrackets = 0\n    var closeBrackets = 0\n    var openBracketsStack\
    \ = [String]()\n    var closeBracketsStack = [String]()\n    for char in string\
    \ {\n        if char == \"[\" {\n            openBracketsStack.append(char)\n\
    \            openBrackets++\n        } else if char == \"]\" {\n            closeBracketsStack.append(char)\n\
    \            closeBrackets++\n        } else if char == \"]\" && openBrackets\
    \ > 0 && closeBrackets == 0 {\n            openBracketsStack.removeLast()\n  \
    \          closeBracketsStack.removeLast()\n            openBrackets--\n     \
    \   } else if char == \"[\" && openBrackets == 0 && closeBrackets > 0 {\n    \
    \        openBracketsStack.removeLast()\n            closeBracketsStack.removeLast()\n\
    \            openBrackets++\n        }\n    }\n    return openBrackets == 0 &&\
    \ closeBrackets == 0", "    var stack = [String]()\n    var open = 0\n    for\
    \ idx, char in enumerate(string) {\n        if char == '[' {\n            open\
    \ += 1\n            stack.append(char)\n        } else if char == ']' {\n    \
    \        open -= 1\n            if open == 0 {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return open > 0", '    guard let pattern
    = try? NSRegularExpression(pattern: "\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\[\\',
  "    guard let openBracket = string.index(of: \"[\"),\n        let closeBracket\
    \ = string.index(of: \"]\"),\n        openBracket < closeBracket else { return\
    \ false }\n    \n    var openBracketCount = 0\n    var closeBracketCount = 0\n\
    \    \n    for index in string.indices {\n        guard let character = string[index],\n\
    \            character == \"[\" else { continue }\n        openBracketCount +=\
    \ 1\n        \n        guard let nextIndex = string.index(index, offsetBy: 1),\n\
    \            string[nextIndex] == \"]\" else { continue }\n        closeBracketCount\
    \ += 1\n    }\n    \n    return openBracketCount == closeBracketCount", "    var\
    \ stack = [String]()\n    var open = 0\n    var close = 0\n    for i := 0; i <\
    \ len(string); i++ {\n        if string[i] == '[' {\n            stack.append(string[i])\n\
    \            open++\n        } else if string[i] == ']' {\n            close++\n\
    \            if close == open {\n                stack.removeLast()\n        \
    \    }\n        } else if string[i] == '[' {\n            open++\n        } else\
    \ if string[i] == ']' {\n            close++\n        }\n    }\n    return stack.isEmpty",
  "    let brackets = string.unicodeScalars\n        .filter { $0 != '[' }\n     \
    \   .filter { $0 != ']' }\n        .filter { $0 != '{' }\n        .filter { $0\
    \ != '}' }\n        .filter { $0 != '(' }\n        .filter { $0 != ')' }\n   \
    \ return brackets.count > 0", "    guard let start = string.index(of: \"[\"),\n\
    \        let end = string.index(of: \"]\"),\n        let start = string.index(of:\
    \ \"[\", range: start..<end),\n        let end = string.index(of: \"]\", range:\
    \ start..<end),\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        let start\
    \ = string.index(of: \"[\", range: start..<end),\n        let end = string.index(of:\
    \ \"]\", range: start..<end),\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n        let end = string.index(of: \"]\", range: start..<end),\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        let start = string.index(of:\
    \ \"[\", range: start..<end),\n        let end = string.index(of: \"]\", range:\
    \ start..<end),\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        let start\
    \ = string.index(of: \"[\", range: start..<end),\n        let end = string.index(of:\
    \ \"]\", range: start..<end),\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n        let end = string.index(of: \"]\", range: start..<end),\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        let start = string.index(of:\
    \ \"[\", range: start..<end),\n        let end = string.index(of: \"]\", range:\
    \ start..<end),\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        let start\
    \ = string.index(of: \"[\", range: start..<end),\n        let end = string.index(of:\
    \ \"]\", range: start..<end),\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n        let end = string.index(of: \"]\", range: start..<end),\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        let start = string.index(of:\
    \ \"[\", range: start.", "    guard let openingBracket = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil) else {\n        return\
    \ false\n    }\n    guard let closingBracket = string.rangeOfString(\"]\", options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n        return false\n    }\n\
    \    guard let openingBracketIndex = string.index(of: openingBracket, options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n        return false\n    }\n\
    \    guard let closingBracketIndex = string.index(of: closingBracket, options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n        return false\n    }\n\
    \    guard openingBracketIndex != closingBracketIndex else {\n        return false\n\
    \    }\n    guard openingBracketIndex < closingBracketIndex else {\n        return\
    \ false\n    }\n    guard let openingBracket = string.substring(from: openingBracketIndex,\
    \ length: openingBracketIndex - openingBracketIndex + 1) else {\n        return\
    \ false\n    }\n    guard let closingBracket = string.substring(from: closingBracketIndex,\
    \ length: closingBracketIndex - openingBracketIndex + 1) else {\n        return\
    \ false\n    }\n    guard openingBracket == \"[\" else {\n        return false\n\
    \    }\n    guard closingBracket == \"]\" else {\n        return false\n    }\n\
    \    return true", "    \n    let stack = Stack()\n    \n    for char in string\
    \ {\n        \n        if char == '[' {\n            stack.push(char)\n      \
    \  } else if char == ']' {\n            if stack.top() == '[' {\n            \
    \    stack.pop()\n            } else {\n                return false\n       \
    \     }\n        }\n    }\n    \n    return stack.empty()", "    var stack = [String]()\n\
    \    var openBrackets = 0\n    var closeBrackets = 0\n    var openBracketsCount\
    \ = 0\n    var closeBracketsCount = 0\n    for char in string {\n        if char\
    \ == '[' {\n            openBracketsCount += 1\n            stack.append(char)\n\
    \        } else if char == ']' {\n            closeBracketsCount += 1\n      \
    \      if openBracketsCount == closeBracketsCount {\n                if openBrackets\
    \ == closeBrackets {\n                    return true\n                }\n   \
    \             openBracketsCount -= 1\n                closeBracketsCount -= 1\n\
    \                openBrackets -= 1\n                closeBrackets += 1\n     \
    \       } else {\n                openBracketsCount -= 1\n            }\n    \
    \        stack.removeLast()\n        } else if char == '[' {\n            openBrackets\
    \ += 1\n        } else if char == ']' {\n            closeBrackets += 1\n    \
    \    }\n    }\n    return false", "    \n    // Your code here\n    \n    return\
    \ true", "    guard let openingBracket = string.rangeOfString(\"[\", options:\
    \ .BackwardsSearch) else {\n        return false\n    }\n    guard let closingBracket\
    \ = string.rangeOfString(\"]\", options: .BackwardsSearch) else {\n        return\
    \ false\n    }\n    guard openingBracket.location < closingBracket.location else\
    \ {\n        return false\n    }\n    guard openingBracket.location > 0 else {\n\
    \        return false\n    }\n    guard closingBracket.location < string.characters.count\
    \ else {\n        return false\n    }\n    guard closingBracket.location > openingBracket.location\
    \ else {\n        return false\n    }\n    guard let openingBracketIndex = string.characters.index(of:\
    \ openingBracket.character) else {\n        return false\n    }\n    guard let\
    \ closingBracketIndex = string.characters.index(of: closingBracket.character)\
    \ else {\n        return false\n    }\n    guard openingBracketIndex < closingBracketIndex\
    \ else {\n        return false\n    }\n    guard openingBracketIndex < string.characters.count\
    \ - 1 else {\n        return false\n    }\n    guard let openingBracket = string.characters[openingBracketIndex\
    \ + 1] else {\n        return false\n    }\n    guard let closingBracket = string.characters[closingBracketIndex\
    \ - 1] else {\n        return false\n    }\n    guard openingBracket == \"[\"\
    \ && closingBracket == \"]\" else {\n        return false\n    }\n    return true",
  "    let stack = Stack()\n    for char in string {\n        if char == '[' {\n \
    \           stack.push(char)\n        } else if char == ']' {\n            if\
    \ stack.top() == '[' {\n                stack.pop()\n            } else {\n  \
    \              return false\n            }\n        } else {\n            return\
    \ false\n        }\n    }\n    return stack.empty()", "    guard let start = string.index(of:\
    \ \"[\"),\n        let end = string.index(of: \"]\"),\n        start < end else\
    \ { return false }\n    var open = 0\n    var close = 0\n    var nesting = 0\n\
    \    for index in string.indices {\n        if string[index] == \"]\" {\n    \
    \        close--\n            if close < 0 {\n                nesting++\n    \
    \            close = open\n            }\n        } else if string[index] == \"\
    [\" {\n            open++\n            if open < 0 {\n                nesting++\n\
    \                open = close\n            }\n        }\n    }\n    return nesting\
    \ > 0", "    var stack = [String]()\n    var openingBrackets = 0\n    for char\
    \ in string {\n        if char == '[' {\n            stack.append(char)\n    \
    \        openingBrackets += 1\n        } else if char == ']' {\n            if\
    \ openingBrackets > 0 {\n                openingBrackets -= 1\n            } else\
    \ {\n                return false\n            }\n        }\n    }\n    return\
    \ openingBrackets == 0", "    guard let start = string.index(of: \"[\"),\n   \
    \     let end = string.index(of: \"]\"),\n        start != end,\n        start\
    \ < string.endIndex,\n        end > string.startIndex\n        else { return false\
    \ }\n    \n    var openingBracketCount = 0\n    var closingBracketCount = 0\n\
    \    var openingBracket: Character?\n    var closingBracket: Character?\n    \n\
    \    for char in string.characters {\n        if char == \"[\" {\n           \
    \ openingBracketCount += 1\n            openingBracket = char\n        } else\
    \ if char == \"]\" {\n            closingBracketCount += 1\n            closingBracket\
    \ = char\n        }\n    }\n    \n    return openingBracketCount > 0 && closingBracketCount\
    \ > 0 && openingBracketCount < closingBracketCount", "    var openingBrackets\
    \ = 0\n    var closingBrackets = 0\n    var openingBracketsStack = [String]()\n\
    \    var closingBracketsStack = [String]()\n    \n    for char in string {\n \
    \       switch char {\n        case '[':\n            openingBracketsStack.append(char)\n\
    \            openingBrackets++\n        case ']':\n            closingBracketsStack.append(char)\n\
    \            closingBrackets++\n        default:\n            if openingBrackets\
    \ == 0 {\n                if closingBrackets == 0 {\n                    return\
    \ false\n                }\n                \n                closingBracketsStack.removeLast()\n\
    \                closingBrackets--\n            } else {\n                openingBracketsStack.removeLast()\n\
    \                openingBrackets--\n            }\n        }\n    }\n    \n  \
    \  return openingBrackets == 0 && closingBrackets == 0", "    guard let start\
    \ = string.index(of: \"[\"), let end = string.index(of: \"]\") else {\n      \
    \  return false\n    }\n    return string.distance(from: start, to: end) == 1\
    \ && is_nested(string[start..<end])", "    if string == \"\" {\n        return\
    \ false\n    }\n    var openingBracketCount = 0\n    var closingBracketCount =\
    \ 0\n    var openingBracket: Int = 0\n    var closingBracket: Int = 0\n    var\
    \ openingBracketCountInString = 0\n    var closingBracketCountInString = 0\n \
    \   var openingBracketInString: Int = 0\n    var closingBracketInString: Int =\
    \ 0\n    var openingBracketCountInStringInString = 0\n    var closingBracketCountInStringInString\
    \ = 0\n    var openingBracketInStringInString: Int = 0\n    var closingBracketInStringInString:\
    \ Int = 0\n    var openingBracketCountInStringInStringInString = 0\n    var closingBracketCountInStringInStringInString\
    \ = 0\n    var openingBracketInStringInStringInString: Int = 0\n    var closingBracketInStringInStringInString:\
    \ Int = 0\n    var openingBracketCountInStringInStringInStringInString = 0\n \
    \   var closingBracketCountInStringInStringInStringInString = 0\n    var openingBracketInStringInStringInStringInString:\
    \ Int = 0\n    var closingBracketInStringInStringInStringInString: Int = 0\n \
    \   var openingBracketCountInStringInStringInStringInStringInString = 0\n    var\
    \ closingBracketCountInStringInStringInStringInStringInString = 0\n    var openingBracketInStringInStringInStringInStringInString:\
    \ Int = 0\n    var closingBracketInStringInStringInStringInStringInStringInString:\
    \ Int = 0\n    var openingBracketCountInStringInStringInStringInStringInStringInString\
    \ = 0\n    var closingBracketCountInStringInStringInStringInStringInStringInString\
    \ = 0\n    var openingBracketInStringInStringInStringInStringInStringInStringInString:\
    \ Int = 0\n    var closingBracketInStringInStringInStringInStringInStringInStringInStringInString:\
    \ Int = 0\n    var openingBracketCountInStringInStringInStringInStringInStringInStringInStringInString\
    \ = 0\n    var closingBracketCountInStringInStringInStringInStringInStringInStringInStringInString\
    \ = 0\n    var openingBracketInStringInStringInStringInStringInStringInStringInStringInStringInString:\
    \ Int = 0\n    var closingBracketInStringInStringInStringInStringInStringInStringInStringInStringInStringInString:\
    \ Int = 0", "    var stack = [String]()\n    for ch in string {\n        if ch\
    \ == '[' {\n            stack.append(String(ch))\n        } else if ch == ']'\
    \ {\n            if stack.isEmpty {\n                return false\n          \
    \  }\n            stack.removeLast()\n        } else if ch == '[' {\n        \
    \    stack.append(String(ch))\n        } else if ch == ']' {\n            if stack.isEmpty\
    \ {\n                return false\n            }\n            stack.removeLast()\n\
    \        } else if stack.isEmpty {\n            return false\n        }\n    }\n\
    \    return stack.isEmpty", "\tlet stack = Stack()\n\tlet openBrackets = Set<Character>()\n\
    \tlet closeBrackets = Set<Character>()\n\t\n\tlet openBracketsCount = stack.count\n\
    \t\n\tfor char in string {\n\t\tif char == '[' {\n\t\t\topenBrackets.insert(char)\n\
    \t\t} else if char == ']' {\n\t\t\tcloseBrackets.insert(char)\n\t\t} else {\n\t\
    \t\tstack.append(char)\n\t\t}\n\t}\n\t\n\tlet closeBracketsCount = stack.count\n\
    \t\n\tif openBracketsCount != closeBracketsCount {\n\t\treturn false\n\t}\n\t\n\
    \tlet openBracketsStack = stack.copy() as! [Character]\n\t\n\twhile openBracketsStack.count\
    \ > 0 {\n\t\tlet openBracket = openBracketsStack.removeLast()\n\t\t\n\t\tif openBracketsStack.contains(openBracket)\
    \ {\n\t\t\treturn false\n\t\t}\n\t\t\n\t\tif openBrackets.contains(openBracket)\
    \ {\n\t\t\treturn false\n\t\t}\n\t\t\n\t\topenBracketsStack.append(openBracket)\n\
    \t}\n\t\n\treturn true", "    guard let range = string.range(of: \"[[]]\") else\
    \ {\n        return false\n    }\n    \n    let start = string.index(range.lowerBound,\
    \ offsetBy: 1)\n    let end = string.index(range.upperBound, offsetBy: 1)\n  \
    \  \n    return start < end", "    var stack = [String]()\n    var open = 0\n\
    \    var close = 0\n    for i := 0; i < len(string); i++ {\n        if string[i]\
    \ == '[' {\n            stack.append(string[i])\n            open++\n        }\
    \ else if string[i] == ']' {\n            close++\n            if open > close\
    \ {\n                return false\n            }\n            open--\n       \
    \ } else {\n            if open > close {\n                return false\n    \
    \        }\n        }\n    }\n    return open > close", "    guard let open =\
    \ string.index(of: \"[\"),\n        let close = string.index(of: \"]\"),\n   \
    \     open != close else {\n        return false\n    }\n    let openBracketCount\
    \ = string.distance(from: open, to: close)\n    let closeBracketCount = string.distance(from:\
    \ close, to: open)\n    return openBracketCount != closeBracketCount", "    guard\
    \ let start = string.index(of: \"[\"), let end = string.index(of: \"]\"), let\
    \ range = start..end else { return false }\n    return string.range(of: \"[\"\
    , options: .backwards)?.lowerBound == range.lowerBound && string.range(of: \"\
    ]\", options: .backwards)?.upperBound == range.upperBound", "    var stack = [String]()\n\
    \    var open = 0\n    var close = 0\n    var i = 0\n    var j = 0\n    var openingBrackets\
    \ = 0\n    var closingBrackets = 0\n    var openingBracketsCount = 0\n    var\
    \ closingBracketsCount = 0\n    var openingBracketsCountBefore = 0\n    var closingBracketsCountBefore\
    \ = 0\n    var openingBracketsCountAfter = 0\n    var closingBracketsCountAfter\
    \ = 0\n    var openingBracketsCountBeforeAfter = 0\n    var closingBracketsCountBeforeAfter\
    \ = 0\n    var openingBracketsCountBeforeBefore = 0\n    var closingBracketsCountBeforeBefore\
    \ = 0\n    var openingBracketsCountBeforeAfterAfter = 0\n    var closingBracketsCountBeforeAfterAfter\
    \ = 0\n    var openingBracketsCountAfterAfter = 0\n    var closingBracketsCountAfterAfter\
    \ = 0\n    var openingBracketsCountBeforeBeforeAfter = 0\n    var closingBracketsCountBeforeBeforeAfter\
    \ = 0\n    var openingBracketsCountBeforeBeforeBefore = 0\n    var closingBracketsCountBeforeBeforeBefore\
    \ = 0\n    var openingBracketsCountBeforeAfterAfter = 0\n    var closingBracketsCountBeforeAfterAfter\
    \ = 0\n    var openingBracketsCountAfterAfter = 0\n    var closingBracketsCountAfterAfter\
    \ = 0\n    var openingBracketsCountBeforeBeforeAfter = 0\n    var closingBracketsCountBeforeBeforeAfter\
    \ = 0\n    var openingBracketsCountBeforeBeforeBefore = 0\n    var closingBracketsCountBeforeBeforeBefore\
    \ = 0\n    var openingBracketsCountBeforeAfterAfter = 0\n    var closingBracketsCountBeforeAfterAfter\
    \ = 0\n    var openingBracketsCountAfterAfter = 0\n    var closingBracketsCountAfterAfter\
    \ = 0\n    var openingBracketsCountBeforeBeforeAfter = 0\n    var closingBracketsCountBeforeBeforeAfter\
    \ = 0\n    var openingBracketsCountBeforeBeforeBefore = 0\n    var closingBracketsCountBeforeBeforeBefore\
    \ = 0\n    var openingBracketsCountBeforeAfterAfter = 0\n    var closingBracketsCountBeforeAfterAfter\
    \ = 0\n    var openingBracketsCountAfterAfter = 0\n    var closingBracketsCountAfterAfter\
    \ = 0\n    var openingBracketsCountBeforeBeforeAfter = 0\n    var closingBracketsCountBeforeBeforeAfter\
    \ = 0\n    var openingBracketsCountBeforeBeforeBefore = 0\n    var closingBracketsCountBeforeBeforeBefore\
    \ = 0\n    var openingBracketsCountBeforeAfterAfter = 0\n    var closingBracketsCountBeforeAfter",
  "    let brackets = string.unicodeScalars\n        .filter({ $0 != CharacterSet.openParenthesis\
    \ })\n        .filter({ $0 != CharacterSet.closeParenthesis })\n        .filter({\
    \ $0 != CharacterSet.openBracket})\n        .filter({ $0 != CharacterSet.closeBracket})\n\
    \        .filter({ $0 != CharacterSet.openBrace})\n        .filter({ $0 != CharacterSet.closeBrace})\n\
    \    return brackets.count > 0", "    var stack = [String]()\n    var open = 0\n\
    \    for index in 0..<string.characters.count {\n        let char = string.characters[index]\n\
    \        if char == \"[\" {\n            open++\n        } else if char == \"\
    ]\" {\n            open--\n        } else if char == \"{\" {\n            stack.append(char)\n\
    \        } else if char == \"}\" {\n            if open < 0 {\n              \
    \  return false\n            }\n            open--\n        }\n    }\n    return\
    \ open < 0", "    guard let start = string.index(of: \"[\"),\n        let end\
    \ = string.index(of: \"]\"),\n        start != end,\n        start < string.endIndex,\n\
    \        end > string.startIndex\n        else { return false }\n    let start\
    \ = string.index(before: start)\n    let end = string.index(before: end)\n   \
    \ let range = start..<end\n    let nested = string.substring(with: range)\n  \
    \  return nested.contains(\"[\")", "    let stack = Stack()\n    for character\
    \ in string {\n        switch character {\n        case '[':\n            stack.push(character)\n\
    \        case ']':\n            if stack.count > 0 {\n                stack.pop()\n\
    \            } else {\n                return false\n            }\n        default:\n\
    \            return false\n        }\n    }\n    return stack.count == 0", " \
    \   \n    let brackets = string.replacingOccurrences(of: \"[\", with: \"\").replacingOccurrences(of:\
    \ \"]\", with: \"\")\n    \n    let openBrackets = brackets.replacingOccurrences(of:\
    \ \"(\", with: \"\").replacingOccurrences(of: \")\", with: \"\")\n    \n    let\
    \ closeBrackets = brackets.replacingOccurrences(of: \"[\", with: \"\").replacingOccurrences(of:\
    \ \"]\", with: \"\")\n    \n    let openBracketsCount = openBrackets.characters.count\n\
    \    \n    let closeBracketsCount = closeBrackets.characters.count\n    \n   \
    \ let openBracketsCount = Int(openBracketsCount)\n    \n    let closeBracketsCount\
    \ = Int(closeBracketsCount)\n    \n    if openBracketsCount < closeBracketsCount\
    \ {\n        return false\n    } else {\n        return true\n    }", "    guard\
    \ let pattern = try? NSRegularExpression(pattern: \"\\\\[\\\\[\\\\]\\\\]\\\\]\"\
    , options: []) else {\n        return false\n    }\n    \n    guard let range\
    \ = pattern.range(of: string, options: .regularExpression) else { return false\
    \ }\n    \n    let result = pattern.matches(in: string, options: [], range: range)\n\
    \    \n    return result", "    var stack = [String]()\n    var opening = false\n\
    \    for char in string {\n        if char == '[' {\n            stack.append(char)\n\
    \        } else if char == ']' {\n            if opening = true {\n          \
    \      return false\n            }\n            stack.removeLast()\n        }\
    \ else if char == '[' {\n            opening = true\n        }\n    }\n    return\
    \ stack.count == 0", "    guard let openBracket = string.rangeOfString(\"[\",\
    \ options: .LiteralSearch, range: nil, locale: nil) else {\n        return false\n\
    \    }\n    guard let closeBracket = string.rangeOfString(\"]\", options: .LiteralSearch,\
    \ range: nil, locale: nil) else {\n        return false\n    }\n    guard openBracket.location\
    \ != closeBracket.location else {\n        return false\n    }\n    guard openBracket.location\
    \ > closeBracket.location else {\n        return false\n    }\n    guard openBracket.location\
    \ < string.endIndex else {\n        return false\n    }\n    guard closeBracket.location\
    \ > string.endIndex else {\n        return false\n    }\n    guard closeBracket.location\
    \ < openBracket.location else {\n        return false\n    }\n    guard let openBracketIndex\
    \ = string.index(openBracket.location, offsetBy: 1) {\n        return false\n\
    \    }\n    guard let closeBracketIndex = string.index(closeBracket.location,\
    \ offsetBy: 1) {\n        return false\n    }\n    guard openBracketIndex < closeBracketIndex\
    \ else {\n        return false\n    }\n    guard openBracketIndex < string.endIndex\
    \ else {\n        return false\n    }\n    guard closeBracketIndex < string.endIndex\
    \ else {\n        return false\n    }\n    guard let openBracket = string[openBracketIndex],\n\
    \        let closeBracket = string[closeBracketIndex],\n        let openBracketIndex\
    \ = string.index(openBracket, offsetBy: 1) {\n        return false\n    }\n  \
    \  guard let closeBracketIndex = string.index(closeBracket, offsetBy: 1) {\n \
    \       return false\n    }\n    guard openBracketIndex < closeBracketIndex else\
    \ {\n        return false\n    }\n    guard openBracketIndex < string.endIndex\
    \ else {\n        return false\n    }\n    guard closeBracketIndex < string.endIndex\
    \ else {\n        return false\n    }\n    guard openBracket == \"[\" else {\n\
    \        return false\n    }\n    guard closeBracket == \"]\" else {\n       \
    \ return false\n    }\n    return true", "    var stack = [String]()\n    for\
    \ ch in string {\n        if ch == '[' {\n            stack.append(ch)\n     \
    \   } else if ch == ']' {\n            if stack.isEmpty {\n                return\
    \ false\n            }\n            stack.removeLast()\n        } else if ch ==\
    \ '[' {\n            stack.append(ch)\n        } else if ch == ']' {\n       \
    \     if stack.isEmpty {\n                return false\n            }\n      \
    \      stack.removeLast()\n        } else if ch == '{' {\n            stack.append(ch)\n\
    \        } else if ch == '}' {\n            if stack.isEmpty {\n             \
    \   return false\n            }\n            stack.removeLast()\n        }\n \
    \   }\n    return stack.isEmpty", "    guard let openingBracket = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil) else {\n        return\
    \ false\n    }\n    guard let closingBracket = string.rangeOfString(\"]\", options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n        return false\n    }\n\
    \    guard let openingBracketIndex = string.index(of: openingBracket, options:\
    \ .Backwards, range: nil, locale: nil) else {\n        return false\n    }\n \
    \   guard let closingBracketIndex = string.index(of: closingBracket, options:\
    \ .Backwards, range: nil, locale: nil) else {\n        return false\n    }\n \
    \   guard let openingBracketIndex = string.index(of: openingBracket, options:\
    \ .Backwards, range: nil, locale: nil) else {\n        return false\n    }\n \
    \   guard let closingBracketIndex = string.index(of: closingBracket, options:\
    \ .Backwards, range: nil, locale: nil) else {\n        return false\n    }\n \
    \   guard let openingBracketIndex = string.index(of: openingBracket, options:\
    \ .Backwards, range: nil, locale: nil) else {\n        return false\n    }\n \
    \   guard let closingBracketIndex = string.index(of: closingBracket, options:\
    \ .Backwards, range: nil, locale: nil) else {\n        return false\n    }\n \
    \   guard let openingBracketIndex = string.index(of: openingBracket, options:\
    \ .Backwards, range: nil, locale: nil) else {\n        return false\n    }\n \
    \   guard let closingBracketIndex = string.index(of: closingBracket, options:\
    \ .Backwards, range: nil, locale: nil) else {\n        return false\n    }\n \
    \   guard let openingBracketIndex = string.index(of: openingBracket, options:\
    \ .Backwards, range: nil, locale: nil) else {\n        return false\n    }\n \
    \   guard let closingBracketIndex = string.index(of: closingBracket, options:\
    \ .Backwards, range: nil, locale: nil) else {\n        return false\n    }\n \
    \   guard let openingBracketIndex = string.index(of: openingBracket, options:\
    \ .Backwards, range: nil, locale: nil) else {\n        return false\n    }\n \
    \   guard let closingBracketIndex = string.index(of: closingBracket, options:\
    \ .Backwards, range: nil, locale: nil) else {\n        return false\n    }", " \
    \   guard let start = string.index(of: \"[\"),\n        let end = string.index(of:\
    \ \"]\"),\n        start != end,\n        start < string.endIndex\n        else\
    \ { return false }\n    \n    var openingBracketCount = 0\n    var closingBracketCount\
    \ = 0\n    \n    for index in string.indices(of: \"[\") {\n        if let index\
    \ = string.index(of: \"]\", range: start..<index) {\n            closingBracketCount\
    \ += 1\n        }\n        openingBracketCount += 1\n    }\n    \n    return openingBracketCount\
    \ > closingBracketCount", "    guard let start = string.index(of: \"[\"), let\
    \ end = string.index(of: \"]\") else {\n        return false\n    }\n    guard\
    \ let start = string.index(of: \"[\", range: start..<end) else {\n        return\
    \ false\n    }\n    guard let end = string.index(of: \"]\", range: start..<end)\
    \ else {\n        return false\n    }\n    guard let start = string.index(of:\
    \ \"[\", range: start..<end) else {\n        return false\n    }\n    guard let\
    \ end = string.index(of: \"]\", range: start..<end) else {\n        return false\n\
    \    }\n    return true", "    var stack = [String]()\n    for char in string\
    \ {\n        if char == '[' {\n            stack.append(char)\n        } else\
    \ if char == ']' {\n            if stack.count > 0 {\n                stack.removeLast()\n\
    \            } else {\n                return false\n            }\n        }\
    \ else {\n            return false\n        }\n    }\n    return stack.count ==\
    \ 0", "    let stack = Stack()\n    for char in string {\n        if char == '['\
    \ {\n            stack.push(char)\n        } else if char == ']' {\n         \
    \   if stack.top() == '[' {\n                stack.pop()\n            } else {\n\
    \                return false\n            }\n        } else {\n            return\
    \ false\n        }\n    }\n    return stack.top() == nil", "    guard let index\
    \ = string.index(of: \"[\"),\n        let end = string.index(of: \"]\", range:\
    \ start..<string.endIndex) else {\n            return false\n    }\n    return\
    \ string.substring(from: index..<end).count > 0", "    guard let open = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil),\n        let close = string.rangeOfString(\"\
    ]\", options: .LiteralSearch, range: nil, locale: nil) else {\n            return\
    \ false\n    }\n    return open < close", "    var stack = [String]()\n    var\
    \ openingBrackets = 0\n    for ch in string {\n        if ch == '[' {\n      \
    \      stack.append(ch)\n            openingBrackets += 1\n        } else if ch\
    \ == ']' {\n            openingBrackets -= 1\n            if openingBrackets ==\
    \ 0 {\n                stack.removeLast()\n            }\n        } else if openingBrackets\
    \ > 0 {\n            return false\n        }\n    }\n    return openingBrackets\
    \ == 0", "    guard let openBracket = string.rangeOfString(\"[\", options: .BackwardsSearch)\
    \ else { return false }\n    guard let closeBracket = string.rangeOfString(\"\
    ]\", options: .BackwardsSearch) else { return false }\n    guard openBracket.location\
    \ != closeBracket.location else { return false }\n    guard openBracket.location\
    \ > closeBracket.location else { return false }\n    guard openBracket.location\
    \ < string.count - 1 else { return false }\n    guard closeBracket.location >\
    \ string.count - 1 else { return false }\n    guard closeBracket.location < openBracket.location\
    \ else { return false }\n    guard openBracket.location < closeBracket.location\
    \ else { return false }\n    guard openBracket.location != string.count - 1 else\
    \ { return false }\n    guard closeBracket.location != string.count - 1 else {\
    \ return false }\n    guard openBracket.location != closeBracket.location else\
    \ { return false }\n    guard openBracket.location != string.count - 1 else {\
    \ return false }\n    guard closeBracket.location != string.count - 1 else { return\
    \ false }\n    guard openBracket.location != closeBracket.location else { return\
    \ false }\n    guard openBracket.location != string.count - 1 else { return false\
    \ }\n    guard closeBracket.location != string.count - 1 else { return false }\n\
    \    guard openBracket.location != closeBracket.location else { return false }\n\
    \    guard openBracket.location != string.count - 1 else { return false }\n  \
    \  guard closeBracket.location != string.count - 1 else { return false }\n   \
    \ guard openBracket.location != closeBracket.location else { return false }\n\
    \    guard openBracket.location != string.count - 1 else { return false }\n  \
    \  guard closeBracket.location != string.count - 1 else { return false }\n   \
    \ guard openBracket.location != closeBracket.location else { return false }\n\
    \    guard openBracket.location != string.count - 1 else { return false }\n  \
    \  guard closeBracket.location != string.count - 1 else { return false }\n   \
    \ guard openBracket.location != closeBracket.location else { return false }\n\
    \    guard openBracket.location != string.count - 1 else { return false }\n  \
    \  guard closeBracket.location != string.count - 1 else { return false }\n", "\t\
    let openBrackets = string.rangeOfString(\"[\")\n\tlet closeBrackets = string.rangeOfString(\"\
    ]\")\n\t\n\tif openBrackets == nil || closeBrackets == nil {\n\t\treturn false\n\
    \t}\n\t\n\tlet openBracketsCount = openBrackets?.endIndex\n\tlet closeBracketsCount\
    \ = closeBrackets?.startIndex\n\t\n\tif openBracketsCount == 0 || closeBracketsCount\
    \ == 0 {\n\t\treturn false\n\t}\n\t\n\tlet openBracketsCount2 = openBrackets?.endIndex\n\
    \tlet closeBracketsCount2 = closeBrackets?.startIndex\n\t\n\tif openBracketsCount2\
    \ == 0 || closeBracketsCount2 == 0 {\n\t\treturn false\n\t}\n\t\n\tlet openBracketsCount3\
    \ = openBrackets?.endIndex\n\tlet closeBracketsCount3 = closeBrackets?.startIndex\n\
    \t\n\tif openBracketsCount3 == 0 || closeBracketsCount3 == 0 {\n\t\treturn false\n\
    \t}\n\t\n\tlet openBracketsCount4 = openBrackets?.endIndex\n\tlet closeBracketsCount4\
    \ = closeBrackets?.startIndex\n\t\n\tif openBracketsCount4 == 0 || closeBracketsCount4\
    \ == 0 {\n\t\treturn false\n\t}\n\t\n\tlet openBracketsCount5 = openBrackets?.endIndex\n\
    \tlet closeBracketsCount5 = closeBrackets?.startIndex\n\t\n\tif openBracketsCount5\
    \ == 0 || closeBracketsCount5 == 0 {\n\t\treturn false\n\t}\n\t\n\tlet openBracketsCount6\
    \ = openBrackets?.endIndex\n\tlet closeBracketsCount6 = closeBrackets?.startIndex\n\
    \t\n\tif openBracketsCount6 == 0 || closeBracketsCount6 == 0 {\n\t\treturn false\n\
    \t}\n\t\n\tlet openBracketsCount7 = openBrackets?.endIndex\n\tlet closeBracketsCount7\
    \ = closeBrackets?.startIndex\n\t\n\tif openBracketsCount7 == 0 || closeBracketsCount7\
    \ == 0 {\n\t\treturn false\n\t}\n\t\n\tlet openBracketsCount8 = openBrackets?.endIndex\n\
    \tlet closeBracketsCount8 = closeBrackets?.startIndex\n\t\n\tif openBracketsCount8\
    \ == 0 || closeBracketsCount8 == 0 {\n\t\treturn false\n\t}\n\t\n\t", "    let\
    \ stack = Stack()\n    for char in string {\n        if char == '[' {\n      \
    \      stack.push(char)\n        } else if char == ']' {\n            if stack.top()\
    \ == '[' {\n                stack.pop()\n            } else {\n              \
    \  return false\n            }\n        }\n    }\n    return stack.top() == nil",
  "    guard let start = string.index(of: \"[\"),\n        let end = string.index(of:\
    \ \"]\"),\n        start != end,\n        let start = string.index(of: \"[\",\
    \ range: start..<end),\n        let end = string.index(of: \"]\", range: start..<end),\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        let start = string.index(of:\
    \ \"[\", range: start..<end),\n        let end = string.index(of: \"]\", range:\
    \ start..<end),\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        let start\
    \ = string.index(of: \"[\", range: start..<end),\n        let end = string.index(of:\
    \ \"]\", range: start..<end),\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n        let end = string.index(of: \"]\", range: start..<end),\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        let start = string.index(of:\
    \ \"[\", range: start..<end),\n        let end = string.index(of: \"]\", range:\
    \ start..<end),\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        let start\
    \ = string.index(of: \"[\", range: start..<end),\n        let end = string.index(of:\
    \ \"]\", range: start..<end),\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n        let end = string.index(of: \"]\", range: start..<end),\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        let start = string.index(of:\
    \ \"[\", range: start..<end),\n        let end = string.index(of: \"]\", range:\
    \ start..<end),\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        let start\
    \ = string.index(of: \"[\", range: start..<end),\n        let end = string.index(of:\
    \ \"]\", range: start..<end),\n        let start = string.index(of", "    let\
    \ brackets = string.unicodeScalars.filter { $0.isBr }\n    \n    if brackets.count\
    \ < 1 {\n        return false\n    }\n    \n    let openingBrackets = brackets.filter\
    \ { $0.isBr }\n    \n    if openingBrackets.count < 1 {\n        return false\n\
    \    }\n    \n    let closingBrackets = brackets.filter { !$0.isBr }\n    \n \
    \   if closingBrackets.count < 1 {\n        return false\n    }\n    \n    let\
    \ openingBracketsCount = openingBrackets.count\n    let closingBracketsCount =\
    \ closingBrackets.count\n    \n    if openingBracketsCount != closingBracketsCount\
    \ {\n        return false\n    }\n    \n    let openingBracketsString = openingBrackets.map\
    \ { $0.value }\n    let closingBracketsString = closingBrackets.map { $0.value\
    \ }\n    \n    let openingBracketsStringCount = openingBracketsString.count\n\
    \    let closingBracketsStringCount = closingBracketsString.count\n    \n    if\
    \ openingBracketsStringCount != closingBracketsStringCount {\n        return false\n\
    \    }\n    \n    let openingBracketsStringSet = Set(openingBracketsString)\n\
    \    let closingBracketsStringSet = Set(closingBracketsString)\n    \n    if openingBracketsStringSet.count\
    \ != closingBracketsStringSet.count {\n        return false\n    }\n    \n   \
    \ let openingBracketsStringSetCount = openingBracketsStringSet.count\n    let\
    \ closingBracketsStringSetCount = closingBracketsStringSet.count\n    \n    if\
    \ openingBracketsStringSetCount != closingBracketsStringSetCount {\n        return\
    \ false\n    }\n    \n    return true", "    guard let openBracket = string.rangeOfString(\"\
    [\", options: .BackwardsSearch) else { return false }\n    guard let closeBracket\
    \ = string.rangeOfString(\"]\", options: .BackwardsSearch) else { return false\
    \ }\n    guard openBracket.location != closeBracket.location else { return false\
    \ }\n    guard openBracket.location > closeBracket.location else { return false\
    \ }\n    guard openBracket.location < string.endIndex else { return false }\n\
    \    guard closeBracket.location > string.endIndex else { return false }\n   \
    \ guard closeBracket.location < openBracket.location else { return false }\n \
    \   guard openBracket.location != string.startIndex else { return false }\n  \
    \  guard closeBracket.location != string.startIndex else { return false }\n  \
    \  guard openBracket.location != string.endIndex else { return false }\n    guard\
    \ closeBracket.location != string.endIndex else { return false }\n    guard openBracket.location\
    \ != string.startIndex else { return false }\n    guard closeBracket.location\
    \ != string.startIndex else { return false }\n    guard openBracket.location !=\
    \ string.endIndex else { return false }\n    guard closeBracket.location != string.endIndex\
    \ else { return false }\n    return true", "\tlet stack = Stack()\n\tlet openingBrackets\
    \ = [String]()\n\tlet closingBrackets = [String]()\n\tlet openingBracketCount\
    \ = 1\n\tlet closingBracketCount = 1\n\t\n\tlet openingBracket = CharacterSet.openingBrackets\n\
    \tlet closingBracket = CharacterSet.closingBrackets\n\t\n\tlet characterSet =\
    \ CharacterSet(charactersIn: string)\n\t\n\tlet openingBracketSet = CharacterSet(charactersIn:\
    \ openingBracket)\n\tlet closingBracketSet = CharacterSet(charactersIn: closingBracket)\n\
    \t\n\tlet openingBracketRange = NSRange(location: openingBracketSet.location(in:\
    \ string), length: openingBracketSet.count(in: string))\n\tlet closingBracketRange\
    \ = NSRange(location: closingBracketSet.location(in: string), length: closingBracketSet.count(in:\
    \ string))\n\t\n\tlet openingBracketRangeCount = openingBracketRange.length\n\t\
    let closingBracketRangeCount = closingBracketRange.length\n\t\n\tlet openingBracketRangeLocation\
    \ = openingBracketRange.location\n\tlet closingBracketRangeLocation = closingBracketRange.location\n\
    \t\n\tlet openingBracketRangeEnd = openingBracketRange.location\n\tlet closingBracketRangeEnd\
    \ = closingBracketRange.location\n\t\n\tlet openingBracketRangeLocation = openingBracketRange.location\n\
    \tlet closingBracketRangeLocation = closingBracketRange.location\n\t\n\tlet openingBracketRangeEnd\
    \ = openingBracketRange.location\n\tlet closingBracketRangeEnd = closingBracketRange.location\n\
    \t\n\tlet openingBracketRangeLocation = openingBracketRange.location\n\tlet closingBracketRangeLocation\
    \ = closingBracketRange.location\n\t\n\tlet openingBracketRangeEnd = openingBracketRange.location\n\
    \tlet closingBracketRangeEnd = closingBracketRange.location\n\t\n\tlet openingBracketRangeLocation\
    \ = openingBracketRange.location\n\tlet closingBracketRangeLocation = closingBracketRange.location\n\
    \t\n\tlet openingBracketRangeEnd = openingBracketRange.location\n\tlet closingBracketRangeEnd\
    \ = closingBracketRange.location\n\t\n\tlet openingBracketRangeLocation = openingBracketRange.location\n\
    \tlet closingBracketRangeLocation = closingBracketRange.location\n\t\n", "   \
    \ \n    var stack = [String]()\n    var openBrackets = 0\n    var closeBrackets\
    \ = 0\n    \n    for character in string {\n        if character == '[' {\n  \
    \          openBrackets += 1\n            stack.append(character)\n        } else\
    \ if character == ']' {\n            closeBrackets += 1\n            stack.removeLast()\n\
    \            if stack.count == 0 {\n                return false\n           \
    \ }\n        } else if character == ']' && openBrackets > 0 && closeBrackets >\
    \ 0 {\n            openBrackets -= 1\n            closeBrackets -= 1\n       \
    \ }\n    }\n    return openBrackets == 0 && closeBrackets == 0", "\tlet brackets\
    \ = string.unicodeScalars\n\tlet openingBrackets = brackets.filter({ $0.isOpen\
    \ })\n\tlet closingBrackets = brackets.filter({ $0.isClosing })\n\tlet openingBracketCount\
    \ = openingBrackets.count\n\tlet closingBracketCount = closingBrackets.count\n\
    \t\n\treturn openingBracketCount == closingBracketCount", "    let stack = Stack<String>()\n\
    \    for character in string {\n        if character == '[' {\n            stack.push(character)\n\
    \        } else if character == ']' {\n            if stack.count > 0 {\n    \
    \            stack.pop()\n            } else {\n                return false\n\
    \            }\n        }\n    }\n    return stack.count == 0", "    \n    //\
    \ Initialize a stack to store brackets\n    var stack = [Character]()\n    \n\
    \    // Iterate over input string\n    for char in string {\n        \n      \
    \  // If current character is opening, push it to the stack\n        if char ==\
    \ '[' {\n            stack.append(char)\n        \n        // If current character\
    \ is closing, pop from the stack\n        } else if char == ']' {\n          \
    \  \n            // If stack is empty, return false\n            if stack.count\
    \ == 0 {\n                return false\n            }\n            \n        \
    \    // Pop from the stack\n            stack.removeLast()\n        }\n    }\n\
    \    \n    // If stack is empty, return false\n    if stack.count == 0 {\n   \
    \     return false\n    }\n    \n    // Otherwise, return true\n    return true",
  "    guard let open = string.rangeOfString(\"[\", options: .LiteralSearch, range:\
    \ nil, locale: nil),\n        let close = string.rangeOfString(\"]\", options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n            return false\n\
    \    }\n    return open < close && close > open", "\tlet openingBrackets = string.unicodeScalars.filter({\
    \ $0.isOpen })\n\tlet closingBrackets = string.unicodeScalars.filter({ $0.isClosing\
    \ })\n\t\n\treturn openingBrackets.count >= closingBrackets.count"]
stop_tokens:
- "\n}"
