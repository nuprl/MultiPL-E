name: HumanEval_132_is_nested
language: swift
prompt: "\n/// Create a function that takes a string as input which contains only\
  \ square brackets.\n/// The function should return True if and only if there is\
  \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
  \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
  \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E False\n\
  /// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\nfunc is_nested(string:\
  \ String) -> Bool {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
  \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
  assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
  ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
  \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
  \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
  \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
  \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
completions: ["    var stack = [String]()\n    var openBrackets = 0\n    var closeBrackets\
    \ = 0\n    for symbol in string {\n        switch symbol {\n        case \"[\"\
    : openBrackets += 1\n        case \"[\": closeBrackets += 1\n        case \"(\"\
    : openBrackets += 1\n        case \")\": closeBrackets += 1\n        default:\
    \ break\n        }\n        stack.append(symbol)\n    }\n    if openBrackets ==\
    \ closeBrackets {\n        return true\n    }\n    return false", "    let stack\
    \ = Stack()\n    for char in string {\n        if char == '[' {\n            stack.push(char)\n\
    \        } else if char == ']' {\n            if stack.count > 0 {\n         \
    \       if stack.peek() == '[' {\n                    stack.pop()\n          \
    \      } else {\n                    return false\n                }\n       \
    \     } else {\n                return false\n            }\n        }\n    }\n\
    \    return stack.count == 0", "    var stack = [String]()\n    var openingBrackets\
    \ = 0\n    for char in string {\n        if char == '[' {\n            openingBrackets\
    \ += 1\n        } else if char == ']' {\n            openingBrackets -= 1\n  \
    \      } else if char == '[' && openingBrackets == 0 {\n            stack.append(char)\n\
    \        } else if char == ']' && openingBrackets > 0 {\n            if stack[stack.count\
    \ - 1] == '[' {\n                stack.removeLast()\n            } else {\n  \
    \              return false\n            }\n        }\n    }\n    return openingBrackets\
    \ == 0", "    guard let openBracket = string.rangeOfString(\"[\", options: .LiteralSearch,\
    \ range: nil, locale: nil) else {\n        return false\n    }\n    guard let\
    \ closeBracket = string.rangeOfString(\"]\", options: .LiteralSearch, range: nil,\
    \ locale: nil) else {\n        return false\n    }\n    guard openBracket.location\
    \ != closeBracket.location else {\n        return false\n    }\n    guard openBracket.location\
    \ != string.endIndex else {\n        return false\n    }\n    guard closeBracket.location\
    \ != string.startIndex else {\n        return false\n    }\n    guard openBracket.location\
    \ != string.startIndex else {\n        return false\n    }\n    guard closeBracket.location\
    \ != string.endIndex else {\n        return false\n    }\n    guard openBracket.location\
    \ != string.endIndex else {\n        return false\n    }\n    return true", " \
    \   let stack = Stack()\n    for char in string {\n        if char == '[' {\n\
    \            stack.push(char)\n        } else if char == ']' {\n            if\
    \ stack.top() == '[' {\n                stack.pop()\n            } else {\n  \
    \              return false\n            }\n        } else {\n            return\
    \ false\n        }\n    }\n    return stack.empty()", "    \n    let stack = Stack()\n\
    \    \n    for character in string {\n        \n        if character == '[' {\n\
    \            stack.push(character)\n        }\n        \n        if character\
    \ == ']' {\n            \n            if stack.count > 0 {\n                \n\
    \                if stack.peek() == '[' {\n                    stack.pop()\n \
    \               } else {\n                    return false\n                }\n\
    \            }\n        }\n    }\n    \n    return stack.count == 0", "    \n\
    \    let brackets = string.replacingOccurrences(of: \"[\", with: \"\").replacingOccurrences(of:\
    \ \"]\", with: \"\")\n    \n    if brackets.count < 2 {\n        return false\n\
    \    }\n    \n    let openingBrackets = brackets.replacingOccurrences(of: \"[\"\
    , with: \"\").replacingOccurrences(of: \"]\", with: \"\")\n    \n    if openingBrackets.count\
    \ < 2 {\n        return false\n    }\n    \n    let closingBrackets = brackets.replacingOccurrences(of:\
    \ \"[\", with: \"\").replacingOccurrences(of: \"]\", with: \"\")\n    \n    if\
    \ closingBrackets.count < 2 {\n        return false\n    }\n    \n    let openingBracketsCount\
    \ = openingBrackets.count\n    let closingBracketsCount = closingBrackets.count\n\
    \    \n    if openingBracketsCount != closingBracketsCount {\n        return false\n\
    \    }\n    \n    let openingBracketsArray = openingBrackets.characters\n    let\
    \ closingBracketsArray = closingBrackets.characters\n    \n    let openingBracketsArrayCount\
    \ = openingBracketsArray.count\n    let closingBracketsArrayCount = closingBracketsArray.count\n\
    \    \n    if openingBracketsArrayCount != closingBracketsArrayCount {\n     \
    \   return false\n    }\n    \n    let openingBracketsArrayIndex = 0\n    let\
    \ closingBracketsArrayIndex = 0\n    \n    while openingBracketsArrayIndex < openingBracketsArrayCount\
    \ && closingBracketsArrayIndex < closingBracketsArrayCount {\n        \n     \
    \   let openingBracket = openingBracketsArray[openingBracketsArrayIndex]\n   \
    \     let closingBracket = closingBracketsArray[closingBracketsArrayIndex]\n \
    \       \n        if openingBracket != closingBracket {\n            return false\n\
    \        }\n        \n        openingBracketsArrayIndex += 1\n        closingBracketsArrayIndex\
    \ += 1\n    }\n    \n    return true", "    var stack = [String]()\n    var open\
    \ = 0\n    var close = 0\n    for i := 0; i < len(string); i++ {\n        if string[i]\
    \ == '[' {\n            open++\n            stack.append(string[i])\n        }\
    \ else if string[i] == ']' {\n            close++\n            if open > close\
    \ {\n                return false\n            }\n            open--\n       \
    \ }\n    }\n    return open > close", "    let brackets = string.unicodeScalars\n\
    \        .filter { $0 != brackets.first }\n        .map { $0 }\n        .filter\
    \ { $0 != brackets.last }\n        .map { $0 }\n        .filter { $0 != brackets.first\
    \ }\n        .map { $0 }\n        .filter { $0 != brackets.last }\n        .map\
    \ { $0 }\n        .filter { $0 != brackets.first }\n        .map { $0 }\n    \
    \    .filter { $0 != brackets.last }\n        .map { $0 }\n        .filter { $0\
    \ != brackets.first }\n        .map { $0 }\n        .filter { $0 != brackets.last\
    \ }\n        .map { $0 }\n        .filter { $0 != brackets.first }\n        .map\
    \ { $0 }\n        .filter { $0 != brackets.last }\n        .map { $0 }\n     \
    \   .filter { $0 != brackets.first }\n        .map { $0 }\n        .filter { $0\
    \ != brackets.last }\n        .map { $0 }\n        .filter { $0 != brackets.first\
    \ }\n        .map { $0 }\n        .filter { $0 != brackets.last }\n        .map\
    \ { $0 }\n        .filter { $0 != brackets.first }\n        .map { $0 }\n    \
    \    .filter { $0 != brackets.last }\n        .map { $0 }\n        .filter { $0\
    \ != brackets.first }\n        .map { $0 }\n        .filter { $0 != brackets.last\
    \ }\n        .map { $0 }\n        .filter { $0 != brackets.first }\n        .map\
    \ { $0 }\n        .filter { $0 != brackets.last }\n        .map { $0 }\n     \
    \   .filter { $0 != brackets.first }\n        .map { $0 }\n        .filter { $0\
    \ != brackets.last }\n        .map { $0 }\n        .filter { $0 != brackets.first\
    \ }\n        .map { $0 }\n        .filter { $0 != brackets.last }\n        .map\
    \ { $0 }\n        .filter { $0 != brackets.first }\n        .map { $0 }\n    \
    \    .filter { $0 != brackets.last }\n        .map { $0 }\n        .filter { $0\
    \ != brackets.first }\n        .map { $0 }\n        .filter { $0 != brackets.last\
    \ }\n        .map { $0 }\n", "    guard let open = string.range(of: \"[\"),\n\
    \        let close = string.range(of: \"]\"),\n        open != nil && close !=\
    \ nil else {\n        return false\n    }\n    \n    let openCount = string.distance(from:\
    \ open.upperBound, to: open.lowerBound)\n    let closeCount = string.distance(from:\
    \ close.upperBound, to: close.lowerBound)\n    \n    return openCount == closeCount",
  "    \n    // Your code here\n    \n    return true", "    let openingBrackets =\
    \ string.unicodeScalars.filter({ $0.isOpen })\n    let closingBrackets = string.unicodeScalars.filter({\
    \ $0.isClosing })\n    \n    if openingBrackets.count != closingBrackets.count\
    \ {\n        return false\n    }\n    \n    let openingBracketsCount = openingBrackets.count\n\
    \    let closingBracketsCount = closingBrackets.count\n    \n    if openingBracketsCount\
    \ == 0 {\n        return true\n    }\n    \n    if openingBracketsCount == 1 {\n\
    \        return closingBrackets.first!.isNested == openingBrackets.first!.isNested\n\
    \    }\n    \n    let openingBracketsIndex = openingBrackets.first!.index\n  \
    \  let closingBracketsIndex = closingBrackets.first!.index\n    \n    let openingBracketsString\
    \ = string.substring(from: openingBracketsIndex)\n    let closingBracketsString\
    \ = string.substring(from: closingBracketsIndex)\n    \n    let openingBracketsStringCount\
    \ = openingBracketsString.unicodeScalars.filter({ $0.isOpen }).count\n    let\
    \ closingBracketsStringCount = closingBracketsString.unicodeScalars.filter({ $0.isClosing\
    \ }).count\n    \n    if openingBracketsStringCount != closingBracketsStringCount\
    \ {\n        return false\n    }\n    \n    let openingBracketsStringIndex = openingBracketsString.unicodeScalars.filter({\
    \ $0.isOpen }).first!.index\n    let closingBracketsStringIndex = closingBracketsString.unicodeScalars.filter({\
    \ $0.isClosing }).first!.index\n    \n    let openingBracketsStringCount = openingBracketsString.unicodeScalars.filter({\
    \ $0.isOpen }).count\n    let closingBracketsStringCount = closingBracketsString.unicodeScalars.filter({\
    \ $0.isClosing }).count\n    \n    if openingBracketsStringCount != closingBracketsStringCount\
    \ {\n        return false\n    }\n    \n    let openingBracketsStringIndex = openingBracketsString.unicodeScalars.filter({\
    \ $0.isOpen }).first!.index\n    let closingBracketsStringIndex = closingBracketsString.unicodeScalars.filter({\
    \ $0.isClosing }).first!.index\n    \n    let openingBracketsStringCount = openingBracketsString.unicodeScalars.filter({\
    \ $0.isOpen }).count\n    let closingBracket", "    guard let start = string.index(of:\
    \ \"[\"), let end = string.index(of: \"]\") else {\n        return false\n   \
    \ }\n    \n    var stack = [String]()\n    stack.append(string[start..<end])\n\
    \    \n    for _ in 0..<string.count {\n        guard let start = string.index(of:\
    \ \"[\"), let end = string.index(of: \"]\") else {\n            return false\n\
    \        }\n        \n        if start < end {\n            stack.append(string[start..<end])\n\
    \        }\n    }\n    \n    return stack.count > 1", "    var stack = [String]()\n\
    \    var opening = false\n    for char in string {\n        if char == '[' {\n\
    \            stack.append(char)\n            opening = true\n        } else if\
    \ char == ']' {\n            if opening {\n                opening = false\n \
    \           } else {\n                return false\n            }\n        } else\
    \ {\n            if opening {\n                stack.removeLast()\n          \
    \  }\n        }\n    }\n    return stack.count == 0", "    let stack = Stack()\n\
    \    for character in string {\n        if character == '[' {\n            stack.push(character)\n\
    \        } else if character == ']' {\n            if stack.top() == '[' {\n \
    \               stack.pop()\n            } else {\n                return false\n\
    \            }\n        } else {\n            return false\n        }\n    }\n\
    \    return stack.empty()", "    \n    // Initialize a stack to store brackets\n\
    \    var stack = [String]()\n    \n    // Initialize a counter to keep track of\
    \ how many brackets are in the string\n    var count = 0\n    \n    // Iterate\
    \ through the string and add each character to the stack\n    for char in string\
    \ {\n        \n        // If the character is a bracket, add it to the stack\n\
    \        if char == \"[\" || char == \"]\" {\n            stack.append(char)\n\
    \            count += 1\n            \n        // If the character is a closing\
    \ bracket, pop the stack\n        } else if char == \"]\" {\n            \n  \
    \          // If the stack is empty, return False\n            if stack.count\
    \ == 0 {\n                return false\n            }\n            \n        \
    \    // Pop the last element from the stack\n            stack.removeLast()\n\
    \            \n            // If the stack is empty, return False\n          \
    \  if stack.count == 0 {\n                return false\n            }\n      \
    \      \n            // Increment the counter\n            count += 1\n      \
    \  }\n    }\n    \n    // If the stack is empty, return False\n    if stack.count\
    \ == 0 {\n        return false\n    }\n    \n    // If the stack is not empty,\
    \ return True\n    return true", "\tlet openBracketsCount = string.count(\"[\"\
    )\n\tlet closeBracketsCount = string.count(\"]\")\n\t\n\tif openBracketsCount\
    \ != closeBracketsCount {\n\t\treturn false\n\t}\n\t\n\tlet openBracketsIndex\
    \ = 0\n\tlet closeBracketsIndex = 0\n\t\n\twhile openBracketsIndex < openBracketsCount\
    \ {\n\t\tlet openBracket = string[openBracketsIndex]\n\t\t\n\t\tif openBracket\
    \ == \"[\" {\n\t\t\topenBracketsIndex += 1\n\t\t} else if openBracket == \"]\"\
    \ {\n\t\t\tcloseBracketsIndex += 1\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t\
    }\n\t\n\treturn true", "    let stack = Stack()\n    for char in string {\n  \
    \      if char == '[' {\n            stack.push(char)\n        } else if char\
    \ == ']' {\n            if stack.top() == '[' {\n                stack.pop()\n\
    \            } else {\n                return false\n            }\n        }\
    \ else {\n            return false\n        }\n    }\n    return stack.empty()",
  "\tlet stack = Stack()\n\tlet openBrackets = Set<Character>()\n\tlet closeBrackets\
    \ = Set<Character>()\n\tlet openBracketsCount = 1\n\tlet closeBracketsCount =\
    \ 1\n\t\n\tfor char in string.characters {\n\t\tif char == '[' {\n\t\t\topenBrackets.insert(char)\n\
    \t\t\topenBracketsCount += 1\n\t\t} else if char == ']' {\n\t\t\tcloseBrackets.insert(char)\n\
    \t\t\tcloseBracketsCount += 1\n\t\t} else if char == '{' {\n\t\t\topenBracketsCount\
    \ += 1\n\t\t} else if char == '}' {\n\t\t\tcloseBracketsCount += 1\n\t\t}\n\t\t\
    \n\t\tif openBracketsCount == closeBracketsCount {\n\t\t\tstack.push(char)\n\t\
    \t}\n\t}\n\t\n\treturn stack.count == 0", "    guard let range = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil) else {\n        return\
    \ false\n    }\n    guard let start = range.lowerBound else {\n        return\
    \ false\n    }\n    guard let end = string.rangeOfString(\"]\", options: .LiteralSearch,\
    \ range: nil, locale: nil)?.upperBound else {\n        return false\n    }\n \
    \   return start < end"]
stop_tokens:
- "\n}"
