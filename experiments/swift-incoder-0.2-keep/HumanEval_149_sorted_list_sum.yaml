name: HumanEval_149_sorted_list_sum
language: swift
prompt: "\n/// Write a function that accepts a list of strings as a parameter,\n///\
  \ deletes the strings that have odd lengths from it,\n/// and returns the resulted\
  \ list with a sorted order,\n/// The list is always a list of strings and never\
  \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
  \ list should be ascending by length of each word, and you\n/// should return the\
  \ list sorted by that rule.\n/// If two words have the same length, sort the list\
  \ alphabetically.\n/// The function should return a list of strings in sorted order.\n\
  /// You may assume that all words will have the same length.\n/// For example:\n\
  /// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n/// assert list_sort([\"\
  ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nfunc sorted_list_sum(lst: [String])\
  \ -> [String] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(sorted_list_sum(lst: [\"aa\", \"a\", \"\
  aaa\"]) == [\"aa\"])\nassert(sorted_list_sum(lst: [\"school\", \"AI\", \"asdf\"\
  , \"b\"]) == [\"AI\", \"asdf\", \"school\"])\nassert(sorted_list_sum(lst: [\"d\"\
  , \"b\", \"c\", \"a\"]) == [] as [String])\nassert(sorted_list_sum(lst: [\"d\",\
  \ \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"])\nassert(sorted_list_sum(lst:\
  \ [\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"])\nassert(sorted_list_sum(lst:\
  \ [\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == [] as [String])\nassert(sorted_list_sum(lst:\
  \ [\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"])"
completions: ["    var result = [String]()\n    var i = 0\n    for word in lst {\n\
    \        if i % 2 == 0 {\n            result.append(word)\n        }\n       \
    \ i += 1\n    }\n    result.sort()\n    return result", "    var lst2 = lst\n\
    \    lst2.sort()\n    return lst2", '    return lst', '    return lst', "    var\
    \ result = [String]()\n    for str in lst {\n        if result.count > 0 {\n \
    \           if str.count > result[result.count - 1].count {\n                result.append(str)\n\
    \            } else {\n                let index = result.index(of: str)\n   \
    \             result.remove(at: index)\n                result.append(str)\n \
    \           }\n        } else {\n            result.append(str)\n        }\n \
    \   }\n    return result", "    var res = lst\n    for index in 0..<res.count\
    \ {\n        if res[index].count % 2 == 1 {\n            res[index] = res[index].sorted()\n\
    \        }\n    }\n    return res", "    var res = lst\n    for index in 0..<res.count\
    \ {\n        let item = res[index]\n        if item.count % 2 == 1 {\n       \
    \     res[index] = item.sorted()\n        }\n    }\n    return res", "    var\
    \ result = [String]()\n    for word in lst {\n        if result.contains(word)\
    \ {\n            continue\n        }\n        result.append(word)\n    }\n   \
    \ result.sort()\n    return result", "    var result = [String]()\n    for word\
    \ in lst {\n        if result.count < result.count {\n            result.append(word)\n\
    \        } else {\n            if word.count > result.count {\n              \
    \  result.removeFirst()\n                result.append(word)\n            }\n\
    \        }\n    }\n    return result.sorted(by: { (word1, word2) -> Bool in\n\
    \        return word1.count < word2.count\n    })", "    var result = [String]()\n\
    \    for word in lst {\n        if result.count > 0 {\n            if word.count\
    \ > result[result.count - 1].count {\n                result.append(word)\n  \
    \          } else {\n                let index = result.index(of: word)\n    \
    \            result[index] = word\n            }\n        } else {\n         \
    \   result.append(word)\n        }\n    }\n    return result.sorted(by: { (word1,\
    \ word2) -> Bool in\n        return word1.count < word2.count\n    })", "    var\
    \ lstCopy = lst\n    lstCopy.sort { (a, b) -> Bool in\n        if a.count < b.count\
    \ {\n            return true\n        }\n        if a.count == b.count {\n   \
    \         return a.lowercased().compare(b.lowercased()) == .orderedAscending\n\
    \        }\n        return false\n    }\n    return lstCopy", "    var lst2 =\
    \ lst\n    for index in 0..<lst2.count {\n        if lst2[index].count % 2 ==\
    \ 1 {\n            lst2.remove(at: index)\n        }\n    }\n    return lst2.sorted(by:\
    \ { (a, b) -> Bool in\n        let aLength = (a as NSString).length\n        let\
    \ bLength = (b as NSString).length\n        if aLength == bLength {\n        \
    \    return a.compare(b) == .orderedAscending\n        }\n        return aLength\
    \ < bLength\n    })", "    var result = [String]()\n    for word in lst {\n  \
    \      if result.count < 2 {\n            result.append(word)\n        } else\
    \ {\n            if word.count > result[0].count {\n                result[0]\
    \ = word\n            } else {\n                if word.count < result[1].count\
    \ {\n                    result[1] = word\n                }\n            }\n\
    \        }\n    }\n    return result", "    var result = [String]()\n    for word\
    \ in lst {\n        if result.count < result.count {\n            result.append(word)\n\
    \        } else {\n            if word.count > result.count {\n              \
    \  result.insert(result.count, word)\n            } else {\n                if\
    \ word.count < result.count {\n                    result.insert(result.count,\
    \ word)\n                }\n            }\n        }\n    }\n    return result",
  '    return lst', "    var result = [String]()\n    var i = 0\n    for word in lst\
    \ {\n        if i % 2 == 0 {\n            result.append(word)\n        }\n   \
    \     i += 1\n    }\n    result.sort()\n    return result", "    var result =\
    \ [String]()\n    for word in lst {\n        if result.contains(word) {\n    \
    \        continue\n        }\n        result.append(word)\n    }\n    result.sort()\n\
    \    return result", "    var result = [String]()\n    for word in lst {\n   \
    \     if result.count < 2 {\n            result.append(word)\n        } else if\
    \ word.count > result.last {\n            result.append(word)\n        } else\
    \ if word.count < result.last {\n            guard let index = result.index(of:\
    \ word) else { return result }\n            result.remove(at: index)\n       \
    \     result.append(word)\n        }\n    }\n    return result.sorted(by: { $0.count\
    \ > $1.count })", "    var result = [String]()\n    for word in lst {\n      \
    \  if result.contains(word) {\n            continue\n        }\n        result.append(word)\n\
    \    }\n    return result.sorted(by: { (word1, word2) -> Bool in\n        let\
    \ word1Len = word1.characters.count\n        let word2Len = word2.characters.count\n\
    \        return word1Len > word2Len || (word1Len == word2Len && word1 < word2)\n\
    \    })", "    var result = lst\n    for index in 0..<result.count {\n       \
    \ if result[index].count % 2 == 1 {\n            result.remove(at: index)\n  \
    \      }\n    }\n    return result"]
stop_tokens:
- "\n}"
