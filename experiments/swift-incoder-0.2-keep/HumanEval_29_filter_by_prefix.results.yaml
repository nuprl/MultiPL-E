language: swift
name: HumanEval_29_filter_by_prefix
results:
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    if strings.IsEmpty() {\n      \
    \  return strings\n    }\n    if strings.Contains(prefix) {\n        return strings.FilterString(func(s\
    \ string) bool {\n            return strings.HasPrefix(s, prefix)\n        })\n\
    \    }\n    return strings\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_stjuth_.swift:12:37: error: expected expression in list of expressions\n\
    \        return strings.FilterString(func(s string) bool {\n                 \
    \                   ^\n/tmp/tmp_stjuth_.swift:12:41: error: expected identifier\
    \ in function declaration\n        return strings.FilterString(func(s string)\
    \ bool {\n                                        ^\n/tmp/tmp_stjuth_.swift:8:16:\
    \ error: value of type '[String]' has no member 'IsEmpty'\n    if strings.IsEmpty()\
    \ {\n       ~~~~~~~ ^~~~~~~\n/tmp/tmp_stjuth_.swift:11:16: error: value of type\
    \ '[String]' has no member 'Contains'\n    if strings.Contains(prefix) {\n   \
    \    ~~~~~~~ ^~~~~~~~\n/tmp/tmp_stjuth_.swift:12:24: error: value of type '[String]'\
    \ has no member 'FilterString'\n        return strings.FilterString(func(s string)\
    \ bool {\n               ~~~~~~~ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter { (string:\
    \ String) -> Bool in\n\t\treturn string.hasPrefix(prefix)\n\t}\n\treturn filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered = [String]()\n   \
    \ for s in strings {\n        if s.startsWith(prefix) {\n            filtered\
    \ = append(filtered, s)\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq3t_f_2w.swift:10:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n/tmp/tmpq3t_f_2w.swift:11:24:\
    \ error: cannot find 'append' in scope\n            filtered = append(filtered,\
    \ s)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet prefix = prefix.lowercased()\n\
    \treturn strings.filter {\n\t\t$0.hasPrefix(prefix)\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter { (string:\
    \ String) -> Bool in\n\t\treturn string.hasPrefix(prefix)\n\t}\n\treturn filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet prefix = prefix.lowercased()\n\
    \treturn strings.filter {\n\t\t$0.hasPrefix(prefix)\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter { (string:\
    \ String) -> Bool in\n\t\treturn string.hasPrefix(prefix)\n\t}\n\treturn filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tif strings.IsNullOrEmpty(prefix)\
    \ {\n\t\treturn strings\n\t}\n\tstrings = strings.ToLower()\n\tprefix = prefix.ToLower()\n\
    \tresult := make([]string, 0)\n\tfor _, s := range strings {\n\t\tif strings.HasPrefix(s,\
    \ prefix) {\n\t\t\tresult = append(result, s)\n\t\t}\n\t}\n\treturn result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp6ug7ljpi.swift:13:8: error: consecutive statements on a line must\
    \ be separated by ';'\n        result := make([]string, 0)\n              ^\n\
    \              ;\n/tmp/tmp6ug7ljpi.swift:13:9: error: expected expression\n  \
    \      result := make([]string, 0)\n               ^\n/tmp/tmp6ug7ljpi.swift:14:7:\
    \ error: expected 'in' after for-each pattern\n        for _, s := range strings\
    \ {\n             ^\n/tmp/tmp6ug7ljpi.swift:14:7: error: expected Sequence expression\
    \ for for-each loop\n        for _, s := range strings {\n             ^\n/tmp/tmp6ug7ljpi.swift:8:13:\
    \ error: value of type '[String]' has no member 'IsNullOrEmpty'\n        if strings.IsNullOrEmpty(prefix)\
    \ {\n           ~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp6ug7ljpi.swift:11:2: error: cannot\
    \ assign to value: 'strings' is a 'let' constant\n        strings = strings.ToLower()\n\
    \        ^~~~~~~\n/tmp/tmp6ug7ljpi.swift:11:20: error: value of type '[String]'\
    \ has no member 'ToLower'\n        strings = strings.ToLower()\n             \
    \     ~~~~~~~ ^~~~~~~\n/tmp/tmp6ug7ljpi.swift:12:2: error: cannot assign to value:\
    \ 'prefix' is a 'let' constant\n        prefix = prefix.ToLower()\n        ^~~~~~\n\
    /tmp/tmp6ug7ljpi.swift:12:18: error: value of type 'String' has no member 'ToLower'\n\
    \        prefix = prefix.ToLower()\n                 ~~~~~~ ^~~~~~~\n/tmp/tmp6ug7ljpi.swift:13:2:\
    \ error: cannot find 'result' in scope\n        result := make([]string, 0)\n\
    \        ^~~~~~\n/tmp/tmp6ug7ljpi.swift:19:9: error: cannot find 'result' in scope\n\
    \        return result\n               ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return strings.filter({ $0.hasPrefix(prefix)\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(filter_by_prefix(strings: []\
    \ as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824545
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered = [String]()\n   \
    \ for s in strings {\n        if s.startsWith(prefix) {\n            filtered\
    \ = append(filtered, s)\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq3t_f_2w.swift:10:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n/tmp/tmpq3t_f_2w.swift:11:24:\
    \ error: cannot find 'append' in scope\n            filtered = append(filtered,\
    \ s)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tprefix += \".\"\n\treturn strings.filter({\
    \ $0.hasPrefix(prefix) })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp6gynksxd.swift:8:9: error: left side of mutating operator isn't\
    \ mutable: 'prefix' is a 'let' constant\n        prefix += \".\"\n        ~~~~~~\
    \ ^\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered = [String]()\n   \
    \ for s in strings {\n        if s.startsWith(prefix) {\n            filtered\
    \ = append(filtered, s)\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq3t_f_2w.swift:10:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n/tmp/tmpq3t_f_2w.swift:11:24:\
    \ error: cannot find 'append' in scope\n            filtered = append(filtered,\
    \ s)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tif strings.IsNullOrEmpty(prefix)\
    \ {\n\t\treturn strings\n\t}\n\tprefix += \".\"\n\treturn strings.SplitN(strings,\
    \ prefix, -1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpzv8q_1mk.swift:8:13: error: value of type '[String]' has no member\
    \ 'IsNullOrEmpty'\n        if strings.IsNullOrEmpty(prefix) {\n           ~~~~~~~\
    \ ^~~~~~~~~~~~~\n/tmp/tmpzv8q_1mk.swift:11:9: error: left side of mutating operator\
    \ isn't mutable: 'prefix' is a 'let' constant\n        prefix += \".\"\n     \
    \   ~~~~~~ ^\n/tmp/tmpzv8q_1mk.swift:12:17: error: value of type '[String]' has\
    \ no member 'SplitN'\n        return strings.SplitN(strings, prefix, -1)\n   \
    \            ~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return strings.filter { (string:\
    \ String) -> Bool in\n        let prefixLength = string.characters.count\n   \
    \     return string.hasPrefix(prefix)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == []\
    \ as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"\
    xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjm7089dq.swift:9:35: error: 'characters' is unavailable: Please\
    \ use String directly\n        let prefixLength = string.characters.count\n  \
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpjm7089dq.swift:9:13: warning: initialization of immutable\
    \ value 'prefixLength' was never used; consider replacing with assignment to '_'\
    \ or removing it\n        let prefixLength = string.characters.count\n       \
    \ ~~~~^~~~~~~~~~~~\n        _\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter { (string:\
    \ String) -> Bool in\n\t\treturn string.hasPrefix(prefix)\n\t}\n\treturn filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tprefix = prefix.lowercased()\n\t\
    strings = strings.filter({ $0.hasPrefix(prefix) })\n\treturn strings\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpg8y80li_.swift:8:2: error: cannot assign to value: 'prefix' is\
    \ a 'let' constant\n        prefix = prefix.lowercased()\n        ^~~~~~\n/tmp/tmpg8y80li_.swift:9:2:\
    \ error: cannot assign to value: 'strings' is a 'let' constant\n        strings\
    \ = strings.filter({ $0.hasPrefix(prefix) })\n        ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered: [String] = []\n \
    \   for s in strings {\n        if s.startsWith(prefix) {\n            filtered\
    \ = append(filtered, s)\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpsbvwpzul.swift:10:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n/tmp/tmpsbvwpzul.swift:11:24:\
    \ error: cannot find 'append' in scope\n            filtered = append(filtered,\
    \ s)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    if strings.IsEmpty() {\n      \
    \  return strings\n    }\n    if strings.Contains(prefix) {\n        return strings.filter({\
    \ $0.hasPrefix(prefix) })\n    }\n    return strings\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpr8wn0_jk.swift:8:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n/tmp/tmpr8wn0_jk.swift:11:16:\
    \ error: value of type '[String]' has no member 'Contains'\n    if strings.Contains(prefix)\
    \ {\n       ~~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet prefix = prefix.lowercased()\n\
    \tlet filtered = strings.filter {\n\t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    if strings.IsEmpty() {\n      \
    \  return strings\n    }\n    if strings.Contains(prefix) {\n        return strings.filter({\
    \ $0.hasPrefix(prefix) })\n    }\n    return strings\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpr8wn0_jk.swift:8:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n/tmp/tmpr8wn0_jk.swift:11:16:\
    \ error: value of type '[String]' has no member 'Contains'\n    if strings.Contains(prefix)\
    \ {\n       ~~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered = [String]()\n   \
    \ for s in strings {\n        if s.startsWith(prefix) {\n            filtered\
    \ = append(filtered, s)\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq3t_f_2w.swift:10:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n/tmp/tmpq3t_f_2w.swift:11:24:\
    \ error: cannot find 'append' in scope\n            filtered = append(filtered,\
    \ s)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tprefix += \"\"\n\tstrings = strings.filter({\
    \ $0.hasPrefix(prefix) })\n\treturn strings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == []\
    \ as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"\
    xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpvw9oxjn2.swift:8:9: error: left side of mutating operator isn't\
    \ mutable: 'prefix' is a 'let' constant\n        prefix += \"\"\n        ~~~~~~\
    \ ^\n/tmp/tmpvw9oxjn2.swift:9:2: error: cannot assign to value: 'strings' is a\
    \ 'let' constant\n        strings = strings.filter({ $0.hasPrefix(prefix) })\n\
    \        ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return filter_by_prefix(strings,\
    \ prefix, true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxb86vhxp.swift:8:46: error: extra argument in call\n    return\
    \ filter_by_prefix(strings, prefix, true)\n                           ~~~~~~~~~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered = [String]()\n   \
    \ for s in strings {\n        if s.startsWith(prefix) {\n            filtered\
    \ = append(filtered, s)\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq3t_f_2w.swift:10:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n/tmp/tmpq3t_f_2w.swift:11:24:\
    \ error: cannot find 'append' in scope\n            filtered = append(filtered,\
    \ s)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet prefix = prefix.lowercased()\n\
    \treturn strings.filter {\n\t\t$0.hasPrefix(prefix)\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tprefix = prefix.lowercased()\n\t\
    filtered = strings.filter {\n\t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp48y_gx46.swift:8:2: error: cannot assign to value: 'prefix' is\
    \ a 'let' constant\n        prefix = prefix.lowercased()\n        ^~~~~~\n/tmp/tmp48y_gx46.swift:9:2:\
    \ error: cannot find 'filtered' in scope\n        filtered = strings.filter {\n\
    \        ^~~~~~~~\n/tmp/tmp48y_gx46.swift:12:9: error: cannot find 'filtered'\
    \ in scope\n        return filtered\n               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter { (string:\
    \ String) -> Bool in\n\t\treturn string.hasPrefix(prefix)\n\t}\n\treturn filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter { (string:\
    \ String) -> Bool in\n\t\treturn string.hasPrefix(prefix)\n\t}\n\treturn filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered = [String]()\n   \
    \ for s in strings {\n        if s.startsWith(prefix) {\n            filtered\
    \ = append(filtered, s)\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq3t_f_2w.swift:10:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n/tmp/tmpq3t_f_2w.swift:11:24:\
    \ error: cannot find 'append' in scope\n            filtered = append(filtered,\
    \ s)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return strings.filter {\n     \
    \   strings.firstIndex(of: $0, options: .caseInsensitive) != nil\n    }.filter\
    \ {\n        $0.hasPrefix(prefix)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == [] as [String])\n\
    assert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"\
    xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpoj9zdgeu.swift:9:46: error: extra argument 'options' in call\n\
    \        strings.firstIndex(of: $0, options: .caseInsensitive) != nil\n      \
    \                    ~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~\n/tmp/tmpoj9zdgeu.swift:9:46:\
    \ error: cannot infer contextual base in reference to member 'caseInsensitive'\n\
    \        strings.firstIndex(of: $0, options: .caseInsensitive) != nil\n      \
    \                                      ~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\treturn strings.filter({ $0.hasPrefix(prefix)\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(filter_by_prefix(strings: []\
    \ as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return filter_by_prefix(strings,\
    \ prefix, true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxb86vhxp.swift:8:46: error: extra argument in call\n    return\
    \ filter_by_prefix(strings, prefix, true)\n                           ~~~~~~~~~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet prefixes = strings.map { $0.startsWith(prefix)\
    \ }\n\treturn strings.filter {\n\t\t$0.startsWith(prefix)\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpi7fuuscf.swift:8:34: error: value of type 'String' has no member\
    \ 'startsWith'\n        let prefixes = strings.map { $0.startsWith(prefix) }\n\
    \                                     ~~ ^~~~~~~~~~\n/tmp/tmpi7fuuscf.swift:10:6:\
    \ error: value of type 'String' has no member 'startsWith'\n                $0.startsWith(prefix)\n\
    \                ~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter { (string:\
    \ String) -> Bool in\n\t\treturn string.hasPrefix(prefix)\n\t}\n\treturn filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return strings.filter({ $0.hasPrefix(prefix)\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(filter_by_prefix(strings: []\
    \ as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824545
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered: [String] = []\n \
    \   for s in strings {\n        if s.startsWith(prefix) {\n            filtered\
    \ = append(filtered, s)\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpsbvwpzul.swift:10:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n/tmp/tmpsbvwpzul.swift:11:24:\
    \ error: cannot find 'append' in scope\n            filtered = append(filtered,\
    \ s)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tfilteredStrings := strings.filter({\
    \ $0.hasPrefix(prefix) })\n\treturn filteredStrings\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpnszs39_l.swift:8:17: error: consecutive statements on a line must\
    \ be separated by ';'\n        filteredStrings := strings.filter({ $0.hasPrefix(prefix)\
    \ })\n                       ^\n                       ;\n/tmp/tmpnszs39_l.swift:8:18:\
    \ error: expected expression\n        filteredStrings := strings.filter({ $0.hasPrefix(prefix)\
    \ })\n                        ^\n/tmp/tmpnszs39_l.swift:8:2: error: cannot find\
    \ 'filteredStrings' in scope\n        filteredStrings := strings.filter({ $0.hasPrefix(prefix)\
    \ })\n        ^~~~~~~~~~~~~~~\n/tmp/tmpnszs39_l.swift:9:9: error: cannot find\
    \ 'filteredStrings' in scope\n        return filteredStrings\n               ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered = [String]()\n   \
    \ for s in strings {\n        if s.startsWith(prefix) {\n            filtered\
    \ = append(filtered, s)\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq3t_f_2w.swift:10:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n/tmp/tmpq3t_f_2w.swift:11:24:\
    \ error: cannot find 'append' in scope\n            filtered = append(filtered,\
    \ s)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered = [String]()\n   \
    \ for s in strings {\n        if s.startsWith(prefix) {\n            filtered\
    \ = append(filtered, s)\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq3t_f_2w.swift:10:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n/tmp/tmpq3t_f_2w.swift:11:24:\
    \ error: cannot find 'append' in scope\n            filtered = append(filtered,\
    \ s)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered: [String] = []\n \
    \   for s in strings {\n        if s.startsWith(prefix) {\n            filtered\
    \ = append(filtered, s)\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpsbvwpzul.swift:10:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n/tmp/tmpsbvwpzul.swift:11:24:\
    \ error: cannot find 'append' in scope\n            filtered = append(filtered,\
    \ s)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter { (string:\
    \ String) -> Bool in\n\t\treturn string.hasPrefix(prefix)\n\t}\n\treturn filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\treturn strings.filter({ $0.hasPrefix(prefix)\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(filter_by_prefix(strings: []\
    \ as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return filter_by_prefix(strings,\
    \ prefix, true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxb86vhxp.swift:8:46: error: extra argument in call\n    return\
    \ filter_by_prefix(strings, prefix, true)\n                           ~~~~~~~~~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter { (string:\
    \ String) -> Bool in\n\t\treturn string.hasPrefix(prefix)\n\t}\n\treturn filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered = [String]()\n   \
    \ for s in strings {\n        if s.startsWith(prefix) {\n            filtered\
    \ = append(filtered, s)\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq3t_f_2w.swift:10:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n/tmp/tmpq3t_f_2w.swift:11:24:\
    \ error: cannot find 'append' in scope\n            filtered = append(filtered,\
    \ s)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered = [String]()\n   \
    \ for s in strings {\n        if s.startsWith(prefix) {\n            filtered\
    \ = append(filtered, s)\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq3t_f_2w.swift:10:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n/tmp/tmpq3t_f_2w.swift:11:24:\
    \ error: cannot find 'append' in scope\n            filtered = append(filtered,\
    \ s)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered = [String]()\n   \
    \ for s in strings {\n        if s.startsWith(prefix) {\n            filtered\
    \ = append(filtered, s)\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq3t_f_2w.swift:10:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n/tmp/tmpq3t_f_2w.swift:11:24:\
    \ error: cannot find 'append' in scope\n            filtered = append(filtered,\
    \ s)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    if strings.IsEmpty() {\n      \
    \  return strings\n    }\n    if strings.IsPrefix(prefix) {\n        return strings.Substr(prefix.Length)\n\
    \    }\n    return strings\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpr9zzm92y.swift:8:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n/tmp/tmpr9zzm92y.swift:11:16:\
    \ error: value of type '[String]' has no member 'IsPrefix'\n    if strings.IsPrefix(prefix)\
    \ {\n       ~~~~~~~ ^~~~~~~~\n/tmp/tmpr9zzm92y.swift:12:24: error: value of type\
    \ '[String]' has no member 'Substr'\n        return strings.Substr(prefix.Length)\n\
    \               ~~~~~~~ ^~~~~~\n/tmp/tmpr9zzm92y.swift:12:38: error: value of\
    \ type 'String' has no member 'Length'\n        return strings.Substr(prefix.Length)\n\
    \                              ~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter { (string:\
    \ String) -> Bool in\n\t\treturn string.hasPrefix(prefix)\n\t}\n\treturn filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return filter_by_prefix(strings,\
    \ prefix, true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxb86vhxp.swift:8:46: error: extra argument in call\n    return\
    \ filter_by_prefix(strings, prefix, true)\n                           ~~~~~~~~~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered = [String]()\n   \
    \ for s in strings {\n        if s.startsWith(prefix) {\n            filtered\
    \ = append(filtered, s)\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq3t_f_2w.swift:10:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n/tmp/tmpq3t_f_2w.swift:11:24:\
    \ error: cannot find 'append' in scope\n            filtered = append(filtered,\
    \ s)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tif strings.IsNullOrEmpty(prefix)\
    \ {\n\t\treturn strings\n\t}\n\tfilteredStrings := strings.FilterStrings(strings.HasPrefix,\
    \ strings)\n\treturn filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == [] as [String])\n\
    assert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"\
    xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxvsjq6dm.swift:11:17: error: consecutive statements on a line must\
    \ be separated by ';'\n        filteredStrings := strings.FilterStrings(strings.HasPrefix,\
    \ strings)\n                       ^\n                       ;\n/tmp/tmpxvsjq6dm.swift:11:18:\
    \ error: expected expression\n        filteredStrings := strings.FilterStrings(strings.HasPrefix,\
    \ strings)\n                        ^\n/tmp/tmpxvsjq6dm.swift:8:13: error: value\
    \ of type '[String]' has no member 'IsNullOrEmpty'\n        if strings.IsNullOrEmpty(prefix)\
    \ {\n           ~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpxvsjq6dm.swift:11:2: error: cannot\
    \ find 'filteredStrings' in scope\n        filteredStrings := strings.FilterStrings(strings.HasPrefix,\
    \ strings)\n        ^~~~~~~~~~~~~~~\n/tmp/tmpxvsjq6dm.swift:12:9: error: cannot\
    \ find 'filteredStrings' in scope\n        return filteredStrings\n          \
    \     ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered = [String]()\n   \
    \ for s in strings {\n        if s.startsWith(prefix) {\n            filtered\
    \ = append(filtered, s)\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq3t_f_2w.swift:10:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n/tmp/tmpq3t_f_2w.swift:11:24:\
    \ error: cannot find 'append' in scope\n            filtered = append(filtered,\
    \ s)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter { (string:\
    \ String) -> Bool in\n\t\treturn string.hasPrefix(prefix)\n\t}\n\treturn filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet prefixes = strings.map { $0.prefix(prefix)\
    \ }\n\treturn strings.filter { prefixes.contains($0) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmptntsts0t.swift:8:41: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        let prefixes = strings.map { $0.prefix(prefix)\
    \ }\n                                               ^\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tprefix += \" \"\n\tstrings = strings.filter({\
    \ $0.hasPrefix(prefix) })\n\treturn strings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == []\
    \ as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"\
    xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjesy0tjy.swift:8:9: error: left side of mutating operator isn't\
    \ mutable: 'prefix' is a 'let' constant\n        prefix += \" \"\n        ~~~~~~\
    \ ^\n/tmp/tmpjesy0tjy.swift:9:2: error: cannot assign to value: 'strings' is a\
    \ 'let' constant\n        strings = strings.filter({ $0.hasPrefix(prefix) })\n\
    \        ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered = [String]()\n   \
    \ for s in strings {\n        if s.startsWith(prefix) {\n            filtered\
    \ = append(filtered, s)\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq3t_f_2w.swift:10:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n/tmp/tmpq3t_f_2w.swift:11:24:\
    \ error: cannot find 'append' in scope\n            filtered = append(filtered,\
    \ s)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\treturn filter_by_prefix(strings,\
    \ prefix, true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp37hx4z65.swift:8:43: error: extra argument in call\n        return\
    \ filter_by_prefix(strings, prefix, true)\n                               ~~~~~~~~~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tif strings.IsNullOrEmpty(prefix)\
    \ {\n\t\treturn strings\n\t}\n\treturn strings.filter({ $0.hasPrefix(prefix) })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpf4pvxgbs.swift:8:13: error: value of type '[String]' has no member\
    \ 'IsNullOrEmpty'\n        if strings.IsNullOrEmpty(prefix) {\n           ~~~~~~~\
    \ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return filter_by_prefix(strings,\
    \ prefix, true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxb86vhxp.swift:8:46: error: extra argument in call\n    return\
    \ filter_by_prefix(strings, prefix, true)\n                           ~~~~~~~~~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return filter_by_prefix(strings,\
    \ prefix, true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxb86vhxp.swift:8:46: error: extra argument in call\n    return\
    \ filter_by_prefix(strings, prefix, true)\n                           ~~~~~~~~~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    if strings.IsEmpty() {\n      \
    \  return strings\n    }\n    if strings.Contains(prefix) {\n        return strings.filter({\
    \ $0.hasPrefix(prefix) })\n    }\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == []\
    \ as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"\
    xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9fjceh83.swift:8:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n/tmp/tmp9fjceh83.swift:11:16:\
    \ error: value of type '[String]' has no member 'Contains'\n    if strings.Contains(prefix)\
    \ {\n       ~~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet prefix = prefix.lowercased()\n\
    \treturn strings.filter {\n\t\t$0.hasPrefix(prefix)\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\treturn filter_by_prefix(strings,\
    \ prefix, true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp37hx4z65.swift:8:43: error: extra argument in call\n        return\
    \ filter_by_prefix(strings, prefix, true)\n                               ~~~~~~~~~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tprefix = prefix.lowercased()\n\t\
    filtered = strings.filter {\n\t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp48y_gx46.swift:8:2: error: cannot assign to value: 'prefix' is\
    \ a 'let' constant\n        prefix = prefix.lowercased()\n        ^~~~~~\n/tmp/tmp48y_gx46.swift:9:2:\
    \ error: cannot find 'filtered' in scope\n        filtered = strings.filter {\n\
    \        ^~~~~~~~\n/tmp/tmp48y_gx46.swift:12:9: error: cannot find 'filtered'\
    \ in scope\n        return filtered\n               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    if strings.IsEmpty() {\n      \
    \  return strings\n    }\n    if strings.HasPrefix(prefix) {\n        return strings.SplitN(prefix,\
    \ 1, strings)\n    }\n    return strings\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == [] as [String])\n\
    assert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"\
    xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpi06bvb1w.swift:8:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n/tmp/tmpi06bvb1w.swift:11:16:\
    \ error: value of type '[String]' has no member 'HasPrefix'\n    if strings.HasPrefix(prefix)\
    \ {\n       ~~~~~~~ ^~~~~~~~~\n/tmp/tmpi06bvb1w.swift:12:24: error: value of type\
    \ '[String]' has no member 'SplitN'\n        return strings.SplitN(prefix, 1,\
    \ strings)\n               ~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return filter_by_prefix(strings,\
    \ prefix, true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxb86vhxp.swift:8:46: error: extra argument in call\n    return\
    \ filter_by_prefix(strings, prefix, true)\n                           ~~~~~~~~~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered = [String]()\n   \
    \ for s in strings {\n        if s.startsWith(prefix) {\n            filtered\
    \ = append(filtered, s)\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq3t_f_2w.swift:10:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n/tmp/tmpq3t_f_2w.swift:11:24:\
    \ error: cannot find 'append' in scope\n            filtered = append(filtered,\
    \ s)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return filter_by_prefix(strings,\
    \ prefix, true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxb86vhxp.swift:8:46: error: extra argument in call\n    return\
    \ filter_by_prefix(strings, prefix, true)\n                           ~~~~~~~~~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return filter_by_prefix(strings,\
    \ prefix, true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxb86vhxp.swift:8:46: error: extra argument in call\n    return\
    \ filter_by_prefix(strings, prefix, true)\n                           ~~~~~~~~~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return filter_by_prefix(strings,\
    \ prefix, true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxb86vhxp.swift:8:46: error: extra argument in call\n    return\
    \ filter_by_prefix(strings, prefix, true)\n                           ~~~~~~~~~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tprefix = prefix.lowercased()\n\t\
    strings = strings.filter({ $0.hasPrefix(prefix) })\n\treturn strings\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpg8y80li_.swift:8:2: error: cannot assign to value: 'prefix' is\
    \ a 'let' constant\n        prefix = prefix.lowercased()\n        ^~~~~~\n/tmp/tmpg8y80li_.swift:9:2:\
    \ error: cannot assign to value: 'strings' is a 'let' constant\n        strings\
    \ = strings.filter({ $0.hasPrefix(prefix) })\n        ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return strings.filter({ $0.hasPrefix(prefix)\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(filter_by_prefix(strings: []\
    \ as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824545
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\treturn filter_by_prefix(strings,\
    \ prefix, true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp37hx4z65.swift:8:43: error: extra argument in call\n        return\
    \ filter_by_prefix(strings, prefix, true)\n                               ~~~~~~~~~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter { (string:\
    \ String) -> Bool in\n\t\treturn string.hasPrefix(prefix)\n\t}\n\treturn filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter { (string:\
    \ String) -> Bool in\n\t\treturn string.hasPrefix(prefix)\n\t}\n\treturn filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\treturn filter_by_prefix(strings,\
    \ prefix, true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp37hx4z65.swift:8:43: error: extra argument in call\n        return\
    \ filter_by_prefix(strings, prefix, true)\n                               ~~~~~~~~~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered = [String]()\n   \
    \ for s in strings {\n        if s.startsWith(prefix) {\n            filtered\
    \ = append(filtered, s)\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq3t_f_2w.swift:10:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n/tmp/tmpq3t_f_2w.swift:11:24:\
    \ error: cannot find 'append' in scope\n            filtered = append(filtered,\
    \ s)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered = [String]()\n   \
    \ for s in strings {\n        if s.startsWith(prefix) {\n            filtered\
    \ = append(filtered, s)\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq3t_f_2w.swift:10:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n/tmp/tmpq3t_f_2w.swift:11:24:\
    \ error: cannot find 'append' in scope\n            filtered = append(filtered,\
    \ s)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tprefix = prefix.lowercased()\n\t\
    strings = strings.filter({ $0.hasPrefix(prefix) })\n\treturn strings\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpg8y80li_.swift:8:2: error: cannot assign to value: 'prefix' is\
    \ a 'let' constant\n        prefix = prefix.lowercased()\n        ^~~~~~\n/tmp/tmpg8y80li_.swift:9:2:\
    \ error: cannot assign to value: 'strings' is a 'let' constant\n        strings\
    \ = strings.filter({ $0.hasPrefix(prefix) })\n        ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered = [String]()\n   \
    \ for s in strings {\n        if s.startsWith(prefix) {\n            filtered\
    \ = append(filtered, s)\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq3t_f_2w.swift:10:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n/tmp/tmpq3t_f_2w.swift:11:24:\
    \ error: cannot find 'append' in scope\n            filtered = append(filtered,\
    \ s)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter { (string:\
    \ String) -> Bool in\n\t\treturn string.hasPrefix(prefix)\n\t}\n\treturn filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered = [String]()\n   \
    \ for s in strings {\n        if s.startsWith(prefix) {\n            filtered\
    \ = append(filtered, s)\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq3t_f_2w.swift:10:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n/tmp/tmpq3t_f_2w.swift:11:24:\
    \ error: cannot find 'append' in scope\n            filtered = append(filtered,\
    \ s)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return strings.filter { (string)\
    \ -> Bool in\n        let prefixLength = string.characters.count\n        let\
    \ prefixIndex = string.characters.index(string.startIndex, offsetBy: prefixLength)\n\
    \        return prefixIndex != nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == []\
    \ as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"\
    xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpe3xwaq8d.swift:11:28: warning: comparing non-optional value of\
    \ type 'String.Index' to 'nil' always returns true\n        return prefixIndex\
    \ != nil\n               ~~~~~~~~~~~ ^  ~~~\n/tmp/tmpe3xwaq8d.swift:9:35: error:\
    \ 'characters' is unavailable: Please use String directly\n        let prefixLength\
    \ = string.characters.count\n                                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpe3xwaq8d.swift:10:34: error: 'characters'\
    \ is unavailable: Please use String directly\n        let prefixIndex = string.characters.index(string.startIndex,\
    \ offsetBy: prefixLength)\n                                 ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered = [String]()\n   \
    \ for s in strings {\n        if s.startsWith(prefix) {\n            filtered\
    \ = append(filtered, s)\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq3t_f_2w.swift:10:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n/tmp/tmpq3t_f_2w.swift:11:24:\
    \ error: cannot find 'append' in scope\n            filtered = append(filtered,\
    \ s)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return filter_by_prefix(strings,\
    \ prefix, true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxb86vhxp.swift:8:46: error: extra argument in call\n    return\
    \ filter_by_prefix(strings, prefix, true)\n                           ~~~~~~~~~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return filter_by_prefix(strings,\
    \ prefix, true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxb86vhxp.swift:8:46: error: extra argument in call\n    return\
    \ filter_by_prefix(strings, prefix, true)\n                           ~~~~~~~~~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter { (string:\
    \ String) -> Bool in\n\t\treturn string.hasPrefix(prefix)\n\t}\n\treturn filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return filter_by_prefix(strings,\
    \ prefix, true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxb86vhxp.swift:8:46: error: extra argument in call\n    return\
    \ filter_by_prefix(strings, prefix, true)\n                           ~~~~~~~~~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    if strings.IsEmpty() {\n      \
    \  return strings\n    }\n    if strings.HasPrefix(prefix) {\n        return strings.SplitN(prefix,\
    \ 1, strings)\n    }\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == [] as [String])\n\
    assert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"\
    xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpixizhj9h.swift:8:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n/tmp/tmpixizhj9h.swift:11:16:\
    \ error: value of type '[String]' has no member 'HasPrefix'\n    if strings.HasPrefix(prefix)\
    \ {\n       ~~~~~~~ ^~~~~~~~~\n/tmp/tmpixizhj9h.swift:12:24: error: value of type\
    \ '[String]' has no member 'SplitN'\n        return strings.SplitN(prefix, 1,\
    \ strings)\n               ~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter { (string:\
    \ String) -> Bool in\n\t\treturn string.hasPrefix(prefix)\n\t}\n\treturn filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    if strings.IsEmpty() {\n      \
    \  return strings\n    }\n    if strings.HasPrefix(prefix) {\n        return strings.filter({\
    \ $0.hasPrefix(prefix) })\n    }\n    return strings\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq30n0swn.swift:8:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n/tmp/tmpq30n0swn.swift:11:16:\
    \ error: value of type '[String]' has no member 'HasPrefix'\n    if strings.HasPrefix(prefix)\
    \ {\n       ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter { (string:\
    \ String) -> Bool in\n\t\treturn string.hasPrefix(prefix)\n\t}\n\treturn filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered = [String]()\n   \
    \ for s in strings {\n        if s.startsWith(prefix) {\n            filtered\
    \ = append(filtered, s)\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq3t_f_2w.swift:10:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n/tmp/tmpq3t_f_2w.swift:11:24:\
    \ error: cannot find 'append' in scope\n            filtered = append(filtered,\
    \ s)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\treturn filter_by_prefix(strings,\
    \ prefix, true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp37hx4z65.swift:8:43: error: extra argument in call\n        return\
    \ filter_by_prefix(strings, prefix, true)\n                               ~~~~~~~~~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    if strings.IsEmpty() {\n      \
    \  return strings\n    }\n    if strings.Contains(prefix) {\n        return strings.filter({\
    \ $0.hasPrefix(prefix) })\n    }\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == []\
    \ as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"\
    xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9fjceh83.swift:8:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n/tmp/tmp9fjceh83.swift:11:16:\
    \ error: value of type '[String]' has no member 'Contains'\n    if strings.Contains(prefix)\
    \ {\n       ~~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\treturn filter_by_prefix(strings,\
    \ prefix, true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp37hx4z65.swift:8:43: error: extra argument in call\n        return\
    \ filter_by_prefix(strings, prefix, true)\n                               ~~~~~~~~~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter { (string:\
    \ String) -> Bool in\n\t\treturn string.hasPrefix(prefix)\n\t}\n\treturn filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered = [String]()\n   \
    \ for s in strings {\n        if s.startsWith(prefix) {\n            filtered\
    \ = append(filtered, s)\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq3t_f_2w.swift:10:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n/tmp/tmpq3t_f_2w.swift:11:24:\
    \ error: cannot find 'append' in scope\n            filtered = append(filtered,\
    \ s)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return filter_by_prefix(strings,\
    \ prefix, true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxb86vhxp.swift:8:46: error: extra argument in call\n    return\
    \ filter_by_prefix(strings, prefix, true)\n                           ~~~~~~~~~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tif strings.IsNullOrEmpty(prefix)\
    \ {\n\t\treturn strings\n\t}\n\tstrings = strings.ToLower()\n\tprefix = prefix.ToLower()\n\
    \treturn strings.SplitN(strings, prefix, func(i int, s string) bool {\n\t\treturn\
    \ strings.HasPrefix(s, prefix)\n\t})\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == [] as [String])\n\
    assert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"\
    xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpcmybffk_.swift:13:41: error: expected expression in list of expressions\n\
    \        return strings.SplitN(strings, prefix, func(i int, s string) bool {\n\
    \                                               ^\n/tmp/tmpcmybffk_.swift:13:45:\
    \ error: expected identifier in function declaration\n        return strings.SplitN(strings,\
    \ prefix, func(i int, s string) bool {\n                                     \
    \              ^\n/tmp/tmpcmybffk_.swift:8:13: error: value of type '[String]'\
    \ has no member 'IsNullOrEmpty'\n        if strings.IsNullOrEmpty(prefix) {\n\
    \           ~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpcmybffk_.swift:11:2: error: cannot\
    \ assign to value: 'strings' is a 'let' constant\n        strings = strings.ToLower()\n\
    \        ^~~~~~~\n/tmp/tmpcmybffk_.swift:11:20: error: value of type '[String]'\
    \ has no member 'ToLower'\n        strings = strings.ToLower()\n             \
    \     ~~~~~~~ ^~~~~~~\n/tmp/tmpcmybffk_.swift:12:2: error: cannot assign to value:\
    \ 'prefix' is a 'let' constant\n        prefix = prefix.ToLower()\n        ^~~~~~\n\
    /tmp/tmpcmybffk_.swift:12:18: error: value of type 'String' has no member 'ToLower'\n\
    \        prefix = prefix.ToLower()\n                 ~~~~~~ ^~~~~~~\n/tmp/tmpcmybffk_.swift:13:17:\
    \ error: value of type '[String]' has no member 'SplitN'\n        return strings.SplitN(strings,\
    \ prefix, func(i int, s string) bool {\n               ~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return filter_by_prefix(strings,\
    \ prefix, true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxb86vhxp.swift:8:46: error: extra argument in call\n    return\
    \ filter_by_prefix(strings, prefix, true)\n                           ~~~~~~~~~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\treturn filter_by_prefix(strings,\
    \ prefix, true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp37hx4z65.swift:8:43: error: extra argument in call\n        return\
    \ filter_by_prefix(strings, prefix, true)\n                               ~~~~~~~~~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    if strings.IsEmpty() {\n      \
    \  return strings\n    }\n    if strings.HasPrefix(prefix) {\n        return strings.SplitN(prefix,\
    \ 1, strings)\n    }\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == [] as [String])\n\
    assert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"\
    xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpixizhj9h.swift:8:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n/tmp/tmpixizhj9h.swift:11:16:\
    \ error: value of type '[String]' has no member 'HasPrefix'\n    if strings.HasPrefix(prefix)\
    \ {\n       ~~~~~~~ ^~~~~~~~~\n/tmp/tmpixizhj9h.swift:12:24: error: value of type\
    \ '[String]' has no member 'SplitN'\n        return strings.SplitN(prefix, 1,\
    \ strings)\n               ~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet prefix = prefix.lowercased()\n\
    \treturn strings.filter {\n\t\t$0.hasPrefix(prefix)\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered = [String]()\n   \
    \ for s in strings {\n        if s.startsWith(prefix) {\n            filtered\
    \ = append(filtered, s)\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq3t_f_2w.swift:10:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n/tmp/tmpq3t_f_2w.swift:11:24:\
    \ error: cannot find 'append' in scope\n            filtered = append(filtered,\
    \ s)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    if strings.IsEmpty() {\n      \
    \  return strings\n    }\n    if strings.HasPrefix(prefix) {\n        return strings.SplitN(prefix,\
    \ 1, strings)\n    }\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == [] as [String])\n\
    assert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"\
    xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpixizhj9h.swift:8:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n/tmp/tmpixizhj9h.swift:11:16:\
    \ error: value of type '[String]' has no member 'HasPrefix'\n    if strings.HasPrefix(prefix)\
    \ {\n       ~~~~~~~ ^~~~~~~~~\n/tmp/tmpixizhj9h.swift:12:24: error: value of type\
    \ '[String]' has no member 'SplitN'\n        return strings.SplitN(prefix, 1,\
    \ strings)\n               ~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tprefix += \"\"\n\treturn strings.filter({\
    \ $0.hasPrefix(prefix) })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpd3n2rube.swift:8:9: error: left side of mutating operator isn't\
    \ mutable: 'prefix' is a 'let' constant\n        prefix += \"\"\n        ~~~~~~\
    \ ^\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter { (string:\
    \ String) -> Bool in\n\t\treturn string.hasPrefix(prefix)\n\t}\n\treturn filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered = [String]()\n   \
    \ for s in strings {\n        if s.startsWith(prefix) {\n            filtered\
    \ = append(filtered, s)\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq3t_f_2w.swift:10:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n/tmp/tmpq3t_f_2w.swift:11:24:\
    \ error: cannot find 'append' in scope\n            filtered = append(filtered,\
    \ s)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered = [String]()\n   \
    \ for s in strings {\n        if s.startsWith(prefix) {\n            filtered\
    \ = append(filtered, s)\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq3t_f_2w.swift:10:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n/tmp/tmpq3t_f_2w.swift:11:24:\
    \ error: cannot find 'append' in scope\n            filtered = append(filtered,\
    \ s)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tprefix += \" \"\n\tstrings = strings.filter({\
    \ $0.hasPrefix(prefix) })\n\treturn strings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == []\
    \ as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"\
    xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjesy0tjy.swift:8:9: error: left side of mutating operator isn't\
    \ mutable: 'prefix' is a 'let' constant\n        prefix += \" \"\n        ~~~~~~\
    \ ^\n/tmp/tmpjesy0tjy.swift:9:2: error: cannot assign to value: 'strings' is a\
    \ 'let' constant\n        strings = strings.filter({ $0.hasPrefix(prefix) })\n\
    \        ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered = [String]()\n   \
    \ for s in strings {\n        if s.startsWith(prefix) {\n            filtered\
    \ = append(filtered, s)\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq3t_f_2w.swift:10:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n/tmp/tmpq3t_f_2w.swift:11:24:\
    \ error: cannot find 'append' in scope\n            filtered = append(filtered,\
    \ s)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter { (string:\
    \ String) -> Bool in\n\t\treturn string.hasPrefix(prefix)\n\t}\n\treturn filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    if strings.IsEmpty() {\n      \
    \  return strings\n    }\n    if strings.IsSingle() && strings.First().StartsWith(prefix)\
    \ {\n        return strings.Take(1)\n    }\n    return strings\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmptk90ts6o.swift:8:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n/tmp/tmptk90ts6o.swift:11:16:\
    \ error: value of type '[String]' has no member 'IsSingle'\n    if strings.IsSingle()\
    \ && strings.First().StartsWith(prefix) {\n       ~~~~~~~ ^~~~~~~~\n/tmp/tmptk90ts6o.swift:11:38:\
    \ error: value of type '[String]' has no member 'First'\n    if strings.IsSingle()\
    \ && strings.First().StartsWith(prefix) {\n                             ~~~~~~~\
    \ ^~~~~\n/tmp/tmptk90ts6o.swift:12:24: error: value of type '[String]' has no\
    \ member 'Take'\n        return strings.Take(1)\n               ~~~~~~~ ^~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered = [String]()\n   \
    \ for s in strings {\n        if s.startsWith(prefix) {\n            filtered\
    \ = append(filtered, s)\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq3t_f_2w.swift:10:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n/tmp/tmpq3t_f_2w.swift:11:24:\
    \ error: cannot find 'append' in scope\n            filtered = append(filtered,\
    \ s)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter { (string:\
    \ String) -> Bool in\n\t\treturn string.hasPrefix(prefix)\n\t}\n\treturn filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter { (string:\
    \ String) -> Bool in\n\t\treturn string.hasPrefix(prefix)\n\t}\n\treturn filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered = [String]()\n   \
    \ for s in strings {\n        if s.startsWith(prefix) {\n            filtered\
    \ = append(filtered, s)\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq3t_f_2w.swift:10:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n/tmp/tmpq3t_f_2w.swift:11:24:\
    \ error: cannot find 'append' in scope\n            filtered = append(filtered,\
    \ s)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\treturn filter_by_prefix(strings,\
    \ prefix, true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp37hx4z65.swift:8:43: error: extra argument in call\n        return\
    \ filter_by_prefix(strings, prefix, true)\n                               ~~~~~~~~~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet prefixes = strings.map { $0.prefix(prefix)\
    \ }\n\treturn strings.filter {\n\t\t$0.prefix(prefix) == true || prefixes.contains($0)\n\
    \t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(filter_by_prefix(strings: []\
    \ as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjigdaelb.swift:8:41: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        let prefixes = strings.map { $0.prefix(prefix)\
    \ }\n                                               ^\n/tmp/tmpjigdaelb.swift:10:13:\
    \ error: cannot convert value of type 'String' to expected argument type 'Int'\n\
    \                $0.prefix(prefix) == true || prefixes.contains($0)\n        \
    \                  ^\n/tmp/tmpjigdaelb.swift:10:6: error: cannot convert value\
    \ of type 'String.SubSequence' (aka 'Substring') to expected argument type 'Bool'\n\
    \                $0.prefix(prefix) == true || prefixes.contains($0)\n        \
    \           ^\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return filter_by_prefix(strings,\
    \ prefix, true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxb86vhxp.swift:8:46: error: extra argument in call\n    return\
    \ filter_by_prefix(strings, prefix, true)\n                           ~~~~~~~~~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    if strings.IsEmpty() {\n      \
    \  return strings\n    }\n    if strings.Contains(prefix) {\n        return strings.filter({\
    \ $0.hasPrefix(prefix) })\n    } else {\n        return strings\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmps4rm3in7.swift:8:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n/tmp/tmps4rm3in7.swift:11:16:\
    \ error: value of type '[String]' has no member 'Contains'\n    if strings.Contains(prefix)\
    \ {\n       ~~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet prefixes = strings.map { $0.hasPrefix(prefix)\
    \ }\n\treturn strings.filter { prefixes.contains($0) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp76oxgad0.swift:9:26: error: instance method 'contains' requires\
    \ the types 'Bool' and 'String.Element' (aka 'Character') be equivalent\n    \
    \    return strings.filter { prefixes.contains($0) }\n                       \
    \         ^\n_StringProcessing.Collection:3:17: note: where 'Self.Element' = 'Bool',\
    \ 'C.Element' = 'String.Element' (aka 'Character')\n    public func contains<C>(_\
    \ other: C) -> Bool where C : Collection, Self.Element == C.Element\n        \
    \        ^\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    if strings.IsEmpty() {\n      \
    \  return strings\n    }\n    if strings.HasPrefix(prefix) {\n        return strings.SplitN(prefix,\
    \ 1, strings)\n    }\n    return strings\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == [] as [String])\n\
    assert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"\
    xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpi06bvb1w.swift:8:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n/tmp/tmpi06bvb1w.swift:11:16:\
    \ error: value of type '[String]' has no member 'HasPrefix'\n    if strings.HasPrefix(prefix)\
    \ {\n       ~~~~~~~ ^~~~~~~~~\n/tmp/tmpi06bvb1w.swift:12:24: error: value of type\
    \ '[String]' has no member 'SplitN'\n        return strings.SplitN(prefix, 1,\
    \ strings)\n               ~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter { (string:\
    \ String) -> Bool in\n\t\treturn string.hasPrefix(prefix)\n\t}\n\treturn filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet prefixes = strings.map { $0.startsWith(prefix)\
    \ }\n\treturn strings.filter { prefixes.contains($0) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpdxxza4w3.swift:8:34: error: value of type 'String' has no member\
    \ 'startsWith'\n        let prefixes = strings.map { $0.startsWith(prefix) }\n\
    \                                     ~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tif strings.IsNullOrEmpty(prefix)\
    \ {\n\t\treturn strings\n\t}\n\tvar filtered = [String]()\n\tfor _, s := range\
    \ strings {\n\t\tif strings.HasPrefix(s, prefix) {\n\t\t\tfiltered = append(filtered,\
    \ s)\n\t\t}\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == [] as [String])\n\
    assert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"\
    xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpc63_bhzw.swift:12:7: error: expected 'in' after for-each pattern\n\
    \        for _, s := range strings {\n             ^\n/tmp/tmpc63_bhzw.swift:12:7:\
    \ error: expected Sequence expression for for-each loop\n        for _, s := range\
    \ strings {\n             ^\n/tmp/tmpc63_bhzw.swift:8:13: error: value of type\
    \ '[String]' has no member 'IsNullOrEmpty'\n        if strings.IsNullOrEmpty(prefix)\
    \ {\n           ~~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tif strings.IsNullOrEmpty(prefix)\
    \ {\n\t\treturn strings\n\t}\n\tfilteredStrings := make([]string, 0)\n\tfor _,\
    \ s := range strings {\n\t\tif strings.HasPrefix(s, prefix) {\n\t\t\tfilteredStrings\
    \ = append(filteredStrings, s)\n\t\t}\n\t}\n\treturn filteredStrings\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpqphh7xpy.swift:11:17: error: consecutive statements on a line must\
    \ be separated by ';'\n        filteredStrings := make([]string, 0)\n        \
    \               ^\n                       ;\n/tmp/tmpqphh7xpy.swift:11:18: error:\
    \ expected expression\n        filteredStrings := make([]string, 0)\n        \
    \                ^\n/tmp/tmpqphh7xpy.swift:12:7: error: expected 'in' after for-each\
    \ pattern\n        for _, s := range strings {\n             ^\n/tmp/tmpqphh7xpy.swift:12:7:\
    \ error: expected Sequence expression for for-each loop\n        for _, s := range\
    \ strings {\n             ^\n/tmp/tmpqphh7xpy.swift:8:13: error: value of type\
    \ '[String]' has no member 'IsNullOrEmpty'\n        if strings.IsNullOrEmpty(prefix)\
    \ {\n           ~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpqphh7xpy.swift:11:2: error: cannot\
    \ find 'filteredStrings' in scope\n        filteredStrings := make([]string, 0)\n\
    \        ^~~~~~~~~~~~~~~\n/tmp/tmpqphh7xpy.swift:17:9: error: cannot find 'filteredStrings'\
    \ in scope\n        return filteredStrings\n               ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return filter_by_prefix(strings,\
    \ prefix, true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxb86vhxp.swift:8:46: error: extra argument in call\n    return\
    \ filter_by_prefix(strings, prefix, true)\n                           ~~~~~~~~~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return filter_by_prefix(strings,\
    \ prefix, true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxb86vhxp.swift:8:46: error: extra argument in call\n    return\
    \ filter_by_prefix(strings, prefix, true)\n                           ~~~~~~~~~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered = [String]()\n   \
    \ for s in strings {\n        if s.startsWith(prefix) {\n            filtered\
    \ = append(filtered, s)\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq3t_f_2w.swift:10:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n/tmp/tmpq3t_f_2w.swift:11:24:\
    \ error: cannot find 'append' in scope\n            filtered = append(filtered,\
    \ s)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tprefix += \"\"\n\tstrings = strings.filter({\
    \ $0.hasPrefix(prefix) })\n\treturn strings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == []\
    \ as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"\
    xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpvw9oxjn2.swift:8:9: error: left side of mutating operator isn't\
    \ mutable: 'prefix' is a 'let' constant\n        prefix += \"\"\n        ~~~~~~\
    \ ^\n/tmp/tmpvw9oxjn2.swift:9:2: error: cannot assign to value: 'strings' is a\
    \ 'let' constant\n        strings = strings.filter({ $0.hasPrefix(prefix) })\n\
    \        ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered = [String]()\n   \
    \ for s in strings {\n        if s.startsWith(prefix) {\n            filtered\
    \ = append(filtered, s)\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq3t_f_2w.swift:10:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n/tmp/tmpq3t_f_2w.swift:11:24:\
    \ error: cannot find 'append' in scope\n            filtered = append(filtered,\
    \ s)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered = [String]()\n   \
    \ for s in strings {\n        if s.startsWith(prefix) {\n            filtered\
    \ = append(filtered, s)\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq3t_f_2w.swift:10:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n/tmp/tmpq3t_f_2w.swift:11:24:\
    \ error: cannot find 'append' in scope\n            filtered = append(filtered,\
    \ s)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter {\n\
    \t\t$0.hasPrefix(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 0
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter { (string:\
    \ String) -> Bool in\n\t\treturn string.hasPrefix(prefix)\n\t}\n\treturn filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered = [String]()\n   \
    \ for s in strings {\n        if s.startsWith(prefix) {\n            filtered\
    \ = append(filtered, s)\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq3t_f_2w.swift:10:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n/tmp/tmpq3t_f_2w.swift:11:24:\
    \ error: cannot find 'append' in scope\n            filtered = append(filtered,\
    \ s)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// Filter an input list of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
    \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    if strings.IsEmpty() {\n      \
    \  return strings\n    }\n    if strings.HasPrefix(prefix) {\n        return strings.SplitN(prefix,\
    \ 1, strings)\n    }\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == [] as [String])\n\
    assert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"\
    xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpixizhj9h.swift:8:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n/tmp/tmpixizhj9h.swift:11:16:\
    \ error: value of type '[String]' has no member 'HasPrefix'\n    if strings.HasPrefix(prefix)\
    \ {\n       ~~~~~~~ ^~~~~~~~~\n/tmp/tmpixizhj9h.swift:12:24: error: value of type\
    \ '[String]' has no member 'SplitN'\n        return strings.SplitN(prefix, 1,\
    \ strings)\n               ~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824578
