language: swift
name: HumanEval_72_will_it_fly
results:
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count == w else {\n\
    \        return false\n    }\n    \n    var maxSum = w\n    var maxSumIndex =\
    \ 0\n    \n    for i in 0..<q.count {\n        let sum = q[i] + maxSum\n     \
    \   \n        if sum > maxSum {\n            maxSum = sum\n            maxSumIndex\
    \ = i\n        }\n    }\n    \n    return maxSum == w && maxSumIndex == 0\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpkp1d_8x6/tmpkp1d_8x6.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b268b952c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b268b649b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b268b649988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b268b6487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkp1d_8x6                        0x0000555b064bd53f <unavailable> + 5439

    5    libc.so.6                          0x00002b268bb3e460 __libc_start_main +
    245

    6    tmpkp1d_8x6                        0x0000555b064bd1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014316
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var max = 0\n    for x in q\
    \ {\n        if x > max {\n            max = x\n        }\n    }\n    if max >\
    \ w {\n        return false\n    }\n    var sum = 0\n    for x in q {\n      \
    \  sum += x\n    }\n    if sum < w {\n        return false\n    }\n    return\
    \ true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpgk4pplz2/tmpgk4pplz2.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba5c922cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba5c8f23b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba5c8f23988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5c8f227b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgk4pplz2                        0x000056103e5ad46f <unavailable> + 5231

    5    libc.so.6                          0x00002ba5c9418460 __libc_start_main +
    245

    6    tmpgk4pplz2                        0x000056103e5ad0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014316
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxSum = w\n    var maxSumIndex\
    \ = 0\n    var maxSumElement = q[0]\n    for index in 0..<q.count {\n        let\
    \ element = q[index]\n        let sum = element + maxSumElement\n        if sum\
    \ > maxSum {\n            maxSum = sum\n            maxSumIndex = index\n    \
    \        maxSumElement = element\n        }\n    }\n    return maxSum == w\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp9a2x28st/tmp9a2x28st.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2740092c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b273fd89b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b273fd89988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b273fd887b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9a2x28st                        0x00005592812295fb <unavailable> + 5627

    5    libc.so.6                          0x00002b274027e460 __libc_start_main +
    245

    6    tmp9a2x28st                        0x00005592812291a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    if q.count < 2 || w < 0 || w\
    \ > Int.max {\n        return false\n    }\n    var max = 0\n    var maxIndex\
    \ = 0\n    var sum = 0\n    for index in 0..<q.count {\n        sum += q[index]\n\
    \        if sum > max {\n            max = sum\n            maxIndex = index\n\
    \        }\n    }\n    if maxIndex == 0 {\n        return true\n    }\n    if\
    \ maxIndex == q.count - 1 {\n        return false\n    }\n    if sum == max {\n\
    \        return true\n    }\n    return will_it_fly(q, w - max) + will_it_fly(q[maxIndex..<q.count],\
    \ w - max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2,\
    \ 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp598u2qqg.swift:36:23: error: missing argument labels 'q:w:' in\
    \ call\n    return will_it_fly(q, w - max) + will_it_fly(q[maxIndex..<q.count],\
    \ w - max)\n                      ^\n                       q: w: \n/tmp/tmp598u2qqg.swift:36:36:\
    \ error: binary operator '+' cannot be applied to two 'Bool' operands\n    return\
    \ will_it_fly(q, w - max) + will_it_fly(q[maxIndex..<q.count], w - max)\n    \
    \                               ^\nSwift.FloatingPoint:1:17: note: candidate requires\
    \ that 'Bool' conform to 'FloatingPoint' (requirement specified as 'Self' : 'FloatingPoint')\n\
    public protocol FloatingPoint : Hashable, SignedNumeric, Strideable where Self\
    \ == Self.Magnitude {\n                ^\n/tmp/tmp598u2qqg.swift:36:49: error:\
    \ missing argument labels 'q:w:' in call\n    return will_it_fly(q, w - max) +\
    \ will_it_fly(q[maxIndex..<q.count], w - max)\n                              \
    \                  ^\n                                                 q:    \
    \                 w: \n/tmp/tmp598u2qqg.swift:36:51: error: cannot convert value\
    \ of type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return will_it_fly(q,\
    \ w - max) + will_it_fly(q[maxIndex..<q.count], w - max)\n                   \
    \                               ^\n"
  stdout: ''
  timestamp: 1660014316
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum\
    \ = 0\n    var isBalanced = true\n    for element in q {\n        if element >\
    \ maxWeight {\n            maxWeight = element\n        }\n        if element\
    \ > maxSum {\n            maxSum = element\n        }\n        if element != maxWeight\
    \ {\n            isBalanced = false\n        }\n    }\n    return isBalanced &&\
    \ maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp4klpsbyr/tmp4klpsbyr.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af524dc7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af524abeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af524abe988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af524abd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4klpsbyr                        0x0000560d7340446f <unavailable> + 5231

    5    libc.so.6                          0x00002af524fb3460 __libc_start_main +
    245

    6    tmp4klpsbyr                        0x0000560d734040d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014316
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum\
    \ = q.reduce(0, +)\n    return maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpfs6hacoi/tmpfs6hacoi.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aefc3261c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aefc2f58b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aefc2f58988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aefc2f577b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfs6hacoi                        0x0000562da449043b <unavailable> + 5179

    5    libc.so.6                          0x00002aefc344d460 __libc_start_main +
    245

    6    tmpfs6hacoi                        0x0000562da448ffe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var max = 0\n    for x in q\
    \ {\n        max = max(max, x)\n    }\n    if max <= w {\n        return true\n\
    \    }\n    var sum = 0\n    for x in q {\n        sum += x\n    }\n    if sum\
    \ < w {\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp0iqpqol4.swift:16:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, x)\n              ^\n"
  stdout: ''
  timestamp: 1660014316
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count == w else {\n\
    \        return false\n    }\n    guard let first = q.first else {\n        return\
    \ true\n    }\n    guard let last = q.last else {\n        return true\n    }\n\
    \    let maxWeight = w - first - last\n    return q.count == maxWeight && q.sorted()\
    \ == q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpznw400yz/tmpznw400yz.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3bf03ffc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3bf00f6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3bf00f6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3bf00f57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpznw400yz                        0x000055c1bac985ff <unavailable> + 5631

    5    libc.so.6                          0x00002b3bf05eb460 __libc_start_main +
    245

    6    tmpznw400yz                        0x000055c1bac98269 <unavailable> + 4713

    '
  stdout: ''
  timestamp: 1660014316
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum\
    \ = q.reduce(0) { (max, next) -> Int in\n        return max + next\n    }\n  \
    \  return maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpdgxspvkz/tmpdgxspvkz.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7cf47b8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7cf44afb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7cf44af988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7cf44ae7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdgxspvkz                        0x00005632f71b343b <unavailable> + 5179

    5    libc.so.6                          0x00002b7cf49a4460 __libc_start_main +
    245

    6    tmpdgxspvkz                        0x00005632f71b2fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1660014316
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count == w else { return\
    \ false }\n    var max = 0\n    var sum = 0\n    for x in q {\n        sum +=\
    \ x\n        if sum > max {\n            max = sum\n        }\n    }\n    return\
    \ sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2,\
    \ 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp5dw4v__q/tmp5dw4v__q.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b97843fec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b97840f5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b97840f5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b97840f47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5dw4v__q                        0x00005654de8f64bf <unavailable> + 5311

    5    libc.so.6                          0x00002b97845ea460 __libc_start_main +
    245

    6    tmp5dw4v__q                        0x00005654de8f6129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 && w > 0 &&\
    \ w <= q.max() else {\n        return false\n    }\n    var sum = 0\n    for i\
    \ in q {\n        sum += i\n    }\n    return sum == w && q == q.sorted().reversed()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpsezzanax.swift:14:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else {\n                                         ^\n/tmp/tmpsezzanax.swift:14:42:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else {\n             \
    \                            ^\n                                             \
    \  ?? <#default value#>\n/tmp/tmpsezzanax.swift:14:42: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    guard q.count\
    \ > 0 && w > 0 && w <= q.max() else {\n                                      \
    \   ^\n                                              !\n"
  stdout: ''
  timestamp: 1660014316
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxSum = w\n    for element\
    \ in q {\n        maxSum -= element\n        if maxSum < 0 {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpx307ezpn/tmpx307ezpn.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b74389bac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b74386b1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b74386b1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b74386b07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx307ezpn                        0x0000559246c9652b <unavailable> + 5419

    5    libc.so.6                          0x00002b7438ba6460 __libc_start_main +
    245

    6    tmpx307ezpn                        0x0000559246c960d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxSum = w\n    var maxSumIndex\
    \ = 0\n    var maxSumElement = q[0]\n    for i := 1; i < len(q); i++ {\n     \
    \   maxSum += q[i]\n        if maxSum > w {\n            return false\n      \
    \  }\n        if maxSum > maxSumElement {\n            maxSumElement = maxSum\n\
    \            maxSumIndex = i\n        }\n    }\n    return maxSumElement == q[maxSumIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpu_a_k4vk.swift:17:12: error: expected type\n    for i := 1; i <\
    \ len(q); i++ {\n           ^\n            <#type#>\n/tmp/tmpu_a_k4vk.swift:17:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 1; i < len(q); i++\
    \ {\n           ^\n/tmp/tmpu_a_k4vk.swift:17:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 1; i < len(q); i++ {\n           ^\n"
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 && w > 0 &&\
    \ w <= q.max() else { return false }\n    \n    var i = 0\n    var j = q.count\
    \ - 1\n    \n    while i < j {\n        if q[i] != q[j] {\n            return\
    \ false\n        }\n        i += 1\n        j -= 1\n    }\n    \n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp7cx9yrx3.swift:14:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else { return false }\n                                         ^\n\
    /tmp/tmp7cx9yrx3.swift:14:42: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max()\
    \ else { return false }\n                                         ^\n        \
    \                                       ?? <#default value#>\n/tmp/tmp7cx9yrx3.swift:14:42:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else { return false }\n\
    \                                         ^\n                                \
    \              !\n"
  stdout: ''
  timestamp: 1660014316
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count == w else { return\
    \ false }\n    var max = 0\n    var sum = 0\n    for x in q {\n        sum +=\
    \ x\n        if sum > max {\n            max = sum\n        }\n    }\n    return\
    \ sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2,\
    \ 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp5dw4v__q/tmp5dw4v__q.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b97843fec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b97840f5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b97840f5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b97840f47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5dw4v__q                        0x00005654de8f64bf <unavailable> + 5311

    5    libc.so.6                          0x00002b97845ea460 __libc_start_main +
    245

    6    tmp5dw4v__q                        0x00005654de8f6129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 && w > 0 &&\
    \ w <= q.max() else {\n        return false\n    }\n    \n    var sum = 0\n  \
    \  var max = 0\n    for element in q {\n        sum += element\n        if sum\
    \ > max {\n            max = sum\n        }\n    }\n    \n    return sum == max\
    \ && q == q.sort()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpx8u0959r.swift:14:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else {\n                                         ^\n/tmp/tmpx8u0959r.swift:14:42:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else {\n             \
    \                            ^\n                                             \
    \  ?? <#default value#>\n/tmp/tmpx8u0959r.swift:14:42: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    guard q.count\
    \ > 0 && w > 0 && w <= q.max() else {\n                                      \
    \   ^\n                                              !\n/tmp/tmpx8u0959r.swift:27:26:\
    \ error: cannot convert value of type '[Int]' to expected argument type '()'\n\
    \    return sum == max && q == q.sort()\n                         ^\n/tmp/tmpx8u0959r.swift:27:33:\
    \ error: cannot use mutating member on immutable value: 'q' is a 'let' constant\n\
    \    return sum == max && q == q.sort()\n                              ~ ^\n"
  stdout: ''
  timestamp: 1660014316
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    \n    // Write your code here.\n\
    \    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpsb8g9qn7/tmpsb8g9qn7.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aafecd9dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aafeca94b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aafeca94988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aafeca937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb8g9qn7                        0x000055bb6fd643bb <unavailable> + 5051

    5    libc.so.6                          0x00002aafecf89460 __libc_start_main +
    245

    6    tmpsb8g9qn7                        0x000055bb6fd63f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 && w > 0 &&\
    \ w <= q.max() else {\n        return false\n    }\n    \n    var sum = 0\n  \
    \  for element in q {\n        sum += element\n    }\n    \n    return sum <=\
    \ w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w:\
    \ 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpbnb28947.swift:14:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else {\n                                         ^\n/tmp/tmpbnb28947.swift:14:42:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else {\n             \
    \                            ^\n                                             \
    \  ?? <#default value#>\n/tmp/tmpbnb28947.swift:14:42: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    guard q.count\
    \ > 0 && w > 0 && w <= q.max() else {\n                                      \
    \   ^\n                                              !\n"
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count == w else { return\
    \ false }\n    guard let first = q.first else { return false }\n    guard let\
    \ last = q.last else { return false }\n    guard let first = q.first else { return\
    \ false }\n    guard let last = q.last else { return false }\n    guard let first\
    \ = q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return \n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpm09masdy.swift:77:42: error: expected '}' at end of brace statement\n\
    assert(will_it_fly(q: [5], w: 5) == true)\n                                  \
    \       ^\n/tmp/tmpm09masdy.swift:13:44: note: to match this opening '{'\nfunc\
    \ will_it_fly(q: [Int], w: Int) -> Bool {\n                                  \
    \         ^\n/tmp/tmpm09masdy.swift:56:36: error: non-void function should return\
    \ a value\n    guard let last = q.last else { return \n                      \
    \             ^\n/tmp/tmpm09masdy.swift:60:6: error: operator functions can only\
    \ be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n/tmp/tmpm09masdy.swift:15:15: warning: value 'first'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let first = q.first else { return false }\n          ~~~~^~~~~~~~\n        \
    \                      != nil\n/tmp/tmpm09masdy.swift:16:15: warning: value 'last'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let last = q.last else { return false }\n          ~~~~^~~~~~~\n           \
    \                 != nil\n/tmp/tmpm09masdy.swift:17:15: warning: value 'first'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let first = q.first else { return false }\n          ~~~~^~~~~~~~\n        \
    \                      != nil\n/tmp/tmpm09masdy.swift:18:15: warning: value 'last'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let last = q.last else { return false }\n          ~~~~^~~~~~~\n           \
    \                 != nil\n/tmp/tmpm09masdy.swift:19:15: warning: value 'first'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let first = q.first else { return false }\n          ~~~~^~~~~~~~\n        \
    \                      != nil\n/tmp/tmpm09masdy.swift:20:15: warning: value 'last'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let last = q.last else { return false }\n          ~~~~^~~~~~~\n           \
    \                 != nil\n/tmp/tmpm09masdy.swift:21:15: warning: value 'f"
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 && w > 0 &&\
    \ w <= q.max() else { return false }\n    guard let first = q.first else { return\
    \ false }\n    guard let last = q.last else { return false }\n    guard let middle\
    \ = q.index(of: first) else { return false }\n    guard let middle2 = q.index(of:\
    \ last) else { return false }\n    guard let middle3 = q.index(of: middle) else\
    \ { return false }\n    guard let middle4 = q.index(of: middle2) else { return\
    \ false }\n    guard let middle5 = q.index(of: middle4) else { return false }\n\
    \    guard let middle6 = q.index(of: middle5) else { return false }\n    guard\
    \ let middle7 = q.index(of: middle6) else { return false }\n    guard let middle8\
    \ = q.index(of: middle7) else { return false }\n    guard let middle9 = q.index(of:\
    \ middle8) else { return false }\n    guard let middle10 = q.index(of: middle9)\
    \ else { return false }\n    guard let middle11 = q.index(of: middle10) else {\
    \ return false }\n    guard let middle12 = q.index(of: middle11) else { return\
    \ false }\n    guard let middle13 = q.index(of: middle12) else { return false\
    \ }\n    guard let middle14 = q.index(of: middle13) else { return false }\n  \
    \  guard let middle15 = q.index(of: middle14) else { return false }\n    guard\
    \ let middle16 = q.index(of: middle15) else { return false }\n    guard let middle17\
    \ = q.index(of: middle16) else { return false }\n    guard let middle18 = q.index(of:\
    \ middle17) else { return false }\n    guard let middle19 = q.index(of: middle18)\
    \ else { return false }\n    guard let middle20 = q.index(of: middle19) else {\
    \ return false }\n    guard let middle21 = q.index(of: middle20) else { return\
    \ false }\n    guard let middle22 = q.index(of: middle21) else { return false\
    \ }\n    guard let middle23 = q.index(of: middle22) else { return false }\n  \
    \  guard let middle24 = q.index(of: middle23) else { return false }\n    guard\
    \ let middle25 = q.index(of: middle24) else { return false }\n    guard let middle26\
    \ = q.index(of: middle25) else { return false }\n    guard let middle27 = q.index(of:\
    \ middle26) else \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp3gywpgl5.swift:43:52: error: expected '{' after 'guard' else\n\
    \    guard let middle27 = q.index(of: middle26) else \n                      \
    \                             ^\n/tmp/tmp3gywpgl5.swift:14:42: error: value of\
    \ optional type 'Int?' must be unwrapped to a value of type 'Int'\n    guard q.count\
    \ > 0 && w > 0 && w <= q.max() else { return false }\n                       \
    \                  ^\n/tmp/tmp3gywpgl5.swift:14:42: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n    guard q.count\
    \ > 0 && w > 0 && w <= q.max() else { return false }\n                       \
    \                  ^\n                                               ?? <#default\
    \ value#>\n/tmp/tmp3gywpgl5.swift:14:42: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n    guard q.count > 0 && w >\
    \ 0 && w <= q.max() else { return false }\n                                  \
    \       ^\n                                              !\n/tmp/tmp3gywpgl5.swift:17:26:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n    guard\
    \ let middle = q.index(of: first) else { return false }\n                    \
    \     ^\n/tmp/tmp3gywpgl5.swift:17:26: note: use 'firstIndex(of:)' instead\n \
    \   guard let middle = q.index(of: first) else { return false }\n            \
    \             ^~~~~\n                         firstIndex\n/tmp/tmp3gywpgl5.swift:18:27:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n    guard\
    \ let middle2 = q.index(of: last) else { return false }\n                    \
    \      ^\n/tmp/tmp3gywpgl5.swift:18:27: note: use 'firstIndex(of:)' instead\n\
    \    guard let middle2 = q.index(of: last) else { return false }\n           \
    \               ^~~~~\n                          firstIndex\n/tmp/tmp3gywpgl5.swift:19:27:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n    guard\
    \ let middle3 = q.index(of: middle) else { return false }\n                  \
    \        ^\n/tmp/tmp3gywpgl5.swift:19:27: note: use 'firstIndex(of:)' instead\n\
    \    guard let middle3 = q.index(of: middle) else { re"
  stdout: ''
  timestamp: 1660014316
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var max = 0\n    var sum = 0\n\
    \    for x in q {\n        sum += x\n        if sum > max {\n            max =\
    \ sum\n        }\n    }\n    return sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpcpelfk46/tmpcpelfk46.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8e02983c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8e0267ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8e0267a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8e026797b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcpelfk46                        0x000055cb42b4c52b <unavailable> + 5419

    5    libc.so.6                          0x00002b8e02b6f460 __libc_start_main +
    245

    6    tmpcpelfk46                        0x000055cb42b4c0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014316
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxSum = w\n    for x in\
    \ q {\n        maxSum = maxSum * x + x\n    }\n    return maxSum <= w\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpxjho1r8l/tmpxjho1r8l.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ade6dda6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ade6da9db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ade6da9d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ade6da9c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxjho1r8l                        0x000055b9d408546f <unavailable> + 5231

    5    libc.so.6                          0x00002ade6df92460 __libc_start_main +
    245

    6    tmpxjho1r8l                        0x000055b9d40850d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014316
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var max = 0\n    for v in q\
    \ {\n        if v > max {\n            max = v\n        }\n    }\n    if max <=\
    \ w {\n        return true\n    }\n    var sum = 0\n    for v in q {\n       \
    \ sum += v\n    }\n    if sum < w {\n        return false\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpttxrssyj/tmpttxrssyj.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acea6d9ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acea6a91b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acea6a91988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acea6a907b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpttxrssyj                        0x0000555ecf45452b <unavailable> + 5419

    5    libc.so.6                          0x00002acea6f86460 __libc_start_main +
    245

    6    tmpttxrssyj                        0x0000555ecf4540d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var max = 0\n    var sum = 0\n\
    \    for x in q {\n        sum += x\n        if sum > max {\n            max =\
    \ sum\n        }\n    }\n    return sum == max && is_palindromic(q) && w <= max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp79zn24y7.swift:22:26: error: cannot find 'is_palindromic' in scope\n\
    \    return sum == max && is_palindromic(q) && w <= max\n                    \
    \     ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 && w > 0 &&\
    \ w <= q.max() else { return false }\n    guard let first = q.first else { return\
    \ false }\n    guard let last = q.last else { return false }\n    guard let first\
    \ = q.first,\n        let last = q.last,\n        let first = q[0],\n        let\
    \ last = q[q.count-1],\n        let first = q[0],\n        let last = q[q.count-1],\n\
    \        let first = q[0],\n        let last = q[q.count-1],\n        let first\
    \ = q[0],\n        let last = q[q.count-1],\n        let first = q[0],\n     \
    \   let last = q[q.count-1],\n        let first = q[0],\n        let last = q[q.count-1],\n\
    \        let first = q[0],\n        let last = q[q.count-1],\n        let first\
    \ = q[0],\n        let last = q[q.count-1],\n        let first = q[0],\n     \
    \   let last = q[q.count-1],\n        let first = q[0],\n        let last = q[q.count-1],\n\
    \        let first = q[0],\n        let last = q[q.count-1],\n        let first\
    \ = q[0],\n        let last = q[q.count-1],\n        let first = q[0],\n     \
    \   let last = q[q.count-1],\n        let first = q[0],\n        let last = q[q.count-1],\n\
    \        let first = q[0],\n        let last = q[q.count-1],\n        let first\
    \ = q[0],\n        let last = q[q.count-1],\n        let first = q[0],\n     \
    \   let last = q[q.count-1],\n        let first = q[0],\n        let last = q[q.count-1],\n\
    \        let first = q[0],\n        let last = q[q.count-1],\n        let first\
    \ = q[0],\n        let last = q[q.count-1],\n        let first = q[0],\n     \
    \   let last = q[q.count-1],\n        let first = q[0],\n        let last = q[q.count-1],\n\
    \        let first = q[0],\n        let last = q[q.count-1],\n        let first\
    \ = q[0],\n        let last = q[q.count-1],\n        let first = q[0],\n     \
    \   let last = q[q.count-1],\n        let first = q[0],\n        let last = q[q.count-1],\n\
    \        let first = q[0],\n        let last = q[q.count-1],\n        let first\
    \ = q[0],\n        let last = q[q.count-1],\n        let first = q[0],\n     \
    \   let last = q[q.count-1],\n        let first = q[0],\n        let last = q[q.count-1],\n\
    \        let first = q[0],\n        let last = q[q.count-1],\n        let first\
    \ = q[0],\n        let last = q[q.count-1],\n        let first = q[0],\n\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpmjnd1kl2.swift:83:26: error: expected expression in conditional\n\
    \        let first = q[0],\n                         ^\n/tmp/tmpmjnd1kl2.swift:14:42:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \    guard q.count > 0 && w > 0 && w <= q.max() else { return false }\n      \
    \                                   ^\n/tmp/tmpmjnd1kl2.swift:14:42: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \ guard q.count > 0 && w > 0 && w <= q.max() else { return false }\n         \
    \                                ^\n                                         \
    \      ?? <#default value#>\n/tmp/tmpmjnd1kl2.swift:14:42: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    guard\
    \ q.count > 0 && w > 0 && w <= q.max() else { return false }\n               \
    \                          ^\n                                              !\n\
    /tmp/tmpmjnd1kl2.swift:19:9: error: initializer for conditional binding must have\
    \ Optional type, not 'Int'\n        let first = q[0],\n        ^           ~~~~\n\
    /tmp/tmpmjnd1kl2.swift:20:9: error: initializer for conditional binding must have\
    \ Optional type, not 'Int'\n        let last = q[q.count-1],\n        ^      \
    \    ~~~~~~~~~~~~\n/tmp/tmpmjnd1kl2.swift:21:9: error: initializer for conditional\
    \ binding must have Optional type, not 'Int'\n        let first = q[0],\n    \
    \    ^           ~~~~\n/tmp/tmpmjnd1kl2.swift:22:9: error: initializer for conditional\
    \ binding must have Optional type, not 'Int'\n        let last = q[q.count-1],\n\
    \        ^          ~~~~~~~~~~~~\n/tmp/tmpmjnd1kl2.swift:23:9: error: initializer\
    \ for conditional binding must have Optional type, not 'Int'\n        let first\
    \ = q[0],\n        ^           ~~~~\n/tmp/tmpmjnd1kl2.swift:24:9: error: initializer\
    \ for conditional binding must have Optional type, not 'Int'\n        let last\
    \ = q[q.count-1],\n        ^          ~~~~~~~~~~~~\n/tmp/tmpmjnd1kl2.swift:25:9:\
    \ error: initializer for conditional binding must have Optional type, not 'Int'\n\
    \        let first = q[0],\n       "
  stdout: ''
  timestamp: 1660014316
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var max = 0\n    for x in q\
    \ {\n        if x > max {\n            max = x\n        }\n    }\n    if max >\
    \ w {\n        return false\n    }\n    var sum = 0\n    for x in q {\n      \
    \  sum += x\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp1zkc4vnn/tmp1zkc4vnn.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acdb254dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acdb2244b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acdb2244988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acdb22437b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1zkc4vnn                        0x000056020f6d452b <unavailable> + 5419

    5    libc.so.6                          0x00002acdb2739460 __libc_start_main +
    245

    6    tmp1zkc4vnn                        0x000056020f6d40d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    if q.isEmpty {\n        return\
    \ true\n    }\n    \n    if q.isEmpty {\n        return true\n    }\n    \n  \
    \  if q.isEmpty {\n        return true\n    }\n    \n    if q.isEmpty {\n    \
    \    return true\n    }\n    \n    if q.isEmpty {\n        return true\n    }\n\
    \    \n    if q.isEmpty {\n        return true\n    }\n    \n    if q.isEmpty\
    \ {\n        return true\n    }\n    \n    if q.isEmpty {\n        return true\n\
    \    }\n    \n    if q.isEmpty {\n        return true\n    }\n    \n    if q.isEmpty\
    \ {\n        return true\n    }\n    \n    if q.isEmpty {\n        return true\n\
    \    }\n    \n    if q.isEmpty {\n        return true\n    }\n    \n    if q.isEmpty\
    \ {\n        return true\n    }\n    \n    if q.isEmpty {\n        return true\n\
    \    }\n    \n    if q.isEmpty {\n        return true\n    }\n    \n    if q.isEmpty\
    \ {\n        return true\n    }\n    \n    if q.isEmpty {\n        return true\n\
    \    }\n    \n    if q.isEmpty {\n        return true\n    }\n    \n    if q.isEmpty\
    \ {\n        return true\n    }\n    \n    if q.isEmpty {\n        return true\n\
    \    }\n    \n    if q.isEmpty {\n        return true\n    }\n    \n    if q.isEmpty\
    \ {\n        return true\n    }\n    \n    if q.isEmpty {\n        return true\n\
    \    }\n    \n    if q.isEmpty {\n        return true\n    }\n    \n    if q.isEmpty\
    \ {\n        return true\n    }\n    \n    if q.isEmpty {\n        return true\n\
    \    }\n    \n    if q.isEmpty {\n        return true\n    }\n    \n    if q.isEmpty\
    \ {\n        return true\n    }\n    \n    if q.isEmpty {\n        return true\n\
    \    }\n    \n    if q.isEmpty {\n        return true\n    }\n    \n    if q.isEmpty\
    \ {\n        return true\n    }\n    \n    if q.isEmpty {\n        return true\n\
    \    }\n    \n    if q.isEmpty {\n        return true\n    }\n    \n    if q.isEmpty\
    \ {\n        return true\n    }\n    \n    if q.isEmpty {\n        return true\n\
    \    }\n    \n    if q.isEmpty {\n        return true\n    }\n    \n    if q.isEmpty\
    \ {\n        return true\n    }\n    \n    if q.isEmpty {\n        return true\n\
    \    }\n    \n    if q.isEmpty {\n        return true\n    }\n    \n    if q.isEmpty\
    \ {\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w:\
    \ 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp6v9j3oc1.swift:191:42: error: expected '}' at end of brace statement\n\
    assert(will_it_fly(q: [5], w: 5) == true)\n                                  \
    \       ^\n/tmp/tmp6v9j3oc1.swift:13:44: note: to match this opening '{'\nfunc\
    \ will_it_fly(q: [Int], w: Int) -> Bool {\n                                  \
    \         ^\n/tmp/tmp6v9j3oc1.swift:174:6: error: operator functions can only\
    \ be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014316
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count == w else {\n\
    \        return false\n    }\n    \n    var maxSum = w\n    var maxSumIndex =\
    \ 0\n    \n    for i in 0..<q.count {\n        let sum = q[i] + maxSum\n     \
    \   if sum > maxSum {\n            maxSum = sum\n            maxSumIndex = i\n\
    \        }\n    }\n    \n    return maxSumIndex == q.count - 1\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp_fr1eh5v/tmp_fr1eh5v.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af9fb4e8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af9fb1dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af9fb1df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af9fb1de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_fr1eh5v                        0x000055b960ef453f <unavailable> + 5439

    5    libc.so.6                          0x00002af9fb6d4460 __libc_start_main +
    245

    6    tmp_fr1eh5v                        0x000055b960ef41a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014316
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxSum = w\n    for element\
    \ in q {\n        maxSum -= element\n        if maxSum < 0 {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpx307ezpn/tmpx307ezpn.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b74389bac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b74386b1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b74386b1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b74386b07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx307ezpn                        0x0000559246c9652b <unavailable> + 5419

    5    libc.so.6                          0x00002b7438ba6460 __libc_start_main +
    245

    6    tmpx307ezpn                        0x0000559246c960d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014316
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var max = 0\n    var sum = 0\n\
    \    for element in q {\n        sum += element\n        if sum > max {\n    \
    \        max = sum\n        }\n    }\n    return sum <= w\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpha3w05on/tmpha3w05on.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b64a3b70c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b64a3867b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b64a3867988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b64a38667b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpha3w05on                        0x0000555f966c552b <unavailable> + 5419

    5    libc.so.6                          0x00002b64a3d5c460 __libc_start_main +
    245

    6    tmpha3w05on                        0x0000555f966c50d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count == w else { return\
    \ false }\n    guard let first = q.first else { return false }\n    guard let\
    \ last = q.last else { return false }\n    guard let first = q.first else { return\
    \ false }\n    guard let last = q.last else { return false }\n    guard let first\
    \ = q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return \n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpm09masdy.swift:77:42: error: expected '}' at end of brace statement\n\
    assert(will_it_fly(q: [5], w: 5) == true)\n                                  \
    \       ^\n/tmp/tmpm09masdy.swift:13:44: note: to match this opening '{'\nfunc\
    \ will_it_fly(q: [Int], w: Int) -> Bool {\n                                  \
    \         ^\n/tmp/tmpm09masdy.swift:56:36: error: non-void function should return\
    \ a value\n    guard let last = q.last else { return \n                      \
    \             ^\n/tmp/tmpm09masdy.swift:60:6: error: operator functions can only\
    \ be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n/tmp/tmpm09masdy.swift:15:15: warning: value 'first'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let first = q.first else { return false }\n          ~~~~^~~~~~~~\n        \
    \                      != nil\n/tmp/tmpm09masdy.swift:16:15: warning: value 'last'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let last = q.last else { return false }\n          ~~~~^~~~~~~\n           \
    \                 != nil\n/tmp/tmpm09masdy.swift:17:15: warning: value 'first'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let first = q.first else { return false }\n          ~~~~^~~~~~~~\n        \
    \                      != nil\n/tmp/tmpm09masdy.swift:18:15: warning: value 'last'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let last = q.last else { return false }\n          ~~~~^~~~~~~\n           \
    \                 != nil\n/tmp/tmpm09masdy.swift:19:15: warning: value 'first'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let first = q.first else { return false }\n          ~~~~^~~~~~~~\n        \
    \                      != nil\n/tmp/tmpm09masdy.swift:20:15: warning: value 'last'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let last = q.last else { return false }\n          ~~~~^~~~~~~\n           \
    \                 != nil\n/tmp/tmpm09masdy.swift:21:15: warning: value 'f"
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 && w > 0 &&\
    \ w <= q.max() else {\n        return false\n    }\n    let sum: Int = q.sum()\n\
    \    return sum == w && q.palindrome()\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9_h_aw3b.swift:14:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else {\n                                         ^\n/tmp/tmp9_h_aw3b.swift:14:42:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else {\n             \
    \                            ^\n                                             \
    \  ?? <#default value#>\n/tmp/tmp9_h_aw3b.swift:14:42: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    guard q.count\
    \ > 0 && w > 0 && w <= q.max() else {\n                                      \
    \   ^\n                                              !\n/tmp/tmp9_h_aw3b.swift:17:22:\
    \ error: value of type '[Int]' has no member 'sum'\n    let sum: Int = q.sum()\n\
    \                   ~ ^~~\n/tmp/tmp9_h_aw3b.swift:18:26: error: value of type\
    \ '[Int]' has no member 'palindrome'\n    return sum == w && q.palindrome()\n\
    \                       ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014316
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    \n    // Write your code here.\n\
    \    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpsb8g9qn7/tmpsb8g9qn7.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aafecd9dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aafeca94b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aafeca94988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aafeca937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb8g9qn7                        0x000055bb6fd643bb <unavailable> + 5051

    5    libc.so.6                          0x00002aafecf89460 __libc_start_main +
    245

    6    tmpsb8g9qn7                        0x000055bb6fd63f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014316
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum\
    \ = q.reduce(0, +)\n    for element in q {\n        if element > maxWeight {\n\
    \            maxWeight = element\n            maxSum = element\n        }\n  \
    \  }\n    return maxWeight <= w && maxSum == maxWeight\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpbu8chqd7/tmpbu8chqd7.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7ac053ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7ac0231b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7ac0231988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7ac02307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbu8chqd7                        0x0000557b5ffde4df <unavailable> + 5343

    5    libc.so.6                          0x00002b7ac0726460 __libc_start_main +
    245

    6    tmpbu8chqd7                        0x0000557b5ffde149 <unavailable> + 4425

    '
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 && w > 0 &&\
    \ w <= q.max() else { return false }\n    var sum = 0\n    var max = 0\n    for\
    \ x in q {\n        sum += x\n        if sum > max { max = sum }\n    }\n    return\
    \ sum == max && q == q.sort().reverse()\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpvaurhhhd.swift:14:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else { return false }\n                                         ^\n\
    /tmp/tmpvaurhhhd.swift:14:42: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max()\
    \ else { return false }\n                                         ^\n        \
    \                                       ?? <#default value#>\n/tmp/tmpvaurhhhd.swift:14:42:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else { return false }\n\
    \                                         ^\n                                \
    \              !\n/tmp/tmpvaurhhhd.swift:21:33: error: cannot use mutating member\
    \ on immutable value: 'q' is a 'let' constant\n    return sum == max && q == q.sort().reverse()\n\
    \                              ~ ^\n/tmp/tmpvaurhhhd.swift:21:40: error: value\
    \ of tuple type '()' has no member 'reverse'\n    return sum == max && q == q.sort().reverse()\n\
    \                              ~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014316
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var max = 0\n    for x in q\
    \ {\n        if x > max {\n            max = x\n        }\n    }\n    if max >\
    \ w {\n        return false\n    }\n    var sum = 0\n    for x in q {\n      \
    \  sum += x\n    }\n    if sum < w {\n        return false\n    }\n    return\
    \ true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpgk4pplz2/tmpgk4pplz2.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba5c922cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba5c8f23b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba5c8f23988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5c8f227b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgk4pplz2                        0x000056103e5ad46f <unavailable> + 5231

    5    libc.so.6                          0x00002ba5c9418460 __libc_start_main +
    245

    6    tmpgk4pplz2                        0x000056103e5ad0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var max = 0\n    var sum = 0\n\
    \    for x in q {\n        sum += x\n        if sum > max {\n            max =\
    \ sum\n        }\n    }\n    if w == max {\n        return true\n    }\n    if\
    \ w < max {\n        return false\n    }\n    var i = 0\n    var j = 0\n    var\
    \ k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p\
    \ = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u =\
    \ 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n\
    \    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n \
    \   var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n  \
    \  var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n   \
    \ var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var\
    \ u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z\
    \ = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e =\
    \ 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n\
    \    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n \
    \   var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n  \
    \  var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n   \
    \ var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var\
    \ e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j\
    \ = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o =\
    \ 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n\
    \    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n \
    \   var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n  \
    \  var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n   \
    \ var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var\
    \ o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t\
    \ = 0\n    var u = 0\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmprlip67sh.swift:145:8: error: expected pattern\n    var \n     \
    \  ^\n/tmp/tmprlip67sh.swift:54:9: error: invalid redeclaration of 'i'\n    var\
    \ i = 0\n        ^\n/tmp/tmprlip67sh.swift:28:9: note: 'i' previously declared\
    \ here\n    var i = 0\n        ^\n/tmp/tmprlip67sh.swift:55:9: error: invalid\
    \ redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmprlip67sh.swift:29:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmprlip67sh.swift:56:9:\
    \ error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmprlip67sh.swift:30:9:\
    \ note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmprlip67sh.swift:57:9:\
    \ error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmprlip67sh.swift:31:9:\
    \ note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmprlip67sh.swift:58:9:\
    \ error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmprlip67sh.swift:32:9:\
    \ note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmprlip67sh.swift:59:9:\
    \ error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmprlip67sh.swift:33:9:\
    \ note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmprlip67sh.swift:60:9:\
    \ error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmprlip67sh.swift:34:9:\
    \ note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmprlip67sh.swift:61:9:\
    \ error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmprlip67sh.swift:35:9:\
    \ note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmprlip67sh.swift:62:9:\
    \ error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmprlip67sh.swift:36:9:\
    \ note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmprlip67sh.swift:63:9:\
    \ error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmprlip67sh.swift:37:9:\
    \ note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmprlip67sh.swift:64:9:\
    \ error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmprlip67sh.swift:38:9:\
    \ note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmprlip67sh.swift:65:9: "
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    if q.isEmpty {\n        return\
    \ true\n    }\n    \n    var maxWeight = w\n    var maxSum = q[0]\n    for element\
    \ in q {\n        if element > maxWeight {\n            maxWeight = element\n\
    \        }\n        maxSum += element\n    }\n    \n    if maxWeight <= w {\n\
    \        return true\n    }\n    \n    if maxSum < w {\n        return false\n\
    \    }\n    \n    return will_it_fly(q, maxWeight)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpyvkzl4n4.swift:35:23: error: missing argument labels 'q:w:' in\
    \ call\n    return will_it_fly(q, maxWeight)\n                      ^\n      \
    \                 q: w: \n"
  stdout: ''
  timestamp: 1660014316
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum\
    \ = q.reduce(0) { $0 + $1 }\n    for element in q {\n        if element > maxWeight\
    \ {\n            maxWeight = element\n        }\n        maxSum = maxSum + element\n\
    \    }\n    return maxWeight <= w && maxSum == w\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpyi5sw5ts/tmpyi5sw5ts.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b90b0f75c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b90b0c6cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b90b0c6c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b90b0c6b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyi5sw5ts                        0x000055e9c50614df <unavailable> + 5343

    5    libc.so.6                          0x00002b90b1161460 __libc_start_main +
    245

    6    tmpyi5sw5ts                        0x000055e9c5061149 <unavailable> + 4425

    '
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 && w > 0 &&\
    \ w <= q.max() else { return false }\n    var maxSum = q.max()\n    for element\
    \ in q {\n        maxSum -= element\n        if maxSum < 0 {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpjj6v2ans.swift:14:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else { return false }\n                                         ^\n\
    /tmp/tmpjj6v2ans.swift:14:42: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max()\
    \ else { return false }\n                                         ^\n        \
    \                                       ?? <#default value#>\n/tmp/tmpjj6v2ans.swift:14:42:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else { return false }\n\
    \                                         ^\n                                \
    \              !\n/tmp/tmpjj6v2ans.swift:17:9: error: value of optional type 'Int?'\
    \ must be unwrapped to a value of type 'Int'\n        maxSum -= element\n    \
    \    ^\n/tmp/tmpjj6v2ans.swift:17:9: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n        maxSum -= element\n        ^\n\
    \              !\n/tmp/tmpjj6v2ans.swift:18:12: error: value of optional type\
    \ 'Int?' must be unwrapped to a value of type 'Int'\n        if maxSum < 0 {\n\
    \           ^\n/tmp/tmpjj6v2ans.swift:18:12: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n        if maxSum < 0 {\n\
    \           ^\n                  ?? <#default value#>\n/tmp/tmpjj6v2ans.swift:18:12:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        if maxSum < 0 {\n           ^\n                 !\n"
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 && w > 0 &&\
    \ w <= q.max() else {\n        return false\n    }\n    \n    let rev = q.reversed()\n\
    \    let sum = q.map { $0 + $1 }.reduce(0, +)\n    return sum == w && rev == q\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmptrr80g2z.swift:14:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else {\n                                         ^\n/tmp/tmptrr80g2z.swift:14:42:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else {\n             \
    \                            ^\n                                             \
    \  ?? <#default value#>\n/tmp/tmptrr80g2z.swift:14:42: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    guard q.count\
    \ > 0 && w > 0 && w <= q.max() else {\n                                      \
    \   ^\n                                              !\n/tmp/tmptrr80g2z.swift:19:21:\
    \ error: contextual closure type '(Int) throws -> Int' expects 1 argument, but\
    \ 2 were used in closure body\n    let sum = q.map { $0 + $1 }.reduce(0, +)\n\
    \                    ^\n/tmp/tmptrr80g2z.swift:20:24: error: cannot convert value\
    \ of type 'ReversedCollection<[Int]>' to expected argument type '[Int]'\n    return\
    \ sum == w && rev == q\n                       ^\n"
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count == w else { return\
    \ false }\n    guard let first = q.first else { return false }\n    guard let\
    \ last = q.last else { return false }\n    guard let first = q.first else { return\
    \ false }\n    guard let last = q.last else { return false }\n    guard let first\
    \ = q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return \n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpm09masdy.swift:77:42: error: expected '}' at end of brace statement\n\
    assert(will_it_fly(q: [5], w: 5) == true)\n                                  \
    \       ^\n/tmp/tmpm09masdy.swift:13:44: note: to match this opening '{'\nfunc\
    \ will_it_fly(q: [Int], w: Int) -> Bool {\n                                  \
    \         ^\n/tmp/tmpm09masdy.swift:56:36: error: non-void function should return\
    \ a value\n    guard let last = q.last else { return \n                      \
    \             ^\n/tmp/tmpm09masdy.swift:60:6: error: operator functions can only\
    \ be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n/tmp/tmpm09masdy.swift:15:15: warning: value 'first'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let first = q.first else { return false }\n          ~~~~^~~~~~~~\n        \
    \                      != nil\n/tmp/tmpm09masdy.swift:16:15: warning: value 'last'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let last = q.last else { return false }\n          ~~~~^~~~~~~\n           \
    \                 != nil\n/tmp/tmpm09masdy.swift:17:15: warning: value 'first'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let first = q.first else { return false }\n          ~~~~^~~~~~~~\n        \
    \                      != nil\n/tmp/tmpm09masdy.swift:18:15: warning: value 'last'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let last = q.last else { return false }\n          ~~~~^~~~~~~\n           \
    \                 != nil\n/tmp/tmpm09masdy.swift:19:15: warning: value 'first'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let first = q.first else { return false }\n          ~~~~^~~~~~~~\n        \
    \                      != nil\n/tmp/tmpm09masdy.swift:20:15: warning: value 'last'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let last = q.last else { return false }\n          ~~~~^~~~~~~\n           \
    \                 != nil\n/tmp/tmpm09masdy.swift:21:15: warning: value 'f"
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 && w > 0 &&\
    \ w <= q.max() else { return false }\n    guard let first = q.first else { return\
    \ false }\n    guard let last = q.last else { return false }\n    guard let middle\
    \ = q.index(of: first) else { return false }\n    guard let middle2 = q.index(of:\
    \ last) else { return false }\n    guard middle != middle2 else { return false\
    \ }\n    guard let middle3 = q.index(of: middle) else { return false }\n    guard\
    \ middle3 != middle else { return false }\n    guard let middle4 = q.index(of:\
    \ middle2) else { return false }\n    guard middle4 != middle else { return false\
    \ }\n    guard middle4 != middle3 else { return false }\n    guard let middle5\
    \ = q.index(of: middle4) else { return false }\n    guard middle5 != middle else\
    \ { return false }\n    guard middle5 != middle2 else { return false }\n    guard\
    \ middle5 != middle3 else { return false }\n    guard middle5 != middle4 else\
    \ { return false }\n    guard middle5 != middle2 else { return false }\n    guard\
    \ middle5 != middle else { return false }\n    guard middle5 != middle3 else {\
    \ return false }\n    guard middle5 != middle4 else { return false }\n    guard\
    \ middle5 != middle2 else { return false }\n    guard middle5 != middle else {\
    \ return false }\n    guard middle5 != middle3 else { return false }\n    guard\
    \ middle5 != middle4 else { return false }\n    guard middle5 != middle2 else\
    \ { return false }\n    guard middle5 != middle else { return false }\n    guard\
    \ middle5 != middle3 else { return false }\n    guard middle5 != middle4 else\
    \ { return false }\n    guard middle5 != middle2 else { return false }\n    guard\
    \ middle5 != middle else { return false }\n    guard middle5 != middle3 else {\
    \ return false }\n    guard middle5 != middle4 else { return false }\n    guard\
    \ middle5 != middle2 else { return false }\n    guard middle5 != middle else {\
    \ return false }\n    guard middle5 != middle3 else { return false }\n    guard\
    \ middle5 != middle4 else { return false }\n    guard middle5 != middle2 else\
    \ { return false }\n    guard middle5 != middle else { return false }\n    guard\
    \ middle5 != middle3 else { return false }\n    \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmps55x7axb.swift:14:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else { return false }\n                                         ^\n\
    /tmp/tmps55x7axb.swift:14:42: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max()\
    \ else { return false }\n                                         ^\n        \
    \                                       ?? <#default value#>\n/tmp/tmps55x7axb.swift:14:42:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else { return false }\n\
    \                                         ^\n                                \
    \              !\n/tmp/tmps55x7axb.swift:17:26: warning: 'index(of:)' is deprecated:\
    \ renamed to 'firstIndex(of:)'\n    guard let middle = q.index(of: first) else\
    \ { return false }\n                         ^\n/tmp/tmps55x7axb.swift:17:26:\
    \ note: use 'firstIndex(of:)' instead\n    guard let middle = q.index(of: first)\
    \ else { return false }\n                         ^~~~~\n                    \
    \     firstIndex\n/tmp/tmps55x7axb.swift:18:27: warning: 'index(of:)' is deprecated:\
    \ renamed to 'firstIndex(of:)'\n    guard let middle2 = q.index(of: last) else\
    \ { return false }\n                          ^\n/tmp/tmps55x7axb.swift:18:27:\
    \ note: use 'firstIndex(of:)' instead\n    guard let middle2 = q.index(of: last)\
    \ else { return false }\n                          ^~~~~\n                   \
    \       firstIndex\n/tmp/tmps55x7axb.swift:20:27: warning: 'index(of:)' is deprecated:\
    \ renamed to 'firstIndex(of:)'\n    guard let middle3 = q.index(of: middle) else\
    \ { return false }\n                          ^\n/tmp/tmps55x7axb.swift:20:27:\
    \ note: use 'firstIndex(of:)' instead\n    guard let middle3 = q.index(of: middle)\
    \ else { return false }\n                          ^~~~~\n                   \
    \       firstIndex\n/tmp/tmps55x7axb.swift:22:27: warning: 'index(of:)' is deprecated:\
    \ renamed to 'firstIndex(of:"
  stdout: ''
  timestamp: 1660014316
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count == w, q.count\
    \ > 0 else {\n        return false\n    }\n    var maxSum = w\n    var maxSumIndex\
    \ = 0\n    for index in 0..<q.count {\n        let currentSum = q[index] + maxSum\n\
    \        if currentSum > maxSum {\n            maxSum = currentSum\n         \
    \   maxSumIndex = index\n        }\n    }\n    return maxSum == w\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpd67gm9or/tmpd67gm9or.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba299c4fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba299946b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba299946988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba2999457b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd67gm9or                        0x000055f35821953f <unavailable> + 5439

    5    libc.so.6                          0x00002ba299e3b460 __libc_start_main +
    245

    6    tmpd67gm9or                        0x000055f3582191a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014316
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum\
    \ = 0\n    for element in q {\n        maxWeight -= element\n        maxSum +=\
    \ element\n    }\n    return maxWeight <= 0 && maxSum == w\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpc2_fba1e/tmpc2_fba1e.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b258571ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2585411b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2585411988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b25854107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc2_fba1e                        0x000055fdd508146f <unavailable> + 5231

    5    libc.so.6                          0x00002b2585906460 __libc_start_main +
    245

    6    tmpc2_fba1e                        0x000055fdd50810d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014316
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count == w else {\n\
    \        return false\n    }\n    var maxSum = w\n    var maxSumIndex = 0\n  \
    \  var maxSumElement = q[0]\n    for index in 1..<q.count {\n        let element\
    \ = q[index]\n        let sum = element + maxSumElement\n        if sum > maxSum\
    \ {\n            maxSum = sum\n            maxSumIndex = index\n            maxSumElement\
    \ = element\n        }\n    }\n    return maxSum == w\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmps15ynah7/tmps15ynah7.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1c43d04c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1c439fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1c439fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1c439fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps15ynah7                        0x0000559a66a4d53f <unavailable> + 5439

    5    libc.so.6                          0x00002b1c43ef0460 __libc_start_main +
    245

    6    tmps15ynah7                        0x0000559a66a4d1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014316
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxSum = w\n    for element\
    \ in q {\n        maxSum = maxSum - element\n    }\n    if maxSum < 0 {\n    \
    \    return false\n    }\n    var sum = 0\n    for element in q {\n        sum\
    \ = sum + element\n    }\n    if sum < w {\n        return false\n    }\n    return\
    \ true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp7h_er_ra/tmp7h_er_ra.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7505c89c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7505980b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7505980988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b750597f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7h_er_ra                        0x0000556211e8346f <unavailable> + 5231

    5    libc.so.6                          0x00002b7505e75460 __libc_start_main +
    245

    6    tmp7h_er_ra                        0x0000556211e830d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxSum = w\n    var maxSumIndex\
    \ = 0\n    var maxSumElement = q[0]\n    for i := 1; i < len(q); i++ {\n     \
    \   if q[i] > maxSumElement {\n            maxSum = maxSumElement\n          \
    \  maxSumIndex = i\n            maxSumElement = q[i]\n        } else if q[i] ==\
    \ maxSumElement {\n            maxSum += q[i]\n        }\n    }\n    return maxSum\
    \ < w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp5o3dvh0h.swift:17:12: error: expected type\n    for i := 1; i <\
    \ len(q); i++ {\n           ^\n            <#type#>\n/tmp/tmp5o3dvh0h.swift:17:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 1; i < len(q); i++\
    \ {\n           ^\n/tmp/tmp5o3dvh0h.swift:17:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 1; i < len(q); i++ {\n           ^\n"
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxSum = w\n    var maxSumIndex\
    \ = 0\n    var maxSumElement = q[0]\n    for i := 1; i < len(q); i++ {\n     \
    \   maxSum = maxSum - q[i]\n        if maxSum < 0 {\n            return false\n\
    \        }\n        if maxSum > w {\n            return false\n        }\n   \
    \     if maxSum == w {\n            maxSumElement = q[i]\n            maxSumIndex\
    \ = i\n        }\n    }\n    if maxSum == w {\n        return maxSumElement ==\
    \ q[maxSumIndex]\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmplrjpj1ee.swift:17:12: error: expected type\n    for i := 1; i <\
    \ len(q); i++ {\n           ^\n            <#type#>\n/tmp/tmplrjpj1ee.swift:17:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 1; i < len(q); i++\
    \ {\n           ^\n/tmp/tmplrjpj1ee.swift:17:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 1; i < len(q); i++ {\n           ^\n"
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count == w.count &&\
    \ q.count == w.reversed().count else { return false }\n    let maxWeight = w.reversed()\n\
    \    return q == maxWeight && q.count == maxWeight.count && q.count == maxWeight.reversed().count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp7s0fuj_a.swift:14:24: error: value of type 'Int' has no member\
    \ 'count'\n    guard q.count == w.count && q.count == w.reversed().count else\
    \ { return false }\n                     ~ ^~~~~\n/tmp/tmp7s0fuj_a.swift:14:46:\
    \ error: value of type 'Int' has no member 'reversed'\n    guard q.count == w.count\
    \ && q.count == w.reversed().count else { return false }\n                   \
    \                        ~ ^~~~~~~~\n/tmp/tmp7s0fuj_a.swift:15:23: error: value\
    \ of type 'Int' has no member 'reversed'\n    let maxWeight = w.reversed()\n \
    \                   ~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 else {\n \
    \       return true\n    }\n    guard w > 0 else {\n        return false\n   \
    \ }\n    guard let first = q.first else {\n        return false\n    }\n    guard\
    \ let last = q.last else {\n        return false\n    }\n    guard first == last\
    \ else {\n        return false\n    }\n    guard let first = q.first else {\n\
    \        return false\n    }\n    guard let last = q.last else {\n        return\
    \ false\n    }\n    guard first == last else {\n        return false\n    }\n\
    \    guard let first = q.first else {\n        return false\n    }\n    guard\
    \ let last = q.last else {\n        return false\n    }\n    guard first == last\
    \ else {\n        return false\n    }\n    guard let first = q.first else {\n\
    \        return false\n    }\n    guard let last = q.last else {\n        return\
    \ false\n    }\n    guard first == last else {\n        return false\n    }\n\
    \    guard let first = q.first else {\n        return false\n    }\n    guard\
    \ let last = q.last else {\n        return false\n    }\n    guard first == last\
    \ else {\n        return false\n    }\n    guard let first = q.first else {\n\
    \        return false\n    }\n    guard let last = q.last else {\n        return\
    \ false\n    }\n    guard first == last else {\n        return false\n    }\n\
    \    guard let first = q.first else {\n        return false\n    }\n    guard\
    \ let last = q.last else {\n        return false\n    }\n    guard first == last\
    \ else {\n        return false\n    }\n    guard let first = q.first else {\n\
    \        return false\n    }\n    guard let last = q.last else {\n        return\
    \ false\n    }\n    guard first == last else {\n        return false\n    }\n\
    \    guard let first = q.first else {\n        return false\n    }\n    guard\
    \ let last = q.last else {\n        return false\n    }\n    guard first == last\
    \ else {\n        return false\n    }\n    guard let first = q.first else {\n\
    \        return false\n    }\n    guard let last = q.last else {\n        return\
    \ false\n    }\n    guard first == last else {\n        return false\n    }\n\
    \    guard let first = q.first else {\n        return false\n    }\n    guard\
    \ let last = q.last else {\n        return false\n    }\n    guard first == last\
    \ else {\n        return false\n    }\n    guard let first = q.first else {\n\
    \        return false\n    }\n    guard let last = q.last else {\n        return\
    \ false\n    }\n    guard first == last \n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpy5jbf58v.swift:125:24: error: expected 'else' after 'guard' condition\n\
    \    guard first == last \n                       ^\n"
  stdout: ''
  timestamp: 1660014316
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxSum = w\n    for element\
    \ in q {\n        maxSum -= element\n        if maxSum < 0 {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpx307ezpn/tmpx307ezpn.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b74389bac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b74386b1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b74386b1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b74386b07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx307ezpn                        0x0000559246c9652b <unavailable> + 5419

    5    libc.so.6                          0x00002b7438ba6460 __libc_start_main +
    245

    6    tmpx307ezpn                        0x0000559246c960d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count == w else {\n\
    \        return false\n    }\n    \n    var max = 0\n    var maxIndex = 0\n  \
    \  \n    for i in 0..<q.count {\n        if q[i] > max {\n            max = q[i]\n\
    \            maxIndex = i\n        }\n    }\n    \n    if maxIndex == 0 {\n  \
    \      return true\n    }\n    \n    if maxIndex == q.count - 1 {\n        return\
    \ true\n    }\n    \n    if max > w {\n        return false\n    }\n    \n   \
    \ return will_it_fly(q[maxIndex..<q.count], w)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpm2svlc44.swift:40:23: error: missing argument labels 'q:w:' in\
    \ call\n    return will_it_fly(q[maxIndex..<q.count], w)\n                   \
    \   ^\n                       q:                     w: \n/tmp/tmpm2svlc44.swift:40:25:\
    \ error: cannot convert value of type 'ArraySlice<Int>' to expected argument type\
    \ '[Int]'\n    return will_it_fly(q[maxIndex..<q.count], w)\n                \
    \        ^\n"
  stdout: ''
  timestamp: 1660014316
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    \n    // Write your code here.\n\
    \    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpsb8g9qn7/tmpsb8g9qn7.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aafecd9dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aafeca94b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aafeca94988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aafeca937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb8g9qn7                        0x000055bb6fd643bb <unavailable> + 5051

    5    libc.so.6                          0x00002aafecf89460 __libc_start_main +
    245

    6    tmpsb8g9qn7                        0x000055bb6fd63f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 && w > 0 &&\
    \ w <= q.max() else { return false }\n    guard let first = q.first else { return\
    \ false }\n    guard let last = q.last else { return false }\n    guard let mid\
    \ = q.mid(at: 0) else { return false }\n    guard let mid2 = q.mid(at: 1) else\
    \ { return false }\n    guard let mid3 = q.mid(at: 2) else { return false }\n\
    \    guard let mid4 = q.mid(at: 3) else { return false }\n    guard let mid5 =\
    \ q.mid(at: 4) else { return false }\n    guard let mid6 = q.mid(at: 5) else {\
    \ return false }\n    guard let mid7 = q.mid(at: 6) else { return false }\n  \
    \  guard let mid8 = q.mid(at: 7) else { return false }\n    guard let mid9 = q.mid(at:\
    \ 8) else { return false }\n    guard let mid10 = q.mid(at: 9) else { return false\
    \ }\n    guard let mid11 = q.mid(at: 10) else { return false }\n    guard let\
    \ mid12 = q.mid(at: 11) else { return false }\n    guard let mid13 = q.mid(at:\
    \ 12) else { return false }\n    guard let mid14 = q.mid(at: 13) else { return\
    \ false }\n    guard let mid15 = q.mid(at: 14) else { return false }\n    guard\
    \ let mid16 = q.mid(at: 15) else { return false }\n    guard let mid17 = q.mid(at:\
    \ 16) else { return false }\n    guard let mid18 = q.mid(at: 17) else { return\
    \ false }\n    guard let mid19 = q.mid(at: 18) else { return false }\n    guard\
    \ let mid20 = q.mid(at: 19) else { return false }\n    guard let mid21 = q.mid(at:\
    \ 20) else { return false }\n    guard let mid22 = q.mid(at: 21) else { return\
    \ false }\n    guard let mid23 = q.mid(at: 22) else { return false }\n    guard\
    \ let mid24 = q.mid(at: 23) else { return false }\n    guard let mid25 = q.mid(at:\
    \ 24) else { return false }\n    guard let mid26 = q.mid(at: 25) else { return\
    \ false }\n    guard let mid27 = q.mid(at\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp8fjouusr.swift:44:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmp8fjouusr.swift:43:28: note: to match this opening '('\n    guard let\
    \ mid27 = q.mid(at\n                           ^\n/tmp/tmp8fjouusr.swift:43:31:\
    \ error: expected 'else' after 'guard' condition\n    guard let mid27 = q.mid(at\n\
    \                              ^\n/tmp/tmp8fjouusr.swift:14:42: error: value of\
    \ optional type 'Int?' must be unwrapped to a value of type 'Int'\n    guard q.count\
    \ > 0 && w > 0 && w <= q.max() else { return false }\n                       \
    \                  ^\n/tmp/tmp8fjouusr.swift:14:42: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n    guard q.count\
    \ > 0 && w > 0 && w <= q.max() else { return false }\n                       \
    \                  ^\n                                               ?? <#default\
    \ value#>\n/tmp/tmp8fjouusr.swift:14:42: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n    guard q.count > 0 && w >\
    \ 0 && w <= q.max() else { return false }\n                                  \
    \       ^\n                                              !\n/tmp/tmp8fjouusr.swift:17:23:\
    \ error: value of type '[Int]' has no member 'mid'\n    guard let mid = q.mid(at:\
    \ 0) else { return false }\n                    ~ ^~~\n/tmp/tmp8fjouusr.swift:18:24:\
    \ error: value of type '[Int]' has no member 'mid'\n    guard let mid2 = q.mid(at:\
    \ 1) else { return false }\n                     ~ ^~~\n/tmp/tmp8fjouusr.swift:19:24:\
    \ error: value of type '[Int]' has no member 'mid'\n    guard let mid3 = q.mid(at:\
    \ 2) else { return false }\n                     ~ ^~~\n/tmp/tmp8fjouusr.swift:20:24:\
    \ error: value of type '[Int]' has no member 'mid'\n    guard let mid4 = q.mid(at:\
    \ 3) else { return false }\n                     ~ ^~~\n/tmp/tmp8fjouusr.swift:21:24:\
    \ error: value of type '[Int]' has no member 'mid'\n    guard let mid5 = q.mid(at:\
    \ 4) else { return false }\n                     ~ ^~~\n/tmp/tmp8fjouusr.swift:22:24:\
    \ error: value of type '[Int]' has no member 'mid'\n    guard let mid6 = q.mid(at:\
    \ 5) "
  stdout: ''
  timestamp: 1660014316
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count == w else { return\
    \ false }\n    var max = 0\n    var sum = 0\n    for x in q {\n        sum +=\
    \ x\n        if sum > max {\n            max = sum\n        }\n    }\n    if sum\
    \ == max {\n        return true\n    }\n    return false\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmptvp1b6o1/tmptvp1b6o1.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b91dc8cac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b91dc5c1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b91dc5c1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b91dc5c07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptvp1b6o1                        0x000055e5a84a64bf <unavailable> + 5311

    5    libc.so.6                          0x00002b91dcab6460 __libc_start_main +
    245

    6    tmptvp1b6o1                        0x000055e5a84a6129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014316
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxSum = w\n    for element\
    \ in q {\n        maxSum -= element\n        if maxSum < 0 {\n            return\
    \ false\n        }\n    }\n    return maxSum == 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpu4rizsuj/tmpu4rizsuj.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae85c14bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae85be42b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae85be42988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae85be417b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu4rizsuj                        0x0000562088e4d46f <unavailable> + 5231

    5    libc.so.6                          0x00002ae85c337460 __libc_start_main +
    245

    6    tmpu4rizsuj                        0x0000562088e4d0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 && w > 0 &&\
    \ w <= q.max() else {\n        return false\n    }\n    \n    var sum = 0\n  \
    \  for x in q {\n        sum += x\n    }\n    return sum <= w\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmphh9n4q98.swift:14:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else {\n                                         ^\n/tmp/tmphh9n4q98.swift:14:42:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else {\n             \
    \                            ^\n                                             \
    \  ?? <#default value#>\n/tmp/tmphh9n4q98.swift:14:42: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    guard q.count\
    \ > 0 && w > 0 && w <= q.max() else {\n                                      \
    \   ^\n                                              !\n"
  stdout: ''
  timestamp: 1660014316
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum\
    \ = q.reduce(0, +)\n    for i in  q.indices {\n        if maxWeight < q[i] {\n\
    \            maxWeight = q[i]\n        }\n        if maxSum < maxWeight {\n  \
    \          maxSum = maxWeight\n        }\n    }\n    return maxSum == maxWeight\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpco82xr61/tmpco82xr61.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac88e9f0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac88e6e7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac88e6e7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac88e6e67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpco82xr61                        0x000055a517dc360b <unavailable> + 5643

    5    libc.so.6                          0x00002ac88ebdc460 __libc_start_main +
    245

    6    tmpco82xr61                        0x000055a517dc31b9 <unavailable> + 4537

    '
  stdout: ''
  timestamp: 1660014316
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    \n    // Write your code here.\n\
    \    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpsb8g9qn7/tmpsb8g9qn7.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aafecd9dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aafeca94b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aafeca94988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aafeca937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb8g9qn7                        0x000055bb6fd643bb <unavailable> + 5051

    5    libc.so.6                          0x00002aafecf89460 __libc_start_main +
    245

    6    tmpsb8g9qn7                        0x000055bb6fd63f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    \n    let maxWeight = w\n  \
    \  \n    if q.count == 0 {\n        return true\n    }\n    \n    if q.count ==\
    \ 1 {\n        return false\n    }\n    \n    let firstElement = q[0]\n    \n\
    \    if maxWeight == w {\n        return true\n    }\n    \n    if maxWeight <\
    \ w {\n        return false\n    }\n    \n    let lastElement = q[q.count - 1]\n\
    \    \n    if firstElement == lastElement {\n        return false\n    }\n   \
    \ \n    let maxSum = maxWeight - firstElement + lastElement\n    \n    if maxSum\
    \ < 0 {\n        return false\n    }\n    \n    return will_it_fly(q[1..<q.count],\
    \ maxSum)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2,\
    \ 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpf3jp_r9x.swift:47:23: error: missing argument labels 'q:w:' in\
    \ call\n    return will_it_fly(q[1..<q.count], maxSum)\n                     \
    \ ^\n                       q:              w: \n/tmp/tmpf3jp_r9x.swift:47:25:\
    \ error: cannot convert value of type 'ArraySlice<Int>' to expected argument type\
    \ '[Int]'\n    return will_it_fly(q[1..<q.count], maxSum)\n                  \
    \      ^\n"
  stdout: ''
  timestamp: 1660014316
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum\
    \ = q.reduce(0) { $0 + $1 }\n    for element in q {\n        if element > maxWeight\
    \ {\n            maxWeight = element\n        }\n        maxSum = maxSum + element\n\
    \    }\n    return maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmptgkzccx4/tmptgkzccx4.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b426935bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4269052b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4269052988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b42690517b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptgkzccx4                        0x000055c8a9bc94df <unavailable> + 5343

    5    libc.so.6                          0x00002b4269547460 __libc_start_main +
    245

    6    tmptgkzccx4                        0x000055c8a9bc9149 <unavailable> + 4425

    '
  stdout: ''
  timestamp: 1660014317
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    let maxWeight = w\n    \n  \
    \  // The palindromic list is a palindrome if the sum of its elements is less\
    \ than or equal the maximum possible weight.\n    // The palindromic list is a\
    \ palindrome if the sum of its elements is less than or equal the maximum possible\
    \ weight.\n    // The palindromic list is a palindrome if the sum of its elements\
    \ is less than or equal the maximum possible weight.\n    // The palindromic list\
    \ is a palindrome if the sum of its elements is less than or equal the maximum\
    \ possible weight.\n    // The palindromic list is a palindrome if the sum of\
    \ its elements is less than or equal the maximum possible weight.\n    // The\
    \ palindromic list is a palindrome if the sum of its elements is less than or\
    \ equal the maximum possible weight.\n    // The palindromic list is a palindrome\
    \ if the sum of its elements is less than or equal the maximum possible weight.\n\
    \    // The palindromic list is a palindrome if the sum of its elements is less\
    \ than or equal the maximum possible weight.\n    // The palindromic list is a\
    \ palindrome if the sum of its elements is less than or equal the maximum possible\
    \ weight.\n    // The palindromic list is a palindrome if the sum of its elements\
    \ is less than or equal the maximum possible weight.\n    // The palindromic list\
    \ is a palindrome if the sum of its elements is less than or equal the maximum\
    \ possible weight.\n    // The palindromic list is a palindrome if the sum of\
    \ its elements is less than or equal the maximum possible weight.\n    // The\
    \ palindromic list is a palindrome if the sum of its elements is less than or\
    \ equal the maximum possible weight.\n    // The palindromic list is a palindrome\
    \ if the sum of its elements is less than or equal the maximum possible weight.\n\
    \    // The palindromic list is a palindrome if the sum of its elements is less\
    \ than or equal the maximum possible weight.\n    // The palindromic list is a\
    \ palindrome if the sum of its elements is less than or equal the maximum possible\
    \ weight.\n    // The palindromic list is a palindrome if the sum of its elements\
    \ is less than or equal the maximum possible weight.\n    // The palindromic list\
    \ is a palindrome if the sum of its elements is less than or equal the maximum\
    \ possible weight.\n    // The palindromic list is a palindrome if the sum of\
    \ its elements is less than or equal the maximum possible weight.\n    // The\
    \ palindromic list is a p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp_mnqb4jp.swift:14:9: warning: initialization of immutable value\
    \ 'maxWeight' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let maxWeight = w\n    ~~~~^~~~~~~~~\n    _\n/tmp/tmp_mnqb4jp.swift:36:1:\
    \ error: missing return in global function expected to return 'Bool'\n}\n^\n"
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 && w > 0 &&\
    \ w <= q.max() else {\n        return false\n    }\n    \n    let maxSum = q.max()\n\
    \    \n    return q.reversed().reduce(true) { $0 && $1 && ($0 + q[$0] + w) <=\
    \ maxSum }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2,\
    \ 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpktrfi5dw.swift:14:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else {\n                                         ^\n/tmp/tmpktrfi5dw.swift:14:42:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else {\n             \
    \                            ^\n                                             \
    \  ?? <#default value#>\n/tmp/tmpktrfi5dw.swift:14:42: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    guard q.count\
    \ > 0 && w > 0 && w <= q.max() else {\n                                      \
    \   ^\n                                              !\n/tmp/tmpktrfi5dw.swift:20:12:\
    \ error: the compiler is unable to type-check this expression in reasonable time;\
    \ try breaking up the expression into distinct sub-expressions\n    return q.reversed().reduce(true)\
    \ { $0 && $1 && ($0 + q[$0] + w) <= maxSum }\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014505
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count == w else { return\
    \ false }\n    guard let first = q.first else { return false }\n    guard let\
    \ last = q.last else { return false }\n    guard let first = q.first else { return\
    \ false }\n    guard let last = q.last else { return false }\n    guard let first\
    \ = q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return \n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpm09masdy.swift:77:42: error: expected '}' at end of brace statement\n\
    assert(will_it_fly(q: [5], w: 5) == true)\n                                  \
    \       ^\n/tmp/tmpm09masdy.swift:13:44: note: to match this opening '{'\nfunc\
    \ will_it_fly(q: [Int], w: Int) -> Bool {\n                                  \
    \         ^\n/tmp/tmpm09masdy.swift:56:36: error: non-void function should return\
    \ a value\n    guard let last = q.last else { return \n                      \
    \             ^\n/tmp/tmpm09masdy.swift:60:6: error: operator functions can only\
    \ be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n/tmp/tmpm09masdy.swift:15:15: warning: value 'first'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let first = q.first else { return false }\n          ~~~~^~~~~~~~\n        \
    \                      != nil\n/tmp/tmpm09masdy.swift:16:15: warning: value 'last'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let last = q.last else { return false }\n          ~~~~^~~~~~~\n           \
    \                 != nil\n/tmp/tmpm09masdy.swift:17:15: warning: value 'first'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let first = q.first else { return false }\n          ~~~~^~~~~~~~\n        \
    \                      != nil\n/tmp/tmpm09masdy.swift:18:15: warning: value 'last'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let last = q.last else { return false }\n          ~~~~^~~~~~~\n           \
    \                 != nil\n/tmp/tmpm09masdy.swift:19:15: warning: value 'first'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let first = q.first else { return false }\n          ~~~~^~~~~~~~\n        \
    \                      != nil\n/tmp/tmpm09masdy.swift:20:15: warning: value 'last'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let last = q.last else { return false }\n          ~~~~^~~~~~~\n           \
    \                 != nil\n/tmp/tmpm09masdy.swift:21:15: warning: value 'f"
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 && w > 0 &&\
    \ w <= q.max() else { return false }\n    guard let first = q.first else { return\
    \ false }\n    guard let last = q.last else { return false }\n    guard let first\
    \ = q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp1qx0eaj5.swift:14:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else { return false }\n                                         ^\n\
    /tmp/tmp1qx0eaj5.swift:14:42: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max()\
    \ else { return false }\n                                         ^\n        \
    \                                       ?? <#default value#>\n/tmp/tmp1qx0eaj5.swift:14:42:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else { return false }\n\
    \                                         ^\n                                \
    \              !\n"
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 && w > 0 &&\
    \ w <= q.max() else {\n        return false\n    }\n    \n    var sum = 0\n  \
    \  for element in q {\n        sum += element\n    }\n    \n    return sum <=\
    \ w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w:\
    \ 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpbnb28947.swift:14:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else {\n                                         ^\n/tmp/tmpbnb28947.swift:14:42:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else {\n             \
    \                            ^\n                                             \
    \  ?? <#default value#>\n/tmp/tmpbnb28947.swift:14:42: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    guard q.count\
    \ > 0 && w > 0 && w <= q.max() else {\n                                      \
    \   ^\n                                              !\n"
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 && w > 0 &&\
    \ w <= q.max() else { return false }\n    guard let first = q.first else { return\
    \ false }\n    guard let last = q.last else { return false }\n    guard let middle\
    \ = q.index(of: first)?.advanced(by: 1) else { return false }\n    guard let middle2\
    \ = q.index(of: last)?.advanced(by: -1) else { return false }\n    guard let middle3\
    \ = q.index(of: middle)?.advanced(by: 1) else { return false }\n    guard let\
    \ middle4 = q.index(of: middle2)?.advanced(by: -1) else { return false }\n   \
    \ guard let middle5 = q.index(of: middle3)?.advanced(by: 1) else { return false\
    \ }\n    guard let middle6 = q.index(of: middle4)?.advanced(by: -1) else { return\
    \ false }\n    guard let middle7 = q.index(of: middle5)?.advanced(by: 1) else\
    \ { return false }\n    guard let middle8 = q.index(of: middle6)?.advanced(by:\
    \ -1) else { return false }\n    guard let middle9 = q.index(of: middle7)?.advanced(by:\
    \ 1) else { return false }\n    guard let middle10 = q.index(of: middle8)?.advanced(by:\
    \ -1) else { return false }\n    guard let middle11 = q.index(of: middle9)?.advanced(by:\
    \ 1) else { return false }\n    guard let middle12 = q.index(of: middle10)?.advanced(by:\
    \ -1) else { return false }\n    guard let middle13 = q.index(of: middle11)?.advanced(by:\
    \ 1) else { return false }\n    guard let middle14 = q.index(of: middle12)?.advanced(by:\
    \ -1) else { return false }\n    guard let middle15 = q.index(of: middle13)?.advanced(by:\
    \ 1) else { return false }\n    guard let middle16 = q.index(of: middle14)?.advanced(by:\
    \ -1) else { return false }\n    guard let middle17 = q.index(of: middle15)?.advanced(by:\
    \ 1) else { return false }\n    guard let middle18 = q.index(of: middle16)?.advanced(by:\
    \ -1) else { return false }\n    guard let middle19 = q.index(of: middle17)?.advanced(by:\
    \ 1) else { return false }\n    guard let middle20 = q.index(of: middle18)?.advanced(by:\
    \ -1) else { return false }\n    guard let \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpdy9gbein.swift:37:14: error: expected pattern\n    guard let \n\
    \             ^\n/tmp/tmpdy9gbein.swift:37:11: error: unwrap condition requires\
    \ a valid identifier\n    guard let \n          ^\n          <#identifier#> =\
    \ \n/tmp/tmpdy9gbein.swift:37:14: error: expected 'else' after 'guard' condition\n\
    \    guard let \n             ^\n/tmp/tmpdy9gbein.swift:14:42: error: value of\
    \ optional type 'Int?' must be unwrapped to a value of type 'Int'\n    guard q.count\
    \ > 0 && w > 0 && w <= q.max() else { return false }\n                       \
    \                  ^\n/tmp/tmpdy9gbein.swift:14:42: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n    guard q.count\
    \ > 0 && w > 0 && w <= q.max() else { return false }\n                       \
    \                  ^\n                                               ?? <#default\
    \ value#>\n/tmp/tmpdy9gbein.swift:14:42: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n    guard q.count > 0 && w >\
    \ 0 && w <= q.max() else { return false }\n                                  \
    \       ^\n                                              !\n/tmp/tmpdy9gbein.swift:17:26:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n    guard\
    \ let middle = q.index(of: first)?.advanced(by: 1) else { return false }\n   \
    \                      ^\n/tmp/tmpdy9gbein.swift:17:26: note: use 'firstIndex(of:)'\
    \ instead\n    guard let middle = q.index(of: first)?.advanced(by: 1) else { return\
    \ false }\n                         ^~~~~\n                         firstIndex\n\
    /tmp/tmpdy9gbein.swift:18:27: warning: 'index(of:)' is deprecated: renamed to\
    \ 'firstIndex(of:)'\n    guard let middle2 = q.index(of: last)?.advanced(by: -1)\
    \ else { return false }\n                          ^\n/tmp/tmpdy9gbein.swift:18:27:\
    \ note: use 'firstIndex(of:)' instead\n    guard let middle2 = q.index(of: last)?.advanced(by:\
    \ -1) else { return false }\n                          ^~~~~\n               \
    \           firstIndex\n/tmp/tmpdy9gbein.swift:19:27: warning: 'index(of:)' is\
    \ deprecated: renamed to 'firstIn"
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.isEmpty == false else\
    \ {\n        return false\n    }\n    guard q.count == 1 else {\n        return\
    \ false\n    }\n    guard w > 0 else {\n        return false\n    }\n    guard\
    \ w <= q.last else {\n        return false\n    }\n    guard q.reduce(0, +) ==\
    \ w else {\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpfz5wccub.swift:23:18: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard w <= q.last else {\n      \
    \           ^\n/tmp/tmpfz5wccub.swift:23:18: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n    guard w <= q.last else\
    \ {\n                 ^\n                      ?? <#default value#>\n/tmp/tmpfz5wccub.swift:23:18:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    guard w <= q.last else {\n                 ^\n                  \
    \   !\n"
  stdout: ''
  timestamp: 1660014316
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    \n    // Write your code here.\n\
    \    \n    var maxSum = w\n    var maxSumIndex = 0\n    \n    for index in 0..<q.count\
    \ {\n        let currentSum = q[index] + w\n        if currentSum > maxSum {\n\
    \            maxSum = currentSum\n            maxSumIndex = index\n        }\n\
    \    }\n    \n    return maxSumIndex == q.count - 1\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmperlup0co/tmperlup0co.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba88d4c9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba88d1c0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba88d1c0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba88d1bf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmperlup0co                        0x00005622277c753f <unavailable> + 5439

    5    libc.so.6                          0x00002ba88d6b5460 __libc_start_main +
    245

    6    tmperlup0co                        0x00005622277c71a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014317
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    if q.count == 0 || w == 0 {\n\
    \        return true\n    }\n    \n    let maxWeight = w\n    \n    var maxSum\
    \ = q[0]\n    \n    for x in q {\n        maxSum -= x\n        if maxSum < 0 {\n\
    \            return false\n        }\n    }\n    \n    if maxSum > maxWeight {\n\
    \        return false\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpgmu159h8/tmpgmu159h8.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac384898c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac38458fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac38458f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac38458e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgmu159h8                        0x000055eee7dd351f <unavailable> + 5407

    5    libc.so.6                          0x00002ac384a84460 __libc_start_main +
    245

    6    tmpgmu159h8                        0x000055eee7dd3189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1660014317
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 && w > 0 &&\
    \ w <= q.max() else { return false }\n    \n    var maxSum = q.max()\n    var\
    \ sum = 0\n    for v in q {\n        sum += v\n        if sum > maxSum { maxSum\
    \ = sum }\n    }\n    \n    return maxSum == w\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpw4sv2wn7.swift:14:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else { return false }\n                                         ^\n\
    /tmp/tmpw4sv2wn7.swift:14:42: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max()\
    \ else { return false }\n                                         ^\n        \
    \                                       ?? <#default value#>\n/tmp/tmpw4sv2wn7.swift:14:42:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else { return false }\n\
    \                                         ^\n                                \
    \              !\n/tmp/tmpw4sv2wn7.swift:20:18: error: value of optional type\
    \ 'Int?' must be unwrapped to a value of type 'Int'\n        if sum > maxSum {\
    \ maxSum = sum }\n                 ^\n/tmp/tmpw4sv2wn7.swift:20:18: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \     if sum > maxSum { maxSum = sum }\n                 ^\n                 \
    \       ?? <#default value#>\n/tmp/tmpw4sv2wn7.swift:20:18: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        if\
    \ sum > maxSum { maxSum = sum }\n                 ^\n                       !\n"
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 && w > 0 &&\
    \ w <= q.max() else {\n        return false\n    }\n    \n    var sum = 0\n  \
    \  for x in q {\n        sum += x\n    }\n    \n    return sum == w && q == q.sort()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpytm3hsi3.swift:14:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else {\n                                         ^\n/tmp/tmpytm3hsi3.swift:14:42:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else {\n             \
    \                            ^\n                                             \
    \  ?? <#default value#>\n/tmp/tmpytm3hsi3.swift:14:42: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    guard q.count\
    \ > 0 && w > 0 && w <= q.max() else {\n                                      \
    \   ^\n                                              !\n/tmp/tmpytm3hsi3.swift:23:24:\
    \ error: cannot convert value of type '[Int]' to expected argument type '()'\n\
    \    return sum == w && q == q.sort()\n                       ^\n/tmp/tmpytm3hsi3.swift:23:31:\
    \ error: cannot use mutating member on immutable value: 'q' is a 'let' constant\n\
    \    return sum == w && q == q.sort()\n                            ~ ^\n"
  stdout: ''
  timestamp: 1660014316
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var max = 0\n    for x in q\
    \ {\n        if x > max {\n            max = x\n        }\n    }\n    if max <=\
    \ w {\n        return true\n    }\n    var i = 0\n    var j = q.count - 1\n  \
    \  var sum = 0\n    while i < j {\n        sum += q[i]\n        if sum > w {\n\
    \            return false\n        }\n        i += 1\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp68nzhwvd/tmp68nzhwvd.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b42ecfb9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b42eccb0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b42eccb0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b42eccaf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp68nzhwvd                        0x00005562383bf5db <unavailable> + 5595

    5    libc.so.6                          0x00002b42ed1a5460 __libc_start_main +
    245

    6    tmp68nzhwvd                        0x00005562383bf189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1660014317
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxSum = w\n    var maxSumIndex\
    \ = 0\n    var maxSumElement = q[0]\n    for i := 1; i < len(q); i++ {\n     \
    \   maxSum += q[i]\n        if maxSum > w {\n            return false\n      \
    \  }\n        if maxSum > maxSumElement {\n            maxSumElement = maxSum\n\
    \            maxSumIndex = i\n        }\n    }\n    return maxSumElement == q[maxSumIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpu_a_k4vk.swift:17:12: error: expected type\n    for i := 1; i <\
    \ len(q); i++ {\n           ^\n            <#type#>\n/tmp/tmpu_a_k4vk.swift:17:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 1; i < len(q); i++\
    \ {\n           ^\n/tmp/tmpu_a_k4vk.swift:17:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 1; i < len(q); i++ {\n           ^\n"
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count == w.count &&\
    \ q.count == q.max() else {\n        return false\n    }\n    \n    var maxSum\
    \ = w.reduce(0, combine: +)\n    \n    for element in q {\n        maxSum -= element\n\
    \        if maxSum < 0 {\n            return false\n        }\n    }\n    \n \
    \   return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpzd3pa09d.swift:14:24: error: value of type 'Int' has no member\
    \ 'count'\n    guard q.count == w.count && q.count == q.max() else {\n       \
    \              ~ ^~~~~\n/tmp/tmpzd3pa09d.swift:18:20: error: value of type 'Int'\
    \ has no member 'reduce'\n    var maxSum = w.reduce(0, combine: +)\n         \
    \        ~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014317
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxSum = w\n    var maxSumIndex\
    \ = 0\n    var maxSumElement = q[0]\n    for index in 1..<q.count {\n        let\
    \ element = q[index]\n        let sum = element + maxSumElement\n        if sum\
    \ > maxSum {\n            maxSum = sum\n            maxSumIndex = index\n    \
    \        maxSumElement = element\n        }\n    }\n    return maxSum == w &&\
    \ maxSumIndex == q.count - 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp9p0q3de5/tmp9p0q3de5.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adbf0b37c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adbf082eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adbf082e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adbf082d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9p0q3de5                        0x0000563a3db0953f <unavailable> + 5439

    5    libc.so.6                          0x00002adbf0d23460 __libc_start_main +
    245

    6    tmp9p0q3de5                        0x0000563a3db091a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014317
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 && w > 0 &&\
    \ w <= q.max() else {\n        return false\n    }\n    var sum = 0\n    for element\
    \ in q {\n        sum += element\n    }\n    return sum == w && is_palindromic(q)\
    \ && is_balanced(q)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmplupvkq7k.swift:14:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else {\n                                         ^\n/tmp/tmplupvkq7k.swift:14:42:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else {\n             \
    \                            ^\n                                             \
    \  ?? <#default value#>\n/tmp/tmplupvkq7k.swift:14:42: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    guard q.count\
    \ > 0 && w > 0 && w <= q.max() else {\n                                      \
    \   ^\n                                              !\n/tmp/tmplupvkq7k.swift:21:24:\
    \ error: cannot find 'is_palindromic' in scope\n    return sum == w && is_palindromic(q)\
    \ && is_balanced(q)\n                       ^~~~~~~~~~~~~~\n/tmp/tmplupvkq7k.swift:21:45:\
    \ error: cannot find 'is_balanced' in scope\n    return sum == w && is_palindromic(q)\
    \ && is_balanced(q)\n                                            ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014317
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxWeight = w\n    var balanced\
    \ = true\n    var sum = 0\n    for element in q {\n        sum += element\n  \
    \      if sum > maxWeight {\n            maxWeight = sum\n        }\n        if\
    \ element != q[q.index(element)!] {\n            balanced = false\n        }\n\
    \    }\n    return balanced && sum <= maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpw9os74uk.swift:22:33: error: missing argument label 'of:' in call\n\
    \        if element != q[q.index(element)!] {\n                              \
    \  ^\n                                of: \n"
  stdout: ''
  timestamp: 1660014317
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxSum = w\n    var maxSumIndex\
    \ = 0\n    var maxSumElement = q[0]\n    for index in 1..<q.count {\n        let\
    \ element = q[index]\n        let sum = element + maxSumElement\n        if sum\
    \ > maxSum {\n            maxSum = sum\n            maxSumIndex = index\n    \
    \        maxSumElement = element\n        }\n    }\n    return maxSum == w\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp5np7fryw/tmp5np7fryw.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6adcb01c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6adc7f8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6adc7f8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6adc7f77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5np7fryw                        0x00005574549495fb <unavailable> + 5627

    5    libc.so.6                          0x00002b6adcced460 __libc_start_main +
    245

    6    tmp5np7fryw                        0x00005574549491a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014317
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxSum = w\n    for element\
    \ in q {\n        maxSum -= element\n        if maxSum < 0 {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpx307ezpn/tmpx307ezpn.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b74389bac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b74386b1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b74386b1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b74386b07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx307ezpn                        0x0000559246c9652b <unavailable> + 5419

    5    libc.so.6                          0x00002b7438ba6460 __libc_start_main +
    245

    6    tmpx307ezpn                        0x0000559246c960d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 && w > 0 &&\
    \ w <= q.max() else { return false }\n    guard let first = q.first else { return\
    \ false }\n    guard let last = q.last else { return false }\n    guard let middle\
    \ = q.mid(at: q.count / 2) else { return false }\n    guard let middleWeight =\
    \ middle.reduce(0) { $0 + $1 }\n    guard middleWeight <= w else { return false\
    \ }\n    guard let middleReversed = middle.reversed().reduce(0) { $0 + $1 }\n\
    \    guard middleReversed <= w else { return false }\n    guard let middleReversedWeight\
    \ = middleReversed.reduce(0) { $0 + $1 }\n    guard middleReversedWeight <= w\
    \ else { return false }\n    return middleWeight <= w && middleReversedWeight\
    \ <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpg5_1658y.swift:18:47: error: expected 'else' after 'guard' condition\n\
    \    guard let middleWeight = middle.reduce(0) { $0 + $1 }\n                 \
    \                             ^\n                                            \
    \  else \n/tmp/tmpg5_1658y.swift:18:49: error: anonymous closure argument not\
    \ contained in a closure\n    guard let middleWeight = middle.reduce(0) { $0 +\
    \ $1 }\n                                                ^\n/tmp/tmpg5_1658y.swift:18:54:\
    \ error: anonymous closure argument not contained in a closure\n    guard let\
    \ middleWeight = middle.reduce(0) { $0 + $1 }\n                              \
    \                       ^\n/tmp/tmpg5_1658y.swift:20:60: error: expected 'else'\
    \ after 'guard' condition\n    guard let middleReversed = middle.reversed().reduce(0)\
    \ { $0 + $1 }\n                                                           ^\n\
    \                                                           else \n/tmp/tmpg5_1658y.swift:20:62:\
    \ error: anonymous closure argument not contained in a closure\n    guard let\
    \ middleReversed = middle.reversed().reduce(0) { $0 + $1 }\n                 \
    \                                            ^\n/tmp/tmpg5_1658y.swift:20:67:\
    \ error: anonymous closure argument not contained in a closure\n    guard let\
    \ middleReversed = middle.reversed().reduce(0) { $0 + $1 }\n                 \
    \                                                 ^\n/tmp/tmpg5_1658y.swift:22:63:\
    \ error: expected 'else' after 'guard' condition\n    guard let middleReversedWeight\
    \ = middleReversed.reduce(0) { $0 + $1 }\n                                   \
    \                           ^\n                                              \
    \                else \n/tmp/tmpg5_1658y.swift:22:65: error: anonymous closure\
    \ argument not contained in a closure\n    guard let middleReversedWeight = middleReversed.reduce(0)\
    \ { $0 + $1 }\n                                                              \
    \  ^\n/tmp/tmpg5_1658y.swift:22:70: error: anonymous closure argument not contained\
    \ in a closure\n    guard let middleReversedWeight = middleReversed.reduce(0)\
    \ { $0 + $1 }\n  "
  stdout: ''
  timestamp: 1660014317
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum\
    \ = q.reduce(0, +)\n    for x in q {\n        if x > maxWeight {\n           \
    \ maxWeight = x\n            maxSum = x\n        }\n    }\n    return maxSum ==\
    \ maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2,\
    \ 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpdvf8m70q/tmpdvf8m70q.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2462255c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2461f4cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2461f4c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2461f4b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdvf8m70q                        0x000055895204a4df <unavailable> + 5343

    5    libc.so.6                          0x00002b2462441460 __libc_start_main +
    245

    6    tmpdvf8m70q                        0x000055895204a149 <unavailable> + 4425

    '
  stdout: ''
  timestamp: 1660014317
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxSum = w\n    var maxSumIndex\
    \ = 0\n    var sum = 0\n    for i : Int in 0..<q.count {\n        sum += q[i]\n\
    \        if sum > maxSum {\n            maxSum = sum\n            maxSumIndex\
    \ = i\n        }\n    }\n    if maxSum < w {\n        return false\n    }\n  \
    \  var reversedQ = q.reverse()\n    for i : Int in 0..<reversedQ.count {\n   \
    \     sum += reversedQ[i]\n        if sum > maxSum {\n            maxSum = sum\n\
    \            maxSumIndex = i\n        }\n    }\n    return maxSumIndex == q.count\
    \ - 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpliptoav0.swift:27:23: error: cannot use mutating member on immutable\
    \ value: 'q' is a 'let' constant\n    var reversedQ = q.reverse()\n          \
    \          ~ ^\n"
  stdout: ''
  timestamp: 1660014317
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    \n    var maxSum = w\n    var\
    \ maxSumIndex = 0\n    \n    for index in 0..<q.count {\n        let element =\
    \ q[index]\n        \n        if element > maxSum {\n            maxSum = element\n\
    \            maxSumIndex = index\n        }\n    }\n    \n    if maxSum == w {\n\
    \        return true\n    }\n    \n    if maxSum > w {\n        return false\n\
    \    }\n    \n    if maxSumIndex == 0 {\n        return true\n    }\n    \n  \
    \  if maxSumIndex == q.count - 1 {\n        return true\n    }\n    \n    if maxSumIndex\
    \ == 1 {\n        return q[0] == q[q.count - 1]\n    }\n    \n    if maxSumIndex\
    \ == 2 {\n        return q[0] == q[1] && q[1] == q[q.count - 1]\n    }\n    \n\
    \    if maxSumIndex == 3 {\n        return q[0] == q[1] && q[1] == q[2] && q[2]\
    \ == q[q.count - 1]\n    }\n    \n    if maxSumIndex == 4 {\n        return q[0]\
    \ == q[1] && q[1] == q[2] && q[2] == q[3] && q[3] == q[q.count - 1]\n    }\n \
    \   \n    if maxSumIndex == 5 {\n        return q[0] == q[1] && q[1] == q[2] &&\
    \ q[2] == q[3] && q[3] == q[4] && q[4] == q[q.count - 1]\n    }\n    \n    if\
    \ maxSumIndex == 6 {\n        return q[0] == q[1] && q[1] == q[2] && q[2] == q[3]\
    \ && q[3] == q[4] && q[4] == q[5] && q[5] == q[q.count - 1]\n    }\n    \n   \
    \ if maxSumIndex == 7 {\n        return q[0] == q[1] && q[1] == q[2] && q[2] ==\
    \ q[3] && q[3] == q[4] && q[4] == q[5] && q[5] == q[6] && q[6] == q[q.count -\
    \ 1]\n    }\n    \n    if maxSumIndex == 8 {\n        return q[0] == q[1] && q[1]\
    \ == q[2] && q[2] == q[3] && q[3] == q[4] && q[4] == q[5] && q[5] == q[6] && q[6]\
    \ == q[7] && q[7] == q[q.count - 1]\n    }\n    \n    if maxSumIndex == 9 {\n\
    \        return q[0] == q[1] && q[1] == q[2] && q[2] == q[3] && q[3] == q[4] &&\
    \ q[4] == q[5] && q[5] == q[6] && q[6] == q[7] && q[7] == q[8] && q[8] == q[q.count\
    \ - 1]\n    }\n    \n    if \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmps7vee6uz.swift:79:7: error: expected expression, var, or let in\
    \ 'if' condition\n    if \n      ^\n"
  stdout: ''
  timestamp: 1660014317
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 && w > 0 &&\
    \ w <= q.max() else {\n        return false\n    }\n    var sum = 0\n    for i\
    \ in q {\n        sum += i\n    }\n    return sum == w && is_balanced(q)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpp0_8_wzs.swift:14:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else {\n                                         ^\n/tmp/tmpp0_8_wzs.swift:14:42:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else {\n             \
    \                            ^\n                                             \
    \  ?? <#default value#>\n/tmp/tmpp0_8_wzs.swift:14:42: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    guard q.count\
    \ > 0 && w > 0 && w <= q.max() else {\n                                      \
    \   ^\n                                              !\n/tmp/tmpp0_8_wzs.swift:21:24:\
    \ error: cannot find 'is_balanced' in scope\n    return sum == w && is_balanced(q)\n\
    \                       ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014317
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 && w > 0 &&\
    \ w <= q.max() else { return false }\n    var sum = 0\n    for i in q {\n    \
    \    sum += i\n    }\n    return sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp5voog058.swift:14:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else { return false }\n                                         ^\n\
    /tmp/tmp5voog058.swift:14:42: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max()\
    \ else { return false }\n                                         ^\n        \
    \                                       ?? <#default value#>\n/tmp/tmp5voog058.swift:14:42:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else { return false }\n\
    \                                         ^\n                                \
    \              !\n"
  stdout: ''
  timestamp: 1660014317
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count == w else {\n\
    \        return false\n    }\n    \n    let maxWeight = w\n    var sum = 0\n \
    \   \n    for element in q {\n        sum += element\n    }\n    \n    return\
    \ sum <= maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpdbxkcm2p/tmpdbxkcm2p.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b12ed8ffc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b12ed5f6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b12ed5f6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b12ed5f57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdbxkcm2p                        0x000055ca3e9434bf <unavailable> + 5311

    5    libc.so.6                          0x00002b12edaeb460 __libc_start_main +
    245

    6    tmpdbxkcm2p                        0x000055ca3e943129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014317
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxSum = w\n    var maxSumIndex\
    \ = 0\n    var sum = 0\n    for i in  q {\n        sum += i\n        if sum >\
    \ maxSum {\n            maxSum = sum\n            maxSumIndex = i\n        }\n\
    \    }\n    return maxSum == w && maxSumIndex < q.count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpl9nh23wa/tmpl9nh23wa.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7dd917bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7dd8e72b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7dd8e72988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7dd8e717b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9nh23wa                        0x000055d0ba76557b <unavailable> + 5499

    5    libc.so.6                          0x00002b7dd9367460 __libc_start_main +
    245

    6    tmpl9nh23wa                        0x000055d0ba765129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014317
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var max = 0\n    for x in q\
    \ {\n        max = max(max, x)\n    }\n    if w == max {\n        return true\n\
    \    }\n    if w > max {\n        return false\n    }\n    var i = 0\n    var\
    \ j = 0\n    var sum = 0\n    var balanced = true\n    while i < q.count {\n \
    \       sum += q[i]\n        if sum > w {\n            balanced = false\n    \
    \        break\n        }\n        i += 1\n    }\n    if balanced {\n        for\
    \ j = q.count - 1; j >= 0; j-- {\n            sum += q[j]\n            if sum\
    \ > w {\n                balanced = false\n                break\n           \
    \ }\n        }\n    }\n    return balanced\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmphgilq2gd.swift:37:9: error: C-style for statement has been removed\
    \ in Swift 3\n        for j = q.count - 1; j >= 0; j-- {\n        ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmphgilq2gd.swift:16:15: error: cannot call value of non-function type 'Int'\n\
    \        max = max(max, x)\n              ^\n"
  stdout: ''
  timestamp: 1660014317
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var max = 0\n    for x in q\
    \ {\n        if x > max {\n            max = x\n        }\n    }\n    if max ==\
    \ 0 {\n        return true\n    }\n    var sum = 0\n    for x in q {\n       \
    \ sum += x\n    }\n    if sum == w {\n        return true\n    }\n    if sum >\
    \ w {\n        return false\n    }\n    return will_it_fly(q, w)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp2jq7z3oe.swift:33:23: error: missing argument labels 'q:w:' in\
    \ call\n    return will_it_fly(q, w)\n                      ^\n              \
    \         q: w: \n"
  stdout: ''
  timestamp: 1660014317
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxSum = w\n    var maxSumIndex\
    \ = 0\n    var maxSumIndex2 = 0\n    var maxSumIndex3 = 0\n    var maxSumIndex4\
    \ = 0\n    var maxSumIndex5 = 0\n    var maxSumIndex6 = 0\n    var maxSumIndex7\
    \ = 0\n    var maxSumIndex8 = 0\n    var maxSumIndex9 = 0\n    var maxSumIndex10\
    \ = 0\n    var maxSumIndex11 = 0\n    var maxSumIndex12 = 0\n    var maxSumIndex13\
    \ = 0\n    var maxSumIndex14 = 0\n    var maxSumIndex15 = 0\n    var maxSumIndex16\
    \ = 0\n    var maxSumIndex17 = 0\n    var maxSumIndex18 = 0\n    var maxSumIndex19\
    \ = 0\n    var maxSumIndex20 = 0\n    var maxSumIndex21 = 0\n    var maxSumIndex22\
    \ = 0\n    var maxSumIndex23 = 0\n    var maxSumIndex24 = 0\n    var maxSumIndex25\
    \ = 0\n    var maxSumIndex26 = 0\n    var maxSumIndex27 = 0\n    var maxSumIndex28\
    \ = 0\n    var maxSumIndex29 = 0\n    var maxSumIndex30 = 0\n    var maxSumIndex31\
    \ = 0\n    var maxSumIndex32 = 0\n    var maxSumIndex33 = 0\n    var maxSumIndex34\
    \ = 0\n    var maxSumIndex35 = 0\n    var maxSumIndex36 = 0\n    var maxSumIndex37\
    \ = 0\n    var maxSumIndex38 = 0\n    var maxSumIndex39 = 0\n    var maxSumIndex40\
    \ = 0\n    var maxSumIndex41 = 0\n    var maxSumIndex42 = 0\n    var maxSumIndex43\
    \ = 0\n    var maxSumIndex44 = 0\n    var maxSumIndex45 = 0\n    var maxSumIndex46\
    \ = 0\n    var maxSumIndex47 = 0\n    var maxSumIndex48 = 0\n    var maxSumIndex49\
    \ = 0\n    var maxSumIndex50 = 0\n    var maxSumIndex51 = 0\n    var maxSumIndex52\
    \ = 0\n    var maxSumIndex53 = 0\n    var maxSumIndex54 = 0\n    var maxSumIndex55\
    \ = 0\n    var maxSumIndex56 = 0\n    var maxSumIndex57 = 0\n    var maxSumIndex58\
    \ = 0\n    var maxSumIndex59 = 0\n    var maxSumIndex60 = 0\n    var maxSumIndex61\
    \ = 0\n    var maxSumIndex62 = 0\n    var maxSumIndex63 = 0\n    var maxSumIndex64\
    \ = 0\n    var maxSumIndex65 = 0\n    var maxSumIndex66 = 0\n    var maxSumIndex67\
    \ = 0\n    var maxSumIndex68 = 0\n    var maxSumIndex69 = 0\n    var maxSumIndex70\
    \ = 0\n    var maxSumIndex71 = 0\n    var maxSumIndex72 = 0\n    var maxSum\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp97h3r40x.swift:87:9: error: type annotation missing in pattern\n\
    \    var maxSum\n        ^\n"
  stdout: ''
  timestamp: 1660014317
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxSum = w\n    var maxSumIndex\
    \ = 0\n    var maxSumIndex2 = 0\n    var maxSumIndex3 = 0\n    var maxSumIndex4\
    \ = 0\n    var maxSumIndex5 = 0\n    var maxSumIndex6 = 0\n    var maxSumIndex7\
    \ = 0\n    var maxSumIndex8 = 0\n    var maxSumIndex9 = 0\n    var maxSumIndex10\
    \ = 0\n    var maxSumIndex11 = 0\n    var maxSumIndex12 = 0\n    var maxSumIndex13\
    \ = 0\n    var maxSumIndex14 = 0\n    var maxSumIndex15 = 0\n    var maxSumIndex16\
    \ = 0\n    var maxSumIndex17 = 0\n    var maxSumIndex18 = 0\n    var maxSumIndex19\
    \ = 0\n    var maxSumIndex20 = 0\n    var maxSumIndex21 = 0\n    var maxSumIndex22\
    \ = 0\n    var maxSumIndex23 = 0\n    var maxSumIndex24 = 0\n    var maxSumIndex25\
    \ = 0\n    var maxSumIndex26 = 0\n    var maxSumIndex27 = 0\n    var maxSumIndex28\
    \ = 0\n    var maxSumIndex29 = 0\n    var maxSumIndex30 = 0\n    var maxSumIndex31\
    \ = 0\n    var maxSumIndex32 = 0\n    var maxSumIndex33 = 0\n    var maxSumIndex34\
    \ = 0\n    var maxSumIndex35 = 0\n    var maxSumIndex36 = 0\n    var maxSumIndex37\
    \ = 0\n    var maxSumIndex38 = 0\n    var maxSumIndex39 = 0\n    var maxSumIndex40\
    \ = 0\n    var maxSumIndex41 = 0\n    var maxSumIndex42 = 0\n    var maxSumIndex43\
    \ = 0\n    var maxSumIndex44 = 0\n    var maxSumIndex45 = 0\n    var maxSumIndex46\
    \ = 0\n    var maxSumIndex47 = 0\n    var maxSumIndex48 = 0\n    var maxSumIndex49\
    \ = 0\n    var maxSumIndex50 = 0\n    var maxSumIndex51 = 0\n    var maxSumIndex52\
    \ = 0\n    var maxSumIndex53 = 0\n    var maxSumIndex54 = 0\n    var maxSumIndex55\
    \ = 0\n    var maxSumIndex56 = 0\n    var maxSumIndex57 = 0\n    var maxSumIndex58\
    \ = 0\n    var maxSumIndex59 = 0\n    var maxSumIndex60 = 0\n    var maxSumIndex61\
    \ = 0\n    var maxSumIndex62 = 0\n    var maxSumIndex63 = 0\n    var maxSumIndex64\
    \ = 0\n    var maxSumIndex65 = 0\n    var maxSumIndex66 = 0\n    var maxSumIndex67\
    \ = 0\n    var maxSumIndex68 = 0\n    var maxSumIndex69 = 0\n    var maxSumIndex70\
    \ = 0\n    var maxSumIndex71 = 0\n    var maxSumIndex72 = 0\n    var maxSum\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp97h3r40x.swift:87:9: error: type annotation missing in pattern\n\
    \    var maxSum\n        ^\n"
  stdout: ''
  timestamp: 1660014317
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum\
    \ = q.reduce(0) { $0 + $1 }\n    for element in q {\n        if element > maxWeight\
    \ {\n            maxWeight = element\n        }\n        maxSum = maxSum + element\n\
    \    }\n    return maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmptgkzccx4/tmptgkzccx4.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b426935bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4269052b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4269052988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b42690517b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptgkzccx4                        0x000055c8a9bc94df <unavailable> + 5343

    5    libc.so.6                          0x00002b4269547460 __libc_start_main +
    245

    6    tmptgkzccx4                        0x000055c8a9bc9149 <unavailable> + 4425

    '
  stdout: ''
  timestamp: 1660014317
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum\
    \ = 0\n    for i := 0; i < len(q); i++ {\n        maxSum += q[i]\n        if maxSum\
    \ > maxWeight {\n            maxWeight = maxSum\n        }\n    }\n    return\
    \ maxWeight <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmptb4rdfrk.swift:16:12: error: expected type\n    for i := 0; i <\
    \ len(q); i++ {\n           ^\n            <#type#>\n/tmp/tmptb4rdfrk.swift:16:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(q); i++\
    \ {\n           ^\n/tmp/tmptb4rdfrk.swift:16:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(q); i++ {\n           ^\n"
  stdout: ''
  timestamp: 1660014317
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 else {\n \
    \       return true\n    }\n    \n    var maxWeight = w\n    var maxSum = 0\n\
    \    var isPalindromic = false\n    \n    for element in q {\n        if element\
    \ > maxWeight {\n            maxWeight = element\n        }\n        \n      \
    \  if element > maxSum {\n            maxSum = element\n        }\n        \n\
    \        if element == maxWeight {\n            isPalindromic = true\n       \
    \ }\n    }\n    \n    return isPalindromic && maxSum < maxWeight\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpqp914dza/tmpqp914dza.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aecd2843c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aecd253ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aecd253a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aecd25397b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqp914dza                        0x0000562791cae4bf <unavailable> + 5311

    5    libc.so.6                          0x00002aecd2a2f460 __libc_start_main +
    245

    6    tmpqp914dza                        0x0000562791cae129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014317
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count == w else {\n\
    \        return false\n    }\n    \n    var maxSum = w\n    var maxSumIndex =\
    \ 0\n    \n    for i in 0..<q.count {\n        let sum = q[i] + maxSum\n     \
    \   if sum > maxSum {\n            maxSum = sum\n            maxSumIndex = i\n\
    \        }\n    }\n    \n    return maxSum == w && maxSumIndex == 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpp_y6vszb/tmpp_y6vszb.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b76db876c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b76db56db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b76db56d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b76db56c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp_y6vszb                        0x000055afca64853f <unavailable> + 5439

    5    libc.so.6                          0x00002b76dba62460 __libc_start_main +
    245

    6    tmpp_y6vszb                        0x000055afca6481a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014317
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 && w > 0 &&\
    \ w <= q.maxElement() else { return false }\n    guard let first = q.first else\
    \ { return false }\n    let last = q.last\n    let sum = q.reduce(0, combine:\
    \ +)\n    return sum == w && first == last\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmprifa_mfc.swift:14:42: error: value of type '[Int]' has no member\
    \ 'maxElement'\n    guard q.count > 0 && w > 0 && w <= q.maxElement() else { return\
    \ false }\n                                       ~ ^~~~~~~~~~\n/tmp/tmprifa_mfc.swift:17:23:\
    \ error: extraneous argument label 'combine:' in call\n    let sum = q.reduce(0,\
    \ combine: +)\n                      ^   ~~~~~~~~~\n                         \
    \ \n"
  stdout: ''
  timestamp: 1660014317
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxWeight = w\n    var balanced\
    \ = true\n    for element in q {\n        if element > maxWeight {\n         \
    \   maxWeight = element\n        }\n        if element != maxWeight {\n      \
    \      balanced = false\n        }\n    }\n    return balanced && maxWeight <=\
    \ w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w:\
    \ 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpi3sq8tuh/tmpi3sq8tuh.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c8e933c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c8e62ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c8e62a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c8e6297b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi3sq8tuh                        0x000056020342646f <unavailable> + 5231

    5    libc.so.6                          0x00002b9c8eb1f460 __libc_start_main +
    245

    6    tmpi3sq8tuh                        0x00005602034260d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014317
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum\
    \ = q.reduce(0, +)\n    for element in q {\n        maxWeight -= element\n   \
    \     if maxWeight < 0 {\n            return false\n        }\n        maxSum\
    \ += element\n    }\n    return maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpdixlsehe/tmpdixlsehe.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3690b0fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3690806b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3690806988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b36908057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdixlsehe                        0x00005587827f64df <unavailable> + 5343

    5    libc.so.6                          0x00002b3690cfb460 __libc_start_main +
    245

    6    tmpdixlsehe                        0x00005587827f6149 <unavailable> + 4425

    '
  stdout: ''
  timestamp: 1660014317
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum\
    \ = 0\n    for element in q {\n        maxSum += element\n        if maxSum >\
    \ maxWeight {\n            maxWeight = maxSum\n        }\n    }\n    return maxWeight\
    \ <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpsmijm155/tmpsmijm155.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af165853c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af16554ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af16554a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af1655497b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsmijm155                        0x000055bc8df9152b <unavailable> + 5419

    5    libc.so.6                          0x00002af165a3f460 __libc_start_main +
    245

    6    tmpsmijm155                        0x000055bc8df910d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014317
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum\
    \ = q.reduce(0, +)\n    for element in q {\n        if element > maxWeight {\n\
    \            maxWeight = element\n        }\n        if element + maxWeight >\
    \ maxSum {\n            maxSum = element + maxWeight\n        }\n    }\n    return\
    \ maxWeight <= w && maxSum < w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpfk8qrkku/tmpfk8qrkku.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abc70c55c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abc7094cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abc7094c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abc7094b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfk8qrkku                        0x0000562eb8c294df <unavailable> + 5343

    5    libc.so.6                          0x00002abc70e41460 __libc_start_main +
    245

    6    tmpfk8qrkku                        0x0000562eb8c29149 <unavailable> + 4425

    '
  stdout: ''
  timestamp: 1660014317
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 && w > 0 &&\
    \ w <= q.max() else {\n        return false\n    }\n    \n    var sum = 0\n  \
    \  var max = 0\n    \n    for element in q {\n        sum += element\n       \
    \ if sum > max {\n            max = sum\n        }\n    }\n    \n    return sum\
    \ == max && q == q.sorted().reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpo7hen6yf.swift:14:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else {\n                                         ^\n/tmp/tmpo7hen6yf.swift:14:42:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else {\n             \
    \                            ^\n                                             \
    \  ?? <#default value#>\n/tmp/tmpo7hen6yf.swift:14:42: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    guard q.count\
    \ > 0 && w > 0 && w <= q.max() else {\n                                      \
    \   ^\n                                              !\n"
  stdout: ''
  timestamp: 1660014317
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    \n    // Write your code here.\n\
    \    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpsb8g9qn7/tmpsb8g9qn7.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aafecd9dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aafeca94b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aafeca94988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aafeca937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb8g9qn7                        0x000055bb6fd643bb <unavailable> + 5051

    5    libc.so.6                          0x00002aafecf89460 __libc_start_main +
    245

    6    tmpsb8g9qn7                        0x000055bb6fd63f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 && w > 0 &&\
    \ w <= q.max() else { return false }\n    var maxSum = w\n    var maxSumIndex\
    \ = 0\n    var maxSumElement = q[0]\n    for index in 1..<q.count {\n        let\
    \ element = q[index]\n        let sum = element + maxSumElement\n        if sum\
    \ > maxSum { maxSum = sum; maxSumIndex = index }\n        maxSumElement = element\n\
    \    }\n    return maxSum == w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpgu2xu31m.swift:14:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else { return false }\n                                         ^\n\
    /tmp/tmpgu2xu31m.swift:14:42: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max()\
    \ else { return false }\n                                         ^\n        \
    \                                       ?? <#default value#>\n/tmp/tmpgu2xu31m.swift:14:42:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else { return false }\n\
    \                                         ^\n                                \
    \              !\n"
  stdout: ''
  timestamp: 1660014317
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count == w else { return\
    \ false }\n    guard let first = q.first else { return false }\n    guard let\
    \ last = q.last else { return false }\n    guard let first = q.first else { return\
    \ false }\n    guard let last = q.last else { return false }\n    guard let first\
    \ = q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return \n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpm09masdy.swift:77:42: error: expected '}' at end of brace statement\n\
    assert(will_it_fly(q: [5], w: 5) == true)\n                                  \
    \       ^\n/tmp/tmpm09masdy.swift:13:44: note: to match this opening '{'\nfunc\
    \ will_it_fly(q: [Int], w: Int) -> Bool {\n                                  \
    \         ^\n/tmp/tmpm09masdy.swift:56:36: error: non-void function should return\
    \ a value\n    guard let last = q.last else { return \n                      \
    \             ^\n/tmp/tmpm09masdy.swift:60:6: error: operator functions can only\
    \ be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n/tmp/tmpm09masdy.swift:15:15: warning: value 'first'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let first = q.first else { return false }\n          ~~~~^~~~~~~~\n        \
    \                      != nil\n/tmp/tmpm09masdy.swift:16:15: warning: value 'last'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let last = q.last else { return false }\n          ~~~~^~~~~~~\n           \
    \                 != nil\n/tmp/tmpm09masdy.swift:17:15: warning: value 'first'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let first = q.first else { return false }\n          ~~~~^~~~~~~~\n        \
    \                      != nil\n/tmp/tmpm09masdy.swift:18:15: warning: value 'last'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let last = q.last else { return false }\n          ~~~~^~~~~~~\n           \
    \                 != nil\n/tmp/tmpm09masdy.swift:19:15: warning: value 'first'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let first = q.first else { return false }\n          ~~~~^~~~~~~~\n        \
    \                      != nil\n/tmp/tmpm09masdy.swift:20:15: warning: value 'last'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let last = q.last else { return false }\n          ~~~~^~~~~~~\n           \
    \                 != nil\n/tmp/tmpm09masdy.swift:21:15: warning: value 'f"
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.isEmpty == false else\
    \ {\n        return false\n    }\n    guard q.count == 1 else {\n        return\
    \ false\n    }\n    guard w >= 0 else {\n        return false\n    }\n    guard\
    \ w <= q.last else {\n        return false\n    }\n    guard q.reduce(0, +) ==\
    \ w else {\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp197f4nwr.swift:23:18: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard w <= q.last else {\n      \
    \           ^\n/tmp/tmp197f4nwr.swift:23:18: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n    guard w <= q.last else\
    \ {\n                 ^\n                      ?? <#default value#>\n/tmp/tmp197f4nwr.swift:23:18:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    guard w <= q.last else {\n                 ^\n                  \
    \   !\n"
  stdout: ''
  timestamp: 1660014317
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum\
    \ = w.reduce(0, +)\n    return q.count == q.count && q.sorted() == q.sorted()\
    \ && maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpp1gndddm.swift:15:20: error: value of type 'Int' has no member\
    \ 'reduce'\n    let maxSum = w.reduce(0, +)\n                 ~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014317
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxWeight = w\n    var balanced\
    \ = true\n    for element in q {\n        if element > maxWeight {\n         \
    \   maxWeight = element\n        }\n        if element != maxWeight {\n      \
    \      balanced = false\n        }\n    }\n    return balanced && maxWeight <=\
    \ w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w:\
    \ 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpi3sq8tuh/tmpi3sq8tuh.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c8e933c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c8e62ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c8e62a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c8e6297b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi3sq8tuh                        0x000056020342646f <unavailable> + 5231

    5    libc.so.6                          0x00002b9c8eb1f460 __libc_start_main +
    245

    6    tmpi3sq8tuh                        0x00005602034260d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014317
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum\
    \ = 0\n    for element in q {\n        maxWeight -= element\n        maxSum +=\
    \ element\n    }\n    return maxWeight <= 0 && maxSum < maxWeight\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp14syar2z/tmp14syar2z.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3ad462fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3ad4326b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3ad4326988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3ad43257b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp14syar2z                        0x000055d37648546f <unavailable> + 5231

    5    libc.so.6                          0x00002b3ad481b460 __libc_start_main +
    245

    6    tmp14syar2z                        0x000055d3764850d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014317
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count == w else { return\
    \ false }\n    var maxSum = w\n    var maxSumIndex = 0\n    var maxSumElement\
    \ = q[0]\n    for index in 1..<q.count {\n        let element = q[index]\n   \
    \     if element > maxSumElement {\n            maxSumElement = element\n    \
    \        maxSumIndex = index\n        }\n        maxSum = maxSum * element + maxSum\n\
    \    }\n    return maxSum == w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpfzgpbgpv/tmpfzgpbgpv.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af7c1431c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af7c1128b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af7c1128988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af7c11277b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfzgpbgpv                        0x00005586b777253f <unavailable> + 5439

    5    libc.so.6                          0x00002af7c161d460 __libc_start_main +
    245

    6    tmpfzgpbgpv                        0x00005586b77721a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014317
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum\
    \ = 0\n    for i := 0; i < len(q); i++ {\n        maxSum += q[i]\n        if maxSum\
    \ > maxWeight {\n            maxSum -= maxWeight\n            maxWeight = w\n\
    \        }\n    }\n    return maxSum == 0 || maxSum == w\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpoxnucqnx.swift:16:12: error: expected type\n    for i := 0; i <\
    \ len(q); i++ {\n           ^\n            <#type#>\n/tmp/tmpoxnucqnx.swift:16:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(q); i++\
    \ {\n           ^\n/tmp/tmpoxnucqnx.swift:16:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(q); i++ {\n           ^\n"
  stdout: ''
  timestamp: 1660014317
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 && w > 0 &&\
    \ w <= q.max() else {\n        return false\n    }\n    \n    var sum = 0\n  \
    \  for element in q {\n        sum += element\n    }\n    \n    return sum ==\
    \ w && is_balanced(q) && is_palindromic(q)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpa5ehb4gn.swift:14:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else {\n                                         ^\n/tmp/tmpa5ehb4gn.swift:14:42:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else {\n             \
    \                            ^\n                                             \
    \  ?? <#default value#>\n/tmp/tmpa5ehb4gn.swift:14:42: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    guard q.count\
    \ > 0 && w > 0 && w <= q.max() else {\n                                      \
    \   ^\n                                              !\n/tmp/tmpa5ehb4gn.swift:23:24:\
    \ error: cannot find 'is_balanced' in scope\n    return sum == w && is_balanced(q)\
    \ && is_palindromic(q)\n                       ^~~~~~~~~~~\n/tmp/tmpa5ehb4gn.swift:23:42:\
    \ error: cannot find 'is_palindromic' in scope\n    return sum == w && is_balanced(q)\
    \ && is_palindromic(q)\n                                         ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014317
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum\
    \ = q.sum\n    return q.count == 1 && maxSum == maxWeight && q[0] == maxWeight\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp3mlk1_em.swift:15:20: error: value of type '[Int]' has no member\
    \ 'sum'\n    let maxSum = q.sum\n                 ~ ^~~\n"
  stdout: ''
  timestamp: 1660014317
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count == w else { return\
    \ false }\n    var max = 0\n    for v in q {\n        max += v\n    }\n    if\
    \ max > w { return false }\n    var sum = 0\n    for v in q {\n        sum +=\
    \ v\n    }\n    if sum < max { return false }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpiaz3w722/tmpiaz3w722.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aee0dac3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aee0d7bab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aee0d7ba988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aee0d7b97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiaz3w722                        0x000055bade5c94bf <unavailable> + 5311

    5    libc.so.6                          0x00002aee0dcaf460 __libc_start_main +
    245

    6    tmpiaz3w722                        0x000055bade5c9129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014317
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count == w else { return\
    \ false }\n    guard let first = q.first else { return false }\n    guard let\
    \ last = q.last else { return false }\n    guard let first = q.first else { return\
    \ false }\n    guard let last = q.last else { return false }\n    guard let first\
    \ = q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return \n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpm09masdy.swift:77:42: error: expected '}' at end of brace statement\n\
    assert(will_it_fly(q: [5], w: 5) == true)\n                                  \
    \       ^\n/tmp/tmpm09masdy.swift:13:44: note: to match this opening '{'\nfunc\
    \ will_it_fly(q: [Int], w: Int) -> Bool {\n                                  \
    \         ^\n/tmp/tmpm09masdy.swift:56:36: error: non-void function should return\
    \ a value\n    guard let last = q.last else { return \n                      \
    \             ^\n/tmp/tmpm09masdy.swift:60:6: error: operator functions can only\
    \ be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n/tmp/tmpm09masdy.swift:15:15: warning: value 'first'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let first = q.first else { return false }\n          ~~~~^~~~~~~~\n        \
    \                      != nil\n/tmp/tmpm09masdy.swift:16:15: warning: value 'last'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let last = q.last else { return false }\n          ~~~~^~~~~~~\n           \
    \                 != nil\n/tmp/tmpm09masdy.swift:17:15: warning: value 'first'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let first = q.first else { return false }\n          ~~~~^~~~~~~~\n        \
    \                      != nil\n/tmp/tmpm09masdy.swift:18:15: warning: value 'last'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let last = q.last else { return false }\n          ~~~~^~~~~~~\n           \
    \                 != nil\n/tmp/tmpm09masdy.swift:19:15: warning: value 'first'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let first = q.first else { return false }\n          ~~~~^~~~~~~~\n        \
    \                      != nil\n/tmp/tmpm09masdy.swift:20:15: warning: value 'last'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let last = q.last else { return false }\n          ~~~~^~~~~~~\n           \
    \                 != nil\n/tmp/tmpm09masdy.swift:21:15: warning: value 'f"
  stdout: ''
  timestamp: 1660014316
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    \n    // Write your code here.\n\
    \    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpsb8g9qn7/tmpsb8g9qn7.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aafecd9dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aafeca94b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aafeca94988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aafeca937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb8g9qn7                        0x000055bb6fd643bb <unavailable> + 5051

    5    libc.so.6                          0x00002aafecf89460 __libc_start_main +
    245

    6    tmpsb8g9qn7                        0x000055bb6fd63f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014316
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var max = 0\n    for x in q\
    \ {\n        if x > max {\n            max = x\n        }\n    }\n    if w ==\
    \ max {\n        return true\n    }\n    if w < max {\n        return false\n\
    \    }\n    var sum = 0\n    for x in q {\n        sum += x\n    }\n    return\
    \ sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2,\
    \ 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp7mfzs4x0/tmp7mfzs4x0.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5b0ad40c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5b0aa37b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5b0aa37988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5b0aa367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7mfzs4x0                        0x000055f28ede952b <unavailable> + 5419

    5    libc.so.6                          0x00002b5b0af2c460 __libc_start_main +
    245

    6    tmp7mfzs4x0                        0x000055f28ede90d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014317
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    \n    var maxWeight = w\n  \
    \  var maxSum = q.reduce(0) { (max, next) -> Int in\n        return max < next\
    \ ? max : next\n    }\n    \n    for element in q {\n        if element > maxWeight\
    \ {\n            maxWeight = element\n        }\n    }\n    \n    return maxWeight\
    \ <= maxSum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2,\
    \ 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpuxg8735p/tmpuxg8735p.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f00408c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f000ffb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0f000ff988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0f000fe7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuxg8735p                        0x000055effe4f44df <unavailable> + 5343

    5    libc.so.6                          0x00002b0f005f4460 __libc_start_main +
    245

    6    tmpuxg8735p                        0x000055effe4f4149 <unavailable> + 4425

    '
  stdout: ''
  timestamp: 1660014317
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count == w else { return\
    \ false }\n    guard let first = q.first else { return false }\n    let max =\
    \ q.max()\n    guard max >= w else { return false }\n    guard let last = q.last\
    \ else { return false }\n    guard first == last else { return false }\n    guard\
    \ let mid = q.index(of: first) else {\n        return false\n    }\n    guard\
    \ let mid2 = q.index(of: last) else {\n        return false\n    }\n    guard\
    \ mid == mid2 else {\n        return false\n    }\n    guard let first = q.first,\n\
    \        let last = q.last,\n        let mid = q.index(of: first),\n        let\
    \ mid2 = q.index(of: last) else {\n        return false\n    }\n    guard mid\
    \ != mid2 else {\n        return false\n    }\n    guard let first = q.first,\n\
    \        let last = q.last,\n        let mid = q.index(of: first),\n        let\
    \ mid2 = q.index(of: last) else {\n        return false\n    }\n    guard mid\
    \ != mid2 else {\n        return false\n    }\n    guard let first = q.first,\n\
    \        let last = q.last,\n        let mid = q.index(of: first),\n        let\
    \ mid2 = q.index(of: last) else {\n        return false\n    }\n    guard mid\
    \ != mid2 else {\n        return false\n    }\n    guard let first = q.first,\n\
    \        let last = q.last,\n        let mid = q.index(of: first),\n        let\
    \ mid2 = q.index(of: last) else {\n        return false\n    }\n    guard mid\
    \ != mid2 else {\n        return false\n    }\n    guard let first = q.first,\n\
    \        let last = q.last,\n        let mid = q.index(of: first),\n        let\
    \ mid2 = q.index(of: last) else {\n        return false\n    }\n    guard mid\
    \ != mid2 else {\n        return false\n    }\n    guard let first = q.first,\n\
    \        let last = q.last,\n        let mid = q.index(of: first),\n        let\
    \ mid2 = q.index(of: last) else {\n        return false\n    }\n    guard mid\
    \ != mid2 else {\n        return false\n    }\n    guard let first = q.first,\n\
    \        let last = q.last,\n        let mid = q.index(of: first),\n        let\
    \ mid2 = q.index(of: last) else {\n        return false\n    }\n    guard mid\
    \ != mid2 else {\n        return false\n    }\n    guard let first = q.\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmptiferity.swift:92:24: error: expected member name following '.'\n\
    \    guard let first = q.\n                       ^\n/tmp/tmptiferity.swift:92:25:\
    \ error: expected 'else' after 'guard' condition\n    guard let first = q.\n \
    \                       ^\n/tmp/tmptiferity.swift:17:11: error: value of optional\
    \ type 'Int?' must be unwrapped to a value of type 'Int'\n    guard max >= w else\
    \ { return false }\n          ^\n/tmp/tmptiferity.swift:16:9: note: short-circuit\
    \ using 'guard' to exit this function early if the optional value contains 'nil'\n\
    \    let max = q.max()\n        ^\n    guard             else { return <#default\
    \ value#> }\n/tmp/tmptiferity.swift:16:17: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n    let max = q.max()\n  \
    \              ^\n                      ?? <#default value#>\n/tmp/tmptiferity.swift:16:17:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    let max = q.max()\n                ^\n                     !\n/tmp/tmptiferity.swift:17:11:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    guard max >= w else { return false }\n          ^\n             \
    \ ?? <#default value#>\n/tmp/tmptiferity.swift:17:11: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    guard max >=\
    \ w else { return false }\n          ^\n             !\n/tmp/tmptiferity.swift:20:23:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n    guard\
    \ let mid = q.index(of: first) else {\n                      ^\n/tmp/tmptiferity.swift:20:23:\
    \ note: use 'firstIndex(of:)' instead\n    guard let mid = q.index(of: first)\
    \ else {\n                      ^~~~~\n                      firstIndex\n/tmp/tmptiferity.swift:23:24:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n    guard\
    \ let mid2 = q.index(of: last) else {\n                       ^\n/tmp/tmptiferity.swift:23:24:\
    \ note: use 'firstIndex(of:)' instead\n    guard let mid2 = q.index(of: last)\
    \ else {\n                       ^~~~~\n        "
  stdout: ''
  timestamp: 1660014317
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 && w > 0 &&\
    \ w <= q.max() else { return false }\n    guard let first = q.first else { return\
    \ false }\n    guard let last = q.last else { return false }\n    guard let first\
    \ = q.first,\n        let last = q.last,\n        q.count == 1 || first == last\
    \ else { return false }\n    guard let first = q.first,\n        let last = q.last,\n\
    \        q.count == 1 || last == first else { return false }\n    guard let first\
    \ = q.first,\n        let last = q.last,\n        q.count == 1 || last == first\
    \ || q.last == first else { return false }\n    guard let first = q.first,\n \
    \       let last = q.last,\n        q.count == 1 || last == first || q.last ==\
    \ first || last == first else { return false }\n    guard let first = q.first,\n\
    \        let last = q.last,\n        q.count == 1 || last == first || q.last ==\
    \ first || last == first || last == first else { return false }\n    guard let\
    \ first = q.first,\n        let last = q.last,\n        q.count == 1 || last ==\
    \ first || q.last == first || last == first || last == first || last == first\
    \ else { return false }\n    guard let first = q.first,\n        let last = q.last,\n\
    \        q.count == 1 || last == first || q.last == first || last == first ||\
    \ last == first || last == first || last == first else { return false }\n    guard\
    \ let first = q.first,\n        let last = q.last,\n        q.count == 1 || last\
    \ == first || q.last == first || last == first || last == first || last == first\
    \ || last == first else { return false }\n    guard let first = q.first,\n   \
    \     let last = q.last,\n        q.count == 1 || last == first || q.last == first\
    \ || last == first || last == first || last == first || last == first || last\
    \ == first else { return false }\n    guard let first = q.first,\n        let\
    \ last = q.last,\n        q.count == 1 || last == first || q.last == first ||\
    \ last == first || last == first || last == first || last == first || last ==\
    \ first else { return false }\n    guard let first = q.first,\n        let last\
    \ = q.last,\n        q.count == 1 || last == first || q.last == first || last\
    \ == first || last == first || last == first || last == first || last == first\
    \ else { return false }\n    guard let first = q.first,\n        let \n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpj8mei1hq.swift:51:12: error: expected pattern\n        let \n \
    \          ^\n/tmp/tmpj8mei1hq.swift:51:9: error: unwrap condition requires a\
    \ valid identifier\n        let \n        ^\n        <#identifier#> = \n/tmp/tmpj8mei1hq.swift:51:12:\
    \ error: expected 'else' after 'guard' condition\n        let \n           ^\n\
    /tmp/tmpj8mei1hq.swift:14:42: error: value of optional type 'Int?' must be unwrapped\
    \ to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <= q.max() else\
    \ { return false }\n                                         ^\n/tmp/tmpj8mei1hq.swift:14:42:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else { return false }\n\
    \                                         ^\n                                \
    \               ?? <#default value#>\n/tmp/tmpj8mei1hq.swift:14:42: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    guard\
    \ q.count > 0 && w > 0 && w <= q.max() else { return false }\n               \
    \                          ^\n                                              !\n"
  stdout: ''
  timestamp: 1660014317
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxSum = w\n    var maxSumIndex\
    \ = 0\n    var maxSumIndex2 = 0\n    var maxSumIndex3 = 0\n    var maxSumIndex4\
    \ = 0\n    var maxSumIndex5 = 0\n    var maxSumIndex6 = 0\n    var maxSumIndex7\
    \ = 0\n    var maxSumIndex8 = 0\n    var maxSumIndex9 = 0\n    var maxSumIndex10\
    \ = 0\n    var maxSumIndex11 = 0\n    var maxSumIndex12 = 0\n    var maxSumIndex13\
    \ = 0\n    var maxSumIndex14 = 0\n    var maxSumIndex15 = 0\n    var maxSumIndex16\
    \ = 0\n    var maxSumIndex17 = 0\n    var maxSumIndex18 = 0\n    var maxSumIndex19\
    \ = 0\n    var maxSumIndex20 = 0\n    var maxSumIndex21 = 0\n    var maxSumIndex22\
    \ = 0\n    var maxSumIndex23 = 0\n    var maxSumIndex24 = 0\n    var maxSumIndex25\
    \ = 0\n    var maxSumIndex26 = 0\n    var maxSumIndex27 = 0\n    var maxSumIndex28\
    \ = 0\n    var maxSumIndex29 = 0\n    var maxSumIndex30 = 0\n    var maxSumIndex31\
    \ = 0\n    var maxSumIndex32 = 0\n    var maxSumIndex33 = 0\n    var maxSumIndex34\
    \ = 0\n    var maxSumIndex35 = 0\n    var maxSumIndex36 = 0\n    var maxSumIndex37\
    \ = 0\n    var maxSumIndex38 = 0\n    var maxSumIndex39 = 0\n    var maxSumIndex40\
    \ = 0\n    var maxSumIndex41 = 0\n    var maxSumIndex42 = 0\n    var maxSumIndex43\
    \ = 0\n    var maxSumIndex44 = 0\n    var maxSumIndex45 = 0\n    var maxSumIndex46\
    \ = 0\n    var maxSumIndex47 = 0\n    var maxSumIndex48 = 0\n    var maxSumIndex49\
    \ = 0\n    var maxSumIndex50 = 0\n    var maxSumIndex51 = 0\n    var maxSumIndex52\
    \ = 0\n    var maxSumIndex53 = 0\n    var maxSumIndex54 = 0\n    var maxSumIndex55\
    \ = 0\n    var maxSumIndex56 = 0\n    var maxSumIndex57 = 0\n    var maxSumIndex58\
    \ = 0\n    var maxSumIndex59 = 0\n    var maxSumIndex60 = 0\n    var maxSumIndex61\
    \ = 0\n    var maxSumIndex62 = 0\n    var maxSumIndex63 = 0\n    var maxSumIndex64\
    \ = 0\n    var maxSumIndex65 = 0\n    var maxSumIndex66 = 0\n    var maxSumIndex67\
    \ = 0\n    var maxSumIndex68 = 0\n    var maxSumIndex69 = 0\n    var maxSumIndex70\
    \ = 0\n    var maxSumIndex71 = 0\n    var maxSumIndex72 = 0\n    var maxSum\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp97h3r40x.swift:87:9: error: type annotation missing in pattern\n\
    \    var maxSum\n        ^\n"
  stdout: ''
  timestamp: 1660014317
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum\
    \ = q.reduce(0) { $0 + $1 }\n    for element in q {\n        if element > maxWeight\
    \ {\n            maxWeight = element\n        }\n        maxSum = maxSum + element\n\
    \    }\n    return maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmptgkzccx4/tmptgkzccx4.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b426935bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4269052b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4269052988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b42690517b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptgkzccx4                        0x000055c8a9bc94df <unavailable> + 5343

    5    libc.so.6                          0x00002b4269547460 __libc_start_main +
    245

    6    tmptgkzccx4                        0x000055c8a9bc9149 <unavailable> + 4425

    '
  stdout: ''
  timestamp: 1660014317
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxSum = w\n    var maxSumIndex\
    \ = 0\n    var isBalanced = true\n    for i := 0; i < len(q); i++ {\n        if\
    \ q[i] > maxSum {\n            maxSum = q[i]\n            maxSumIndex = i\n  \
    \      }\n    }\n    if maxSum < w {\n        isBalanced = false\n    }\n    if\
    \ maxSum == w {\n        return true\n    }\n    if maxSum < w {\n        return\
    \ false\n    }\n    if maxSum == w {\n        return true\n    }\n    if maxSum\
    \ > w {\n        return false\n    }\n    if maxSum == w {\n        return true\n\
    \    }\n    if maxSum > w {\n        return false\n    }\n    if maxSum == w {\n\
    \        return true\n    }\n    if maxSum > w {\n        return false\n    }\n\
    \    if maxSum == w {\n        return true\n    }\n    if maxSum > w {\n     \
    \   return false\n    }\n    if maxSum == w {\n        return true\n    }\n  \
    \  if maxSum > w {\n        return false\n    }\n    if maxSum == w {\n      \
    \  return true\n    }\n    if maxSum > w {\n        return false\n    }\n    if\
    \ maxSum == w {\n        return true\n    }\n    if maxSum > w {\n        return\
    \ false\n    }\n    if maxSum == w {\n        return true\n    }\n    if maxSum\
    \ > w {\n        return false\n    }\n    if maxSum == w {\n        return true\n\
    \    }\n    if maxSum > w {\n        return false\n    }\n    if maxSum == w {\n\
    \        return true\n    }\n    if maxSum > w {\n        return false\n    }\n\
    \    if maxSum == w {\n        return true\n    }\n    if maxSum > w {\n     \
    \   return false\n    }\n    if maxSum == w {\n        return true\n    }\n  \
    \  if maxSum > w {\n        return false\n    }\n    if maxSum == w {\n      \
    \  return true\n    }\n    if maxSum > w {\n        return false\n    }\n    if\
    \ maxSum == w {\n        return true\n    }\n    if maxSum > w {\n        return\
    \ false\n    }\n    if maxSum == w {\n        return true\n    }\n    if maxSum\
    \ > w {\n        return false\n    }\n    if maxSum == w {\n        return true\n\
    \    }\n    if maxSum > w {\n        return false\n    }\n    if maxSum == w {\n\
    \        return true\n    }\n    if maxSum > w {\n        return false\n    }\n\
    \    if maxSum == w {\n        return true\n    }\n    if max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpj31qgt60.swift:17:12: error: expected type\n    for i := 0; i <\
    \ len(q); i++ {\n           ^\n            <#type#>\n/tmp/tmpj31qgt60.swift:17:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(q); i++\
    \ {\n           ^\n/tmp/tmpj31qgt60.swift:17:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(q); i++ {\n           ^\n/tmp/tmpj31qgt60.swift:137:11:\
    \ error: expected '{' after 'if' condition\n    if max\n          ^\n/tmp/tmpj31qgt60.swift:137:8:\
    \ error: generic parameter 'T' could not be inferred\n    if max\n       ^\nSwift.max:1:24:\
    \ note: in call to function 'max'\n@inlinable public func max<T>(_ x: T, _ y:\
    \ T) -> T where T : Comparable\n                       ^\n/tmp/tmpj31qgt60.swift:137:8:\
    \ error: no 'max' candidates produce the expected contextual result type 'Bool'\n\
    \    if max\n       ^\nSwift.max:1:24: note: found candidate with type '(_, _)\
    \ -> _'\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\nSwift.max:1:24: note: found candidate with type '(_,\
    \ _, _, _...) -> _'\n@inlinable public func max<T>(_ x: T, _ y: T, _ z: T, _ rest:\
    \ T...) -> T where T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660014317
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count == w else { return\
    \ false }\n    guard let first = q.first else { return false }\n    guard let\
    \ last = q.last else { return false }\n    guard let firstReversed = q.reversed().first\
    \ else { return false }\n    guard let lastReversed = q.reversed().last else {\
    \ return false }\n    guard first == lastReversed else { return false }\n    guard\
    \ let firstReversedSum = q.reversed().reduce(0) { $0 + $1 }\n        <= w else\
    \ { return false }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp6zb53miw.swift:20:57: error: expected 'else' after 'guard' condition\n\
    \    guard let firstReversedSum = q.reversed().reduce(0) { $0 + $1 }\n       \
    \                                                 ^\n                        \
    \                                else \n/tmp/tmp6zb53miw.swift:20:59: error: anonymous\
    \ closure argument not contained in a closure\n    guard let firstReversedSum\
    \ = q.reversed().reduce(0) { $0 + $1 }\n                                     \
    \                     ^\n/tmp/tmp6zb53miw.swift:20:64: error: anonymous closure\
    \ argument not contained in a closure\n    guard let firstReversedSum = q.reversed().reduce(0)\
    \ { $0 + $1 }\n                                                              \
    \ ^\n/tmp/tmp6zb53miw.swift:21:9: error: unary operator cannot be separated from\
    \ its operand\n        <= w else { return false }\n        ^ ~\n          \n/tmp/tmp6zb53miw.swift:21:13:\
    \ error: consecutive statements on a line must be separated by ';'\n        <=\
    \ w else { return false }\n            ^\n            ;\n/tmp/tmp6zb53miw.swift:21:14:\
    \ error: expected expression\n        <= w else { return false }\n           \
    \  ^\n/tmp/tmp6zb53miw.swift:20:55: error: missing argument for parameter #2 in\
    \ call\n    guard let firstReversedSum = q.reversed().reduce(0) { $0 + $1 }\n\
    \                                                      ^\n                   \
    \                                   , <#(Int?, Int) throws -> Int?#>\nSwift.Sequence:2:28:\
    \ note: 'reduce' declared here\n    @inlinable public func reduce<Result>(_ initialResult:\
    \ Result, _ nextPartialResult: (_ partialResult: Result, Self.Element) throws\
    \ -> Result) rethrows -> Result\n                           ^\n/tmp/tmp6zb53miw.swift:21:9:\
    \ error: '<=' is not a prefix unary operator\n        <= w else { return false\
    \ }\n        ^\n"
  stdout: ''
  timestamp: 1660014317
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 && w > 0 &&\
    \ w <= q.max() else { return false }\n    guard let first = q.first else { return\
    \ false }\n    guard let last = q.last else { return false }\n    guard let mid\
    \ = q.mid(at: 0) else { return false }\n    guard let mid2 = q.mid(at: 1) else\
    \ { return false }\n    guard let mid3 = q.mid(at: 2) else { return false }\n\
    \    guard let mid4 = q.mid(at: 3) else { return false }\n    guard let mid5 =\
    \ q.mid(at: 4) else { return false }\n    guard let mid6 = q.mid(at: 5) else {\
    \ return false }\n    guard let mid7 = q.mid(at: 6) else { return false }\n  \
    \  guard let mid8 = q.mid(at: 7) else { return false }\n    guard let mid9 = q.mid(at:\
    \ 8) else { return false }\n    guard let mid10 = q.mid(at: 9) else { return false\
    \ }\n    guard let mid11 = q.mid(at: 10) else { return false }\n    guard let\
    \ mid12 = q.mid(at: 11) else { return false }\n    guard let mid13 = q.mid(at:\
    \ 12) else { return false }\n    guard let mid14 = q.mid(at: 13) else { return\
    \ false }\n    guard let mid15 = q.mid(at: 14) else { return false }\n    guard\
    \ let mid16 = q.mid(at: 15) else { return false }\n    guard let mid17 = q.mid(at:\
    \ 16) else { return false }\n    guard let mid18 = q.mid(at: 17) else { return\
    \ false }\n    guard let mid19 = q.mid(at: 18) else { return false }\n    guard\
    \ let mid20 = q.mid(at: 19) else { return false }\n    guard let mid21 = q.mid(at:\
    \ 20) else { return false }\n    guard let mid22 = q.mid(at: 21) else { return\
    \ false }\n    guard let mid23 = q.mid(at: 22) else { return false }\n    guard\
    \ let mid24 = q.mid(at: 23) else { return false }\n    guard let mid25 = q.mid(at:\
    \ 24) else { return false }\n    guard let mid26 = q.mid(at: 25) else { return\
    \ false }\n    guard let mid27 = q.mid(at\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp8fjouusr.swift:44:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmp8fjouusr.swift:43:28: note: to match this opening '('\n    guard let\
    \ mid27 = q.mid(at\n                           ^\n/tmp/tmp8fjouusr.swift:43:31:\
    \ error: expected 'else' after 'guard' condition\n    guard let mid27 = q.mid(at\n\
    \                              ^\n/tmp/tmp8fjouusr.swift:14:42: error: value of\
    \ optional type 'Int?' must be unwrapped to a value of type 'Int'\n    guard q.count\
    \ > 0 && w > 0 && w <= q.max() else { return false }\n                       \
    \                  ^\n/tmp/tmp8fjouusr.swift:14:42: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n    guard q.count\
    \ > 0 && w > 0 && w <= q.max() else { return false }\n                       \
    \                  ^\n                                               ?? <#default\
    \ value#>\n/tmp/tmp8fjouusr.swift:14:42: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n    guard q.count > 0 && w >\
    \ 0 && w <= q.max() else { return false }\n                                  \
    \       ^\n                                              !\n/tmp/tmp8fjouusr.swift:17:23:\
    \ error: value of type '[Int]' has no member 'mid'\n    guard let mid = q.mid(at:\
    \ 0) else { return false }\n                    ~ ^~~\n/tmp/tmp8fjouusr.swift:18:24:\
    \ error: value of type '[Int]' has no member 'mid'\n    guard let mid2 = q.mid(at:\
    \ 1) else { return false }\n                     ~ ^~~\n/tmp/tmp8fjouusr.swift:19:24:\
    \ error: value of type '[Int]' has no member 'mid'\n    guard let mid3 = q.mid(at:\
    \ 2) else { return false }\n                     ~ ^~~\n/tmp/tmp8fjouusr.swift:20:24:\
    \ error: value of type '[Int]' has no member 'mid'\n    guard let mid4 = q.mid(at:\
    \ 3) else { return false }\n                     ~ ^~~\n/tmp/tmp8fjouusr.swift:21:24:\
    \ error: value of type '[Int]' has no member 'mid'\n    guard let mid5 = q.mid(at:\
    \ 4) else { return false }\n                     ~ ^~~\n/tmp/tmp8fjouusr.swift:22:24:\
    \ error: value of type '[Int]' has no member 'mid'\n    guard let mid6 = q.mid(at:\
    \ 5) "
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxSum = w\n    var maxSumIndex\
    \ = 0\n    var maxSumValue = 0\n    for i in  q {\n        if maxSumValue < i\
    \ {\n            maxSumValue = i\n            maxSumIndex = i\n        }\n   \
    \ }\n    if maxSumValue == w {\n        return true\n    }\n    if maxSumValue\
    \ > w {\n        return false\n    }\n    var sum = 0\n    for i in  q {\n   \
    \     sum += i\n    }\n    if sum < w {\n        return false\n    }\n    if sum\
    \ > w {\n        return true\n    }\n    if maxSumIndex == 0 {\n        return\
    \ true\n    }\n    if maxSumIndex == q.count - 1 {\n        return false\n   \
    \ }\n    if maxSumIndex == q.count / 2 {\n        return will_it_fly(q, w)\n \
    \   }\n    if maxSumIndex == q.count / 2 + 1 {\n        return will_it_fly(q,\
    \ w)\n    }\n    if maxSumIndex == q.count / 2 + 2 {\n        return will_it_fly(q,\
    \ w)\n    }\n    if maxSumIndex == q.count / 2 + 3 {\n        return will_it_fly(q,\
    \ w)\n    }\n    if maxSumIndex == q.count / 2 + 4 {\n        return will_it_fly(q,\
    \ w)\n    }\n    if maxSumIndex == q.count / 2 + 5 {\n        return will_it_fly(q,\
    \ w)\n    }\n    if maxSumIndex == q.count / 2 + 6 {\n        return will_it_fly(q,\
    \ w)\n    }\n    if maxSumIndex == q.count / 2 + 7 {\n        return will_it_fly(q,\
    \ w)\n    }\n    if maxSumIndex == q.count / 2 + 8 {\n        return will_it_fly(q,\
    \ w)\n    }\n    if maxSumIndex == q.count / 2 + 9 {\n        return will_it_fly(q,\
    \ w)\n    }\n    if maxSumIndex == q.count / 2 + 10 {\n        return will_it_fly(q,\
    \ w)\n    }\n    if maxSumIndex == q.count / 2 + 11 {\n        return will_it_fly(q,\
    \ w)\n    }\n    if maxSumIndex == q.count / 2 + 12 {\n        return will_it_fly(q,\
    \ w)\n    }\n    if maxSumIndex == q.count / 2 + 13 {\n        return will_it_fly(q,\
    \ w)\n    }\n    if maxSumIndex == q.count / 2 + 14 {\n        return will_it_fly(q,\
    \ w)\n    }\n    if maxSumIndex == q.count / 2 + 15 {\n        return will_it_fly(q,\
    \ w)\n    }\n    if maxSumIndex == q.count / 2 + 16 {\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpigf7xfd6.swift:114:42: error: expected '}' at end of brace statement\n\
    assert(will_it_fly(q: [5], w: 5) == true)\n                                  \
    \       ^\n/tmp/tmpigf7xfd6.swift:13:44: note: to match this opening '{'\nfunc\
    \ will_it_fly(q: [Int], w: Int) -> Bool {\n                                  \
    \         ^\n/tmp/tmpigf7xfd6.swift:46:27: error: missing argument labels 'q:w:'\
    \ in call\n        return will_it_fly(q, w)\n                          ^\n   \
    \                        q: w: \n/tmp/tmpigf7xfd6.swift:49:27: error: missing\
    \ argument labels 'q:w:' in call\n        return will_it_fly(q, w)\n         \
    \                 ^\n                           q: w: \n/tmp/tmpigf7xfd6.swift:52:27:\
    \ error: missing argument labels 'q:w:' in call\n        return will_it_fly(q,\
    \ w)\n                          ^\n                           q: w: \n/tmp/tmpigf7xfd6.swift:55:27:\
    \ error: missing argument labels 'q:w:' in call\n        return will_it_fly(q,\
    \ w)\n                          ^\n                           q: w: \n/tmp/tmpigf7xfd6.swift:58:27:\
    \ error: missing argument labels 'q:w:' in call\n        return will_it_fly(q,\
    \ w)\n                          ^\n                           q: w: \n/tmp/tmpigf7xfd6.swift:61:27:\
    \ error: missing argument labels 'q:w:' in call\n        return will_it_fly(q,\
    \ w)\n                          ^\n                           q: w: \n/tmp/tmpigf7xfd6.swift:64:27:\
    \ error: missing argument labels 'q:w:' in call\n        return will_it_fly(q,\
    \ w)\n                          ^\n                           q: w: \n/tmp/tmpigf7xfd6.swift:67:27:\
    \ error: missing argument labels 'q:w:' in call\n        return will_it_fly(q,\
    \ w)\n                          ^\n                           q: w: \n/tmp/tmpigf7xfd6.swift:70:27:\
    \ error: missing argument labels 'q:w:' in call\n        return will_it_fly(q,\
    \ w)\n                          ^\n                           q: w: \n/tmp/tmpigf7xfd6.swift:73:27:\
    \ error: missing argument labels 'q:w:' in call\n        return will_it_fly(q,\
    \ w)\n                          ^\n                           q: w: \n/tmp/tmpigf7xfd6.swift:7"
  stdout: ''
  timestamp: 1660014317
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 && w > 0 &&\
    \ w <= q.maxElement() else {\n        return false\n    }\n    \n    var sum =\
    \ 0\n    var maxSum = w\n    for element in q {\n        sum += element\n    \
    \    if sum > maxSum {\n            maxSum = sum\n        }\n    }\n    \n   \
    \ return maxSum == w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpuj5103x0.swift:14:42: error: value of type '[Int]' has no member\
    \ 'maxElement'\n    guard q.count > 0 && w > 0 && w <= q.maxElement() else {\n\
    \                                       ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014317
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var max = 0\n    for x in q\
    \ {\n        if x > max {\n            max = x\n        }\n    }\n    if max >\
    \ w {\n        return false\n    }\n    var sum = 0\n    for x in q {\n      \
    \  sum += x\n    }\n    if sum < w {\n        return false\n    }\n    return\
    \ true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpgk4pplz2/tmpgk4pplz2.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba5c922cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba5c8f23b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba5c8f23988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5c8f227b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgk4pplz2                        0x000056103e5ad46f <unavailable> + 5231

    5    libc.so.6                          0x00002ba5c9418460 __libc_start_main +
    245

    6    tmpgk4pplz2                        0x000056103e5ad0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014316
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count == w else { return\
    \ false }\n    var maxSum = w\n    for v in q {\n        if maxSum < v {\n   \
    \         maxSum = v\n        }\n    }\n    return maxSum == w\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp81kfo2ty/tmp81kfo2ty.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8d77909c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8d77600b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8d77600988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8d775ff7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp81kfo2ty                        0x000055945b0854bf <unavailable> + 5311

    5    libc.so.6                          0x00002b8d77af5460 __libc_start_main +
    245

    6    tmp81kfo2ty                        0x000055945b085129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014317
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var max = 0\n    for x in q\
    \ {\n        if x > max {\n            max = x\n        }\n    }\n    if max ==\
    \ 0 {\n        return true\n    }\n    if w == 0 {\n        return false\n   \
    \ }\n    if w == 1 {\n        return true\n    }\n    if w == max {\n        return\
    \ true\n    }\n    if w == max - 1 {\n        return true\n    }\n    if w ==\
    \ max - 2 {\n        return true\n    }\n    if w == max - 3 {\n        return\
    \ true\n    }\n    if w == max - 4 {\n        return true\n    }\n    if w ==\
    \ max - 5 {\n        return true\n    }\n    if w == max - 6 {\n        return\
    \ true\n    }\n    if w == max - 7 {\n        return true\n    }\n    if w ==\
    \ max - 8 {\n        return true\n    }\n    if w == max - 9 {\n        return\
    \ true\n    }\n    if w == max - 10 {\n        return true\n    }\n    if w ==\
    \ max - 11 {\n        return true\n    }\n    if w == max - 12 {\n        return\
    \ true\n    }\n    if w == max - 13 {\n        return true\n    }\n    if w ==\
    \ max - 14 {\n        return true\n    }\n    if w == max - 15 {\n        return\
    \ true\n    }\n    if w == max - 16 {\n        return true\n    }\n    if w ==\
    \ max - 17 {\n        return true\n    }\n    if w == max - 18 {\n        return\
    \ true\n    }\n    if w == max - 19 {\n        return true\n    }\n    if w ==\
    \ max - 20 {\n        return true\n    }\n    if w == max - 21 {\n        return\
    \ true\n    }\n    if w == max - 22 {\n        return true\n    }\n    if w ==\
    \ max - 23 {\n        return true\n    }\n    if w == max - 24 {\n        return\
    \ true\n    }\n    if w == max - 25 {\n        return true\n    }\n    if w ==\
    \ max - 26 {\n        return true\n    }\n    if w == max - 27 {\n        return\
    \ true\n    }\n    if w == max - 28 {\n        return true\n    }\n    if w ==\
    \ max - 29 {\n        return true\n    }\n    if w == max - 30 {\n        return\
    \ true\n    }\n    if w == max - 31 {\n        return true\n    }\n    if w ==\
    \ max - 32 {\n        return true\n    }\n    if w == max - 33 {\n        return\
    \ true\n    }\n    if w == max - 34 {\n        return true\n    }\n    if w ==\
    \ max - 35 {\n        return true\n    }\n    if w == max - 36 {\n        return\
    \ true\n    }\n    if w == max - 37 {\n        return true\n    }\n    if w ==\
    \ max - 38 {\n        return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpycp7bal3.swift:165:42: error: expected '}' at end of brace statement\n\
    assert(will_it_fly(q: [5], w: 5) == true)\n                                  \
    \       ^\n/tmp/tmpycp7bal3.swift:13:44: note: to match this opening '{'\nfunc\
    \ will_it_fly(q: [Int], w: Int) -> Bool {\n                                  \
    \         ^\n/tmp/tmpycp7bal3.swift:148:6: error: operator functions can only\
    \ be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014317
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 && w > 0 &&\
    \ w <= q.max() else { return false }\n    var sum = 0\n    for x in q {\n    \
    \    sum += x\n    }\n    return sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmptov2w3jn.swift:14:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else { return false }\n                                         ^\n\
    /tmp/tmptov2w3jn.swift:14:42: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max()\
    \ else { return false }\n                                         ^\n        \
    \                                       ?? <#default value#>\n/tmp/tmptov2w3jn.swift:14:42:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else { return false }\n\
    \                                         ^\n                                \
    \              !\n"
  stdout: ''
  timestamp: 1660014317
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxSum = w\n    var maxSumIndex\
    \ = 0\n    var maxSumElement = q[0]\n    for index in 1..<q.count {\n        let\
    \ element = q[index]\n        let sum = element + maxSumElement\n        if sum\
    \ > maxSum {\n            maxSum = sum\n            maxSumIndex = index\n    \
    \        maxSumElement = element\n        }\n    }\n    return maxSum == w\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp5np7fryw/tmp5np7fryw.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6adcb01c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6adc7f8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6adc7f8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6adc7f77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5np7fryw                        0x00005574549495fb <unavailable> + 5627

    5    libc.so.6                          0x00002b6adcced460 __libc_start_main +
    245

    6    tmp5np7fryw                        0x00005574549491a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014317
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxSum = w\n    for element\
    \ in q {\n        maxSum -= element\n        if maxSum < 0 {\n            return\
    \ false\n        }\n    }\n    return maxSum == 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpu4rizsuj/tmpu4rizsuj.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae85c14bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae85be42b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae85be42988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae85be417b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu4rizsuj                        0x0000562088e4d46f <unavailable> + 5231

    5    libc.so.6                          0x00002ae85c337460 __libc_start_main +
    245

    6    tmpu4rizsuj                        0x0000562088e4d0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 && w > 0 &&\
    \ w <= q.max() else {\n        return false\n    }\n    \n    var sum = 0\n  \
    \  var max = 0\n    for element in q {\n        sum += element\n        if sum\
    \ > max {\n            max = sum\n        }\n    }\n    \n    return sum == max\
    \ && q == q.sorted().reverse()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpnttav_91.swift:14:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else {\n                                         ^\n/tmp/tmpnttav_91.swift:14:42:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else {\n             \
    \                            ^\n                                             \
    \  ?? <#default value#>\n/tmp/tmpnttav_91.swift:14:42: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    guard q.count\
    \ > 0 && w > 0 && w <= q.max() else {\n                                      \
    \   ^\n                                              !\n/tmp/tmpnttav_91.swift:27:26:\
    \ error: cannot convert value of type '[Int]' to expected argument type '()'\n\
    \    return sum == max && q == q.sorted().reverse()\n                        \
    \ ^\n/tmp/tmpnttav_91.swift:27:42: error: cannot use mutating member on immutable\
    \ value: function call returns immutable value\n    return sum == max && q ==\
    \ q.sorted().reverse()\n                              ~~~~~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660014317
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    let maxWeight = w\n    var maxSum\
    \ = q.reduce(0, +)\n    maxSum = maxSum.max(w)\n    return maxSum == maxWeight\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmphzt5irxd.swift:16:14: error: static member 'max' cannot be used\
    \ on instance of type 'Int'\n    maxSum = maxSum.max(w)\n             ^~~~~~\n\
    \             Int\n/tmp/tmphzt5irxd.swift:16:21: error: cannot call value of non-function\
    \ type 'Int'\n    maxSum = maxSum.max(w)\n                    ^\n"
  stdout: ''
  timestamp: 1660014317
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 && w > 0 &&\
    \ w <= q.max() else {\n        return false\n    }\n    \n    var sum = 0\n  \
    \  for element in q {\n        sum += element\n    }\n    \n    return sum ==\
    \ w && is_balanced(q) && is_palindromic(q)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpa5ehb4gn.swift:14:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else {\n                                         ^\n/tmp/tmpa5ehb4gn.swift:14:42:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else {\n             \
    \                            ^\n                                             \
    \  ?? <#default value#>\n/tmp/tmpa5ehb4gn.swift:14:42: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    guard q.count\
    \ > 0 && w > 0 && w <= q.max() else {\n                                      \
    \   ^\n                                              !\n/tmp/tmpa5ehb4gn.swift:23:24:\
    \ error: cannot find 'is_balanced' in scope\n    return sum == w && is_balanced(q)\
    \ && is_palindromic(q)\n                       ^~~~~~~~~~~\n/tmp/tmpa5ehb4gn.swift:23:42:\
    \ error: cannot find 'is_palindromic' in scope\n    return sum == w && is_balanced(q)\
    \ && is_palindromic(q)\n                                         ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014317
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxSum = w\n    var maxSumIndex\
    \ = 0\n    var maxSumElement = q[0]\n    for index in 1..<q.count {\n        maxSum\
    \ = maxSum - q[index]\n        if maxSum < 0 {\n            return false\n   \
    \     }\n        if maxSum == 0 {\n            if maxSumElement == q[index] {\n\
    \                return true\n            }\n        } else {\n            if\
    \ maxSumElement == q[index] {\n                return false\n            }\n \
    \           if maxSum < maxSum {\n                maxSum = maxSum\n          \
    \      maxSumIndex = index\n                maxSumElement = q[index]\n       \
    \     }\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp4d_0dj9l.swift:31:24: error: assigning a variable to itself\n \
    \               maxSum = maxSum\n                ~~~~~~ ^ ~~~~~~\n/tmp/tmp4d_0dj9l.swift:15:9:\
    \ warning: variable 'maxSumIndex' was written to, but never read\n    var maxSumIndex\
    \ = 0\n        ^\n"
  stdout: ''
  timestamp: 1660014317
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum\
    \ = q.reduce(0) { $0 + $1 }\n    for element in q {\n        if element > maxWeight\
    \ {\n            maxWeight = element\n        }\n        maxSum = maxSum + element\n\
    \    }\n    return maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmptgkzccx4/tmptgkzccx4.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b426935bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4269052b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4269052988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b42690517b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptgkzccx4                        0x000055c8a9bc94df <unavailable> + 5343

    5    libc.so.6                          0x00002b4269547460 __libc_start_main +
    245

    6    tmptgkzccx4                        0x000055c8a9bc9149 <unavailable> + 4425

    '
  stdout: ''
  timestamp: 1660014317
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum\
    \ = 0\n    for i : Int in q.indices {\n        let sum = q[i]\n        if sum\
    \ > maxSum {\n            maxSum = sum\n            maxWeight = w\n        }\n\
    \    }\n    return maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpdjzwxgfi/tmpdjzwxgfi.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3ecb861c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3ecb558b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3ecb558988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3ecb5577b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdjzwxgfi                        0x000055757d5b859b <unavailable> + 5531

    5    libc.so.6                          0x00002b3ecba4d460 __libc_start_main +
    245

    6    tmpdjzwxgfi                        0x000055757d5b8149 <unavailable> + 4425

    '
  stdout: ''
  timestamp: 1660014317
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 && w > 0 &&\
    \ w <= q.max() else { return false }\n    guard let first = q.first else { return\
    \ false }\n    guard let last = q.last else { return false }\n    let sum = q.reduce(0,\
    \ +)\n    return sum == w && q == q.filter({$0 != first}).reversed().filter({$0\
    \ != last})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2,\
    \ 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp86z60s2d.swift:14:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else { return false }\n                                         ^\n\
    /tmp/tmp86z60s2d.swift:14:42: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max()\
    \ else { return false }\n                                         ^\n        \
    \                                       ?? <#default value#>\n/tmp/tmp86z60s2d.swift:14:42:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else { return false }\n\
    \                                         ^\n                                \
    \              !\n"
  stdout: ''
  timestamp: 1660014317
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxWeight = w\n    var balanced\
    \ = true\n    for element in q {\n        if element > maxWeight {\n         \
    \   maxWeight = element\n        }\n        if element != maxWeight {\n      \
    \      balanced = false\n        }\n    }\n    return balanced && maxWeight <=\
    \ w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w:\
    \ 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpi3sq8tuh/tmpi3sq8tuh.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c8e933c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c8e62ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c8e62a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c8e6297b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi3sq8tuh                        0x000056020342646f <unavailable> + 5231

    5    libc.so.6                          0x00002b9c8eb1f460 __libc_start_main +
    245

    6    tmpi3sq8tuh                        0x00005602034260d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014317
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var max = 0\n    var sum = 0\n\
    \    for x in q {\n        sum += x\n        if sum > max {\n            max =\
    \ sum\n        }\n    }\n    if sum == w {\n        return true\n    }\n    if\
    \ sum < w {\n        return false\n    }\n    if max < w {\n        return false\n\
    \    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpjynh0fbg/tmpjynh0fbg.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b005d481c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b005d178b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b005d178988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b005d1777b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjynh0fbg                        0x000056326469946f <unavailable> + 5231

    5    libc.so.6                          0x00002b005d66d460 __libc_start_main +
    245

    6    tmpjynh0fbg                        0x00005632646990d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014318
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum\
    \ = q.reduce(0) { $0 + $1 }\n    for element in q {\n        if element > maxWeight\
    \ {\n            maxWeight = element\n        }\n        maxSum = maxSum + element\n\
    \    }\n    return maxSum == maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpbenejsvt/tmpbenejsvt.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b182c01dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b182bd14b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b182bd14988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b182bd137b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbenejsvt                        0x000055d921ce54df <unavailable> + 5343

    5    libc.so.6                          0x00002b182c209460 __libc_start_main +
    245

    6    tmpbenejsvt                        0x000055d921ce5149 <unavailable> + 4425

    '
  stdout: ''
  timestamp: 1660014317
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    if q.isEmpty {\n        return\
    \ true\n    }\n    if q.isPalindromic {\n        return q.sum() <= w\n    }\n\
    \    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp2f482y53.swift:17:10: error: value of type '[Int]' has no member\
    \ 'isPalindromic'\n    if q.isPalindromic {\n       ~ ^~~~~~~~~~~~~\n/tmp/tmp2f482y53.swift:18:18:\
    \ error: value of type '[Int]' has no member 'sum'\n        return q.sum() <=\
    \ w\n               ~ ^~~\n"
  stdout: ''
  timestamp: 1660014317
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var max = 0\n    for x in q\
    \ {\n        max = max(max, x)\n    }\n    if max <= w {\n        return true\n\
    \    }\n    var sum = 0\n    for x in q {\n        sum += x\n    }\n    if sum\
    \ < w {\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp0iqpqol4.swift:16:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, x)\n              ^\n"
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxSum = w\n    var maxSumIndex\
    \ = 0\n    var maxSumElement = 0\n    var maxSumElementIndex = 0\n    var isBalanced\
    \ = true\n    for index in 0..<q.count {\n        let element = q[index]\n   \
    \     if element > maxSumElement {\n            maxSumElement = element\n    \
    \        maxSumElementIndex = index\n        }\n        if element > maxSum {\n\
    \            maxSum = element\n            maxSumIndex = index\n        }\n  \
    \      if element == maxSum {\n            if index == q.count - 1 {\n       \
    \         isBalanced = false\n            }\n        }\n    }\n    if maxSumIndex\
    \ == q.count - 1 {\n        return isBalanced\n    }\n    if maxSumElement ==\
    \ w {\n        return true\n    }\n    if maxSumElement > w {\n        return\
    \ false\n    }\n    if maxSumElement == maxSum {\n        if maxSumIndex == 0\
    \ {\n            return true\n        }\n        if maxSumIndex == q.count - 1\
    \ {\n            return true\n        }\n        if maxSumIndex == q.count - 2\
    \ {\n            return true\n        }\n    }\n    if maxSumElement == maxSum\
    \ - 1 {\n        if maxSumIndex == 0 {\n            return true\n        }\n \
    \       if maxSumIndex == q.count - 1 {\n            return true\n        }\n\
    \        if maxSumIndex == q.count - 2 {\n            return true\n        }\n\
    \    }\n    if maxSumElement == maxSum + 1 {\n        if maxSumIndex == 0 {\n\
    \            return true\n        }\n        if maxSumIndex == q.count - 1 {\n\
    \            return true\n        }\n        if maxSumIndex == q.count - 2 {\n\
    \            return true\n        }\n    }\n    if maxSumElement == maxSum - 2\
    \ {\n        if maxSumIndex == 0 {\n            return true\n        }\n     \
    \   if maxSumIndex == q.count - 1 {\n            return true\n        }\n    \
    \    if maxSumIndex == q.count - 2 {\n            return true\n        }\n   \
    \ }\n    if maxSumElement == maxSum + 2 {\n        if maxSumIndex == 0 {\n   \
    \         return true\n        }\n        if maxSumIndex == q.count - 1 {\n  \
    \          return true\n        }\n        if maxSumIndex == q.count - 2 {\n \
    \           return true\n        }\n    }\n    if maxSumElement == maxSum - 3\
    \ {\n        if maxSumIndex == 0 {\n            return true\n        }\n     \
    \   if maxSumIndex == q.count - 1 {\n            return true\n        }\n    \
    \    if maxSumIndex == q.count - 2 {\n            return true\n        }\n   \
    \ }\n    if maxSumElement == maxSum + 3 {\n        if maxSumIndex == 0 {\n   \
    \         return true\n        }\n        if maxSumIndex == q.count - 1 {\n  \
    \          return \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpem4fijtu.swift:136:42: error: expected '}' at end of brace statement\n\
    assert(will_it_fly(q: [5], w: 5) == true)\n                                  \
    \       ^\n/tmp/tmpem4fijtu.swift:110:36: note: to match this opening '{'\n  \
    \  if maxSumElement == maxSum + 3 {\n                                   ^\n/tmp/tmpem4fijtu.swift:136:42:\
    \ error: expected '}' at end of brace statement\nassert(will_it_fly(q: [5], w:\
    \ 5) == true)\n                                         ^\n/tmp/tmpem4fijtu.swift:13:44:\
    \ note: to match this opening '{'\nfunc will_it_fly(q: [Int], w: Int) -> Bool\
    \ {\n                                           ^\n/tmp/tmpem4fijtu.swift:115:13:\
    \ error: non-void function should return a value\n            return \n      \
    \      ^\n/tmp/tmpem4fijtu.swift:119:6: error: operator functions can only be\
    \ declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n/tmp/tmpem4fijtu.swift:17:9: warning: variable 'maxSumElementIndex'\
    \ was written to, but never read\n    var maxSumElementIndex = 0\n        ^\n"
  stdout: ''
  timestamp: 1660014317
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count == w else { return\
    \ false }\n    guard let first = q.first else { return false }\n    guard let\
    \ last = q.last else { return false }\n    guard first == last else { return false\
    \ }\n    guard let first = q.first,\n        let last = q.last,\n        first\
    \ == last else { return false }\n    guard let first = q.first,\n        let last\
    \ = q.last,\n        first != last else { return false }\n    guard let first\
    \ = q.first,\n        let last = q.last,\n        first == last else { return\
    \ false }\n    guard let first = q.first,\n        let last = q.last,\n      \
    \  first != last else { return false }\n    guard let first = q.first,\n     \
    \   let last = q.last,\n        first == last else { return false }\n    guard\
    \ let first = q.first,\n        let last = q.last,\n        first != last else\
    \ { return false }\n    guard let first = q.first,\n        let last = q.last,\n\
    \        first == last else { return false }\n    guard let first = q.first,\n\
    \        let last = q.last,\n        first != last else { return false }\n   \
    \ guard let first = q.first,\n        let last = q.last,\n        first == last\
    \ else { return false }\n    guard let first = q.first,\n        let last = q.last,\n\
    \        first != last else { return false }\n    guard let first = q.first,\n\
    \        let last = q.last,\n        first == last else { return false }\n   \
    \ guard let first = q.first,\n        let last = q.last,\n        first != last\
    \ else { return false }\n    guard let first = q.first,\n        let last = q.last,\n\
    \        first == last else { return false }\n    guard let first = q.first,\n\
    \        let last = q.last,\n        first != last else { return false }\n   \
    \ guard let first = q.first,\n        let last = q.last,\n        first == last\
    \ else { return false }\n    guard let first = q.first,\n        let last = q.last,\n\
    \        first != last else { return false }\n    guard let first = q.first,\n\
    \        let last = q.last,\n        first == last else { return false }\n   \
    \ guard let first = q.first,\n        let last = q.last,\n        first != last\
    \ else { return false }\n    guard let first = q.first,\n        let last = q.last,\n\
    \        first == last else { return false }\n    guard let first = q.first,\n\
    \        let \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpm4nm_wyd.swift:76:12: error: expected pattern\n        let \n \
    \          ^\n/tmp/tmpm4nm_wyd.swift:76:9: error: unwrap condition requires a\
    \ valid identifier\n        let \n        ^\n        <#identifier#> = \n/tmp/tmpm4nm_wyd.swift:76:12:\
    \ error: expected 'else' after 'guard' condition\n        let \n           ^\n"
  stdout: ''
  timestamp: 1660014317
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 && w > 0 &&\
    \ w <= q.max() else {\n        return false\n    }\n    guard let first = q.first\
    \ else {\n        return true\n    }\n    let last = q.last\n    let mid = q.count\
    \ / 2\n    var leftSum = w\n    var rightSum = w\n    var leftMax = w\n    var\
    \ rightMax = w\n    var leftMaxIndex = -1\n    var rightMaxIndex = -1\n    for\
    \ i in 0..<mid {\n        leftSum += q[i]\n        if leftSum > leftMax {\n  \
    \          leftMax = leftSum\n            leftMaxIndex = i\n        }\n      \
    \  rightSum += q[mid+i]\n        if rightSum > rightMax {\n            rightMax\
    \ = rightSum\n            rightMaxIndex = mid+i\n        }\n    }\n    if leftMaxIndex\
    \ == -1 || rightMaxIndex == -1 {\n        return false\n    }\n    if leftMaxIndex\
    \ != rightMaxIndex {\n        return false\n    }\n    if leftMaxIndex == 0 {\n\
    \        return true\n    }\n    if rightMaxIndex == mid {\n        return true\n\
    \    }\n    return will_it_fly(q[leftMaxIndex..<rightMaxIndex], w)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp1fxqnh9u.swift:14:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else {\n                                         ^\n/tmp/tmp1fxqnh9u.swift:14:42:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else {\n             \
    \                            ^\n                                             \
    \  ?? <#default value#>\n/tmp/tmp1fxqnh9u.swift:14:42: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    guard q.count\
    \ > 0 && w > 0 && w <= q.max() else {\n                                      \
    \   ^\n                                              !\n/tmp/tmp1fxqnh9u.swift:52:23:\
    \ error: missing argument labels 'q:w:' in call\n    return will_it_fly(q[leftMaxIndex..<rightMaxIndex],\
    \ w)\n                      ^\n                       q:                     \
    \          w: \n/tmp/tmp1fxqnh9u.swift:52:25: error: cannot convert value of type\
    \ 'ArraySlice<Int>' to expected argument type '[Int]'\n    return will_it_fly(q[leftMaxIndex..<rightMaxIndex],\
    \ w)\n                        ^\n"
  stdout: ''
  timestamp: 1660014318
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxSum = w\n    for element\
    \ in q {\n        maxSum -= element\n        if maxSum < 0 {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpx307ezpn/tmpx307ezpn.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b74389bac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b74386b1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b74386b1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b74386b07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx307ezpn                        0x0000559246c9652b <unavailable> + 5419

    5    libc.so.6                          0x00002b7438ba6460 __libc_start_main +
    245

    6    tmpx307ezpn                        0x0000559246c960d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxSum = w\n    for element\
    \ in q {\n        if element > maxSum {\n            maxSum = element\n      \
    \  }\n    }\n    return is_balanced(q, maxSum)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpwttfz579.swift:20:12: error: cannot find 'is_balanced' in scope\n\
    \    return is_balanced(q, maxSum)\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014317
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 && w > 0 &&\
    \ w <= q.max() else { return false }\n    var sum = 0\n    for x in q {\n    \
    \    sum += x\n    }\n    return sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmptov2w3jn.swift:14:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else { return false }\n                                         ^\n\
    /tmp/tmptov2w3jn.swift:14:42: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max()\
    \ else { return false }\n                                         ^\n        \
    \                                       ?? <#default value#>\n/tmp/tmptov2w3jn.swift:14:42:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else { return false }\n\
    \                                         ^\n                                \
    \              !\n"
  stdout: ''
  timestamp: 1660014317
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxWeight = w\n    var balanced\
    \ = true\n    var sum = 0\n    for element in q {\n        sum += element\n  \
    \      if sum > maxWeight {\n            balanced = false\n            maxWeight\
    \ = sum\n        }\n    }\n    return balanced && sum <= maxWeight\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpjholt97o/tmpjholt97o.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b677f483c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b677f17ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b677f17a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b677f1797b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjholt97o                        0x000055e691c7f52b <unavailable> + 5419

    5    libc.so.6                          0x00002b677f66f460 __libc_start_main +
    245

    6    tmpjholt97o                        0x000055e691c7f0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014318
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum\
    \ = q.reduce(0) { $0 + $1 }\n    for element in q {\n        if element > maxWeight\
    \ {\n            maxWeight = element\n        }\n        maxSum = maxSum + element\n\
    \    }\n    return maxWeight <= w && maxSum == w\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpyi5sw5ts/tmpyi5sw5ts.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b90b0f75c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b90b0c6cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b90b0c6c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b90b0c6b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyi5sw5ts                        0x000055e9c50614df <unavailable> + 5343

    5    libc.so.6                          0x00002b90b1161460 __libc_start_main +
    245

    6    tmpyi5sw5ts                        0x000055e9c5061149 <unavailable> + 4425

    '
  stdout: ''
  timestamp: 1660014316
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxSum = w\n    for element\
    \ in q {\n        maxSum = maxSum - element\n        if maxSum < 0 {\n       \
    \     return false\n        }\n    }\n    return maxSum == 0 || maxSum == w\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpze9ba4o9/tmpze9ba4o9.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2f9b728c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2f9b41fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2f9b41f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2f9b41e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpze9ba4o9                        0x000056362a5f746f <unavailable> + 5231

    5    libc.so.6                          0x00002b2f9b914460 __libc_start_main +
    245

    6    tmpze9ba4o9                        0x000056362a5f70d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014318
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count == w else { return\
    \ false }\n    guard let first = q.first else { return false }\n    guard let\
    \ last = q.last else { return false }\n    guard let first = q.first else { return\
    \ false }\n    guard let last = q.last else { return false }\n    guard let first\
    \ = q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return \n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpm09masdy.swift:77:42: error: expected '}' at end of brace statement\n\
    assert(will_it_fly(q: [5], w: 5) == true)\n                                  \
    \       ^\n/tmp/tmpm09masdy.swift:13:44: note: to match this opening '{'\nfunc\
    \ will_it_fly(q: [Int], w: Int) -> Bool {\n                                  \
    \         ^\n/tmp/tmpm09masdy.swift:56:36: error: non-void function should return\
    \ a value\n    guard let last = q.last else { return \n                      \
    \             ^\n/tmp/tmpm09masdy.swift:60:6: error: operator functions can only\
    \ be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n/tmp/tmpm09masdy.swift:15:15: warning: value 'first'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let first = q.first else { return false }\n          ~~~~^~~~~~~~\n        \
    \                      != nil\n/tmp/tmpm09masdy.swift:16:15: warning: value 'last'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let last = q.last else { return false }\n          ~~~~^~~~~~~\n           \
    \                 != nil\n/tmp/tmpm09masdy.swift:17:15: warning: value 'first'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let first = q.first else { return false }\n          ~~~~^~~~~~~~\n        \
    \                      != nil\n/tmp/tmpm09masdy.swift:18:15: warning: value 'last'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let last = q.last else { return false }\n          ~~~~^~~~~~~\n           \
    \                 != nil\n/tmp/tmpm09masdy.swift:19:15: warning: value 'first'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let first = q.first else { return false }\n          ~~~~^~~~~~~~\n        \
    \                      != nil\n/tmp/tmpm09masdy.swift:20:15: warning: value 'last'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let last = q.last else { return false }\n          ~~~~^~~~~~~\n           \
    \                 != nil\n/tmp/tmpm09masdy.swift:21:15: warning: value 'f"
  stdout: ''
  timestamp: 1660014316
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count == w else {\n\
    \        return false\n    }\n    \n    let maxWeight = w\n    var maxSum = q.reduce(0)\
    \ { $0 + $1 }\n    \n    for element in q {\n        if element > maxSum {\n \
    \           maxSum = element\n        }\n    }\n    \n    return maxSum == maxWeight\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpwbifqiqn/tmpwbifqiqn.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6bdbcbfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6bdb9b6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6bdb9b6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6bdb9b57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwbifqiqn                        0x000056102870253f <unavailable> + 5439

    5    libc.so.6                          0x00002b6bdbeab460 __libc_start_main +
    245

    6    tmpwbifqiqn                        0x00005610287021a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014318
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 && w > 0 &&\
    \ w <= q.max() else { return false }\n    var sum = 0\n    for i in q {\n    \
    \    sum += i\n    }\n    return sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp5voog058.swift:14:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else { return false }\n                                         ^\n\
    /tmp/tmp5voog058.swift:14:42: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max()\
    \ else { return false }\n                                         ^\n        \
    \                                       ?? <#default value#>\n/tmp/tmp5voog058.swift:14:42:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else { return false }\n\
    \                                         ^\n                                \
    \              !\n"
  stdout: ''
  timestamp: 1660014317
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var max = 0\n    for x in q\
    \ {\n        max = max(max, x)\n    }\n    if max < w {\n        return false\n\
    \    }\n    var sum = 0\n    for x in q {\n        sum += x\n    }\n    if sum\
    \ < w {\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpvd9tog0l.swift:16:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, x)\n              ^\n"
  stdout: ''
  timestamp: 1660014317
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 && w > 0 &&\
    \ w <= q.max() else {\n        return false\n    }\n    let s = q.sum()\n    return\
    \ s == w && s == q.max() - w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp5qy88oh_.swift:14:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else {\n                                         ^\n/tmp/tmp5qy88oh_.swift:14:42:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else {\n             \
    \                            ^\n                                             \
    \  ?? <#default value#>\n/tmp/tmp5qy88oh_.swift:14:42: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    guard q.count\
    \ > 0 && w > 0 && w <= q.max() else {\n                                      \
    \   ^\n                                              !\n/tmp/tmp5qy88oh_.swift:17:15:\
    \ error: value of type '[Int]' has no member 'sum'\n    let s = q.sum()\n    \
    \        ~ ^~~\n/tmp/tmp5qy88oh_.swift:18:29: error: value of optional type 'Int?'\
    \ must be unwrapped to a value of type 'Int'\n    return s == w && s == q.max()\
    \ - w\n                            ^\n/tmp/tmp5qy88oh_.swift:18:29: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \ return s == w && s == q.max() - w\n                            ^\n         \
    \                 (       ?? <#default value#>)\n/tmp/tmp5qy88oh_.swift:18:29:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    return s == w && s == q.max() - w\n                            ^\n\
    \                                 !\n"
  stdout: ''
  timestamp: 1660014318
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 && w > 0 &&\
    \ w <= q.max() else {\n        return false\n    }\n    var sum = 0\n    for i\
    \ in q {\n        sum += i\n    }\n    return sum <= w\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpiowkmvqw.swift:14:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else {\n                                         ^\n/tmp/tmpiowkmvqw.swift:14:42:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else {\n             \
    \                            ^\n                                             \
    \  ?? <#default value#>\n/tmp/tmpiowkmvqw.swift:14:42: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    guard q.count\
    \ > 0 && w > 0 && w <= q.max() else {\n                                      \
    \   ^\n                                              !\n"
  stdout: ''
  timestamp: 1660014317
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum\
    \ = 0\n    for element in q {\n        maxSum += element\n        if maxSum >\
    \ maxWeight {\n            maxSum = maxWeight\n            maxWeight = w\n   \
    \     }\n    }\n    return maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp9r98vzb_/tmp9r98vzb_.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f64dd1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f64ac8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0f64ac8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0f64ac77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9r98vzb_                        0x0000563b5c54252b <unavailable> + 5419

    5    libc.so.6                          0x00002b0f64fbd460 __libc_start_main +
    245

    6    tmp9r98vzb_                        0x0000563b5c5420d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014318
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxSum = w\n    var maxSumIndex\
    \ = 0\n    var maxSumElement = q[0]\n    for i := 1; i < len(q); i++ {\n     \
    \   maxSum += q[i]\n        if maxSum > w {\n            return false\n      \
    \  }\n        if maxSum > maxSumElement {\n            maxSumElement = maxSum\n\
    \            maxSumIndex = i\n        }\n    }\n    return maxSumElement == q[maxSumIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpu_a_k4vk.swift:17:12: error: expected type\n    for i := 1; i <\
    \ len(q); i++ {\n           ^\n            <#type#>\n/tmp/tmpu_a_k4vk.swift:17:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 1; i < len(q); i++\
    \ {\n           ^\n/tmp/tmpu_a_k4vk.swift:17:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 1; i < len(q); i++ {\n           ^\n"
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count == w else { return\
    \ false }\n    guard let a = q.first else { return false }\n    guard let b =\
    \ q.last else { return false }\n    guard a < b else { return false }\n    guard\
    \ let c = q.first + q.last else { return false }\n    guard c <= w else { return\
    \ false }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp5gw5wa49.swift:18:27: error: binary operator '+' cannot be applied\
    \ to two 'Int?' operands\n    guard let c = q.first + q.last else { return false\
    \ }\n                  ~~~~~~~ ^ ~~~~~~\n/tmp/tmp5gw5wa49.swift:18:27: note: overloads\
    \ for '+' exist with these partially matching parameter lists: (Int, Int)\n  \
    \  guard let c = q.first + q.last else { return false }\n                    \
    \      ^\n"
  stdout: ''
  timestamp: 1660014318
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxSum = w\n    var maxSumIndex\
    \ = 0\n    var maxSumValue = 0\n    for i := 0; i < len(q); i++ {\n        if\
    \ q[i] > maxSumValue {\n            maxSumValue = q[i]\n            maxSumIndex\
    \ = i\n        }\n    }\n    if maxSumValue > w {\n        return false\n    }\n\
    \    for i := 0; i < len(q); i++ {\n        if q[i] > maxSumValue {\n        \
    \    maxSumValue = q[i]\n            maxSumIndex = i\n        }\n    }\n    if\
    \ maxSumValue > w {\n        return false\n    }\n    for i := 0; i < len(q);\
    \ i++ {\n        if q[i] > maxSumValue {\n            maxSumValue = q[i]\n   \
    \         maxSumIndex = i\n        }\n    }\n    if maxSumValue > w {\n      \
    \  return false\n    }\n    for i := 0; i < len(q); i++ {\n        if q[i] > maxSumValue\
    \ {\n            maxSumValue = q[i]\n            maxSumIndex = i\n        }\n\
    \    }\n    if maxSumValue > w {\n        return false\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmped6yi6sj.swift:17:12: error: expected type\n    for i := 0; i <\
    \ len(q); i++ {\n           ^\n            <#type#>\n/tmp/tmped6yi6sj.swift:17:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(q); i++\
    \ {\n           ^\n/tmp/tmped6yi6sj.swift:17:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(q); i++ {\n           ^\n/tmp/tmped6yi6sj.swift:26:12:\
    \ error: expected type\n    for i := 0; i < len(q); i++ {\n           ^\n    \
    \        <#type#>\n/tmp/tmped6yi6sj.swift:26:12: error: expected 'in' after for-each\
    \ pattern\n    for i := 0; i < len(q); i++ {\n           ^\n/tmp/tmped6yi6sj.swift:26:12:\
    \ error: expected Sequence expression for for-each loop\n    for i := 0; i < len(q);\
    \ i++ {\n           ^\n/tmp/tmped6yi6sj.swift:35:12: error: expected type\n  \
    \  for i := 0; i < len(q); i++ {\n           ^\n            <#type#>\n/tmp/tmped6yi6sj.swift:35:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(q); i++\
    \ {\n           ^\n/tmp/tmped6yi6sj.swift:35:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(q); i++ {\n           ^\n/tmp/tmped6yi6sj.swift:44:12:\
    \ error: expected type\n    for i := 0; i < len(q); i++ {\n           ^\n    \
    \        <#type#>\n/tmp/tmped6yi6sj.swift:44:12: error: expected 'in' after for-each\
    \ pattern\n    for i := 0; i < len(q); i++ {\n           ^\n/tmp/tmped6yi6sj.swift:44:12:\
    \ error: expected Sequence expression for for-each loop\n    for i := 0; i < len(q);\
    \ i++ {\n           ^\n"
  stdout: ''
  timestamp: 1660014318
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum\
    \ = q[0]\n    for element in q {\n        if element > maxWeight {\n         \
    \   maxWeight = element\n        }\n        maxSum += element\n    }\n    if maxWeight\
    \ > w {\n        return false\n    }\n    if maxSum < w {\n        return true\n\
    \    }\n    return will_it_fly(q, maxWeight)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp0fnhrn5p.swift:28:23: error: missing argument labels 'q:w:' in\
    \ call\n    return will_it_fly(q, maxWeight)\n                      ^\n      \
    \                 q: w: \n"
  stdout: ''
  timestamp: 1660014318
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var max = 0\n    var sum = 0\n\
    \    for x in q {\n        sum += x\n        if sum > max {\n            max =\
    \ sum\n        }\n    }\n    if max <= w {\n        return true\n    }\n    if\
    \ max > w {\n        return false\n    }\n    var reversed = q\n    for x in reversed{\n\
    \        reversed.removeAtIndex(q.startIndex)\n    }\n    return will_it_fly(reversed,\
    \ w)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w:\
    \ 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpx5zcy1xg.swift:30:18: error: value of type '[Int]' has no member\
    \ 'removeAtIndex'\n        reversed.removeAtIndex(q.startIndex)\n        ~~~~~~~~\
    \ ^~~~~~~~~~~~~\n/tmp/tmpx5zcy1xg.swift:32:23: error: missing argument labels\
    \ 'q:w:' in call\n    return will_it_fly(reversed, w)\n                      ^\n\
    \                       q:        w: \n"
  stdout: ''
  timestamp: 1660014318
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var max = 0\n    for x in q\
    \ {\n        if x > max {\n            max = x\n        }\n    }\n    if w ==\
    \ max {\n        return true\n    }\n    if w > max {\n        return false\n\
    \    }\n    var sum = 0\n    for x in q {\n        sum += x\n    }\n    if sum\
    \ < w {\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpt3_8hzjg/tmpt3_8hzjg.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b95f971ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b95f9415b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b95f9415988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b95f94147b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt3_8hzjg                        0x0000561f75f5146f <unavailable> + 5231

    5    libc.so.6                          0x00002b95f990a460 __libc_start_main +
    245

    6    tmpt3_8hzjg                        0x0000561f75f510d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014318
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxSum = w\n    var maxSumIndex\
    \ = 0\n    var maxSumElement = q[0]\n    for index in 1..<q.count {\n        let\
    \ element = q[index]\n        if element > maxSumElement {\n            maxSumElement\
    \ = element\n            maxSumIndex = index\n        }\n        maxSum = maxSum\
    \ + element\n    }\n    return maxSum == w && maxSumElement == q[maxSumIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp02g4gxgh/tmp02g4gxgh.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4da4e8cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4da4b83b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4da4b83988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4da4b827b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp02g4gxgh                        0x0000564e6859c53f <unavailable> + 5439

    5    libc.so.6                          0x00002b4da5078460 __libc_start_main +
    245

    6    tmp02g4gxgh                        0x0000564e6859c1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014318
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 && w > 0 &&\
    \ w <= q.max() else {\n        return false\n    }\n    var sum = 0\n    for element\
    \ in q {\n        sum += element\n    }\n    return sum <= w\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp3w4ug_ep.swift:14:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else {\n                                         ^\n/tmp/tmp3w4ug_ep.swift:14:42:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else {\n             \
    \                            ^\n                                             \
    \  ?? <#default value#>\n/tmp/tmp3w4ug_ep.swift:14:42: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    guard q.count\
    \ > 0 && w > 0 && w <= q.max() else {\n                                      \
    \   ^\n                                              !\n"
  stdout: ''
  timestamp: 1660014318
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum\
    \ = 0\n    for element in q {\n        maxWeight -= element\n        maxSum +=\
    \ element\n    }\n    if maxWeight < 0 {\n        return false\n    }\n    if\
    \ maxSum < 0 {\n        return true\n    }\n    return maxSum == w\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpfx73uzp6/tmpfx73uzp6.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad40301dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad402d14b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad402d14988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad402d137b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfx73uzp6                        0x00005613b92e046f <unavailable> + 5231

    5    libc.so.6                          0x00002ad403209460 __libc_start_main +
    245

    6    tmpfx73uzp6                        0x00005613b92e00d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014318
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count == w, q.count\
    \ > 0 else {\n        return false\n    }\n    var max = 0\n    var sum = 0\n\
    \    for x in q {\n        sum += x\n        if sum > max {\n            max =\
    \ sum\n        }\n    }\n    return sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpbtz2l5jq/tmpbtz2l5jq.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7ef19d9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7ef16d0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7ef16d0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7ef16cf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbtz2l5jq                        0x0000557eac16f4bf <unavailable> + 5311

    5    libc.so.6                          0x00002b7ef1bc5460 __libc_start_main +
    245

    6    tmpbtz2l5jq                        0x0000557eac16f129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014318
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count == w.count else\
    \ { return false }\n    guard q.count == 0 || q.count == 1 || q.count == w.count\
    \ / 2 else { return false }\n    guard let i = q.index(of: q[0]) else {\n    \
    \    return false\n    }\n    var maxSum = w\n    var maxSumIndex = 0\n    var\
    \ maxSumIndex2 = 0\n    var maxSumIndex3 = 0\n    var maxSumIndex4 = 0\n    var\
    \ maxSumIndex5 = 0\n    var maxSumIndex6 = 0\n    var maxSumIndex7 = 0\n    var\
    \ maxSumIndex8 = 0\n    var maxSumIndex9 = 0\n    var maxSumIndex10 = 0\n    var\
    \ maxSumIndex11 = 0\n    var maxSumIndex12 = 0\n    var maxSumIndex13 = 0\n  \
    \  var maxSumIndex14 = 0\n    var maxSumIndex15 = 0\n    var maxSumIndex16 = 0\n\
    \    var maxSumIndex17 = 0\n    var maxSumIndex18 = 0\n    var maxSumIndex19 =\
    \ 0\n    var maxSumIndex20 = 0\n    var maxSumIndex21 = 0\n    var maxSumIndex22\
    \ = 0\n    var maxSumIndex23 = 0\n    var maxSumIndex24 = 0\n    var maxSumIndex25\
    \ = 0\n    var maxSumIndex26 = 0\n    var maxSumIndex27 = 0\n    var maxSumIndex28\
    \ = 0\n    var maxSumIndex29 = 0\n    var maxSumIndex30 = 0\n    var maxSumIndex31\
    \ = 0\n    var maxSumIndex32 = 0\n    var maxSumIndex33 = 0\n    var maxSumIndex34\
    \ = 0\n    var maxSumIndex35 = 0\n    var maxSumIndex36 = 0\n    var maxSumIndex37\
    \ = 0\n    var maxSumIndex38 = 0\n    var maxSumIndex39 = 0\n    var maxSumIndex40\
    \ = 0\n    var maxSumIndex41 = 0\n    var maxSumIndex42 = 0\n    var maxSumIndex43\
    \ = 0\n    var maxSumIndex44 = 0\n    var maxSumIndex45 = 0\n    var maxSumIndex46\
    \ = 0\n    var maxSumIndex47 = 0\n    var maxSumIndex48 = 0\n    var maxSumIndex49\
    \ = 0\n    var maxSumIndex50 = 0\n    var maxSumIndex51 = 0\n    var maxSumIndex52\
    \ = 0\n    var maxSumIndex53 = 0\n    var maxSumIndex54 = 0\n    var maxSumIndex55\
    \ = 0\n    var maxSumIndex56 = 0\n    var maxSumIndex57 = 0\n    var maxSumIndex58\
    \ = 0\n    var maxSumIndex59 = 0\n    var maxSumIndex60 = 0\n    var maxSumIndex61\
    \ = 0\n    var maxSumIndex62 = 0\n    var maxSumIndex63 = 0\n    var maxSumIndex64\
    \ = 0\n    var maxSumIndex65 = 0\n    var max\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpsc3md507.swift:14:24: error: value of type 'Int' has no member\
    \ 'count'\n    guard q.count == w.count else { return false }\n              \
    \       ~ ^~~~~\n/tmp/tmpsc3md507.swift:15:56: error: value of type 'Int' has\
    \ no member 'count'\n    guard q.count == 0 || q.count == 1 || q.count == w.count\
    \ / 2 else { return false }\n                                                \
    \     ~ ^~~~~\n/tmp/tmpsc3md507.swift:16:21: warning: 'index(of:)' is deprecated:\
    \ renamed to 'firstIndex(of:)'\n    guard let i = q.index(of: q[0]) else {\n \
    \                   ^\n/tmp/tmpsc3md507.swift:16:21: note: use 'firstIndex(of:)'\
    \ instead\n    guard let i = q.index(of: q[0]) else {\n                    ^~~~~\n\
    \                    firstIndex\n/tmp/tmpsc3md507.swift:85:9: error: type annotation\
    \ missing in pattern\n    var max\n        ^\n"
  stdout: ''
  timestamp: 1660014318
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count == w.count &&\
    \ q.count == q.max() else { return false }\n    let maxWeight = q.max()\n    let\
    \ sumOfElements = q.map({ $0 + $1 }).reduce(0) { $0 + $1 }\n    return sumOfElements\
    \ <= maxWeight && isPalindromic(q)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpimnofn5o.swift:14:24: error: value of type 'Int' has no member\
    \ 'count'\n    guard q.count == w.count && q.count == q.max() else { return false\
    \ }\n                     ~ ^~~~~\n/tmp/tmpimnofn5o.swift:16:31: error: contextual\
    \ closure type '(Int) throws -> Int' expects 1 argument, but 2 were used in closure\
    \ body\n    let sumOfElements = q.map({ $0 + $1 }).reduce(0) { $0 + $1 }\n   \
    \                           ^\n/tmp/tmpimnofn5o.swift:17:42: error: cannot find\
    \ 'isPalindromic' in scope\n    return sumOfElements <= maxWeight && isPalindromic(q)\n\
    \                                         ^~~~~~~~~~~~~\n/tmp/tmpimnofn5o.swift:17:29:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \    return sumOfElements <= maxWeight && isPalindromic(q)\n                 \
    \           ^\n/tmp/tmpimnofn5o.swift:15:9: note: short-circuit using 'guard'\
    \ to exit this function early if the optional value contains 'nil'\n    let maxWeight\
    \ = q.max()\n        ^\n    guard                   else { return <#default value#>\
    \ }\n/tmp/tmpimnofn5o.swift:15:23: note: coalesce using '??' to provide a default\
    \ when the optional value contains 'nil'\n    let maxWeight = q.max()\n      \
    \                ^\n                            ?? <#default value#>\n/tmp/tmpimnofn5o.swift:15:23:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    let maxWeight = q.max()\n                      ^\n              \
    \             !\n/tmp/tmpimnofn5o.swift:17:29: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n    return sumOfElements <=\
    \ maxWeight && isPalindromic(q)\n                            ^\n             \
    \                         ?? <#default value#>\n/tmp/tmpimnofn5o.swift:17:29:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    return sumOfElements <= maxWeight && isPalindromic(q)\n         \
    \                   ^\n                                     !\n"
  stdout: ''
  timestamp: 1660014318
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum\
    \ = q.reduce(0, +)\n    for element in q {\n        if element > maxWeight {\n\
    \            maxWeight = element\n        }\n    }\n    for element in q {\n \
    \       if element > maxSum {\n            maxSum = element\n        }\n    }\n\
    \    return maxWeight <= maxSum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp9yza7l1n/tmp9yza7l1n.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0fe021dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0fdff14b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0fdff14988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0fdff137b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9yza7l1n                        0x000055fe3cf404df <unavailable> + 5343

    5    libc.so.6                          0x00002b0fe0409460 __libc_start_main +
    245

    6    tmp9yza7l1n                        0x000055fe3cf40149 <unavailable> + 4425

    '
  stdout: ''
  timestamp: 1660014318
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    if q.count == 0 || w == 0 {\n\
    \        return true\n    }\n    \n    var maxSum = w\n    var maxSumIndex = 0\n\
    \    \n    for i in  stride(from: q.count - 1, through: 0, by: -1) {\n       \
    \ let sum = q[i] + q[i+1]\n        if sum > maxSum {\n            maxSum = sum\n\
    \            maxSumIndex = i\n        }\n    }\n    \n    return maxSum == w &&\
    \ maxSumIndex == q.count - 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b2b672afc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2b66fa6561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b2b66fa6286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b2b66fa613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b2b66fa5bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b2b66da5e83 <unavailable> + 188035

    6    tmpdrhlhta3                        0x00005628fbb2bc66 <unavailable> + 7270

    7    tmpdrhlhta3                        0x00005628fbb2b56a <unavailable> + 5482

    8    libc.so.6                          0x00002b2b6749b460 __libc_start_main +
    245

    9    tmpdrhlhta3                        0x00005628fbb2b249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660014318
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 && w > 0 &&\
    \ w <= q.max() else { return false }\n    var sum = 0\n    for i in q {\n    \
    \    sum += i\n    }\n    return sum == w && q == q.sort()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpklydiuqi.swift:14:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else { return false }\n                                         ^\n\
    /tmp/tmpklydiuqi.swift:14:42: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max()\
    \ else { return false }\n                                         ^\n        \
    \                                       ?? <#default value#>\n/tmp/tmpklydiuqi.swift:14:42:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else { return false }\n\
    \                                         ^\n                                \
    \              !\n/tmp/tmpklydiuqi.swift:19:24: error: cannot convert value of\
    \ type '[Int]' to expected argument type '()'\n    return sum == w && q == q.sort()\n\
    \                       ^\n/tmp/tmpklydiuqi.swift:19:31: error: cannot use mutating\
    \ member on immutable value: 'q' is a 'let' constant\n    return sum == w && q\
    \ == q.sort()\n                            ~ ^\n"
  stdout: ''
  timestamp: 1660014318
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum\
    \ = q.reduce(0, +)\n    for element in q {\n        if element > maxWeight {\n\
    \            maxWeight = element\n        }\n    }\n    for element in q {\n \
    \       if element > maxSum {\n            maxSum = element\n        }\n    }\n\
    \    return maxWeight <= maxSum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp9yza7l1n/tmp9yza7l1n.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0fe021dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0fdff14b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0fdff14988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0fdff137b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9yza7l1n                        0x000055fe3cf404df <unavailable> + 5343

    5    libc.so.6                          0x00002b0fe0409460 __libc_start_main +
    245

    6    tmp9yza7l1n                        0x000055fe3cf40149 <unavailable> + 4425

    '
  stdout: ''
  timestamp: 1660014318
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count > 0 && w > 0 &&\
    \ w <= q.max() else { return false }\n    guard let first = q.first else { return\
    \ false }\n    guard let last = q.last else { return false }\n    guard let mid\
    \ = q.mid(at: 0) else { return false }\n    guard let mid2 = q.mid(at: 1) else\
    \ { return false }\n    guard let mid3 = q.mid(at: 2) else { return false }\n\
    \    guard let mid4 = q.mid(at: 3) else { return false }\n    guard let mid5 =\
    \ q.mid(at: 4) else { return false }\n    guard let mid6 = q.mid(at: 5) else {\
    \ return false }\n    guard let mid7 = q.mid(at: 6) else { return false }\n  \
    \  guard let mid8 = q.mid(at: 7) else { return false }\n    guard let mid9 = q.mid(at:\
    \ 8) else { return false }\n    guard let mid10 = q.mid(at: 9) else { return false\
    \ }\n    guard let mid11 = q.mid(at: 10) else { return false }\n    guard let\
    \ mid12 = q.mid(at: 11) else { return false }\n    guard let mid13 = q.mid(at:\
    \ 12) else { return false }\n    guard let mid14 = q.mid(at: 13) else { return\
    \ false }\n    guard let mid15 = q.mid(at: 14) else { return false }\n    guard\
    \ let mid16 = q.mid(at: 15) else { return false }\n    guard let mid17 = q.mid(at:\
    \ 16) else { return false }\n    guard let mid18 = q.mid(at: 17) else { return\
    \ false }\n    guard let mid19 = q.mid(at: 18) else { return false }\n    guard\
    \ let mid20 = q.mid(at: 19) else { return false }\n    guard let mid21 = q.mid(at:\
    \ 20) else { return false }\n    guard let mid22 = q.mid(at: 21) else { return\
    \ false }\n    guard let mid23 = q.mid(at: 22) else { return false }\n    guard\
    \ let mid24 = q.mid(at: 23) else { return false }\n    guard let mid25 = q.mid(at:\
    \ 24) else { return false }\n    guard let mid26 = q.mid(at: 25) else { return\
    \ false }\n    guard let mid27 = q.mid(at\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp8fjouusr.swift:44:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmp8fjouusr.swift:43:28: note: to match this opening '('\n    guard let\
    \ mid27 = q.mid(at\n                           ^\n/tmp/tmp8fjouusr.swift:43:31:\
    \ error: expected 'else' after 'guard' condition\n    guard let mid27 = q.mid(at\n\
    \                              ^\n/tmp/tmp8fjouusr.swift:14:42: error: value of\
    \ optional type 'Int?' must be unwrapped to a value of type 'Int'\n    guard q.count\
    \ > 0 && w > 0 && w <= q.max() else { return false }\n                       \
    \                  ^\n/tmp/tmp8fjouusr.swift:14:42: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n    guard q.count\
    \ > 0 && w > 0 && w <= q.max() else { return false }\n                       \
    \                  ^\n                                               ?? <#default\
    \ value#>\n/tmp/tmp8fjouusr.swift:14:42: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n    guard q.count > 0 && w >\
    \ 0 && w <= q.max() else { return false }\n                                  \
    \       ^\n                                              !\n/tmp/tmp8fjouusr.swift:17:23:\
    \ error: value of type '[Int]' has no member 'mid'\n    guard let mid = q.mid(at:\
    \ 0) else { return false }\n                    ~ ^~~\n/tmp/tmp8fjouusr.swift:18:24:\
    \ error: value of type '[Int]' has no member 'mid'\n    guard let mid2 = q.mid(at:\
    \ 1) else { return false }\n                     ~ ^~~\n/tmp/tmp8fjouusr.swift:19:24:\
    \ error: value of type '[Int]' has no member 'mid'\n    guard let mid3 = q.mid(at:\
    \ 2) else { return false }\n                     ~ ^~~\n/tmp/tmp8fjouusr.swift:20:24:\
    \ error: value of type '[Int]' has no member 'mid'\n    guard let mid4 = q.mid(at:\
    \ 3) else { return false }\n                     ~ ^~~\n/tmp/tmp8fjouusr.swift:21:24:\
    \ error: value of type '[Int]' has no member 'mid'\n    guard let mid5 = q.mid(at:\
    \ 4) else { return false }\n                     ~ ^~~\n/tmp/tmp8fjouusr.swift:22:24:\
    \ error: value of type '[Int]' has no member 'mid'\n    guard let mid6 = q.mid(at:\
    \ 5) "
  stdout: ''
  timestamp: 1660014316
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    \n    var maxSum = w\n    var\
    \ maxSumIndex = 0\n    \n    for index in 0..<q.count {\n        let sum = q[index]\n\
    \        \n        if sum > maxSum {\n            maxSum = sum\n            maxSumIndex\
    \ = index\n        }\n    }\n    \n    return maxSum == w && maxSumIndex == q.count\
    \ - 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpo3686hwp/tmpo3686hwp.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acad5cdac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acad59d1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acad59d1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acad59d07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpo3686hwp                        0x000055c9d946453f <unavailable> + 5439

    5    libc.so.6                          0x00002acad5ec6460 __libc_start_main +
    245

    6    tmpo3686hwp                        0x000055c9d94641a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014318
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxSum = w\n    var maxSumIndex\
    \ = 0\n    var maxSumElement = q[0]\n    for index in 1..<q.count {\n        let\
    \ element = q[index]\n        let sumElement = element + maxSumElement\n     \
    \   if sumElement > maxSum {\n            maxSum = sumElement\n            maxSumIndex\
    \ = index\n            maxSumElement = element\n        }\n    }\n    return maxSum\
    \ == w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpubrw3u6p/tmpubrw3u6p.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b528f0bac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b528edb1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b528edb1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b528edb07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpubrw3u6p                        0x000055dc7229e5fb <unavailable> + 5627

    5    libc.so.6                          0x00002b528f2a6460 __libc_start_main +
    245

    6    tmpubrw3u6p                        0x000055dc7229e1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014318
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum\
    \ = 0\n    for x in q {\n        maxSum += x\n        if maxSum > maxWeight {\n\
    \            maxSum = maxWeight\n        }\n        maxWeight -= x\n    }\n  \
    \  return maxSum == 0 || maxSum == w\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpts7zjhlu/tmpts7zjhlu.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f58adcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f587d3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0f587d3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0f587d27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpts7zjhlu                        0x00005643d36dc46f <unavailable> + 5231

    5    libc.so.6                          0x00002b0f58cc8460 __libc_start_main +
    245

    6    tmpts7zjhlu                        0x00005643d36dc0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014318
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count == w else { return\
    \ false }\n    guard q.isPalindromic else { return false }\n    guard q.reduce(0,\
    \ +) <= w else { return false }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmposw5jiqd.swift:15:13: error: value of type '[Int]' has no member\
    \ 'isPalindromic'\n    guard q.isPalindromic else { return false }\n         \
    \ ~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014318
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    \n    // Write your code here.\n\
    \    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpsb8g9qn7/tmpsb8g9qn7.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aafecd9dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aafeca94b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aafeca94988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aafeca937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb8g9qn7                        0x000055bb6fd643bb <unavailable> + 5051

    5    libc.so.6                          0x00002aafecf89460 __libc_start_main +
    245

    6    tmpsb8g9qn7                        0x000055bb6fd63f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    \n    var maxSum = w\n    var\
    \ maxSumIndex = 0\n    \n    for i in q {\n        if i > maxSum {\n         \
    \   maxSum = i\n            maxSumIndex = q.index(of: i)\n        }\n    }\n \
    \   \n    if maxSum == w {\n        return true\n    }\n    \n    if maxSum >\
    \ w {\n        return false\n    }\n    \n    if maxSumIndex == 0 {\n        return\
    \ true\n    }\n    \n    if maxSumIndex == q.count - 1 {\n        return true\n\
    \    }\n    \n    let leftSum = q[maxSumIndex - 1]\n    let rightSum = q[maxSumIndex\
    \ + 1]\n    \n    if leftSum == w {\n        return true\n    }\n    \n    if\
    \ rightSum == w {\n        return true\n    }\n    \n    if leftSum > w {\n  \
    \      return false\n    }\n    \n    if rightSum > w {\n        return false\n\
    \    }\n    \n    return will_it_fly(q[maxSumIndex - 1 ..< q.count], w) && will_it_fly(q[maxSumIndex\
    \ ..< q.count - 1], w)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmplapq3eaw.swift:21:29: error: value of optional type 'Array<Int>.Index?'\
    \ (aka 'Optional<Int>') must be unwrapped to a value of type 'Array<Int>.Index'\
    \ (aka 'Int')\n            maxSumIndex = q.index(of: i)\n                    \
    \        ^\n/tmp/tmplapq3eaw.swift:21:29: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n            maxSumIndex =\
    \ q.index(of: i)\n                            ^\n                            \
    \             ?? <#default value#>\n/tmp/tmplapq3eaw.swift:21:29: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        \
    \    maxSumIndex = q.index(of: i)\n                            ^\n           \
    \                             !\n/tmp/tmplapq3eaw.swift:60:23: error: missing\
    \ argument labels 'q:w:' in call\n    return will_it_fly(q[maxSumIndex - 1 ..<\
    \ q.count], w) && will_it_fly(q[maxSumIndex ..< q.count - 1], w)\n           \
    \           ^\n                       q:                              w: \n/tmp/tmplapq3eaw.swift:60:25:\
    \ error: cannot convert value of type 'ArraySlice<Int>' to expected argument type\
    \ '[Int]'\n    return will_it_fly(q[maxSumIndex - 1 ..< q.count], w) && will_it_fly(q[maxSumIndex\
    \ ..< q.count - 1], w)\n                        ^\n/tmp/tmplapq3eaw.swift:60:73:\
    \ error: missing argument labels 'q:w:' in call\n    return will_it_fly(q[maxSumIndex\
    \ - 1 ..< q.count], w) && will_it_fly(q[maxSumIndex ..< q.count - 1], w)\n   \
    \                                                                     ^\n    \
    \                                                                     q:     \
    \                         w: \n/tmp/tmplapq3eaw.swift:60:75: error: cannot convert\
    \ value of type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return\
    \ will_it_fly(q[maxSumIndex - 1 ..< q.count], w) && will_it_fly(q[maxSumIndex\
    \ ..< q.count - 1], w)\n                                                     \
    \                     ^\n"
  stdout: ''
  timestamp: 1660014318
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var max = 0\n    var sum = 0\n\
    \    for x in q {\n        sum += x\n        if sum > max {\n            max =\
    \ sum\n        }\n    }\n    if max <= w {\n        return true\n    }\n    if\
    \ max > w {\n        return false\n    }\n    var i = 0\n    var j = q.count -\
    \ 1\n    while i < j {\n        if q[i] != q[j] {\n            return false\n\
    \        }\n        i += 1\n        j -= 1\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp1wn2a3jc/tmp1wn2a3jc.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abfa11efc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abfa0ee6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abfa0ee6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abfa0ee57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1wn2a3jc                        0x0000556e4b7eb5db <unavailable> + 5595

    5    libc.so.6                          0x00002abfa13db460 __libc_start_main +
    245

    6    tmp1wn2a3jc                        0x0000556e4b7eb189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1660014318
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count == w else { return\
    \ false }\n    guard q.isPalindromic else { return false }\n    guard q.sumLessOrEqualToOrEqualToW(w)\
    \ else { return false }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp_tqj4o9v.swift:15:13: error: value of type '[Int]' has no member\
    \ 'isPalindromic'\n    guard q.isPalindromic else { return false }\n         \
    \ ~ ^~~~~~~~~~~~~\n/tmp/tmp_tqj4o9v.swift:16:13: error: value of type '[Int]'\
    \ has no member 'sumLessOrEqualToOrEqualToW'\n    guard q.sumLessOrEqualToOrEqualToW(w)\
    \ else { return false }\n          ~ ^~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014318
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxSum = w\n    for v in\
    \ q {\n        if maxSum < v {\n            return false\n        }\n        maxSum\
    \ += v\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp3dh46r7z/tmp3dh46r7z.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2dfbafbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2dfb7f2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2dfb7f2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2dfb7f17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3dh46r7z                        0x0000557e26eff52b <unavailable> + 5419

    5    libc.so.6                          0x00002b2dfbce7460 __libc_start_main +
    245

    6    tmp3dh46r7z                        0x0000557e26eff0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014318
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxWeight = w\n    var balanced\
    \ = true\n    var sum = 0\n    for element in q {\n        sum += element\n  \
    \      if sum > maxWeight {\n            balanced = false\n            break\n\
    \        }\n    }\n    return balanced && sum <= maxWeight\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpqnft62m8/tmpqnft62m8.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6a3227fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6a31f76b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6a31f76988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6a31f757b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqnft62m8                        0x000055eb7a55952b <unavailable> + 5419

    5    libc.so.6                          0x00002b6a3246b460 __libc_start_main +
    245

    6    tmpqnft62m8                        0x000055eb7a5590d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014318
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxSum = w\n    var maxSumIndex\
    \ = 0\n    var sum = 0\n    for i in  q {\n        sum += i\n        if sum >\
    \ maxSum {\n            maxSum = sum\n            maxSumIndex = i\n        }\n\
    \    }\n    if maxSum < w {\n        return false\n    }\n    var reversed = [Int]()\n\
    \    for i in  q {\n        reversed.append(q[q.count - 1 - i])\n    }\n    if\
    \ maxSum == w {\n        return true\n    }\n    return will_it_fly(reversed,\
    \ w)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w:\
    \ 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmph7s0vope.swift:34:23: error: missing argument labels 'q:w:' in\
    \ call\n    return will_it_fly(reversed, w)\n                      ^\n       \
    \                q:        w: \n"
  stdout: ''
  timestamp: 1660014318
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var maxSum = w\n    var maxSumIndex\
    \ = 0\n    var maxSumElement = q[0]\n    for i := 1; i < len(q); i++ {\n     \
    \   var currentSum = q[i]\n        for j := i - 1; j >= 0; j-- {\n           \
    \ currentSum += q[j]\n            if currentSum > maxSum {\n                maxSum\
    \ = currentSum\n                maxSumIndex = j\n                maxSumElement\
    \ = q[j]\n            }\n        }\n    }\n    return maxSum == w && maxSumElement\
    \ == q[maxSumIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp4a0b9ubp.swift:17:12: error: expected type\n    for i := 1; i <\
    \ len(q); i++ {\n           ^\n            <#type#>\n/tmp/tmp4a0b9ubp.swift:17:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 1; i < len(q); i++\
    \ {\n           ^\n/tmp/tmp4a0b9ubp.swift:17:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 1; i < len(q); i++ {\n           ^\n/tmp/tmp4a0b9ubp.swift:19:16:\
    \ error: expected type\n        for j := i - 1; j >= 0; j-- {\n              \
    \ ^\n                <#type#>\n/tmp/tmp4a0b9ubp.swift:19:16: error: expected 'in'\
    \ after for-each pattern\n        for j := i - 1; j >= 0; j-- {\n            \
    \   ^\n/tmp/tmp4a0b9ubp.swift:19:16: error: expected Sequence expression for for-each\
    \ loop\n        for j := i - 1; j >= 0; j-- {\n               ^\n"
  stdout: ''
  timestamp: 1660014318
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var max = 0\n    var sum = 0\n\
    \    for x in q {\n        sum += x\n        if sum > max {\n            max =\
    \ sum\n        }\n    }\n    return sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpcpelfk46/tmpcpelfk46.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8e02983c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8e0267ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8e0267a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8e026797b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcpelfk46                        0x000055cb42b4c52b <unavailable> + 5419

    5    libc.so.6                          0x00002b8e02b6f460 __libc_start_main +
    245

    6    tmpcpelfk46                        0x000055cb42b4c0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var max = 0\n    for i : Int\
    \ in q {\n        max = max(max, i)\n    }\n    if w == max {\n        return\
    \ true\n    }\n    if w < max {\n        return false\n    }\n    var sum = 0\n\
    \    for i : Int in q {\n        sum += i\n    }\n    return sum <= w\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp4ttbkezn.swift:16:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, i)\n              ^\n"
  stdout: ''
  timestamp: 1660014318
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count == w else { return\
    \ false }\n    guard let first = q.first else { return false }\n    guard let\
    \ last = q.last else { return false }\n    guard let first = q.first else { return\
    \ false }\n    guard let last = q.last else { return false }\n    guard let first\
    \ = q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return \n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpm09masdy.swift:77:42: error: expected '}' at end of brace statement\n\
    assert(will_it_fly(q: [5], w: 5) == true)\n                                  \
    \       ^\n/tmp/tmpm09masdy.swift:13:44: note: to match this opening '{'\nfunc\
    \ will_it_fly(q: [Int], w: Int) -> Bool {\n                                  \
    \         ^\n/tmp/tmpm09masdy.swift:56:36: error: non-void function should return\
    \ a value\n    guard let last = q.last else { return \n                      \
    \             ^\n/tmp/tmpm09masdy.swift:60:6: error: operator functions can only\
    \ be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n/tmp/tmpm09masdy.swift:15:15: warning: value 'first'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let first = q.first else { return false }\n          ~~~~^~~~~~~~\n        \
    \                      != nil\n/tmp/tmpm09masdy.swift:16:15: warning: value 'last'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let last = q.last else { return false }\n          ~~~~^~~~~~~\n           \
    \                 != nil\n/tmp/tmpm09masdy.swift:17:15: warning: value 'first'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let first = q.first else { return false }\n          ~~~~^~~~~~~~\n        \
    \                      != nil\n/tmp/tmpm09masdy.swift:18:15: warning: value 'last'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let last = q.last else { return false }\n          ~~~~^~~~~~~\n           \
    \                 != nil\n/tmp/tmpm09masdy.swift:19:15: warning: value 'first'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let first = q.first else { return false }\n          ~~~~^~~~~~~~\n        \
    \                      != nil\n/tmp/tmpm09masdy.swift:20:15: warning: value 'last'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let last = q.last else { return false }\n          ~~~~^~~~~~~\n           \
    \                 != nil\n/tmp/tmpm09masdy.swift:21:15: warning: value 'f"
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var max = 0\n    for x in q\
    \ {\n        max = max(max, x)\n    }\n    if max <= w {\n        return true\n\
    \    }\n    var sum = 0\n    for x in q {\n        sum += x\n    }\n    return\
    \ sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2,\
    \ 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpak89xmfj.swift:16:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, x)\n              ^\n"
  stdout: ''
  timestamp: 1660014318
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    \n    // Write your code here.\n\
    \    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpsb8g9qn7/tmpsb8g9qn7.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aafecd9dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aafeca94b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aafeca94988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aafeca937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb8g9qn7                        0x000055bb6fd643bb <unavailable> + 5051

    5    libc.so.6                          0x00002aafecf89460 __libc_start_main +
    245

    6    tmpsb8g9qn7                        0x000055bb6fd63f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014316
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    var max = 0\n    for x in q\
    \ {\n        if x > max {\n            max = x\n        }\n    }\n    if max >\
    \ w {\n        return false\n    }\n    var sum = 0\n    for x in q {\n      \
    \  sum += x\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp1zkc4vnn/tmp1zkc4vnn.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acdb254dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acdb2244b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acdb2244988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acdb22437b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1zkc4vnn                        0x000056020f6d452b <unavailable> + 5419

    5    libc.so.6                          0x00002acdb2739460 __libc_start_main +
    245

    6    tmp1zkc4vnn                        0x000056020f6d40d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014316
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    guard q.count == w else {\n\
    \        return false\n    }\n    \n    let maxWeight = w\n    var sum = 0\n \
    \   for element in q {\n        sum += element\n    }\n    \n    return sum ==\
    \ maxWeight && is_balanced(q) && is_palindromic(q)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpyc8sfwm8.swift:24:32: error: cannot find 'is_balanced' in scope\n\
    \    return sum == maxWeight && is_balanced(q) && is_palindromic(q)\n        \
    \                       ^~~~~~~~~~~\n/tmp/tmpyc8sfwm8.swift:24:50: error: cannot\
    \ find 'is_palindromic' in scope\n    return sum == maxWeight && is_balanced(q)\
    \ && is_palindromic(q)\n                                                 ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014318
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    let maxWeight = w\n    var sum\
    \ = 0\n    for x in q {\n        sum += x\n    }\n    return sum <= maxWeight\
    \ && is_balanced(q)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmphtjy00hr.swift:19:32: error: cannot find 'is_balanced' in scope\n\
    \    return sum <= maxWeight && is_balanced(q)\n                             \
    \  ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014318
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    func will_it_fly(q: [Int], w: Int) -> Bool {\n    let maxWeight = w\n    var maxSum\
    \ = Int.max\n    for element in q {\n        let sum = element + maxSum\n    \
    \    if sum > maxWeight {\n            maxSum = sum\n            maxWeight = sum\n\
    \        }\n    }\n    return maxSum == maxWeight\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp3vnl9qqi.swift:20:13: error: cannot assign to value: 'maxWeight'\
    \ is a 'let' constant\n            maxWeight = sum\n            ^~~~~~~~~\n/tmp/tmp3vnl9qqi.swift:14:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let maxWeight = w\n    ^~~\n\
    \    var\n"
  stdout: ''
  timestamp: 1660014318
