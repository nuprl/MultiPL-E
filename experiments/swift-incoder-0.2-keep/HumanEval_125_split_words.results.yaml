language: swift
name: HumanEval_125_split_words
results:
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.components(separatedBy:\
    \ \" \") else {\n        return Err(Int(rawValue: 1))\n    }\n    \n    let wordCount\
    \ = words.count\n    \n    if wordCount == 0 {\n        return Err(Int(rawValue:\
    \ 2))\n    }\n    \n    if wordCount == 1 {\n        return Ok(words)\n    }\n\
    \    \n    if wordCount == 2 {\n        return Ok(words.first!)\n    }\n    \n\
    \    if wordCount == 3 {\n        return Ok(words.first!)\n    }\n    \n    if\
    \ wordCount == 4 {\n        return Ok(words.first!)\n    }\n    \n    if wordCount\
    \ == 5 {\n        return Ok(words.first!)\n    }\n    \n    if wordCount == 6\
    \ {\n        return Ok(words.first!)\n    }\n    \n    if wordCount == 7 {\n \
    \       return Ok(words.first!)\n    }\n    \n    if wordCount == 8 {\n      \
    \  return Ok(words.first!)\n    }\n    \n    if wordCount == 9 {\n        return\
    \ Ok(words.first!)\n    }\n    \n    if wordCount == 10 {\n        return Ok(words.first!)\n\
    \    }\n    \n    if wordCount == 11 {\n        return Ok(words.first!)\n    }\n\
    \    \n    if wordCount == 12 {\n        return Ok(words.first!)\n    }\n    \n\
    \    if wordCount == 13 {\n        return Ok(words.first!)\n    }\n    \n    if\
    \ wordCount == 14 {\n        return Ok(words.first!)\n    }\n    \n    if wordCount\
    \ == 15 {\n        return Ok(words.first!)\n    }\n    \n    if wordCount == 16\
    \ {\n        return Ok(words.first!)\n    }\n    \n    if wordCount == 17 {\n\
    \        return Ok(words.first!)\n    }\n    \n    if wordCount == 18 {\n    \
    \    return Ok(words.first!)\n    }\n    \n    if wordCount == 19 {\n        return\
    \ Ok(words.first!)\n    }\n    \n    if wordCount == 20 {\n        return Ok(words.first!)\n\
    \    }\n    \n    if wordCount == 21 {\n        return Ok(words.first!)\n    }\n\
    \    \n    if wordCount == 22 {\n        return Ok(words.first!)\n    }\n    \n\
    \    if wordCount == 23 {\n        return Ok(words.first!)\n    }\n    \n    if\
    \ wordCount == 24 {\n        return Ok(words.first!)\n    }\n    \n    if wordCount\
    \ == 25 {\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpye1z65nx.swift:141:44: error: expected '}' at end of brace statement\n\
    assert(split_words(txt: \"\") == .failure(0))\n                              \
    \             ^\n/tmp/tmpye1z65nx.swift:11:56: note: to match this opening '{'\n\
    func split_words(txt: String) -> Result<[String], Int> {\n                   \
    \                                    ^\n/tmp/tmpye1z65nx.swift:12:27: error: value\
    \ of type 'String' has no member 'components'\n    guard let words = txt.components(separatedBy:\
    \ \" \") else {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmpye1z65nx.swift:13:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(rawValue: 1))\n  \
    \             ^~~\n/tmp/tmpye1z65nx.swift:13:23: error: extraneous argument label\
    \ 'rawValue:' in call\n        return Err(Int(rawValue: 1))\n                \
    \      ^~~~~~~~~~~\n                       \n/tmp/tmpye1z65nx.swift:19:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(rawValue: 2))\n         \
    \      ^~~\n/tmp/tmpye1z65nx.swift:19:23: error: extraneous argument label 'rawValue:'\
    \ in call\n        return Err(Int(rawValue: 2))\n                      ^~~~~~~~~~~\n\
    \                       \n/tmp/tmpye1z65nx.swift:23:16: error: cannot find 'Ok'\
    \ in scope\n        return Ok(words)\n               ^~\n/tmp/tmpye1z65nx.swift:27:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words.first!)\n        \
    \       ^~\n/tmp/tmpye1z65nx.swift:31:16: error: cannot find 'Ok' in scope\n \
    \       return Ok(words.first!)\n               ^~\n/tmp/tmpye1z65nx.swift:35:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words.first!)\n        \
    \       ^~\n/tmp/tmpye1z65nx.swift:39:16: error: cannot find 'Ok' in scope\n \
    \       return Ok(words.first!)\n               ^~\n/tmp/tmpye1z65nx.swift:43:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words.first!)\n        \
    \       ^~\n/tmp/tmpye1z65nx.swift:47:16: error: cannot find 'Ok' in scope\n \
    \       return Ok(words.first!)\n               ^~\n/tmp/tmpye1z65nx.swift:51:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words.first!)\n        \
    \       ^~\n/tmp/tmpye1z65nx.swift:55:1"
  stdout: ''
  timestamp: 1660054237
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(.letters))\n    }\n    if\
    \ words.count == 1 {\n        return Ok(words)\n    }\n    let letters = words.map({\
    \ $0.lowercased() })\n    let odd = letters.filter({ $0.count % 2 == 1 })\n  \
    \  return Ok(odd.count)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpoqxc0jwo.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpoqxc0jwo.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(.letters))\n               ^~~\n/tmp/tmpoqxc0jwo.swift:14:24:\
    \ error: missing argument label 'bitPattern:' in call\n        return Err(Int(.letters))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmpoqxc0jwo.swift:17:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpoqxc0jwo.swift:21:12: error: cannot find 'Ok' in scope\n    return Ok(odd.count)\n\
    \           ^~\n"
  stdout: ''
  timestamp: 1660054237
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.components(separatedBy:\
    \ \" \") else {\n        return Err(Int(.init(rawValue: 10)))\n    }\n    \n \
    \   var result: [String] = []\n    \n    for word in words {\n        if let wordCount\
    \ = word.characters.filter({ $0.isLetter }).count {\n            if wordCount\
    \ % 2 == 1 {\n                result.append(word)\n            }\n        } else\
    \ {\n            if let wordCount = word.characters.filter({ $0.isLetter }).count\
    \ {\n                if wordCount % 2 == 0 {\n                    result.append(word)\n\
    \                }\n            } else {\n                result.append(word)\n\
    \            }\n        }\n    }\n    \n    guard result.count > 0 else {\n  \
    \      return Err(Int(.init(rawValue: 10)))\n    }\n    \n    return Ok(result)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmphyetfk1y.swift:12:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmphyetfk1y.swift:13:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(.init(rawValue: 10)))\n \
    \              ^~~\n/tmp/tmphyetfk1y.swift:13:25: error: reference to member 'init'\
    \ cannot be resolved without a contextual type\n        return Err(Int(.init(rawValue:\
    \ 10)))\n                        ^\n/tmp/tmphyetfk1y.swift:35:16: error: cannot\
    \ find 'Err' in scope\n        return Err(Int(.init(rawValue: 10)))\n        \
    \       ^~~\n/tmp/tmphyetfk1y.swift:35:25: error: reference to member 'init' cannot\
    \ be resolved without a contextual type\n        return Err(Int(.init(rawValue:\
    \ 10)))\n                        ^\n/tmp/tmphyetfk1y.swift:38:12: error: cannot\
    \ find 'Ok' in scope\n    return Ok(result)\n           ^~\n"
  stdout: ''
  timestamp: 1660054237
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.split(separator: \" \"\
    ) else {\n        return Err(Int(.notFound))\n    }\n    \n    var result: [String]\
    \ = []\n    \n    for word in words {\n        guard let word = word.trimmingCharacters(in:\
    \ .whitespaces) else {\n            return Err(Int(.notFound))\n        }\n  \
    \      \n        if word.characters.count == 0 {\n            continue\n     \
    \   }\n        \n        if word.characters.count % 2 == 1 {\n            return\
    \ Err(Int(.notFound))\n        }\n        \n        if word.lowercased() != word\
    \ {\n            return Err(Int(.notFound))\n        }\n        \n        result.append(word)\n\
    \    }\n    \n    return Ok(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp0elaht3t.swift:13:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(.notFound))\n               ^~~\n/tmp/tmp0elaht3t.swift:13:24:\
    \ error: missing argument label 'bitPattern:' in call\n        return Err(Int(.notFound))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmp0elaht3t.swift:12:11:\
    \ error: initializer for conditional binding must have Optional type, not '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n    guard let words = txt.split(separator: \" \")\
    \ else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp0elaht3t.swift:19:31:\
    \ error: value of type 'String.SubSequence' (aka 'Substring') has no member 'trimmingCharacters'\n\
    \        guard let word = word.trimmingCharacters(in: .whitespaces) else {\n \
    \                        ~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp0elaht3t.swift:19:55:\
    \ error: cannot infer contextual base in reference to member 'whitespaces'\n \
    \       guard let word = word.trimmingCharacters(in: .whitespaces) else {\n  \
    \                                                   ~^~~~~~~~~~~\n/tmp/tmp0elaht3t.swift:20:20:\
    \ error: cannot find 'Err' in scope\n            return Err(Int(.notFound))\n\
    \                   ^~~\n/tmp/tmp0elaht3t.swift:20:28: error: missing argument\
    \ label 'bitPattern:' in call\n            return Err(Int(.notFound))\n      \
    \                     ^\n                           bitPattern: \n/tmp/tmp0elaht3t.swift:28:20:\
    \ error: cannot find 'Err' in scope\n            return Err(Int(.notFound))\n\
    \                   ^~~\n/tmp/tmp0elaht3t.swift:28:28: error: missing argument\
    \ label 'bitPattern:' in call\n            return Err(Int(.notFound))\n      \
    \                     ^\n                           bitPattern: \n/tmp/tmp0elaht3t.swift:32:20:\
    \ error: cannot find 'Err' in scope\n            return Err(Int(.notFound))\n\
    \                   ^~~\n/tmp/tmp0elaht3t.swift:32:28: error: missing argument\
    \ label 'bitPattern:' in call\n            return Err(Int(.notFound))\n      \
    \                     ^\n                           bitPattern: \n/tmp/tmp0elaht3t.swift:38:12:\
    \ error: cannot find 'Ok' in sco"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(0))\n    }\n    let wordCount\
    \ = words.count\n    let wordCountWithCommas = wordCount + words.count - 1\n \
    \   let wordCountWithCommasWithOddOrder = wordCountWithCommas + 1\n    let wordCountWithCommasWithOddOrderWithOddOrder\
    \ = wordCountWithCommasWithOddOrder + 1\n    let wordCountWithCommasWithOddOrderWithOddOrderWithOddOrder\
    \ = wordCountWithCommasWithOddOrderWithOddOrder + 1\n    let wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrder\
    \ = wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrder + 1\n\
    \    let wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrder\
    \ = wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrder\
    \ + 1\n    let wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrder\
    \ = wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrder\n\
    \    let wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrder\
    \ = wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrder\n\
    \    let wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrder\
    \ = wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrder\n\
    \    let wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrder\
    \ = wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithO\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp_uvecvur.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp_uvecvur.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(0))\n               ^~~\n/tmp/tmp_uvecvur.swift:21:79:\
    \ error: use of local variable 'wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrder'\
    \ before its declaration\n    let wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrder\
    \ = wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrder + 1\n\
    \                                                                            \
    \  ^\n/tmp/tmp_uvecvur.swift:21:9: note: 'wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrder'\
    \ declared here\n    let wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrder\
    \ = wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrder + 1\n\
    \        ^\n/tmp/tmp_uvecvur.swift:22:91: error: use of local variable 'wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrder'\
    \ before its declaration\n    let wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrder\
    \ = wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrder\
    \ + 1\n                                                                      \
    \                    ^\n/tmp/tmp_uvecvur.swift:23:9: note: 'wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrder'\
    \ declared here\n    let wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrder\
    \ = wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrder\n\
    \        ^\n/tmp/tmp_uvecvur.swift:23:103: error: use of local variable 'wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrder'\
    \ before its declaration\n    let wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrder\
    \ = wordCo"
  stdout: ''
  timestamp: 1660054237
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(1))\n    }\n    if words.count\
    \ == 1 {\n        return Ok(words)\n    }\n    let chars = words.map { String($0).lowercased()\
    \ }\n    let count = chars.count\n    if chars.count % 2 == 1 {\n        return\
    \ Ok(words.map { String($0).lowercased() })\n    }\n    return Ok(words.map {\
    \ String($0).lowercased() })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpkvip00rt.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpkvip00rt.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(1))\n               ^~~\n/tmp/tmpkvip00rt.swift:17:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpkvip00rt.swift:22:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words.map { String($0).lowercased() })\n               ^~\n/tmp/tmpkvip00rt.swift:24:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words.map { String($0).lowercased()\
    \ })\n           ^~\n"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.split(separator: \" \"\
    ) else {\n        return Err(Int(errorCode: errorCodes.wrongFormat))\n    }\n\
    \    \n    var result: [String] = []\n    \n    for word in words {\n        guard\
    \ let letters = word.split(separator: \",\") else {\n            return Err(Int(errorCode:\
    \ errorCodes.wrongFormat))\n        }\n        \n        for letter in letters\
    \ {\n            if letter.lowercased() != letter {\n                return Err(Int(errorCode:\
    \ errorCodes.wrongFormat))\n            }\n        }\n        \n        result.append(word)\n\
    \    }\n    \n    return Ok(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmptdwpsqk_.swift:13:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(errorCode: errorCodes.wrongFormat))\n               ^~~\n/tmp/tmptdwpsqk_.swift:13:35:\
    \ error: cannot find 'errorCodes' in scope\n        return Err(Int(errorCode:\
    \ errorCodes.wrongFormat))\n                                  ^~~~~~~~~~\n/tmp/tmptdwpsqk_.swift:13:20:\
    \ error: no exact matches in call to initializer \n        return Err(Int(errorCode:\
    \ errorCodes.wrongFormat))\n                   ^\n/tmp/tmptdwpsqk_.swift:13:20:\
    \ note: found candidate with type '(Float16) -> Int'\n        return Err(Int(errorCode:\
    \ errorCodes.wrongFormat))\n                   ^\n/tmp/tmptdwpsqk_.swift:13:20:\
    \ note: found candidate with type '(Float) -> Int'\n        return Err(Int(errorCode:\
    \ errorCodes.wrongFormat))\n                   ^\n/tmp/tmptdwpsqk_.swift:13:20:\
    \ note: found candidate with type '(Double) -> Int'\n        return Err(Int(errorCode:\
    \ errorCodes.wrongFormat))\n                   ^\n/tmp/tmptdwpsqk_.swift:13:20:\
    \ note: found candidate with type '(Float80) -> Int'\n        return Err(Int(errorCode:\
    \ errorCodes.wrongFormat))\n                   ^\n/tmp/tmptdwpsqk_.swift:13:20:\
    \ note: found candidate with type '(Builtin.Int64) -> Int'\n        return Err(Int(errorCode:\
    \ errorCodes.wrongFormat))\n                   ^\n/tmp/tmptdwpsqk_.swift:13:20:\
    \ note: found candidate with type '(Builtin.Word) -> Int'\n        return Err(Int(errorCode:\
    \ errorCodes.wrongFormat))\n                   ^\n/tmp/tmptdwpsqk_.swift:13:20:\
    \ note: found candidate with type '(String) -> Int?'\n        return Err(Int(errorCode:\
    \ errorCodes.wrongFormat))\n                   ^\n/tmp/tmptdwpsqk_.swift:12:11:\
    \ error: initializer for conditional binding must have Optional type, not '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n    guard let words = txt.split(separator: \" \")\
    \ else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmptdwpsqk_.swift:20:20:\
    \ error: cannot find 'Err' in scope\n            return Err(Int(errorCode: errorCodes.wrongFormat))\n\
    \                   ^~~\n/tmp/tmptdwpsqk_.swift:20:39: error"
  stdout: ''
  timestamp: 1660054237
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let txt = txt.trimmingCharacters(in: .whitespacesAndNewlines)\
    \ else { return Err(0) }\n    guard let words = txt.components(separatedBy: \"\
    ,\").map(String.init) else { return Err(0) }\n    let count = words.count\n  \
    \  let letters = words.map { $0.lowercased().count }\n    let odd = letters.filter\
    \ { $0 % 2 == 1 }\n    return Ok([count] + odd)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpx2obvhrq.swift:12:25: error: value of type 'String' has no member\
    \ 'trimmingCharacters'\n    guard let txt = txt.trimmingCharacters(in: .whitespacesAndNewlines)\
    \ else { return Err(0) }\n                    ~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpx2obvhrq.swift:12:49:\
    \ error: cannot infer contextual base in reference to member 'whitespacesAndNewlines'\n\
    \    guard let txt = txt.trimmingCharacters(in: .whitespacesAndNewlines) else\
    \ { return Err(0) }\n                                               ~^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpx2obvhrq.swift:12:87: error: cannot find 'Err' in scope\n    guard let\
    \ txt = txt.trimmingCharacters(in: .whitespacesAndNewlines) else { return Err(0)\
    \ }\n                                                                        \
    \              ^~~\n/tmp/tmpx2obvhrq.swift:13:87: error: cannot find 'Err' in\
    \ scope\n    guard let words = txt.components(separatedBy: \",\").map(String.init)\
    \ else { return Err(0) }\n                                                   \
    \                                   ^~~\n/tmp/tmpx2obvhrq.swift:17:12: error:\
    \ cannot find 'Ok' in scope\n    return Ok([count] + odd)\n           ^~\n"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(0))\n    }\n    let comma\
    \ = words.last?.components(separatedBy: \",\")\n    if comma == nil {\n      \
    \  return Err(Int(words.count))\n    }\n    let letters = words.count % 2 == 0\
    \ ? words.count / 2 : words.count / 2 + 1\n    return Ok([words[0], words[letters],\
    \ comma!])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp29iclfse.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp29iclfse.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(0))\n               ^~~\n/tmp/tmp29iclfse.swift:18:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(words.count))\n  \
    \             ^~~\n/tmp/tmp29iclfse.swift:21:12: error: cannot find 'Ok' in scope\n\
    \    return Ok([words[0], words[letters], comma!])\n           ^~\n"
  stdout: ''
  timestamp: 1660054237
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(0)\n    }\n    let count = words.count\n\
    \    let letters = words.map { $0.lowercased().count }\n    if letters.contains(0)\
    \ {\n        return Err(0)\n    }\n    if letters.contains(1) {\n        return\
    \ Err(1)\n    }\n    if letters.contains(2) {\n        return Err(2)\n    }\n\
    \    if letters.contains(3) {\n        return Err(3)\n    }\n    if letters.contains(4)\
    \ {\n        return Err(4)\n    }\n    if letters.contains(5) {\n        return\
    \ Err(5)\n    }\n    if letters.contains(6) {\n        return Err(6)\n    }\n\
    \    if letters.contains(7) {\n        return Err(7)\n    }\n    if letters.contains(8)\
    \ {\n        return Err(8)\n    }\n    if letters.contains(9) {\n        return\
    \ Err(9)\n    }\n    if letters.contains(10) {\n        return Err(10)\n    }\n\
    \    if letters.contains(11) {\n        return Err(11)\n    }\n    if letters.contains(12)\
    \ {\n        return Err(12)\n    }\n    if letters.contains(13) {\n        return\
    \ Err(13)\n    }\n    if letters.contains(14) {\n        return Err(14)\n    }\n\
    \    if letters.contains(15) {\n        return Err(15)\n    }\n    if letters.contains(16)\
    \ {\n        return Err(16)\n    }\n    if letters.contains(17) {\n        return\
    \ Err(17)\n    }\n    if letters.contains(18) {\n        return Err(18)\n    }\n\
    \    if letters.contains(19) {\n        return Err(19)\n    }\n    if letters.contains(20)\
    \ {\n        return Err(20)\n    }\n    if letters.contains(21) {\n        return\
    \ Err(21)\n    }\n    if letters.contains(22) {\n        return Err(22)\n    }\n\
    \    if letters.contains(23) {\n        return Err(23)\n    }\n    if letters.contains(24)\
    \ {\n        return Err(24)\n    }\n    if letters.contains(25) {\n        return\
    \ Err(25)\n    }\n    return Ok(words.map { $0.lowercased() })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpdorlzpgk.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpdorlzpgk.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(0)\n               ^~~\n/tmp/tmpdorlzpgk.swift:19:16:\
    \ error: cannot find 'Err' in scope\n        return Err(0)\n               ^~~\n\
    /tmp/tmpdorlzpgk.swift:22:16: error: cannot find 'Err' in scope\n        return\
    \ Err(1)\n               ^~~\n/tmp/tmpdorlzpgk.swift:25:16: error: cannot find\
    \ 'Err' in scope\n        return Err(2)\n               ^~~\n/tmp/tmpdorlzpgk.swift:28:16:\
    \ error: cannot find 'Err' in scope\n        return Err(3)\n               ^~~\n\
    /tmp/tmpdorlzpgk.swift:31:16: error: cannot find 'Err' in scope\n        return\
    \ Err(4)\n               ^~~\n/tmp/tmpdorlzpgk.swift:34:16: error: cannot find\
    \ 'Err' in scope\n        return Err(5)\n               ^~~\n/tmp/tmpdorlzpgk.swift:37:16:\
    \ error: cannot find 'Err' in scope\n        return Err(6)\n               ^~~\n\
    /tmp/tmpdorlzpgk.swift:40:16: error: cannot find 'Err' in scope\n        return\
    \ Err(7)\n               ^~~\n/tmp/tmpdorlzpgk.swift:43:16: error: cannot find\
    \ 'Err' in scope\n        return Err(8)\n               ^~~\n/tmp/tmpdorlzpgk.swift:46:16:\
    \ error: cannot find 'Err' in scope\n        return Err(9)\n               ^~~\n\
    /tmp/tmpdorlzpgk.swift:49:16: error: cannot find 'Err' in scope\n        return\
    \ Err(10)\n               ^~~\n/tmp/tmpdorlzpgk.swift:52:16: error: cannot find\
    \ 'Err' in scope\n        return Err(11)\n               ^~~\n/tmp/tmpdorlzpgk.swift:55:16:\
    \ error: cannot find 'Err' in scope\n        return Err(12)\n               ^~~\n\
    /tmp/tmpdorlzpgk.swift:58:16: error: cannot find 'Err' in scope\n        return\
    \ Err(13)\n               ^~~\n/tmp/tmpdorlzpgk.swift:61:16: error: cannot find\
    \ 'Err' in scope\n        return Err(14)\n               ^~~\n/tmp/tmpdorlzpgk.swift:64:16:\
    \ error: cannot find 'Err' in scope\n        return Err(15)\n               ^~~\n\
    /tmp/tmpdorlzpgk.swift:67:16: error: cannot find 'Err' in scope\n        return\
    \ Err(16)\n   "
  stdout: ''
  timestamp: 1660054237
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(0))\n    }\n    if words.count\
    \ == 1 {\n        return Ok(words)\n    }\n    let firstWord = words[0]\n    let\
    \ firstLetter = firstWord.characters.first!\n    if firstLetter >= 97 && firstLetter\
    \ <= 122 {\n        return Ok(words)\n    }\n    if firstLetter >= 65 && firstLetter\
    \ <= 90 {\n        return Ok(words)\n    }\n    if firstLetter >= 48 && firstLetter\
    \ <= 57 {\n        return Ok(words)\n    }\n    if firstLetter >= 32 && firstLetter\
    \ <= 47 {\n        return Ok(words)\n    }\n    if firstLetter >= 0 && firstLetter\
    \ <= 9 {\n        return Ok(words)\n    }\n    if firstLetter >= 33 && firstLetter\
    \ <= 47 {\n        return Ok(words)\n    }\n    if firstLetter >= 58 && firstLetter\
    \ <= 64 {\n        return Ok(words)\n    }\n    if firstLetter >= 91 && firstLetter\
    \ <= 96 {\n        return Ok(words)\n    }\n    if firstLetter >= 123 && firstLetter\
    \ <= 126 {\n        return Ok(words)\n    }\n    return Err(Int(0))\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpr2e31n0k.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpr2e31n0k.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(0))\n               ^~~\n/tmp/tmpr2e31n0k.swift:17:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpr2e31n0k.swift:22:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpr2e31n0k.swift:25:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpr2e31n0k.swift:28:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpr2e31n0k.swift:31:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpr2e31n0k.swift:34:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpr2e31n0k.swift:37:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpr2e31n0k.swift:40:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpr2e31n0k.swift:43:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpr2e31n0k.swift:46:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpr2e31n0k.swift:48:12: error: cannot find 'Err' in scope\n    return Err(Int(0))\n\
    \           ^~~\n"
  stdout: ''
  timestamp: 1660054237
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(0)\n    }\n    \n    let comma\
    \ = words.last!.components(separatedBy: \",\")\n    if comma.count == 0 {\n  \
    \      return Ok(words.map { $0.lowercased() })\n    }\n    \n    return Ok(words.map\
    \ { $0.lowercased() })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpyeh5teir.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpyeh5teir.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(0)\n               ^~~\n/tmp/tmpyeh5teir.swift:19:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words.map { $0.lowercased()\
    \ })\n               ^~\n/tmp/tmpyeh5teir.swift:22:12: error: cannot find 'Ok'\
    \ in scope\n    return Ok(words.map { $0.lowercased() })\n           ^~\n"
  stdout: ''
  timestamp: 1660054237
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(1))\n    }\n    if words.count\
    \ == 1 {\n        return Ok(words)\n    }\n    let wordCount = words.count\n \
    \   let alphabet = Array(Array(UnicodeScalar(UInt8(ascii: \"a\".unicodeScalars.first!.value\
    \ - 1))...UnicodeScalar(UInt8(ascii: \"z\".unicodeScalars.first!.value - 1))))\n\
    \    let alphabetCount = alphabet.count\n    let alphabetLetters = words.map {\
    \ $0.lowercased() }\n    let alphabetLettersCount = alphabetLetters.count\n  \
    \  let alphabetLettersOdd = alphabetLetters.filter { $0 % 2 == 1 }\n    let alphabetLettersEven\
    \ = alphabetLetters.filter { $0 % 2 == 0 }\n    let alphabetLettersOddCount =\
    \ alphabetLettersOdd.count\n    let alphabetLettersEvenCount = alphabetLettersEven.count\n\
    \    let alphabetLettersOddOrder = alphabetLettersOdd.map { $0 + 1 }\n    let\
    \ alphabetLettersEvenOrder = alphabetLettersEven.map { $0 + 1 }\n    let alphabetLettersOddOrderCount\
    \ = alphabetLettersOddOrder.count\n    let alphabetLettersEvenOrderCount = alphabetLettersEvenOrder.count\n\
    \    let alphabetLettersOddOrderLetters = alphabetLettersOddOrder.map { alphabet[Int($0)]\
    \ }\n    let alphabetLettersEvenOrderLetters = alphabetLettersEvenOrder.map {\
    \ alphabet[Int($0)] }\n    let alphabetLettersOddOrderLettersCount = alphabetLettersOddOrderLetters.count\n\
    \    let alphabetLettersEvenOrderLettersCount = alphabetLettersEvenOrderLetters.count\n\
    \    let alphabetLettersOddOrderLettersOdd = alphabetLettersOddOrderLetters.map\
    \ { $0 % 2 == 1 }\n    let alphabetLettersEvenOrderLettersOdd = alphabetLettersEvenOrderLetters.map\
    \ { $0 % 2 == 1 }\n    let alphabetLettersOddOrderLettersEven = alphabetLettersOddOrderLetters.map\
    \ { $0 % 2 == 0 }\n    let alphabetLettersEvenOrderLettersEven = alphabetLettersEvenOrderLetters.map\
    \ { $0 % 2 == 0 }\n    let alphabetLettersOddOrderLettersOddCount = alphabetLettersOddOrderLettersOdd.count\n\
    \    let alphabetLettersEvenOrderLettersOddCount = alphabetLettersEvenOrderLettersOdd.count\n\
    \    let alphabetLettersOddOrderLettersEvenCount = alphabetLettersOddOrderLetter\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmps4n5kz21.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmps4n5kz21.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(1))\n               ^~~\n/tmp/tmps4n5kz21.swift:17:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmps4n5kz21.swift:20:32: error: missing argument label 'arrayLiteral:' in\
    \ call\n    let alphabet = Array(Array(UnicodeScalar(UInt8(ascii: \"a\".unicodeScalars.first!.value\
    \ - 1))...UnicodeScalar(UInt8(ascii: \"z\".unicodeScalars.first!.value - 1))))\n\
    \                               ^\n                               arrayLiteral:\
    \ \n/tmp/tmps4n5kz21.swift:20:91: error: cannot convert value of type 'UInt32'\
    \ to expected argument type 'Unicode.Scalar'\n    let alphabet = Array(Array(UnicodeScalar(UInt8(ascii:\
    \ \"a\".unicodeScalars.first!.value - 1))...UnicodeScalar(UInt8(ascii: \"z\".unicodeScalars.first!.value\
    \ - 1))))\n                                                                  \
    \                        ^\n/tmp/tmps4n5kz21.swift:20:158: error: cannot convert\
    \ value of type 'UInt32' to expected argument type 'Unicode.Scalar'\n    let alphabet\
    \ = Array(Array(UnicodeScalar(UInt8(ascii: \"a\".unicodeScalars.first!.value -\
    \ 1))...UnicodeScalar(UInt8(ascii: \"z\".unicodeScalars.first!.value - 1))))\n\
    \                                                                            \
    \                                                                            \
    \     ^\n/tmp/tmps4n5kz21.swift:42:51: error: cannot find 'alphabetLettersOddOrderLetter'\
    \ in scope\n    let alphabetLettersOddOrderLettersEvenCount = alphabetLettersOddOrderLetter\n\
    \                                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count < 2 {\n        return Err(words.count)\n    }\n    let comma\
    \ = words.last?.components(separatedBy: \",\")\n    if comma?.count < 2 {\n  \
    \      return Err(words.count)\n    }\n    let letters = words.last?.characters.filter\
    \ { $0 >= 'a' && $0 <= 'z' }.count\n    if letters % 2 == 1 {\n        return\
    \ Err(letters)\n    }\n    return Ok(words.dropLast())\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpyr2zck4w.swift:20:57: error: single-quoted string literal found,\
    \ use '\"'\n    let letters = words.last?.characters.filter { $0 >= 'a' && $0\
    \ <= 'z' }.count\n                                                        ^~~\n\
    \                                                        \"a\"\n/tmp/tmpyr2zck4w.swift:20:70:\
    \ error: single-quoted string literal found, use '\"'\n    let letters = words.last?.characters.filter\
    \ { $0 >= 'a' && $0 <= 'z' }.count\n                                         \
    \                            ^~~\n                                           \
    \                          \"z\"\n/tmp/tmpyr2zck4w.swift:12:21: error: value of\
    \ type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmpyr2zck4w.swift:14:16: error:\
    \ cannot find 'Err' in scope\n        return Err(words.count)\n              \
    \ ^~~\n/tmp/tmpyr2zck4w.swift:17:15: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    if comma?.count < 2 {\n         \
    \     ^\n/tmp/tmpyr2zck4w.swift:17:15: note: coalesce using '??' to provide a\
    \ default when the optional value contains 'nil'\n    if comma?.count < 2 {\n\
    \              ^\n                    ?? <#default value#>\n/tmp/tmpyr2zck4w.swift:17:15:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    if comma?.count < 2 {\n              ^\n       (           )!\n/tmp/tmpyr2zck4w.swift:18:16:\
    \ error: cannot find 'Err' in scope\n        return Err(words.count)\n       \
    \        ^~~\n/tmp/tmpyr2zck4w.swift:20:76: error: type of expression is ambiguous\
    \ without more context\n    let letters = words.last?.characters.filter { $0 >=\
    \ 'a' && $0 <= 'z' }.count\n                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    /tmp/tmpyr2zck4w.swift:22:16: error: cannot find 'Err' in scope\n        return\
    \ Err(letters)\n               ^~~\n/tmp/tmpyr2zck4w.swift:24:12: error: cannot\
    \ find 'Ok' in scope\n    return Ok(words.dropLast())\n           ^~\n"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(0))\n    }\n    let wordCount\
    \ = words.count\n    let wordCountWithCommas = wordCount + words.count - 1\n \
    \   let wordCountWithCommasWithOddOrder = wordCountWithCommas + words.count -\
    \ 1\n    if wordCountWithCommasWithOddOrder % 2 == 1 {\n        return Err(Int(0))\n\
    \    }\n    let wordCountWithCommasWithOddOrderWithOddOrder = wordCountWithCommasWithOddOrder\
    \ + 1\n    if wordCountWithCommasWithOddOrderWithOddOrder % 2 == 1 {\n       \
    \ return Err(Int(0))\n    }\n    return Ok(words.map { $0.trimmingCharacters(in:\
    \ .whitespaces) })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpvlztqpl7.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpvlztqpl7.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(0))\n               ^~~\n/tmp/tmpvlztqpl7.swift:20:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(0))\n            \
    \   ^~~\n/tmp/tmpvlztqpl7.swift:24:16: error: cannot find 'Err' in scope\n   \
    \     return Err(Int(0))\n               ^~~\n/tmp/tmpvlztqpl7.swift:26:12: error:\
    \ cannot find 'Ok' in scope\n    return Ok(words.map { $0.trimmingCharacters(in:\
    \ .whitespaces) })\n           ^~\n/tmp/tmpvlztqpl7.swift:26:54: error: cannot\
    \ infer contextual base in reference to member 'whitespaces'\n    return Ok(words.map\
    \ { $0.trimmingCharacters(in: .whitespaces) })\n                             \
    \                       ~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054237
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(0))\n    }\n    let wordCount\
    \ = words.count\n    let letterCount = words.map { $0.count }.reduce(0, +)\n \
    \   if letterCount % 2 == 1 {\n        return Err(Int(letterCount))\n    }\n \
    \   let letterCount = letterCount / 2\n    let letters = words.map { $0.lowercased()\
    \ }\n    return Ok(letters.prefix(letterCount).map(String.init))\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpfa9tfs5k.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpfa9tfs5k.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(0))\n               ^~~\n/tmp/tmpfa9tfs5k.swift:19:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(letterCount))\n  \
    \             ^~~\n/tmp/tmpfa9tfs5k.swift:23:12: error: cannot find 'Ok' in scope\n\
    \    return Ok(letters.prefix(letterCount).map(String.init))\n           ^~\n"
  stdout: ''
  timestamp: 1660054237
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    guard words.count > 0 else { return Err(0) }\n    let wordCount = words.count\n\
    \    let wordCountWithCommas = wordCount + words.count - 1\n    let wordCountWithCommasWithOddOrder\
    \ = wordCountWithCommas + words.count - 1\n    let wordCountWithCommasWithOddOrderWithOddLetter\
    \ = wordCountWithCommasWithOddOrder + words.count - 1\n    guard wordCountWithCommasWithOddOrderWithOddLetter\
    \ >= 26 && wordCountWithCommasWithOddOrderWithOddLetter < 26 else {\n        return\
    \ Err(wordCountWithCommasWithOddOrderWithOddLetter)\n    }\n    return Ok(words)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp70k1frm6.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp70k1frm6.swift:13:41: error: cannot find 'Err'\
    \ in scope\n    guard words.count > 0 else { return Err(0) }\n               \
    \                         ^~~\n/tmp/tmp70k1frm6.swift:19:16: error: cannot find\
    \ 'Err' in scope\n        return Err(wordCountWithCommasWithOddOrderWithOddLetter)\n\
    \               ^~~\n/tmp/tmp70k1frm6.swift:21:12: error: cannot find 'Ok' in\
    \ scope\n    return Ok(words)\n           ^~\n"
  stdout: ''
  timestamp: 1660054237
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(.letters.rawValue))\n   \
    \ }\n    if words.count == 1 {\n        return Ok(words)\n    }\n    let wordCount\
    \ = words.count\n    let wordCount = wordCount.map { $0.count }\n    let wordCount\
    \ = wordCount.filter { $0 % 2 == 1 }\n    if wordCount.count == 0 {\n        return\
    \ Err(Int(.letters.rawValue))\n    }\n    if wordCount.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let wordCount = wordCount.map { $0.count }\n    let wordCount\
    \ = wordCount.filter { $0 % 2 == 1 }\n    if wordCount.count == 0 {\n        return\
    \ Err(Int(.letters.rawValue))\n    }\n    if wordCount.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let wordCount = wordCount.map { $0.count }\n    let wordCount\
    \ = wordCount.filter { $0 % 2 == 1 }\n    if wordCount.count == 0 {\n        return\
    \ Err(Int(.letters.rawValue))\n    }\n    if wordCount.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let wordCount = wordCount.map { $0.count }\n    let wordCount\
    \ = wordCount.filter { $0 % 2 == 1 }\n    if wordCount.count == 0 {\n        return\
    \ Err(Int(.letters.rawValue))\n    }\n    if wordCount.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let wordCount = wordCount.map { $0.count }\n    let wordCount\
    \ = wordCount.filter { $0 % 2 == 1 }\n    if wordCount.count == 0 {\n        return\
    \ Err(Int(.letters.rawValue))\n    }\n    if wordCount.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let wordCount = wordCount.map { $0.count }\n    let wordCount\
    \ = wordCount.filter { $0 % 2 == 1 }\n    if wordCount.count == 0 {\n        return\
    \ Err(Int(.letters.rawValue))\n    }\n    if wordCount.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let wordCount = wordCount.map { $0.count }\n    let wordCount\
    \ = wordCount.filter { $0 % 2 == 1 }\n    if wordCount.count == 0 {\n        return\
    \ Err(Int(.letters.rawValue))\n    }\n    if wordCount.count == 1 {\n        return\
    \ Ok(words)\n    }\n    let wordCount = wordCount.map { $0.count }\n    let wordCount\
    \ = wordCount.filter { $0 % 2 == 1 }\n    if word\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp7_8ze6xx.swift:78:12: error: expected '{' after 'if' condition\n\
    \    if word\n           ^\n/tmp/tmp7_8ze6xx.swift:12:21: error: value of type\
    \ 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmp7_8ze6xx.swift:14:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(.letters.rawValue))\n   \
    \            ^~~\n/tmp/tmp7_8ze6xx.swift:14:25: error: reference to member 'letters'\
    \ cannot be resolved without a contextual type\n        return Err(Int(.letters.rawValue))\n\
    \                        ^\n/tmp/tmp7_8ze6xx.swift:17:16: error: cannot find 'Ok'\
    \ in scope\n        return Ok(words)\n               ^~\n/tmp/tmp7_8ze6xx.swift:23:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(.letters.rawValue))\n\
    \               ^~~\n/tmp/tmp7_8ze6xx.swift:23:25: error: reference to member\
    \ 'letters' cannot be resolved without a contextual type\n        return Err(Int(.letters.rawValue))\n\
    \                        ^\n/tmp/tmp7_8ze6xx.swift:26:16: error: cannot find 'Ok'\
    \ in scope\n        return Ok(words)\n               ^~\n/tmp/tmp7_8ze6xx.swift:31:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(.letters.rawValue))\n\
    \               ^~~\n/tmp/tmp7_8ze6xx.swift:31:25: error: reference to member\
    \ 'letters' cannot be resolved without a contextual type\n        return Err(Int(.letters.rawValue))\n\
    \                        ^\n/tmp/tmp7_8ze6xx.swift:34:16: error: cannot find 'Ok'\
    \ in scope\n        return Ok(words)\n               ^~\n/tmp/tmp7_8ze6xx.swift:39:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(.letters.rawValue))\n\
    \               ^~~\n/tmp/tmp7_8ze6xx.swift:39:25: error: reference to member\
    \ 'letters' cannot be resolved without a contextual type\n        return Err(Int(.letters.rawValue))\n\
    \                        ^\n/tmp/tmp7_8ze6xx.swift:42:16: error: cannot find 'Ok'\
    \ in scope\n        return Ok(words)\n               ^~\n/tmp/tmp7_8ze6xx.swift:47:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(.letters.rawValue))\n\
    \               ^~~\n/tmp/tm"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.components(separatedBy:\
    \ \" \") else {\n        return Err(Int(.init(rawValue: 1))) // no whitespaces\
    \ exists in the text\n    }\n    \n    var words: [String] = []\n    \n    for\
    \ word in words {\n        if let word = word.lowercased() {\n            if word.count\
    \ % 2 == 1 {\n                words.append(word)\n            }\n        }\n \
    \   }\n    \n    return Ok(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpk_l4_jbc.swift:12:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmpk_l4_jbc.swift:13:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(.init(rawValue: 1))) // no\
    \ whitespaces exists in the text\n               ^~~\n/tmp/tmpk_l4_jbc.swift:13:25:\
    \ error: reference to member 'init' cannot be resolved without a contextual type\n\
    \        return Err(Int(.init(rawValue: 1))) // no whitespaces exists in the text\n\
    \                        ^\n/tmp/tmpk_l4_jbc.swift:19:12: error: initializer for\
    \ conditional binding must have Optional type, not 'String'\n        if let word\
    \ = word.lowercased() {\n           ^          ~~~~~~~~~~~~~~~~~\n/tmp/tmpk_l4_jbc.swift:26:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words)\n           ^~\n"
  stdout: ''
  timestamp: 1660054237
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(0)\n    }\n    let firstWord\
    \ = words[0]\n    let lastWord = words[words.count - 1]\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return Err(firstWord.characters.count)\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return Err(lastWord.characters.count)\n    }\n    if firstWord.hasSuffix(\"\
    !\") {\n        return Err(firstWord.characters.count)\n    }\n    if lastWord.hasPrefix(\"\
    !\") {\n        return Err(lastWord.characters.count)\n    }\n    if firstWord.hasPrefix(\"\
    \\\"\") {\n        return Err(firstWord.characters.count)\n    }\n    if lastWord.hasSuffix(\"\
    \\\"\") {\n        return Err(lastWord.characters.count)\n    }\n    if firstWord.hasPrefix(\"\
    '\") {\n        return Err(firstWord.characters.count)\n    }\n    if lastWord.hasSuffix(\"\
    '\") {\n        return Err(lastWord.characters.count)\n    }\n    if firstWord.hasPrefix(\"\
    (\") {\n        return Err(firstWord.characters.count)\n    }\n    if lastWord.hasSuffix(\"\
    (\") {\n        return Err(lastWord.characters.count)\n    }\n    if firstWord.hasPrefix(\"\
    [\") {\n        return Err(firstWord.characters.count)\n    }\n    if lastWord.hasSuffix(\"\
    [\") {\n        return Err(lastWord.characters.count)\n    }\n    if firstWord.hasPrefix(\"\
    {\") {\n        return Err(firstWord.characters.count)\n    }\n    if lastWord.hasSuffix(\"\
    {\") {\n        return Err(lastWord.characters.count)\n    }\n    if firstWord.hasPrefix(\"\
    (\") {\n        return Err(firstWord.characters.count)\n    }\n    if lastWord.hasSuffix(\"\
    (\") {\n        return Err(lastWord.characters.count)\n    }\n    if firstWord.hasPrefix(\"\
    [\") {\n        return Err(firstWord.characters.count)\n    }\n    if lastWord.hasSuffix(\"\
    [\") {\n        return Err(lastWord.characters.count)\n    }\n    if firstWord.hasPrefix(\"\
    {\") {\n        return Err(firstWord.characters.count)\n    }\n    if lastWord.hasSuffix(\"\
    {\") {\n        return Err(lastWord.characters.count)\n    }\n    if firstWord.hasPrefix(\"\
    (\") {\n        return Err(firstWord.characters.count)\n    }\n    if lastWord.hasSuffix(\"\
    (\") {\n        return Err(lastWord.characters.count)\n    }\n    if firstWord.hasPrefix(\"\
    [\") {\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello\
    \ world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"\
    Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpt0xm8im9.swift:107:44: error: expected '}' at end of brace statement\n\
    assert(split_words(txt: \"\") == .failure(0))\n                              \
    \             ^\n/tmp/tmpt0xm8im9.swift:11:56: note: to match this opening '{'\n\
    func split_words(txt: String) -> Result<[String], Int> {\n                   \
    \                                    ^\n/tmp/tmpt0xm8im9.swift:12:21: error: value\
    \ of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmpt0xm8im9.swift:14:16: error:\
    \ cannot find 'Err' in scope\n        return Err(0)\n               ^~~\n/tmp/tmpt0xm8im9.swift:19:16:\
    \ error: cannot find 'Err' in scope\n        return Err(firstWord.characters.count)\n\
    \               ^~~\n/tmp/tmpt0xm8im9.swift:22:16: error: cannot find 'Err' in\
    \ scope\n        return Err(lastWord.characters.count)\n               ^~~\n/tmp/tmpt0xm8im9.swift:25:16:\
    \ error: cannot find 'Err' in scope\n        return Err(firstWord.characters.count)\n\
    \               ^~~\n/tmp/tmpt0xm8im9.swift:28:16: error: cannot find 'Err' in\
    \ scope\n        return Err(lastWord.characters.count)\n               ^~~\n/tmp/tmpt0xm8im9.swift:31:16:\
    \ error: cannot find 'Err' in scope\n        return Err(firstWord.characters.count)\n\
    \               ^~~\n/tmp/tmpt0xm8im9.swift:34:16: error: cannot find 'Err' in\
    \ scope\n        return Err(lastWord.characters.count)\n               ^~~\n/tmp/tmpt0xm8im9.swift:37:16:\
    \ error: cannot find 'Err' in scope\n        return Err(firstWord.characters.count)\n\
    \               ^~~\n/tmp/tmpt0xm8im9.swift:40:16: error: cannot find 'Err' in\
    \ scope\n        return Err(lastWord.characters.count)\n               ^~~\n/tmp/tmpt0xm8im9.swift:43:16:\
    \ error: cannot find 'Err' in scope\n        return Err(firstWord.characters.count)\n\
    \               ^~~\n/tmp/tmpt0xm8im9.swift:46:16: error: cannot find 'Err' in\
    \ scope\n        return Err(lastWord.characters.count)\n               ^~~\n/tmp/tmpt0xm8im9.swift:49:16:\
    \ error: cannot find 'Err' in scope\n        return Err(firstWord.characters.count)\n\
    \               ^~~\n/tmp/tmpt"
  stdout: ''
  timestamp: 1660054237
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    guard !words.isEmpty else { return Err(0) }\n    let comma = words.firstIndex(where:\
    \ { $0 == \",\" })\n    let commaCount = comma == nil ? words.count : comma!\n\
    \    let lowercaseCount = words.count - commaCount\n    let lowercaseLetters =\
    \ lowercaseCount % 2\n    let lowercaseLettersCount = lowercaseLetters == 0 ?\
    \ lowercaseCount / 2 : lowercaseCount / 2\n    let lowercaseLettersCount = lowercaseLettersCount\
    \ == 0 ? 1 : lowercaseLettersCount\n    return Ok([words[0..<commaCount], words[commaCount+1..<words.count],\
    \ lowercaseLettersCount])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp009s0qm1.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp009s0qm1.swift:13:40: error: cannot find 'Err'\
    \ in scope\n    guard !words.isEmpty else { return Err(0) }\n                \
    \                       ^~~\n/tmp/tmp009s0qm1.swift:20:12: error: cannot find\
    \ 'Ok' in scope\n    return Ok([words[0..<commaCount], words[commaCount+1..<words.count],\
    \ lowercaseLettersCount])\n           ^~\n"
  stdout: ''
  timestamp: 1660054237
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(1))\n    }\n    if words.count\
    \ == 1 {\n        return Ok(words)\n    }\n    let comma = words.last!.components(separatedBy:\
    \ \",\")\n    if comma.count == 0 {\n        return Ok(words)\n    }\n    if comma.count\
    \ == 1 {\n        return Ok(words + [comma])\n    }\n    let letters = words.map\
    \ { $0.lowercased().count }\n    let odd = letters.filter { $0 % 2 == 1 }\n  \
    \  if odd.count == 0 {\n        return Ok(words)\n    }\n    return Err(Int(odd.count))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpadz3koop.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpadz3koop.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(1))\n               ^~~\n/tmp/tmpadz3koop.swift:17:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpadz3koop.swift:21:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpadz3koop.swift:24:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words + [comma])\n               ^~\n/tmp/tmpadz3koop.swift:29:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpadz3koop.swift:31:12: error: cannot find 'Err' in scope\n    return Err(Int(odd.count))\n\
    \           ^~~\n"
  stdout: ''
  timestamp: 1660054237
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(0))\n    }\n    let wordCount\
    \ = words.count\n    let wordCountWithCommas = wordCount + words.count - 1\n \
    \   let wordCountWithCommasWithOddOrder = wordCountWithCommas + words.count -\
    \ 1\n    let wordCountWithCommasWithOddOrderWithOddOrder = wordCountWithCommasWithOddOrder\
    \ + words.count - 1\n    let wordCountWithCommasWithOddOrderWithOddOrderWithOddOrder\
    \ = wordCountWithCommasWithOddOrderWithOddOrder + words.count - 1\n    let wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrder\
    \ = wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrder + words.count\
    \ - 1\n    return Ok([words]) // TODO: return Err(Int(0)) when wordCount is 0\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpcr37jcdh.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpcr37jcdh.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(0))\n               ^~~\n/tmp/tmpcr37jcdh.swift:21:79:\
    \ error: use of local variable 'wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrder'\
    \ before its declaration\n    let wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrder\
    \ = wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrder + words.count\
    \ - 1\n                                                                      \
    \        ^\n/tmp/tmpcr37jcdh.swift:21:9: note: 'wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrder'\
    \ declared here\n    let wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrder\
    \ = wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrder + words.count\
    \ - 1\n        ^\n/tmp/tmpcr37jcdh.swift:22:12: error: cannot find 'Ok' in scope\n\
    \    return Ok([words]) // TODO: return Err(Int(0)) when wordCount is 0\n    \
    \       ^~\n"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    \n    guard let words = txt.split(separator:\
    \ \" \") else {\n        return Err(Int(rawValue: 1))\n    }\n    \n    guard\
    \ let words2 = words.split(separator: \",\") else {\n        return Err(Int(rawValue:\
    \ 2))\n    }\n    \n    let words3 = words2.map({ $0.lowercased() })\n    \n \
    \   guard let words4 = words3.filter({ $0.count % 2 == 1 }) else {\n        return\
    \ Err(Int(rawValue: 3))\n    }\n    \n    guard let words5 = words4.filter({ $0.count\
    \ % 2 == 0 }) else {\n        return Err(Int(rawValue: 4))\n    }\n    \n    return\
    \ Ok(words5)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpytofcge3.swift:14:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(rawValue: 1))\n               ^~~\n/tmp/tmpytofcge3.swift:14:23:\
    \ error: extraneous argument label 'rawValue:' in call\n        return Err(Int(rawValue:\
    \ 1))\n                      ^~~~~~~~~~~\n                       \n/tmp/tmpytofcge3.swift:13:11:\
    \ error: initializer for conditional binding must have Optional type, not '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n    guard let words = txt.split(separator: \" \")\
    \ else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpytofcge3.swift:18:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(rawValue: 2))\n  \
    \             ^~~\n/tmp/tmpytofcge3.swift:18:23: error: extraneous argument label\
    \ 'rawValue:' in call\n        return Err(Int(rawValue: 2))\n                \
    \      ^~~~~~~~~~~\n                       \n/tmp/tmpytofcge3.swift:17:11: error:\
    \ initializer for conditional binding must have Optional type, not '[ArraySlice<String.SubSequence>]'\
    \ (aka 'Array<ArraySlice<Substring>>')\n    guard let words2 = words.split(separator:\
    \ \",\") else {\n          ^            ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpytofcge3.swift:21:34:\
    \ error: value of type 'ArraySlice<String.SubSequence>' (aka 'ArraySlice<Substring>')\
    \ has no member 'lowercased'\n    let words3 = words2.map({ $0.lowercased() })\n\
    \                              ~~ ^~~~~~~~~~\n/tmp/tmpytofcge3.swift:24:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(rawValue: 3))\n         \
    \      ^~~\n/tmp/tmpytofcge3.swift:24:23: error: extraneous argument label 'rawValue:'\
    \ in call\n        return Err(Int(rawValue: 3))\n                      ^~~~~~~~~~~\n\
    \                       \n/tmp/tmpytofcge3.swift:28:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(rawValue: 4))\n               ^~~\n/tmp/tmpytofcge3.swift:28:23:\
    \ error: extraneous argument label 'rawValue:' in call\n        return Err(Int(rawValue:\
    \ 4))\n                      ^~~~~~~~~~~\n                       \n/tmp/tmpytofcge3.swift:31:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words5)\n "
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    \n    if words.count == 0 {\n        return Err(0)\n    }\n    \n    var\
    \ result: [String] = []\n    \n    for word in words {\n        let splits = word.components(separatedBy:\
    \ \",\")\n        \n        if splits.count > 0 {\n            for split in splits\
    \ {\n                result.append(split)\n            }\n        } else {\n \
    \           result.append(word)\n        }\n    }\n    \n    if result.count %\
    \ 2 != 0 {\n        return Err(result.count / 2)\n    }\n    \n    return Ok(result)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpi8h0bz5u.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpi8h0bz5u.swift:15:16: error: cannot find 'Err'\
    \ in scope\n        return Err(0)\n               ^~~\n/tmp/tmpi8h0bz5u.swift:33:16:\
    \ error: cannot find 'Err' in scope\n        return Err(result.count / 2)\n  \
    \             ^~~\n/tmp/tmpi8h0bz5u.swift:36:12: error: cannot find 'Ok' in scope\n\
    \    return Ok(result)\n           ^~\n"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(1))\n    }\n    let comma\
    \ = words.last!.components(separatedBy: \",\")\n    if comma.count == 0 {\n  \
    \      return Err(Int(words.count))\n    }\n    let letters = words.map { $0.lowercased().characters.count\
    \ }\n    let odd = letters.filter { $0 % 2 != 0 }\n    return Ok([String](odd.map\
    \ { $0.lowercased() }))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpm161omha.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpm161omha.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(1))\n               ^~~\n/tmp/tmpm161omha.swift:18:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(words.count))\n  \
    \             ^~~\n/tmp/tmpm161omha.swift:22:12: error: cannot find 'Ok' in scope\n\
    \    return Ok([String](odd.map { $0.lowercased() }))\n           ^~\n"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count < 2 {\n        return Err(words.count)\n    }\n    let firstWord\
    \ = words[0]\n    let lastWord = words[words.count - 1]\n    if firstWord.hasPrefix(\"\
    \ \") {\n        return Err(firstWord.count)\n    }\n    if lastWord.hasSuffix(\"\
    \ \") {\n        return Err(lastWord.count)\n    }\n    if firstWord.hasSuffix(\"\
    ,\") {\n        return Err(firstWord.count)\n    }\n    if lastWord.hasPrefix(\"\
    ,\") {\n        return Err(lastWord.count)\n    }\n    if firstWord.hasPrefix(\"\
    \ \") {\n        return Err(firstWord.count)\n    }\n    if lastWord.hasSuffix(\"\
    \ \") {\n        return Err(lastWord.count)\n    }\n    if firstWord.hasPrefix(\"\
    \ \") {\n        return Err(firstWord.count)\n    }\n    if lastWord.hasSuffix(\"\
    \ \") {\n        return Err(lastWord.count)\n    }\n    if firstWord.hasPrefix(\"\
    \ \") {\n        return Err(firstWord.count)\n    }\n    if lastWord.hasSuffix(\"\
    \ \") {\n        return Err(lastWord.count)\n    }\n    if firstWord.hasPrefix(\"\
    \ \") {\n        return Err(firstWord.count)\n    }\n    if lastWord.hasSuffix(\"\
    \ \") {\n        return Err(lastWord.count)\n    }\n    if firstWord.hasPrefix(\"\
    \ \") {\n        return Err(firstWord.count)\n    }\n    if lastWord.hasSuffix(\"\
    \ \") {\n        return Err(lastWord.count)\n    }\n    if firstWord.hasPrefix(\"\
    \ \") {\n        return Err(firstWord.count)\n    }\n    if lastWord.hasSuffix(\"\
    \ \") {\n        return Err(lastWord.count)\n    }\n    if firstWord.hasPrefix(\"\
    \ \") {\n        return Err(firstWord.count)\n    }\n    if lastWord.hasSuffix(\"\
    \ \") {\n        return Err(lastWord.count)\n    }\n    if firstWord.hasPrefix(\"\
    \ \") {\n        return Err(firstWord.count)\n    }\n    if lastWord.hasSuffix(\"\
    \ \") {\n        return Err(lastWord.count)\n    }\n    if firstWord.hasPrefix(\"\
    \ \") {\n        return Err(firstWord.count)\n    }\n    if lastWord.hasSuffix(\"\
    \ \") {\n        return Err(lastWord.count)\n    }\n    if firstWord.hasPrefix(\"\
    \ \") {\n        return Err(firstWord.count)\n    }\n    if lastWord.hasSuffix(\"\
    \ \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\"\
    ) == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world\
    \ !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"\
    abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpbb0uvfpr.swift:87:27: error: unterminated string literal\n    if\
    \ lastWord.hasSuffix(\" \n                          ^\n/tmp/tmpbb0uvfpr.swift:12:21:\
    \ error: value of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmpbb0uvfpr.swift:14:16: error:\
    \ cannot find 'Err' in scope\n        return Err(words.count)\n              \
    \ ^~~\n/tmp/tmpbb0uvfpr.swift:19:16: error: cannot find 'Err' in scope\n     \
    \   return Err(firstWord.count)\n               ^~~\n/tmp/tmpbb0uvfpr.swift:22:16:\
    \ error: cannot find 'Err' in scope\n        return Err(lastWord.count)\n    \
    \           ^~~\n/tmp/tmpbb0uvfpr.swift:25:16: error: cannot find 'Err' in scope\n\
    \        return Err(firstWord.count)\n               ^~~\n/tmp/tmpbb0uvfpr.swift:28:16:\
    \ error: cannot find 'Err' in scope\n        return Err(lastWord.count)\n    \
    \           ^~~\n/tmp/tmpbb0uvfpr.swift:31:16: error: cannot find 'Err' in scope\n\
    \        return Err(firstWord.count)\n               ^~~\n/tmp/tmpbb0uvfpr.swift:34:16:\
    \ error: cannot find 'Err' in scope\n        return Err(lastWord.count)\n    \
    \           ^~~\n/tmp/tmpbb0uvfpr.swift:37:16: error: cannot find 'Err' in scope\n\
    \        return Err(firstWord.count)\n               ^~~\n/tmp/tmpbb0uvfpr.swift:40:16:\
    \ error: cannot find 'Err' in scope\n        return Err(lastWord.count)\n    \
    \           ^~~\n/tmp/tmpbb0uvfpr.swift:43:16: error: cannot find 'Err' in scope\n\
    \        return Err(firstWord.count)\n               ^~~\n/tmp/tmpbb0uvfpr.swift:46:16:\
    \ error: cannot find 'Err' in scope\n        return Err(lastWord.count)\n    \
    \           ^~~\n/tmp/tmpbb0uvfpr.swift:49:16: error: cannot find 'Err' in scope\n\
    \        return Err(firstWord.count)\n               ^~~\n/tmp/tmpbb0uvfpr.swift:52:16:\
    \ error: cannot find 'Err' in scope\n        return Err(lastWord.count)\n    \
    \           ^~~\n/tmp/tmpbb0uvfpr.swift:55:16: error: cannot find 'Err' in scope\n\
    \        return Err(firstWord.count)\n               ^~~\n/tmp/tmpbb0uvfpr.swift:58:16:\
    \ error: cannot find 'Err' in scope\n        return Err(lastWord.count)\n    "
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count < 2 {\n        return Err(0)\n    }\n    let comma = words.last.components(separatedBy:\
    \ \",\")\n    if comma.count == 0 {\n        return Ok(words.map { $0.lowercased()\
    \ })\n    }\n    return Err(comma.count)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpnc3u6vea.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpnc3u6vea.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(0)\n               ^~~\n/tmp/tmpnc3u6vea.swift:18:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words.map { $0.lowercased()\
    \ })\n               ^~\n/tmp/tmpnc3u6vea.swift:20:12: error: cannot find 'Err'\
    \ in scope\n    return Err(comma.count)\n           ^~~\n"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(0)\n    }\n    let comma = words.last!.components(separatedBy:\
    \ \",\")\n    if comma.count == 0 {\n        return Err(words.count + 1)\n   \
    \ }\n    let letters = words.count - 1\n    let odd = letters % 2\n    if odd\
    \ {\n        return Err(letters)\n    }\n    return Ok(words)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp_6t2et10.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp_6t2et10.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(0)\n               ^~~\n/tmp/tmp_6t2et10.swift:18:16:\
    \ error: cannot find 'Err' in scope\n        return Err(words.count + 1)\n   \
    \            ^~~\n/tmp/tmp_6t2et10.swift:23:16: error: cannot find 'Err' in scope\n\
    \        return Err(letters)\n               ^~~\n/tmp/tmp_6t2et10.swift:25:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words)\n           ^~\n"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.components(separatedBy:\
    \ \" \") else {\n        return Err(Int(errorCode: errorCodes.wrongFormat))\n\
    \    }\n    \n    var words: [String] = []\n    for word in words {\n        if\
    \ let word = word.lowercased() {\n            words.append(word)\n        }\n\
    \    }\n    \n    if words.count % 2 == 1 {\n        return Ok(words)\n    }\n\
    \    \n    return Err(Int(errorCode: errorCodes.wrongFormat))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp9wheniec.swift:12:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmp9wheniec.swift:13:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(errorCode: errorCodes.wrongFormat))\n\
    \               ^~~\n/tmp/tmp9wheniec.swift:13:35: error: cannot find 'errorCodes'\
    \ in scope\n        return Err(Int(errorCode: errorCodes.wrongFormat))\n     \
    \                             ^~~~~~~~~~\n/tmp/tmp9wheniec.swift:13:20: error:\
    \ no exact matches in call to initializer \n        return Err(Int(errorCode:\
    \ errorCodes.wrongFormat))\n                   ^\n/tmp/tmp9wheniec.swift:13:20:\
    \ note: found candidate with type '(Float16) -> Int'\n        return Err(Int(errorCode:\
    \ errorCodes.wrongFormat))\n                   ^\n/tmp/tmp9wheniec.swift:13:20:\
    \ note: found candidate with type '(Float) -> Int'\n        return Err(Int(errorCode:\
    \ errorCodes.wrongFormat))\n                   ^\n/tmp/tmp9wheniec.swift:13:20:\
    \ note: found candidate with type '(Double) -> Int'\n        return Err(Int(errorCode:\
    \ errorCodes.wrongFormat))\n                   ^\n/tmp/tmp9wheniec.swift:13:20:\
    \ note: found candidate with type '(Float80) -> Int'\n        return Err(Int(errorCode:\
    \ errorCodes.wrongFormat))\n                   ^\n/tmp/tmp9wheniec.swift:13:20:\
    \ note: found candidate with type '(Builtin.Int64) -> Int'\n        return Err(Int(errorCode:\
    \ errorCodes.wrongFormat))\n                   ^\n/tmp/tmp9wheniec.swift:13:20:\
    \ note: found candidate with type '(Builtin.Word) -> Int'\n        return Err(Int(errorCode:\
    \ errorCodes.wrongFormat))\n                   ^\n/tmp/tmp9wheniec.swift:13:20:\
    \ note: found candidate with type '(String) -> Int?'\n        return Err(Int(errorCode:\
    \ errorCodes.wrongFormat))\n                   ^\n/tmp/tmp9wheniec.swift:18:12:\
    \ error: initializer for conditional binding must have Optional type, not 'String'\n\
    \        if let word = word.lowercased() {\n           ^          ~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp9wheniec.swift:24:16: error: cannot find 'Ok' in sc"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count < 2 {\n        return Err(words.count)\n    }\n    let comma\
    \ = words.last!.components(separatedBy: \",\")\n    if comma.count < 2 {\n   \
    \     return Err(comma.count)\n    }\n    let letters = words.map { $0.lowercased().characters.count\
    \ }\n    return Ok(letters.filter { $0 % 2 == 1 })\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpi4o0elaq.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpi4o0elaq.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(words.count)\n               ^~~\n/tmp/tmpi4o0elaq.swift:18:16:\
    \ error: cannot find 'Err' in scope\n        return Err(comma.count)\n       \
    \        ^~~\n/tmp/tmpi4o0elaq.swift:21:12: error: cannot find 'Ok' in scope\n\
    \    return Ok(letters.filter { $0 % 2 == 1 })\n           ^~\n"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let txt = txt.lowercased() else {\n  \
    \      return Err(Int(.Failure))\n    }\n    let words = txt.components(separatedBy:\
    \ \" \")\n    guard !words.isEmpty else {\n        return Err(Int(.Failure))\n\
    \    }\n    guard let first = words.first else {\n        return Err(Int(.Failure))\n\
    \    }\n    guard let last = words.last else {\n        return Err(Int(.Failure))\n\
    \    }\n    guard let count = txt.unicodeScalars.filter({ $0.isLetter}).count\
    \ else {\n        return Err(Int(.Failure))\n    }\n    guard count % 2 == 1 else\
    \ {\n        return Err(Int(.Failure))\n    }\n    guard let count = txt.unicodeScalars.filter({\
    \ $0.isLetter}).count else {\n        return Err(Int(.Failure))\n    }\n    guard\
    \ count % 2 == 1 else {\n        return Err(Int(.Failure))\n    }\n    guard let\
    \ count = txt.unicodeScalars.filter({ $0.isLetter}).count else {\n        return\
    \ Err(Int(.Failure))\n    }\n    guard count % 2 == 1 else {\n        return Err(Int(.Failure))\n\
    \    }\n    guard let count = txt.unicodeScalars.filter({ $0.isLetter}).count\
    \ else {\n        return Err(Int(.Failure))\n    }\n    guard count % 2 == 1 else\
    \ {\n        return Err(Int(.Failure))\n    }\n    guard let count = txt.unicodeScalars.filter({\
    \ $0.isLetter}).count else {\n        return Err(Int(.Failure))\n    }\n    guard\
    \ count % 2 == 1 else {\n        return Err(Int(.Failure))\n    }\n    guard let\
    \ count = txt.unicodeScalars.filter({ $0.isLetter}).count else {\n        return\
    \ Err(Int(.Failure))\n    }\n    guard count % 2 == 1 else {\n        return Err(Int(.Failure))\n\
    \    }\n    guard let count = txt.unicodeScalars.filter({ $0.isLetter}).count\
    \ else {\n        return Err(Int(.Failure))\n    }\n    guard count % 2 == 1 else\
    \ {\n        return Err(Int(.Failure))\n    }\n    guard let count = txt.unicodeScalars.filter({\
    \ $0.isLetter}).count else {\n        return Err(Int(.Failure))\n    }\n    guard\
    \ count % 2 == 1 else {\n        return Err(Int(.Failure))\n    }\n    guard let\
    \ count = txt.unicodeScalars.filter({ $0.isLetter}).count else {\n        return\
    \ Err(Int(.Failure))\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpqosmw15g.swift:13:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(.Failure))\n               ^~~\n/tmp/tmpqosmw15g.swift:13:24:\
    \ error: missing argument label 'bitPattern:' in call\n        return Err(Int(.Failure))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmpqosmw15g.swift:12:11:\
    \ error: initializer for conditional binding must have Optional type, not 'String'\n\
    \    guard let txt = txt.lowercased() else {\n          ^         ~~~~~~~~~~~~~~~~\n\
    /tmp/tmpqosmw15g.swift:15:21: error: value of type 'String' has no member 'components'\n\
    \    let words = txt.components(separatedBy: \" \")\n                ~~~ ^~~~~~~~~~\n\
    /tmp/tmpqosmw15g.swift:17:16: error: cannot find 'Err' in scope\n        return\
    \ Err(Int(.Failure))\n               ^~~\n/tmp/tmpqosmw15g.swift:17:24: error:\
    \ missing argument label 'bitPattern:' in call\n        return Err(Int(.Failure))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmpqosmw15g.swift:20:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(.Failure))\n     \
    \          ^~~\n/tmp/tmpqosmw15g.swift:20:24: error: missing argument label 'bitPattern:'\
    \ in call\n        return Err(Int(.Failure))\n                       ^\n     \
    \                  bitPattern: \n/tmp/tmpqosmw15g.swift:23:16: error: cannot find\
    \ 'Err' in scope\n        return Err(Int(.Failure))\n               ^~~\n/tmp/tmpqosmw15g.swift:23:24:\
    \ error: missing argument label 'bitPattern:' in call\n        return Err(Int(.Failure))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmpqosmw15g.swift:25:54:\
    \ error: value of type 'Unicode.Scalar' has no member 'isLetter'\n    guard let\
    \ count = txt.unicodeScalars.filter({ $0.isLetter}).count else {\n           \
    \                                       ~~ ^~~~~~~~\n/tmp/tmpqosmw15g.swift:26:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(.Failure))\n     \
    \          ^~~\n/tmp/tmpqosmw15g.swift:26:24: error: missing argument label 'bitPattern:'\
    \ in call\n        return Err(Int(.Failure))\n                       ^\n     \
    \                  "
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.split(separator: \" \"\
    ) else {\n        return Err(Int(errorCode: ErrorCode.invalidArgument))\n    }\n\
    \    \n    var result: [String] = []\n    \n    for word in words {\n        if\
    \ let wordCount = word.split(separator: \",\").count {\n            result.append(word)\n\
    \        } else {\n            result.append(word.lowercased())\n        }\n \
    \   }\n    \n    return Ok(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp15ff26u1.swift:13:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(errorCode: ErrorCode.invalidArgument))\n               ^~~\n\
    /tmp/tmp15ff26u1.swift:13:35: error: cannot find 'ErrorCode' in scope\n      \
    \  return Err(Int(errorCode: ErrorCode.invalidArgument))\n                   \
    \               ^~~~~~~~~\n/tmp/tmp15ff26u1.swift:13:20: error: no exact matches\
    \ in call to initializer \n        return Err(Int(errorCode: ErrorCode.invalidArgument))\n\
    \                   ^\n/tmp/tmp15ff26u1.swift:13:20: note: found candidate with\
    \ type '(Float16) -> Int'\n        return Err(Int(errorCode: ErrorCode.invalidArgument))\n\
    \                   ^\n/tmp/tmp15ff26u1.swift:13:20: note: found candidate with\
    \ type '(Float) -> Int'\n        return Err(Int(errorCode: ErrorCode.invalidArgument))\n\
    \                   ^\n/tmp/tmp15ff26u1.swift:13:20: note: found candidate with\
    \ type '(Double) -> Int'\n        return Err(Int(errorCode: ErrorCode.invalidArgument))\n\
    \                   ^\n/tmp/tmp15ff26u1.swift:13:20: note: found candidate with\
    \ type '(Float80) -> Int'\n        return Err(Int(errorCode: ErrorCode.invalidArgument))\n\
    \                   ^\n/tmp/tmp15ff26u1.swift:13:20: note: found candidate with\
    \ type '(Builtin.Int64) -> Int'\n        return Err(Int(errorCode: ErrorCode.invalidArgument))\n\
    \                   ^\n/tmp/tmp15ff26u1.swift:13:20: note: found candidate with\
    \ type '(Builtin.Word) -> Int'\n        return Err(Int(errorCode: ErrorCode.invalidArgument))\n\
    \                   ^\n/tmp/tmp15ff26u1.swift:13:20: note: found candidate with\
    \ type '(String) -> Int?'\n        return Err(Int(errorCode: ErrorCode.invalidArgument))\n\
    \                   ^\n/tmp/tmp15ff26u1.swift:12:11: error: initializer for conditional\
    \ binding must have Optional type, not '[String.SubSequence]' (aka 'Array<Substring>')\n\
    \    guard let words = txt.split(separator: \" \") else {\n          ^       \
    \    ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp15ff26u1.swift:20:20: error: no exact\
    \ matches in call to instance method 'append'\n            result.append(word)\n\
    \                   ^\nSwift.Array:6:"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    guard words.count > 0 else { return Err(0) }\n    let wordCount = words.count\n\
    \    let wordCountWithCommas = wordCount + words.count - 1\n    let letterCount\
    \ = txt.characters.count\n    let letterCountWithCommas = letterCount + txt.characters.count\
    \ - 1\n    \n    guard letterCountWithCommas % 2 == 0 else {\n        return Err(letterCountWithCommas)\n\
    \    }\n    \n    guard wordCountWithCommas % 2 == 0 else {\n        return Err(wordCountWithCommas)\n\
    \    }\n    \n    guard letterCountWithCommas == wordCountWithCommas else {\n\
    \        return Err(letterCountWithCommas)\n    }\n    \n    let letterCountWithCommasToLower\
    \ = letterCountWithCommas - letterCountWithCommas % 2\n    \n    let wordCountWithCommasToLower\
    \ = wordCountWithCommas - wordCountWithCommas % 2\n    \n    guard letterCountWithCommasToLower\
    \ == wordCountWithCommasToLower else {\n        return Err(letterCountWithCommasToLower)\n\
    \    }\n    \n    return Ok(words.map { $0.trimmingCharacters(in: .whitespacesAndNewlines)\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\"\
    ) == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world\
    \ !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"\
    abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp8tq1hio5.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp8tq1hio5.swift:13:41: error: cannot find 'Err'\
    \ in scope\n    guard words.count > 0 else { return Err(0) }\n               \
    \                         ^~~\n/tmp/tmp8tq1hio5.swift:16:27: error: 'characters'\
    \ is unavailable: Please use String directly\n    let letterCount = txt.characters.count\n\
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp8tq1hio5.swift:17:51: error: 'characters' is unavailable:\
    \ Please use String directly\n    let letterCountWithCommas = letterCount + txt.characters.count\
    \ - 1\n                                                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp8tq1hio5.swift:20:16: error: cannot find\
    \ 'Err' in scope\n        return Err(letterCountWithCommas)\n               ^~~\n\
    /tmp/tmp8tq1hio5.swift:24:16: error: cannot find 'Err' in scope\n        return\
    \ Err(wordCountWithCommas)\n               ^~~\n/tmp/tmp8tq1hio5.swift:28:16:\
    \ error: cannot find 'Err' in scope\n        return Err(letterCountWithCommas)\n\
    \               ^~~\n/tmp/tmp8tq1hio5.swift:36:16: error: cannot find 'Err' in\
    \ scope\n        return Err(letterCountWithCommasToLower)\n               ^~~\n\
    /tmp/tmp8tq1hio5.swift:39:12: error: cannot find 'Ok' in scope\n    return Ok(words.map\
    \ { $0.trimmingCharacters(in: .whitespacesAndNewlines) })\n           ^~\n/tmp/tmp8tq1hio5.swift:39:54:\
    \ error: cannot infer contextual base in reference to member 'whitespacesAndNewlines'\n\
    \    return Ok(words.map { $0.trimmingCharacters(in: .whitespacesAndNewlines)\
    \ })\n                                                    ~^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.components(separatedBy:\
    \ \" \") else {\n        return Err(Int(errorCode: errorCodes.invalidArgument))\n\
    \    }\n    \n    var wordList: [String] = []\n    \n    for word in words {\n\
    \        if let word = word.lowercased() {\n            wordList.append(word)\n\
    \        }\n    }\n    \n    return Ok(wordList)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpht5qtk51.swift:12:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmpht5qtk51.swift:13:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(errorCode: errorCodes.invalidArgument))\n\
    \               ^~~\n/tmp/tmpht5qtk51.swift:13:35: error: cannot find 'errorCodes'\
    \ in scope\n        return Err(Int(errorCode: errorCodes.invalidArgument))\n \
    \                                 ^~~~~~~~~~\n/tmp/tmpht5qtk51.swift:13:20: error:\
    \ no exact matches in call to initializer \n        return Err(Int(errorCode:\
    \ errorCodes.invalidArgument))\n                   ^\n/tmp/tmpht5qtk51.swift:13:20:\
    \ note: found candidate with type '(Float16) -> Int'\n        return Err(Int(errorCode:\
    \ errorCodes.invalidArgument))\n                   ^\n/tmp/tmpht5qtk51.swift:13:20:\
    \ note: found candidate with type '(Float) -> Int'\n        return Err(Int(errorCode:\
    \ errorCodes.invalidArgument))\n                   ^\n/tmp/tmpht5qtk51.swift:13:20:\
    \ note: found candidate with type '(Double) -> Int'\n        return Err(Int(errorCode:\
    \ errorCodes.invalidArgument))\n                   ^\n/tmp/tmpht5qtk51.swift:13:20:\
    \ note: found candidate with type '(Float80) -> Int'\n        return Err(Int(errorCode:\
    \ errorCodes.invalidArgument))\n                   ^\n/tmp/tmpht5qtk51.swift:13:20:\
    \ note: found candidate with type '(Builtin.Int64) -> Int'\n        return Err(Int(errorCode:\
    \ errorCodes.invalidArgument))\n                   ^\n/tmp/tmpht5qtk51.swift:13:20:\
    \ note: found candidate with type '(Builtin.Word) -> Int'\n        return Err(Int(errorCode:\
    \ errorCodes.invalidArgument))\n                   ^\n/tmp/tmpht5qtk51.swift:13:20:\
    \ note: found candidate with type '(String) -> Int?'\n        return Err(Int(errorCode:\
    \ errorCodes.invalidArgument))\n                   ^\n/tmp/tmpht5qtk51.swift:24:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(wordList)\n           ^~\n"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    \n    if words.count == 0 {\n        return Err(Int(1))\n    }\n    \n\
    \    let wordCount = words.count\n    \n    if wordCount == 1 {\n        return\
    \ Ok(words)\n    }\n    \n    let firstWord = words[0]\n    \n    if firstWord.hasPrefix(\"\
    ,\") {\n        let commaWords = firstWord.components(separatedBy: \",\")\n  \
    \      return Ok(commaWords)\n    }\n    \n    if firstWord.hasPrefix(\"\\\"\"\
    ) {\n        let quoteWords = firstWord.components(separatedBy: \"\\\"\")\n  \
    \      return Ok(quoteWords)\n    }\n    \n    if firstWord.hasPrefix(\"'\") {\n\
    \        let singleQuoteWords = firstWord.components(separatedBy: \"'\")\n   \
    \     return Ok(singleQuoteWords)\n    }\n    \n    if firstWord.hasPrefix(\"\
    (\") {\n        let parenWords = firstWord.components(separatedBy: \")\")\n  \
    \      return Ok(parenWords)\n    }\n    \n    if firstWord.hasPrefix(\"[\") {\n\
    \        let bracketWords = firstWord.components(separatedBy: \"[\")\n       \
    \ return Ok(bracketWords)\n    }\n    \n    if firstWord.hasPrefix(\"{\") {\n\
    \        let braceWords = firstWord.components(separatedBy: \"{\")\n        return\
    \ Ok(braceWords)\n    }\n    \n    if firstWord.hasPrefix(\"[\") {\n        let\
    \ bracketWords = firstWord.components(separatedBy: \"[\")\n        return Ok(bracketWords)\n\
    \    }\n    \n    if firstWord.hasPrefix(\"{\") {\n        let braceWords = firstWord.components(separatedBy:\
    \ \"{\")\n        return Ok(braceWords)\n    }\n    \n    if firstWord.hasPrefix(\"\
    {\") {\n        let braceWords = firstWord.components(separatedBy: \"{\")\n  \
    \      return Ok(braceWords)\n    }\n    \n    if firstWord.hasPrefix(\"{\") {\n\
    \        let braceWords = firstWord.components(separatedBy: \"{\")\n        return\
    \ Ok(braceWords)\n    }\n    \n    if firstWord.hasPrefix(\"{\") {\n        let\
    \ braceWords = firstWord.components(separatedBy: \"{\")\n        return Ok(braceWords)\n\
    \    }\n    \n    if firstWord.hasPrefix(\"{\") {\n        let braceWords = firstWord.components(separatedBy:\
    \ \"{\")\n        return Ok(braceWords)\n    }\n    \n    if firstWord.hasPrefix\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpqpu5kdk1.swift:86:27: error: expected '{' after 'if' condition\n\
    \    if firstWord.hasPrefix\n                          ^\n/tmp/tmpqpu5kdk1.swift:12:21:\
    \ error: value of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmpqpu5kdk1.swift:15:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(1))\n               ^~~\n\
    /tmp/tmpqpu5kdk1.swift:21:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpqpu5kdk1.swift:28:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(commaWords)\n               ^~\n/tmp/tmpqpu5kdk1.swift:33:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(quoteWords)\n          \
    \     ^~\n/tmp/tmpqpu5kdk1.swift:38:16: error: cannot find 'Ok' in scope\n   \
    \     return Ok(singleQuoteWords)\n               ^~\n/tmp/tmpqpu5kdk1.swift:43:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(parenWords)\n          \
    \     ^~\n/tmp/tmpqpu5kdk1.swift:48:16: error: cannot find 'Ok' in scope\n   \
    \     return Ok(bracketWords)\n               ^~\n/tmp/tmpqpu5kdk1.swift:53:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(braceWords)\n          \
    \     ^~\n/tmp/tmpqpu5kdk1.swift:58:16: error: cannot find 'Ok' in scope\n   \
    \     return Ok(bracketWords)\n               ^~\n/tmp/tmpqpu5kdk1.swift:63:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(braceWords)\n          \
    \     ^~\n/tmp/tmpqpu5kdk1.swift:68:16: error: cannot find 'Ok' in scope\n   \
    \     return Ok(braceWords)\n               ^~\n/tmp/tmpqpu5kdk1.swift:73:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(braceWords)\n          \
    \     ^~\n/tmp/tmpqpu5kdk1.swift:78:16: error: cannot find 'Ok' in scope\n   \
    \     return Ok(braceWords)\n               ^~\n/tmp/tmpqpu5kdk1.swift:83:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(braceWords)\n          \
    \     ^~\n"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    let count = words.count\n    if count == 0 {\n        return Err(count)\n\
    \    }\n    if count == 1 {\n        return Ok([words[0]])\n    }\n    let first\
    \ = words[0]\n    let last = words[words.count - 1]\n    if let first = first,\n\
    \        let last = last,\n        let first = first.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp_4rddksk.swift:24:1977: error: expected member name following '.'\n\
    \        let first = first.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScala"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.components(separatedBy:\
    \ \" \") else {\n        return Err(Int(.init(rawValue: 10)))\n    }\n    \n \
    \   var result: [String] = []\n    \n    for word in words {\n        if let wordWithoutSpaces\
    \ = word.trimmingCharacters(in: .whitespaces) {\n            result.append(wordWithoutSpaces)\n\
    \        }\n    }\n    \n    if result.count > 0 {\n        return Ok(result)\n\
    \    }\n    \n    if result.count == 0 {\n        return Err(Int(.init(rawValue:\
    \ 10)))\n    }\n    \n    if result.count < 26 {\n        return Err(Int(.init(rawValue:\
    \ 10)))\n    }\n    \n    var resultCount = 0\n    \n    for word in words {\n\
    \        if let wordWithoutSpaces = word.trimmingCharacters(in: .whitespaces)\
    \ {\n            if let count = wordWithoutSpaces.lowercased() {\n           \
    \     resultCount += Int(count)\n            }\n        }\n    }\n    \n    if\
    \ resultCount % 2 == 1 {\n        return Err(Int(.init(rawValue: 10)))\n    }\n\
    \    \n    return Ok(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpnrjzoa2s.swift:12:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmpnrjzoa2s.swift:13:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(.init(rawValue: 10)))\n \
    \              ^~~\n/tmp/tmpnrjzoa2s.swift:13:25: error: reference to member 'init'\
    \ cannot be resolved without a contextual type\n        return Err(Int(.init(rawValue:\
    \ 10)))\n                        ^\n/tmp/tmpnrjzoa2s.swift:25:16: error: cannot\
    \ find 'Ok' in scope\n        return Ok(result)\n               ^~\n/tmp/tmpnrjzoa2s.swift:29:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(.init(rawValue: 10)))\n\
    \               ^~~\n/tmp/tmpnrjzoa2s.swift:29:25: error: reference to member\
    \ 'init' cannot be resolved without a contextual type\n        return Err(Int(.init(rawValue:\
    \ 10)))\n                        ^\n/tmp/tmpnrjzoa2s.swift:33:16: error: cannot\
    \ find 'Err' in scope\n        return Err(Int(.init(rawValue: 10)))\n        \
    \       ^~~\n/tmp/tmpnrjzoa2s.swift:33:25: error: reference to member 'init' cannot\
    \ be resolved without a contextual type\n        return Err(Int(.init(rawValue:\
    \ 10)))\n                        ^\n/tmp/tmpnrjzoa2s.swift:47:16: error: cannot\
    \ find 'Err' in scope\n        return Err(Int(.init(rawValue: 10)))\n        \
    \       ^~~\n/tmp/tmpnrjzoa2s.swift:47:25: error: reference to member 'init' cannot\
    \ be resolved without a contextual type\n        return Err(Int(.init(rawValue:\
    \ 10)))\n                        ^\n/tmp/tmpnrjzoa2s.swift:50:12: error: cannot\
    \ find 'Ok' in scope\n    return Ok(result)\n           ^~\n/tmp/tmpnrjzoa2s.swift:19:65:\
    \ error: cannot infer contextual base in reference to member 'whitespaces'\n \
    \       if let wordWithoutSpaces = word.trimmingCharacters(in: .whitespaces) {\n\
    \                                                               ~^~~~~~~~~~~\n\
    /tmp/tmpnrjzoa2s.swift:39:65: error: cannot infer contextual base in reference\
    \ to member 'whitespaces'\n        if let wordWithoutSpaces = word.trimmingCharacters(in: "
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(0))\n    }\n    if words.count\
    \ == 1 {\n        return Err(Int(1))\n    }\n    if words.count == 2 {\n     \
    \   return Err(Int(2))\n    }\n    if words.count > 2 {\n        return Err(Int(3))\n\
    \    }\n    let letters = words.map { $0.lowercased() }\n    let odd = letters.filter\
    \ { $0 % 2 == 1 }\n    return Ok(odd.count)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp64znv06v.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp64znv06v.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(0))\n               ^~~\n/tmp/tmp64znv06v.swift:17:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(1))\n            \
    \   ^~~\n/tmp/tmp64znv06v.swift:20:16: error: cannot find 'Err' in scope\n   \
    \     return Err(Int(2))\n               ^~~\n/tmp/tmp64znv06v.swift:23:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(3))\n               ^~~\n\
    /tmp/tmp64znv06v.swift:27:12: error: cannot find 'Ok' in scope\n    return Ok(odd.count)\n\
    \           ^~\n"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    let wordCount = words.count\n    let wordCountWithCommas = wordCount +\
    \ words.count - 1\n    let wordCountWithCommasWithOddOrder = wordCountWithCommas\
    \ + words.count - 1\n    let wordCountWithCommasWithOddOrderWithOddLetter = wordCountWithCommasWithOddOrder\
    \ + words.count - 1\n    let wordCountWithCommasWithOddOrderWithOddLetterWithOddLetter\
    \ = wordCountWithCommasWithOddOrderWithOddLetter + words.count - 1\n    \n   \
    \ switch wordCount {\n    case 0:\n        return Err(0)\n    case 1:\n      \
    \  return Ok([words[0]])\n    case 2:\n        return Ok([words[0], words[1]])\n\
    \    case 3:\n        return Ok([words[0], words[1], words[2]])\n    case 4:\n\
    \        return Ok([words[0], words[1], words[2], words[3]])\n    case 5:\n  \
    \      return Ok([words[0], words[1], words[2], words[3], words[4]])\n    case\
    \ 6:\n        return Ok([words[0], words[1], words[2], words[3], words[4], words[5]])\n\
    \    case 7:\n        return Ok([words[0], words[1], words[2], words[3], words[4],\
    \ words[5], words[6]])\n    case 8:\n        return Ok([words[0], words[1], words[2],\
    \ words[3], words[4], words[5], words[6], words[7]])\n    case 9:\n        return\
    \ Ok([words[0], words[1], words[2], words[3], words[4], words[5], words[6], words[7],\
    \ words[8]])\n    case 10:\n        return Ok([words[0], words[1], words[2], words[3],\
    \ words[4], words[5], words[6], words[7], words[8], words[9]])\n    case 11:\n\
    \        return Ok([words[0], words[1], words[2], words[3], words[4], words[5],\
    \ words[6], words[7], words[8], words[9], words[10]])\n    case 12:\n        return\
    \ Ok([words[0], words[1], words[2], words[3], words[4], words[5], words[6], words[7],\
    \ words[8], words[9], words[10], words[11]])\n    case 13:\n        return Ok([words[0],\
    \ words[1], words[2], words[3], words[4], words[5], words[6], words[7], words[8],\
    \ words[9], words[10], words[11], words[12]])\n    case 14:\n        return Ok([words[0],\
    \ words[1], words[2], words[3], words[\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp6ya4pyc5.swift:50:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmp6ya4pyc5.swift:72:44: error: expected '}' at end of brace statement\n\
    assert(split_words(txt: \"\") == .failure(0))\n                              \
    \             ^\n/tmp/tmp6ya4pyc5.swift:11:56: note: to match this opening '{'\n\
    func split_words(txt: String) -> Result<[String], Int> {\n                   \
    \                                    ^\n/tmp/tmp6ya4pyc5.swift:12:21: error: value\
    \ of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmp6ya4pyc5.swift:21:16: error:\
    \ cannot find 'Err' in scope\n        return Err(0)\n               ^~~\n/tmp/tmp6ya4pyc5.swift:23:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok([words[0]])\n          \
    \     ^~\n/tmp/tmp6ya4pyc5.swift:25:16: error: cannot find 'Ok' in scope\n   \
    \     return Ok([words[0], words[1]])\n               ^~\n/tmp/tmp6ya4pyc5.swift:27:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok([words[0], words[1], words[2]])\n\
    \               ^~\n/tmp/tmp6ya4pyc5.swift:29:16: error: cannot find 'Ok' in scope\n\
    \        return Ok([words[0], words[1], words[2], words[3]])\n               ^~\n\
    /tmp/tmp6ya4pyc5.swift:31:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok([words[0], words[1], words[2], words[3], words[4]])\n               ^~\n\
    /tmp/tmp6ya4pyc5.swift:33:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok([words[0], words[1], words[2], words[3], words[4], words[5]])\n         \
    \      ^~\n/tmp/tmp6ya4pyc5.swift:35:16: error: cannot find 'Ok' in scope\n  \
    \      return Ok([words[0], words[1], words[2], words[3], words[4], words[5],\
    \ words[6]])\n               ^~\n/tmp/tmp6ya4pyc5.swift:37:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok([words[0], words[1], words[2], words[3], words[4],\
    \ words[5], words[6], words[7]])\n               ^~\n/tmp/tmp6ya4pyc5.swift:39:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok([words[0], words[1], words[2],\
    \ words[3], words[4], words[5], words[6], words[7], words[8]])\n           "
  stdout: ''
  timestamp: 1660054248
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(.zero))\n    }\n    let wordCount\
    \ = words.count\n    let letterCount = txt.unicodeScalars.filter({ $0.isLetter\
    \ }).count\n    if letterCount == 0 {\n        return Err(Int(.zero))\n    }\n\
    \    if letterCount % 2 == 1 {\n        return Err(Int(.zero))\n    }\n    if\
    \ wordCount % 2 == 1 {\n        return Err(Int(.zero))\n    }\n    return Ok(words.map\
    \ { $0.trimmingCharacters(in: .whitespacesAndNewlines) })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpritsxzm1.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpritsxzm1.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(.zero))\n               ^~~\n/tmp/tmpritsxzm1.swift:17:54:\
    \ error: value of type 'Unicode.Scalar' has no member 'isLetter'\n    let letterCount\
    \ = txt.unicodeScalars.filter({ $0.isLetter }).count\n                       \
    \                           ~~ ^~~~~~~~\n/tmp/tmpritsxzm1.swift:19:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(.zero))\n               ^~~\n\
    /tmp/tmpritsxzm1.swift:22:16: error: cannot find 'Err' in scope\n        return\
    \ Err(Int(.zero))\n               ^~~\n/tmp/tmpritsxzm1.swift:25:16: error: cannot\
    \ find 'Err' in scope\n        return Err(Int(.zero))\n               ^~~\n/tmp/tmpritsxzm1.swift:27:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words.map { $0.trimmingCharacters(in:\
    \ .whitespacesAndNewlines) })\n           ^~\n/tmp/tmpritsxzm1.swift:27:54: error:\
    \ cannot infer contextual base in reference to member 'whitespacesAndNewlines'\n\
    \    return Ok(words.map { $0.trimmingCharacters(in: .whitespacesAndNewlines)\
    \ })\n                                                    ~^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.split(separator: \" \"\
    ) else {\n        return Err(Int(.init(rawValue: 1)).rawValue)\n    }\n    \n\
    \    var result = [String]()\n    \n    for word in words {\n        if let wordCount\
    \ = word.split(separator: \",\").count {\n            result.append(word)\n  \
    \      } else {\n            result.append(word.lowercased())\n        }\n   \
    \ }\n    \n    return Ok(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp24n8arev.swift:13:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(.init(rawValue: 1)).rawValue)\n               ^~~\n/tmp/tmp24n8arev.swift:13:44:\
    \ error: value of type 'Int' has no member 'rawValue'\n        return Err(Int(.init(rawValue:\
    \ 1)).rawValue)\n                   ~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmp24n8arev.swift:13:25:\
    \ error: reference to member 'init' cannot be resolved without a contextual type\n\
    \        return Err(Int(.init(rawValue: 1)).rawValue)\n                      \
    \  ^\n/tmp/tmp24n8arev.swift:12:11: error: initializer for conditional binding\
    \ must have Optional type, not '[String.SubSequence]' (aka 'Array<Substring>')\n\
    \    guard let words = txt.split(separator: \" \") else {\n          ^       \
    \    ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp24n8arev.swift:20:20: error: no exact\
    \ matches in call to instance method 'append'\n            result.append(word)\n\
    \                   ^\nSwift.Array:6:37: note: candidate expects value of type\
    \ 'String' for parameter #1 (got 'String.SubSequence' (aka 'Substring'))\n   \
    \ @inlinable public mutating func append(_ newElement: __owned Element)\n    \
    \                                ^\nSwift.RangeReplaceableCollection:4:37: note:\
    \ candidate expects value of type 'String' for parameter #1 (got 'String.SubSequence'\
    \ (aka 'Substring'))\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Self.Element)\n                                    ^\n/tmp/tmp24n8arev.swift:20:20:\
    \ note: found candidate with type '(__owned String.SubSequence) -> ()' (aka '(__owned\
    \ Substring) -> ()')\n            result.append(word)\n                   ^\n\
    /tmp/tmp24n8arev.swift:19:12: error: initializer for conditional binding must\
    \ have Optional type, not 'Int'\n        if let wordCount = word.split(separator:\
    \ \",\").count {\n           ^               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp24n8arev.swift:26:12: error: cannot find 'Ok' in scope\n    return Ok(result)\n\
    \           ^~\n"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.components(separatedBy:\
    \ \" \") else {\n        return Err(Int(errorCode: ErrorCode.invalidArgument,\
    \ message: \"Invalid argument\"))\n    }\n    var result: [String] = []\n    for\
    \ word in words {\n        if let word = word.lowercased() {\n            result.append(word)\n\
    \        }\n    }\n    if result.count == 0 {\n        return Err(Int(errorCode:\
    \ ErrorCode.invalidArgument, message: \"Invalid argument\"))\n    }\n    if result.count\
    \ == 1 {\n        return result\n    }\n    if result.count % 2 == 1 {\n     \
    \   return Err(Int(errorCode: ErrorCode.invalidArgument, message: \"Invalid argument\"\
    ))\n    }\n    let even = result.count / 2\n    let odd = result.count - even\n\
    \    let alphabet = Array(Array(result.prefix(upTo: even)).joined(separator: \"\
    ,\"))\n    let alphabetOdd = Array(Array(result.prefix(upTo: odd)).joined(separator:\
    \ \",\"))\n    return Ok([alphabet, alphabetOdd])\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpk0s9hkh2.swift:12:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmpk0s9hkh2.swift:13:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(errorCode: ErrorCode.invalidArgument,\
    \ message: \"Invalid argument\"))\n               ^~~\n/tmp/tmpk0s9hkh2.swift:13:35:\
    \ error: cannot find 'ErrorCode' in scope\n        return Err(Int(errorCode: ErrorCode.invalidArgument,\
    \ message: \"Invalid argument\"))\n                                  ^~~~~~~~~\n\
    /tmp/tmpk0s9hkh2.swift:13:71: error: extra argument 'message' in call\n      \
    \  return Err(Int(errorCode: ErrorCode.invalidArgument, message: \"Invalid argument\"\
    ))\n                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpk0s9hkh2.swift:22:16: error: cannot find 'Err' in scope\n        return\
    \ Err(Int(errorCode: ErrorCode.invalidArgument, message: \"Invalid argument\"\
    ))\n               ^~~\n/tmp/tmpk0s9hkh2.swift:22:35: error: cannot find 'ErrorCode'\
    \ in scope\n        return Err(Int(errorCode: ErrorCode.invalidArgument, message:\
    \ \"Invalid argument\"))\n                                  ^~~~~~~~~\n/tmp/tmpk0s9hkh2.swift:22:71:\
    \ error: extra argument 'message' in call\n        return Err(Int(errorCode: ErrorCode.invalidArgument,\
    \ message: \"Invalid argument\"))\n                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpk0s9hkh2.swift:25:16: error: cannot convert return expression of type\
    \ '[String]' to return type 'Result<[String], Int>'\n        return result\n \
    \              ^~~~~~\n/tmp/tmpk0s9hkh2.swift:28:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(errorCode: ErrorCode.invalidArgument, message:\
    \ \"Invalid argument\"))\n               ^~~\n/tmp/tmpk0s9hkh2.swift:28:35: error:\
    \ cannot find 'ErrorCode' in scope\n        return Err(Int(errorCode: ErrorCode.invalidArgument,\
    \ message: \"Invalid argument\"))\n                                  ^~~~~~~~~\n\
    /tmp/tmpk0s9hkh2.swift:28:71: error: extra argument"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let txt = txt.trimmingCharacters(in: .whitespacesAndNewlines)\
    \ else {\n        return Err(Int(.invalidValue))\n    }\n    \n    var words:\
    \ [String] = []\n    \n    for c in txt.unicodeScalars {\n        guard let c\
    \ = c else {\n            continue\n        }\n        \n        switch c {\n\
    \        case .letter:\n            words.append(String(c.value))\n        case\
    \ .whitespace:\n        case .control:\n        case .symbol:\n        case .punctuation:\n\
    \        case .number:\n        case .punctuationSpace:\n        case .controlSpace:\n\
    \        case .nonBreakingSpace:\n        case .enDash:\n        case .emDash:\n\
    \        case .endash:\n        case .emDash:\n        case .enSpace:\n      \
    \  case .emSpace:\n        case .endSpace:\n        case .endParagraph:\n    \
    \    case .paragraphSeparator:\n        case .newline: break\n        default:\n\
    \            words.append(String(c.value))\n        }\n    }\n    \n    if words.isEmpty\
    \ {\n        return Err(Int(.invalidValue))\n    }\n    \n    return Ok(words)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpa596ski8.swift:26:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case .whitespace:\n        ^~~~~~~~~~~~~~~~~\n\
    \                          break\n/tmp/tmpa596ski8.swift:27:9: error: 'case' label\
    \ in a 'switch' must have at least one executable statement\n        case .control:\n\
    \        ^~~~~~~~~~~~~~\n                       break\n/tmp/tmpa596ski8.swift:28:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case .symbol:\n        ^~~~~~~~~~~~~\n                      break\n/tmp/tmpa596ski8.swift:29:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case .punctuation:\n        ^~~~~~~~~~~~~~~~~~\n                    \
    \       break\n/tmp/tmpa596ski8.swift:30:9: error: 'case' label in a 'switch'\
    \ must have at least one executable statement\n        case .number:\n       \
    \ ^~~~~~~~~~~~~\n                      break\n/tmp/tmpa596ski8.swift:31:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case .punctuationSpace:\n        ^~~~~~~~~~~~~~~~~~~~~~~\n             \
    \                   break\n/tmp/tmpa596ski8.swift:32:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case .controlSpace:\n\
    \        ^~~~~~~~~~~~~~~~~~~\n                            break\n/tmp/tmpa596ski8.swift:33:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case .nonBreakingSpace:\n        ^~~~~~~~~~~~~~~~~~~~~~~\n          \
    \                      break\n/tmp/tmpa596ski8.swift:34:9: error: 'case' label\
    \ in a 'switch' must have at least one executable statement\n        case .enDash:\n\
    \        ^~~~~~~~~~~~~\n                      break\n/tmp/tmpa596ski8.swift:35:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case .emDash:\n        ^~~~~~~~~~~~~\n                      break\n/tmp/tmpa596ski8.swift:36:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case .endash:\n        ^~~~~~~~~~~~~"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count < 2 {\n        return Err(words.count)\n    }\n    let comma\
    \ = words.last\n    let letters = words.dropLast()\n    let letterCount = letters.count\n\
    \    let letterCountOdd = letterCount % 2 == 1 ? letterCount / 2 : 0\n    let\
    \ letterCountEven = letterCount / 2\n    let letterCountEvenOdd = letterCountEven\
    \ % 2 == 1 ? letterCountEven / 2 : 0\n    \n    if letterCountEvenOdd > 0 {\n\
    \        return Err(letterCountEvenOdd)\n    }\n    \n    if letterCountOdd >\
    \ 0 {\n        return Err(letterCountOdd)\n    }\n    \n    if letterCount > 0\
    \ {\n        return Err(letterCount)\n    }\n    \n    if comma != nil {\n   \
    \     return Err(letterCount)\n    }\n    \n    return Ok(words)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp7gkwg9wt.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp7gkwg9wt.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(words.count)\n               ^~~\n/tmp/tmp7gkwg9wt.swift:24:16:\
    \ error: cannot find 'Err' in scope\n        return Err(letterCountEvenOdd)\n\
    \               ^~~\n/tmp/tmp7gkwg9wt.swift:28:16: error: cannot find 'Err' in\
    \ scope\n        return Err(letterCountOdd)\n               ^~~\n/tmp/tmp7gkwg9wt.swift:32:16:\
    \ error: cannot find 'Err' in scope\n        return Err(letterCount)\n       \
    \        ^~~\n/tmp/tmp7gkwg9wt.swift:36:16: error: cannot find 'Err' in scope\n\
    \        return Err(letterCount)\n               ^~~\n/tmp/tmp7gkwg9wt.swift:39:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words)\n           ^~\n"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.split(separator: \" \"\
    ) else {\n        return Err(Int(errorCode: ErrorCode.invalidArgument.rawValue,\
    \ errorMessage: \"Invalid argument\"))\n    }\n    \n    var words: [String] =\
    \ []\n    for word in words {\n        guard let letters = word.split(separator:\
    \ \",\") else {\n            return Err(Int(errorCode: ErrorCode.invalidArgument.rawValue,\
    \ errorMessage: \"Invalid argument\"))\n        }\n        \n        for letter\
    \ in letters {\n            guard let letter = letter.lowercased() else {\n  \
    \              return Err(Int(errorCode: ErrorCode.invalidArgument.rawValue, errorMessage:\
    \ \"Invalid argument\"))\n            }\n            \n            if let index\
    \ = words.firstIndex(of: letter) {\n                words[index] = words[index]\
    \ + letter\n            } else {\n                words.append(letter)\n     \
    \       }\n        }\n    }\n    \n    return Ok(words)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpyr2dmdr9.swift:13:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(errorCode: ErrorCode.invalidArgument.rawValue, errorMessage:\
    \ \"Invalid argument\"))\n               ^~~\n/tmp/tmpyr2dmdr9.swift:13:35: error:\
    \ cannot find 'ErrorCode' in scope\n        return Err(Int(errorCode: ErrorCode.invalidArgument.rawValue,\
    \ errorMessage: \"Invalid argument\"))\n                                  ^~~~~~~~~\n\
    /tmp/tmpyr2dmdr9.swift:13:85: error: extra argument 'errorMessage' in call\n \
    \       return Err(Int(errorCode: ErrorCode.invalidArgument.rawValue, errorMessage:\
    \ \"Invalid argument\"))\n                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpyr2dmdr9.swift:12:11: error: initializer for conditional binding must\
    \ have Optional type, not '[String.SubSequence]' (aka 'Array<Substring>')\n  \
    \  guard let words = txt.split(separator: \" \") else {\n          ^         \
    \  ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpyr2dmdr9.swift:16:9: error: invalid redeclaration\
    \ of 'words'\n    var words: [String] = []\n        ^\n/tmp/tmpyr2dmdr9.swift:12:15:\
    \ note: 'words' previously declared here\n    guard let words = txt.split(separator:\
    \ \" \") else {\n              ^\n/tmp/tmpyr2dmdr9.swift:35:12: error: cannot\
    \ find 'Ok' in scope\n    return Ok(words)\n           ^~\n"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    guard !words.isEmpty else { return Err(0) }\n    guard !words.contains(\"\
    ,\") else { return Err(0) }\n    guard !words.contains(\".\") else { return Err(0)\
    \ }\n    guard !words.contains(\"!\") else { return Err(0) }\n    guard !words.contains(\"\
    ?\") else { return Err(0) }\n    guard !words.contains(\":\") else { return Err(0)\
    \ }\n    guard !words.contains(\";\") else { return Err(0) }\n    guard !words.contains(\"\
    :\") else { return Err(0) }\n    guard !words.contains(\"<\") else { return Err(0)\
    \ }\n    guard !words.contains(\"=\") else { return Err(0) }\n    guard !words.contains(\"\
    >\") else { return Err(0) }\n    guard !words.contains(\",\") else { return Err(0)\
    \ }\n    guard !words.contains(\".\") else { return Err(0) }\n    guard !words.contains(\"\
    !\") else { return Err(0) }\n    guard !words.contains(\"?\") else { return Err(0)\
    \ }\n    guard !words.contains(\":\") else { return Err(0) }\n    guard !words.contains(\"\
    ;\") else { return Err(0) }\n    guard !words.contains(\":\") else { return Err(0)\
    \ }\n    guard !words.contains(\"<\") else { return Err(0) }\n    guard !words.contains(\"\
    =\") else { return Err(0) }\n    guard !words.contains(\">\") else { return Err(0)\
    \ }\n    guard !words.contains(\",\") else { return Err(0) }\n    guard !words.contains(\"\
    .\") else { return Err(0) }\n    guard !words.contains(\"!\") else { return Err(0)\
    \ }\n    guard !words.contains(\"?\") else { return Err(0) }\n    guard !words.contains(\"\
    :\") else { return Err(0) }\n    guard !words.contains(\";\") else { return Err(0)\
    \ }\n    guard !words.contains(\":\") else { return Err(0) }\n    guard !words.contains(\"\
    <\") else { return Err(0) }\n    guard !words.contains(\"=\") else { return Err(0)\
    \ }\n    guard !words.contains(\">\") else { return Err(0) }\n    guard !words.contains(\"\
    ,\") \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello\
    \ world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"\
    Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpzqnfsvoq.swift:44:31: error: expected 'else' after 'guard' condition\n\
    \    guard !words.contains(\",\") \n                              ^\n/tmp/tmpzqnfsvoq.swift:12:21:\
    \ error: value of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmpzqnfsvoq.swift:13:40: error:\
    \ cannot find 'Err' in scope\n    guard !words.isEmpty else { return Err(0) }\n\
    \                                       ^~~\n/tmp/tmpzqnfsvoq.swift:14:46: error:\
    \ cannot find 'Err' in scope\n    guard !words.contains(\",\") else { return Err(0)\
    \ }\n                                             ^~~\n/tmp/tmpzqnfsvoq.swift:15:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\".\") else { return\
    \ Err(0) }\n                                             ^~~\n/tmp/tmpzqnfsvoq.swift:16:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\"!\") else { return\
    \ Err(0) }\n                                             ^~~\n/tmp/tmpzqnfsvoq.swift:17:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\"?\") else { return\
    \ Err(0) }\n                                             ^~~\n/tmp/tmpzqnfsvoq.swift:18:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\":\") else { return\
    \ Err(0) }\n                                             ^~~\n/tmp/tmpzqnfsvoq.swift:19:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\";\") else { return\
    \ Err(0) }\n                                             ^~~\n/tmp/tmpzqnfsvoq.swift:20:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\":\") else { return\
    \ Err(0) }\n                                             ^~~\n/tmp/tmpzqnfsvoq.swift:21:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\"<\") else { return\
    \ Err(0) }\n                                             ^~~\n/tmp/tmpzqnfsvoq.swift:22:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\"=\") else { return\
    \ Err(0) }\n                                             ^~~\n/tmp/tmpzqnfsvoq.swift:23:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.c"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(0)\n    }\n    \n    var result:\
    \ [String] = []\n    \n    for word in words {\n        let wordSplit = word.components(separatedBy:\
    \ \",\")\n        if wordSplit.count == 0 {\n            return Err(0)\n     \
    \   }\n        \n        for wordSplit2 in wordSplit {\n            let wordSplit3\
    \ = wordSplit2.components(separatedBy: \" \")\n            if wordSplit3.count\
    \ == 0 {\n                return Err(0)\n            }\n            \n       \
    \     for wordSplit4 in wordSplit3 {\n                let wordSplit5 = wordSplit4.components(separatedBy:\
    \ \"\")\n                if wordSplit5.count == 0 {\n                    return\
    \ Err(0)\n                }\n                \n                for wordSplit6\
    \ in wordSplit5 {\n                    let wordSplit7 = wordSplit6.components(separatedBy:\
    \ \"\")\n                    if wordSplit7.count == 0 {\n                    \
    \    return Err(0)\n                    }\n                    \n            \
    \        for wordSplit8 in wordSplit7 {\n                        let wordSplit9\
    \ = wordSplit8.components(separatedBy: \"\")\n                        if wordSplit9.count\
    \ == 0 {\n                            return Err(0)\n                        }\n\
    \                        \n                        for wordSplit10 in wordSplit9\
    \ {\n                            let wordSplit11 = wordSplit10.components(separatedBy:\
    \ \"\")\n                            if wordSplit11.count == 0 {\n           \
    \                     return Err(0)\n                            }\n         \
    \                   \n                            for wordSplit12 in wordSplit11\
    \ {\n                                let wordSplit13 = wordSplit12.components(separatedBy:\
    \ \"\")\n                                if wordSplit13.count == 0 {\n       \
    \                             return Err(0)\n                                }\n\
    \                                \n                                for wordSplit14\
    \ in wordSplit13 {\n                                    let wordSplit15 = wordSplit14.components(separatedBy:\
    \ \"\")\n                                    if wordSplit15.count == 0 {\n   \
    \                                     return Err(0)\n                        \
    \            }\n                                    \n                       \
    \             for wordSplit16 in wordSplit15 {\n                             \
    \           let wordSplit17 = wordSplit16.components(separatedBy: \"\")\n    \
    \                                    if wordSplit17.count == 0 {\n           \
    \                                 return Err(0)\n                            \
    \            }\n                                        \n                   \
    \                     for wordSplit18 in wordSplit17 {\n                     \
    \                       let wordSplit19 = wordSplit18.components(separatedBy:\
    \ \"\")\n                                            if wordSplit19.count == 0\
    \ {\n                                                return Err(0)\n         \
    \                                   }\n                                      \
    \      \n                                            for wordSplit20 in wordSplit19\
    \ {\n                                                let wordSplit21 = wordSplit20.components(separatedBy:\
    \ \"\")\n                                                if wordSplit21.count\
    \ == 0 {\n                                                    return Err(0)\n\
    \                                                }\n                         \
    \                       \n                                                for\
    \ wordSplit22 in wordSplit21 {\n                                             \
    \       let wordSplit23\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpwmqs76kj.swift:109:44: error: expected '}' at end of brace statement\n\
    assert(split_words(txt: \"\") == .failure(0))\n                              \
    \             ^\n/tmp/tmpwmqs76kj.swift:79:76: note: to match this opening '{'\n\
    \                                            for wordSplit20 in wordSplit19 {\n\
    \                                                                           ^\n\
    /tmp/tmpwmqs76kj.swift:109:44: error: expected '}' at end of brace statement\n\
    assert(split_words(txt: \"\") == .failure(0))\n                              \
    \             ^\n/tmp/tmpwmqs76kj.swift:73:72: note: to match this opening '{'\n\
    \                                        for wordSplit18 in wordSplit17 {\n  \
    \                                                                     ^\n/tmp/tmpwmqs76kj.swift:109:44:\
    \ error: expected '}' at end of brace statement\nassert(split_words(txt: \"\"\
    ) == .failure(0))\n                                           ^\n/tmp/tmpwmqs76kj.swift:67:68:\
    \ note: to match this opening '{'\n                                    for wordSplit16\
    \ in wordSplit15 {\n                                                         \
    \          ^\n/tmp/tmpwmqs76kj.swift:109:44: error: expected '}' at end of brace\
    \ statement\nassert(split_words(txt: \"\") == .failure(0))\n                 \
    \                          ^\n/tmp/tmpwmqs76kj.swift:61:64: note: to match this\
    \ opening '{'\n                                for wordSplit14 in wordSplit13\
    \ {\n                                                               ^\n/tmp/tmpwmqs76kj.swift:109:44:\
    \ error: expected '}' at end of brace statement\nassert(split_words(txt: \"\"\
    ) == .failure(0))\n                                           ^\n/tmp/tmpwmqs76kj.swift:55:60:\
    \ note: to match this opening '{'\n                            for wordSplit12\
    \ in wordSplit11 {\n                                                         \
    \  ^\n/tmp/tmpwmqs76kj.swift:109:44: error: expected '}' at end of brace statement\n\
    assert(split_words(txt: \"\") == .failure(0))\n                              \
    \             ^\n/tmp/tmpwmqs76kj.swift:49:55: note: to match this op"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(1))\n    }\n    if words.count\
    \ == 1 {\n        return Ok(words)\n    }\n    let firstWord = words[0]\n    let\
    \ lastWord = words[words.count - 1]\n    let firstChar = firstWord.characters.first\n\
    \    let lastChar = lastWord.characters.last\n    if firstChar == lastChar {\n\
    \        return Ok(words)\n    }\n    if firstChar == \" \" {\n        return\
    \ Ok(words)\n    }\n    if lastChar == \" \" {\n        return Ok(words)\n   \
    \ }\n    if firstChar == \",\" {\n        return Ok(words)\n    }\n    if lastChar\
    \ == \",\" {\n        return Ok(words)\n    }\n    if firstChar == \".\" {\n \
    \       return Ok(words)\n    }\n    if lastChar == \".\" {\n        return Ok(words)\n\
    \    }\n    if firstChar == \" \" {\n        return Ok(words)\n    }\n    if lastChar\
    \ == \" \" {\n        return Ok(words)\n    }\n    if firstChar == \",\" {\n \
    \       return Ok(words)\n    }\n    if lastChar == \",\" {\n        return Ok(words)\n\
    \    }\n    if firstChar == \".\" {\n        return Ok(words)\n    }\n    if lastChar\
    \ == \".\" {\n        return Ok(words)\n    }\n    if firstChar == \" \" {\n \
    \       return Ok(words)\n    }\n    if lastChar == \" \" {\n        return Ok(words)\n\
    \    }\n    if firstChar == \",\" {\n        return Ok(words)\n    }\n    if lastChar\
    \ == \",\" {\n        return Ok(words)\n    }\n    if firstChar == \".\" {\n \
    \       return Ok(words)\n    }\n    if lastChar == \".\" {\n        return Ok(words)\n\
    \    }\n    if firstChar == \" \" {\n        return Ok(words)\n    }\n    if lastChar\
    \ == \" \" {\n        return Ok(words)\n    }\n    if firstChar == \",\" {\n \
    \       return Ok(words)\n    }\n    if lastChar == \",\" {\n        return Ok(words)\n\
    \    }\n    if firstChar == \".\" {\n        return Ok(words)\n    }\n    if lastChar\
    \ == \".\" {\n        return Ok(words)\n    }\n    if firstChar == \" \" {\n \
    \       return Ok(words)\n    }\n    if lastChar == \" \" {\n        return Ok(words)\n\
    \    }\n    if firstChar == \",\" {\n        return Ok(words)\n    }\n    if lastChar\
    \ == \",\" {\n        return Ok(words)\n    }\n    if \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpgrfk63yu.swift:110:7: error: expected expression, var, or let in\
    \ 'if' condition\n    if \n      ^\n/tmp/tmpgrfk63yu.swift:12:21: error: value\
    \ of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmpgrfk63yu.swift:14:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(1))\n               ^~~\n\
    /tmp/tmpgrfk63yu.swift:17:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpgrfk63yu.swift:24:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpgrfk63yu.swift:27:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpgrfk63yu.swift:30:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpgrfk63yu.swift:33:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpgrfk63yu.swift:36:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpgrfk63yu.swift:39:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpgrfk63yu.swift:42:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpgrfk63yu.swift:45:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpgrfk63yu.swift:48:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpgrfk63yu.swift:51:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpgrfk63yu.swift:54:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpgrfk63yu.swift:57:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpgrfk63yu.swift:60:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpgrfk63yu.swift:63:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpgrfk63yu.swift:66:16: error: cannot find 'Ok' in scope\n        return"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    guard words.count > 0 else { return Err(0) }\n    let comma = words.last!.components(separatedBy:\
    \ \",\")\n    guard comma.count > 0 else { return Err(0) }\n    let letters =\
    \ words.map { $0.lowercased().characters.count }\n    let odd = letters.filter\
    \ { $0 % 2 != 0 }\n    return Ok(odd.count)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp70d7vhbd.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp70d7vhbd.swift:13:41: error: cannot find 'Err'\
    \ in scope\n    guard words.count > 0 else { return Err(0) }\n               \
    \                         ^~~\n/tmp/tmp70d7vhbd.swift:15:41: error: cannot find\
    \ 'Err' in scope\n    guard comma.count > 0 else { return Err(0) }\n         \
    \                               ^~~\n/tmp/tmp70d7vhbd.swift:18:12: error: cannot\
    \ find 'Ok' in scope\n    return Ok(odd.count)\n           ^~\n"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.split(separator: \" \"\
    ) else {\n        return Err(Int(rawValue: -1))\n    }\n    \n    var result:\
    \ [String] = []\n    \n    for word in words {\n        guard let word = word.trimmingCharacters(in:\
    \ .whitespaces) else {\n            return Err(Int(rawValue: -1))\n        }\n\
    \        \n        if word.count > 0 {\n            result.append(word)\n    \
    \    }\n    }\n    \n    if result.count == 0 {\n        return Err(Int(rawValue:\
    \ -1))\n    }\n    \n    if result.count > 1 {\n        return Err(Int(rawValue:\
    \ -2))\n    }\n    \n    if result.count < 2 {\n        return Err(Int(rawValue:\
    \ -3))\n    }\n    \n    return Ok(result)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpqz6n5e5f.swift:13:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(rawValue: -1))\n               ^~~\n/tmp/tmpqz6n5e5f.swift:13:23:\
    \ error: extraneous argument label 'rawValue:' in call\n        return Err(Int(rawValue:\
    \ -1))\n                      ^~~~~~~~~~~\n                       \n/tmp/tmpqz6n5e5f.swift:12:11:\
    \ error: initializer for conditional binding must have Optional type, not '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n    guard let words = txt.split(separator: \" \")\
    \ else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpqz6n5e5f.swift:19:31:\
    \ error: value of type 'String.SubSequence' (aka 'Substring') has no member 'trimmingCharacters'\n\
    \        guard let word = word.trimmingCharacters(in: .whitespaces) else {\n \
    \                        ~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpqz6n5e5f.swift:19:55:\
    \ error: cannot infer contextual base in reference to member 'whitespaces'\n \
    \       guard let word = word.trimmingCharacters(in: .whitespaces) else {\n  \
    \                                                   ~^~~~~~~~~~~\n/tmp/tmpqz6n5e5f.swift:20:20:\
    \ error: cannot find 'Err' in scope\n            return Err(Int(rawValue: -1))\n\
    \                   ^~~\n/tmp/tmpqz6n5e5f.swift:20:27: error: extraneous argument\
    \ label 'rawValue:' in call\n            return Err(Int(rawValue: -1))\n     \
    \                     ^~~~~~~~~~~\n                           \n/tmp/tmpqz6n5e5f.swift:29:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(rawValue: -1))\n \
    \              ^~~\n/tmp/tmpqz6n5e5f.swift:29:23: error: extraneous argument label\
    \ 'rawValue:' in call\n        return Err(Int(rawValue: -1))\n               \
    \       ^~~~~~~~~~~\n                       \n/tmp/tmpqz6n5e5f.swift:33:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(rawValue: -2))\n        \
    \       ^~~\n/tmp/tmpqz6n5e5f.swift:33:23: error: extraneous argument label 'rawValue:'\
    \ in call\n        return Err(Int(rawValue: -2))\n                      ^~~~~~~~~~~\n\
    \                       \n/tmp/tmpqz6n5e5f.swift:37:16: error: cannot find 'Err'\
    \ in scope\n        return Err(I"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(0))\n    }\n    let firstWord\
    \ = words[0]\n    let lastWord = words[words.count - 1]\n    if firstWord.count\
    \ != lastWord.count {\n        return Err(Int(0))\n    }\n    let firstWordChars\
    \ = firstWord.characters\n    let lastWordChars = lastWord.characters\n    let\
    \ firstWordCharCount = firstWord.count\n    let lastWordCharCount = lastWord.count\n\
    \    let firstWordCharsCount = firstWordChars.count\n    let lastWordCharsCount\
    \ = lastWordChars.count\n    let firstWordCharsCountUpper = firstWordCharsCount.filter{$0.isUpper}.count\n\
    \    let lastWordCharsCountUpper = lastWordCharsCount.filter{$0.isUpper}.count\n\
    \    let firstWordCharsCountLower = firstWordCharsCount.filter{$0.isLower}.count\n\
    \    let lastWordCharsCountLower = lastWordCharsCount.filter{$0.isLower}.count\n\
    \    let firstWordCharsCountDigit = firstWordCharsCount.filter{$0.isDigit}.count\n\
    \    let lastWordCharsCountDigit = lastWordCharsCount.filter{$0.isDigit}.count\n\
    \    let firstWordCharsCountNonDigit = firstWordCharsCount.filter{$0.isNonDigit}.count\n\
    \    let lastWordCharsCountNonDigit = lastWordCharsCount.filter{$0.isNonDigit}.count\n\
    \    let firstWordCharsCountSpace = firstWordCharsCount.filter{$0.isSpace}.count\n\
    \    let lastWordCharsCountSpace = lastWordCharsCount.filter{$0.isSpace}.count\n\
    \    let firstWordCharsCountComma = firstWordCharsCount.filter{$0.isComma}.count\n\
    \    let lastWordCharsCountComma = lastWordCharsCount.filter{$0.isComma}.count\n\
    \    let firstWordCharsCountUpperComma = firstWordCharsCount.filter{$0.isUpperComma}.count\n\
    \    let lastWordCharsCountUpperComma = lastWordCharsCount.filter{$0.isUpperComma}.count\n\
    \    let firstWordCharsCountLowerComma = firstWordCharsCount.filter{$0.isLowerComma}.count\n\
    \    let lastWordCharsCountLowerComma = lastWordCharsCount.filter{$0.isLowerComma}.count\n\
    \    let firstWordCharsCountUpperSpace = \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpu3jo5now.swift:43:40: error: expected initial value after '='\n\
    \    let firstWordCharsCountUpperSpace = \n                                  \
    \     ^\n/tmp/tmpu3jo5now.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpu3jo5now.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(0))\n               ^~~\n/tmp/tmpu3jo5now.swift:19:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(0))\n            \
    \   ^~~\n"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(1))\n    }\n    if words.count\
    \ == 1 {\n        return Ok(words)\n    }\n    let comma = words.last!.components(separatedBy:\
    \ \",\")\n    if comma.count == 0 {\n        return Ok(words)\n    }\n    if comma.count\
    \ == 1 {\n        return Ok(words + [comma])\n    }\n    let odd = words.enumerated().filter\
    \ { $0.element % 2 == 1 }.map { $0.element }\n    return Ok(words.dropLast(odd.count)\
    \ + [comma])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmptvp74z29.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmptvp74z29.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(1))\n               ^~~\n/tmp/tmptvp74z29.swift:17:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmptvp74z29.swift:21:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmptvp74z29.swift:24:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words + [comma])\n               ^~\n/tmp/tmptvp74z29.swift:27:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words.dropLast(odd.count) +\
    \ [comma])\n           ^~\n"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    guard words.count > 0 else { return Err(0) }\n    let wordCount = words.count\n\
    \    let wordCountWithCommas = wordCount + words.count - 1\n    let wordCountWithCommasWithOddOrder\
    \ = wordCountWithCommas + words.count - 1\n    let wordCountWithCommasWithOddOrderWithOddLetters\
    \ = wordCountWithCommasWithOddOrder + words.count - 1\n    guard wordCountWithCommasWithOddOrderWithOddLetters\
    \ % 2 == 0 else {\n        return Err(wordCountWithCommasWithOddOrderWithOddLetters)\n\
    \    }\n    return Ok(words.map { $0.trimmingCharacters(in: .whitespaces) })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpguacsjzb.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpguacsjzb.swift:13:41: error: cannot find 'Err'\
    \ in scope\n    guard words.count > 0 else { return Err(0) }\n               \
    \                         ^~~\n/tmp/tmpguacsjzb.swift:19:16: error: cannot find\
    \ 'Err' in scope\n        return Err(wordCountWithCommasWithOddOrderWithOddLetters)\n\
    \               ^~~\n/tmp/tmpguacsjzb.swift:21:12: error: cannot find 'Ok' in\
    \ scope\n    return Ok(words.map { $0.trimmingCharacters(in: .whitespaces) })\n\
    \           ^~\n/tmp/tmpguacsjzb.swift:21:54: error: cannot infer contextual base\
    \ in reference to member 'whitespaces'\n    return Ok(words.map { $0.trimmingCharacters(in:\
    \ .whitespaces) })\n                                                    ~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int((txt.characters.count + txt.lowercased().characters.count)\
    \ / 2))\n    }\n    if words.count == 1 {\n        return Ok(words)\n    }\n \
    \   let words = words.map { $0.lowercased() }\n    let counts = words.map { $0.characters.count\
    \ }\n    let countsSorted = counts.sorted()\n    let countsSorted = countsSorted.map\
    \ { Int($0) }\n    let countsSorted = countsSorted.map { $0 % 2 == 1 ? $0 - 1\
    \ : $0 }\n    let countsSorted = countsSorted.map { $0 % 2 == 0 ? $0 + 1 : $0\
    \ }\n    let countsSorted = countsSorted.map { $0 % 2 == 0 ? $0 - 1 : $0 }\n \
    \   let countsSorted = countsSorted.map { $0 % 2 == 1 ? $0 + 1 : $0 }\n    let\
    \ countsSorted = countsSorted.map { $0 % 2 == 0 ? $0 - 1 : $0 }\n    let countsSorted\
    \ = countsSorted.map { $0 % 2 == 1 ? $0 - 1 : $0 }\n    let countsSorted = countsSorted.map\
    \ { $0 % 2 == 0 ? $0 + 1 : $0 }\n    let countsSorted = countsSorted.map { $0\
    \ % 2 == 1 ? $0 + 1 : $0 }\n    let countsSorted = countsSorted.map { $0 % 2 ==\
    \ 0 ? $0 - 1 : $0 }\n    let countsSorted = countsSorted.map { $0 % 2 == 0 ? $0\
    \ + 1 : $0 }\n    let countsSorted = countsSorted.map { $0 % 2 == 1 ? $0 - 1 :\
    \ $0 }\n    let countsSorted = countsSorted.map { $0 % 2 == 0 ? $0 + 1 : $0 }\n\
    \    let countsSorted = countsSorted.map { $0 % 2 == 1 ? $0 - 1 : $0 }\n    let\
    \ countsSorted = countsSorted.map { $0 % 2 == 0 ? $0 - 1 : $0 }\n    let countsSorted\
    \ = countsSorted.map { $0 % 2 == 0 ? $0 + 1 : $0 }\n    let countsSorted = countsSorted.map\
    \ { $0 % 2 == 1 ? $0 + 1 : $0 }\n    let countsSorted = countsSorted.map { $0\
    \ % 2 == 0 ? $0 - 1 : $0 }\n    let countsSorted = countsSorted.map { $0 % 2 ==\
    \ 0 ? $0 + 1 : $0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpxmsdib42.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpxmsdib42.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int((txt.characters.count + txt.lowercased().characters.count)\
    \ / 2))\n               ^~~\n/tmp/tmpxmsdib42.swift:17:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n"
  stdout: ''
  timestamp: 1660054246
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.split(separator: \" \"\
    ) else {\n        return Err(Int(.init(rawValue: 1)).rawValue)\n    }\n    \n\
    \    guard let comma = words.first {\n        return Err(Int(.init(rawValue: 2)).rawValue)\n\
    \    }\n    \n    guard let letters = words.dropFirst().filter({ $0.count % 2\
    \ == 1 }) {\n        return Err(Int(.init(rawValue: 3)).rawValue)\n    }\n   \
    \ \n    return Ok(letters)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpuwlcswdf.swift:16:35: error: expected 'else' after 'guard' condition\n\
    \    guard let comma = words.first {\n                                  ^\n  \
    \                                else \n/tmp/tmpuwlcswdf.swift:20:73: error: expected\
    \ 'else' after 'guard' condition\n    guard let letters = words.dropFirst().filter({\
    \ $0.count % 2 == 1 }) {\n                                                   \
    \                     ^\n                                                    \
    \                    else \n/tmp/tmpuwlcswdf.swift:13:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(.init(rawValue: 1)).rawValue)\n           \
    \    ^~~\n/tmp/tmpuwlcswdf.swift:13:44: error: value of type 'Int' has no member\
    \ 'rawValue'\n        return Err(Int(.init(rawValue: 1)).rawValue)\n         \
    \          ~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmpuwlcswdf.swift:13:25: error:\
    \ reference to member 'init' cannot be resolved without a contextual type\n  \
    \      return Err(Int(.init(rawValue: 1)).rawValue)\n                        ^\n\
    /tmp/tmpuwlcswdf.swift:12:11: error: initializer for conditional binding must\
    \ have Optional type, not '[String.SubSequence]' (aka 'Array<Substring>')\n  \
    \  guard let words = txt.split(separator: \" \") else {\n          ^         \
    \  ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpuwlcswdf.swift:17:16: error: cannot find\
    \ 'Err' in scope\n        return Err(Int(.init(rawValue: 2)).rawValue)\n     \
    \          ^~~\n/tmp/tmpuwlcswdf.swift:17:44: error: value of type 'Int' has no\
    \ member 'rawValue'\n        return Err(Int(.init(rawValue: 2)).rawValue)\n  \
    \                 ~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmpuwlcswdf.swift:17:25:\
    \ error: reference to member 'init' cannot be resolved without a contextual type\n\
    \        return Err(Int(.init(rawValue: 2)).rawValue)\n                      \
    \  ^\n/tmp/tmpuwlcswdf.swift:21:16: error: cannot find 'Err' in scope\n      \
    \  return Err(Int(.init(rawValue: 3)).rawValue)\n               ^~~\n/tmp/tmpuwlcswdf.swift:21:44:\
    \ error: value of type 'Int' has no member 'rawValue'\n        return Err(Int(.init(rawValue:\
    \ 3)).rawValue)\n          "
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.split(separator: \" \"\
    ) else {\n        return Err(Int(.init(rawValue: 10)))\n    }\n    \n    var words:\
    \ [String] = []\n    \n    for word in words {\n        if let word = word.lowercased()\
    \ {\n            if word.count % 2 == 1 {\n                words.append(word)\n\
    \            }\n        }\n    }\n    \n    return Ok(words)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpskh1r03a.swift:13:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(.init(rawValue: 10)))\n               ^~~\n/tmp/tmpskh1r03a.swift:13:25:\
    \ error: reference to member 'init' cannot be resolved without a contextual type\n\
    \        return Err(Int(.init(rawValue: 10)))\n                        ^\n/tmp/tmpskh1r03a.swift:12:11:\
    \ error: initializer for conditional binding must have Optional type, not '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n    guard let words = txt.split(separator: \" \")\
    \ else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpskh1r03a.swift:16:9:\
    \ error: invalid redeclaration of 'words'\n    var words: [String] = []\n    \
    \    ^\n/tmp/tmpskh1r03a.swift:12:15: note: 'words' previously declared here\n\
    \    guard let words = txt.split(separator: \" \") else {\n              ^\n/tmp/tmpskh1r03a.swift:26:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words)\n           ^~\n"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    guard !words.isEmpty else {\n        return Err(Int(.init(rawValue: 1)))\
    \ // no whitespace in string\n    }\n    guard !words.contains(\",\") else {\n\
    \        return Err(Int(.init(rawValue: 2))) // no commas in string\n    }\n \
    \   guard let letters = txt.unicodeScalars.filter({ $0.isLetter}).count else {\n\
    \        return Err(Int(.init(rawValue: 3))) // no letters in string\n    }\n\
    \    guard let letterCount = letters % 2 else {\n        return Err(Int(.init(rawValue:\
    \ 4))) // odd number of letters\n    }\n    return Ok(words.map { $0.trimmingCharacters(in:\
    \ .whitespacesAndNewlines) })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpw9u65wvq.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpw9u65wvq.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(.init(rawValue: 1))) // no whitespace in string\n\
    \               ^~~\n/tmp/tmpw9u65wvq.swift:14:25: error: reference to member\
    \ 'init' cannot be resolved without a contextual type\n        return Err(Int(.init(rawValue:\
    \ 1))) // no whitespace in string\n                        ^\n/tmp/tmpw9u65wvq.swift:17:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(.init(rawValue: 2)))\
    \ // no commas in string\n               ^~~\n/tmp/tmpw9u65wvq.swift:17:25: error:\
    \ reference to member 'init' cannot be resolved without a contextual type\n  \
    \      return Err(Int(.init(rawValue: 2))) // no commas in string\n          \
    \              ^\n/tmp/tmpw9u65wvq.swift:19:56: error: value of type 'Unicode.Scalar'\
    \ has no member 'isLetter'\n    guard let letters = txt.unicodeScalars.filter({\
    \ $0.isLetter}).count else {\n                                               \
    \     ~~ ^~~~~~~~\n/tmp/tmpw9u65wvq.swift:20:16: error: cannot find 'Err' in scope\n\
    \        return Err(Int(.init(rawValue: 3))) // no letters in string\n       \
    \        ^~~\n/tmp/tmpw9u65wvq.swift:20:25: error: reference to member 'init'\
    \ cannot be resolved without a contextual type\n        return Err(Int(.init(rawValue:\
    \ 3))) // no letters in string\n                        ^\n/tmp/tmpw9u65wvq.swift:23:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(.init(rawValue: 4)))\
    \ // odd number of letters\n               ^~~\n/tmp/tmpw9u65wvq.swift:23:25:\
    \ error: reference to member 'init' cannot be resolved without a contextual type\n\
    \        return Err(Int(.init(rawValue: 4))) // odd number of letters\n      \
    \                  ^\n/tmp/tmpw9u65wvq.swift:25:12: error: cannot find 'Ok' in\
    \ scope\n    return Ok(words.map { $0.trimmingCharacters(in: .whitespacesAndNewlines)\
    \ })\n           ^~\n/tmp/tmpw9u65wvq.swift:25:54: error: cannot infer contextual\
    \ base "
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    \n    if words.count == 0 {\n        return Err(0)\n    }\n    \n    if\
    \ words.count == 1 {\n        return Ok([words[0]])\n    }\n    \n    let firstWord\
    \ = words[0]\n    let lastWord = words[words.count - 1]\n    \n    if firstWord.hasPrefix(\"\
    ,\") {\n        return Ok(words.dropFirst())\n    }\n    \n    if lastWord.hasSuffix(\"\
    ,\") {\n        return Ok(words.dropLast())\n    }\n    \n    let chars = firstWord.characters\n\
    \    \n    if chars.count % 2 == 1 {\n        return Ok(words.dropFirst())\n \
    \   }\n    \n    let odd = chars.count / 2\n    \n    return Ok(words.dropFirst().prefix(odd).dropLast())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpodag9ast.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpodag9ast.swift:15:16: error: cannot find 'Err'\
    \ in scope\n        return Err(0)\n               ^~~\n/tmp/tmpodag9ast.swift:19:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok([words[0]])\n          \
    \     ^~\n/tmp/tmpodag9ast.swift:26:16: error: cannot find 'Ok' in scope\n   \
    \     return Ok(words.dropFirst())\n               ^~\n/tmp/tmpodag9ast.swift:30:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words.dropLast())\n    \
    \           ^~\n/tmp/tmpodag9ast.swift:36:16: error: cannot find 'Ok' in scope\n\
    \        return Ok(words.dropFirst())\n               ^~\n/tmp/tmpodag9ast.swift:41:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words.dropFirst().prefix(odd).dropLast())\n\
    \           ^~\n"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(0)\n    }\n    \n    var words\
    \ = [String]()\n    var count = 0\n    for word in words {\n        if let _ =\
    \ word.rangeOfCharacter(from: CharacterSet.whitespaces) {\n            words.append(word)\n\
    \        } else {\n            words.append(word.lowercased())\n            count\
    \ += 1\n        }\n    }\n    \n    return Ok(words)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp2pt11fw3.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp2pt11fw3.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(0)\n               ^~~\n/tmp/tmp2pt11fw3.swift:20:48:\
    \ error: cannot find 'CharacterSet' in scope\n        if let _ = word.rangeOfCharacter(from:\
    \ CharacterSet.whitespaces) {\n                                              \
    \ ^~~~~~~~~~~~\n/tmp/tmp2pt11fw3.swift:20:25: error: value of type 'String' has\
    \ no member 'rangeOfCharacter'\n        if let _ = word.rangeOfCharacter(from:\
    \ CharacterSet.whitespaces) {\n                   ~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmp2pt11fw3.swift:28:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words)\n           ^~\n"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.split(separator: \" \"\
    ) else {\n        return Err(Int(.init(rawValue: -999)))\n    }\n    \n    var\
    \ result: [String] = []\n    \n    for word in words {\n        guard let wordWithoutSpaces\
    \ = word.removeFirst(\" \").trimmingCharacters(in: .whitespaces) else {\n    \
    \        return Err(Int(.init(rawValue: -999)))\n        }\n        \n       \
    \ if wordWithoutSpaces.isEmpty {\n            continue\n        }\n        \n\
    \        if wordWithoutSpaces.contains(\",\") {\n            guard let wordWithoutCommas\
    \ = wordWithoutSpaces.split(separator: \",\") else {\n                return Err(Int(.init(rawValue:\
    \ -999)))\n            }\n            \n            for wordWithoutComma in wordWithoutCommas\
    \ {\n                if wordWithoutComma.isEmpty {\n                    continue\n\
    \                }\n                \n                if wordWithoutComma.lowercased()\
    \ != wordWithoutComma {\n                    return Err(Int(.init(rawValue: -999)))\n\
    \                }\n                \n                result.append(wordWithoutComma)\n\
    \            }\n        } else {\n            if wordWithoutSpaces.lowercased()\
    \ != wordWithoutSpaces {\n                return Err(Int(.init(rawValue: -999)))\n\
    \            }\n            \n            result.append(wordWithoutSpaces)\n \
    \       }\n    }\n    \n    guard result.count > 0 else {\n        return Err(Int(.init(rawValue:\
    \ -999)))\n    }\n    \n    return Ok(result)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp18k1cy8k.swift:13:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(.init(rawValue: -999)))\n               ^~~\n/tmp/tmp18k1cy8k.swift:13:25:\
    \ error: reference to member 'init' cannot be resolved without a contextual type\n\
    \        return Err(Int(.init(rawValue: -999)))\n                        ^\n/tmp/tmp18k1cy8k.swift:12:11:\
    \ error: initializer for conditional binding must have Optional type, not '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n    guard let words = txt.split(separator: \" \")\
    \ else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp18k1cy8k.swift:19:44:\
    \ error: cannot use mutating member on immutable value: 'word' is a 'let' constant\n\
    \        guard let wordWithoutSpaces = word.removeFirst(\" \").trimmingCharacters(in:\
    \ .whitespaces) else {\n                                      ~~~~ ^\n/tmp/tmp18k1cy8k.swift:19:56:\
    \ error: cannot convert value of type 'String' to expected argument type 'Int'\n\
    \        guard let wordWithoutSpaces = word.removeFirst(\" \").trimmingCharacters(in:\
    \ .whitespaces) else {\n                                                     \
    \  ^\n/tmp/tmp18k1cy8k.swift:19:61: error: value of tuple type '()' has no member\
    \ 'trimmingCharacters'\n        guard let wordWithoutSpaces = word.removeFirst(\"\
    \ \").trimmingCharacters(in: .whitespaces) else {\n                          \
    \            ~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp18k1cy8k.swift:19:85:\
    \ error: cannot infer contextual base in reference to member 'whitespaces'\n \
    \       guard let wordWithoutSpaces = word.removeFirst(\" \").trimmingCharacters(in:\
    \ .whitespaces) else {\n                                                     \
    \                              ~^~~~~~~~~~~\n/tmp/tmp18k1cy8k.swift:20:20: error:\
    \ cannot find 'Err' in scope\n            return Err(Int(.init(rawValue: -999)))\n\
    \                   ^~~\n/tmp/tmp18k1cy8k.swift:20:29: error: reference to member\
    \ 'init' cannot be resolved without a contextual type\n            return Err(Int(.init(rawValue:\
    \ -999)))\n                            ^\n/tmp/tmp18k1cy8k.swift:29:24: error:\
    \ cannot "
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(0))\n    }\n    let comma\
    \ = words.last!.components(separatedBy: \",\")\n    if comma.count == 0 {\n  \
    \      return Err(Int(1))\n    }\n    let letters = words.count % 2 == 0 ? words.count\
    \ / 2 : words.count / 2 + 1\n    return Ok([words[0], words[words.count - 1],\
    \ comma[0], comma[comma.count - 1], letters])\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpbcvnioyg.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpbcvnioyg.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(0))\n               ^~~\n/tmp/tmpbcvnioyg.swift:18:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(1))\n            \
    \   ^~~\n/tmp/tmpbcvnioyg.swift:21:12: error: cannot find 'Ok' in scope\n    return\
    \ Ok([words[0], words[words.count - 1], comma[0], comma[comma.count - 1], letters])\n\
    \           ^~\n"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.components(separatedBy:\
    \ \" \") else {\n        return Err(Int(.errUnknown))\n    }\n    var result =\
    \ [String]()\n    for word in words {\n        if let word = word.lowercased()\
    \ {\n            result.append(word)\n        }\n    }\n    if result.count %\
    \ 2 == 1 {\n        return Err(Int(.errUnknown))\n    }\n    return Ok(result)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpakxq4mb0.swift:12:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmpakxq4mb0.swift:13:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(.errUnknown))\n         \
    \      ^~~\n/tmp/tmpakxq4mb0.swift:13:24: error: missing argument label 'bitPattern:'\
    \ in call\n        return Err(Int(.errUnknown))\n                       ^\n  \
    \                     bitPattern: \n/tmp/tmpakxq4mb0.swift:22:16: error: cannot\
    \ find 'Err' in scope\n        return Err(Int(.errUnknown))\n               ^~~\n\
    /tmp/tmpakxq4mb0.swift:22:24: error: missing argument label 'bitPattern:' in call\n\
    \        return Err(Int(.errUnknown))\n                       ^\n            \
    \           bitPattern: \n/tmp/tmpakxq4mb0.swift:24:12: error: cannot find 'Ok'\
    \ in scope\n    return Ok(result)\n           ^~\n"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.components(separatedBy:\
    \ \" \") else {\n        return Err(Int(rawValue: 1))\n    }\n    \n    var words:\
    \ [String] = []\n    \n    for word in words {\n        guard let letters = word.components(separatedBy:\
    \ \",\") else {\n            return Err(Int(rawValue: 2))\n        }\n       \
    \ \n        for letter in letters {\n            guard let letter = letter.lowercased()\
    \ else {\n                return Err(Int(rawValue: 3))\n            }\n      \
    \      \n            if letters.count % 2 == 1 {\n                words.append(letter)\n\
    \            }\n        }\n    }\n    \n    return Ok(words)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp1sebzrhg.swift:12:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmp1sebzrhg.swift:13:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(rawValue: 1))\n         \
    \      ^~~\n/tmp/tmp1sebzrhg.swift:13:23: error: extraneous argument label 'rawValue:'\
    \ in call\n        return Err(Int(rawValue: 1))\n                      ^~~~~~~~~~~\n\
    \                       \n/tmp/tmp1sebzrhg.swift:19:34: error: value of type 'String'\
    \ has no member 'components'\n        guard let letters = word.components(separatedBy:\
    \ \",\") else {\n                            ~~~~ ^~~~~~~~~~\n/tmp/tmp1sebzrhg.swift:20:20:\
    \ error: cannot find 'Err' in scope\n            return Err(Int(rawValue: 2))\n\
    \                   ^~~\n/tmp/tmp1sebzrhg.swift:20:27: error: extraneous argument\
    \ label 'rawValue:' in call\n            return Err(Int(rawValue: 2))\n      \
    \                    ^~~~~~~~~~~\n                           \n/tmp/tmp1sebzrhg.swift:34:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words)\n           ^~\n"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(0)\n    }\n    let splitWords\
    \ = words.map { $0.components(separatedBy: \",\") }\n    if splitWords.count ==\
    \ 0 {\n        return Err(0)\n    }\n    let lowercaseLetters = splitWords.map\
    \ { $0.map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp9swl1f19.swift:20:1945: error: expected member name following '.'\n\
    \    let lowercaseLetters = splitWords.map { $0.map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.\n\
    \                            "
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    guard words.count > 0 else { return Err(0) }\n    let wordCount = words.count\n\
    \    let wordList: [String] = words.map { $0.lowercased() }\n    let wordListCount\
    \ = wordList.count\n    guard wordListCount > 0 else { return Err(0) }\n    guard\
    \ wordListCount == wordCount else { return Err(0) }\n    guard wordListCount ==\
    \ wordCount else { return Err(0) }\n    guard wordListCount == wordCount else\
    \ { return Err(0) }\n    return Ok(wordList)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpgdu_wbdd.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpgdu_wbdd.swift:13:41: error: cannot find 'Err'\
    \ in scope\n    guard words.count > 0 else { return Err(0) }\n               \
    \                         ^~~\n/tmp/tmpgdu_wbdd.swift:17:43: error: cannot find\
    \ 'Err' in scope\n    guard wordListCount > 0 else { return Err(0) }\n       \
    \                                   ^~~\n/tmp/tmpgdu_wbdd.swift:18:52: error:\
    \ cannot find 'Err' in scope\n    guard wordListCount == wordCount else { return\
    \ Err(0) }\n                                                   ^~~\n/tmp/tmpgdu_wbdd.swift:19:52:\
    \ error: cannot find 'Err' in scope\n    guard wordListCount == wordCount else\
    \ { return Err(0) }\n                                                   ^~~\n\
    /tmp/tmpgdu_wbdd.swift:20:52: error: cannot find 'Err' in scope\n    guard wordListCount\
    \ == wordCount else { return Err(0) }\n                                      \
    \             ^~~\n/tmp/tmpgdu_wbdd.swift:21:12: error: cannot find 'Ok' in scope\n\
    \    return Ok(wordList)\n           ^~\n"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    \n    if words.count == 0 {\n        return Err(Int((txt.characters.count\
    \ + txt.lowercased().characters.count) / 2))\n    }\n    \n    if words.count\
    \ == 1 {\n        return Ok(words)\n    }\n    \n    if words.count % 2 == 1 {\n\
    \        return Ok(words.prefix(words.count / 2))\n    }\n    \n    return Ok(words.suffix(words.count\
    \ / 2))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello\
    \ world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"\
    Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp1xhpiprm.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp1xhpiprm.swift:15:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int((txt.characters.count + txt.lowercased().characters.count)\
    \ / 2))\n               ^~~\n/tmp/tmp1xhpiprm.swift:19:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmp1xhpiprm.swift:23:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words.prefix(words.count\
    \ / 2))\n               ^~\n/tmp/tmp1xhpiprm.swift:26:12: error: cannot find 'Ok'\
    \ in scope\n    return Ok(words.suffix(words.count / 2))\n           ^~\n"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    \n    guard let chars = txt.unicodeScalars.filter\
    \ { $0.isLetter }\n    else {\n        return Err(Int(.lowercaseLetter))\n   \
    \ }\n    \n    let count = chars.count\n    \n    if count == 0 {\n        return\
    \ Err(Int(.lowercaseLetter))\n    }\n    \n    if count == 1 {\n        return\
    \ Ok([txt])\n    }\n    \n    let charsArray = chars.map { String($0) }\n    \n\
    \    if charsArray.count == 2 {\n        return Ok([txt])\n    }\n    \n    if\
    \ charsArray.count == 3 {\n        return Ok([txt])\n    }\n    \n    if charsArray.count\
    \ == 4 {\n        return Ok([txt])\n    }\n    \n    if charsArray.count == 5\
    \ {\n        return Ok([txt])\n    }\n    \n    if charsArray.count == 6 {\n \
    \       return Ok([txt])\n    }\n    \n    if charsArray.count == 7 {\n      \
    \  return Ok([txt])\n    }\n    \n    if charsArray.count == 8 {\n        return\
    \ Ok([txt])\n    }\n    \n    if charsArray.count == 9 {\n        return Ok([txt])\n\
    \    }\n    \n    if charsArray.count == 10 {\n        return Ok([txt])\n    }\n\
    \    \n    if charsArray.count == 11 {\n        return Ok([txt])\n    }\n    \n\
    \    if charsArray.count == 12 {\n        return Ok([txt])\n    }\n    \n    if\
    \ charsArray.count == 13 {\n        return Ok([txt])\n    }\n    \n    if charsArray.count\
    \ == 14 {\n        return Ok([txt])\n    }\n    \n    if charsArray.count == 15\
    \ {\n        return Ok([txt])\n    }\n    \n    if charsArray.count == 16 {\n\
    \        return Ok([txt])\n    }\n    \n    if charsArray.count == 17 {\n    \
    \    return Ok([txt])\n    }\n    \n    if charsArray.count == 18 {\n        return\
    \ Ok([txt])\n    }\n    \n    if charsArray.count == 19 {\n        return Ok([txt])\n\
    \    }\n    \n    if charsArray.count == 20 {\n        return Ok([txt])\n    }\n\
    \    \n    if charsArray.count == 21 {\n        return Ok([txt])\n    }\n    \n\
    \    if charsArray.count == 22 {\n        return Ok([txt])\n    }\n    \n    if\
    \ charsArray.count == 23 {\n        return Ok([txt])\n    }\n    \n    if charsArray.count\
    \ == 24 {\n        return Ok([txt])\n    }\n    \n    if charsArray.count == 25\
    \ {\n        return \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpawxg7y7l.swift:13:49: error: expected 'else' after 'guard' condition\n\
    \    guard let chars = txt.unicodeScalars.filter { $0.isLetter }\n           \
    \                                     ^\n                                    \
    \            else \n/tmp/tmpawxg7y7l.swift:13:51: error: anonymous closure argument\
    \ not contained in a closure\n    guard let chars = txt.unicodeScalars.filter\
    \ { $0.isLetter }\n                                                  ^\n/tmp/tmpawxg7y7l.swift:14:5:\
    \ error: expected expression\n    else {\n    ^\n/tmp/tmpawxg7y7l.swift:146:44:\
    \ error: expected '}' at end of brace statement\nassert(split_words(txt: \"\"\
    ) == .failure(0))\n                                           ^\n/tmp/tmpawxg7y7l.swift:11:56:\
    \ note: to match this opening '{'\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n                                                       ^\n/tmp/tmpawxg7y7l.swift:13:11:\
    \ error: initializer for conditional binding must have Optional type, not '((Unicode.Scalar)\
    \ throws -> Bool) throws -> String.UnicodeScalarView'\n    guard let chars = txt.unicodeScalars.filter\
    \ { $0.isLetter }\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpawxg7y7l.swift:18:23:\
    \ error: value of type '((Unicode.Scalar) throws -> Bool) throws -> String.UnicodeScalarView'\
    \ has no member 'count'\n    let count = chars.count\n                ~~~~~ ^~~~~\n\
    /tmp/tmpawxg7y7l.swift:21:16: error: cannot find 'Err' in scope\n        return\
    \ Err(Int(.lowercaseLetter))\n               ^~~\n/tmp/tmpawxg7y7l.swift:21:24:\
    \ error: missing argument label 'bitPattern:' in call\n        return Err(Int(.lowercaseLetter))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmpawxg7y7l.swift:25:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok([txt])\n               ^~\n\
    /tmp/tmpawxg7y7l.swift:28:28: error: value of type '((Unicode.Scalar) throws ->\
    \ Bool) throws -> String.UnicodeScalarView' has no member 'map'\n    let charsArray\
    \ = chars.map { String($0) }\n                     ~~~~~ ^~~\n/tmp/tmpawxg7y7l.swift:31:16:\
    \ error: cannot find 'Ok' in scop"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(0)\n    }\n    \n    let wordCount\
    \ = words.count\n    let letterCount = words.reduce(0) { (acc, word) -> Int in\n\
    \        let letters = word.components(separatedBy: \",\")\n        if letters.count\
    \ == 0 {\n            return acc + Int(word.characters.count)\n        } else\
    \ {\n            return acc + letters.count\n        }\n    }\n    \n    if letterCount\
    \ % 2 == 1 {\n        return Err(letterCount)\n    }\n    \n    return Ok(words.map\
    \ { $0.trimmingCharacters(in: .whitespaces) })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmprggtsk7i.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmprggtsk7i.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(0)\n               ^~~\n/tmp/tmprggtsk7i.swift:28:16:\
    \ error: cannot find 'Err' in scope\n        return Err(letterCount)\n       \
    \        ^~~\n/tmp/tmprggtsk7i.swift:31:12: error: cannot find 'Ok' in scope\n\
    \    return Ok(words.map { $0.trimmingCharacters(in: .whitespaces) })\n      \
    \     ^~\n/tmp/tmprggtsk7i.swift:31:54: error: cannot infer contextual base in\
    \ reference to member 'whitespaces'\n    return Ok(words.map { $0.trimmingCharacters(in:\
    \ .whitespaces) })\n                                                    ~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(0)\n    }\n    let firstWord\
    \ = words[0]\n    let firstLetter = firstWord.characters.first!\n    if firstLetter\
    \ >= 97 && firstLetter <= 122 {\n        return Err(0)\n    }\n    if firstLetter\
    \ >= 65 && firstLetter <= 90 {\n        return Err(1)\n    }\n    if firstLetter\
    \ >= 97 && firstLetter <= 122 {\n        return Err(1)\n    }\n    return Ok(words)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpv4xbv46n.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpv4xbv46n.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(0)\n               ^~~\n/tmp/tmpv4xbv46n.swift:19:16:\
    \ error: cannot find 'Err' in scope\n        return Err(0)\n               ^~~\n\
    /tmp/tmpv4xbv46n.swift:22:16: error: cannot find 'Err' in scope\n        return\
    \ Err(1)\n               ^~~\n/tmp/tmpv4xbv46n.swift:25:16: error: cannot find\
    \ 'Err' in scope\n        return Err(1)\n               ^~~\n/tmp/tmpv4xbv46n.swift:27:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words)\n           ^~\n"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    \n    var words: [String] = []\n    \n    for\
    \ c in txt.unicodeScalars {\n        if let c = c {\n            \n          \
    \  if let lower = c.lowercase {\n                \n                if words.count\
    \ > 0 {\n                    words.append(\" \")\n                }\n        \
    \        \n                words.append(lower)\n                \n           \
    \ } else if let upper = c.uppercase {\n                \n                if words.count\
    \ > 0 {\n                    words.append(\" \")\n                }\n        \
    \        \n                words.append(upper)\n                \n           \
    \ } else if let digit = c.digit {\n                \n                if words.count\
    \ > 0 {\n                    words.append(\" \")\n                }\n        \
    \        \n                words.append(digit)\n                \n           \
    \ } else if let space = c.space {\n                \n                if words.count\
    \ > 0 {\n                    words.append(\" \")\n                }\n        \
    \        \n                words.append(space)\n                \n           \
    \ } else if let comma = c.comma {\n                \n                if words.count\
    \ > 0 {\n                    words.append(\" \")\n                }\n        \
    \        \n                words.append(comma)\n                \n           \
    \ } else if let colon = c.colon {\n                \n                if words.count\
    \ > 0 {\n                    words.append(\" \")\n                }\n        \
    \        \n                words.append(colon)\n                \n           \
    \ } else if let apos = c.apos {\n                \n                if words.count\
    \ > 0 {\n                    words.append(\" \")\n                }\n        \
    \        \n                words.append(apos)\n                \n            }\
    \ else if let dot = c.dot {\n                \n                if words.count\
    \ > 0 {\n                    words.append(\" \")\n                }\n        \
    \        \n                words.append(dot)\n                \n            }\
    \ else if let exclamation = c.exclamation {\n                \n              \
    \  if words.count > 0 {\n                    words.append(\" \")\n           \
    \     }\n                \n                words.append(exclamation)\n       \
    \         \n            } else if let apos = c.apos {\n                \n    \
    \            if words.count > 0 {\n                    words.append(\" \")\n \
    \               }\n                \n                words.append(apos)\n    \
    \            \n            } else if let dollar = c.dollar {\n               \
    \ \n                if words.count > 0 {\n                    words.append(\"\
    \ \")\n                }\n                \n                words.append(dollar)\n\
    \                \n            } else if let percent = c.percent {\n         \
    \       \n                if words.count > 0 {\n                    words.append(\"\
    \ \")\n                }\n                \n                words.append(percent)\n\
    \                \n            } else if let openParen = c.openParen {\n     \
    \           \n                if words.count > 0 {\n                    words.append(\"\
    \ \")\n                }\n                \n                words.append(openParen)\n\
    \                \n            } else if let closeParen = c.closeParen {\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpab8csrr1.swift:145:44: error: expected '}' at end of brace statement\n\
    assert(split_words(txt: \"\") == .failure(0))\n                              \
    \             ^\n/tmp/tmpab8csrr1.swift:16:22: note: to match this opening '{'\n\
    \        if let c = c {\n                     ^\n/tmp/tmpab8csrr1.swift:145:44:\
    \ error: expected '}' at end of brace statement\nassert(split_words(txt: \"\"\
    ) == .failure(0))\n                                           ^\n/tmp/tmpab8csrr1.swift:15:33:\
    \ note: to match this opening '{'\n    for c in txt.unicodeScalars {\n       \
    \                         ^\n/tmp/tmpab8csrr1.swift:145:44: error: expected '}'\
    \ at end of brace statement\nassert(split_words(txt: \"\") == .failure(0))\n \
    \                                          ^\n/tmp/tmpab8csrr1.swift:11:56: note:\
    \ to match this opening '{'\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n                                                       ^\n/tmp/tmpab8csrr1.swift:18:30:\
    \ error: value of type 'Unicode.Scalar' has no member 'lowercase'\n          \
    \  if let lower = c.lowercase {\n                           ~ ^~~~~~~~~\n/tmp/tmpab8csrr1.swift:26:37:\
    \ error: value of type 'Unicode.Scalar' has no member 'uppercase'\n          \
    \  } else if let upper = c.uppercase {\n                                  ~ ^~~~~~~~~\n\
    /tmp/tmpab8csrr1.swift:34:37: error: value of type 'Unicode.Scalar' has no member\
    \ 'digit'\n            } else if let digit = c.digit {\n                     \
    \             ~ ^~~~~\n/tmp/tmpab8csrr1.swift:42:37: error: value of type 'Unicode.Scalar'\
    \ has no member 'space'\n            } else if let space = c.space {\n       \
    \                           ~ ^~~~~\n/tmp/tmpab8csrr1.swift:50:37: error: value\
    \ of type 'Unicode.Scalar' has no member 'comma'\n            } else if let comma\
    \ = c.comma {\n                                  ~ ^~~~~\n/tmp/tmpab8csrr1.swift:58:37:\
    \ error: value of type 'Unicode.Scalar' has no member 'colon'\n            } else\
    \ if let colon = c.colon {\n                                  ~ ^~~~~\n/tmp/tmpab8csrr1.swift:66:36:\
    \ error: value of type 'Unicode.Scalar' ha"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(0)\n    }\n    let wordCount\
    \ = words.count\n    let letterCount = txt.characters.count\n    if wordCount\
    \ == letterCount {\n        return Ok(words)\n    }\n    if letterCount < 26 {\n\
    \        return Err(letterCount)\n    }\n    let alphabet = Array(0 ..< 26)\n\
    \    let oddLetters = alphabet.filter { $0 % 2 == 1 }\n    let evenLetters = alphabet.filter\
    \ { $0 % 2 == 0 }\n    let letterOrder = oddLetters + evenLetters\n    let letterCounts\
    \ = letterOrder.map { letterOrder.index(of: $0) }\n    let letterCountIndex =\
    \ letterCounts.max()!\n    let letterCounts = letterCounts.map { letterCount.index(of:\
    \ $0) }\n    let letterCountIndex = letterCounts.max()!\n    let letterCountIndex\
    \ = letterCounts.max()!\n    if letterCountIndex == letterCount {\n        return\
    \ Ok(words)\n    }\n    if letterCountIndex == letterCount - 1 {\n        return\
    \ Ok(words.map { $0.lowercased() })\n    }\n    if letterCountIndex == letterCount\
    \ - 2 {\n        return Ok(words.map { $0.lowercased() })\n    }\n    if letterCountIndex\
    \ == letterCount - 3 {\n        return Ok(words.map { $0.lowercased() })\n   \
    \ }\n    if letterCountIndex == letterCount - 4 {\n        return Ok(words.map\
    \ { $0.lowercased() })\n    }\n    if letterCountIndex == letterCount - 5 {\n\
    \        return Ok(words.map { $0.lowercased() })\n    }\n    if letterCountIndex\
    \ == letterCount - 6 {\n        return Ok(words.map { $0.lowercased() })\n   \
    \ }\n    if letterCountIndex == letterCount - 7 {\n        return Ok(words.map\
    \ { $0.lowercased() })\n    }\n    if letterCountIndex == letterCount - 8 {\n\
    \        return Ok(words.map { $0.lowercased() })\n    }\n    if letterCountIndex\
    \ == letterCount - 9 {\n        return Ok(words.map { $0.lowercased() })\n   \
    \ }\n    if letterCountIndex == letterCount - 10 {\n        return Ok(words.map\
    \ { $0.lowercased() })\n    }\n    if letterCountIndex == letterCount - 11 {\n\
    \        return Ok(words.map { $0.lowercased() })\n    }\n    if letterCountIndex\
    \ == letterCount - 12 {\n        return Ok(words.map { $0.lowercased() })\n  \
    \  }\n    if letterCountIndex == letterCount - 13 {\n        return Ok(words.map\
    \ { \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\"\
    ) == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world\
    \ !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"\
    abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpipe2ghl3.swift:77:1: error: expected ')' in expression list\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n^\n/tmp/tmpipe2ghl3.swift:73:18:\
    \ note: to match this opening '('\n        return Ok(words.map { \n          \
    \       ^\n/tmp/tmpipe2ghl3.swift:96:44: error: expected '}' at end of brace statement\n\
    assert(split_words(txt: \"\") == .failure(0))\n                              \
    \             ^\n/tmp/tmpipe2ghl3.swift:72:45: note: to match this opening '{'\n\
    \    if letterCountIndex == letterCount - 13 {\n                             \
    \               ^\n/tmp/tmpipe2ghl3.swift:96:44: error: expected '}' at end of\
    \ brace statement\nassert(split_words(txt: \"\") == .failure(0))\n           \
    \                                ^\n/tmp/tmpipe2ghl3.swift:11:56: note: to match\
    \ this opening '{'\nfunc split_words(txt: String) -> Result<[String], Int> {\n\
    \                                                       ^\n/tmp/tmpipe2ghl3.swift:12:21:\
    \ error: value of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmpipe2ghl3.swift:14:16: error:\
    \ cannot find 'Err' in scope\n        return Err(0)\n               ^~~\n/tmp/tmpipe2ghl3.swift:17:27:\
    \ error: 'characters' is unavailable: Please use String directly\n    let letterCount\
    \ = txt.characters.count\n                          ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpipe2ghl3.swift:19:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpipe2ghl3.swift:22:16:\
    \ error: cannot find 'Err' in scope\n        return Err(letterCount)\n       \
    \        ^~~\n/tmp/tmpipe2ghl3.swift:28:54: warning: 'index(of:)' is deprecated:\
    \ renamed to 'firstIndex(of:)'\n    let letterCounts = letterOrder.map { letterOrder.index(of:\
    \ $0) }\n                                                     ^\n/tmp/tmpipe2ghl3.swift:28:54:\
    \ note: use 'firstIndex(of:)' instead\n    let letterCounts = letterOrder.map\
    \ { letterOrder.index(of: $0) "
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.components(separatedBy:\
    \ \" \") else {\n        return Err(Int(errorCode: ErrorCode.invalidArgument.rawValue,\
    \ message: \"Invalid argument\"))\n    }\n    \n    let wordCount = words.count\n\
    \    \n    if wordCount == 0 {\n        return Err(Int(errorCode: ErrorCode.invalidArgument.rawValue,\
    \ message: \"Invalid argument\"))\n    }\n    \n    if wordCount == 1 {\n    \
    \    return Ok([words[0]])\n    }\n    \n    if wordCount == 2 {\n        return\
    \ Ok([words[0], words[1]])\n    }\n    \n    if wordCount == 3 {\n        return\
    \ Ok([words[0], words[1], words[2]])\n    }\n    \n    if wordCount == 4 {\n \
    \       return Ok([words[0], words[1], words[2], words[3]])\n    }\n    \n   \
    \ if wordCount == 5 {\n        return Ok([words[0], words[1], words[2], words[3],\
    \ words[4]])\n    }\n    \n    if wordCount == 6 {\n        return Ok([words[0],\
    \ words[1], words[2], words[3], words[4], words[5]])\n    }\n    \n    if wordCount\
    \ == 7 {\n        return Ok([words[0], words[1], words[2], words[3], words[4],\
    \ words[5], words[6]])\n    }\n    \n    if wordCount == 8 {\n        return Ok([words[0],\
    \ words[1], words[2], words[3], words[4], words[5], words[6], words[7]])\n   \
    \ }\n    \n    if wordCount == 9 {\n        return Ok([words[0], words[1], words[2],\
    \ words[3], words[4], words[5], words[6], words[7], words[8]])\n    }\n    \n\
    \    if wordCount == 10 {\n        return Ok([words[0], words[1], words[2], words[3],\
    \ words[4], words[5], words[6], words[7], words[8], words[9]])\n    }\n    \n\
    \    if wordCount == 11 {\n        return Ok([words[0], words[1], words[2], words[3],\
    \ words[4], words[5], words[6], words[7], words[8], words[9], words[10]])\n  \
    \  }\n    \n    if wordCount == 12 {\n        return Ok([words[0], words[1], words[2],\
    \ words[3], words[4], words[5], words[6], words[7], words[8], words[9], words[10],\
    \ words[11]])\n    }\n    \n    if wordCount == 13 {\n        return Ok([words[0],\
    \ words[1], words[2], words[3], words[4], words[5], words[6], word\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp5uv9fl4n.swift:71:94: error: expected ']' in container literal\
    \ expression\n        return Ok([words[0], words[1], words[2], words[3], words[4],\
    \ words[5], words[6], word\n                                                 \
    \                                            ^\n/tmp/tmp5uv9fl4n.swift:71:19:\
    \ note: to match this opening '['\n        return Ok([words[0], words[1], words[2],\
    \ words[3], words[4], words[5], words[6], word\n                  ^\n/tmp/tmp5uv9fl4n.swift:94:44:\
    \ error: expected '}' at end of brace statement\nassert(split_words(txt: \"\"\
    ) == .failure(0))\n                                           ^\n/tmp/tmp5uv9fl4n.swift:11:56:\
    \ note: to match this opening '{'\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n                                                       ^\n/tmp/tmp5uv9fl4n.swift:12:27:\
    \ error: value of type 'String' has no member 'components'\n    guard let words\
    \ = txt.components(separatedBy: \" \") else {\n                      ~~~ ^~~~~~~~~~\n\
    /tmp/tmp5uv9fl4n.swift:13:16: error: cannot find 'Err' in scope\n        return\
    \ Err(Int(errorCode: ErrorCode.invalidArgument.rawValue, message: \"Invalid argument\"\
    ))\n               ^~~\n/tmp/tmp5uv9fl4n.swift:13:35: error: cannot find 'ErrorCode'\
    \ in scope\n        return Err(Int(errorCode: ErrorCode.invalidArgument.rawValue,\
    \ message: \"Invalid argument\"))\n                                  ^~~~~~~~~\n\
    /tmp/tmp5uv9fl4n.swift:13:80: error: extra argument 'message' in call\n      \
    \  return Err(Int(errorCode: ErrorCode.invalidArgument.rawValue, message: \"Invalid\
    \ argument\"))\n                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5uv9fl4n.swift:19:16: error: cannot find 'Err' in scope\n        return\
    \ Err(Int(errorCode: ErrorCode.invalidArgument.rawValue, message: \"Invalid argument\"\
    ))\n               ^~~\n/tmp/tmp5uv9fl4n.swift:19:35: error: cannot find 'ErrorCode'\
    \ in scope\n        return Err(Int(errorCode: ErrorCode.invalidArgument.rawValue,\
    \ message: \"Invalid argument\"))\n                                  ^~~~~~~~~\n\
    /tmp/tmp5uv"
  stdout: ''
  timestamp: 1660054243
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(1))\n    }\n    if words.count\
    \ == 1 {\n        return Ok(words)\n    }\n    if words.count == 2 {\n       \
    \ return Ok(words)\n    }\n    if words.count == 3 {\n        return Ok(words)\n\
    \    }\n    if words.count == 4 {\n        return Ok(words)\n    }\n    if words.count\
    \ == 5 {\n        return Ok(words)\n    }\n    if words.count == 6 {\n       \
    \ return Ok(words)\n    }\n    if words.count == 7 {\n        return Ok(words)\n\
    \    }\n    if words.count == 8 {\n        return Ok(words)\n    }\n    if words.count\
    \ == 9 {\n        return Ok(words)\n    }\n    if words.count == 10 {\n      \
    \  return Ok(words)\n    }\n    if words.count == 11 {\n        return Ok(words)\n\
    \    }\n    if words.count == 12 {\n        return Ok(words)\n    }\n    if words.count\
    \ == 13 {\n        return Ok(words)\n    }\n    if words.count == 14 {\n     \
    \   return Ok(words)\n    }\n    if words.count == 15 {\n        return Ok(words)\n\
    \    }\n    if words.count == 16 {\n        return Ok(words)\n    }\n    if words.count\
    \ == 17 {\n        return Ok(words)\n    }\n    if words.count == 18 {\n     \
    \   return Ok(words)\n    }\n    if words.count == 19 {\n        return Ok(words)\n\
    \    }\n    if words.count == 20 {\n        return Ok(words)\n    }\n    if words.count\
    \ == 21 {\n        return Ok(words)\n    }\n    if words.count == 22 {\n     \
    \   return Ok(words)\n    }\n    if words.count == 23 {\n        return Ok(words)\n\
    \    }\n    if words.count == 24 {\n        return Ok(words)\n    }\n    if words.count\
    \ == 25 {\n        return Ok(words)\n    }\n    if words.count == 26 {\n     \
    \   return Ok(words)\n    }\n    if words.count == 27 {\n        return Ok(words)\n\
    \    }\n    if words.count == 28 {\n        return Ok(words)\n    }\n    if words.count\
    \ == 29 {\n        return Ok(words)\n    }\n    if words.count == 30 {\n     \
    \   return Ok(words)\n    }\n    if words.count == 31 {\n        return Ok(words)\n\
    \    }\n    if words.count == 32 {\n        return Ok(words)\n    }\n    if words.count\
    \ == 33 {\n        return Ok(words)\n    }\n    if words.count == 34 {\n     \
    \   return Ok(words)\n    }\n    if words.count == 35 {\n        return Ok(words)\n\
    \    }\n    if words.count == 36 {\n        return Ok(words)\n    }\n    if words.count\
    \ == 37 {\n        return Ok(words)\n    }\n    if words.count == 38 {\n     \
    \   return Ok(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpwuqmssnp.swift:151:44: error: expected '}' at end of brace statement\n\
    assert(split_words(txt: \"\") == .failure(0))\n                              \
    \             ^\n/tmp/tmpwuqmssnp.swift:11:56: note: to match this opening '{'\n\
    func split_words(txt: String) -> Result<[String], Int> {\n                   \
    \                                    ^\n/tmp/tmpwuqmssnp.swift:12:21: error: value\
    \ of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmpwuqmssnp.swift:14:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(1))\n               ^~~\n\
    /tmp/tmpwuqmssnp.swift:17:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpwuqmssnp.swift:20:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpwuqmssnp.swift:23:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpwuqmssnp.swift:26:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpwuqmssnp.swift:29:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpwuqmssnp.swift:32:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpwuqmssnp.swift:35:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpwuqmssnp.swift:38:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpwuqmssnp.swift:41:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpwuqmssnp.swift:44:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpwuqmssnp.swift:47:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpwuqmssnp.swift:50:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpwuqmssnp.swift:53:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpwuqmssnp.swift:56:16: error: cannot find\
    \ 'O"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    \n    if words.count == 0 {\n        return Err(Int(0))\n    }\n    \n\
    \    let wordCount = words.count\n    \n    if wordCount == 1 {\n        return\
    \ Ok([words[0]])\n    }\n    \n    let wordCount2 = wordCount + 1\n    \n    if\
    \ wordCount2 == 26 {\n        return Ok([words[0], words[1]])\n    }\n    \n \
    \   if wordCount2 == 27 {\n        return Ok([words[0], words[1], words[2]])\n\
    \    }\n    \n    if wordCount2 == 28 {\n        return Ok([words[0], words[1],\
    \ words[2], words[3]])\n    }\n    \n    if wordCount2 == 29 {\n        return\
    \ Ok([words[0], words[1], words[2], words[3], words[4]])\n    }\n    \n    if\
    \ wordCount2 == 30 {\n        return Ok([words[0], words[1], words[2], words[3],\
    \ words[4], words[5]])\n    }\n    \n    if wordCount2 == 31 {\n        return\
    \ Ok([words[0], words[1], words[2], words[3], words[4], words[5], words[6]])\n\
    \    }\n    \n    if wordCount2 == 32 {\n        return Ok([words[0], words[1],\
    \ words[2], words[3], words[4], words[5], words[6], words[7]])\n    }\n    \n\
    \    if wordCount2 == 33 {\n        return Ok([words[0], words[1], words[2], words[3],\
    \ words[4], words[5], words[6], words[7], words[8]])\n    }\n    \n    if wordCount2\
    \ == 34 {\n        return Ok([words[0], words[1], words[2], words[3], words[4],\
    \ words[5], words[6], words[7], words[8], words[9]])\n    }\n    \n    if wordCount2\
    \ == 35 {\n        return Ok([words[0], words[1], words[2], words[3], words[4],\
    \ words[5], words[6], words[7], words[8], words[9], words[10]])\n    }\n    \n\
    \    if wordCount2 == 36 {\n        return Ok([words[0], words[1], words[2], words[3],\
    \ words[4], words[5], words[6], words[7], words[8], words[9], words[10], words[11]])\n\
    \    }\n    \n    if wordCount2 == 37 {\n        return Ok([words[0], words[1],\
    \ words[2], words[3], words[4], words[5], words[6], words[7], words[8], words[9],\
    \ words[10], words[11], words[12]])\n    }\n    \n\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp6bkmqoed.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp6bkmqoed.swift:15:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(0))\n               ^~~\n/tmp/tmp6bkmqoed.swift:21:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok([words[0]])\n          \
    \     ^~\n/tmp/tmp6bkmqoed.swift:27:16: error: cannot find 'Ok' in scope\n   \
    \     return Ok([words[0], words[1]])\n               ^~\n/tmp/tmp6bkmqoed.swift:31:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok([words[0], words[1], words[2]])\n\
    \               ^~\n/tmp/tmp6bkmqoed.swift:35:16: error: cannot find 'Ok' in scope\n\
    \        return Ok([words[0], words[1], words[2], words[3]])\n               ^~\n\
    /tmp/tmp6bkmqoed.swift:39:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok([words[0], words[1], words[2], words[3], words[4]])\n               ^~\n\
    /tmp/tmp6bkmqoed.swift:43:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok([words[0], words[1], words[2], words[3], words[4], words[5]])\n         \
    \      ^~\n/tmp/tmp6bkmqoed.swift:47:16: error: cannot find 'Ok' in scope\n  \
    \      return Ok([words[0], words[1], words[2], words[3], words[4], words[5],\
    \ words[6]])\n               ^~\n/tmp/tmp6bkmqoed.swift:51:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok([words[0], words[1], words[2], words[3], words[4],\
    \ words[5], words[6], words[7]])\n               ^~\n/tmp/tmp6bkmqoed.swift:55:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok([words[0], words[1], words[2],\
    \ words[3], words[4], words[5], words[6], words[7], words[8]])\n             \
    \  ^~\n/tmp/tmp6bkmqoed.swift:59:16: error: cannot find 'Ok' in scope\n      \
    \  return Ok([words[0], words[1], words[2], words[3], words[4], words[5], words[6],\
    \ words[7], words[8], words[9]])\n               ^~\n/tmp/tmp6bkmqoed.swift:63:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok([words[0], words[1], words[2],\
    \ words[3], words[4], words[5], words[6], words[7], words[8], words[9], words[10]])\n\
    \               ^~"
  stdout: ''
  timestamp: 1660054249
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count < 2 {\n        return Err(words.count)\n    }\n    let wordCount\
    \ = words.count\n    let letterCount = words.reduce(0) { (result, word) -> Int\
    \ in\n        let letters = word.components(separatedBy: \",\")\n        return\
    \ result + (letters.count * letters.count)\n    }\n    if letterCount % 2 == 1\
    \ {\n        return Err(letterCount)\n    }\n    return Ok(words.map { $0.trimmingCharacters(in:\
    \ .whitespacesAndNewlines) })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpgnq5fix0.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpgnq5fix0.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(words.count)\n               ^~~\n/tmp/tmpgnq5fix0.swift:22:16:\
    \ error: cannot find 'Err' in scope\n        return Err(letterCount)\n       \
    \        ^~~\n/tmp/tmpgnq5fix0.swift:24:12: error: cannot find 'Ok' in scope\n\
    \    return Ok(words.map { $0.trimmingCharacters(in: .whitespacesAndNewlines)\
    \ })\n           ^~\n/tmp/tmpgnq5fix0.swift:24:54: error: cannot infer contextual\
    \ base in reference to member 'whitespacesAndNewlines'\n    return Ok(words.map\
    \ { $0.trimmingCharacters(in: .whitespacesAndNewlines) })\n                  \
    \                                  ~^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.components(separatedBy:\
    \ \" \") else {\n        return Err(Int(rawValue: 1))\n    }\n    \n    let wordCount\
    \ = words.count\n    \n    if wordCount == 0 {\n        return Err(Int(rawValue:\
    \ 1))\n    }\n    \n    let wordCountWithCommas = wordCount + words.count - 1\n\
    \    \n    if wordCountWithCommas > 26 {\n        return Err(Int(rawValue: 2))\n\
    \    }\n    \n    if wordCountWithCommas == 0 {\n        return Ok(words.map {\
    \ $0.lowercased() })\n    }\n    \n    return Ok(words.map { $0.lowercased() })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmps0m7o0d6.swift:12:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmps0m7o0d6.swift:13:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(rawValue: 1))\n         \
    \      ^~~\n/tmp/tmps0m7o0d6.swift:13:23: error: extraneous argument label 'rawValue:'\
    \ in call\n        return Err(Int(rawValue: 1))\n                      ^~~~~~~~~~~\n\
    \                       \n/tmp/tmps0m7o0d6.swift:19:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(rawValue: 1))\n               ^~~\n/tmp/tmps0m7o0d6.swift:19:23:\
    \ error: extraneous argument label 'rawValue:' in call\n        return Err(Int(rawValue:\
    \ 1))\n                      ^~~~~~~~~~~\n                       \n/tmp/tmps0m7o0d6.swift:25:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(rawValue: 2))\n  \
    \             ^~~\n/tmp/tmps0m7o0d6.swift:25:23: error: extraneous argument label\
    \ 'rawValue:' in call\n        return Err(Int(rawValue: 2))\n                \
    \      ^~~~~~~~~~~\n                       \n/tmp/tmps0m7o0d6.swift:29:16: error:\
    \ cannot find 'Ok' in scope\n        return Ok(words.map { $0.lowercased() })\n\
    \               ^~\n/tmp/tmps0m7o0d6.swift:32:12: error: cannot find 'Ok' in scope\n\
    \    return Ok(words.map { $0.lowercased() })\n           ^~\n"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    let wordCount = words.count\n    let letterCount = txt.unicodeScalars.filter({\
    \ $0.isLetter }).count\n    \n    if wordCount == 0 || letterCount == 0 {\n  \
    \      return Err(wordCount)\n    }\n    \n    let wordCountWithCommas = wordCount.map\
    \ { String($0) }\n    let letterCountWithCommas = letterCount.map { String($0)\
    \ }\n    \n    return Ok(wordCountWithCommas.joined(separator: \",\").lowercased()\
    \ + \",\" + letterCountWithCommas.joined(separator: \",\"))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpysjq6ebs.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpysjq6ebs.swift:14:54: error: value of type 'Unicode.Scalar'\
    \ has no member 'isLetter'\n    let letterCount = txt.unicodeScalars.filter({\
    \ $0.isLetter }).count\n                                                  ~~ ^~~~~~~~\n\
    /tmp/tmpysjq6ebs.swift:17:16: error: cannot find 'Err' in scope\n        return\
    \ Err(wordCount)\n               ^~~\n/tmp/tmpysjq6ebs.swift:23:12: error: cannot\
    \ find 'Ok' in scope\n    return Ok(wordCountWithCommas.joined(separator: \",\"\
    ).lowercased() + \",\" + letterCountWithCommas.joined(separator: \",\"))\n   \
    \        ^~\n"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(0)\n    }\n    let wordCount\
    \ = words.count\n    let wordArray = words.map { $0.lowercased() }\n    let wordArrayCount\
    \ = wordArray.count\n    if wordArrayCount % 2 == 1 {\n        return Err(wordArrayCount)\n\
    \    }\n    if wordArrayCount % 2 == 0 {\n        let evenWordArray = wordArray.filter\
    \ { $0 % 2 == 0 }\n        let evenWordArrayCount = evenWordArray.count\n    \
    \    if evenWordArrayCount % 2 == 1 {\n            return Err(evenWordArrayCount)\n\
    \        }\n        let evenWordArrayCount = evenWordArray.count\n        let\
    \ evenWordArray = evenWordArray.map { $0.lowercased() }\n        return Ok(evenWordArray)\n\
    \    }\n    return Err(wordArrayCount)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpnqrmnsvi.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpnqrmnsvi.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(0)\n               ^~~\n/tmp/tmpnqrmnsvi.swift:20:16:\
    \ error: cannot find 'Err' in scope\n        return Err(wordArrayCount)\n    \
    \           ^~~\n/tmp/tmpnqrmnsvi.swift:26:20: error: cannot find 'Err' in scope\n\
    \            return Err(evenWordArrayCount)\n                   ^~~\n/tmp/tmpnqrmnsvi.swift:30:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(evenWordArray)\n       \
    \        ^~\n/tmp/tmpnqrmnsvi.swift:32:12: error: cannot find 'Err' in scope\n\
    \    return Err(wordArrayCount)\n           ^~~\n"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(0))\n    }\n    let wordCount\
    \ = words.count\n    let wordArray = words.map { $0.trimmingCharacters(in: .whitespacesAndNewlines)\
    \ }\n    let wordArrayCount = wordArray.count\n    if wordArrayCount % 2 != 0\
    \ {\n        return Err(Int(0))\n    }\n    let evenWordArray = wordArray.filter\
    \ { $0.count % 2 == 0 }\n    let evenWordArrayCount = evenWordArray.count\n  \
    \  if evenWordArrayCount != wordArrayCount {\n        return Err(Int(0))\n   \
    \ }\n    let evenWordArrayLetters = evenWordArray.map { $0.count }\n    let evenWordArrayLettersCount\
    \ = evenWordArrayLetters.count\n    if evenWordArrayLettersCount != wordArrayCount\
    \ {\n        return Err(Int(0))\n    }\n    let evenWordArrayLettersOdd = evenWordArrayLetters.filter\
    \ { $0 % 2 == 1 }\n    let evenWordArrayLettersOddCount = evenWordArrayLettersOdd.count\n\
    \    if evenWordArrayLettersOddCount != wordArrayCount {\n        return Err(Int(0))\n\
    \    }\n    let evenWordArrayLettersOddOdd = evenWordArrayLettersOdd.filter {\
    \ $0 % 2 == 0 }\n    let evenWordArrayLettersOddOddCount = evenWordArrayLettersOddOdd.count\n\
    \    if evenWordArrayLettersOddOddCount != wordArrayCount {\n        return Err(Int(0))\n\
    \    }\n    let evenWordArrayLettersOddOddOdd = evenWordArrayLettersOddOdd.filter\
    \ { $0 % 2 == 1 }\n    let evenWordArrayLettersOddOddOddCount = evenWordArrayLettersOddOddOdd.count\n\
    \    if evenWordArrayLettersOddOddOddCount != wordArrayCount {\n        return\
    \ Err(Int(0))\n    }\n    let evenWordArrayLettersOddOddOddOdd = evenWordArrayLettersOddOddOdd.filter\
    \ { $0 % 2 == 0 }\n    let evenWordArrayLettersOddOddOddOddCount = evenWordArrayLettersOddOddOddOdd.count\n\
    \    if evenWordArrayLettersOddOddOddOddCount != wordArrayCount {\n        return\
    \ Err(Int(0))\n    }\n    let evenWordArrayLettersOddOddOdd\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpxrzoa8i0.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpxrzoa8i0.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(0))\n               ^~~\n/tmp/tmpxrzoa8i0.swift:17:60:\
    \ error: cannot infer contextual base in reference to member 'whitespacesAndNewlines'\n\
    \    let wordArray = words.map { $0.trimmingCharacters(in: .whitespacesAndNewlines)\
    \ }\n                                                          ~^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpxrzoa8i0.swift:20:16: error: cannot find 'Err' in scope\n        return\
    \ Err(Int(0))\n               ^~~\n/tmp/tmpxrzoa8i0.swift:25:16: error: cannot\
    \ find 'Err' in scope\n        return Err(Int(0))\n               ^~~\n/tmp/tmpxrzoa8i0.swift:30:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(0))\n            \
    \   ^~~\n/tmp/tmpxrzoa8i0.swift:35:16: error: cannot find 'Err' in scope\n   \
    \     return Err(Int(0))\n               ^~~\n/tmp/tmpxrzoa8i0.swift:40:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(0))\n               ^~~\n\
    /tmp/tmpxrzoa8i0.swift:45:16: error: cannot find 'Err' in scope\n        return\
    \ Err(Int(0))\n               ^~~\n/tmp/tmpxrzoa8i0.swift:50:16: error: cannot\
    \ find 'Err' in scope\n        return Err(Int(0))\n               ^~~\n/tmp/tmpxrzoa8i0.swift:52:9:\
    \ error: type annotation missing in pattern\n    let evenWordArrayLettersOddOddOdd\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    \n    if words.count == 0 {\n        return Err(Int(1))\n    }\n    \n\
    \    if words.count == 1 {\n        return Ok(words)\n    }\n    \n    let wordCount\
    \ = words.count\n    let wordCountWithCommas = wordCount + words.count - 1\n \
    \   \n    if wordCountWithCommas == 0 {\n        return Ok(words)\n    }\n   \
    \ \n    if wordCountWithCommas == 1 {\n        return Ok(words + [\"\"])\n   \
    \ }\n    \n    let wordCountWithCommasWithOddOrder = wordCountWithCommas + words.count\
    \ - 1\n    \n    if wordCountWithCommasWithOddOrder == 0 {\n        return Ok(words)\n\
    \    }\n    \n    if wordCountWithCommasWithOddOrder == 1 {\n        return Ok(words\
    \ + [\"\"])\n    }\n    \n    return Err(Int(1))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpdtfuqmu9.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpdtfuqmu9.swift:15:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(1))\n               ^~~\n/tmp/tmpdtfuqmu9.swift:19:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpdtfuqmu9.swift:26:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpdtfuqmu9.swift:30:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words + [\"\"])\n               ^~\n/tmp/tmpdtfuqmu9.swift:36:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpdtfuqmu9.swift:40:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words + [\"\"])\n               ^~\n/tmp/tmpdtfuqmu9.swift:43:12: error:\
    \ cannot find 'Err' in scope\n    return Err(Int(1))\n           ^~~\n"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    guard words.count > 0 else { return Err(0) }\n    guard words.count % 2\
    \ == 0 else { return Err(0) }\n    guard let first = words.first else { return\
    \ Err(0) }\n    let count = words.count / 2\n    let splitted = words.suffix(from:\
    \ count * 2)\n    return Ok(splitted)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpzfehj9bv.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpzfehj9bv.swift:13:41: error: cannot find 'Err'\
    \ in scope\n    guard words.count > 0 else { return Err(0) }\n               \
    \                         ^~~\n/tmp/tmpzfehj9bv.swift:14:46: error: cannot find\
    \ 'Err' in scope\n    guard words.count % 2 == 0 else { return Err(0) }\n    \
    \                                         ^~~\n/tmp/tmpzfehj9bv.swift:15:49: error:\
    \ cannot find 'Err' in scope\n    guard let first = words.first else { return\
    \ Err(0) }\n                                                ^~~\n/tmp/tmpzfehj9bv.swift:18:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(splitted)\n           ^~\n"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int((txt.characters.count - 1)\
    \ / 2))\n    }\n    if words.count == 1 {\n        return Ok(words)\n    }\n \
    \   let chars = txt.characters\n    let lower = chars.filter { $0.isLowercase\
    \ }\n    let odd = chars.filter { $0.isOdd }\n    if lower.count == 0 {\n    \
    \    return Err(Int((txt.characters.count - 1) / 2))\n    }\n    if odd.count\
    \ == 0 {\n        return Ok(words)\n    }\n    return Ok(words.prefix(lower.count).append(odd.prefix(odd.count)))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp9b4nhwu3.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp9b4nhwu3.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int((txt.characters.count - 1) / 2))\n        \
    \       ^~~\n/tmp/tmp9b4nhwu3.swift:17:16: error: cannot find 'Ok' in scope\n\
    \        return Ok(words)\n               ^~\n/tmp/tmp9b4nhwu3.swift:19:21: error:\
    \ 'characters' is unavailable: Please use String directly\n    let chars = txt.characters\n\
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp9b4nhwu3.swift:21:33: error: value of type 'String.Element' (aka\
    \ 'Character') has no member 'isOdd'\n    let odd = chars.filter { $0.isOdd }\n\
    \                             ~~ ^~~~~\n/tmp/tmp9b4nhwu3.swift:23:16: error: cannot\
    \ find 'Err' in scope\n        return Err(Int((txt.characters.count - 1) / 2))\n\
    \               ^~~\n/tmp/tmp9b4nhwu3.swift:26:16: error: cannot find 'Ok' in\
    \ scope\n        return Ok(words)\n               ^~\n/tmp/tmp9b4nhwu3.swift:28:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words.prefix(lower.count).append(odd.prefix(odd.count)))\n\
    \           ^~\n"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(0))\n    }\n    let words\
    \ = words.filter { !$0.isEmpty }\n    if words.count == 0 {\n        return Err(Int(0))\n\
    \    }\n    let words = words.map { $0.lowercased() }\n    let wordCount = words.count\n\
    \    if wordCount == 0 {\n        return Err(Int(0))\n    }\n    let wordCountOdd\
    \ = wordCount % 2 == 1\n    let alphabet = Array(Array(UInt8(97) + 1 ... UInt8(122)))\n\
    \    let alphabetCount = alphabet.count\n    if alphabetCount == 0 {\n       \
    \ return Err(Int(0))\n    }\n    let alphabetCountOdd = alphabetCount % 2 == 1\n\
    \    if wordCountOdd && alphabetCountOdd {\n        return Ok(words)\n    }\n\
    \    if wordCountOdd {\n        return Ok(words.map { $0.lowercased() })\n   \
    \ }\n    if alphabetCountOdd {\n        return Ok(words.map { $0.lowercased()\
    \ })\n    }\n    return Ok(words.map { $0.lowercased() })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpp__d29rm.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpp__d29rm.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(0))\n               ^~~\n/tmp/tmpp__d29rm.swift:18:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(0))\n            \
    \   ^~~\n/tmp/tmpp__d29rm.swift:23:16: error: cannot find 'Err' in scope\n   \
    \     return Err(Int(0))\n               ^~~\n/tmp/tmpp__d29rm.swift:29:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(0))\n               ^~~\n\
    /tmp/tmpp__d29rm.swift:33:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpp__d29rm.swift:36:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words.map { $0.lowercased() })\n          \
    \     ^~\n/tmp/tmpp__d29rm.swift:39:16: error: cannot find 'Ok' in scope\n   \
    \     return Ok(words.map { $0.lowercased() })\n               ^~\n/tmp/tmpp__d29rm.swift:41:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words.map { $0.lowercased()\
    \ })\n           ^~\n"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    \n    let words = txt.components(separatedBy:\
    \ \" \")\n    \n    if words.count == 0 {\n        return Err(Int(0))\n    }\n\
    \    \n    let splitWords = words.map { $0.components(separatedBy: \",\") }\n\
    \    \n    if splitWords.count == 0 {\n        return Err(Int(0))\n    }\n   \
    \ \n    let letters = splitWords.map { $0.map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "error: compile command failed due to signal 15 (use -v to see invocation)\n\
    /tmp/tmp2c98vwb_.swift:26:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmp2c98vwb_.swift:48:44: error: expected '}' at end of brace statement\n\
    assert(split_words(txt: \"\") == .failure(0))\n                              \
    \             ^\n/tmp/tmp2c98vwb_.swift:11:56: note: to match this opening '{'\n\
    func split_words(txt: String) -> Result<[String], Int> {\n                   \
    \                                    ^\n/tmp/tmp2c98vwb_.swift:13:21: error: value\
    \ of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmp2c98vwb_.swift:16:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(0))\n               ^~~\n\
    /tmp/tmp2c98vwb_.swift:22:16: error: cannot find 'Err' in scope\n        return\
    \ Err(Int(0))\n               ^~~\n"
  stdout: ''
  timestamp: 1660054326
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    guard words.count > 0 else {\n        return Err(Int(.init(rawValue: 0)))\
    \ \n    }\n    \n    let wordCount = words.count\n    \n    let wordCountWithCommas\
    \ = wordCount + words.count - 1\n    \n    let wordCountWithCommasWithOddOrder\
    \ = wordCountWithCommas + words.count - 1\n    \n    let wordCountWithCommasWithOddOrderWithOddOrder\
    \ = wordCountWithCommasWithOddOrder + words.count - 1\n    \n    let wordCountWithCommasWithOddOrderWithOddOrderWithOddOrder\
    \ = wordCountWithCommasWithOddOrderWithOddOrder + words.count - 1\n    \n    let\
    \ wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrder = wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrder\
    \ + words.count - 1\n    \n    let wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrder\
    \ = wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrder\
    \ + words.count - 1\n    \n    let wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrder\
    \ = wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrder\
    \ + words.count - 1\n    \n    let wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrder\
    \ = wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrder\
    \ + words.count - 1\n    \n    let wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrder\
    \ = wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrder\
    \ + words.count - 1\n    \n    let wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWith\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpg7hsh14g.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpg7hsh14g.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(.init(rawValue: 0))) \n               ^~~\n\
    /tmp/tmpg7hsh14g.swift:14:25: error: reference to member 'init' cannot be resolved\
    \ without a contextual type\n        return Err(Int(.init(rawValue: 0))) \n  \
    \                      ^\n/tmp/tmpg7hsh14g.swift:27:79: error: use of local variable\
    \ 'wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrder' before\
    \ its declaration\n    let wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrder\
    \ = wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrder + words.count\
    \ - 1\n                                                                      \
    \        ^\n/tmp/tmpg7hsh14g.swift:27:9: note: 'wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrder'\
    \ declared here\n    let wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrder\
    \ = wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrder + words.count\
    \ - 1\n        ^\n/tmp/tmpg7hsh14g.swift:29:91: error: use of local variable 'wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrder'\
    \ before its declaration\n    let wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrder\
    \ = wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrder\
    \ + words.count - 1\n                                                        \
    \                                  ^\n/tmp/tmpg7hsh14g.swift:29:9: note: 'wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrder'\
    \ declared here\n    let wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrder\
    \ = wordCountWithCommasWithOddOrderWithOddOrderWithOddOrderWithOddOrderWithOddOrder\
    \ + words.count - 1\n        ^\n/tmp/tmpg7hsh14g.swift:31:103: error: use of local\
    \ variable 'wordCountWithCommasWithOddOrderWithOddOrderWithOdd"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(0))\n    }\n    let firstWord\
    \ = words[0]\n    let lastWord = words[words.count - 1]\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return Err(Int(0))\n    }\n    if lastWord.hasSuffix(\",\") {\n\
    \        return Err(Int(0))\n    }\n    if firstWord.hasSuffix(\"!\") {\n    \
    \    return Err(Int(0))\n    }\n    if lastWord.hasPrefix(\"!\") {\n        return\
    \ Err(Int(0))\n    }\n    if firstWord.hasPrefix(\",\") {\n        return Err(Int(0))\n\
    \    }\n    if lastWord.hasSuffix(\",\") {\n        return Err(Int(0))\n    }\n\
    \    if firstWord.hasPrefix(\",\") {\n        return Err(Int(0))\n    }\n    if\
    \ lastWord.hasSuffix(\",\") {\n        return Err(Int(0))\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return Err(Int(0))\n    }\n    if lastWord.hasSuffix(\",\") {\n\
    \        return Err(Int(0))\n    }\n    if firstWord.hasPrefix(\",\") {\n    \
    \    return Err(Int(0))\n    }\n    if lastWord.hasSuffix(\",\") {\n        return\
    \ Err(Int(0))\n    }\n    if firstWord.hasPrefix(\",\") {\n        return Err(Int(0))\n\
    \    }\n    if lastWord.hasSuffix(\",\") {\n        return Err(Int(0))\n    }\n\
    \    if firstWord.hasPrefix(\",\") {\n        return Err(Int(0))\n    }\n    if\
    \ lastWord.hasSuffix(\",\") {\n        return Err(Int(0))\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return Err(Int(0))\n    }\n    if lastWord.hasSuffix(\",\") {\n\
    \        return Err(Int(0))\n    }\n    if firstWord.hasPrefix(\",\") {\n    \
    \    return Err(Int(0))\n    }\n    if lastWord.hasSuffix(\",\") {\n        return\
    \ Err(Int(0))\n    }\n    if firstWord.hasPrefix(\",\") {\n        return Err(Int(0))\n\
    \    }\n    if lastWord.hasSuffix(\",\") {\n        return Err(Int(0))\n    }\n\
    \    if firstWord.hasPrefix(\",\") {\n        return Err(Int(0))\n    }\n    if\
    \ lastWord.hasSuffix(\",\") {\n        return Err(Int(0))\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return Err(Int(0))\n    }\n    if lastWord.hasSuffix(\",\") {\n\
    \        return Err(Int(0))\n    }\n    if \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp6753wp8f.swift:96:7: error: expected expression, var, or let in\
    \ 'if' condition\n    if \n      ^\n/tmp/tmp6753wp8f.swift:12:21: error: value\
    \ of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmp6753wp8f.swift:14:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(0))\n               ^~~\n\
    /tmp/tmp6753wp8f.swift:19:16: error: cannot find 'Err' in scope\n        return\
    \ Err(Int(0))\n               ^~~\n/tmp/tmp6753wp8f.swift:22:16: error: cannot\
    \ find 'Err' in scope\n        return Err(Int(0))\n               ^~~\n/tmp/tmp6753wp8f.swift:25:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(0))\n            \
    \   ^~~\n/tmp/tmp6753wp8f.swift:28:16: error: cannot find 'Err' in scope\n   \
    \     return Err(Int(0))\n               ^~~\n/tmp/tmp6753wp8f.swift:31:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(0))\n               ^~~\n\
    /tmp/tmp6753wp8f.swift:34:16: error: cannot find 'Err' in scope\n        return\
    \ Err(Int(0))\n               ^~~\n/tmp/tmp6753wp8f.swift:37:16: error: cannot\
    \ find 'Err' in scope\n        return Err(Int(0))\n               ^~~\n/tmp/tmp6753wp8f.swift:40:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(0))\n            \
    \   ^~~\n/tmp/tmp6753wp8f.swift:43:16: error: cannot find 'Err' in scope\n   \
    \     return Err(Int(0))\n               ^~~\n/tmp/tmp6753wp8f.swift:46:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(0))\n               ^~~\n\
    /tmp/tmp6753wp8f.swift:49:16: error: cannot find 'Err' in scope\n        return\
    \ Err(Int(0))\n               ^~~\n/tmp/tmp6753wp8f.swift:52:16: error: cannot\
    \ find 'Err' in scope\n        return Err(Int(0))\n               ^~~\n/tmp/tmp6753wp8f.swift:55:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(0))\n            \
    \   ^~~\n/tmp/tmp6753wp8f.swift:58:16: error: cannot find 'Err' in scope\n   \
    \     return Err(Int(0))\n               ^~~\n/tmp/tmp6753wp8f.swift:61:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(0))\n               ^~~\n\
    /tmp/tmp6753wp8f.s"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    let count = words.count\n    \n    if words.count == 0 {\n        return\
    \ Err(Int(count))\n    }\n    \n    let wordCounts = words.map { $0.characters.count\
    \ }\n    \n    if wordCounts.contains(where: { $0 % 2 == 1 }) {\n        return\
    \ Err(Int(count))\n    }\n    \n    if wordCounts.contains(where: { $0 % 2 ==\
    \ 0 }) {\n        return Err(Int(count))\n    }\n    \n    return Ok(words.map\
    \ { $0.lowercased() })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp8bcovjqg.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp8bcovjqg.swift:16:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(count))\n               ^~~\n/tmp/tmp8bcovjqg.swift:22:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(count))\n        \
    \       ^~~\n/tmp/tmp8bcovjqg.swift:26:16: error: cannot find 'Err' in scope\n\
    \        return Err(Int(count))\n               ^~~\n/tmp/tmp8bcovjqg.swift:29:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words.map { $0.lowercased()\
    \ })\n           ^~\n"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(1))\n    }\n    if words.count\
    \ == 1 {\n        return Ok(words)\n    }\n    let comma = words.last!.components(separatedBy:\
    \ \",\")\n    if comma.count == 0 {\n        return Ok(words)\n    }\n    if comma.count\
    \ == 1 {\n        return Ok(words + [comma])\n    }\n    let letters = words.map\
    \ { $0.lowercased().count }\n    let odd = letters.filter { $0 % 2 == 1 }\n  \
    \  return Ok(odd)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp8mjrdf6f.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp8mjrdf6f.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(1))\n               ^~~\n/tmp/tmp8mjrdf6f.swift:17:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmp8mjrdf6f.swift:21:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmp8mjrdf6f.swift:24:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words + [comma])\n               ^~\n/tmp/tmp8mjrdf6f.swift:28:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(odd)\n           ^~\n"
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(1))\n    }\n    if words.count\
    \ == 1 {\n        return Ok(words)\n    }\n    let wordCount = words.count\n \
    \   let wordArray = words.map { $0.lowercased() }\n    let evenWordArray = wordArray.filter\
    \ { $0.count % 2 == 0 }\n    let oddWordArray = wordArray.filter { $0.count %\
    \ 2 != 0 }\n    if wordCount == evenWordArray.count {\n        return Ok(evenWordArray)\n\
    \    }\n    if wordCount == oddWordArray.count {\n        return Ok(oddWordArray)\n\
    \    }\n    return Err(Int(1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp64m64yaj.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp64m64yaj.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(1))\n               ^~~\n/tmp/tmp64m64yaj.swift:17:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmp64m64yaj.swift:24:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(evenWordArray)\n               ^~\n/tmp/tmp64m64yaj.swift:27:16: error: cannot\
    \ find 'Ok' in scope\n        return Ok(oddWordArray)\n               ^~\n/tmp/tmp64m64yaj.swift:29:12:\
    \ error: cannot find 'Err' in scope\n    return Err(Int(1))\n           ^~~\n"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    let wordsCount = words.count\n    let lettersCount = txt.unicodeScalars.filter({\
    \ $0.isLetter }).count\n    \n    guard lettersCount % 2 == 1 else {\n       \
    \ return Err(lettersCount)\n    }\n    \n    guard wordsCount > 0 else {\n   \
    \     return Err(wordsCount)\n    }\n    \n    return Ok(words.map { $0.trimmingCharacters(in:\
    \ .whitespaces) })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpa_nzcrcf.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpa_nzcrcf.swift:14:55: error: value of type 'Unicode.Scalar'\
    \ has no member 'isLetter'\n    let lettersCount = txt.unicodeScalars.filter({\
    \ $0.isLetter }).count\n                                                   ~~\
    \ ^~~~~~~~\n/tmp/tmpa_nzcrcf.swift:17:16: error: cannot find 'Err' in scope\n\
    \        return Err(lettersCount)\n               ^~~\n/tmp/tmpa_nzcrcf.swift:21:16:\
    \ error: cannot find 'Err' in scope\n        return Err(wordsCount)\n        \
    \       ^~~\n/tmp/tmpa_nzcrcf.swift:24:12: error: cannot find 'Ok' in scope\n\
    \    return Ok(words.map { $0.trimmingCharacters(in: .whitespaces) })\n      \
    \     ^~\n/tmp/tmpa_nzcrcf.swift:24:54: error: cannot infer contextual base in\
    \ reference to member 'whitespaces'\n    return Ok(words.map { $0.trimmingCharacters(in:\
    \ .whitespaces) })\n                                                    ~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(0))\n    }\n    let wordCount\
    \ = words.count\n    let letterCount = txt.unicodeScalars.filter({ $0.isLetter\
    \ }).count\n    if wordCount == letterCount {\n        return Ok(words)\n    }\n\
    \    if letterCount % 2 == 1 {\n        return Err(Int(0))\n    }\n    return\
    \ Ok(words.filter { $0.isEmpty || $0.isEmpty == false })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmphan1kmw9.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmphan1kmw9.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(0))\n               ^~~\n/tmp/tmphan1kmw9.swift:17:54:\
    \ error: value of type 'Unicode.Scalar' has no member 'isLetter'\n    let letterCount\
    \ = txt.unicodeScalars.filter({ $0.isLetter }).count\n                       \
    \                           ~~ ^~~~~~~~\n/tmp/tmphan1kmw9.swift:19:16: error:\
    \ cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmphan1kmw9.swift:22:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(0))\n            \
    \   ^~~\n/tmp/tmphan1kmw9.swift:24:12: error: cannot find 'Ok' in scope\n    return\
    \ Ok(words.filter { $0.isEmpty || $0.isEmpty == false })\n           ^~\n"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count < 2 {\n        return Err(words.count)\n    }\n    let comma\
    \ = words.last!.components(separatedBy: \",\")\n    if comma.count < 2 {\n   \
    \     return Err(comma.count)\n    }\n    let letters = words.last!.unicodeScalars.filter({\
    \ $0.isLetter() }).map({ $0.value })\n    let odd = letters.filter({ $0.count\
    \ % 2 == 1 })\n    if odd.count < 1 {\n        return Err(odd.count)\n    }\n\
    \    return Ok(odd.map({ $0.joined(separator: \",\") }))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpdncyyick.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpdncyyick.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(words.count)\n               ^~~\n/tmp/tmpdncyyick.swift:18:16:\
    \ error: cannot find 'Err' in scope\n        return Err(comma.count)\n       \
    \        ^~~\n/tmp/tmpdncyyick.swift:23:16: error: cannot find 'Err' in scope\n\
    \        return Err(odd.count)\n               ^~~\n/tmp/tmpdncyyick.swift:25:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(odd.map({ $0.joined(separator:\
    \ \",\") }))\n           ^~\n"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.split(separator: \" \"\
    ) else {\n        return Err(Int(.lowercaseLetters))\n    }\n    \n    var result:\
    \ [String] = []\n    \n    for word in words {\n        guard let wordWithoutSpaces\
    \ = word.trimmingCharacters(in: .whitespaces) else {\n            return Err(Int(.lowercaseLetters))\n\
    \        }\n        \n        if wordWithoutSpaces.isEmpty {\n            continue\n\
    \        }\n        \n        if let comma = wordWithoutSpaces.range(of: \",\"\
    ) {\n            result.append(wordWithoutSpaces.substring(to: comma.lowerBound))\n\
    \        } else {\n            result.append(wordWithoutSpaces)\n        }\n \
    \   }\n    \n    return Ok(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp01v66lt6.swift:13:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(.lowercaseLetters))\n               ^~~\n/tmp/tmp01v66lt6.swift:13:24:\
    \ error: missing argument label 'bitPattern:' in call\n        return Err(Int(.lowercaseLetters))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmp01v66lt6.swift:12:11:\
    \ error: initializer for conditional binding must have Optional type, not '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n    guard let words = txt.split(separator: \" \")\
    \ else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp01v66lt6.swift:19:44:\
    \ error: value of type 'String.SubSequence' (aka 'Substring') has no member 'trimmingCharacters'\n\
    \        guard let wordWithoutSpaces = word.trimmingCharacters(in: .whitespaces)\
    \ else {\n                                      ~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp01v66lt6.swift:19:68:\
    \ error: cannot infer contextual base in reference to member 'whitespaces'\n \
    \       guard let wordWithoutSpaces = word.trimmingCharacters(in: .whitespaces)\
    \ else {\n                                                                  ~^~~~~~~~~~~\n\
    /tmp/tmp01v66lt6.swift:20:20: error: cannot find 'Err' in scope\n            return\
    \ Err(Int(.lowercaseLetters))\n                   ^~~\n/tmp/tmp01v66lt6.swift:20:28:\
    \ error: missing argument label 'bitPattern:' in call\n            return Err(Int(.lowercaseLetters))\n\
    \                           ^\n                           bitPattern: \n/tmp/tmp01v66lt6.swift:34:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(result)\n           ^~\n"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    guard words.count > 0 else {\n        return Err(Int(errorCode: ErrorCode.invalidArgument.rawValue,\
    \ message: \"Invalid argument\"))\n    }\n    guard words.count <= 25 && words.count\
    \ >= 1 else {\n        return Err(Int(errorCode: ErrorCode.invalidArgument.rawValue,\
    \ message: \"Invalid argument\"))\n    }\n    \n    var result: [String] = []\n\
    \    for word in words {\n        if let wordCount = word.characters.count {\n\
    \            if wordCount > 0 {\n                result.append(word)\n       \
    \     }\n        } else {\n            if let wordCount = word.characters.count\
    \ {\n                if wordCount > 0 {\n                    result.append(word)\n\
    \                }\n            } else {\n                if let wordCount = word.characters.count\
    \ {\n                    if wordCount > 0 {\n                        result.append(word)\n\
    \                    }\n                } else {\n                    if let wordCount\
    \ = word.characters.count {\n                        if wordCount > 0 {\n    \
    \                        result.append(word)\n                        }\n    \
    \                } else {\n                        if let wordCount = word.characters.count\
    \ {\n                            if wordCount > 0 {\n                        \
    \        result.append(word)\n                            }\n                \
    \        } else {\n                            if let wordCount = word.characters.count\
    \ {\n                                if wordCount > 0 {\n                    \
    \                result.append(word)\n                                }\n    \
    \                        } else {\n                                if let wordCount\
    \ = word.characters.count {\n                                    if wordCount\
    \ > 0 {\n                                        result.append(word)\n       \
    \                             }\n                                } else {\n  \
    \                                  if let wordCount = word.characters.count {\n\
    \                                        if wordCount > 0 {\n                \
    \                            result.append(word)\n                           \
    \             }\n                                    } else {\n              \
    \                          if let wordCount = word.characters.count {\n      \
    \                                      if wordCount > 0 {\n                  \
    \                              result.append(word)\n                         \
    \                   }\n                                        } else {\n    \
    \                                        if let wordCount = word.characters.count\
    \ {\n                                                if wordCount > 0 {\n    \
    \                                                result.append(word)\n       \
    \                                         }\n                                \
    \            } else {\n                                                if let\
    \ wordCount = word.characters.count {\n                                      \
    \              if wordCount > 0 {\n                                          \
    \              result.append(word)\n                                         \
    \           }\n                                                } else {\n    \
    \                                                if let wordCount = word.characters.count\
    \ {\n                                                        if wordCount > 0\
    \ {\n                                                            result.append(word)\n\
    \                                                        }\n                 \
    \                                   } else {\n                               \
    \                         if let wordCount = word.characters.count {\n       \
    \                                                     if wordCount > 0 {\n   \
    \                                                             result.append(word)\n\
    \                                                            }\n             \
    \                                           } else {\n                       \
    \                                     if let wordCount = word.characters.count\
    \ {\n                                                                if wordCount\
    \ > 0 {\n                                                                    result.append(word)\n\
    \                                                                }\n         \
    \                                                   } else {\n               \
    \                                                 if let wordCount = word.characters.count\
    \ {\n                                                                    if wordCount\
    \ > 0 {\n                                                                    \
    \    result.append(word)\n                                                   \
    \                 }\n                                                        \
    \        } else {\n                                                          \
    \          if let wordCount = word.characters.count {\n                      \
    \                                                                  if wordCount\
    \ > 0 {\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello\
    \ world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"\
    Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpcli_u06m.swift:121:44: error: expected '}' at end of brace statement\n\
    assert(split_words(txt: \"\") == .failure(0))\n                              \
    \             ^\n/tmp/tmpcli_u06m.swift:97:110: note: to match this opening '{'\n\
    \                                                                    if let wordCount\
    \ = word.characters.count {\n                                                \
    \                                                             ^\n/tmp/tmpcli_u06m.swift:121:44:\
    \ error: expected '}' at end of brace statement\nassert(split_words(txt: \"\"\
    ) == .failure(0))\n                                           ^\n/tmp/tmpcli_u06m.swift:96:72:\
    \ note: to match this opening '{'\n                                          \
    \                      } else {\n                                            \
    \                           ^\n/tmp/tmpcli_u06m.swift:121:44: error: expected\
    \ '}' at end of brace statement\nassert(split_words(txt: \"\") == .failure(0))\n\
    \                                           ^\n/tmp/tmpcli_u06m.swift:91:68: note:\
    \ to match this opening '{'\n                                                \
    \            } else {\n                                                      \
    \             ^\n/tmp/tmpcli_u06m.swift:121:44: error: expected '}' at end of\
    \ brace statement\nassert(split_words(txt: \"\") == .failure(0))\n           \
    \                                ^\n/tmp/tmpcli_u06m.swift:86:64: note: to match\
    \ this opening '{'\n                                                        }\
    \ else {\n                                                               ^\n/tmp/tmpcli_u06m.swift:121:44:\
    \ error: expected '}' at end of brace statement\nassert(split_words(txt: \"\"\
    ) == .failure(0))\n                                           ^\n/tmp/tmpcli_u06m.swift:81:60:\
    \ note: to match this opening '{'\n                                          \
    \          } else {\n                                                        \
    \   ^\n/tmp/tmpcli_u06m.swift:121:44: error: expected '}' at end of brace statement\n\
    assert(split_words(txt: \"\") == .failure(0))\n                            "
  stdout: ''
  timestamp: 1660054238
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.components(separatedBy:\
    \ \" \") else {\n        return Err(Int(.Failure))\n    }\n    \n    var result:\
    \ [String] = []\n    \n    for word in words {\n        guard let wordWithoutSpaces\
    \ = word.trimmingCharacters(in: .whitespaces) else {\n            return Err(Int(.Failure))\n\
    \        }\n        \n        if wordWithoutSpaces.count > 0 {\n            result.append(wordWithoutSpaces)\n\
    \        }\n    }\n    \n    if result.count > 0 {\n        return Ok(result)\n\
    \    }\n    \n    if txt.count > 0 {\n        let letters = txt.unicodeScalars.filter({\
    \ $0.isLetter}).count\n        return Ok(letters)\n    }\n    \n    return Err(Int(.Failure))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmptwjs6igj.swift:12:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmptwjs6igj.swift:13:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(.Failure))\n            \
    \   ^~~\n/tmp/tmptwjs6igj.swift:13:24: error: missing argument label 'bitPattern:'\
    \ in call\n        return Err(Int(.Failure))\n                       ^\n     \
    \                  bitPattern: \n/tmp/tmptwjs6igj.swift:29:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(result)\n               ^~\n/tmp/tmptwjs6igj.swift:33:54:\
    \ error: value of type 'Unicode.Scalar' has no member 'isLetter'\n        let\
    \ letters = txt.unicodeScalars.filter({ $0.isLetter}).count\n                \
    \                                  ~~ ^~~~~~~~\n/tmp/tmptwjs6igj.swift:34:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(letters)\n             \
    \  ^~\n/tmp/tmptwjs6igj.swift:37:12: error: cannot find 'Err' in scope\n    return\
    \ Err(Int(.Failure))\n           ^~~\n/tmp/tmptwjs6igj.swift:37:20: error: missing\
    \ argument label 'bitPattern:' in call\n    return Err(Int(.Failure))\n      \
    \             ^\n                   bitPattern: \n/tmp/tmptwjs6igj.swift:19:68:\
    \ error: cannot infer contextual base in reference to member 'whitespaces'\n \
    \       guard let wordWithoutSpaces = word.trimmingCharacters(in: .whitespaces)\
    \ else {\n                                                                  ~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    let result = words.count % 2 == 0 ? words.dropLast() : words.dropFirst()\n\
    \    return Ok(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmptg2p24qp.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmptg2p24qp.swift:14:12: error: cannot find 'Ok'\
    \ in scope\n    return Ok(result)\n           ^~\n"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.components(separatedBy:\
    \ \" \") else {\n        return Err(Int(.init(rawValue: -999)))\n    }\n    \n\
    \    var words: [String] = []\n    for word in words {\n        guard let letters\
    \ = word.components(separatedBy: \",\") else {\n            return Err(Int(.init(rawValue:\
    \ -999)))\n        }\n        \n        for letter in letters {\n            guard\
    \ let letter = letter.lowercased(), let index = alphabet.index(of: letter) else\
    \ {\n                return Err(Int(.init(rawValue: -999)))\n            }\n \
    \           \n            if index%2 == 1 {\n                words.append(word)\n\
    \                break\n            }\n        }\n    }\n    \n    return Ok(words)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmplx4k24g4.swift:12:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmplx4k24g4.swift:13:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(.init(rawValue: -999)))\n\
    \               ^~~\n/tmp/tmplx4k24g4.swift:13:25: error: reference to member\
    \ 'init' cannot be resolved without a contextual type\n        return Err(Int(.init(rawValue:\
    \ -999)))\n                        ^\n/tmp/tmplx4k24g4.swift:18:34: error: value\
    \ of type 'String' has no member 'components'\n        guard let letters = word.components(separatedBy:\
    \ \",\") else {\n                            ~~~~ ^~~~~~~~~~\n/tmp/tmplx4k24g4.swift:19:20:\
    \ error: cannot find 'Err' in scope\n            return Err(Int(.init(rawValue:\
    \ -999)))\n                   ^~~\n/tmp/tmplx4k24g4.swift:19:29: error: reference\
    \ to member 'init' cannot be resolved without a contextual type\n            return\
    \ Err(Int(.init(rawValue: -999)))\n                            ^\n/tmp/tmplx4k24g4.swift:34:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words)\n           ^~\n/tmp/tmplx4k24g4.swift:23:65:\
    \ error: cannot find 'alphabet' in scope\n            guard let letter = letter.lowercased(),\
    \ let index = alphabet.index(of: letter) else {\n                            \
    \                                    ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.components(separatedBy:\
    \ \" \") else {\n        return Err(Int(.invalid))\n    }\n    \n    var result:\
    \ [String] = []\n    \n    for word in words {\n        guard let letters = word.components(separatedBy:\
    \ \",\") else {\n            return Err(Int(.invalid))\n        }\n        \n\
    \        for letter in letters {\n            if let number = Int(letter) {\n\
    \                if number % 2 == 1 {\n                    result.append(letter)\n\
    \                }\n            }\n        }\n    }\n    \n    return Ok(result)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp846dj9fx.swift:12:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmp846dj9fx.swift:13:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(.invalid))\n            \
    \   ^~~\n/tmp/tmp846dj9fx.swift:13:24: error: missing argument label 'bitPattern:'\
    \ in call\n        return Err(Int(.invalid))\n                       ^\n     \
    \                  bitPattern: \n/tmp/tmp846dj9fx.swift:32:12: error: cannot find\
    \ 'Ok' in scope\n    return Ok(result)\n           ^~\n"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.split(separator: \" \"\
    ) else {\n        return Err(Int(.init(rawValue: 1)).rawValue)\n    }\n    \n\
    \    var result = [String]()\n    \n    for word in words {\n        guard let\
    \ wordWithoutSpaces = word.trimmingCharacters(in: .whitespaces) else {\n     \
    \       return Err(Int(.init(rawValue: 2)).rawValue)\n        }\n        \n  \
    \      if wordWithoutSpaces.isEmpty {\n            continue\n        }\n     \
    \   \n        if let comma = wordWithoutSpaces.range(of: \",\") {\n          \
    \  result.append(wordWithoutSpaces[..<comma])\n        } else {\n            result.append(wordWithoutSpaces)\n\
    \        }\n    }\n    \n    if result.count == 0 {\n        return Err(Int(.init(rawValue:\
    \ 3)).rawValue)\n    }\n    \n    return Ok(result)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp01njy21h.swift:13:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(.init(rawValue: 1)).rawValue)\n               ^~~\n/tmp/tmp01njy21h.swift:13:44:\
    \ error: value of type 'Int' has no member 'rawValue'\n        return Err(Int(.init(rawValue:\
    \ 1)).rawValue)\n                   ~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmp01njy21h.swift:13:25:\
    \ error: reference to member 'init' cannot be resolved without a contextual type\n\
    \        return Err(Int(.init(rawValue: 1)).rawValue)\n                      \
    \  ^\n/tmp/tmp01njy21h.swift:12:11: error: initializer for conditional binding\
    \ must have Optional type, not '[String.SubSequence]' (aka 'Array<Substring>')\n\
    \    guard let words = txt.split(separator: \" \") else {\n          ^       \
    \    ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp01njy21h.swift:19:44: error: value of\
    \ type 'String.SubSequence' (aka 'Substring') has no member 'trimmingCharacters'\n\
    \        guard let wordWithoutSpaces = word.trimmingCharacters(in: .whitespaces)\
    \ else {\n                                      ~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp01njy21h.swift:19:68:\
    \ error: cannot infer contextual base in reference to member 'whitespaces'\n \
    \       guard let wordWithoutSpaces = word.trimmingCharacters(in: .whitespaces)\
    \ else {\n                                                                  ~^~~~~~~~~~~\n\
    /tmp/tmp01njy21h.swift:20:20: error: cannot find 'Err' in scope\n            return\
    \ Err(Int(.init(rawValue: 2)).rawValue)\n                   ^~~\n/tmp/tmp01njy21h.swift:20:48:\
    \ error: value of type 'Int' has no member 'rawValue'\n            return Err(Int(.init(rawValue:\
    \ 2)).rawValue)\n                       ~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmp01njy21h.swift:20:29:\
    \ error: reference to member 'init' cannot be resolved without a contextual type\n\
    \            return Err(Int(.init(rawValue: 2)).rawValue)\n                  \
    \          ^\n/tmp/tmp01njy21h.swift:35:16: error: cannot find 'Err' in scope\n\
    \        return Err(Int(.init(rawValue: 3)).rawValue)\n               ^~~\n/tmp/tmp01njy21h.swift:35:44:\
    \ error: value of type 'Int' has no member"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    let wordCount = words.count\n    let letterCount = txt.lowercased().characters.count\n\
    \    \n    if wordCount == 0 || letterCount == 0 {\n        return Err(letterCount)\n\
    \    }\n    \n    if letterCount % 2 == 1 {\n        return Err(letterCount)\n\
    \    }\n    \n    return Ok(words.map { $0.trimmingCharacters(in: .whitespaces)\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\"\
    ) == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world\
    \ !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"\
    abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpezocs6se.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpezocs6se.swift:14:40: error: 'characters' is unavailable:\
    \ Please use String directly\n    let letterCount = txt.lowercased().characters.count\n\
    \                                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpezocs6se.swift:17:16: error: cannot find 'Err' in scope\n\
    \        return Err(letterCount)\n               ^~~\n/tmp/tmpezocs6se.swift:21:16:\
    \ error: cannot find 'Err' in scope\n        return Err(letterCount)\n       \
    \        ^~~\n/tmp/tmpezocs6se.swift:24:12: error: cannot find 'Ok' in scope\n\
    \    return Ok(words.map { $0.trimmingCharacters(in: .whitespaces) })\n      \
    \     ^~\n/tmp/tmpezocs6se.swift:24:54: error: cannot infer contextual base in\
    \ reference to member 'whitespaces'\n    return Ok(words.map { $0.trimmingCharacters(in:\
    \ .whitespaces) })\n                                                    ~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(1))\n    }\n    if words.count\
    \ == 1 {\n        return Ok(words)\n    }\n    let firstWord = words[0]\n    let\
    \ lastWord = words[words.count - 1]\n    let firstLetter = firstWord.characters.first!\n\
    \    let lastLetter = lastWord.characters.last!\n    let letterCount = firstLetter\
    \ - lastLetter\n    if letterCount % 2 == 1 {\n        return Ok(words)\n    }\n\
    \    return Err(Int(letterCount))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpninbxm4u.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpninbxm4u.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(1))\n               ^~~\n/tmp/tmpninbxm4u.swift:17:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpninbxm4u.swift:25:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpninbxm4u.swift:27:12: error: cannot find\
    \ 'Err' in scope\n    return Err(Int(letterCount))\n           ^~~\n"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(0))\n    }\n    if words.count\
    \ == 1 {\n        return Ok(words)\n    }\n    let lastWord = words[words.count\
    \ - 1]\n    let lastWordIsLetter = lastWord.rangeOfCharacter(from: CharacterSet.letters)\
    \ != nil\n    let lastWordIsDigit = lastWord.rangeOfCharacter(from: CharacterSet.decimalDigits)\
    \ != nil\n    if lastWordIsLetter || lastWordIsDigit {\n        return Err(Int(0))\n\
    \    }\n    let lastWordIsUpper = lastWord.rangeOfCharacter(from: CharacterSet.uppercase)\
    \ != nil\n    if lastWordIsUpper {\n        return Err(Int(0))\n    }\n    return\
    \ Ok(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpvsw83m3p.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpvsw83m3p.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(0))\n               ^~~\n/tmp/tmpvsw83m3p.swift:17:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpvsw83m3p.swift:20:60: error: cannot find 'CharacterSet' in scope\n   \
    \ let lastWordIsLetter = lastWord.rangeOfCharacter(from: CharacterSet.letters)\
    \ != nil\n                                                           ^~~~~~~~~~~~\n\
    /tmp/tmpvsw83m3p.swift:21:59: error: cannot find 'CharacterSet' in scope\n   \
    \ let lastWordIsDigit = lastWord.rangeOfCharacter(from: CharacterSet.decimalDigits)\
    \ != nil\n                                                          ^~~~~~~~~~~~\n\
    /tmp/tmpvsw83m3p.swift:23:16: error: cannot find 'Err' in scope\n        return\
    \ Err(Int(0))\n               ^~~\n/tmp/tmpvsw83m3p.swift:25:59: error: cannot\
    \ find 'CharacterSet' in scope\n    let lastWordIsUpper = lastWord.rangeOfCharacter(from:\
    \ CharacterSet.uppercase) != nil\n                                           \
    \               ^~~~~~~~~~~~\n/tmp/tmpvsw83m3p.swift:27:16: error: cannot find\
    \ 'Err' in scope\n        return Err(Int(0))\n               ^~~\n/tmp/tmpvsw83m3p.swift:29:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words)\n           ^~\n"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.split(separator: \" \"\
    ) else {\n        return Err(Int(rawValue: 1))\n    }\n    guard let wordCount\
    \ = words.count else {\n        return Err(Int(rawValue: 2))\n    }\n    guard\
    \ wordCount % 2 == 0 else {\n        return Err(Int(rawValue: 3))\n    }\n   \
    \ let wordArray = words.enumerated().map { (index, word) in\n        return word.lowercased()\n\
    \    }\n    return Ok(wordArray)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpjl26vn0g.swift:13:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(rawValue: 1))\n               ^~~\n/tmp/tmpjl26vn0g.swift:13:23:\
    \ error: extraneous argument label 'rawValue:' in call\n        return Err(Int(rawValue:\
    \ 1))\n                      ^~~~~~~~~~~\n                       \n/tmp/tmpjl26vn0g.swift:12:11:\
    \ error: initializer for conditional binding must have Optional type, not '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n    guard let words = txt.split(separator: \" \")\
    \ else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpjl26vn0g.swift:16:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(rawValue: 2))\n  \
    \             ^~~\n/tmp/tmpjl26vn0g.swift:16:23: error: extraneous argument label\
    \ 'rawValue:' in call\n        return Err(Int(rawValue: 2))\n                \
    \      ^~~~~~~~~~~\n                       \n/tmp/tmpjl26vn0g.swift:15:11: error:\
    \ initializer for conditional binding must have Optional type, not 'Int'\n   \
    \ guard let wordCount = words.count else {\n          ^               ~~~~~~~~~~~\n\
    /tmp/tmpjl26vn0g.swift:19:16: error: cannot find 'Err' in scope\n        return\
    \ Err(Int(rawValue: 3))\n               ^~~\n/tmp/tmpjl26vn0g.swift:19:23: error:\
    \ extraneous argument label 'rawValue:' in call\n        return Err(Int(rawValue:\
    \ 3))\n                      ^~~~~~~~~~~\n                       \n/tmp/tmpjl26vn0g.swift:24:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(wordArray)\n           ^~\n"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(0)\n    }\n    if words.count\
    \ == 1 {\n        return Ok(words)\n    }\n    let comma = words.last!.components(separatedBy:\
    \ \",\")\n    if comma.count == 0 {\n        return Ok(words.dropLast())\n   \
    \ }\n    if comma.count == 1 {\n        return Ok(words.dropLast())\n    }\n \
    \   let letters = words.dropLast().map { $0.lowercased().count }\n    let odd\
    \ = letters.filter { $0 % 2 == 1 }\n    if odd.count == 0 {\n        return Ok(letters)\n\
    \    }\n    return Err(letters.count)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpp94bmo6n.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpp94bmo6n.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(0)\n               ^~~\n/tmp/tmpp94bmo6n.swift:17:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpp94bmo6n.swift:21:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words.dropLast())\n               ^~\n/tmp/tmpp94bmo6n.swift:24:16: error:\
    \ cannot find 'Ok' in scope\n        return Ok(words.dropLast())\n           \
    \    ^~\n/tmp/tmpp94bmo6n.swift:29:16: error: cannot find 'Ok' in scope\n    \
    \    return Ok(letters)\n               ^~\n/tmp/tmpp94bmo6n.swift:31:12: error:\
    \ cannot find 'Err' in scope\n    return Err(letters.count)\n           ^~~\n"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    \n    let words = txt.components(separatedBy:\
    \ \" \")\n    \n    if words.count == 0 {\n        return Err(Int(1))\n    }\n\
    \    \n    let wordCount = words.count\n    \n    if wordCount == 1 {\n      \
    \  return Ok(words)\n    }\n    \n    let firstWord = words[0]\n    \n    if firstWord.hasPrefix(\"\
    ,\") {\n        return Ok(words)\n    }\n    \n    if firstWord.hasPrefix(\"\\\
    \"\") {\n        let firstWordWithoutQuotes = firstWord.trimmingCharacters(in:\
    \ CharacterSet.whitespacesAndNewlines)\n        return Ok(firstWordWithoutQuotes.components(separatedBy:\
    \ \",\"))\n    }\n    \n    if firstWord.hasPrefix(\"'\") {\n        let firstWordWithoutQuotes\
    \ = firstWord.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n  \
    \      return Ok(firstWordWithoutQuotes.components(separatedBy: \",\"))\n    }\n\
    \    \n    if firstWord.hasPrefix(\"(\") {\n        let firstWordWithoutQuotes\
    \ = firstWord.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n  \
    \      return Ok(firstWordWithoutQuotes.components(separatedBy: \",\"))\n    }\n\
    \    \n    if firstWord.hasPrefix(\"[\") {\n        let firstWordWithoutQuotes\
    \ = firstWord.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n  \
    \      return Ok(firstWordWithoutQuotes.components(separatedBy: \",\"))\n    }\n\
    \    \n    if firstWord.hasPrefix(\"{\") {\n        let firstWordWithoutQuotes\
    \ = firstWord.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n  \
    \      return Ok(firstWordWithoutQuotes.components(separatedBy: \",\"))\n    }\n\
    \    \n    if firstWord.hasPrefix(\"[\") {\n        let firstWordWithoutQuotes\
    \ = firstWord.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n  \
    \      return Ok(firstWordWithoutQuotes.components(separatedBy: \",\"))\n    }\n\
    \    \n    if firstWord.hasPrefix(\"{\") {\n        let firstWordWithoutQuotes\
    \ = firstWord.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n  \
    \      return Ok(firstWordWithoutQuotes.components(separatedBy: \",\"))\n    }\n\
    \    \n    if firstWord.hasPrefix(\"(\") {\n        let firstWordWithoutQuotes\
    \ = firstWord.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n  \
    \      return Ok(firstWordWithoutQuotes.components(separ\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpxalpggyn.swift:69:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpxalpggyn.swift:68:52: note: to match this opening '('\n        return\
    \ Ok(firstWordWithoutQuotes.components(separ\n                               \
    \                    ^\n/tmp/tmpxalpggyn.swift:91:44: error: expected '}' at end\
    \ of brace statement\nassert(split_words(txt: \"\") == .failure(0))\n        \
    \                                   ^\n/tmp/tmpxalpggyn.swift:11:56: note: to\
    \ match this opening '{'\nfunc split_words(txt: String) -> Result<[String], Int>\
    \ {\n                                                       ^\n/tmp/tmpxalpggyn.swift:13:21:\
    \ error: value of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmpxalpggyn.swift:16:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(1))\n               ^~~\n\
    /tmp/tmpxalpggyn.swift:22:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpxalpggyn.swift:28:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpxalpggyn.swift:32:71:\
    \ error: cannot find 'CharacterSet' in scope\n        let firstWordWithoutQuotes\
    \ = firstWord.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n  \
    \                                                                    ^~~~~~~~~~~~\n\
    /tmp/tmpxalpggyn.swift:33:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(firstWordWithoutQuotes.components(separatedBy: \",\"))\n               ^~\n\
    /tmp/tmpxalpggyn.swift:37:71: error: cannot find 'CharacterSet' in scope\n   \
    \     let firstWordWithoutQuotes = firstWord.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n\
    \                                                                      ^~~~~~~~~~~~\n\
    /tmp/tmpxalpggyn.swift:38:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(firstWordWithoutQuotes.components(separatedBy: \",\"))\n               ^~\n\
    /tmp/tmpxalpggyn.swift:42:71: error: cannot find 'CharacterSet' in scope\n   \
    \     let firstWordWithoutQuotes = firstWord.trimmingCharacters(in: "
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    \n    if words.count == 0 {\n        return Err(Int(.zero))\n    }\n  \
    \  \n    let wordCount = words.count\n    \n    if wordCount == 1 {\n        return\
    \ Ok([words[0]])\n    }\n    \n    if wordCount == 2 {\n        return Ok([words[0],\
    \ words[1]])\n    }\n    \n    if wordCount == 3 {\n        return Ok([words[0],\
    \ words[1], words[2]])\n    }\n    \n    if wordCount == 4 {\n        return Ok([words[0],\
    \ words[1], words[2], words[3]])\n    }\n    \n    if wordCount == 5 {\n     \
    \   return Ok([words[0], words[1], words[2], words[3], words[4]])\n    }\n   \
    \ \n    if wordCount == 6 {\n        return Ok([words[0], words[1], words[2],\
    \ words[3], words[4], words[5]])\n    }\n    \n    if wordCount == 7 {\n     \
    \   return Ok([words[0], words[1], words[2], words[3], words[4], words[5], words[6]])\n\
    \    }\n    \n    if wordCount == 8 {\n        return Ok([words[0], words[1],\
    \ words[2], words[3], words[4], words[5], words[6], words[7]])\n    }\n    \n\
    \    if wordCount == 9 {\n        return Ok([words[0], words[1], words[2], words[3],\
    \ words[4], words[5], words[6], words[7], words[8]])\n    }\n    \n    if wordCount\
    \ == 10 {\n        return Ok([words[0], words[1], words[2], words[3], words[4],\
    \ words[5], words[6], words[7], words[8], words[9]])\n    }\n    \n    if wordCount\
    \ == 11 {\n        return Ok([words[0], words[1], words[2], words[3], words[4],\
    \ words[5], words[6], words[7], words[8], words[9], words[10]])\n    }\n    \n\
    \    if wordCount == 12 {\n        return Ok([words[0], words[1], words[2], words[3],\
    \ words[4], words[5], words[6], words[7], words[8], words[9], words[10], words[11]])\n\
    \    }\n    \n    if wordCount == 13 {\n        return Ok([words[0], words[1],\
    \ words[2], words[3], words[4], words[5], words[6], words[7], words[8], words[9],\
    \ words[10], words[11], words[12]])\n    }\n    \n    if wordCount == 14 {\n \
    \       return Ok([words[0], \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpav_yeadl.swift:74:1: error: expected expression in container literal\n\
    }\n^\n/tmp/tmpav_yeadl.swift:96:44: error: expected '}' at end of brace statement\n\
    assert(split_words(txt: \"\") == .failure(0))\n                              \
    \             ^\n/tmp/tmpav_yeadl.swift:11:56: note: to match this opening '{'\n\
    func split_words(txt: String) -> Result<[String], Int> {\n                   \
    \                                    ^\n/tmp/tmpav_yeadl.swift:12:21: error: value\
    \ of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmpav_yeadl.swift:15:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(.zero))\n               ^~~\n\
    /tmp/tmpav_yeadl.swift:21:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok([words[0]])\n               ^~\n/tmp/tmpav_yeadl.swift:25:16: error: cannot\
    \ find 'Ok' in scope\n        return Ok([words[0], words[1]])\n              \
    \ ^~\n/tmp/tmpav_yeadl.swift:29:16: error: cannot find 'Ok' in scope\n       \
    \ return Ok([words[0], words[1], words[2]])\n               ^~\n/tmp/tmpav_yeadl.swift:33:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok([words[0], words[1], words[2],\
    \ words[3]])\n               ^~\n/tmp/tmpav_yeadl.swift:37:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok([words[0], words[1], words[2], words[3], words[4]])\n\
    \               ^~\n/tmp/tmpav_yeadl.swift:41:16: error: cannot find 'Ok' in scope\n\
    \        return Ok([words[0], words[1], words[2], words[3], words[4], words[5]])\n\
    \               ^~\n/tmp/tmpav_yeadl.swift:45:16: error: cannot find 'Ok' in scope\n\
    \        return Ok([words[0], words[1], words[2], words[3], words[4], words[5],\
    \ words[6]])\n               ^~\n/tmp/tmpav_yeadl.swift:49:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok([words[0], words[1], words[2], words[3], words[4],\
    \ words[5], words[6], words[7]])\n               ^~\n/tmp/tmpav_yeadl.swift:53:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok([words[0], words[1], words[2],\
    \ words[3], words[4], words[5], words[6], words[7], words[8]])\n    "
  stdout: ''
  timestamp: 1660054249
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.split(separator: \" \"\
    ) else {\n        return Err(Int(rawValue: 1))\n    }\n    \n    var result: [String]\
    \ = []\n    \n    for word in words {\n        if let word = word.lowercased()\
    \ {\n            result.append(word)\n        }\n    }\n    \n    if result.count\
    \ % 2 == 1 {\n        return Err(Int(rawValue: 1))\n    }\n    \n    return Ok(result)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp9sfhztuc.swift:13:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(rawValue: 1))\n               ^~~\n/tmp/tmp9sfhztuc.swift:13:23:\
    \ error: extraneous argument label 'rawValue:' in call\n        return Err(Int(rawValue:\
    \ 1))\n                      ^~~~~~~~~~~\n                       \n/tmp/tmp9sfhztuc.swift:12:11:\
    \ error: initializer for conditional binding must have Optional type, not '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n    guard let words = txt.split(separator: \" \")\
    \ else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp9sfhztuc.swift:19:12:\
    \ error: initializer for conditional binding must have Optional type, not 'String'\n\
    \        if let word = word.lowercased() {\n           ^          ~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp9sfhztuc.swift:25:16: error: cannot find 'Err' in scope\n        return\
    \ Err(Int(rawValue: 1))\n               ^~~\n/tmp/tmp9sfhztuc.swift:25:23: error:\
    \ extraneous argument label 'rawValue:' in call\n        return Err(Int(rawValue:\
    \ 1))\n                      ^~~~~~~~~~~\n                       \n/tmp/tmp9sfhztuc.swift:28:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(result)\n           ^~\n"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(0))\n    }\n    let wordCount\
    \ = words.count\n    let letterCount = words.reduce(0) { $0 + $1.count }\n   \
    \ if letterCount == 0 {\n        return Err(Int(0))\n    }\n    if letterCount\
    \ % 2 == 1 {\n        return Err(Int(0))\n    }\n    return Ok(words.map { $0.trimmingCharacters(in:\
    \ .whitespacesAndNewlines) })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpk7qx3fn3.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpk7qx3fn3.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(0))\n               ^~~\n/tmp/tmpk7qx3fn3.swift:19:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(0))\n            \
    \   ^~~\n/tmp/tmpk7qx3fn3.swift:22:16: error: cannot find 'Err' in scope\n   \
    \     return Err(Int(0))\n               ^~~\n/tmp/tmpk7qx3fn3.swift:24:12: error:\
    \ cannot find 'Ok' in scope\n    return Ok(words.map { $0.trimmingCharacters(in:\
    \ .whitespacesAndNewlines) })\n           ^~\n/tmp/tmpk7qx3fn3.swift:24:54: error:\
    \ cannot infer contextual base in reference to member 'whitespacesAndNewlines'\n\
    \    return Ok(words.map { $0.trimmingCharacters(in: .whitespacesAndNewlines)\
    \ })\n                                                    ~^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(0))\n    }\n    if words.count\
    \ == 1 {\n        return Ok(words)\n    }\n    let lastWord = words[words.count\
    \ - 1]\n    if lastWord.count == 0 {\n        return Ok(words)\n    }\n    if\
    \ lastWord.count > 1 {\n        return Err(Int(0))\n    }\n    let firstWord =\
    \ words[0]\n    if firstWord.count > 1 {\n        return Err(Int(0))\n    }\n\
    \    let firstLetter = firstWord.first\n    if firstLetter == nil {\n        return\
    \ Err(Int(0))\n    }\n    let lastLetter = firstWord.last\n    if lastLetter ==\
    \ nil {\n        return Err(Int(0))\n    }\n    let letterCount = lastLetter!.count\
    \ - firstLetter!.count + 1\n    if letterCount % 2 == 1 {\n        return Err(Int(0))\n\
    \    }\n    return Ok(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpg3iumhmh.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpg3iumhmh.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(0))\n               ^~~\n/tmp/tmpg3iumhmh.swift:17:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpg3iumhmh.swift:21:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpg3iumhmh.swift:24:16: error: cannot find\
    \ 'Err' in scope\n        return Err(Int(0))\n               ^~~\n/tmp/tmpg3iumhmh.swift:28:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(0))\n            \
    \   ^~~\n/tmp/tmpg3iumhmh.swift:32:16: error: cannot find 'Err' in scope\n   \
    \     return Err(Int(0))\n               ^~~\n/tmp/tmpg3iumhmh.swift:36:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(0))\n               ^~~\n\
    /tmp/tmpg3iumhmh.swift:40:16: error: cannot find 'Err' in scope\n        return\
    \ Err(Int(0))\n               ^~~\n/tmp/tmpg3iumhmh.swift:42:12: error: cannot\
    \ find 'Ok' in scope\n    return Ok(words)\n           ^~\n"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(1))\n    }\n    if words.count\
    \ == 1 {\n        return Ok(words)\n    }\n    let comma = words.last!.components(separatedBy:\
    \ \",\")\n    if comma.count == 0 {\n        return Ok(words)\n    }\n    return\
    \ Ok(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp_ilyuy4o.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp_ilyuy4o.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(1))\n               ^~~\n/tmp/tmp_ilyuy4o.swift:17:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmp_ilyuy4o.swift:21:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmp_ilyuy4o.swift:23:12: error: cannot find\
    \ 'Ok' in scope\n    return Ok(words)\n           ^~\n"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int((txt.characters.count / 2)\
    \ - 1))\n    }\n    if words.count == 1 {\n        return Ok(words)\n    }\n \
    \   let chars = txt.characters\n    let count = chars.count\n    let letters =\
    \ chars.filter { $0 >= 'a' && $0 <= 'z' }\n    let letterCount = letters.count\n\
    \    let oddLetters = letters.filter { $0 % 2 != 0 }\n    if letterCount == 0\
    \ {\n        return Err(Int((count / 2) - 1))\n    }\n    if letterCount == 1\
    \ {\n        return Ok(words)\n    }\n    if letterCount == 2 {\n        return\
    \ Ok(letters)\n    }\n    if letterCount == 3 {\n        return Ok(oddLetters)\n\
    \    }\n    if letterCount == 4 {\n        return Ok(letters.filter { $0 >= 'a'\
    \ && $0 <= 'z' })\n    }\n    if letterCount == 5 {\n        return Ok(letters.filter\
    \ { $0 >= 'a' && $0 <= 'z' })\n    }\n    if letterCount == 6 {\n        return\
    \ Ok(letters.filter { $0 >= 'a' && $0 <= 'z' })\n    }\n    if letterCount ==\
    \ 7 {\n        return Ok(letters.filter { $0 >= 'a' && $0 <= 'z' })\n    }\n \
    \   if letterCount == 8 {\n        return Ok(letters.filter { $0 >= 'a' && $0\
    \ <= 'z' })\n    }\n    if letterCount == 9 {\n        return Ok(letters.filter\
    \ { $0 >= 'a' && $0 <= 'z' })\n    }\n    if letterCount == 10 {\n        return\
    \ Ok(letters.filter { $0 >= 'a' && $0 <= 'z' })\n    }\n    if letterCount ==\
    \ 11 {\n        return Ok(letters.filter { $0 >= 'a' && $0 <= 'z' })\n    }\n\
    \    if letterCount == 12 {\n        return Ok(letters.filter { $0 >= 'a' && $0\
    \ <= 'z' })\n    }\n    if letterCount == 13 {\n        return Ok(letters.filter\
    \ { $0 >= 'a' && $0 <= 'z' })\n    }\n    if letterCount == 14 {\n        return\
    \ Ok(letters.filter { $0 >= 'a' && $0 <= 'z' })\n    }\n    if letterCount ==\
    \ 15 {\n        return Ok(letters.filter { $0 >= 'a' && $0 <= 'z' })\n    }\n\
    \    if letterCount == 16 {\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpfhmtpe6i.swift:21:40: error: single-quoted string literal found,\
    \ use '\"'\n    let letters = chars.filter { $0 >= 'a' && $0 <= 'z' }\n      \
    \                                 ^~~\n                                      \
    \ \"a\"\n/tmp/tmpfhmtpe6i.swift:21:53: error: single-quoted string literal found,\
    \ use '\"'\n    let letters = chars.filter { $0 >= 'a' && $0 <= 'z' }\n      \
    \                                              ^~~\n                         \
    \                           \"z\"\n/tmp/tmpfhmtpe6i.swift:37:42: error: single-quoted\
    \ string literal found, use '\"'\n        return Ok(letters.filter { $0 >= 'a'\
    \ && $0 <= 'z' })\n                                         ^~~\n            \
    \                             \"a\"\n/tmp/tmpfhmtpe6i.swift:37:55: error: single-quoted\
    \ string literal found, use '\"'\n        return Ok(letters.filter { $0 >= 'a'\
    \ && $0 <= 'z' })\n                                                      ^~~\n\
    \                                                      \"z\"\n/tmp/tmpfhmtpe6i.swift:40:42:\
    \ error: single-quoted string literal found, use '\"'\n        return Ok(letters.filter\
    \ { $0 >= 'a' && $0 <= 'z' })\n                                         ^~~\n\
    \                                         \"a\"\n/tmp/tmpfhmtpe6i.swift:40:55:\
    \ error: single-quoted string literal found, use '\"'\n        return Ok(letters.filter\
    \ { $0 >= 'a' && $0 <= 'z' })\n                                              \
    \        ^~~\n                                                      \"z\"\n/tmp/tmpfhmtpe6i.swift:43:42:\
    \ error: single-quoted string literal found, use '\"'\n        return Ok(letters.filter\
    \ { $0 >= 'a' && $0 <= 'z' })\n                                         ^~~\n\
    \                                         \"a\"\n/tmp/tmpfhmtpe6i.swift:43:55:\
    \ error: single-quoted string literal found, use '\"'\n        return Ok(letters.filter\
    \ { $0 >= 'a' && $0 <= 'z' })\n                                              \
    \        ^~~\n                                                      \"z\"\n/tmp/tmpfhmtpe6i.swift:46:42:\
    \ error: single-quoted string literal found, use '\"'\n        return Ok(let"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    guard !words.isEmpty else { return Err(0) }\n    let comma = words.last!.components(separatedBy:\
    \ \",\")\n    guard !comma.isEmpty else { return Err(0) }\n    let letters = words.map\
    \ { $0.lowercased().count }\n    return Ok(letters.filter { $0 % 2 == 1 })\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp0930sn_p.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp0930sn_p.swift:13:40: error: cannot find 'Err'\
    \ in scope\n    guard !words.isEmpty else { return Err(0) }\n                \
    \                       ^~~\n/tmp/tmp0930sn_p.swift:15:40: error: cannot find\
    \ 'Err' in scope\n    guard !comma.isEmpty else { return Err(0) }\n          \
    \                             ^~~\n/tmp/tmp0930sn_p.swift:17:12: error: cannot\
    \ find 'Ok' in scope\n    return Ok(letters.filter { $0 % 2 == 1 })\n        \
    \   ^~\n"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    \n    if words.count == 0 {\n        return Err(Int(errorCode: ErrorCode.invalidArgument))\n\
    \    }\n    \n    var result: [String] = []\n    \n    for word in words {\n \
    \       if let wordAsString = word as? String {\n            result.append(wordAsString)\n\
    \        }\n    }\n    \n    if result.count == 0 {\n        return Err(Int(errorCode:\
    \ ErrorCode.invalidArgument))\n    }\n    \n    if result.count > 1 {\n      \
    \  return Err(Int(errorCode: ErrorCode.invalidArgument))\n    }\n    \n    if\
    \ result.count == 1 {\n        return Ok(result)\n    }\n    \n    let letters\
    \ = txt.lowercased().unicodeScalars.filter({ $0.isLetter}).count\n    \n    if\
    \ letters % 2 == 1 {\n        return Ok(result)\n    }\n    \n    return Err(Int(errorCode:\
    \ ErrorCode.invalidArgument))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpfs8s2cv2.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpfs8s2cv2.swift:15:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(errorCode: ErrorCode.invalidArgument))\n  \
    \             ^~~\n/tmp/tmpfs8s2cv2.swift:15:35: error: cannot find 'ErrorCode'\
    \ in scope\n        return Err(Int(errorCode: ErrorCode.invalidArgument))\n  \
    \                                ^~~~~~~~~\n/tmp/tmpfs8s2cv2.swift:15:20: error:\
    \ no exact matches in call to initializer \n        return Err(Int(errorCode:\
    \ ErrorCode.invalidArgument))\n                   ^\n/tmp/tmpfs8s2cv2.swift:15:20:\
    \ note: found candidate with type '(Float16) -> Int'\n        return Err(Int(errorCode:\
    \ ErrorCode.invalidArgument))\n                   ^\n/tmp/tmpfs8s2cv2.swift:15:20:\
    \ note: found candidate with type '(Float) -> Int'\n        return Err(Int(errorCode:\
    \ ErrorCode.invalidArgument))\n                   ^\n/tmp/tmpfs8s2cv2.swift:15:20:\
    \ note: found candidate with type '(Double) -> Int'\n        return Err(Int(errorCode:\
    \ ErrorCode.invalidArgument))\n                   ^\n/tmp/tmpfs8s2cv2.swift:15:20:\
    \ note: found candidate with type '(Float80) -> Int'\n        return Err(Int(errorCode:\
    \ ErrorCode.invalidArgument))\n                   ^\n/tmp/tmpfs8s2cv2.swift:15:20:\
    \ note: found candidate with type '(Builtin.Int64) -> Int'\n        return Err(Int(errorCode:\
    \ ErrorCode.invalidArgument))\n                   ^\n/tmp/tmpfs8s2cv2.swift:15:20:\
    \ note: found candidate with type '(Builtin.Word) -> Int'\n        return Err(Int(errorCode:\
    \ ErrorCode.invalidArgument))\n                   ^\n/tmp/tmpfs8s2cv2.swift:15:20:\
    \ note: found candidate with type '(String) -> Int?'\n        return Err(Int(errorCode:\
    \ ErrorCode.invalidArgument))\n                   ^\n/tmp/tmpfs8s2cv2.swift:27:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(errorCode: ErrorCode.invalidArgument))\n\
    \               ^~~\n/tmp/tmpfs8s2cv2.swift:27:35: error: cannot find 'ErrorCode'\
    \ in scope\n        return Err(Int(error"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(0))\n    }\n    let wordCount\
    \ = words.count\n    let letterCount = txt.characters.count\n    if wordCount\
    \ == letterCount {\n        return Ok(words)\n    }\n    if wordCount == letterCount\
    \ - 1 {\n        return Ok(words)\n    }\n    if wordCount == letterCount - 2\
    \ {\n        return Ok(words)\n    }\n    if wordCount == letterCount - 3 {\n\
    \        return Ok(words)\n    }\n    if wordCount == letterCount - 4 {\n    \
    \    return Ok(words)\n    }\n    if wordCount == letterCount - 5 {\n        return\
    \ Ok(words)\n    }\n    if wordCount == letterCount - 6 {\n        return Ok(words)\n\
    \    }\n    if wordCount == letterCount - 7 {\n        return Ok(words)\n    }\n\
    \    if wordCount == letterCount - 8 {\n        return Ok(words)\n    }\n    if\
    \ wordCount == letterCount - 9 {\n        return Ok(words)\n    }\n    if wordCount\
    \ == letterCount - 10 {\n        return Ok(words)\n    }\n    if wordCount ==\
    \ letterCount - 11 {\n        return Ok(words)\n    }\n    if wordCount == letterCount\
    \ - 12 {\n        return Ok(words)\n    }\n    if wordCount == letterCount - 13\
    \ {\n        return Ok(words)\n    }\n    if wordCount == letterCount - 14 {\n\
    \        return Ok(words)\n    }\n    if wordCount == letterCount - 15 {\n   \
    \     return Ok(words)\n    }\n    if wordCount == letterCount - 16 {\n      \
    \  return Ok(words)\n    }\n    if wordCount == letterCount - 17 {\n        return\
    \ Ok(words)\n    }\n    if wordCount == letterCount - 18 {\n        return Ok(words)\n\
    \    }\n    if wordCount == letterCount - 19 {\n        return Ok(words)\n   \
    \ }\n    if wordCount == letterCount - 20 {\n        return Ok(words)\n    }\n\
    \    if wordCount == letterCount - 21 {\n        return Ok(words)\n    }\n   \
    \ if wordCount == letterCount - 22 {\n        return Ok(words)\n    }\n    if\
    \ wordCount == letterCount - 23 {\n        return Ok(words)\n    }\n    if wordCount\
    \ == letterCount - 24 {\n        return Ok(words)\n    }\n    if wordCount ==\
    \ letterCount - 25 {\n        return Ok(words)\n    }\n    return Err(Int(0))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpxi8e0qab.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpxi8e0qab.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(0))\n               ^~~\n/tmp/tmpxi8e0qab.swift:17:27:\
    \ error: 'characters' is unavailable: Please use String directly\n    let letterCount\
    \ = txt.characters.count\n                          ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpxi8e0qab.swift:19:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpxi8e0qab.swift:22:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpxi8e0qab.swift:25:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpxi8e0qab.swift:28:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpxi8e0qab.swift:31:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpxi8e0qab.swift:34:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpxi8e0qab.swift:37:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpxi8e0qab.swift:40:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpxi8e0qab.swift:43:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpxi8e0qab.swift:46:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpxi8e0qab.swift:49:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpxi8e0qab.swift:52:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpxi8e0qab.swift:55:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpxi8e0qab.swift:58:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n    "
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count < 2 {\n        return Err(words.count)\n    }\n    let wordCount\
    \ = words.count\n    let letterCount = txt.characters.count\n    let oddLetters\
    \ = letterCount % 2\n    if oddLetters == 0 {\n        return Ok(words)\n    }\n\
    \    if letterCount == wordCount {\n        return Ok(words)\n    }\n    if letterCount\
    \ == wordCount - 1 {\n        return Ok(words)\n    }\n    if letterCount > wordCount\
    \ {\n        return Err(letterCount)\n    }\n    return Err(wordCount)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpebvjzquh.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpebvjzquh.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(words.count)\n               ^~~\n/tmp/tmpebvjzquh.swift:17:27:\
    \ error: 'characters' is unavailable: Please use String directly\n    let letterCount\
    \ = txt.characters.count\n                          ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpebvjzquh.swift:20:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpebvjzquh.swift:23:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpebvjzquh.swift:26:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpebvjzquh.swift:29:16: error: cannot find\
    \ 'Err' in scope\n        return Err(letterCount)\n               ^~~\n/tmp/tmpebvjzquh.swift:31:12:\
    \ error: cannot find 'Err' in scope\n    return Err(wordCount)\n           ^~~\n"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(1))\n    }\n    if words.count\
    \ == 1 {\n        return Ok(words)\n    }\n    if words.count > 1 {\n        let\
    \ firstWord = words[0]\n        let lastWord = words[words.count - 1]\n      \
    \  let firstLetter = firstWord.characters.first\n        let lastLetter = lastWord.characters.last\n\
    \        let firstLetterCount = firstLetter == nil ? 0 : Int(firstLetter!)\n \
    \       let lastLetterCount = lastLetter == nil ? 0 : Int(lastLetter!)\n     \
    \   let letterCount = firstLetterCount + lastLetterCount\n        let oddCount\
    \ = letterCount % 2\n        if oddCount == 0 {\n            return Ok(words)\n\
    \        }\n        return Err(Int(oddCount))\n    }\n    return Ok(words)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpj8lzcwq2.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpj8lzcwq2.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(1))\n               ^~~\n/tmp/tmpj8lzcwq2.swift:17:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpj8lzcwq2.swift:29:20: error: cannot find 'Ok' in scope\n            return\
    \ Ok(words)\n                   ^~\n/tmp/tmpj8lzcwq2.swift:31:16: error: cannot\
    \ find 'Err' in scope\n        return Err(Int(oddCount))\n               ^~~\n\
    /tmp/tmpj8lzcwq2.swift:33:12: error: cannot find 'Ok' in scope\n    return Ok(words)\n\
    \           ^~\n"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let txt = txt.data(using: .utf8) else\
    \ {\n        return Err(Int(.errSecParam))\n    }\n    \n    var words: [String]\
    \ = []\n    var count = 0\n    var last = 0\n    \n    for _ in 0..<txt.count\
    \ {\n        let start = txt.index(last, offsetBy: 1)\n        let end = txt.index(start,\
    \ offsetBy: 1)\n        \n        if let _ = txt[start..<end] {\n            words.append(String(txt[start..<end]))\n\
    \            count += 1\n            last = end\n        }\n    }\n    \n    if\
    \ count % 2 == 1 {\n        words.append(String(txt[last..<txt.count]))\n    }\n\
    \    \n    return Ok(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp08glhv8l.swift:12:25: error: value of type 'String' has no member\
    \ 'data'\n    guard let txt = txt.data(using: .utf8) else {\n                \
    \    ~~~ ^~~~\n/tmp/tmp08glhv8l.swift:12:38: error: cannot infer contextual base\
    \ in reference to member 'utf8'\n    guard let txt = txt.data(using: .utf8) else\
    \ {\n                                    ~^~~~\n/tmp/tmp08glhv8l.swift:13:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(.errSecParam))\n \
    \              ^~~\n/tmp/tmp08glhv8l.swift:13:24: error: missing argument label\
    \ 'bitPattern:' in call\n        return Err(Int(.errSecParam))\n             \
    \          ^\n                       bitPattern: \n/tmp/tmp08glhv8l.swift:35:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words)\n           ^~\n"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(1))\n    }\n    let commaWords\
    \ = txt.components(separatedBy: \",\")\n    if commaWords.count == 0 {\n     \
    \   return Err(Int(words.count))\n    }\n    return Ok(words.count)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp9w5fx1wc.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp9w5fx1wc.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(1))\n               ^~~\n/tmp/tmp9w5fx1wc.swift:16:26:\
    \ error: value of type 'String' has no member 'components'\n    let commaWords\
    \ = txt.components(separatedBy: \",\")\n                     ~~~ ^~~~~~~~~~\n\
    /tmp/tmp9w5fx1wc.swift:18:16: error: cannot find 'Err' in scope\n        return\
    \ Err(Int(words.count))\n               ^~~\n/tmp/tmp9w5fx1wc.swift:20:12: error:\
    \ cannot find 'Ok' in scope\n    return Ok(words.count)\n           ^~\n"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    \n    if words.count == 0 {\n        return Err(Int(.alphabet))\n    }\n\
    \    \n    if words.count == 1 {\n        return Ok(words)\n    }\n    \n    if\
    \ words.count % 2 == 1 {\n        return Err(Int(.alphabet))\n    }\n    \n  \
    \  let even = words.filter{$0.count % 2 == 0}\n    let odd = words.filter{$0.count\
    \ % 2 != 0}\n    \n    if even.count == 0 {\n        return Ok(even)\n    }\n\
    \    \n    if odd.count == 0 {\n        return Ok(odd)\n    }\n    \n    let evenLetters\
    \ = even.map { $0.lowercased() }\n    let oddLetters = odd.map { $0.lowercased()\
    \ }\n    \n    if evenLetters.count == 0 {\n        return Ok(evenLetters)\n \
    \   }\n    \n    if oddLetters.count == 0 {\n        return Ok(oddLetters)\n \
    \   }\n    \n    let evenLettersCount = evenLetters.count\n    let oddLettersCount\
    \ = oddLetters.count\n    \n    if evenLettersCount == oddLettersCount {\n   \
    \     return Ok(evenLetters)\n    }\n    \n    return Err(Int(.alphabet))\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp0baqper_.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp0baqper_.swift:15:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(.alphabet))\n               ^~~\n/tmp/tmp0baqper_.swift:15:24:\
    \ error: missing argument label 'bitPattern:' in call\n        return Err(Int(.alphabet))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmp0baqper_.swift:19:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmp0baqper_.swift:23:16: error: cannot find 'Err' in scope\n        return\
    \ Err(Int(.alphabet))\n               ^~~\n/tmp/tmp0baqper_.swift:23:24: error:\
    \ missing argument label 'bitPattern:' in call\n        return Err(Int(.alphabet))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmp0baqper_.swift:30:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(even)\n               ^~\n\
    /tmp/tmp0baqper_.swift:34:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(odd)\n               ^~\n/tmp/tmp0baqper_.swift:41:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(evenLetters)\n               ^~\n/tmp/tmp0baqper_.swift:45:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(oddLetters)\n          \
    \     ^~\n/tmp/tmp0baqper_.swift:52:16: error: cannot find 'Ok' in scope\n   \
    \     return Ok(evenLetters)\n               ^~\n/tmp/tmp0baqper_.swift:55:12:\
    \ error: cannot find 'Err' in scope\n    return Err(Int(.alphabet))\n        \
    \   ^~~\n/tmp/tmp0baqper_.swift:55:20: error: missing argument label 'bitPattern:'\
    \ in call\n    return Err(Int(.alphabet))\n                   ^\n            \
    \       bitPattern: \n"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.split(separator: \" \"\
    ) else {\n        return Err(Int(.init(rawValue: 1))) // No whitespaces found\n\
    \    }\n    \n    var result: [String] = []\n    for word in words {\n       \
    \ guard let word = word.trimmingCharacters(in: .whitespaces) else {\n        \
    \    return Err(Int(.init(rawValue: 1))) // No whitespaces found\n        }\n\
    \        \n        if word.count > 0 {\n            result.append(word)\n    \
    \    }\n    }\n    \n    if result.count == 0 {\n        return Err(Int(.init(rawValue:\
    \ 1))) // No words found\n    }\n    \n    if result.count > 1 {\n        return\
    \ Err(Int(.init(rawValue: 2))) // More than one word found\n    }\n    \n    if\
    \ result.count == 1 {\n        return Ok(result)\n    }\n    \n    if result.count\
    \ > 26 {\n        return Err(Int(.init(rawValue: 26))) // More than 26 letters\
    \ found\n    }\n    \n    return Ok(result)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpwls4y585.swift:13:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(.init(rawValue: 1))) // No whitespaces found\n            \
    \   ^~~\n/tmp/tmpwls4y585.swift:13:25: error: reference to member 'init' cannot\
    \ be resolved without a contextual type\n        return Err(Int(.init(rawValue:\
    \ 1))) // No whitespaces found\n                        ^\n/tmp/tmpwls4y585.swift:12:11:\
    \ error: initializer for conditional binding must have Optional type, not '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n    guard let words = txt.split(separator: \" \")\
    \ else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpwls4y585.swift:18:31:\
    \ error: value of type 'String.SubSequence' (aka 'Substring') has no member 'trimmingCharacters'\n\
    \        guard let word = word.trimmingCharacters(in: .whitespaces) else {\n \
    \                        ~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpwls4y585.swift:18:55:\
    \ error: cannot infer contextual base in reference to member 'whitespaces'\n \
    \       guard let word = word.trimmingCharacters(in: .whitespaces) else {\n  \
    \                                                   ~^~~~~~~~~~~\n/tmp/tmpwls4y585.swift:19:20:\
    \ error: cannot find 'Err' in scope\n            return Err(Int(.init(rawValue:\
    \ 1))) // No whitespaces found\n                   ^~~\n/tmp/tmpwls4y585.swift:19:29:\
    \ error: reference to member 'init' cannot be resolved without a contextual type\n\
    \            return Err(Int(.init(rawValue: 1))) // No whitespaces found\n   \
    \                         ^\n/tmp/tmpwls4y585.swift:28:16: error: cannot find\
    \ 'Err' in scope\n        return Err(Int(.init(rawValue: 1))) // No words found\n\
    \               ^~~\n/tmp/tmpwls4y585.swift:28:25: error: reference to member\
    \ 'init' cannot be resolved without a contextual type\n        return Err(Int(.init(rawValue:\
    \ 1))) // No words found\n                        ^\n/tmp/tmpwls4y585.swift:32:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(.init(rawValue: 2)))\
    \ // More than one word found\n               ^~~\n/tmp/tmpwls4y585.swift:32:25:\
    \ error: reference to member 'init' cannot be resolved "
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.components(separatedBy:\
    \ \" \") else {\n        return Err(Int(.Failure))\n    }\n    \n    var result:\
    \ [String] = []\n    \n    for word in words {\n        if let word = word.lowercased()\
    \ {\n            result.append(word)\n        }\n    }\n    \n    if result.count\
    \ % 2 == 1 {\n        return Err(Int(.Failure))\n    }\n    \n    return Ok(result)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpl2fg9a9n.swift:12:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmpl2fg9a9n.swift:13:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(.Failure))\n            \
    \   ^~~\n/tmp/tmpl2fg9a9n.swift:13:24: error: missing argument label 'bitPattern:'\
    \ in call\n        return Err(Int(.Failure))\n                       ^\n     \
    \                  bitPattern: \n/tmp/tmpl2fg9a9n.swift:25:16: error: cannot find\
    \ 'Err' in scope\n        return Err(Int(.Failure))\n               ^~~\n/tmp/tmpl2fg9a9n.swift:25:24:\
    \ error: missing argument label 'bitPattern:' in call\n        return Err(Int(.Failure))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmpl2fg9a9n.swift:28:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(result)\n           ^~\n"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    guard !words.isEmpty else { return Err(0) }\n    let commaWords = words.filter\
    \ { $0 == \",\" }\n    let commaWordsCount = commaWords.count\n    let letterWords\
    \ = words.filter { $0.lowercased() != $0.lowercased().replacingOccurrences(of:\
    \ \" \", with: \"\") }\n    let letterWordsCount = letterWords.count\n    let\
    \ letterWordsCountOddOrder = letterWords.filter { $0.lowercased() != $0.lowercased().replacingOccurrences(of:\
    \ \" \", with: \"\") }\n    let letterWordsCountOddOrderCount = letterWordsCountOddOrder.count\n\
    \    guard commaWordsCount == letterWordsCount || commaWordsCount == letterWordsCountOddOrder\
    \ || commaWordsCountOddOrderCount == letterWordsCount else { return Err(0) }\n\
    \    return Ok([words])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpgy8b1ze_.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpgy8b1ze_.swift:13:40: error: cannot find 'Err'\
    \ in scope\n    guard !words.isEmpty else { return Err(0) }\n                \
    \                       ^~~\n/tmp/tmpgy8b1ze_.swift:20:97: error: cannot find\
    \ 'commaWordsCountOddOrderCount' in scope\n    guard commaWordsCount == letterWordsCount\
    \ || commaWordsCount == letterWordsCountOddOrder || commaWordsCountOddOrderCount\
    \ == letterWordsCount else { return Err(0) }\n                               \
    \                                                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpgy8b1ze_.swift:20:160: error: cannot find 'Err' in scope\n    guard commaWordsCount\
    \ == letterWordsCount || commaWordsCount == letterWordsCountOddOrder || commaWordsCountOddOrderCount\
    \ == letterWordsCount else { return Err(0) }\n                               \
    \                                                                            \
    \                                                    ^~~\n/tmp/tmpgy8b1ze_.swift:21:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok([words])\n           ^~\n"
  stdout: ''
  timestamp: 1660054240
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(1))\n    }\n    if words.count\
    \ == 1 {\n        return Ok(words)\n    }\n    let firstWord = words[0]\n    let\
    \ lastWord = words[words.count - 1]\n    let firstLetter = firstWord.characters.first\n\
    \    let lastLetter = lastWord.characters.last\n    if firstLetter < lastLetter\
    \ {\n        return Ok(words)\n    }\n    return Err(Int(1))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp_htc2u0c.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp_htc2u0c.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(1))\n               ^~~\n/tmp/tmp_htc2u0c.swift:17:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmp_htc2u0c.swift:24:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmp_htc2u0c.swift:26:12: error: cannot find\
    \ 'Err' in scope\n    return Err(Int(1))\n           ^~~\n"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.components(separatedBy:\
    \ \" \") else {\n        return Err(Int(.init(rawValue: 1)).rawValue)\n    }\n\
    \    \n    var result: [String] = []\n    \n    for word in words {\n        guard\
    \ let letters = word.components(separatedBy: \",\") else {\n            return\
    \ Err(Int(.init(rawValue: 2)).rawValue)\n        }\n        \n        for letter\
    \ in letters {\n            if let count = letters.filter({ $0.isLetter }).count\
    \ {\n                if count % 2 == 1 {\n                    return Err(Int(.init(rawValue:\
    \ 3)).rawValue)\n                }\n            }\n            \n            result.append(letter)\n\
    \        }\n    }\n    \n    return Ok(result)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp29dpgfnk.swift:12:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmp29dpgfnk.swift:13:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(.init(rawValue: 1)).rawValue)\n\
    \               ^~~\n/tmp/tmp29dpgfnk.swift:13:44: error: value of type 'Int'\
    \ has no member 'rawValue'\n        return Err(Int(.init(rawValue: 1)).rawValue)\n\
    \                   ~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmp29dpgfnk.swift:13:25:\
    \ error: reference to member 'init' cannot be resolved without a contextual type\n\
    \        return Err(Int(.init(rawValue: 1)).rawValue)\n                      \
    \  ^\n/tmp/tmp29dpgfnk.swift:34:12: error: cannot find 'Ok' in scope\n    return\
    \ Ok(result)\n           ^~\n"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    guard words.count > 0 else { return Err(0) }\n    let comma = words.last!.components(separatedBy:\
    \ \",\")\n    guard comma.count == 0 else { return Err(0) }\n    let letters =\
    \ words.map { $0.lowercased().count }\n    let odd = letters.filter { $0 % 2 ==\
    \ 1 }\n    return Ok([words.first!] + odd)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpxvih7co_.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpxvih7co_.swift:13:41: error: cannot find 'Err'\
    \ in scope\n    guard words.count > 0 else { return Err(0) }\n               \
    \                         ^~~\n/tmp/tmpxvih7co_.swift:15:42: error: cannot find\
    \ 'Err' in scope\n    guard comma.count == 0 else { return Err(0) }\n        \
    \                                 ^~~\n/tmp/tmpxvih7co_.swift:18:12: error: cannot\
    \ find 'Ok' in scope\n    return Ok([words.first!] + odd)\n           ^~\n"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(0))\n    }\n    let splitWords\
    \ = words.map { $0.components(separatedBy: \",\").map { $0.lowercased() } }\n\
    \    if splitWords.count == 0 {\n        return Err(Int(0))\n    }\n    let even\
    \ = splitWords.filter { $0.count % 2 == 0 }\n    let odd = splitWords.filter {\
    \ $0.count % 2 != 0 }\n    if even.count > odd.count {\n        return Err(Int(0))\n\
    \    }\n    return Ok(even.count)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpoegbumyr.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpoegbumyr.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(0))\n               ^~~\n/tmp/tmpoegbumyr.swift:18:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(0))\n            \
    \   ^~~\n/tmp/tmpoegbumyr.swift:23:16: error: cannot find 'Err' in scope\n   \
    \     return Err(Int(0))\n               ^~~\n/tmp/tmpoegbumyr.swift:25:12: error:\
    \ cannot find 'Ok' in scope\n    return Ok(even.count)\n           ^~\n"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    \n    if words.count == 0 {\n        return Err(Int(.zero))\n    }\n  \
    \  \n    let wordCount = words.count\n    \n    if wordCount == 1 {\n        return\
    \ Ok([words[0]])\n    }\n    \n    let firstWord = words[0]\n    \n    if wordCount\
    \ == 2 {\n        return Ok([firstWord, words[1]])\n    }\n    \n    if wordCount\
    \ == 3 {\n        return Ok([firstWord, words[1], words[2]])\n    }\n    \n  \
    \  if wordCount == 4 {\n        return Ok([firstWord, words[1], words[2], words[3]])\n\
    \    }\n    \n    if wordCount == 5 {\n        return Ok([firstWord, words[1],\
    \ words[2], words[3], words[4]])\n    }\n    \n    if wordCount == 6 {\n     \
    \   return Ok([firstWord, words[1], words[2], words[3], words[4], words[5]])\n\
    \    }\n    \n    if wordCount == 7 {\n        return Ok([firstWord, words[1],\
    \ words[2], words[3], words[4], words[5], words[6]])\n    }\n    \n    if wordCount\
    \ == 8 {\n        return Ok([firstWord, words[1], words[2], words[3], words[4],\
    \ words[5], words[6], words[7]])\n    }\n    \n    if wordCount == 9 {\n     \
    \   return Ok([firstWord, words[1], words[2], words[3], words[4], words[5], words[6],\
    \ words[7], words[8]])\n    }\n    \n    if wordCount == 10 {\n        return\
    \ Ok([firstWord, words[1], words[2], words[3], words[4], words[5], words[6], words[7],\
    \ words[8], words[9]])\n    }\n    \n    if wordCount == 11 {\n        return\
    \ Ok([firstWord, words[1], words[2], words[3], words[4], words[5], words[6], words[7],\
    \ words[8], words[9], words[10]])\n    }\n    \n    if wordCount == 12 {\n   \
    \     return Ok([firstWord, words[1], words[2], words[3], words[4], words[5],\
    \ words[6], words[7], words[8], words[9], words[10], words[11]])\n    }\n    \n\
    \    if wordCount == 13 {\n        return Ok([firstWord, words[1], words[2], words[3],\
    \ words[4], words[5], words[6], words[7], words[8], words[9], words[10], words[11],\
    \ \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\"\
    ) == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world\
    \ !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"\
    abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpnp1m90xu.swift:72:1: error: expected expression in container literal\n\
    }\n^\n/tmp/tmpnp1m90xu.swift:94:44: error: expected '}' at end of brace statement\n\
    assert(split_words(txt: \"\") == .failure(0))\n                              \
    \             ^\n/tmp/tmpnp1m90xu.swift:11:56: note: to match this opening '{'\n\
    func split_words(txt: String) -> Result<[String], Int> {\n                   \
    \                                    ^\n/tmp/tmpnp1m90xu.swift:12:21: error: value\
    \ of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmpnp1m90xu.swift:15:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(.zero))\n               ^~~\n\
    /tmp/tmpnp1m90xu.swift:21:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok([words[0]])\n               ^~\n/tmp/tmpnp1m90xu.swift:27:16: error: cannot\
    \ find 'Ok' in scope\n        return Ok([firstWord, words[1]])\n             \
    \  ^~\n/tmp/tmpnp1m90xu.swift:31:16: error: cannot find 'Ok' in scope\n      \
    \  return Ok([firstWord, words[1], words[2]])\n               ^~\n/tmp/tmpnp1m90xu.swift:35:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok([firstWord, words[1], words[2],\
    \ words[3]])\n               ^~\n/tmp/tmpnp1m90xu.swift:39:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok([firstWord, words[1], words[2], words[3], words[4]])\n\
    \               ^~\n/tmp/tmpnp1m90xu.swift:43:16: error: cannot find 'Ok' in scope\n\
    \        return Ok([firstWord, words[1], words[2], words[3], words[4], words[5]])\n\
    \               ^~\n/tmp/tmpnp1m90xu.swift:47:16: error: cannot find 'Ok' in scope\n\
    \        return Ok([firstWord, words[1], words[2], words[3], words[4], words[5],\
    \ words[6]])\n               ^~\n/tmp/tmpnp1m90xu.swift:51:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok([firstWord, words[1], words[2], words[3], words[4],\
    \ words[5], words[6], words[7]])\n               ^~\n/tmp/tmpnp1m90xu.swift:55:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok([firstWord, words[1], words[2],\
    \ words[3], words[4], words[5], words[6], words[7], words[8"
  stdout: ''
  timestamp: 1660054243
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(1))\n    }\n    if words.count\
    \ == 1 {\n        return Ok(words)\n    }\n    let comma = words.last?.components(separatedBy:\
    \ \",\")\n    if comma == nil {\n        return Ok(words)\n    }\n    return Ok(words\
    \ + comma!)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpuk7amg2e.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpuk7amg2e.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(1))\n               ^~~\n/tmp/tmpuk7amg2e.swift:17:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpuk7amg2e.swift:21:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpuk7amg2e.swift:23:12: error: cannot find\
    \ 'Ok' in scope\n    return Ok(words + comma!)\n           ^~\n"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(.lowercaseLetters))\n   \
    \ }\n    if words.count == 1 {\n        return Ok(words)\n    }\n    let splitWords\
    \ = words.map { $0.components(separatedBy: \",\") }\n    let countLetters = splitWords.map\
    \ { $0.count }\n    let countLettersOdd = countLetters.filter { $0 % 2 == 1 }\n\
    \    if countLettersOdd.count == 0 {\n        return Ok(countLetters)\n    }\n\
    \    return Err(Int(.lowercaseLetters))\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp2u1lvl2o.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp2u1lvl2o.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(.lowercaseLetters))\n               ^~~\n/tmp/tmp2u1lvl2o.swift:14:24:\
    \ error: missing argument label 'bitPattern:' in call\n        return Err(Int(.lowercaseLetters))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmp2u1lvl2o.swift:17:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmp2u1lvl2o.swift:23:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(countLetters)\n               ^~\n/tmp/tmp2u1lvl2o.swift:25:12: error: cannot\
    \ find 'Err' in scope\n    return Err(Int(.lowercaseLetters))\n           ^~~\n\
    /tmp/tmp2u1lvl2o.swift:25:20: error: missing argument label 'bitPattern:' in call\n\
    \    return Err(Int(.lowercaseLetters))\n                   ^\n              \
    \     bitPattern: \n"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(1))\n    }\n    if words.count\
    \ == 1 {\n        return Ok(words)\n    }\n    let comma = words.last?.components(separatedBy:\
    \ \",\")\n    if comma == nil {\n        return Ok(words.dropLast())\n    }\n\
    \    return Ok(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpqzm078u7.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpqzm078u7.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(1))\n               ^~~\n/tmp/tmpqzm078u7.swift:17:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpqzm078u7.swift:21:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words.dropLast())\n               ^~\n/tmp/tmpqzm078u7.swift:23:12: error:\
    \ cannot find 'Ok' in scope\n    return Ok(words)\n           ^~\n"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(0)\n    }\n    if words.count\
    \ == 1 {\n        return Ok(words)\n    }\n    if words.count == 2 {\n       \
    \ return Ok(words.map { $0.lowercased() })\n    }\n    if words.count == 3 {\n\
    \        return Ok(words.map { $0.lowercased() })\n    }\n    if words.count >\
    \ 3 {\n        return Err(words.count - 1)\n    }\n    return Ok(words.map { $0.lowercased()\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\"\
    ) == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world\
    \ !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"\
    abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp14m3cvpz.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp14m3cvpz.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(0)\n               ^~~\n/tmp/tmp14m3cvpz.swift:17:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmp14m3cvpz.swift:20:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words.map { $0.lowercased() })\n               ^~\n/tmp/tmp14m3cvpz.swift:23:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words.map { $0.lowercased()\
    \ })\n               ^~\n/tmp/tmp14m3cvpz.swift:26:16: error: cannot find 'Err'\
    \ in scope\n        return Err(words.count - 1)\n               ^~~\n/tmp/tmp14m3cvpz.swift:28:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words.map { $0.lowercased()\
    \ })\n           ^~\n"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.split(separator: \" \"\
    ) else {\n        return Err(Int(errorCode: ErrorCode.InvalidInput))\n    }\n\
    \    \n    var words: [String] = []\n    \n    for word in words {\n        guard\
    \ let letters = word.split(separator: \",\") else {\n            return Err(Int(errorCode:\
    \ ErrorCode.InvalidInput))\n        }\n        \n        for letter in letters\
    \ {\n            if let count = letter.count() {\n                if count % 2\
    \ == 1 {\n                    return Err(Int(errorCode: ErrorCode.InvalidInput))\n\
    \                }\n                \n                words.append(letter)\n \
    \           }\n        }\n    }\n    \n    return Ok(words)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp8kofizmc.swift:13:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(errorCode: ErrorCode.InvalidInput))\n               ^~~\n/tmp/tmp8kofizmc.swift:13:35:\
    \ error: cannot find 'ErrorCode' in scope\n        return Err(Int(errorCode: ErrorCode.InvalidInput))\n\
    \                                  ^~~~~~~~~\n/tmp/tmp8kofizmc.swift:13:20: error:\
    \ no exact matches in call to initializer \n        return Err(Int(errorCode:\
    \ ErrorCode.InvalidInput))\n                   ^\n/tmp/tmp8kofizmc.swift:13:20:\
    \ note: found candidate with type '(Float16) -> Int'\n        return Err(Int(errorCode:\
    \ ErrorCode.InvalidInput))\n                   ^\n/tmp/tmp8kofizmc.swift:13:20:\
    \ note: found candidate with type '(Float) -> Int'\n        return Err(Int(errorCode:\
    \ ErrorCode.InvalidInput))\n                   ^\n/tmp/tmp8kofizmc.swift:13:20:\
    \ note: found candidate with type '(Double) -> Int'\n        return Err(Int(errorCode:\
    \ ErrorCode.InvalidInput))\n                   ^\n/tmp/tmp8kofizmc.swift:13:20:\
    \ note: found candidate with type '(Float80) -> Int'\n        return Err(Int(errorCode:\
    \ ErrorCode.InvalidInput))\n                   ^\n/tmp/tmp8kofizmc.swift:13:20:\
    \ note: found candidate with type '(Builtin.Int64) -> Int'\n        return Err(Int(errorCode:\
    \ ErrorCode.InvalidInput))\n                   ^\n/tmp/tmp8kofizmc.swift:13:20:\
    \ note: found candidate with type '(Builtin.Word) -> Int'\n        return Err(Int(errorCode:\
    \ ErrorCode.InvalidInput))\n                   ^\n/tmp/tmp8kofizmc.swift:13:20:\
    \ note: found candidate with type '(String) -> Int?'\n        return Err(Int(errorCode:\
    \ ErrorCode.InvalidInput))\n                   ^\n/tmp/tmp8kofizmc.swift:12:11:\
    \ error: initializer for conditional binding must have Optional type, not '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n    guard let words = txt.split(separator: \" \")\
    \ else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp8kofizmc.swift:16:9:\
    \ error: invalid redeclaration of 'words'\n    var words: [String] = []\n    \
    \    ^\n/tmp/tmp8kofizmc.swift:12:15: note: 'words' previously declared here\n\
    \    guard "
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.split(separator: \" \"\
    ) else {\n        return Err(Int(errorCode: ErrorCode.invalidArgument))\n    }\n\
    \    \n    let wordCount = words.count\n    \n    if wordCount == 0 {\n      \
    \  return Err(Int(errorCode: ErrorCode.invalidArgument))\n    }\n    \n    if\
    \ wordCount == 1 {\n        return Ok(words)\n    }\n    \n    if wordCount ==\
    \ 2 {\n        return Ok(words.split(separator: \",\"))\n    }\n    \n    if wordCount\
    \ == 3 {\n        return Ok(words.split(separator: \",\").map(String.init))\n\
    \    }\n    \n    if wordCount == 4 {\n        return Ok(words.split(separator:\
    \ \",\").map(String.init).map(String.init))\n    }\n    \n    if wordCount ==\
    \ 5 {\n        return Ok(words.split(separator: \",\").map(String.init).map(String.init).map(String.init))\n\
    \    }\n    \n    if wordCount == 6 {\n        return Ok(words.split(separator:\
    \ \",\").map(String.init).map(String.init).map(String.init).map(String.init))\n\
    \    }\n    \n    if wordCount == 7 {\n        return Ok(words.split(separator:\
    \ \",\").map(String.init).map(String.init).map(String.init).map(String.init).map(String.init))\n\
    \    }\n    \n    if wordCount == 8 {\n        return Ok(words.split(separator:\
    \ \",\").map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init))\n\
    \    }\n    \n    if wordCount == 9 {\n        return Ok(words.split(separator:\
    \ \",\").map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init))\n\
    \    }\n    \n    if wordCount == 10 {\n        return Ok(words.split(separator:\
    \ \",\").map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init))\n\
    \    }\n    \n    if wordCount == 11 {\n        return Ok(words.split(separator:\
    \ \",\").map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init))\n\
    \    }\n    \n    if wordCount == 12 {\n        return Ok(words.split(separator:\
    \ \",\").map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "error: compile command failed due to signal 15 (use -v to see invocation)\n\
    /tmp/tmpe39fj5nd.swift:67:182: error: expected member name following '.'\n   \
    \     return Ok(words.split(separator: \",\").map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).\n\
    \                                                                            \
    \                                                                            \
    \                             ^\n/tmp/tmpe39fj5nd.swift:68:1: error: expected\
    \ ')' in expression list\n}\n^\n/tmp/tmpe39fj5nd.swift:67:18: note: to match this\
    \ opening '('\n        return Ok(words.split(separator: \",\").map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).\n\
    \                 ^\n/tmp/tmpe39fj5nd.swift:90:44: error: expected '}' at end\
    \ of brace statement\nassert(split_words(txt: \"\") == .failure(0))\n        \
    \                                   ^\n/tmp/tmpe39fj5nd.swift:11:56: note: to\
    \ match this opening '{'\nfunc split_words(txt: String) -> Result<[String], Int>\
    \ {\n                                                       ^\n/tmp/tmpe39fj5nd.swift:13:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(errorCode: ErrorCode.invalidArgument))\n\
    \               ^~~\n/tmp/tmpe39fj5nd.swift:13:35: error: cannot find 'ErrorCode'\
    \ in scope\n        return Err(Int(errorCode: ErrorCode.invalidArgument))\n  \
    \                                ^~~~~~~~~\n/tmp/tmpe39fj5nd.swift:13:20: error:\
    \ no exact matches in call to initializer \n        return Err(Int(errorCode:\
    \ ErrorCode.invalidArgument))\n                   ^\n/tmp/tmpe39fj5nd.swift:13:20:\
    \ note: found candidate with type '(Float16) -> Int'\n        return Err(Int(errorCode:\
    \ ErrorCode.invalidArgument))\n                   ^\n/tmp/tmpe39fj5nd.swift:13:20:\
    \ note: found candidate with type '(Float) -> Int'\n        return Err(Int(errorCode:\
    \ ErrorCode.invalidArgument))\n                   ^\n/tmp/tmpe39fj5nd.swift:13:20:\
    \ note: found candidat"
  stdout: ''
  timestamp: 1660054335
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.components(separatedBy:\
    \ \" \") else {\n        return Err(Int(errorCode: ErrorCode.InvalidParameter.rawValue,\
    \ message: \"Invalid parameter\"))\n    }\n    \n    var wordCount = 0\n    var\
    \ words: [String] = []\n    \n    for word in words {\n        if let word = word.lowercased()\
    \ {\n            if word.isEmpty {\n                continue\n            }\n\
    \            \n            if wordCount % 2 == 1 {\n                words.append(word)\n\
    \            }\n            \n            wordCount += 1\n        }\n    }\n \
    \   \n    return Ok(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpum5k6sfu.swift:12:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmpum5k6sfu.swift:13:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(errorCode: ErrorCode.InvalidParameter.rawValue,\
    \ message: \"Invalid parameter\"))\n               ^~~\n/tmp/tmpum5k6sfu.swift:13:35:\
    \ error: cannot find 'ErrorCode' in scope\n        return Err(Int(errorCode: ErrorCode.InvalidParameter.rawValue,\
    \ message: \"Invalid parameter\"))\n                                  ^~~~~~~~~\n\
    /tmp/tmpum5k6sfu.swift:13:81: error: extra argument 'message' in call\n      \
    \  return Err(Int(errorCode: ErrorCode.InvalidParameter.rawValue, message: \"\
    Invalid parameter\"))\n                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpum5k6sfu.swift:20:12: error: initializer for conditional binding must\
    \ have Optional type, not 'String'\n        if let word = word.lowercased() {\n\
    \           ^          ~~~~~~~~~~~~~~~~~\n/tmp/tmpum5k6sfu.swift:33:12: error:\
    \ cannot find 'Ok' in scope\n    return Ok(words)\n           ^~\n"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    guard words.count > 0 else { return Err(0) }\n    \n    let splitWords\
    \ = words.map { $0.components(separatedBy: \",\").map { $0.lowercased() } }\n\
    \    \n    if splitWords.count % 2 == 1 {\n        return Ok(splitWords)\n   \
    \ }\n    \n    return Err(splitWords.count / 2)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpyjt6pncl.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpyjt6pncl.swift:13:41: error: cannot find 'Err'\
    \ in scope\n    guard words.count > 0 else { return Err(0) }\n               \
    \                         ^~~\n/tmp/tmpyjt6pncl.swift:18:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(splitWords)\n               ^~\n/tmp/tmpyjt6pncl.swift:21:12:\
    \ error: cannot find 'Err' in scope\n    return Err(splitWords.count / 2)\n  \
    \         ^~~\n"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(1))\n    }\n    let comma\
    \ = words.last?.components(separatedBy: \",\")\n    if comma?.count == 0 {\n \
    \       return Err(Int(words.count + 1))\n    }\n    return Ok(words.dropLast())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpwbzd9aty.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpwbzd9aty.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(1))\n               ^~~\n/tmp/tmpwbzd9aty.swift:18:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(words.count + 1))\n\
    \               ^~~\n/tmp/tmpwbzd9aty.swift:20:12: error: cannot find 'Ok' in\
    \ scope\n    return Ok(words.dropLast())\n           ^~\n"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(1))\n    }\n    let wordCount\
    \ = words.count\n    let wordArray = words.map { $0.lowercased() }\n    let wordArrayCount\
    \ = wordArray.count\n    if wordArrayCount % 2 == 1 {\n        return Err(Int(wordArrayCount))\n\
    \    }\n    if wordArrayCount % 2 == 0 {\n        let evenWordArray = wordArray.filter\
    \ { $0 % 2 == 0 }\n        let evenWordCount = evenWordArray.count\n        let\
    \ evenWordArrayCount = evenWordArray.count\n        if evenWordArrayCount % 2\
    \ == 1 {\n            return Err(Int(evenWordArrayCount))\n        }\n       \
    \ let evenWordArray = evenWordArray.map { $0.lowercased() }\n        return Ok(evenWordArray)\n\
    \    }\n    return Ok(wordArray)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmppqqpxpsz.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmppqqpxpsz.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(1))\n               ^~~\n/tmp/tmppqqpxpsz.swift:20:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(wordArrayCount))\n\
    \               ^~~\n/tmp/tmppqqpxpsz.swift:27:20: error: cannot find 'Err' in\
    \ scope\n            return Err(Int(evenWordArrayCount))\n                   ^~~\n\
    /tmp/tmppqqpxpsz.swift:30:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(evenWordArray)\n               ^~\n/tmp/tmppqqpxpsz.swift:32:12: error: cannot\
    \ find 'Ok' in scope\n    return Ok(wordArray)\n           ^~\n"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(1))\n    }\n    let wordCount\
    \ = words.count\n    let wordCountWithCommas = wordCount + words.count - 1\n \
    \   let wordCountWithCommasWithOddOrder = wordCountWithCommas + words.count -\
    \ 1\n    let wordCountWithCommasWithOddOrderWithOddOrder = wordCountWithCommasWithOddOrder\
    \ + words.count - 1\n    return Ok([words]) // TODO: return words as well\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpd3r0oize.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpd3r0oize.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(1))\n               ^~~\n/tmp/tmpd3r0oize.swift:20:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok([words]) // TODO: return words\
    \ as well\n           ^~\n"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    guard !words.isEmpty else { return Err(0) }\n    guard !words.contains(\"\
    ,\") else { return Err(1) }\n    guard !words.contains(\".\") else { return Err(2)\
    \ }\n    guard !words.contains(\"!\") else { return Err(3) }\n    guard !words.contains(\"\
    ?\") else { return Err(4) }\n    guard !words.contains(\":\") else { return Err(5)\
    \ }\n    guard !words.contains(\";\") else { return Err(6) }\n    guard !words.contains(\"\
    <\") else { return Err(7) }\n    guard !words.contains(\"=\") else { return Err(8)\
    \ }\n    guard !words.contains(\"[\") else { return Err(9) }\n    guard !words.contains(\"\
    ]\") else { return Err(10) }\n    guard !words.contains(\"{\") else { return Err(11)\
    \ }\n    guard !words.contains(\"}\") else { return Err(12) }\n    guard !words.contains(\"\
    (\") else { return Err(13) }\n    guard !words.contains(\")\") else { return Err(14)\
    \ }\n    guard !words.contains(\",\") else { return Err(15) }\n    guard !words.contains(\"\
    .\") else { return Err(16) }\n    guard !words.contains(\"!\") else { return Err(17)\
    \ }\n    guard !words.contains(\"?\") else { return Err(18) }\n    guard !words.contains(\"\
    :\") else { return Err(19) }\n    guard !words.contains(\";\") else { return Err(20)\
    \ }\n    guard !words.contains(\"<\") else { return Err(21) }\n    guard !words.contains(\"\
    =\") else { return Err(22) }\n    guard !words.contains(\"[\") else { return Err(23)\
    \ }\n    guard !words.contains(\"]\") else { return Err(24) }\n    guard !words.contains(\"\
    {\") else { return Err(25) }\n    guard !words.contains(\"}\") else { return Err(26)\
    \ }\n    guard !words.contains(\"(\") else { return Err(27) }\n    guard !words.contains(\"\
    )\") else { return Err(28) }\n    guard !words.contains(\",\") else { return Err(29)\
    \ }\n    guard !words.contains(\".\") else { return Err(30) }\n    guard !words.contains(\"\
    !\") else { return Err(31) }\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp5vj75a18.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp5vj75a18.swift:13:40: error: cannot find 'Err'\
    \ in scope\n    guard !words.isEmpty else { return Err(0) }\n                \
    \                       ^~~\n/tmp/tmp5vj75a18.swift:14:46: error: cannot find\
    \ 'Err' in scope\n    guard !words.contains(\",\") else { return Err(1) }\n  \
    \                                           ^~~\n/tmp/tmp5vj75a18.swift:15:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\".\") else { return\
    \ Err(2) }\n                                             ^~~\n/tmp/tmp5vj75a18.swift:16:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\"!\") else { return\
    \ Err(3) }\n                                             ^~~\n/tmp/tmp5vj75a18.swift:17:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\"?\") else { return\
    \ Err(4) }\n                                             ^~~\n/tmp/tmp5vj75a18.swift:18:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\":\") else { return\
    \ Err(5) }\n                                             ^~~\n/tmp/tmp5vj75a18.swift:19:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\";\") else { return\
    \ Err(6) }\n                                             ^~~\n/tmp/tmp5vj75a18.swift:20:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\"<\") else { return\
    \ Err(7) }\n                                             ^~~\n/tmp/tmp5vj75a18.swift:21:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\"=\") else { return\
    \ Err(8) }\n                                             ^~~\n/tmp/tmp5vj75a18.swift:22:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\"[\") else { return\
    \ Err(9) }\n                                             ^~~\n/tmp/tmp5vj75a18.swift:23:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\"]\") else { return\
    \ Err(10) }\n                                             ^~~\n/tmp/tmp5vj75a18.swift:24:46:\
    \ error: cannot find 'Err' "
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.components(separatedBy:\
    \ \" \") else {\n        return Err(Int(.notAnInteger))\n    }\n    \n    var\
    \ result: [String] = []\n    \n    for word in words {\n        if let word =\
    \ word.lowercased() {\n            result.append(word)\n        }\n    }\n   \
    \ \n    if result.count == 0 {\n        return Err(Int(.notAnInteger))\n    }\n\
    \    \n    if result.count % 2 == 1 {\n        return Err(Int(.notAnInteger))\n\
    \    }\n    \n    if result.count > 25 {\n        return Err(Int(.notAnInteger))\n\
    \    }\n    \n    return Ok(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp3dg80jia.swift:12:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmp3dg80jia.swift:13:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(.notAnInteger))\n       \
    \        ^~~\n/tmp/tmp3dg80jia.swift:13:24: error: missing argument label 'bitPattern:'\
    \ in call\n        return Err(Int(.notAnInteger))\n                       ^\n\
    \                       bitPattern: \n/tmp/tmp3dg80jia.swift:25:16: error: cannot\
    \ find 'Err' in scope\n        return Err(Int(.notAnInteger))\n              \
    \ ^~~\n/tmp/tmp3dg80jia.swift:25:24: error: missing argument label 'bitPattern:'\
    \ in call\n        return Err(Int(.notAnInteger))\n                       ^\n\
    \                       bitPattern: \n/tmp/tmp3dg80jia.swift:29:16: error: cannot\
    \ find 'Err' in scope\n        return Err(Int(.notAnInteger))\n              \
    \ ^~~\n/tmp/tmp3dg80jia.swift:29:24: error: missing argument label 'bitPattern:'\
    \ in call\n        return Err(Int(.notAnInteger))\n                       ^\n\
    \                       bitPattern: \n/tmp/tmp3dg80jia.swift:33:16: error: cannot\
    \ find 'Err' in scope\n        return Err(Int(.notAnInteger))\n              \
    \ ^~~\n/tmp/tmp3dg80jia.swift:33:24: error: missing argument label 'bitPattern:'\
    \ in call\n        return Err(Int(.notAnInteger))\n                       ^\n\
    \                       bitPattern: \n/tmp/tmp3dg80jia.swift:36:12: error: cannot\
    \ find 'Ok' in scope\n    return Ok(result)\n           ^~\n"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.components(separatedBy:\
    \ \" \") else {\n        return Err(Int(rawValue: 1))\n    }\n    \n    var result\
    \ = [String]()\n    \n    for word in words {\n        if let word = word.lowercased()\
    \ {\n            result.append(word)\n        }\n    }\n    \n    if result.count\
    \ == 0 {\n        return Err(Int(rawValue: 1))\n    }\n    \n    if result.count\
    \ == 1 {\n        return result\n    }\n    \n    if result.count % 2 == 1 {\n\
    \        return Err(Int(rawValue: 1))\n    }\n    \n    let even = result.count\
    \ / 2\n    let odd = result.count - 1\n    \n    let evenWords = result[..<even]\n\
    \    let oddWords = result[even..<odd]\n    \n    return Ok([evenWords, oddWords])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpv0wyyrsp.swift:12:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmpv0wyyrsp.swift:13:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(rawValue: 1))\n         \
    \      ^~~\n/tmp/tmpv0wyyrsp.swift:13:23: error: extraneous argument label 'rawValue:'\
    \ in call\n        return Err(Int(rawValue: 1))\n                      ^~~~~~~~~~~\n\
    \                       \n/tmp/tmpv0wyyrsp.swift:25:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(rawValue: 1))\n               ^~~\n/tmp/tmpv0wyyrsp.swift:25:23:\
    \ error: extraneous argument label 'rawValue:' in call\n        return Err(Int(rawValue:\
    \ 1))\n                      ^~~~~~~~~~~\n                       \n/tmp/tmpv0wyyrsp.swift:29:16:\
    \ error: cannot convert return expression of type '[String]' to return type 'Result<[String],\
    \ Int>'\n        return result\n               ^~~~~~\n/tmp/tmpv0wyyrsp.swift:33:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(rawValue: 1))\n  \
    \             ^~~\n/tmp/tmpv0wyyrsp.swift:33:23: error: extraneous argument label\
    \ 'rawValue:' in call\n        return Err(Int(rawValue: 1))\n                \
    \      ^~~~~~~~~~~\n                       \n/tmp/tmpv0wyyrsp.swift:42:12: error:\
    \ cannot find 'Ok' in scope\n    return Ok([evenWords, oddWords])\n          \
    \ ^~\n"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.components(separatedBy:\
    \ \" \") else {\n        return Err(Int(.init(rawValue: 1)).rawValue)\n    }\n\
    \    \n    let wordCount = words.count\n    \n    guard wordCount > 0 else {\n\
    \        return Err(Int(.init(rawValue: 2)).rawValue)\n    }\n    \n    let letterCount\
    \ = words.reduce(0) { (result, word) -> Int in\n        let letter = word.lowercased()\n\
    \        \n        guard let index = alphabet.index(of: letter) else { return\
    \ result }\n        \n        return result + index\n    }\n    \n    return Ok([words])\
    \ // TODO: Return error if letterCount is odd, not just 1\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpds8aje5e.swift:12:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmpds8aje5e.swift:13:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(.init(rawValue: 1)).rawValue)\n\
    \               ^~~\n/tmp/tmpds8aje5e.swift:13:44: error: value of type 'Int'\
    \ has no member 'rawValue'\n        return Err(Int(.init(rawValue: 1)).rawValue)\n\
    \                   ~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmpds8aje5e.swift:13:25:\
    \ error: reference to member 'init' cannot be resolved without a contextual type\n\
    \        return Err(Int(.init(rawValue: 1)).rawValue)\n                      \
    \  ^\n/tmp/tmpds8aje5e.swift:19:16: error: cannot find 'Err' in scope\n      \
    \  return Err(Int(.init(rawValue: 2)).rawValue)\n               ^~~\n/tmp/tmpds8aje5e.swift:19:44:\
    \ error: value of type 'Int' has no member 'rawValue'\n        return Err(Int(.init(rawValue:\
    \ 2)).rawValue)\n                   ~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmpds8aje5e.swift:19:25:\
    \ error: reference to member 'init' cannot be resolved without a contextual type\n\
    \        return Err(Int(.init(rawValue: 2)).rawValue)\n                      \
    \  ^\n/tmp/tmpds8aje5e.swift:25:27: error: cannot find 'alphabet' in scope\n \
    \       guard let index = alphabet.index(of: letter) else { return result }\n\
    \                          ^~~~~~~~\n/tmp/tmpds8aje5e.swift:30:12: error: cannot\
    \ find 'Ok' in scope\n    return Ok([words]) // TODO: Return error if letterCount\
    \ is odd, not just 1\n           ^~\n"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(1))\n    }\n    if words.count\
    \ == 1 {\n        return Ok(words)\n    }\n    let words = words.compactMap {\
    \ $0.components(separatedBy: \",\") }\n    if words.count == 0 {\n        return\
    \ Err(Int(1))\n    }\n    if words.count == 1 {\n        return Ok(words)\n  \
    \  }\n    let letters = words.map { $0.map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpz_vffydt.swift:26:1835: error: expected member name following '.'\n\
    \    let letters = words.map { $0.map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).map(String.init).\n\
    \                                                                            \
    \                                                              "
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    let wordCount = words.count\n    let wordCountWithCommas = words.count\
    \ + words.count - 1\n    let letterCount = txt.unicodeScalars.filter({ $0.isLetter}).count\n\
    \    let letterCountWithCommas = txt.unicodeScalars.filter({ $0.isLetter}).count\
    \ + txt.unicodeScalars.filter({ $0.isLetter}).count - 1\n    \n    guard wordCount\
    \ > 0 else { return Err(0) }\n    guard wordCountWithCommas > 0 else { return\
    \ Err(0) }\n    guard letterCount > 0 else { return Err(0) }\n    guard letterCountWithCommas\
    \ > 0 else { return Err(0) }\n    \n    return Ok([words[0], words[wordCount -\
    \ 1], letterCount, letterCountWithCommas])\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpdfam3dhf.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpdfam3dhf.swift:15:54: error: value of type 'Unicode.Scalar'\
    \ has no member 'isLetter'\n    let letterCount = txt.unicodeScalars.filter({\
    \ $0.isLetter}).count\n                                                  ~~ ^~~~~~~~\n\
    /tmp/tmpdfam3dhf.swift:16:64: error: value of type 'Unicode.Scalar' has no member\
    \ 'isLetter'\n    let letterCountWithCommas = txt.unicodeScalars.filter({ $0.isLetter}).count\
    \ + txt.unicodeScalars.filter({ $0.isLetter}).count - 1\n                    \
    \                                        ~~ ^~~~~~~~\n/tmp/tmpdfam3dhf.swift:16:114:\
    \ error: value of type 'Unicode.Scalar' has no member 'isLetter'\n    let letterCountWithCommas\
    \ = txt.unicodeScalars.filter({ $0.isLetter}).count + txt.unicodeScalars.filter({\
    \ $0.isLetter}).count - 1\n                                                  \
    \                                                            ~~ ^~~~~~~~\n/tmp/tmpdfam3dhf.swift:18:39:\
    \ error: cannot find 'Err' in scope\n    guard wordCount > 0 else { return Err(0)\
    \ }\n                                      ^~~\n/tmp/tmpdfam3dhf.swift:19:49:\
    \ error: cannot find 'Err' in scope\n    guard wordCountWithCommas > 0 else {\
    \ return Err(0) }\n                                                ^~~\n/tmp/tmpdfam3dhf.swift:20:41:\
    \ error: cannot find 'Err' in scope\n    guard letterCount > 0 else { return Err(0)\
    \ }\n                                        ^~~\n/tmp/tmpdfam3dhf.swift:21:51:\
    \ error: cannot find 'Err' in scope\n    guard letterCountWithCommas > 0 else\
    \ { return Err(0) }\n                                                  ^~~\n/tmp/tmpdfam3dhf.swift:23:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok([words[0], words[wordCount -\
    \ 1], letterCount, letterCountWithCommas])\n           ^~\n"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(0))\n    }\n    if words.count\
    \ == 1 {\n        return Ok([words[0]])\n    }\n    let firstWord = words[0]\n\
    \    let lastWord = words[words.count - 1]\n    if firstWord.hasPrefix(\",\")\
    \ {\n        return Ok(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return Ok(words.dropLast())\n    }\n    if firstWord.hasSuffix(\"\
    ,\") {\n        return Ok(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return Ok(words.dropFirst())\n    }\n    if lastWord.hasPrefix(\"\
    ,\") {\n        return Ok(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return Ok(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return Ok(words.dropLast())\n    }\n    if firstWord.hasSuffix(\"\
    ,\") {\n        return Ok(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return Ok(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return Ok(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return Ok(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return Ok(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return Ok(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return Ok(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return Ok(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return Ok(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return Ok(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return Ok(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return Ok(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return Ok(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return Ok(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\"\
    ,\") {\n        return Ok(words.dropLast())\n    }\n    if firstWord.hasPrefix(\"\
    ,\") {\n        return Ok(words.drop\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpm6183fz3.swift:89:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpm6183fz3.swift:88:18: note: to match this opening '('\n        return\
    \ Ok(words.drop\n                 ^\n/tmp/tmpm6183fz3.swift:111:44: error: expected\
    \ '}' at end of brace statement\nassert(split_words(txt: \"\") == .failure(0))\n\
    \                                           ^\n/tmp/tmpm6183fz3.swift:11:56: note:\
    \ to match this opening '{'\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n                                                       ^\n/tmp/tmpm6183fz3.swift:12:21:\
    \ error: value of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmpm6183fz3.swift:14:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(0))\n               ^~~\n\
    /tmp/tmpm6183fz3.swift:17:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok([words[0]])\n               ^~\n/tmp/tmpm6183fz3.swift:22:16: error: cannot\
    \ find 'Ok' in scope\n        return Ok(words.dropFirst())\n               ^~\n\
    /tmp/tmpm6183fz3.swift:25:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words.dropLast())\n               ^~\n/tmp/tmpm6183fz3.swift:28:16: error:\
    \ cannot find 'Ok' in scope\n        return Ok(words.dropLast())\n           \
    \    ^~\n/tmp/tmpm6183fz3.swift:31:16: error: cannot find 'Ok' in scope\n    \
    \    return Ok(words.dropFirst())\n               ^~\n/tmp/tmpm6183fz3.swift:34:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words.dropLast())\n    \
    \           ^~\n/tmp/tmpm6183fz3.swift:37:16: error: cannot find 'Ok' in scope\n\
    \        return Ok(words.dropFirst())\n               ^~\n/tmp/tmpm6183fz3.swift:40:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words.dropLast())\n    \
    \           ^~\n/tmp/tmpm6183fz3.swift:43:16: error: cannot find 'Ok' in scope\n\
    \        return Ok(words.dropLast())\n               ^~\n/tmp/tmpm6183fz3.swift:46:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words.dropFirst())\n   \
    \            ^~\n/tmp/tmpm6183fz3.swift:49:16: error: cannot find 'Ok' in scope\n\
    \        return O"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.components(separatedBy:\
    \ \" \") else {\n        return Err(Int(.init(rawValue: -999)))\n    }\n    \n\
    \    var result: [String] = []\n    \n    for word in words {\n        guard let\
    \ letters = word.components(separatedBy: \",\") else {\n            return Err(Int(.init(rawValue:\
    \ -999)))\n        }\n        \n        for letter in letters {\n            if\
    \ let count = letter.characters.filter({ $0 >= 'a' && $0 <= 'z' }).count {\n \
    \               if count % 2 == 1 {\n                    result.append(letter)\n\
    \                }\n            }\n        }\n    }\n    \n    if result.count\
    \ == 0 {\n        return Err(Int(.init(rawValue: -999)))\n    }\n    \n    return\
    \ Ok(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpvssce1_n.swift:24:61: error: single-quoted string literal found,\
    \ use '\"'\n            if let count = letter.characters.filter({ $0 >= 'a' &&\
    \ $0 <= 'z' }).count {\n                                                     \
    \       ^~~\n                                                            \"a\"\
    \n/tmp/tmpvssce1_n.swift:24:74: error: single-quoted string literal found, use\
    \ '\"'\n            if let count = letter.characters.filter({ $0 >= 'a' && $0\
    \ <= 'z' }).count {\n                                                        \
    \                 ^~~\n                                                      \
    \                   \"z\"\n/tmp/tmpvssce1_n.swift:12:27: error: value of type\
    \ 'String' has no member 'components'\n    guard let words = txt.components(separatedBy:\
    \ \" \") else {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmpvssce1_n.swift:13:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(.init(rawValue: -999)))\n\
    \               ^~~\n/tmp/tmpvssce1_n.swift:13:25: error: reference to member\
    \ 'init' cannot be resolved without a contextual type\n        return Err(Int(.init(rawValue:\
    \ -999)))\n                        ^\n/tmp/tmpvssce1_n.swift:33:16: error: cannot\
    \ find 'Err' in scope\n        return Err(Int(.init(rawValue: -999)))\n      \
    \         ^~~\n/tmp/tmpvssce1_n.swift:33:25: error: reference to member 'init'\
    \ cannot be resolved without a contextual type\n        return Err(Int(.init(rawValue:\
    \ -999)))\n                        ^\n/tmp/tmpvssce1_n.swift:36:12: error: cannot\
    \ find 'Ok' in scope\n    return Ok(result)\n           ^~\n"
  stdout: ''
  timestamp: 1660054240
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count < 2 { return Err(0) }\n    let firstWord = words[0]\n  \
    \  let lastWord = words[words.count - 1]\n    if firstWord.count < 2 { return\
    \ Err(0) }\n    if lastWord.count < 2 { return Err(0) }\n    let firstChar = firstWord[0]\n\
    \    let lastChar = lastWord[lastWord.count - 1]\n    if firstChar.isUppercase\
    \ && lastChar.isUppercase {\n        return Ok(words.dropFirst())\n    }\n   \
    \ if firstChar.isUppercase {\n        return Ok(words.dropFirst().map { $0.lowercased()\
    \ })\n    }\n    if lastChar.isUppercase {\n        return Ok(words.dropLast().map\
    \ { $0.lowercased() })\n    }\n    return Ok(words.dropFirst().map { $0.lowercased()\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\"\
    ) == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world\
    \ !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"\
    abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpz4lgh4v5.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpz4lgh4v5.swift:13:33: error: cannot find 'Err'\
    \ in scope\n    if words.count < 2 { return Err(0) }\n                       \
    \         ^~~\n/tmp/tmpz4lgh4v5.swift:16:37: error: cannot find 'Err' in scope\n\
    \    if firstWord.count < 2 { return Err(0) }\n                              \
    \      ^~~\n/tmp/tmpz4lgh4v5.swift:17:36: error: cannot find 'Err' in scope\n\
    \    if lastWord.count < 2 { return Err(0) }\n                               \
    \    ^~~\n/tmp/tmpz4lgh4v5.swift:21:16: error: cannot find 'Ok' in scope\n   \
    \     return Ok(words.dropFirst())\n               ^~\n/tmp/tmpz4lgh4v5.swift:24:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words.dropFirst().map {\
    \ $0.lowercased() })\n               ^~\n/tmp/tmpz4lgh4v5.swift:27:16: error:\
    \ cannot find 'Ok' in scope\n        return Ok(words.dropLast().map { $0.lowercased()\
    \ })\n               ^~\n/tmp/tmpz4lgh4v5.swift:29:12: error: cannot find 'Ok'\
    \ in scope\n    return Ok(words.dropFirst().map { $0.lowercased() })\n       \
    \    ^~\n"
  stdout: ''
  timestamp: 1660054240
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(1))\n    }\n    if words.count\
    \ == 1 {\n        return Ok(words)\n    }\n    let wordCount = words.count\n \
    \   let firstWord = words[0]\n    let firstLetter = firstWord.characters.first\n\
    \    let firstLetterUppercase = firstLetter >= 97 && firstLetter <= 122\n    let\
    \ firstLetterLowercase = firstLetter >= 65 && firstLetter <= 90\n    let firstLetterOdd\
    \ = firstLetterUppercase || firstLetterLowercase\n    let firstLetterEven = firstLetterUppercase\
    \ && !firstLetterLowercase\n    let firstLetterOddOrEven = firstLetterOdd || firstLetterEven\n\
    \    if firstLetterOddOrEven {\n        return Err(Int(1))\n    }\n    if firstLetterOdd\
    \ {\n        return Ok(words.dropFirst())\n    }\n    if firstLetterEven {\n \
    \       return Ok(words.dropFirst().map { $0.lowercased() })\n    }\n    return\
    \ Ok(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp05vj25el.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp05vj25el.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(1))\n               ^~~\n/tmp/tmp05vj25el.swift:17:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmp05vj25el.swift:28:16: error: cannot find 'Err' in scope\n        return\
    \ Err(Int(1))\n               ^~~\n/tmp/tmp05vj25el.swift:31:16: error: cannot\
    \ find 'Ok' in scope\n        return Ok(words.dropFirst())\n               ^~\n\
    /tmp/tmp05vj25el.swift:34:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words.dropFirst().map { $0.lowercased() })\n               ^~\n/tmp/tmp05vj25el.swift:36:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words)\n           ^~\n"
  stdout: ''
  timestamp: 1660054239
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    guard words.count > 0 else { return Err(0) }\n    let wordCount = words.count\n\
    \    let wordArray = words.map { $0.lowercased() }\n    let wordArrayCount = wordArray.count\n\
    \    \n    if wordArrayCount % 2 != 0 {\n        return Err(wordArrayCount)\n\
    \    }\n    \n    if wordArrayCount > wordCount {\n        return Err(wordCount)\n\
    \    }\n    \n    return Ok(wordArray)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp40g6zm5h.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp40g6zm5h.swift:13:41: error: cannot find 'Err'\
    \ in scope\n    guard words.count > 0 else { return Err(0) }\n               \
    \                         ^~~\n/tmp/tmp40g6zm5h.swift:19:16: error: cannot find\
    \ 'Err' in scope\n        return Err(wordArrayCount)\n               ^~~\n/tmp/tmp40g6zm5h.swift:23:16:\
    \ error: cannot find 'Err' in scope\n        return Err(wordCount)\n         \
    \      ^~~\n/tmp/tmp40g6zm5h.swift:26:12: error: cannot find 'Ok' in scope\n \
    \   return Ok(wordArray)\n           ^~\n"
  stdout: ''
  timestamp: 1660054240
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.components(separatedBy:\
    \ \" \") else {\n        return Err(Int(.errDomain))\n    }\n    \n    var result\
    \ = [String]()\n    \n    for word in words {\n        guard let letters = word.components(separatedBy:\
    \ \",\") else {\n            return Err(Int(.errDomain))\n        }\n        \n\
    \        for letter in letters {\n            if let letter = letter.lowercased()\
    \ {\n                result.append(letter)\n            }\n        }\n    }\n\
    \    \n    if result.count == 0 {\n        return Err(Int(.errDomain))\n    }\n\
    \    \n    if result.count % 2 == 1 {\n        return Err(Int(.errDomain))\n \
    \   }\n    \n    return Ok(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpxkyid3kb.swift:12:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmpxkyid3kb.swift:13:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(.errDomain))\n          \
    \     ^~~\n/tmp/tmpxkyid3kb.swift:13:24: error: missing argument label 'bitPattern:'\
    \ in call\n        return Err(Int(.errDomain))\n                       ^\n   \
    \                    bitPattern: \n/tmp/tmpxkyid3kb.swift:31:16: error: cannot\
    \ find 'Err' in scope\n        return Err(Int(.errDomain))\n               ^~~\n\
    /tmp/tmpxkyid3kb.swift:31:24: error: missing argument label 'bitPattern:' in call\n\
    \        return Err(Int(.errDomain))\n                       ^\n             \
    \          bitPattern: \n/tmp/tmpxkyid3kb.swift:35:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(.errDomain))\n               ^~~\n/tmp/tmpxkyid3kb.swift:35:24:\
    \ error: missing argument label 'bitPattern:' in call\n        return Err(Int(.errDomain))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmpxkyid3kb.swift:38:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(result)\n           ^~\n"
  stdout: ''
  timestamp: 1660054240
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int((txt.characters.count)))\n\
    \    }\n    let splitWords = words.map { $0.components(separatedBy: \",\").map\
    \ { $0.lowercased() } }\n    if splitWords.count == 0 {\n        return Err(Int((txt.characters.count)))\n\
    \    }\n    let evenOrderWords = splitWords.filter { $0.count % 2 == 0 }\n   \
    \ if evenOrderWords.count > 0 {\n        return Err(Int((txt.characters.count)))\n\
    \    }\n    return Ok(evenOrderWords)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpj4q89o1p.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpj4q89o1p.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int((txt.characters.count)))\n               ^~~\n\
    /tmp/tmpj4q89o1p.swift:18:16: error: cannot find 'Err' in scope\n        return\
    \ Err(Int((txt.characters.count)))\n               ^~~\n/tmp/tmpj4q89o1p.swift:22:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int((txt.characters.count)))\n\
    \               ^~~\n/tmp/tmpj4q89o1p.swift:24:12: error: cannot find 'Ok' in\
    \ scope\n    return Ok(evenOrderWords)\n           ^~\n"
  stdout: ''
  timestamp: 1660054240
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count < 2 {\n        return Err(words.count)\n    }\n    let firstWord\
    \ = words[0]\n    let lastWord = words[words.count - 1]\n    if firstWord.hasPrefix(\"\
    \ \") {\n        return Err(firstWord.count)\n    }\n    if lastWord.hasSuffix(\"\
    \ \") {\n        return Err(lastWord.count)\n    }\n    if firstWord.hasSuffix(\"\
    ,\") {\n        return Err(firstWord.count)\n    }\n    if lastWord.hasPrefix(\"\
    ,\") {\n        return Err(lastWord.count)\n    }\n    let firstWordLower = firstWord.lowercased()\n\
    \    let lastWordLower = lastWord.lowercased()\n    if firstWordLower.hasPrefix(\"\
    a\") {\n        return Err(firstWordLower.count)\n    }\n    if lastWordLower.hasSuffix(\"\
    z\") {\n        return Err(lastWordLower.count)\n    }\n    if firstWordLower.hasSuffix(\"\
    a\") {\n        return Err(firstWordLower.count)\n    }\n    if lastWordLower.hasPrefix(\"\
    a\") {\n        return Err(lastWordLower.count)\n    }\n    if firstWordLower.hasPrefix(\"\
    b\") {\n        return Err(firstWordLower.count)\n    }\n    if lastWordLower.hasSuffix(\"\
    z\") {\n        return Err(lastWordLower.count)\n    }\n    if firstWordLower.hasSuffix(\"\
    b\") {\n        return Err(firstWordLower.count)\n    }\n    if firstWordLower.hasSuffix(\"\
    c\") {\n        return Err(firstWordLower.count)\n    }\n    if lastWordLower.hasPrefix(\"\
    c\") {\n        return Err(lastWordLower.count)\n    }\n    if firstWordLower.hasPrefix(\"\
    d\") {\n        return Err(firstWordLower.count)\n    }\n    if lastWordLower.hasSuffix(\"\
    z\") {\n        return Err(lastWordLower.count)\n    }\n    if firstWordLower.hasSuffix(\"\
    d\") {\n        return Err(firstWordLower.count)\n    }\n    if firstWordLower.hasSuffix(\"\
    e\") {\n        return Err(firstWordLower.count)\n    }\n    if lastWordLower.hasPrefix(\"\
    e\") {\n        return Err(lastWordLower.count)\n    }\n    if firstWordLower.hasPrefix(\"\
    f\") {\n        return Err(firstWordLower.count)\n    }\n    if lastWordLower.hasSuffix(\"\
    z\") {\n        return Err(lastWordLower.count)\n    }\n    if firstWordLower.hasSuffix(\"\
    f\") {\n        return Err(\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmppex_fein.swift:82:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmppex_fein.swift:104:44: error: expected '}' at end of brace statement\n\
    assert(split_words(txt: \"\") == .failure(0))\n                              \
    \             ^\n/tmp/tmppex_fein.swift:11:56: note: to match this opening '{'\n\
    func split_words(txt: String) -> Result<[String], Int> {\n                   \
    \                                    ^\n/tmp/tmppex_fein.swift:12:21: error: value\
    \ of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmppex_fein.swift:14:16: error:\
    \ cannot find 'Err' in scope\n        return Err(words.count)\n              \
    \ ^~~\n/tmp/tmppex_fein.swift:19:16: error: cannot find 'Err' in scope\n     \
    \   return Err(firstWord.count)\n               ^~~\n/tmp/tmppex_fein.swift:22:16:\
    \ error: cannot find 'Err' in scope\n        return Err(lastWord.count)\n    \
    \           ^~~\n/tmp/tmppex_fein.swift:25:16: error: cannot find 'Err' in scope\n\
    \        return Err(firstWord.count)\n               ^~~\n/tmp/tmppex_fein.swift:28:16:\
    \ error: cannot find 'Err' in scope\n        return Err(lastWord.count)\n    \
    \           ^~~\n/tmp/tmppex_fein.swift:33:16: error: cannot find 'Err' in scope\n\
    \        return Err(firstWordLower.count)\n               ^~~\n/tmp/tmppex_fein.swift:36:16:\
    \ error: cannot find 'Err' in scope\n        return Err(lastWordLower.count)\n\
    \               ^~~\n/tmp/tmppex_fein.swift:39:16: error: cannot find 'Err' in\
    \ scope\n        return Err(firstWordLower.count)\n               ^~~\n/tmp/tmppex_fein.swift:42:16:\
    \ error: cannot find 'Err' in scope\n        return Err(lastWordLower.count)\n\
    \               ^~~\n/tmp/tmppex_fein.swift:45:16: error: cannot find 'Err' in\
    \ scope\n        return Err(firstWordLower.count)\n               ^~~\n/tmp/tmppex_fein.swift:48:16:\
    \ error: cannot find 'Err' in scope\n        return Err(lastWordLower.count)\n\
    \               ^~~\n/tmp/tmppex_fein.swift:51:16: error: cannot find 'Err' in\
    \ scope\n        return Err(firstWordLower.count)\n               ^~~\n/t"
  stdout: ''
  timestamp: 1660054240
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    guard words.count > 0 else { return Err(0) }\n    guard words.count % 2\
    \ == 0 else { return Err(0) }\n    \n    var result = [String]()\n    \n    for\
    \ word in words {\n        if let word = word.lowercased() {\n            result.append(word)\n\
    \        }\n    }\n    \n    return Ok(result)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp51l6lqta.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp51l6lqta.swift:13:41: error: cannot find 'Err'\
    \ in scope\n    guard words.count > 0 else { return Err(0) }\n               \
    \                         ^~~\n/tmp/tmp51l6lqta.swift:14:46: error: cannot find\
    \ 'Err' in scope\n    guard words.count % 2 == 0 else { return Err(0) }\n    \
    \                                         ^~~\n/tmp/tmp51l6lqta.swift:24:12: error:\
    \ cannot find 'Ok' in scope\n    return Ok(result)\n           ^~\n"
  stdout: ''
  timestamp: 1660054240
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(0))\n    }\n    let wordCount\
    \ = words.count\n    let wordCountWithCommas = wordCount + words.count - 1\n \
    \   let wordCountWithCommasWithOddOrder = wordCountWithCommas + words.count -\
    \ 1\n    let wordCountWithCommasWithOddOrderWithOddLetters = wordCountWithCommasWithOddOrder\
    \ + words.count - 1\n    if wordCountWithCommasWithOddOrderWithOddLetters % 2\
    \ == 1 {\n        return Err(Int(0))\n    }\n    return Ok(words.map { $0.trimmingCharacters(in:\
    \ .whitespaces) })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmppous6m1a.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmppous6m1a.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(0))\n               ^~~\n/tmp/tmppous6m1a.swift:21:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(0))\n            \
    \   ^~~\n/tmp/tmppous6m1a.swift:23:12: error: cannot find 'Ok' in scope\n    return\
    \ Ok(words.map { $0.trimmingCharacters(in: .whitespaces) })\n           ^~\n/tmp/tmppous6m1a.swift:23:54:\
    \ error: cannot infer contextual base in reference to member 'whitespaces'\n \
    \   return Ok(words.map { $0.trimmingCharacters(in: .whitespaces) })\n       \
    \                                             ~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054240
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.components(separatedBy:\
    \ \" \") else {\n        return Err(Int(rawValue: 1))\n    }\n    \n    let wordCount\
    \ = words.count\n    \n    if wordCount == 0 {\n        return Err(Int(rawValue:\
    \ 2))\n    }\n    \n    if wordCount == 1 {\n        return Ok([words[0]])\n \
    \   }\n    \n    if wordCount == 2 {\n        return Ok([words[0], words[1]])\n\
    \    }\n    \n    if wordCount == 3 {\n        return Ok([words[0], words[1],\
    \ words[2]])\n    }\n    \n    if wordCount == 4 {\n        return Ok([words[0],\
    \ words[1], words[2], words[3]])\n    }\n    \n    if wordCount == 5 {\n     \
    \   return Ok([words[0], words[1], words[2], words[3], words[4]])\n    }\n   \
    \ \n    if wordCount == 6 {\n        return Ok([words[0], words[1], words[2],\
    \ words[3], words[4], words[5]])\n    }\n    \n    if wordCount == 7 {\n     \
    \   return Ok([words[0], words[1], words[2], words[3], words[4], words[5], words[6]])\n\
    \    }\n    \n    if wordCount == 8 {\n        return Ok([words[0], words[1],\
    \ words[2], words[3], words[4], words[5], words[6], words[7]])\n    }\n    \n\
    \    if wordCount == 9 {\n        return Ok([words[0], words[1], words[2], words[3],\
    \ words[4], words[5], words[6], words[7], words[8]])\n    }\n    \n    if wordCount\
    \ == 10 {\n        return Ok([words[0], words[1], words[2], words[3], words[4],\
    \ words[5], words[6], words[7], words[8], words[9]])\n    }\n    \n    if wordCount\
    \ == 11 {\n        return Ok([words[0], words[1], words[2], words[3], words[4],\
    \ words[5], words[6], words[7], words[8], words[9], words[10]])\n    }\n    \n\
    \    if wordCount == 12 {\n        return Ok([words[0], words[1], words[2], words[3],\
    \ words[4], words[5], words[6], words[7], words[8], words[9], words[10], words[11]])\n\
    \    }\n    \n    if wordCount == 13 {\n        return Ok([words[0], words[1],\
    \ words[2], words[3], words[4], words[5], words[6], words[7], words[8], words[9],\
    \ words[10], words[11], words[12\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpw7dndyd0.swift:72:1: error: expected ']' in expression list\n}\n\
    ^\n/tmp/tmpw7dndyd0.swift:71:147: note: to match this opening '['\n        return\
    \ Ok([words[0], words[1], words[2], words[3], words[4], words[5], words[6], words[7],\
    \ words[8], words[9], words[10], words[11], words[12\n                       \
    \                                                                            \
    \                                               ^\n/tmp/tmpw7dndyd0.swift:94:44:\
    \ error: expected '}' at end of brace statement\nassert(split_words(txt: \"\"\
    ) == .failure(0))\n                                           ^\n/tmp/tmpw7dndyd0.swift:11:56:\
    \ note: to match this opening '{'\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n                                                       ^\n/tmp/tmpw7dndyd0.swift:12:27:\
    \ error: value of type 'String' has no member 'components'\n    guard let words\
    \ = txt.components(separatedBy: \" \") else {\n                      ~~~ ^~~~~~~~~~\n\
    /tmp/tmpw7dndyd0.swift:13:16: error: cannot find 'Err' in scope\n        return\
    \ Err(Int(rawValue: 1))\n               ^~~\n/tmp/tmpw7dndyd0.swift:13:23: error:\
    \ extraneous argument label 'rawValue:' in call\n        return Err(Int(rawValue:\
    \ 1))\n                      ^~~~~~~~~~~\n                       \n/tmp/tmpw7dndyd0.swift:19:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(rawValue: 2))\n  \
    \             ^~~\n/tmp/tmpw7dndyd0.swift:19:23: error: extraneous argument label\
    \ 'rawValue:' in call\n        return Err(Int(rawValue: 2))\n                \
    \      ^~~~~~~~~~~\n                       \n/tmp/tmpw7dndyd0.swift:23:16: error:\
    \ cannot find 'Ok' in scope\n        return Ok([words[0]])\n               ^~\n\
    /tmp/tmpw7dndyd0.swift:27:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok([words[0], words[1]])\n               ^~\n/tmp/tmpw7dndyd0.swift:31:16: error:\
    \ cannot find 'Ok' in scope\n        return Ok([words[0], words[1], words[2]])\n\
    \               ^~\n/tmp/tmpw7dndyd0.swift:35:16: error: cannot find 'Ok' in scope\n\
    \        return Ok([words[0], words[1], words[2], words[3]])\n      "
  stdout: ''
  timestamp: 1660054250
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    guard words.count > 0 else { return Err(0) }\n    let comma = words.last!.components(separatedBy:\
    \ \",\").last!\n    guard comma == \"\" else { return Err(0) }\n    let letters\
    \ = words.map { $0.lowercased().characters.count }\n    let odd = letters.filter\
    \ { $0 % 2 != 0 }\n    return Ok(odd.count)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpo5bmc7xf.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpo5bmc7xf.swift:13:41: error: cannot find 'Err'\
    \ in scope\n    guard words.count > 0 else { return Err(0) }\n               \
    \                         ^~~\n/tmp/tmpo5bmc7xf.swift:15:37: error: cannot find\
    \ 'Err' in scope\n    guard comma == \"\" else { return Err(0) }\n           \
    \                         ^~~\n/tmp/tmpo5bmc7xf.swift:18:12: error: cannot find\
    \ 'Ok' in scope\n    return Ok(odd.count)\n           ^~\n"
  stdout: ''
  timestamp: 1660054240
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.components(separatedBy:\
    \ \" \") else {\n        return Err(Int(.init(rawValue: 1)).rawValue)\n    }\n\
    \    \n    var result: [String] = []\n    \n    for word in words {\n        guard\
    \ let letters = word.components(separatedBy: \",\") else {\n            return\
    \ Err(Int(.init(rawValue: 2)).rawValue)\n        }\n        \n        for letter\
    \ in letters {\n            if let number = Int(letter) {\n                if\
    \ number % 2 == 1 {\n                    result.append(letter)\n             \
    \   }\n            }\n        }\n    }\n    \n    if result.count % 2 == 1 {\n\
    \        result.append(result.last!)\n    }\n    \n    return Ok(result)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpvraafgr_.swift:12:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmpvraafgr_.swift:13:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(.init(rawValue: 1)).rawValue)\n\
    \               ^~~\n/tmp/tmpvraafgr_.swift:13:44: error: value of type 'Int'\
    \ has no member 'rawValue'\n        return Err(Int(.init(rawValue: 1)).rawValue)\n\
    \                   ~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmpvraafgr_.swift:13:25:\
    \ error: reference to member 'init' cannot be resolved without a contextual type\n\
    \        return Err(Int(.init(rawValue: 1)).rawValue)\n                      \
    \  ^\n/tmp/tmpvraafgr_.swift:36:12: error: cannot find 'Ok' in scope\n    return\
    \ Ok(result)\n           ^~\n"
  stdout: ''
  timestamp: 1660054240
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    guard !words.isEmpty else {\n        return Err(Int(errorCode: errorCodes.invalidArgument))\n\
    \    }\n    guard !words.contains(\",\") else {\n        return Err(Int(errorCode:\
    \ errorCodes.invalidArgument))\n    }\n    let chars = words.map { $0.characters.count\
    \ }\n    let oddChars = chars.filter { $0 % 2 == 1 }\n    let evenChars = chars.filter\
    \ { $0 % 2 == 0 }\n    let evenCharsCount = evenChars.count\n    let oddCharsCount\
    \ = oddChars.count\n    guard evenCharsCount != oddCharsCount else {\n       \
    \ return Err(Int(errorCode: errorCodes.invalidArgument))\n    }\n    let charsCount\
    \ = chars.count\n    let charsCountUpper = charsCount - evenCharsCount\n    let\
    \ charsCountLower = charsCount - oddCharsCount\n    let charsCountUpperUpper =\
    \ charsCountUpper - evenCharsCount\n    let charsCountUpperLower = charsCountUpper\
    \ - oddCharsCount\n    let charsCountLowerUpper = charsCountLower - evenCharsCount\n\
    \    let charsCountLowerLower = charsCountLower - oddCharsCount\n    let charsCountUpperUpperUpper\
    \ = charsCountUpperUpper - evenCharsCount\n    let charsCountUpperUpperLower =\
    \ charsCountUpperUpper - oddCharsCount\n    let charsCountUpperLowerUpper = charsCountUpperLower\
    \ - evenCharsCount\n    let charsCountUpperLowerLower = charsCountUpperLower -\
    \ oddCharsCount\n    let charsCountLowerUpperUpper = charsCountLowerUpper - evenCharsCount\n\
    \    let charsCountLowerUpperLower = charsCountLowerUpper - oddCharsCount\n  \
    \  let charsCountLowerLowerUpper = charsCountLowerLower - evenCharsCount\n   \
    \ let charsCountLowerLowerLower = charsCountLowerLower - oddCharsCount\n    let\
    \ charsCountUpperUpperUpperUpper = charsCountUpperUpperUpper - evenCharsCount\n\
    \    let charsCountUpperUpperUpperLower = charsCountUpperUpperUpper - oddCharsCount\n\
    \    let charsCountUpperUpperLowerUpper = charsCountUpperUpperLower - evenCharsCount\n\
    \    let charsCountUpperUpperLowerLower = charsCountUpperUpperLower - oddChars\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpoin0y6eo.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpoin0y6eo.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(errorCode: errorCodes.invalidArgument))\n \
    \              ^~~\n/tmp/tmpoin0y6eo.swift:14:35: error: cannot find 'errorCodes'\
    \ in scope\n        return Err(Int(errorCode: errorCodes.invalidArgument))\n \
    \                                 ^~~~~~~~~~\n/tmp/tmpoin0y6eo.swift:14:20: error:\
    \ no exact matches in call to initializer \n        return Err(Int(errorCode:\
    \ errorCodes.invalidArgument))\n                   ^\n/tmp/tmpoin0y6eo.swift:14:20:\
    \ note: found candidate with type '(Float16) -> Int'\n        return Err(Int(errorCode:\
    \ errorCodes.invalidArgument))\n                   ^\n/tmp/tmpoin0y6eo.swift:14:20:\
    \ note: found candidate with type '(Float) -> Int'\n        return Err(Int(errorCode:\
    \ errorCodes.invalidArgument))\n                   ^\n/tmp/tmpoin0y6eo.swift:14:20:\
    \ note: found candidate with type '(Double) -> Int'\n        return Err(Int(errorCode:\
    \ errorCodes.invalidArgument))\n                   ^\n/tmp/tmpoin0y6eo.swift:14:20:\
    \ note: found candidate with type '(Float80) -> Int'\n        return Err(Int(errorCode:\
    \ errorCodes.invalidArgument))\n                   ^\n/tmp/tmpoin0y6eo.swift:14:20:\
    \ note: found candidate with type '(Builtin.Int64) -> Int'\n        return Err(Int(errorCode:\
    \ errorCodes.invalidArgument))\n                   ^\n/tmp/tmpoin0y6eo.swift:14:20:\
    \ note: found candidate with type '(Builtin.Word) -> Int'\n        return Err(Int(errorCode:\
    \ errorCodes.invalidArgument))\n                   ^\n/tmp/tmpoin0y6eo.swift:14:20:\
    \ note: found candidate with type '(String) -> Int?'\n        return Err(Int(errorCode:\
    \ errorCodes.invalidArgument))\n                   ^\n/tmp/tmpoin0y6eo.swift:17:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(errorCode: errorCodes.invalidArgument))\n\
    \               ^~~\n/tmp/tmpoin0y6eo.swift:17:35: error: cannot find 'errorCodes'\
    \ in scope\n        return"
  stdout: ''
  timestamp: 1660054240
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    guard words.count > 0 else { return Err(0) }\n    guard words.count % 2\
    \ == 0 else {\n        return Err(words.count / 2)\n    }\n    let even = words.count\
    \ / 2\n    let odd = words.count - even\n    let letters = words.map { $0.lowercased()\
    \ }\n    return Ok([letters[0..<even], letters[even..<odd], letters[odd..<words.count]])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpddcvxgp6.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpddcvxgp6.swift:13:41: error: cannot find 'Err'\
    \ in scope\n    guard words.count > 0 else { return Err(0) }\n               \
    \                         ^~~\n/tmp/tmpddcvxgp6.swift:15:16: error: cannot find\
    \ 'Err' in scope\n        return Err(words.count / 2)\n               ^~~\n/tmp/tmpddcvxgp6.swift:20:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok([letters[0..<even], letters[even..<odd],\
    \ letters[odd..<words.count]])\n           ^~\n"
  stdout: ''
  timestamp: 1660054240
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(1))\n    }\n    if words.count\
    \ == 1 {\n        return Ok(words)\n    }\n    let letters = words.map { $0.lowercased()\
    \ }\n    let odd = letters.filter { $0.count % 2 == 1 }\n    if odd.count == 0\
    \ {\n        return Ok(letters)\n    }\n    return Err(Int(odd.count))\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp2myokwuu.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp2myokwuu.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(1))\n               ^~~\n/tmp/tmp2myokwuu.swift:17:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmp2myokwuu.swift:22:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(letters)\n               ^~\n/tmp/tmp2myokwuu.swift:24:12: error: cannot\
    \ find 'Err' in scope\n    return Err(Int(odd.count))\n           ^~~\n"
  stdout: ''
  timestamp: 1660054240
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    let result = words.count % 2 == 0 ? words.count / 2 : words.count / 2 +\
    \ 1\n    return Ok(words.map { $0.trimmingCharacters(in: .whitespacesAndNewlines)\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\"\
    ) == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world\
    \ !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"\
    abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpk7al0ke1.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpk7al0ke1.swift:14:12: error: cannot find 'Ok'\
    \ in scope\n    return Ok(words.map { $0.trimmingCharacters(in: .whitespacesAndNewlines)\
    \ })\n           ^~\n/tmp/tmpk7al0ke1.swift:14:54: error: cannot infer contextual\
    \ base in reference to member 'whitespacesAndNewlines'\n    return Ok(words.map\
    \ { $0.trimmingCharacters(in: .whitespacesAndNewlines) })\n                  \
    \                                  ~^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054240
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let txt = txt.data(using: .utf8) else\
    \ {\n        return Err(Int(errorCode: ErrorCode.invalidArgument.rawValue, userInfo:\
    \ nil))\n    }\n    \n    var words: [String] = []\n    var word = \"\"\n    var\
    \ wordCount = 0\n    var isWord = false\n    \n    for ch in txt.unicodeScalars\
    \ {\n        guard let ch = ch else {\n            return Err(Int(errorCode: ErrorCode.invalidArgument.rawValue,\
    \ userInfo: nil))\n        }\n        \n        if ch.isWhitespace() {\n     \
    \       if word != \"\" {\n                words.append(word)\n              \
    \  word = \"\"\n                wordCount = 0\n            }\n        } else {\n\
    \            if word == \"\" {\n                word = String(ch)\n          \
    \      isWord = true\n            } else {\n                word += String(ch)\n\
    \            }\n        }\n        \n        if isWord {\n            wordCount\
    \ += 1\n        }\n    }\n    \n    if word != \"\" {\n        words.append(word)\n\
    \    }\n    \n    if wordCount == 0 {\n        return Err(Int(errorCode: ErrorCode.invalidArgument.rawValue,\
    \ userInfo: nil))\n    }\n    \n    if wordCount % 2 == 1 {\n        return Err(Int(errorCode:\
    \ ErrorCode.invalidArgument.rawValue, userInfo: nil))\n    }\n    \n    return\
    \ Ok(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp0l46_xys.swift:12:25: error: value of type 'String' has no member\
    \ 'data'\n    guard let txt = txt.data(using: .utf8) else {\n                \
    \    ~~~ ^~~~\n/tmp/tmp0l46_xys.swift:12:38: error: cannot infer contextual base\
    \ in reference to member 'utf8'\n    guard let txt = txt.data(using: .utf8) else\
    \ {\n                                    ~^~~~\n/tmp/tmp0l46_xys.swift:13:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(errorCode: ErrorCode.invalidArgument.rawValue,\
    \ userInfo: nil))\n               ^~~\n/tmp/tmp0l46_xys.swift:13:35: error: cannot\
    \ find 'ErrorCode' in scope\n        return Err(Int(errorCode: ErrorCode.invalidArgument.rawValue,\
    \ userInfo: nil))\n                                  ^~~~~~~~~\n/tmp/tmp0l46_xys.swift:13:81:\
    \ error: extra argument 'userInfo' in call\n        return Err(Int(errorCode:\
    \ ErrorCode.invalidArgument.rawValue, userInfo: nil))\n                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~\n\
    /tmp/tmp0l46_xys.swift:13:81: error: 'nil' requires a contextual type\n      \
    \  return Err(Int(errorCode: ErrorCode.invalidArgument.rawValue, userInfo: nil))\n\
    \                                                                            \
    \    ^\n/tmp/tmp0l46_xys.swift:51:16: error: cannot find 'Err' in scope\n    \
    \    return Err(Int(errorCode: ErrorCode.invalidArgument.rawValue, userInfo: nil))\n\
    \               ^~~\n/tmp/tmp0l46_xys.swift:51:35: error: cannot find 'ErrorCode'\
    \ in scope\n        return Err(Int(errorCode: ErrorCode.invalidArgument.rawValue,\
    \ userInfo: nil))\n                                  ^~~~~~~~~\n/tmp/tmp0l46_xys.swift:51:81:\
    \ error: extra argument 'userInfo' in call\n        return Err(Int(errorCode:\
    \ ErrorCode.invalidArgument.rawValue, userInfo: nil))\n                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~\n\
    /tmp/tmp0l46_xys.swift:51:81: error: 'nil' requires a contextual type\n      \
    \  return Err(Int(errorCode: ErrorCode.invalidArgument.rawValue, userInfo: nil))\n\
    \                                                                            \
    \    ^\n/t"
  stdout: ''
  timestamp: 1660054240
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    \n    if words.count == 0 {\n        return Err(Int(0))\n    }\n    \n\
    \    let wordCount = words.count\n    \n    if wordCount == 1 {\n        return\
    \ Ok([words[0]])\n    }\n    \n    if wordCount == 2 {\n        return Ok([words[0],\
    \ words[1]])\n    }\n    \n    let letterCount = txt.unicodeScalars.filter({ $0.isLetter\
    \ }).count\n    \n    if letterCount == 1 {\n        return Ok([words[0], words[1]])\n\
    \    }\n    \n    if letterCount == 2 {\n        return Ok([words[0], words[1],\
    \ words[2]])\n    }\n    \n    if letterCount == 3 {\n        return Ok([words[0],\
    \ words[1], words[2], words[3]])\n    }\n    \n    if letterCount == 4 {\n   \
    \     return Ok([words[0], words[1], words[2], words[3], words[4]])\n    }\n \
    \   \n    if letterCount == 5 {\n        return Ok([words[0], words[1], words[2],\
    \ words[3], words[4], words[5]])\n    }\n    \n    if letterCount == 6 {\n   \
    \     return Ok([words[0], words[1], words[2], words[3], words[4], words[5], words[6]])\n\
    \    }\n    \n    if letterCount == 7 {\n        return Ok([words[0], words[1],\
    \ words[2], words[3], words[4], words[5], words[6], words[7]])\n    }\n    \n\
    \    if letterCount == 8 {\n        return Ok([words[0], words[1], words[2], words[3],\
    \ words[4], words[5], words[6], words[7], words[8]])\n    }\n    \n    if letterCount\
    \ == 9 {\n        return Ok([words[0], words[1], words[2], words[3], words[4],\
    \ words[5], words[6], words[7], words[8], words[9]])\n    }\n    \n    if letterCount\
    \ == 10 {\n        return Ok([words[0], words[1], words[2], words[3], words[4],\
    \ words[5], words[6], words[7], words[8], words[9], words[10]])\n    }\n    \n\
    \    if letterCount == 11 {\n        return Ok([words[0], words[1], words[2],\
    \ words[3], words[4], words[5], words[6], words[7], words[8], words[9], words[10],\
    \ words[11]])\n    }\n    \n    if letterCount == 12 {\n        return Ok([words[0],\
    \ words[1], words[2], words[3], words[4], words[5], words[6], words[7], word\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpq048_apy.swift:75:104: error: expected ']' in container literal\
    \ expression\n        return Ok([words[0], words[1], words[2], words[3], words[4],\
    \ words[5], words[6], words[7], word\n                                       \
    \                                                                ^\n/tmp/tmpq048_apy.swift:75:19:\
    \ note: to match this opening '['\n        return Ok([words[0], words[1], words[2],\
    \ words[3], words[4], words[5], words[6], words[7], word\n                  ^\n\
    /tmp/tmpq048_apy.swift:98:44: error: expected '}' at end of brace statement\n\
    assert(split_words(txt: \"\") == .failure(0))\n                              \
    \             ^\n/tmp/tmpq048_apy.swift:11:56: note: to match this opening '{'\n\
    func split_words(txt: String) -> Result<[String], Int> {\n                   \
    \                                    ^\n/tmp/tmpq048_apy.swift:12:21: error: value\
    \ of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmpq048_apy.swift:15:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(0))\n               ^~~\n\
    /tmp/tmpq048_apy.swift:21:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok([words[0]])\n               ^~\n/tmp/tmpq048_apy.swift:25:16: error: cannot\
    \ find 'Ok' in scope\n        return Ok([words[0], words[1]])\n              \
    \ ^~\n/tmp/tmpq048_apy.swift:28:54: error: value of type 'Unicode.Scalar' has\
    \ no member 'isLetter'\n    let letterCount = txt.unicodeScalars.filter({ $0.isLetter\
    \ }).count\n                                                  ~~ ^~~~~~~~\n/tmp/tmpq048_apy.swift:31:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok([words[0], words[1]])\n\
    \               ^~\n/tmp/tmpq048_apy.swift:35:16: error: cannot find 'Ok' in scope\n\
    \        return Ok([words[0], words[1], words[2]])\n               ^~\n/tmp/tmpq048_apy.swift:39:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok([words[0], words[1], words[2],\
    \ words[3]])\n               ^~\n/tmp/tmpq048_apy.swift:43:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok([words[0], words[1],"
  stdout: ''
  timestamp: 1660054245
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    guard words.count > 0 else {\n        return Err(Int(.init(rawValue: 1)).rawValue)\n\
    \    }\n    \n    var result: [String] = []\n    \n    for word in words {\n \
    \       let splitWord = word.components(separatedBy: \",\")\n        guard splitWord.count\
    \ > 0 else {\n            return Err(Int(.init(rawValue: 2)).rawValue)\n     \
    \   }\n        \n        for word in splitWord {\n            let lowercaseLetters\
    \ = word.characters.filter({ $0 >= 'a' && $0 <= 'z' }).count\n            if lowercaseLetters\
    \ % 2 == 1 {\n                result.append(word)\n            }\n        }\n\
    \    }\n    \n    return Ok(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp41mvow2p.swift:26:67: error: single-quoted string literal found,\
    \ use '\"'\n            let lowercaseLetters = word.characters.filter({ $0 >=\
    \ 'a' && $0 <= 'z' }).count\n                                                \
    \                  ^~~\n                                                     \
    \             \"a\"\n/tmp/tmp41mvow2p.swift:26:80: error: single-quoted string\
    \ literal found, use '\"'\n            let lowercaseLetters = word.characters.filter({\
    \ $0 >= 'a' && $0 <= 'z' }).count\n                                          \
    \                                     ^~~\n                                  \
    \                                             \"z\"\n/tmp/tmp41mvow2p.swift:12:21:\
    \ error: value of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmp41mvow2p.swift:14:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(.init(rawValue: 1)).rawValue)\n\
    \               ^~~\n/tmp/tmp41mvow2p.swift:14:44: error: value of type 'Int'\
    \ has no member 'rawValue'\n        return Err(Int(.init(rawValue: 1)).rawValue)\n\
    \                   ~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmp41mvow2p.swift:14:25:\
    \ error: reference to member 'init' cannot be resolved without a contextual type\n\
    \        return Err(Int(.init(rawValue: 1)).rawValue)\n                      \
    \  ^\n/tmp/tmp41mvow2p.swift:33:12: error: cannot find 'Ok' in scope\n    return\
    \ Ok(result)\n           ^~\n"
  stdout: ''
  timestamp: 1660054240
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(1))\n    }\n    let wordCount\
    \ = words.count\n    let wordCountWithCommas = wordCount + words.count - 1\n \
    \   let wordCountWithCommasWithOddOrder = wordCountWithCommas + words.count -\
    \ 1\n    if wordCountWithCommasWithOddOrder % 2 == 1 {\n        return Err(Int(1))\n\
    \    }\n    return Ok(words.map { $0.trimmingCharacters(in: .whitespacesAndNewlines)\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\"\
    ) == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world\
    \ !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"\
    abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpp2v_jnnw.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpp2v_jnnw.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(1))\n               ^~~\n/tmp/tmpp2v_jnnw.swift:20:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(1))\n            \
    \   ^~~\n/tmp/tmpp2v_jnnw.swift:22:12: error: cannot find 'Ok' in scope\n    return\
    \ Ok(words.map { $0.trimmingCharacters(in: .whitespacesAndNewlines) })\n     \
    \      ^~\n/tmp/tmpp2v_jnnw.swift:22:54: error: cannot infer contextual base in\
    \ reference to member 'whitespacesAndNewlines'\n    return Ok(words.map { $0.trimmingCharacters(in:\
    \ .whitespacesAndNewlines) })\n                                              \
    \      ~^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054240
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(1))\n    }\n    if words.count\
    \ == 1 {\n        return Ok(words)\n    }\n    let firstWord = words[0]\n    let\
    \ firstLetter = firstWord.characters.first!\n    if firstLetter >= 97 && firstLetter\
    \ <= 122 {\n        return Ok(words)\n    }\n    if firstLetter >= 65 && firstLetter\
    \ <= 90 {\n        return Ok(words.dropFirst())\n    }\n    if firstLetter >=\
    \ 97 && firstLetter <= 122 {\n        return Ok(words.dropFirst())\n    }\n  \
    \  return Err(Int(1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmptt76x89d.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmptt76x89d.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(1))\n               ^~~\n/tmp/tmptt76x89d.swift:17:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmptt76x89d.swift:22:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmptt76x89d.swift:25:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words.dropFirst())\n               ^~\n/tmp/tmptt76x89d.swift:28:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words.dropFirst())\n   \
    \            ^~\n/tmp/tmptt76x89d.swift:30:12: error: cannot find 'Err' in scope\n\
    \    return Err(Int(1))\n           ^~~\n"
  stdout: ''
  timestamp: 1660054240
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(0)\n    }\n    if words.count\
    \ == 1 {\n        return Ok(words)\n    }\n    let chars = words.map(String.init)\n\
    \    let count = chars.reduce(0) { (acc, char) -> Int in\n        let c = char.unicodeScalars.first!\n\
    \        if c.isLetterOrDigit() {\n            return acc + Int(c.value)\n   \
    \     } else {\n            return acc + Int(c.value - 'a')\n        }\n    }\n\
    \    if count % 2 == 1 {\n        return Ok(words)\n    } else {\n        return\
    \ Err(count)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpibotsva4.swift:25:40: error: single-quoted string literal found,\
    \ use '\"'\n            return acc + Int(c.value - 'a')\n                    \
    \                   ^~~\n                                       \"a\"\n/tmp/tmpibotsva4.swift:12:21:\
    \ error: value of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmpibotsva4.swift:14:16: error:\
    \ cannot find 'Err' in scope\n        return Err(0)\n               ^~~\n/tmp/tmpibotsva4.swift:17:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpibotsva4.swift:29:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpibotsva4.swift:31:16: error: cannot find\
    \ 'Err' in scope\n        return Err(count)\n               ^~~\n"
  stdout: ''
  timestamp: 1660054240
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    let wordCount = words.count\n    let splitWords = words.map { $0.components(separatedBy:\
    \ \",\").map { $0.lowercased() } }\n    let oddLetters = splitWords.filter { $0.count\
    \ % 2 == 1 }\n    let evenLetters = splitWords.filter { $0.count % 2 == 0 }\n\
    \    \n    if wordCount == 0 {\n        return Err(wordCount)\n    }\n    \n \
    \   if wordCount == 1 {\n        return Ok(splitWords)\n    }\n    \n    if wordCount\
    \ == 2 {\n        return Ok(evenLetters)\n    }\n    \n    if wordCount == 3 {\n\
    \        return Ok(oddLetters)\n    }\n    \n    return Err(wordCount)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpyftm1pob.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpyftm1pob.swift:19:16: error: cannot find 'Err'\
    \ in scope\n        return Err(wordCount)\n               ^~~\n/tmp/tmpyftm1pob.swift:23:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(splitWords)\n          \
    \     ^~\n/tmp/tmpyftm1pob.swift:27:16: error: cannot find 'Ok' in scope\n   \
    \     return Ok(evenLetters)\n               ^~\n/tmp/tmpyftm1pob.swift:31:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(oddLetters)\n          \
    \     ^~\n/tmp/tmpyftm1pob.swift:34:12: error: cannot find 'Err' in scope\n  \
    \  return Err(wordCount)\n           ^~~\n"
  stdout: ''
  timestamp: 1660054240
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    guard words.count > 0 else { return Err(0) }\n    let commaWords = words.filter({\
    \ $0.contains(\",\") })\n    let commaWordsCount = commaWords.count\n    let letterWords\
    \ = words.filter({ $0.contains(\"a...z\") })\n    let letterWordsCount = letterWords.count\n\
    \    let letterWordsCount = letterWords.count\n    let letterWordsCount = letterWords.count\n\
    \    let letterWordsCount = letterWords.count\n    let letterWordsCount = letterWords.count\n\
    \    let letterWordsCount = letterWords.count\n    let letterWordsCount = letterWords.count\n\
    \    let letterWordsCount = letterWords.count\n    let letterWordsCount = letterWords.count\n\
    \    let letterWordsCount = letterWords.count\n    let letterWordsCount = letterWords.count\n\
    \    let letterWordsCount = letterWords.count\n    let letterWordsCount = letterWords.count\n\
    \    let letterWordsCount = letterWords.count\n    let letterWordsCount = letterWords.count\n\
    \    let letterWordsCount = letterWords.count\n    let letterWordsCount = letterWords.count\n\
    \    let letterWordsCount = letterWords.count\n    let letterWordsCount = letterWords.count\n\
    \    let letterWordsCount = letterWords.count\n    let letterWordsCount = letterWords.count\n\
    \    let letterWordsCount = letterWords.count\n    let letterWordsCount = letterWords.count\n\
    \    let letterWordsCount = letterWords.count\n    let letterWordsCount = letterWords.count\n\
    \    let letterWordsCount = letterWords.count\n    let letterWordsCount = letterWords.count\n\
    \    let letterWordsCount = letterWords.count\n    let letterWordsCount = letterWords.count\n\
    \    let letterWordsCount = letterWords.count\n    let letterWordsCount = letterWords.count\n\
    \    let letterWordsCount = letterWords.count\n    let letterWordsCount = letterWords.count\n\
    \    let letterWordsCount = letterWords.count\n    let letterWordsCount = letterWords.count\n\
    \    let letterWordsCount = letterWords.count\n    let letterWordsCount = letterWords.count\n\
    \    let letterWordsCount = letterWords.count\n    let letterWordsCount = letterWords.count\n\
    \    let letterWordsCount = letterWords.count\n    let letterWordsCount = letterWords.count\n\
    \    let letterWordsCount = letterWords.count\n    let letterWordsCount = letterWords.count\n\
    \    let letterWordsCount = letterWords.count\n    let letterWordsCount = \n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp6g_fll4u.swift:61:27: error: expected initial value after '='\n\
    \    let letterWordsCount = \n                          ^\n/tmp/tmp6g_fll4u.swift:12:21:\
    \ error: value of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmp6g_fll4u.swift:13:41: error:\
    \ cannot find 'Err' in scope\n    guard words.count > 0 else { return Err(0) }\n\
    \                                        ^~~\n"
  stdout: ''
  timestamp: 1660054240
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int((txt.characters.count)))\n\
    \    }\n    let wordCount = words.count\n    let charCount = txt.characters.count\n\
    \    if charCount == wordCount {\n        return Ok(words)\n    }\n    if charCount\
    \ > wordCount {\n        return Err(Int((charCount - wordCount)))\n    }\n   \
    \ let chars = Array(txt.characters)\n    let charsCount = chars.count\n    let\
    \ charsArray = Array(chars)\n    let charsArrayCount = charsArray.count\n    let\
    \ charsArraySlice = charsArray[0..<charsArrayCount]\n    let charsArraySliceCount\
    \ = charsArraySlice.count\n    let charsArraySlice2 = charsArray[charsArraySliceCount..<charsArrayCount]\n\
    \    let charsArraySlice2Count = charsArraySlice2.count\n    let charsArraySlice3\
    \ = charsArray[charsArraySlice2Count..<charsArrayCount]\n    let charsArraySlice3Count\
    \ = charsArraySlice3.count\n    let charsArraySlice4 = charsArray[charsArraySlice3Count..<charsArrayCount]\n\
    \    let charsArraySlice4Count = charsArraySlice4.count\n    let charsArraySlice5\
    \ = charsArray[charsArraySlice4Count..<charsArrayCount]\n    let charsArraySlice5Count\
    \ = charsArraySlice5.count\n    let charsArraySlice6 = charsArray[charsArraySlice5Count..<charsArrayCount]\n\
    \    let charsArraySlice6Count = charsArraySlice6.count\n    let charsArraySlice7\
    \ = charsArray[charsArraySlice6Count..<charsArrayCount]\n    let charsArraySlice7Count\
    \ = charsArraySlice7.count\n    let charsArraySlice8 = charsArray[charsArraySlice7Count..<charsArrayCount]\n\
    \    let charsArraySlice8Count = charsArraySlice8.count\n    let charsArraySlice9\
    \ = charsArray[charsArraySlice8Count..<charsArrayCount]\n    let charsArraySlice9Count\
    \ = charsArraySlice9.count\n    let charsArraySlice10 = charsArray[charsArraySlice9Count..<charsArrayCount]\n\
    \    let charsArraySlice10Count = charsArraySlice10.count\n    let charsArraySlice11\
    \ = charsArray[charsArraySlice10Count..<charsArrayCount]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp0l3ufrz1.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp0l3ufrz1.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int((txt.characters.count)))\n               ^~~\n\
    /tmp/tmp0l3ufrz1.swift:17:25: error: 'characters' is unavailable: Please use String\
    \ directly\n    let charCount = txt.characters.count\n                       \
    \ ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp0l3ufrz1.swift:19:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmp0l3ufrz1.swift:22:16: error: cannot find 'Err' in scope\n        return\
    \ Err(Int((charCount - wordCount)))\n               ^~~\n/tmp/tmp0l3ufrz1.swift:24:27:\
    \ error: 'characters' is unavailable: Please use String directly\n    let chars\
    \ = Array(txt.characters)\n                          ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660054240
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    let wordCount = words.count\n    let wordArray = words.map { $0.lowercased()\
    \ }\n    \n    if wordCount == 0 {\n        return Err(wordCount)\n    }\n   \
    \ \n    if wordCount == 1 {\n        return Ok(wordArray)\n    }\n    \n    let\
    \ wordArrayWithCommas = wordArray\n        .map { $0.components(separatedBy: \"\
    ,\") }\n        .flatMap { $0 }\n    \n    if wordArrayWithCommas.count == 0 {\n\
    \        return Ok(wordCount)\n    }\n    \n    let wordArrayWithCommasCount =\
    \ wordArrayWithCommas.count\n    \n    if wordArrayWithCommasCount == 1 {\n  \
    \      return Ok(wordArrayWithCommas)\n    }\n    \n    let wordArrayWithCommasCountOdd\
    \ = wordArrayWithCommasCount\n        .filter { $0 % 2 == 1 }\n        .map {\
    \ $0 / 2 }\n    \n    if wordArrayWithCommasCountOdd.count == 0 {\n        return\
    \ Ok(wordCount)\n    }\n    \n    return Ok(wordArrayWithCommas)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmphbf4cpuf.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmphbf4cpuf.swift:17:16: error: cannot find 'Err'\
    \ in scope\n        return Err(wordCount)\n               ^~~\n/tmp/tmphbf4cpuf.swift:21:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(wordArray)\n           \
    \    ^~\n/tmp/tmphbf4cpuf.swift:29:16: error: cannot find 'Ok' in scope\n    \
    \    return Ok(wordCount)\n               ^~\n/tmp/tmphbf4cpuf.swift:35:16: error:\
    \ cannot find 'Ok' in scope\n        return Ok(wordArrayWithCommas)\n        \
    \       ^~\n/tmp/tmphbf4cpuf.swift:43:16: error: cannot find 'Ok' in scope\n \
    \       return Ok(wordCount)\n               ^~\n/tmp/tmphbf4cpuf.swift:46:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(wordArrayWithCommas)\n     \
    \      ^~\n"
  stdout: ''
  timestamp: 1660054240
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    let wordCount = words.count\n    \n    if wordCount == 0 {\n        return\
    \ Err(0)\n    }\n    \n    if wordCount == 1 {\n        return Ok(words)\n   \
    \ }\n    \n    if wordCount == 2 {\n        return Ok(words)\n    }\n    \n  \
    \  if wordCount == 3 {\n        return Ok(words)\n    }\n    \n    if wordCount\
    \ == 4 {\n        return Ok(words)\n    }\n    \n    if wordCount == 5 {\n   \
    \     return Ok(words)\n    }\n    \n    if wordCount == 6 {\n        return Ok(words)\n\
    \    }\n    \n    if wordCount == 7 {\n        return Ok(words)\n    }\n    \n\
    \    if wordCount == 8 {\n        return Ok(words)\n    }\n    \n    if wordCount\
    \ == 9 {\n        return Ok(words)\n    }\n    \n    if wordCount == 10 {\n  \
    \      return Ok(words)\n    }\n    \n    if wordCount == 11 {\n        return\
    \ Ok(words)\n    }\n    \n    if wordCount == 12 {\n        return Ok(words)\n\
    \    }\n    \n    if wordCount == 13 {\n        return Ok(words)\n    }\n    \n\
    \    if wordCount == 14 {\n        return Ok(words)\n    }\n    \n    if wordCount\
    \ == 15 {\n        return Ok(words)\n    }\n    \n    if wordCount == 16 {\n \
    \       return Ok(words)\n    }\n    \n    if wordCount == 17 {\n        return\
    \ Ok(words)\n    }\n    \n    if wordCount == 18 {\n        return Ok(words)\n\
    \    }\n    \n    if wordCount == 19 {\n        return Ok(words)\n    }\n    \n\
    \    if wordCount == 20 {\n        return Ok(words)\n    }\n    \n    if wordCount\
    \ == 21 {\n        return Ok(words)\n    }\n    \n    if wordCount == 22 {\n \
    \       return Ok(words)\n    }\n    \n    if wordCount == 23 {\n        return\
    \ Ok(words)\n    }\n    \n    if wordCount == 24 {\n        return Ok(words)\n\
    \    }\n    \n    if wordCount == 25 {\n        return Ok(words)\n    }\n    \n\
    \    if wordCount == 26 {\n        return Ok(words)\n    }\n    \n    if wordCount\
    \ == 27 {\n        return Ok(words)\n    }\n    \n    if wordCount == 28 {\n \
    \       return Ok(words)\n    }\n    \n    if wordCount == 29 {\n        return\
    \ Ok(words)\n    }\n    \n    if wordCount == 30 {\n        return Ok(words)\n\
    \    }\n    \n    if word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp1wq81diy.swift:139:12: error: expected '{' after 'if' condition\n\
    \    if word\n           ^\n/tmp/tmp1wq81diy.swift:12:21: error: value of type\
    \ 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmp1wq81diy.swift:16:16: error:\
    \ cannot find 'Err' in scope\n        return Err(0)\n               ^~~\n/tmp/tmp1wq81diy.swift:20:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmp1wq81diy.swift:24:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmp1wq81diy.swift:28:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmp1wq81diy.swift:32:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmp1wq81diy.swift:36:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmp1wq81diy.swift:40:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmp1wq81diy.swift:44:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmp1wq81diy.swift:48:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmp1wq81diy.swift:52:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmp1wq81diy.swift:56:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmp1wq81diy.swift:60:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmp1wq81diy.swift:64:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmp1wq81diy.swift:68:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmp1wq81diy.swift:72:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmp1wq81diy.swift:76:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmp1wq81diy.swift:80:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n "
  stdout: ''
  timestamp: 1660054240
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    let commaWords = txt.components(separatedBy: \",\")\n    \n    if words.count\
    \ == 0 {\n        return Err(Int(1))\n    }\n    \n    if commaWords.count ==\
    \ 0 {\n        return Ok(words)\n    }\n    \n    return Ok(words.count + commaWords.count)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpu41z944v.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpu41z944v.swift:13:26: error: value of type 'String'\
    \ has no member 'components'\n    let commaWords = txt.components(separatedBy:\
    \ \",\")\n                     ~~~ ^~~~~~~~~~\n/tmp/tmpu41z944v.swift:16:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(1))\n               ^~~\n\
    /tmp/tmpu41z944v.swift:20:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpu41z944v.swift:23:12: error: cannot find\
    \ 'Ok' in scope\n    return Ok(words.count + commaWords.count)\n           ^~\n"
  stdout: ''
  timestamp: 1660054240
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    guard !words.isEmpty else { return Err(0) }\n    guard !words.contains(\"\
    ,\") else { return Err(0) }\n    guard !words.contains(\".\") else { return Err(0)\
    \ }\n    guard !words.contains(\"!\") else { return Err(0) }\n    guard !words.contains(\"\
    ?\") else { return Err(0) }\n    guard !words.contains(\":\") else { return Err(0)\
    \ }\n    guard !words.contains(\";\") else { return Err(0) }\n    guard !words.contains(\"\
    :\") else { return Err(0) }\n    guard !words.contains(\",\") else { return Err(0)\
    \ }\n    guard !words.contains(\".\") else { return Err(0) }\n    guard !words.contains(\"\
    !\") else { return Err(0) }\n    guard !words.contains(\"?\") else { return Err(0)\
    \ }\n    guard !words.contains(\":\") else { return Err(0) }\n    guard !words.contains(\"\
    ;\") else { return Err(0) }\n    guard !words.contains(\":\") else { return Err(0)\
    \ }\n    guard !words.contains(\",\") else { return Err(0) }\n    guard !words.contains(\"\
    .\") else { return Err(0) }\n    guard !words.contains(\"!\") else { return Err(0)\
    \ }\n    guard !words.contains(\"?\") else { return Err(0) }\n    guard !words.contains(\"\
    :\") else { return Err(0) }\n    guard !words.contains(\";\") else { return Err(0)\
    \ }\n    guard !words.contains(\":\") else { return Err(0) }\n    guard !words.contains(\"\
    ,\") else { return Err(0) }\n    guard !words.contains(\".\") else { return Err(0)\
    \ }\n    guard !words.contains(\"!\") else { return Err(0) }\n    guard !words.contains(\"\
    ?\") else { return Err(0) }\n    guard !words.contains(\":\") else { return Err(0)\
    \ }\n    guard !words.contains(\";\") else { return Err(0) }\n    guard !words.contains(\"\
    :\") else { return Err(0) }\n    guard !words.contains(\",\") else { return Err(0)\
    \ }\n    guard !words.contains(\".\") else { return Err(0) }\n    guard !words.contain\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpth3de4ph.swift:44:25: error: expected 'else' after 'guard' condition\n\
    \    guard !words.contain\n                        ^\n/tmp/tmpth3de4ph.swift:12:21:\
    \ error: value of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmpth3de4ph.swift:13:40: error:\
    \ cannot find 'Err' in scope\n    guard !words.isEmpty else { return Err(0) }\n\
    \                                       ^~~\n/tmp/tmpth3de4ph.swift:14:46: error:\
    \ cannot find 'Err' in scope\n    guard !words.contains(\",\") else { return Err(0)\
    \ }\n                                             ^~~\n/tmp/tmpth3de4ph.swift:15:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\".\") else { return\
    \ Err(0) }\n                                             ^~~\n/tmp/tmpth3de4ph.swift:16:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\"!\") else { return\
    \ Err(0) }\n                                             ^~~\n/tmp/tmpth3de4ph.swift:17:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\"?\") else { return\
    \ Err(0) }\n                                             ^~~\n/tmp/tmpth3de4ph.swift:18:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\":\") else { return\
    \ Err(0) }\n                                             ^~~\n/tmp/tmpth3de4ph.swift:19:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\";\") else { return\
    \ Err(0) }\n                                             ^~~\n/tmp/tmpth3de4ph.swift:20:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\":\") else { return\
    \ Err(0) }\n                                             ^~~\n/tmp/tmpth3de4ph.swift:21:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\",\") else { return\
    \ Err(0) }\n                                             ^~~\n/tmp/tmpth3de4ph.swift:22:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\".\") else { return\
    \ Err(0) }\n                                             ^~~\n/tmp/tmpth3de4ph.swift:23:46:\
    \ error: cannot find 'Err' in scope\n    guard !words.contains(\"!\") "
  stdout: ''
  timestamp: 1660054240
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(0)\n    }\n    \n    let wordCount\
    \ = words.count\n    let wordCountWithCommas = wordCount + words.count - 1\n \
    \   let wordCountWithCommasWithOddOrder = wordCountWithCommas + words.count -\
    \ 1\n    let wordCountWithCommasWithOddOrderWithOddLetter = wordCountWithCommasWithOddOrder\
    \ + words.count - 1\n    \n    if wordCountWithCommasWithOddOrderWithOddLetter\
    \ == 0 {\n        return Ok(words)\n    }\n    \n    return Err(wordCountWithCommasWithOddOrderWithOddLetter)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmptqmu5uqw.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmptqmu5uqw.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(0)\n               ^~~\n/tmp/tmptqmu5uqw.swift:23:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmptqmu5uqw.swift:26:12: error: cannot find 'Err' in scope\n    return Err(wordCountWithCommasWithOddOrderWithOddLetter)\n\
    \           ^~~\n"
  stdout: ''
  timestamp: 1660054240
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    guard words.count > 0 else { return Err(0) }\n    let result = words.map\
    \ { $0.components(separatedBy: \",\").map { $0.lowercased() } }\n    let count\
    \ = result.count\n    if count % 2 == 1 {\n        return Ok(result)\n    } else\
    \ {\n        return Err(count)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpc6jab53f.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpc6jab53f.swift:13:41: error: cannot find 'Err'\
    \ in scope\n    guard words.count > 0 else { return Err(0) }\n               \
    \                         ^~~\n/tmp/tmpc6jab53f.swift:17:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(result)\n               ^~\n/tmp/tmpc6jab53f.swift:19:16:\
    \ error: cannot find 'Err' in scope\n        return Err(count)\n             \
    \  ^~~\n"
  stdout: ''
  timestamp: 1660054240
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(1))\n    }\n    if words.count\
    \ == 1 {\n        return Ok(words)\n    }\n    let chars = words.map(String.init)\n\
    \    let count = chars.reduce(0) { (acc, c) in\n        if let c = c.lowercased()\
    \ {\n            acc += Int(c)\n        }\n        return acc\n    }\n    if count\
    \ % 2 != 0 {\n        return Err(Int(count))\n    }\n    return Ok(chars.map(String.init))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpd7t20ygv.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpd7t20ygv.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(1))\n               ^~~\n/tmp/tmpd7t20ygv.swift:17:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpd7t20ygv.swift:27:16: error: cannot find 'Err' in scope\n        return\
    \ Err(Int(count))\n               ^~~\n/tmp/tmpd7t20ygv.swift:29:12: error: cannot\
    \ find 'Ok' in scope\n    return Ok(chars.map(String.init))\n           ^~\n"
  stdout: ''
  timestamp: 1660054240
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int((txt.characters.count / 26)\
    \ + 1))\n    }\n    if words.count == 1 {\n        return Ok(words)\n    }\n \
    \   let letters = words.map({ $0.lowercased() })\n    let odd = letters.filter({\
    \ $0.count % 2 == 1 })\n    let even = letters.filter({ $0.count % 2 == 0 })\n\
    \    return Ok([even, odd])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmppb33w_pe.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmppb33w_pe.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int((txt.characters.count / 26) + 1))\n       \
    \        ^~~\n/tmp/tmppb33w_pe.swift:17:16: error: cannot find 'Ok' in scope\n\
    \        return Ok(words)\n               ^~\n/tmp/tmppb33w_pe.swift:22:12: error:\
    \ cannot find 'Ok' in scope\n    return Ok([even, odd])\n           ^~\n"
  stdout: ''
  timestamp: 1660054240
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count > 0 {\n        return Ok(words)\n    }\n    if let comma\
    \ = txt.components(separatedBy: \",\") {\n        return Ok(comma)\n    }\n  \
    \  if let lowercase = txt.lowercased() {\n        return Ok(lowercase)\n    }\n\
    \    return Err(Int(bitPattern: 0))\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpt09ovxak.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpt09ovxak.swift:14:16: error: cannot find 'Ok'\
    \ in scope\n        return Ok(words)\n               ^~\n/tmp/tmpt09ovxak.swift:16:24:\
    \ error: value of type 'String' has no member 'components'\n    if let comma =\
    \ txt.components(separatedBy: \",\") {\n                   ~~~ ^~~~~~~~~~\n/tmp/tmpt09ovxak.swift:17:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(comma)\n               ^~\n\
    /tmp/tmpt09ovxak.swift:20:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(lowercase)\n               ^~\n/tmp/tmpt09ovxak.swift:19:8: error: initializer\
    \ for conditional binding must have Optional type, not 'String'\n    if let lowercase\
    \ = txt.lowercased() {\n       ^               ~~~~~~~~~~~~~~~~\n/tmp/tmpt09ovxak.swift:22:12:\
    \ error: cannot find 'Err' in scope\n    return Err(Int(bitPattern: 0))\n    \
    \       ^~~\n"
  stdout: ''
  timestamp: 1660054240
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.components(separatedBy:\
    \ \" \") else {\n        return Err(Int(errorCode: ErrorCode.invalidArgument.rawValue,\
    \ message: \"Invalid argument\"))\n    }\n    \n    var result: [String] = []\n\
    \    \n    for word in words {\n        guard let letters = word.components(separatedBy:\
    \ \",\") else {\n            return Err(Int(errorCode: ErrorCode.invalidArgument.rawValue,\
    \ message: \"Invalid argument\"))\n        }\n        \n        for letter in\
    \ letters {\n            guard let letter = letter.lowercased(), letter != letter\
    \ else {\n                return Err(Int(errorCode: ErrorCode.invalidArgument.rawValue,\
    \ message: \"Invalid argument\"))\n            }\n            \n            if\
    \ letter != letter {\n                result.append(letter)\n            }\n \
    \       }\n    }\n    \n    return Ok(result)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp3gozcypd.swift:12:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmp3gozcypd.swift:13:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(errorCode: ErrorCode.invalidArgument.rawValue,\
    \ message: \"Invalid argument\"))\n               ^~~\n/tmp/tmp3gozcypd.swift:13:35:\
    \ error: cannot find 'ErrorCode' in scope\n        return Err(Int(errorCode: ErrorCode.invalidArgument.rawValue,\
    \ message: \"Invalid argument\"))\n                                  ^~~~~~~~~\n\
    /tmp/tmp3gozcypd.swift:13:80: error: extra argument 'message' in call\n      \
    \  return Err(Int(errorCode: ErrorCode.invalidArgument.rawValue, message: \"Invalid\
    \ argument\"))\n                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp3gozcypd.swift:34:12: error: cannot find 'Ok' in scope\n    return Ok(result)\n\
    \           ^~\n"
  stdout: ''
  timestamp: 1660054240
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.components(separatedBy:\
    \ \" \") else {\n        return Err(Int(rawValue: 1))\n    }\n    \n    var result:\
    \ [String] = []\n    \n    for word in words {\n        if let word = word.lowercased()\
    \ {\n            result.append(word)\n        }\n    }\n    \n    return Ok(result)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpwqs3ap0f.swift:12:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmpwqs3ap0f.swift:13:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(rawValue: 1))\n         \
    \      ^~~\n/tmp/tmpwqs3ap0f.swift:13:23: error: extraneous argument label 'rawValue:'\
    \ in call\n        return Err(Int(rawValue: 1))\n                      ^~~~~~~~~~~\n\
    \                       \n/tmp/tmpwqs3ap0f.swift:24:12: error: cannot find 'Ok'\
    \ in scope\n    return Ok(result)\n           ^~\n"
  stdout: ''
  timestamp: 1660054240
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    \n    if words.count == 0 {\n        return Err(Int(1))\n    }\n    \n\
    \    let wordCount = words.count\n    \n    if wordCount == 1 {\n        return\
    \ Ok(words)\n    }\n    \n    if wordCount == 2 {\n        return Ok(words)\n\
    \    }\n    \n    if wordCount == 3 {\n        return Ok(words)\n    }\n    \n\
    \    if wordCount == 4 {\n        return Ok(words)\n    }\n    \n    if wordCount\
    \ == 5 {\n        return Ok(words)\n    }\n    \n    if wordCount == 6 {\n   \
    \     return Ok(words)\n    }\n    \n    if wordCount == 7 {\n        return Ok(words)\n\
    \    }\n    \n    if wordCount == 8 {\n        return Ok(words)\n    }\n    \n\
    \    if wordCount == 9 {\n        return Ok(words)\n    }\n    \n    if wordCount\
    \ == 10 {\n        return Ok(words)\n    }\n    \n    if wordCount == 11 {\n \
    \       return Ok(words)\n    }\n    \n    if wordCount == 12 {\n        return\
    \ Ok(words)\n    }\n    \n    if wordCount == 13 {\n        return Ok(words)\n\
    \    }\n    \n    if wordCount == 14 {\n        return Ok(words)\n    }\n    \n\
    \    if wordCount == 15 {\n        return Ok(words)\n    }\n    \n    if wordCount\
    \ == 16 {\n        return Ok(words)\n    }\n    \n    if wordCount == 17 {\n \
    \       return Ok(words)\n    }\n    \n    if wordCount == 18 {\n        return\
    \ Ok(words)\n    }\n    \n    if wordCount == 19 {\n        return Ok(words)\n\
    \    }\n    \n    if wordCount == 20 {\n        return Ok(words)\n    }\n    \n\
    \    if wordCount == 21 {\n        return Ok(words)\n    }\n    \n    if wordCount\
    \ == 22 {\n        return Ok(words)\n    }\n    \n    if wordCount == 23 {\n \
    \       return Ok(words)\n    }\n    \n    if wordCount == 24 {\n        return\
    \ Ok(words)\n    }\n    \n    if wordCount == 25 {\n        return Ok(words)\n\
    \    }\n    \n    return Err(Int(1))\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpem315iim.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpem315iim.swift:15:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(1))\n               ^~~\n/tmp/tmpem315iim.swift:21:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpem315iim.swift:25:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpem315iim.swift:29:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpem315iim.swift:33:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpem315iim.swift:37:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpem315iim.swift:41:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpem315iim.swift:45:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpem315iim.swift:49:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpem315iim.swift:53:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpem315iim.swift:57:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpem315iim.swift:61:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpem315iim.swift:65:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpem315iim.swift:69:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpem315iim.swift:73:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpem315iim.swift:77:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpem315iim.swift:81:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpem315iim.swift:85:16: error: cannot find 'Ok' in scope\n        retu"
  stdout: ''
  timestamp: 1660054240
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let txt = txt.trimmingCharacters(in: .whitespacesAndNewlines)\
    \ else {\n        return Err(Int(.errUnknown))\n    }\n    \n    var words: [String]\
    \ = []\n    var count = 0\n    for c in txt {\n        if c == ',' {\n       \
    \     words.append(String(count))\n            count = 0\n        } else {\n \
    \           count += 1\n        }\n    }\n    \n    if count > 0 {\n        words.append(String(count))\n\
    \    }\n    \n    return Ok(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpb8uhylza.swift:19:17: error: single-quoted string literal found,\
    \ use '\"'\n        if c == ',' {\n                ^~~\n                \",\"\n\
    /tmp/tmpb8uhylza.swift:12:25: error: value of type 'String' has no member 'trimmingCharacters'\n\
    \    guard let txt = txt.trimmingCharacters(in: .whitespacesAndNewlines) else\
    \ {\n                    ~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpb8uhylza.swift:12:49:\
    \ error: cannot infer contextual base in reference to member 'whitespacesAndNewlines'\n\
    \    guard let txt = txt.trimmingCharacters(in: .whitespacesAndNewlines) else\
    \ {\n                                               ~^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpb8uhylza.swift:13:16: error: cannot find 'Err' in scope\n        return\
    \ Err(Int(.errUnknown))\n               ^~~\n/tmp/tmpb8uhylza.swift:13:24: error:\
    \ missing argument label 'bitPattern:' in call\n        return Err(Int(.errUnknown))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmpb8uhylza.swift:31:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words)\n           ^~\n"
  stdout: ''
  timestamp: 1660054240
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(1))\n    }\n    if words.count\
    \ == 1 {\n        return Ok(words)\n    }\n    let wordCount = words.count\n \
    \   let letterCount = txt.unicodeScalars.filter({ $0.isUppercase }).count\n  \
    \  if letterCount % 2 == 1 {\n        return Err(Int(letterCount))\n    }\n  \
    \  return Ok(words.map { $0.trimmingCharacters(in: .whitespacesAndNewlines) })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpmr0fbmns.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpmr0fbmns.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(1))\n               ^~~\n/tmp/tmpmr0fbmns.swift:17:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpmr0fbmns.swift:20:54: error: value of type 'Unicode.Scalar' has no member\
    \ 'isUppercase'\n    let letterCount = txt.unicodeScalars.filter({ $0.isUppercase\
    \ }).count\n                                                  ~~ ^~~~~~~~~~~\n\
    /tmp/tmpmr0fbmns.swift:22:16: error: cannot find 'Err' in scope\n        return\
    \ Err(Int(letterCount))\n               ^~~\n/tmp/tmpmr0fbmns.swift:24:12: error:\
    \ cannot find 'Ok' in scope\n    return Ok(words.map { $0.trimmingCharacters(in:\
    \ .whitespacesAndNewlines) })\n           ^~\n/tmp/tmpmr0fbmns.swift:24:54: error:\
    \ cannot infer contextual base in reference to member 'whitespacesAndNewlines'\n\
    \    return Ok(words.map { $0.trimmingCharacters(in: .whitespacesAndNewlines)\
    \ })\n                                                    ~^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054240
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(0)\n    }\n    let wordCount\
    \ = words.count\n    let wordCountWithCommas = wordCount + words.count - 1\n \
    \   let wordCountWithCommasWithOddOrder = wordCountWithCommas + wordCountWithCommas\
    \ - 1\n    let wordCountWithCommasWithOddOrderWithOddOrder = wordCountWithCommasWithOddOrder\
    \ + wordCountWithCommasWithOddOrder - 1\n    if wordCountWithCommasWithOddOrderWithOddOrder\
    \ == 0 {\n        return Ok(words)\n    }\n    if wordCountWithCommasWithOddOrderWithOddOrder\
    \ == 1 {\n        return Ok(words.map { $0.lowercased() })\n    }\n    if wordCountWithCommasWithOddOrderWithOddOrder\
    \ == 2 {\n        return Ok(words.map { $0.lowercased() })\n    }\n    if wordCountWithCommasWithOddOrderWithOddOrder\
    \ == 3 {\n        return Ok(words.map { $0.lowercased() })\n    }\n    if wordCountWithCommasWithOddOrderWithOddOrder\
    \ == 4 {\n        return Ok(words.map { $0.lowercased() })\n    }\n    if wordCountWithCommasWithOddOrderWithOddOrder\
    \ == 5 {\n        return Ok(words.map { $0.lowercased() })\n    }\n    if wordCountWithCommasWithOddOrderWithOddOrder\
    \ == 6 {\n        return Ok(words.map { $0.lowercased() })\n    }\n    if wordCountWithCommasWithOddOrderWithOddOrder\
    \ == 7 {\n        return Ok(words.map { $0.lowercased() })\n    }\n    if wordCountWithCommasWithOddOrderWithOddOrder\
    \ == 8 {\n        return Ok(words.map { $0.lowercased() })\n    }\n    if wordCountWithCommasWithOddOrderWithOddOrder\
    \ == 9 {\n        return Ok(words.map { $0.lowercased() })\n    }\n    if wordCountWithCommasWithOddOrderWithOddOrder\
    \ == 10 {\n        return Ok(words.map { $0.lowercased() })\n    }\n    if wordCountWithCommasWithOddOrderWithOddOrder\
    \ == 11 {\n        return Ok(words.map { $0.lowercased() })\n    }\n    if wordCountWithCommasWithOddOrderWithOddOrder\
    \ == 12 {\n        return Ok(words.map { $0.lowercased() })\n    }\n    if wordCountWithComm\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpz1cgs2u7.swift:59:25: error: expected '{' after 'if' condition\n\
    \    if wordCountWithComm\n                        ^\n/tmp/tmpz1cgs2u7.swift:12:21:\
    \ error: value of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmpz1cgs2u7.swift:14:16: error:\
    \ cannot find 'Err' in scope\n        return Err(0)\n               ^~~\n/tmp/tmpz1cgs2u7.swift:18:63:\
    \ error: cannot convert value of type 'String' to expected argument type 'Int'\n\
    \    let wordCountWithCommasWithOddOrder = wordCountWithCommas + wordCountWithCommas\
    \ - 1\n                                                              ^\n/tmp/tmpz1cgs2u7.swift:19:87:\
    \ error: cannot convert value of type 'String' to expected argument type 'Int'\n\
    \    let wordCountWithCommasWithOddOrderWithOddOrder = wordCountWithCommasWithOddOrder\
    \ + wordCountWithCommasWithOddOrder - 1\n                                    \
    \                                                  ^\n/tmp/tmpz1cgs2u7.swift:21:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpz1cgs2u7.swift:24:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words.map { $0.lowercased() })\n               ^~\n/tmp/tmpz1cgs2u7.swift:27:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words.map { $0.lowercased()\
    \ })\n               ^~\n/tmp/tmpz1cgs2u7.swift:30:16: error: cannot find 'Ok'\
    \ in scope\n        return Ok(words.map { $0.lowercased() })\n               ^~\n\
    /tmp/tmpz1cgs2u7.swift:33:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words.map { $0.lowercased() })\n               ^~\n/tmp/tmpz1cgs2u7.swift:36:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words.map { $0.lowercased()\
    \ })\n               ^~\n/tmp/tmpz1cgs2u7.swift:39:16: error: cannot find 'Ok'\
    \ in scope\n        return Ok(words.map { $0.lowercased() })\n               ^~\n\
    /tmp/tmpz1cgs2u7.swift:42:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words.map { $0.lowercased() })\n               ^~\n/tmp/tmpz1cgs2u7.swift:45:16:\
    \ error: cannot find 'Ok' in sco"
  stdout: ''
  timestamp: 1660054240
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.components(separatedBy:\
    \ \" \") else {\n        return Err(Int(rawValue: 1))\n    }\n    \n    var result:\
    \ [String] = []\n    \n    for word in words {\n        guard let letters = word.components(separatedBy:\
    \ \",\") else {\n            return Err(Int(rawValue: 2))\n        }\n       \
    \ \n        for letter in letters {\n            if let count = letters.filter({\
    \ $0.isLetter }).count {\n                if count % 2 == 1 {\n              \
    \      result.append(letter)\n                }\n            }\n        }\n  \
    \  }\n    \n    return Ok(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpnx1i76le.swift:12:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmpnx1i76le.swift:13:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(rawValue: 1))\n         \
    \      ^~~\n/tmp/tmpnx1i76le.swift:13:23: error: extraneous argument label 'rawValue:'\
    \ in call\n        return Err(Int(rawValue: 1))\n                      ^~~~~~~~~~~\n\
    \                       \n/tmp/tmpnx1i76le.swift:32:12: error: cannot find 'Ok'\
    \ in scope\n    return Ok(result)\n           ^~\n"
  stdout: ''
  timestamp: 1660054240
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(1))\n    }\n    if words.count\
    \ == 1 {\n        return Ok(words)\n    }\n    let firstWord = words[0]\n    let\
    \ firstLetter = firstWord.characters.first!\n    if firstLetter >= 97 && firstLetter\
    \ <= 122 {\n        return Ok(words)\n    }\n    if firstLetter >= 65 && firstLetter\
    \ <= 90 {\n        return Ok(words.dropFirst())\n    }\n    return Err(Int(1))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp5c8d147f.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp5c8d147f.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(1))\n               ^~~\n/tmp/tmp5c8d147f.swift:17:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmp5c8d147f.swift:22:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmp5c8d147f.swift:25:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words.dropFirst())\n               ^~\n/tmp/tmp5c8d147f.swift:27:12:\
    \ error: cannot find 'Err' in scope\n    return Err(Int(1))\n           ^~~\n"
  stdout: ''
  timestamp: 1660054240
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(.zero))\n    }\n    if words.count\
    \ == 1 {\n        return Ok(words)\n    }\n    let wordCount = words.count\n \
    \   let letterCount = words.reduce(0) { (result, word) -> Int in\n        let\
    \ count = word.characters.count\n        return count + result\n    }\n    if\
    \ letterCount % 2 == 1 {\n        return Ok(words)\n    }\n    return Err(Int(.zero))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpdbhbyut1.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpdbhbyut1.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(.zero))\n               ^~~\n/tmp/tmpdbhbyut1.swift:17:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpdbhbyut1.swift:22:22: error: cannot convert return expression of type\
    \ 'String' to return type 'Int'\n        return count + result\n             \
    \  ~~~~~~^~~~~~~~\n/tmp/tmpdbhbyut1.swift:25:16: error: cannot find 'Ok' in scope\n\
    \        return Ok(words)\n               ^~\n/tmp/tmpdbhbyut1.swift:27:12: error:\
    \ cannot find 'Err' in scope\n    return Err(Int(.zero))\n           ^~~\n"
  stdout: ''
  timestamp: 1660054241
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(0))\n    }\n    if words.count\
    \ == 1 {\n        return Ok([words[0]])\n    }\n    let wordCount = words.count\n\
    \    let letterCount = words.reduce(0) { (result, word) -> Int in\n        let\
    \ letters = word.components(separatedBy: \",\")\n        return result + letters.count\n\
    \    }\n    if letterCount % 2 == 1 {\n        return Ok([words[0], words[wordCount\
    \ - 1]])\n    }\n    return Ok([words[0], words[wordCount - 1], letterCount /\
    \ 2])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello\
    \ world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"\
    Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp_tql692f.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp_tql692f.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(0))\n               ^~~\n/tmp/tmp_tql692f.swift:17:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok([words[0]])\n          \
    \     ^~\n/tmp/tmp_tql692f.swift:25:16: error: cannot find 'Ok' in scope\n   \
    \     return Ok([words[0], words[wordCount - 1]])\n               ^~\n/tmp/tmp_tql692f.swift:27:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok([words[0], words[wordCount -\
    \ 1], letterCount / 2])\n           ^~\n"
  stdout: ''
  timestamp: 1660054241
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(0)\n    }\n    if words.count\
    \ == 1 {\n        return Err(1)\n    }\n    if words.count == 2 {\n        return\
    \ Err(words.count)\n    }\n    let letters = words.map { $0.lowercased() }\n \
    \   let odd = letters.filter { $0.count % 2 == 1 }\n    if odd.count == 0 {\n\
    \        return Ok(words)\n    }\n    return Err(odd.count)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp8c6fjhud.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp8c6fjhud.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(0)\n               ^~~\n/tmp/tmp8c6fjhud.swift:17:16:\
    \ error: cannot find 'Err' in scope\n        return Err(1)\n               ^~~\n\
    /tmp/tmp8c6fjhud.swift:20:16: error: cannot find 'Err' in scope\n        return\
    \ Err(words.count)\n               ^~~\n/tmp/tmp8c6fjhud.swift:25:16: error: cannot\
    \ find 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmp8c6fjhud.swift:27:12:\
    \ error: cannot find 'Err' in scope\n    return Err(odd.count)\n           ^~~\n"
  stdout: ''
  timestamp: 1660054241
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(1))\n    }\n    if words.count\
    \ == 1 {\n        return Ok(words)\n    }\n    let comma = words.last\n    let\
    \ letters = txt.lowercased().characters.filter({ $0 != comma }).count\n    return\
    \ Ok([words[0], words[1..<words.count-1], letters])\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmphw6iuhn0.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmphw6iuhn0.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(1))\n               ^~~\n/tmp/tmphw6iuhn0.swift:17:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmphw6iuhn0.swift:21:12: error: cannot find 'Ok' in scope\n    return Ok([words[0],\
    \ words[1..<words.count-1], letters])\n           ^~\n"
  stdout: ''
  timestamp: 1660054241
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    \n    let words = txt.components(separatedBy:\
    \ \" \")\n    \n    if words.count == 0 {\n        return Err(Int((txt.characters.count\
    \ / 2) - 1))\n    }\n    \n    if words.count == 1 {\n        return Ok(words)\n\
    \    }\n    \n    let lastWord = words[words.count - 1]\n    \n    if lastWord.characters.count\
    \ == 0 {\n        return Ok(words)\n    }\n    \n    if lastWord.characters.count\
    \ == 1 {\n        return Ok(words)\n    }\n    \n    if lastWord.characters.count\
    \ % 2 == 1 {\n        return Ok(words)\n    }\n    \n    if lastWord.characters.count\
    \ < 26 {\n        return Ok(words)\n    }\n    \n    if lastWord.characters.count\
    \ < 26 {\n        return Ok(words)\n    }\n    \n    if lastWord.characters.count\
    \ < 26 {\n        return Ok(words)\n    }\n    \n    if lastWord.characters.count\
    \ < 26 {\n        return Ok(words)\n    }\n    \n    if lastWord.characters.count\
    \ < 26 {\n        return Ok(words)\n    }\n    \n    if lastWord.characters.count\
    \ < 26 {\n        return Ok(words)\n    }\n    \n    if lastWord.characters.count\
    \ < 26 {\n        return Ok(words)\n    }\n    \n    if lastWord.characters.count\
    \ < 26 {\n        return Ok(words)\n    }\n    \n    if lastWord.characters.count\
    \ < 26 {\n        return Ok(words)\n    }\n    \n    if lastWord.characters.count\
    \ < 26 {\n        return Ok(words)\n    }\n    \n    if lastWord.characters.count\
    \ < 26 {\n        return Ok(words)\n    }\n    \n    if lastWord.characters.count\
    \ < 26 {\n        return Ok(words)\n    }\n    \n    if lastWord.characters.count\
    \ < 26 {\n        return Ok(words)\n    }\n    \n    if lastWord.characters.count\
    \ < 26 {\n        return Ok(words)\n    }\n    \n    if lastWord.characters.count\
    \ < 26 {\n        return Ok(words)\n    }\n    \n    if lastWord.characters.count\
    \ < 26 {\n        return Ok(words)\n    }\n    \n    if lastWord.characters.count\
    \ < 26 {\n        return Ok(words)\n    }\n    \n    if lastWord.characters.count\
    \ < 26 {\n        return Ok(words)\n    }\n    \n    if lastWord.characters.count\
    \ < 26 {\n        return Ok(words)\n    }\n    \n    if lastWord.characters.count\
    \ < 26 {\n        return Ok(words)\n    }\n    \n    if lastWord.characters.count\
    \ < 26 {\n        return Ok(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpyrwzw7xl.swift:141:44: error: expected '}' at end of brace statement\n\
    assert(split_words(txt: \"\") == .failure(0))\n                              \
    \             ^\n/tmp/tmpyrwzw7xl.swift:11:56: note: to match this opening '{'\n\
    func split_words(txt: String) -> Result<[String], Int> {\n                   \
    \                                    ^\n/tmp/tmpyrwzw7xl.swift:13:21: error: value\
    \ of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmpyrwzw7xl.swift:16:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int((txt.characters.count / 2)\
    \ - 1))\n               ^~~\n/tmp/tmpyrwzw7xl.swift:20:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpyrwzw7xl.swift:26:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpyrwzw7xl.swift:30:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpyrwzw7xl.swift:34:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpyrwzw7xl.swift:38:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpyrwzw7xl.swift:42:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpyrwzw7xl.swift:46:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpyrwzw7xl.swift:50:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpyrwzw7xl.swift:54:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpyrwzw7xl.swift:58:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpyrwzw7xl.swift:62:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpyrwzw7xl.swift:66:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words)\n               ^~\n/tmp/tmpyrwzw7xl.swift:70:16: error: cannot find\
    \ 'Ok' in scope\n        return Ok(words)\n               ^~\n/tmp/tmpyrwzw7xl.swift"
  stdout: ''
  timestamp: 1660054241
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(.zero))\n    }\n    if words.count\
    \ == 1 {\n        return Ok([words[0]])\n    }\n    let words = words.dropFirst()\n\
    \    let letters = words.map({ $0.lowercased() })\n    let odd = letters.filter\
    \ { $0 % 2 == 1 }\n    let even = letters.filter { $0 % 2 == 0 }\n    return Ok([even,\
    \ odd])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello\
    \ world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"\
    Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp2_dx_jq3.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp2_dx_jq3.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(.zero))\n               ^~~\n/tmp/tmp2_dx_jq3.swift:17:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok([words[0]])\n          \
    \     ^~\n/tmp/tmp2_dx_jq3.swift:23:12: error: cannot find 'Ok' in scope\n   \
    \ return Ok([even, odd])\n           ^~\n"
  stdout: ''
  timestamp: 1660054241
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(0)\n    }\n    if words.count\
    \ == 1 {\n        return Ok(words)\n    }\n    let comma = words.last.components(separatedBy:\
    \ \",\")\n    if comma.count == 0 {\n        return Ok(words.dropLast())\n   \
    \ }\n    if comma.count == 1 {\n        return Ok(words.dropLast())\n    }\n \
    \   let letters = words.dropLast()\n    let letterCount = letters.reduce(0) {\
    \ (acc, word) -> Int in\n        let letter = word.components(separatedBy: \"\"\
    ).last\n        guard let letter = letter else { return acc }\n        let letterCode\
    \ = letters.firstIndex(of: letter)\n        return acc + letterCode % 26\n   \
    \ }\n    return Ok(letterCount)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpvvlxjblq.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpvvlxjblq.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(0)\n               ^~~\n/tmp/tmpvvlxjblq.swift:17:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmpvvlxjblq.swift:21:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words.dropLast())\n               ^~\n/tmp/tmpvvlxjblq.swift:24:16: error:\
    \ cannot find 'Ok' in scope\n        return Ok(words.dropLast())\n           \
    \    ^~\n/tmp/tmpvvlxjblq.swift:33:12: error: cannot find 'Ok' in scope\n    return\
    \ Ok(letterCount)\n           ^~\n"
  stdout: ''
  timestamp: 1660054241
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    guard let words = txt.split(separator: \" \"\
    ) else {\n        return Err(Int(.invalid))\n    }\n    \n    var result: [String]\
    \ = []\n    \n    for word in words {\n        if let wordCount = word.characters.count\
    \ {\n            if wordCount % 2 == 1 {\n                result.append(word)\n\
    \            }\n        }\n    }\n    \n    if result.count == 0 {\n        return\
    \ Err(Int(.invalid))\n    }\n    \n    return Ok(result)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpb4n5uzn7.swift:13:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(.invalid))\n               ^~~\n/tmp/tmpb4n5uzn7.swift:13:24:\
    \ error: missing argument label 'bitPattern:' in call\n        return Err(Int(.invalid))\n\
    \                       ^\n                       bitPattern: \n/tmp/tmpb4n5uzn7.swift:12:11:\
    \ error: initializer for conditional binding must have Optional type, not '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n    guard let words = txt.split(separator: \" \")\
    \ else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpb4n5uzn7.swift:19:33:\
    \ error: 'characters' is unavailable: Please use Substring directly\n        if\
    \ let wordCount = word.characters.count {\n                                ^~~~~~~~~~\n\
    Swift.Substring:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public\
    \ var characters: Substring { get set }\n               ^\n/tmp/tmpb4n5uzn7.swift:21:24:\
    \ error: no exact matches in call to instance method 'append'\n              \
    \  result.append(word)\n                       ^\nSwift.Array:6:37: note: candidate\
    \ expects value of type 'String' for parameter #1 (got 'String.SubSequence' (aka\
    \ 'Substring'))\n    @inlinable public mutating func append(_ newElement: __owned\
    \ Element)\n                                    ^\nSwift.RangeReplaceableCollection:4:37:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'String.SubSequence'\
    \ (aka 'Substring'))\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Self.Element)\n                                    ^\n/tmp/tmpb4n5uzn7.swift:21:24:\
    \ note: found candidate with type '(__owned String.SubSequence) -> ()' (aka '(__owned\
    \ Substring) -> ()')\n                result.append(word)\n                  \
    \     ^\n/tmp/tmpb4n5uzn7.swift:19:12: error: initializer for conditional binding\
    \ must have Optional type, not 'Int'\n        if let wordCount = word.characters.count\
    \ {\n           ^               ~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpb4n5uzn7.swift:27:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(.invalid))\n     \
    \          ^~~\n/tm"
  stdout: ''
  timestamp: 1660054241
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(1))\n    }\n    if words.count\
    \ == 1 {\n        return Ok(words)\n    }\n    let firstWord = words[0]\n    let\
    \ lastWord = words[words.count - 1]\n    if firstWord.hasPrefix(\",\") {\n   \
    \     return Ok(words.dropFirst())\n    }\n    if lastWord.hasSuffix(\",\") {\n\
    \        return Ok(words.dropLast())\n    }\n    if firstWord.hasSuffix(\",\"\
    ) {\n        return Ok(words.dropFirst())\n    }\n    return Ok(words)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp9jshjcwe.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp9jshjcwe.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(1))\n               ^~~\n/tmp/tmp9jshjcwe.swift:17:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words)\n               ^~\n\
    /tmp/tmp9jshjcwe.swift:22:16: error: cannot find 'Ok' in scope\n        return\
    \ Ok(words.dropFirst())\n               ^~\n/tmp/tmp9jshjcwe.swift:25:16: error:\
    \ cannot find 'Ok' in scope\n        return Ok(words.dropLast())\n           \
    \    ^~\n/tmp/tmp9jshjcwe.swift:28:16: error: cannot find 'Ok' in scope\n    \
    \    return Ok(words.dropFirst())\n               ^~\n/tmp/tmp9jshjcwe.swift:30:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(words)\n           ^~\n"
  stdout: ''
  timestamp: 1660054241
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    guard words.count > 0 else { return Err(0) }\n    let wordCount = words.count\n\
    \    let wordArray = words.map { $0.lowercased() }\n    let evenWords = wordArray.filter\
    \ { $0.count % 2 == 0 }\n    let oddWords = wordArray.filter { $0.count % 2 !=\
    \ 0 }\n    let evenWordCount = evenWords.count\n    let oddWordCount = oddWords.count\n\
    \    guard evenWordCount == wordCount || oddWordCount == wordCount else { return\
    \ Err(0) }\n    return Ok([evenWords, oddWords])\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp3w60elp1.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp3w60elp1.swift:13:41: error: cannot find 'Err'\
    \ in scope\n    guard words.count > 0 else { return Err(0) }\n               \
    \                         ^~~\n/tmp/tmp3w60elp1.swift:20:81: error: cannot find\
    \ 'Err' in scope\n    guard evenWordCount == wordCount || oddWordCount == wordCount\
    \ else { return Err(0) }\n                                                   \
    \                             ^~~\n/tmp/tmp3w60elp1.swift:21:12: error: cannot\
    \ find 'Ok' in scope\n    return Ok([evenWords, oddWords])\n           ^~\n"
  stdout: ''
  timestamp: 1660054241
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(.zero))\n    }\n    let comma\
    \ = words.last!.components(separatedBy: \",\")\n    if comma.count == 0 {\n  \
    \      return Err(Int(.zero))\n    }\n    let letters = words.map { $0.lowercased()\
    \ }\n    return Ok(letters.filter { $0.count % 2 == 1 })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp70_q2kt0.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp70_q2kt0.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(.zero))\n               ^~~\n/tmp/tmp70_q2kt0.swift:18:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(.zero))\n        \
    \       ^~~\n/tmp/tmp70_q2kt0.swift:21:12: error: cannot find 'Ok' in scope\n\
    \    return Ok(letters.filter { $0.count % 2 == 1 })\n           ^~\n"
  stdout: ''
  timestamp: 1660054241
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ a list of words split on whitespace, if no whitespaces exists in the text you\n\
    /// should split on commas ',' if no commas exists you should return the number\
    \ of lower-case letters with odd order in the\n/// alphabet, ord('a') = 0, ord('b')\
    \ = 1, ... ord('z') = 25\n/// Examples\n/// split_words(\"Hello world!\") \u279E\
    \ [\"Hello\", \"world!\"]\n/// split_words(\"Hello,world!\") \u279E [\"Hello\"\
    , \"world!\"]\n/// split_words(\"abcdef\") == 3\nfunc split_words(txt: String)\
    \ -> Result<[String], Int> {\n    let words = txt.components(separatedBy: \" \"\
    )\n    if words.count == 0 {\n        return Err(Int(0))\n    }\n    let comma\
    \ = words.last?.components(separatedBy: \",\")\n    if comma?.count == 0 {\n \
    \       return Err(Int(1))\n    }\n    return Ok(words)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp1p1ho5lf.swift:12:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp1p1ho5lf.swift:14:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(0))\n               ^~~\n/tmp/tmp1p1ho5lf.swift:18:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(1))\n            \
    \   ^~~\n/tmp/tmp1p1ho5lf.swift:20:12: error: cannot find 'Ok' in scope\n    return\
    \ Ok(words)\n           ^~\n"
  stdout: ''
  timestamp: 1660054241
