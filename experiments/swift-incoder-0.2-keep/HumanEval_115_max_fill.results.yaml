language: swift
name: HumanEval_115_max_fill
results:
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var result = 0\n    \n    for row\
    \ in grid {\n        var buckets = [Int](repeating: 0, count: capacity)\n    \
    \    for well in row {\n            buckets[well] += 1\n        }\n        \n\
    \        for bucket in buckets {\n            if bucket > 0 {\n              \
    \  result += bucket - 1\n            }\n        }\n    }\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:613: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002afe39694c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afe3938b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afe3938b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afe3938b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afe3938abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002afe3918a7ec <unavailable> + 186348

    6    tmp9hm0jbhw                        0x0000556d33b10e91 <unavailable> + 7825

    7    tmp9hm0jbhw                        0x0000556d33b10588 <unavailable> + 5512

    8    libc.so.6                          0x00002afe39880460 __libc_start_main +
    245

    9    tmp9hm0jbhw                        0x0000556d33b10199 <unavailable> + 4505

    '
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var result = 0\n    \n    for row\
    \ in 0..<grid.count {\n        for col in 0..<grid[row].count {\n            if\
    \ grid[row][col] == 1 {\n                result += max_fill_helper(grid, row,\
    \ col, capacity)\n            }\n        }\n    }\n    \n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp9_1c9qon.swift:36:27: error: cannot find 'max_fill_helper' in scope\n\
    \                result += max_fill_helper(grid, row, col, capacity)\n       \
    \                   ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824662
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var result = 0\n    \n    for row\
    \ in grid {\n        var max = 0\n        for cell in row {\n            if cell\
    \ > max {\n                max = cell\n            }\n        }\n        result\
    \ += max - capacity\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpjpzqhra1/tmpjpzqhra1.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae2194c2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae2191b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae2191b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae2191b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjpzqhra1                        0x0000557aacda1546 <unavailable> + 5446

    5    libc.so.6                          0x00002ae2196ae460 __libc_start_main +
    245

    6    tmpjpzqhra1                        0x0000557aacda10d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824662
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var result = 0\n    \n    for row\
    \ in grid {\n        var max = 0\n        for _ in row {\n            max += capacity\n\
    \        }\n        result += max\n    }\n    \n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp0x10hgrp/tmp0x10hgrp.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adbfc742c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adbfc439b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adbfc439988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adbfc4387b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0x10hgrp                        0x0000561540259546 <unavailable> + 5446

    5    libc.so.6                          0x00002adbfc92e460 __libc_start_main +
    245

    6    tmp0x10hgrp                        0x00005615402590d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824662
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var result = 0\n    \n    for row\
    \ in 0..<grid.count {\n        for col in 0..<grid[row].count {\n            if\
    \ grid[row][col] == 1 {\n                result += max(capacity - grid[row][col],\
    \ 0)\n            }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp0n9xl4br/tmp0n9xl4br.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaf07beac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaf078e1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaf078e1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaf078e07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0n9xl4br                        0x000055b343bb46f6 <unavailable> + 5878

    5    libc.so.6                          0x00002aaf07dd6460 __libc_start_main +
    245

    6    tmp0n9xl4br                        0x000055b343bb4289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var count = 0\n    \n    for row\
    \ in grid {\n        for col in row {\n            if col == 1 {\n           \
    \     count += bucket_fill(grid, capacity)\n            }\n        }\n    }\n\
    \    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmprgpj_2lp.swift:36:26: error: cannot find 'bucket_fill' in scope\n\
    \                count += bucket_fill(grid, capacity)\n                      \
    \   ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var buckets = [Int](capacity)\n\
    \    \n    for row in grid {\n        for bucket in row {\n            buckets[bucket]\
    \ += 1\n        }\n    }\n    \n    var max = 0\n    \n    for bucket in buckets\
    \ {\n        if bucket > max {\n            max = bucket\n        }\n    }\n \
    \   \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpj2o2kixv.swift:31:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var buckets = [Int](capacity)\n\
    \    for row in grid {\n        for col in row {\n            if col == 0 {\n\
    \                buckets[col] = buckets[col] + 1\n            }\n        }\n \
    \   }\n    for bucket in buckets {\n        if bucket > result {\n           \
    \ result = bucket\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp37co4b07.swift:31:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824662
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var result = 0\n    \n    for row\
    \ in grid {\n        for well in row {\n            if well > 0 {\n          \
    \      result += well * capacity\n            }\n        }\n    }\n    \n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp9bo14n_y/tmp9bo14n_y.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b88ffa3ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b88ff731b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b88ff731988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b88ff7307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9bo14n_y                        0x000055b7d9fde717 <unavailable> + 5911

    5    libc.so.6                          0x00002b88ffc26460 __libc_start_main +
    245

    6    tmp9bo14n_y                        0x000055b7d9fde0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    guard grid.count > 0 else { return\
    \ 0 }\n    \n    var result = 0\n    \n    for row in 0..<grid.count {\n     \
    \   for col in 0..<grid[row].count {\n            if grid[row][col] == 1 {\n \
    \               result += max_fill_helper(grid, row, col, capacity)\n        \
    \    }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpop5ko8xo.swift:38:27: error: cannot find 'max_fill_helper' in scope\n\
    \                result += max_fill_helper(grid, row, col, capacity)\n       \
    \                   ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824662
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    let rowCount = grid.count\n    let\
    \ colCount = grid[0].count\n    \n    var max = 0\n    \n    for row in 0..<rowCount\
    \ {\n        for col in 0..<colCount {\n            \n            let bucket =\
    \ grid[row][col]\n            \n            if bucket > 0 {\n                \n\
    \                let newCapacity = bucket - capacity\n                \n     \
    \           if newCapacity > max {\n                    max = newCapacity\n  \
    \              }\n                \n            }\n            \n        }\n \
    \   }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpauckehqm/tmpauckehqm.swift:70: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac45e593c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac45e28ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac45e28a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac45e2897b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpauckehqm                        0x000055ddbbb6d656 <unavailable> + 5718

    5    libc.so.6                          0x00002ac45e77f460 __libc_start_main +
    245

    6    tmpauckehqm                        0x000055ddbbb6d1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659824662
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    if grid.isEmpty {\n        return 0\n\
    \    }\n    var result = 0\n    var buckets = [Int](repeating: 0, count: capacity)\n\
    \    for row in grid {\n        for bucket in row {\n            buckets[bucket]\
    \ += 1\n        }\n    }\n    for bucket in buckets {\n        result += bucket\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:613: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae6837c8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae6834bf561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae6834bf286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae6834bf13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae6834bebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae6832be7ec <unavailable> + 186348

    6    tmp2j17m36j                        0x000056520ef61f1e <unavailable> + 7966

    7    tmp2j17m36j                        0x000056520ef615d8 <unavailable> + 5592

    8    libc.so.6                          0x00002ae6839b4460 __libc_start_main +
    245

    9    tmp2j17m36j                        0x000056520ef611e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659824662
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        for col in row {\n            if col == 0 {\n                result +=\
    \ max(capacity - 1, 0)\n            }\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp8xysaixi/tmp8xysaixi.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae792eb0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae792ba7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae792ba7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae792ba67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8xysaixi                        0x000055e73bf605d6 <unavailable> + 5590

    5    libc.so.6                          0x00002ae79309c460 __libc_start_main +
    245

    6    tmp8xysaixi                        0x000055e73bf60169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var buckets = make([][]int,\
    \ capacity)\n    for row in grid {\n        for col in row {\n            buckets[col%capacity]\
    \ = append(buckets[col%capacity], 0)\n        }\n    }\n    for row in grid {\n\
    \        for col in row {\n            buckets[col%capacity][row%capacity] = buckets[col%capacity][row%capacity]\
    \ + 1\n        }\n    }\n    for bucket in buckets {\n        if bucket.len()\
    \ > result {\n            result = bucket.len()\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpg621ymd3.swift:31:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmpg621ymd3.swift:31:19: error: cannot find 'make' in scope\n\
    \    var buckets = make([][]int, capacity)\n                  ^~~~\n/tmp/tmpg621ymd3.swift:31:28:\
    \ error: cannot find 'int' in scope\n    var buckets = make([][]int, capacity)\n\
    \                           ^~~\n/tmp/tmpg621ymd3.swift:31:27: error: missing\
    \ argument for parameter #1 in call\n    var buckets = make([][]int, capacity)\n\
    \                          ^\n                          <#Int#>\nSwift.Array:16:23:\
    \ note: 'subscript(_:)' declared here\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\n/tmp/tmpg621ymd3.swift:34:37:\
    \ error: cannot find 'append' in scope\n            buckets[col%capacity] = append(buckets[col%capacity],\
    \ 0)\n                                    ^~~~~~\n/tmp/tmpg621ymd3.swift:39:35:\
    \ error: cannot convert value of type '[Int]' to expected argument type 'Int'\n\
    \            buckets[col%capacity][row%capacity] = buckets[col%capacity][row%capacity]\
    \ + 1\n                                  ^\n/tmp/tmpg621ymd3.swift:39:73: error:\
    \ cannot convert value of type '[Int]' to expected argument type 'Int'\n     \
    \       buckets[col%capacity][row%capacity] = buckets[col%capacity][row%capacity]\
    \ + 1\n                                                                      \
    \  ^\n"
  stdout: ''
  timestamp: 1659824666
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var count = 0\n    var min = 0\n    for\
    \ row in grid {\n        for col in row {\n            if col == 1 {\n       \
    \         count += 1\n            } else {\n                min = max(min, count)\n\
    \                count = 0\n            }\n        }\n    }\n    return min\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpj_tiiklq/tmpj_tiiklq.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4726e84c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4726b7bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4726b7b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4726b7a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj_tiiklq                        0x000055f8246275d6 <unavailable> + 5590

    5    libc.so.6                          0x00002b4727070460 __libc_start_main +
    245

    6    tmpj_tiiklq                        0x000055f824627169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // init result\n    var result =\
    \ 0\n    \n    // init bucket array\n    var buckets = [Int](repeating: 0, count:\
    \ capacity)\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n \
    \   // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket max\n\
    \    var bucketMax = 0\n    \n    // init bucket min\n    var bucketMin = Int.max\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ sum\n    var bucketSum = 0\n    \n    // init bucket max\n    var bucketMax\
    \ = 0\n    \n    // init bucket min\n    var bucketMin = Int.max\n    \n    //\
    \ init bucket index\n    var bucketIndex = 0\n    \n    // init bucket sum\n \
    \   var bucketSum = 0\n    \n    // init bucket max\n    var bucketMax = 0\n \
    \   \n    // init bucket min\n    var bucketMin = Int.max\n    \n    // init bucket\
    \ index\n    var bucketIndex = 0\n    \n    // init bucket sum\n    var bucketSum\
    \ = 0\n    \n    // init bucket max\n    var bucketMax = 0\n    \n    // init\
    \ bucket min\n    var bucketMin = Int.max\n    \n    // init bucket index\n  \
    \  var bucketIndex = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n\
    \    \n    // init bucket max\n    var bucketMax = 0\n    \n    // init bucket\
    \ min\n    var bucketMin = Int.max\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket max\n    var bucketMax = 0\n    \n    // init bucket min\n    var bucketMin\
    \ = Int.max\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n \
    \   // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket max\n\
    \    var bucketMax = 0\n    \n    // init bucket min\n    var bucketMin = Int.max\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ sum\n    var bucketSum = 0\n    \n    // init bucket max\n    var bucketMax\
    \ = 0\n    \n    // init bucket min\n    var bucketMin = Int.max\n    \n    //\
    \ init bucket index\n    var bucketIndex = 0\n    \n    // init bucket sum\n \
    \   var bucketSum = 0\n    \n    // init bucket max\n    var bucketMax = 0\n \
    \   \n    // init bucket min\n    var bucketMin = Int.max\n    \n    // init bucket\
    \ index\n    var bucketIndex = 0\n    \n    // init bucket sum\n    var bucketSum\
    \ = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpldtpc07a.swift:50:9: error: invalid redeclaration of 'bucketIndex'\n\
    \    var bucketIndex = 0\n        ^\n/tmp/tmpldtpc07a.swift:38:9: note: 'bucketIndex'\
    \ previously declared here\n    var bucketIndex = 0\n        ^\n/tmp/tmpldtpc07a.swift:53:9:\
    \ error: invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n       \
    \ ^\n/tmp/tmpldtpc07a.swift:41:9: note: 'bucketSum' previously declared here\n\
    \    var bucketSum = 0\n        ^\n/tmp/tmpldtpc07a.swift:56:9: error: invalid\
    \ redeclaration of 'bucketMax'\n    var bucketMax = 0\n        ^\n/tmp/tmpldtpc07a.swift:44:9:\
    \ note: 'bucketMax' previously declared here\n    var bucketMax = 0\n        ^\n\
    /tmp/tmpldtpc07a.swift:59:9: error: invalid redeclaration of 'bucketMin'\n   \
    \ var bucketMin = Int.max\n        ^\n/tmp/tmpldtpc07a.swift:47:9: note: 'bucketMin'\
    \ previously declared here\n    var bucketMin = Int.max\n        ^\n/tmp/tmpldtpc07a.swift:62:9:\
    \ error: invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n   \
    \     ^\n/tmp/tmpldtpc07a.swift:38:9: note: 'bucketIndex' previously declared\
    \ here\n    var bucketIndex = 0\n        ^\n/tmp/tmpldtpc07a.swift:65:9: error:\
    \ invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n        ^\n/tmp/tmpldtpc07a.swift:41:9:\
    \ note: 'bucketSum' previously declared here\n    var bucketSum = 0\n        ^\n\
    /tmp/tmpldtpc07a.swift:68:9: error: invalid redeclaration of 'bucketMax'\n   \
    \ var bucketMax = 0\n        ^\n/tmp/tmpldtpc07a.swift:44:9: note: 'bucketMax'\
    \ previously declared here\n    var bucketMax = 0\n        ^\n/tmp/tmpldtpc07a.swift:71:9:\
    \ error: invalid redeclaration of 'bucketMin'\n    var bucketMin = Int.max\n \
    \       ^\n/tmp/tmpldtpc07a.swift:47:9: note: 'bucketMin' previously declared\
    \ here\n    var bucketMin = Int.max\n        ^\n/tmp/tmpldtpc07a.swift:74:9: error:\
    \ invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n\
    /tmp/tmpldtpc07a.swift:38:9: note: 'bucketIndex' previously declared here\n  \
    \  var bucketIndex = 0\n        ^\n/tmp/tmpldtpc07a.swift:77:9: error: invalid\
    \ redeclaration of 'bucketSum'\n    var bucketSum = 0\n        ^\n/tmp/tmpldtpc0"
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    let n = grid.count\n    var ans\
    \ = 0\n    \n    for _ in 0..<n {\n        let bucket = Bucket(capacity)\n   \
    \     \n        for _ in 0..<n {\n            bucket.insert(grid[Int(arc4random_uniform(UInt32(n)))]!)\n\
    \        }\n        \n        ans = max(ans, bucket.empty())\n    }\n    \n  \
    \  return ans\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp4swxgxdv.swift:35:22: error: cannot find 'Bucket' in scope\n  \
    \      let bucket = Bucket(capacity)\n                     ^~~~~~\n/tmp/tmp4swxgxdv.swift:38:36:\
    \ error: cannot find 'arc4random_uniform' in scope\n            bucket.insert(grid[Int(arc4random_uniform(UInt32(n)))]!)\n\
    \                                   ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // init result\n    var result =\
    \ 0\n    \n    // init buckets\n    var buckets = [Int](capacity)\n    \n    //\
    \ init wells\n    var wells = [Int](capacity)\n    \n    // init visited wells\n\
    \    var visited = [Bool](capacity)\n    \n    // init visited wells\n    var\
    \ visited2 = [Bool](capacity)\n    \n    // init visited wells\n    var visited3\
    \ = [Bool](capacity)\n    \n    // init visited wells\n    var visited4 = [Bool](capacity)\n\
    \    \n    // init visited wells\n    var visited5 = [Bool](capacity)\n    \n\
    \    // init visited wells\n    var visited6 = [Bool](capacity)\n    \n    //\
    \ init visited wells\n    var visited7 = [Bool](capacity)\n    \n    // init visited\
    \ wells\n    var visited8 = [Bool](capacity)\n    \n    // init visited wells\n\
    \    var visited9 = [Bool](capacity)\n    \n    // init visited wells\n    var\
    \ visited10 = [Bool](capacity)\n    \n    // init visited wells\n    var visited11\
    \ = [Bool](capacity)\n    \n    // init visited wells\n    var visited12 = [Bool](capacity)\n\
    \    \n    // init visited wells\n    var visited13 = [Bool](capacity)\n    \n\
    \    // init visited wells\n    var visited14 = [Bool](capacity)\n    \n    //\
    \ init visited wells\n    var visited15 = [Bool](capacity)\n    \n    // init\
    \ visited wells\n    var visited16 = [Bool](capacity)\n    \n    // init visited\
    \ wells\n    var visited17 = [Bool](capacity)\n    \n    // init visited wells\n\
    \    var visited18 = [Bool](capacity)\n    \n    // init visited wells\n    var\
    \ visited19 = [Bool](capacity)\n    \n    // init visited wells\n    var visited20\
    \ = [Bool](capacity)\n    \n    // init visited wells\n    var visited21 = [Bool](capacity)\n\
    \    \n    // init visited wells\n    var visited22 = [Bool](capacity)\n    \n\
    \    // init visited wells\n    var visited23 = [Bool](capacity)\n    \n    //\
    \ init visited wells\n    var visited24 = [Bool](capacity)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpaj0k2jbk.swift:35:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpaj0k2jbk.swift:38:23: error: missing\
    \ argument label 'arrayLiteral:' in call\n    var wells = [Int](capacity)\n  \
    \                    ^\n                      arrayLiteral: \n/tmp/tmpaj0k2jbk.swift:41:19:\
    \ error: no exact matches in call to initializer \n    var visited = [Bool](capacity)\n\
    \                  ^\nSwift.Array:3:23: note: candidate requires that 'Int' conform\
    \ to 'Sequence' (requirement specified as 'S' : 'Sequence')\n    @inlinable public\
    \ init<S>(_ s: S) where Element == S.Element, S : Sequence\n                 \
    \     ^\nSwift.RangeReplaceableCollection:3:23: note: candidate requires that\
    \ 'Int' conform to 'Sequence' (requirement specified as 'S' : 'Sequence')\n  \
    \  @inlinable public init<S>(_ elements: S) where S : Sequence, Self.Element ==\
    \ S.Element\n                      ^\n/tmp/tmpaj0k2jbk.swift:41:19: note: candidate\
    \ expects value of type 'Bool' for parameter #1 (got 'Int')\n    var visited =\
    \ [Bool](capacity)\n                  ^\n/tmp/tmpaj0k2jbk.swift:41:19: note: candidate\
    \ expects value of type 'any Decoder' for parameter #1 (got 'Int')\n    var visited\
    \ = [Bool](capacity)\n                  ^\n/tmp/tmpaj0k2jbk.swift:44:20: error:\
    \ no exact matches in call to initializer \n    var visited2 = [Bool](capacity)\n\
    \                   ^\nSwift.Array:3:23: note: candidate requires that 'Int' conform\
    \ to 'Sequence' (requirement specified as 'S' : 'Sequence')\n    @inlinable public\
    \ init<S>(_ s: S) where Element == S.Element, S : Sequence\n                 \
    \     ^\nSwift.RangeReplaceableCollection:3:23: note: candidate requires that\
    \ 'Int' conform to 'Sequence' (requirement specified as 'S' : 'Sequence')\n  \
    \  @inlinable public init<S>(_ elements: S) where S : Sequence, Self.Element ==\
    \ S.Element\n                      ^\n/tmp/tmpaj0k2jbk.swift:44:20: note: candidate\
    \ expects value of type 'Bool' for parameter #1 (got 'Int')\n    var visited2\
    \ = [Bool](capacit"
  stdout: ''
  timestamp: 1659824662
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // TODO: write your code here\n\
    \    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp8hxygw_q/tmp8hxygw_q.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad8e0b69c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad8e0860b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad8e0860988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad8e085f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8hxygw_q                        0x000055fa6e2cf3d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ad8e0d55460 __libc_start_main +
    245

    6    tmp8hxygw_q                        0x000055fa6e2cef69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // init result\n    var result =\
    \ 0\n    \n    // init bucket array\n    var bucket = [Int](repeating: 0, count:\
    \ capacity)\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n \
    \   // init bucket index\n    var bucketIndex2 = 0\n    \n    // init bucket index\n\
    \    var bucketIndex3 = 0\n    \n    // init bucket index\n    var bucketIndex4\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex5 = 0\n    \n    //\
    \ init bucket index\n    var bucketIndex6 = 0\n    \n    // init bucket index\n\
    \    var bucketIndex7 = 0\n    \n    // init bucket index\n    var bucketIndex8\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex9 = 0\n    \n    //\
    \ init bucket index\n    var bucketIndex10 = 0\n    \n    // init bucket index\n\
    \    var bucketIndex11 = 0\n    \n    // init bucket index\n    var bucketIndex12\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex13 = 0\n    \n    //\
    \ init bucket index\n    var bucketIndex14 = 0\n    \n    // init bucket index\n\
    \    var bucketIndex15 = 0\n    \n    // init bucket index\n    var bucketIndex16\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex17 = 0\n    \n    //\
    \ init bucket index\n    var bucketIndex18 = 0\n    \n    // init bucket index\n\
    \    var bucketIndex19 = 0\n    \n    // init bucket index\n    var bucketIndex20\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex21 = 0\n    \n    //\
    \ init bucket index\n    var bucketIndex22 = 0\n    \n    // init bucket index\n\
    \    var bucketIndex23 = 0\n    \n    // init bucket index\n    var bucketIndex24\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex25 = 0\n    \n    //\
    \ init bucket index\n    var bucketIndex26 = 0\n    \n    // init bucket index\n\
    \    var bucketIndex27 = 0\n    \n    // init bucket index\n    var bucketIndex28\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex29 = 0\n    \n    //\
    \ init bucket index\n    var bucketIndex30 = 0\n    \n    // init bucket index\n\
    \    var bucketIndex31 = 0\n    \n    // init bucket index\n    var bucketIndex32\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex33 = 0\n    \n    //\
    \ init bucket index\n    var bucketIndex34 = 0\n    \n    // init bucket index\n\
    \    var bucketIndex35 = 0\n    \n    // init bucket index\n    var bucketIndex36\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex37 = 0\n    \n    //\
    \ \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0],\
    \ [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0,\
    \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid:\
    \ [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1,\
    \ 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp5t94g64l.swift:32:9: warning: initialization of variable 'result'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var result = 0\n    ~~~~^~~~~~\n    _\n/tmp/tmp5t94g64l.swift:35:9: warning:\
    \ initialization of variable 'bucket' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var bucket = [Int](repeating: 0, count:\
    \ capacity)\n    ~~~~^~~~~~\n    _\n/tmp/tmp5t94g64l.swift:38:9: warning: initialization\
    \ of variable 'bucketIndex' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var bucketIndex = 0\n    ~~~~^~~~~~~~~~~\n    _\n\
    /tmp/tmp5t94g64l.swift:41:9: warning: initialization of variable 'bucketIndex2'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var bucketIndex2 = 0\n    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmp5t94g64l.swift:44:9:\
    \ warning: initialization of variable 'bucketIndex3' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var bucketIndex3 = 0\n\
    \    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmp5t94g64l.swift:47:9: warning: initialization\
    \ of variable 'bucketIndex4' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var bucketIndex4 = 0\n    ~~~~^~~~~~~~~~~~\n    _\n\
    /tmp/tmp5t94g64l.swift:50:9: warning: initialization of variable 'bucketIndex5'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var bucketIndex5 = 0\n    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmp5t94g64l.swift:53:9:\
    \ warning: initialization of variable 'bucketIndex6' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var bucketIndex6 = 0\n\
    \    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmp5t94g64l.swift:56:9: warning: initialization\
    \ of variable 'bucketIndex7' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var bucketIndex7 = 0\n    ~~~~^~~~~~~~~~~~\n    _\n\
    /tmp/tmp5t94g64l.swift:59:9: warning: initialization of variable 'bucketIndex8'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var bucketIndex8 = 0\n    ~~~~^~~~~~~~~~~~\n    _\n/t"
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // init result\n    var result =\
    \ 0\n    \n    // init buckets\n    var buckets = [Int](capacity)\n    \n    //\
    \ init well position\n    var wellPosition = 0\n    \n    // init well count\n\
    \    var wellCount = 0\n    \n    // init bucket position\n    var bucketPosition\
    \ = 0\n    \n    // init bucket count\n    var bucketCount = 0\n    \n    // init\
    \ bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket max capacity\n\
    \    var bucketMaxCapacity = 0\n    \n    // init bucket min capacity\n    var\
    \ bucketMinCapacity = 0\n    \n    // init bucket min capacity\n    var bucketMinCapacity\
    \ = 0\n    \n    // init bucket min capacity\n    var bucketMinCapacity = 0\n\
    \    \n    // init bucket min capacity\n    var bucketMinCapacity = 0\n    \n\
    \    // init bucket min capacity\n    var bucketMinCapacity = 0\n    \n    //\
    \ init bucket min capacity\n    var bucketMinCapacity = 0\n    \n    // init bucket\
    \ min capacity\n    var bucketMinCapacity = 0\n    \n    // init bucket min capacity\n\
    \    var bucketMinCapacity = 0\n    \n    // init bucket min capacity\n    var\
    \ bucketMinCapacity = 0\n    \n    // init bucket min capacity\n    var bucketMinCapacity\
    \ = 0\n    \n    // init bucket min capacity\n    var bucketMinCapacity = 0\n\
    \    \n    // init bucket min capacity\n    var bucketMinCapacity = 0\n    \n\
    \    // init bucket min capacity\n    var bucketMinCapacity = 0\n    \n    //\
    \ init bucket min capacity\n    var bucketMinCapacity = 0\n    \n    // init bucket\
    \ min capacity\n    var bucketMinCapacity = 0\n    \n    // init bucket min capacity\n\
    \    var bucketMinCapacity = 0\n    \n    // init bucket min capacity\n    var\
    \ bucketMinCapacity = 0\n    \n    // init bucket min capacity\n    var bucketMinCapacity\
    \ = 0\n    \n    // init bucket min capacity\n    var bucketMinCapacity = 0\n\
    \    \n    // init bucket min capacity\n    var bucketMinCapacity = 0\n    \n\
    \    // init bucket min capacity\n    var bucketMinCapacity = 0\n    \n    //\
    \ init bucket min capacity\n    var bucketMinCapacity = 0\n    \n    // init bucket\
    \ min capacity\n    var bucketMinCapacity = 0\n    \n    // init bucket min capacity\n\
    \    var bucketMinCapacity = 0\n    \n    // init bucket min capacity\n    var\
    \ bucketMinCapacity = 0\n    \n    // init bucket min capacity\n    var bucketMinCapacity\
    \ = 0\n    \n    // init bucket min capacity\n    var bucketMinCapacity = 0\n\
    \    \n    // init bucket min capacity\n    var bucketMinCapacity = 0\n    \n\
    \    // init bucket min capacity\n    var bucketMinCapacity = 0\n    \n    //\
    \ init bucket min \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmplhq17we9.swift:35:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmplhq17we9.swift:59:9: error: invalid\
    \ redeclaration of 'bucketMinCapacity'\n    var bucketMinCapacity = 0\n      \
    \  ^\n/tmp/tmplhq17we9.swift:56:9: note: 'bucketMinCapacity' previously declared\
    \ here\n    var bucketMinCapacity = 0\n        ^\n/tmp/tmplhq17we9.swift:62:9:\
    \ error: invalid redeclaration of 'bucketMinCapacity'\n    var bucketMinCapacity\
    \ = 0\n        ^\n/tmp/tmplhq17we9.swift:56:9: note: 'bucketMinCapacity' previously\
    \ declared here\n    var bucketMinCapacity = 0\n        ^\n/tmp/tmplhq17we9.swift:65:9:\
    \ error: invalid redeclaration of 'bucketMinCapacity'\n    var bucketMinCapacity\
    \ = 0\n        ^\n/tmp/tmplhq17we9.swift:56:9: note: 'bucketMinCapacity' previously\
    \ declared here\n    var bucketMinCapacity = 0\n        ^\n/tmp/tmplhq17we9.swift:68:9:\
    \ error: invalid redeclaration of 'bucketMinCapacity'\n    var bucketMinCapacity\
    \ = 0\n        ^\n/tmp/tmplhq17we9.swift:56:9: note: 'bucketMinCapacity' previously\
    \ declared here\n    var bucketMinCapacity = 0\n        ^\n/tmp/tmplhq17we9.swift:71:9:\
    \ error: invalid redeclaration of 'bucketMinCapacity'\n    var bucketMinCapacity\
    \ = 0\n        ^\n/tmp/tmplhq17we9.swift:56:9: note: 'bucketMinCapacity' previously\
    \ declared here\n    var bucketMinCapacity = 0\n        ^\n/tmp/tmplhq17we9.swift:74:9:\
    \ error: invalid redeclaration of 'bucketMinCapacity'\n    var bucketMinCapacity\
    \ = 0\n        ^\n/tmp/tmplhq17we9.swift:56:9: note: 'bucketMinCapacity' previously\
    \ declared here\n    var bucketMinCapacity = 0\n        ^\n/tmp/tmplhq17we9.swift:77:9:\
    \ error: invalid redeclaration of 'bucketMinCapacity'\n    var bucketMinCapacity\
    \ = 0\n        ^\n/tmp/tmplhq17we9.swift:56:9: note: 'bucketMinCapacity' previously\
    \ declared here\n    var bucketMinCapacity = 0\n        ^\n/tmp/tmplhq17we9.swift:80:9:\
    \ error: invalid redeclaration of 'bucketMinCapacity'\n    var bucketMinCapacity\
    \ = 0\n        ^\n/tmp/tmplhq17we9.swift:56:9: note: 'bucketMinCapacity' pr"
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    if grid.isEmpty {\n        return 0\n\
    \    }\n    \n    var max = 0\n    var buckets = [Int](capacity)\n    \n    for\
    \ row in grid {\n        for bucket in row {\n            buckets[bucket] += 1\n\
    \        }\n    }\n    \n    for bucket in buckets {\n        if bucket > max\
    \ {\n            max = bucket\n        }\n    }\n    \n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpozf3t0e2.swift:35:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824662
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    let rowCount = grid.count\n    let\
    \ colCount = grid[0].count\n    \n    var max = 0\n    \n    for row in 0..<rowCount\
    \ {\n        for col in 0..<colCount {\n            if grid[row][col] == 1 {\n\
    \                max += capacity\n            }\n        }\n    }\n    \n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpqfph4uzi/tmpqfph4uzi.swift:61: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0ac2d77c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0ac2a6eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0ac2a6e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0ac2a6d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqfph4uzi                        0x00005582f3000827 <unavailable> + 6183

    5    libc.so.6                          0x00002b0ac2f63460 __libc_start_main +
    245

    6    tmpqfph4uzi                        0x00005582f30001e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659824662
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // write your code here\n    \n\
    \    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpb8f0yy9_/tmpb8f0yy9_.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4229232c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4228f29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4228f29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4228f287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb8f0yy9_                        0x000055dcd7d3b3d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b422941e460 __libc_start_main +
    245

    6    tmpb8f0yy9_                        0x000055dcd7d3af69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var buckets = [Int](capacity)\n\
    \    for row in grid {\n        for col in row {\n            buckets[col] -=\
    \ 1\n            if buckets[col] == 0 {\n                buckets[col] = capacity\n\
    \            }\n        }\n    }\n    for bucket in buckets {\n        result\
    \ += bucket\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmp6truq5fs.swift:31:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824662
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var result = 0\n    \n    for row\
    \ in grid {\n        for bucket in row {\n            if bucket > capacity {\n\
    \                result += capacity - bucket\n            } else {\n         \
    \       result += bucket\n            }\n        }\n    }\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp5zsqkclj/tmp5zsqkclj.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b251d77fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b251d476b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b251d476988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b251d4757b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5zsqkclj                        0x00005579f2f59717 <unavailable> + 5911

    5    libc.so.6                          0x00002b251d96b460 __libc_start_main +
    245

    6    tmp5zsqkclj                        0x00005579f2f590d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // init result\n    var result =\
    \ 0\n    \n    // init bucket array\n    var buckets = [Int](repeating: 0, count:\
    \ capacity)\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n \
    \   // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket max index\n\
    \    var bucketMaxIndex = 0\n    \n    // init bucket max value\n    var bucketMaxValue\
    \ = grid[0][0]\n    \n    // init bucket max index\n    var bucketMaxIndex = 0\n\
    \    \n    // init bucket max value\n    var bucketMaxValue = grid[0][0]\n   \
    \ \n    // init bucket max index\n    var bucketMaxIndex = 0\n    \n    // init\
    \ bucket max value\n    var bucketMaxValue = grid[0][0]\n    \n    // init bucket\
    \ max index\n    var bucketMaxIndex = 0\n    \n    // init bucket max value\n\
    \    var bucketMaxValue = grid[0][0]\n    \n    // init bucket max index\n   \
    \ var bucketMaxIndex = 0\n    \n    // init bucket max value\n    var bucketMaxValue\
    \ = grid[0][0]\n    \n    // init bucket max index\n    var bucketMaxIndex = 0\n\
    \    \n    // init bucket max value\n    var bucketMaxValue = grid[0][0]\n   \
    \ \n    // init bucket max index\n    var bucketMaxIndex = 0\n    \n    // init\
    \ bucket max value\n    var bucketMaxValue = grid[0][0]\n    \n    // init bucket\
    \ max index\n    var bucketMaxIndex = 0\n    \n    // init bucket max value\n\
    \    var bucketMaxValue = grid[0][0]\n    \n    // init bucket max index\n   \
    \ var bucketMaxIndex = 0\n    \n    // init bucket max value\n    var bucketMaxValue\
    \ = grid[0][0]\n    \n    // init bucket max index\n    var bucketMaxIndex = 0\n\
    \    \n    // init bucket max value\n    var bucketMaxValue = grid[0][0]\n   \
    \ \n    // init bucket max index\n    var bucketMaxIndex = 0\n    \n    // init\
    \ bucket max value\n    var bucketMaxValue = grid[0][0]\n    \n    // init bucket\
    \ max index\n    var bucketMaxIndex = 0\n    \n    // init bucket max value\n\
    \    var bucketMaxValue = grid[0][0]\n    \n    // init bucket max index\n   \
    \ var bucketMaxIndex = 0\n    \n    // init bucket max value\n    var bucketMaxValue\
    \ = grid[0][0]\n    \n    // init bucket max index\n    var bucketMaxIndex = 0\n\
    \    \n    // init bucket max value\n    var bucketMaxValue = grid[0][0]\n   \
    \ \n    // init bucket max index\n    var bucketMaxIndex = 0\n    \n    // init\
    \ bucket max value\n    var bucketMaxValue = grid[0][0]\n    \n    // init bucket\
    \ max index\n    var bucketMaxIndex = 0\n    \n    // init bucket max value\n\
    \    var bucket\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpiia8eqeq.swift:50:9: error: invalid redeclaration of 'bucketMaxIndex'\n\
    \    var bucketMaxIndex = 0\n        ^\n/tmp/tmpiia8eqeq.swift:44:9: note: 'bucketMaxIndex'\
    \ previously declared here\n    var bucketMaxIndex = 0\n        ^\n/tmp/tmpiia8eqeq.swift:53:9:\
    \ error: invalid redeclaration of 'bucketMaxValue'\n    var bucketMaxValue = grid[0][0]\n\
    \        ^\n/tmp/tmpiia8eqeq.swift:47:9: note: 'bucketMaxValue' previously declared\
    \ here\n    var bucketMaxValue = grid[0][0]\n        ^\n/tmp/tmpiia8eqeq.swift:56:9:\
    \ error: invalid redeclaration of 'bucketMaxIndex'\n    var bucketMaxIndex = 0\n\
    \        ^\n/tmp/tmpiia8eqeq.swift:44:9: note: 'bucketMaxIndex' previously declared\
    \ here\n    var bucketMaxIndex = 0\n        ^\n/tmp/tmpiia8eqeq.swift:59:9: error:\
    \ invalid redeclaration of 'bucketMaxValue'\n    var bucketMaxValue = grid[0][0]\n\
    \        ^\n/tmp/tmpiia8eqeq.swift:47:9: note: 'bucketMaxValue' previously declared\
    \ here\n    var bucketMaxValue = grid[0][0]\n        ^\n/tmp/tmpiia8eqeq.swift:62:9:\
    \ error: invalid redeclaration of 'bucketMaxIndex'\n    var bucketMaxIndex = 0\n\
    \        ^\n/tmp/tmpiia8eqeq.swift:44:9: note: 'bucketMaxIndex' previously declared\
    \ here\n    var bucketMaxIndex = 0\n        ^\n/tmp/tmpiia8eqeq.swift:65:9: error:\
    \ invalid redeclaration of 'bucketMaxValue'\n    var bucketMaxValue = grid[0][0]\n\
    \        ^\n/tmp/tmpiia8eqeq.swift:47:9: note: 'bucketMaxValue' previously declared\
    \ here\n    var bucketMaxValue = grid[0][0]\n        ^\n/tmp/tmpiia8eqeq.swift:68:9:\
    \ error: invalid redeclaration of 'bucketMaxIndex'\n    var bucketMaxIndex = 0\n\
    \        ^\n/tmp/tmpiia8eqeq.swift:44:9: note: 'bucketMaxIndex' previously declared\
    \ here\n    var bucketMaxIndex = 0\n        ^\n/tmp/tmpiia8eqeq.swift:71:9: error:\
    \ invalid redeclaration of 'bucketMaxValue'\n    var bucketMaxValue = grid[0][0]\n\
    \        ^\n/tmp/tmpiia8eqeq.swift:47:9: note: 'bucketMaxValue' previously declared\
    \ here\n    var bucketMaxValue = grid[0][0]\n        ^\n/tmp/tmpiia8eqeq.swift:74:9:\
    \ error: invalid redeclaration of 'bucketMaxIndex'\n    var bucketMaxIndex = 0\n\
    \        ^\n/tmp/tmpiia8eqeq.swift:44:9: "
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var count = 0\n    \n    for row\
    \ in grid {\n        for col in row {\n            if col == 0 {\n           \
    \     count += min_fill(grid: &row, capacity: capacity)\n            }\n     \
    \   }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmp5mnqj7t5.swift:36:26: error: cannot find 'min_fill' in scope\n\
    \                count += min_fill(grid: &row, capacity: capacity)\n         \
    \                ^~~~~~~~\n/tmp/tmp5mnqj7t5.swift:36:41: error: cannot pass immutable\
    \ value as inout argument: 'row' is a 'let' constant\n                count +=\
    \ min_fill(grid: &row, capacity: capacity)\n                                 \
    \       ^~~~\n"
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var result = 0\n    var buckets\
    \ = [Int](capacity)\n    \n    for row in grid {\n        for col in row {\n \
    \           buckets[col] += col\n        }\n    }\n    \n    for bucket in buckets\
    \ {\n        if bucket > 0 {\n            result += bucket\n        }\n    }\n\
    \    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpvbgky_ps.swift:32:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // init result\n    var result =\
    \ 0\n    \n    // init bucket array\n    var bucket = [Int](repeating: 0, count:\
    \ capacity)\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n \
    \   // init bucket capacity\n    var bucketCapacity = capacity\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket capacity\n \
    \   var bucketCapacity = capacity\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = capacity\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ capacity\n    var bucketCapacity = capacity\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = capacity\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n\
    \    // init bucket capacity\n    var bucketCapacity = capacity\n    \n    //\
    \ init bucket index\n    var bucketIndex = 0\n    \n    // init bucket capacity\n\
    \    var bucketCapacity = capacity\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = capacity\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ capacity\n    var bucketCapacity = capacity\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = capacity\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n\
    \    // init bucket capacity\n    var bucketCapacity = capacity\n    \n    //\
    \ init bucket index\n    var bucketIndex = 0\n    \n    // init bucket capacity\n\
    \    var bucketCapacity = capacity\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = capacity\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ capacity\n    var bucketCapacity = capacity\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = capacity\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n\
    \    // init bucket capacity\n    var bucketCapacity = capacity\n    \n    //\
    \ init bucket index\n    var bucketIndex = 0\n    \n    // init bucket capacity\n\
    \    var bucketCapacity = capacity\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = capacity\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ capacity\n    var bucketCapacity = capacity\n    \n    // init bucket index\n\
    \    var \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp6ct0et79.swift:152:8: error: expected pattern\n    var \n     \
    \  ^\n/tmp/tmp6ct0et79.swift:44:9: error: invalid redeclaration of 'bucketIndex'\n\
    \    var bucketIndex = 0\n        ^\n/tmp/tmp6ct0et79.swift:38:9: note: 'bucketIndex'\
    \ previously declared here\n    var bucketIndex = 0\n        ^\n/tmp/tmp6ct0et79.swift:47:9:\
    \ error: invalid redeclaration of 'bucketCapacity'\n    var bucketCapacity = capacity\n\
    \        ^\n/tmp/tmp6ct0et79.swift:41:9: note: 'bucketCapacity' previously declared\
    \ here\n    var bucketCapacity = capacity\n        ^\n/tmp/tmp6ct0et79.swift:50:9:\
    \ error: invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n   \
    \     ^\n/tmp/tmp6ct0et79.swift:38:9: note: 'bucketIndex' previously declared\
    \ here\n    var bucketIndex = 0\n        ^\n/tmp/tmp6ct0et79.swift:53:9: error:\
    \ invalid redeclaration of 'bucketCapacity'\n    var bucketCapacity = capacity\n\
    \        ^\n/tmp/tmp6ct0et79.swift:41:9: note: 'bucketCapacity' previously declared\
    \ here\n    var bucketCapacity = capacity\n        ^\n/tmp/tmp6ct0et79.swift:56:9:\
    \ error: invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n   \
    \     ^\n/tmp/tmp6ct0et79.swift:38:9: note: 'bucketIndex' previously declared\
    \ here\n    var bucketIndex = 0\n        ^\n/tmp/tmp6ct0et79.swift:59:9: error:\
    \ invalid redeclaration of 'bucketCapacity'\n    var bucketCapacity = capacity\n\
    \        ^\n/tmp/tmp6ct0et79.swift:41:9: note: 'bucketCapacity' previously declared\
    \ here\n    var bucketCapacity = capacity\n        ^\n/tmp/tmp6ct0et79.swift:62:9:\
    \ error: invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n   \
    \     ^\n/tmp/tmp6ct0et79.swift:38:9: note: 'bucketIndex' previously declared\
    \ here\n    var bucketIndex = 0\n        ^\n/tmp/tmp6ct0et79.swift:65:9: error:\
    \ invalid redeclaration of 'bucketCapacity'\n    var bucketCapacity = capacity\n\
    \        ^\n/tmp/tmp6ct0et79.swift:41:9: note: 'bucketCapacity' previously declared\
    \ here\n    var bucketCapacity = capacity\n        ^\n/tmp/tmp6ct0et79.swift:68:9:\
    \ error: invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n   \
    \     ^\n/tmp/tmp6ct0et79.swift:38:9"
  stdout: ''
  timestamp: 1659824662
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        for well in row {\n            if well > 0 {\n                result\
    \ += well * capacity\n            }\n        }\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp3pmmd8sq/tmp3pmmd8sq.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7c10bb0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7c108a7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7c108a7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7c108a67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3pmmd8sq                        0x00005619f9069717 <unavailable> + 5911

    5    libc.so.6                          0x00002b7c10d9c460 __libc_start_main +
    245

    6    tmp3pmmd8sq                        0x00005619f90690d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824662
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var count = 0\n    var max = 0\n    for\
    \ row in grid {\n        for col in row {\n            if col == 0 {\n       \
    \         count += 1\n                if count > max {\n                    max\
    \ = count\n                }\n                count = 0\n            }\n     \
    \   }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp3_hmjr6b/tmp3_hmjr6b.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba5fde25c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba5fdb1cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba5fdb1c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5fdb1b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3_hmjr6b                        0x00005639155c9546 <unavailable> + 5446

    5    libc.so.6                          0x00002ba5fe011460 __libc_start_main +
    245

    6    tmp3_hmjr6b                        0x00005639155c90d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824662
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        if row[0] == 0 {\n            result += row[1]\n        }\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp_eb3tto7/tmp_eb3tto7.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af99271dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af992414b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af992414988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af9924137b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_eb3tto7                        0x0000560057d31596 <unavailable> + 5526

    5    libc.so.6                          0x00002af992909460 __libc_start_main +
    245

    6    tmp_eb3tto7                        0x0000560057d31129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659824662
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var result = 0\n    \n    for row\
    \ in grid {\n        for well in row {\n            if well != 0 {\n         \
    \       result += well * capacity\n            }\n        }\n    }\n    \n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp_mg6f6zm/tmp_mg6f6zm.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae0b00a6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae0afd9db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae0afd9d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae0afd9c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_mg6f6zm                        0x000055b496794717 <unavailable> + 5911

    5    libc.so.6                          0x00002ae0b0292460 __libc_start_main +
    245

    6    tmp_mg6f6zm                        0x000055b4967940d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824662
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var result = 0\n    \n    for row\
    \ in 0..<grid.count {\n        for col in 0..<grid[row].count {\n            if\
    \ grid[row][col] == 1 {\n                result += max(capacity - grid[row][col],\
    \ 0)\n            }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp0n9xl4br/tmp0n9xl4br.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaf07beac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaf078e1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaf078e1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaf078e07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0n9xl4br                        0x000055b343bb46f6 <unavailable> + 5878

    5    libc.so.6                          0x00002aaf07dd6460 __libc_start_main +
    245

    6    tmp0n9xl4br                        0x000055b343bb4289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // write your code here\n    var\
    \ max = 0\n    var count = 0\n    for row in 0..<grid.count {\n        for col\
    \ in 0..<grid[row].count {\n            if grid[row][col] == 1 {\n           \
    \     grid[row][col] = 0\n                max += capacity\n                count\
    \ += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp21vzo_8x.swift:37:26: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                grid[row][col] = 0\n                ~~~~\
    \     ^\n"
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var buckets = [Int](capacity)\n\
    \    \n    for row in grid {\n        for col in row {\n            buckets[col]\
    \ += 1 \n        }\n    }\n    \n    var result = 0\n    \n    for bucket in buckets\
    \ {\n        if bucket > 0 {\n            result += bucket\n        }\n    }\n\
    \    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpdpd96nqm.swift:31:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var result = 0\n    \n    for row\
    \ in 0..<grid.count {\n        for col in 0..<grid[row].count {\n            if\
    \ grid[row][col] == 1 {\n                result += min_fill(grid[row + 0..<row],\
    \ capacity - grid[row][col])\n            }\n        }\n    }\n    \n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpxl3_q4fa.swift:36:27: error: cannot find 'min_fill' in scope\n\
    \                result += min_fill(grid[row + 0..<row], capacity - grid[row][col])\n\
    \                          ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var result = 0\n    \n    for row\
    \ in grid {\n        for col in row {\n            \n            if col == 0 {\n\
    \                \n                let bucket = bucket {\n                   \
    \ \n                    let capacity = capacity\n                    \n      \
    \              func lower() -> Int {\n                        \n             \
    \           let result = 0\n                        \n                       \
    \ for row in grid {\n                            \n                          \
    \  for col in row {\n                                \n                      \
    \          if col == 0 {\n                                    \n             \
    \                       if capacity > 0 {\n                                  \
    \      \n                                        capacity -= 1\n             \
    \                           \n                                        result +=\
    \ bucket.lower\n                                        \n                   \
    \                 }\n                                    \n                  \
    \              } else {\n                                    \n              \
    \                      if capacity > 0 {\n                                   \
    \     \n                                        capacity -= 1\n              \
    \                          \n                                        result +=\
    \ bucket.lower\n                                        \n                   \
    \                 }\n                                    \n                  \
    \              }\n                                \n                         \
    \   }\n                            \n                        }\n             \
    \           \n                        return result\n                        \n\
    \                    }\n                    \n                    func upper()\
    \ -> Int {\n                        \n                        let result = 0\n\
    \                        \n                        for row in grid {\n       \
    \                     \n                            for col in row {\n       \
    \                         \n                                if col == 0 {\n  \
    \                                  \n                                    if capacity\
    \ > 0 {\n                                        \n                          \
    \              capacity -= 1\n                                        \n     \
    \                                   result += bucket.upper\n                 \
    \                       \n                                    }\n            \
    \                        \n                                } else {\n        \
    \                            \n                                    if capacity\
    \ > 0 {\n                                        \n                          \
    \              capacity -= 1\n                                        \n     \
    \                                   result += bucket.upper\n                 \
    \                       \n                                    }\n            \
    \                        \n                                }\n               \
    \                 \n                            }\n                          \
    \  \n                        }\n                        \n                   \
    \     return result\n                        \n                    }\n       \
    \             \n                    func fill() -> Int {\n                   \
    \     \n                        let result = 0\n                        \n   \
    \                     for row in grid {\n                            \n      \
    \                      for col in row {\n                                \n  \
    \                              if col == 0 {\n                               \
    \     \n                                    if capacity > 0 {\n              \
    \                          \n                                        capacity\
    \ -= 1\n                                        \n                           \
    \             result += bucket.fill\n                                        \n\
    \                                    }\n                                    \n\
    \                                } else {\n                                  \
    \  \n                                    if capacity > 0 {\n                 \
    \                       \n                                        capacity -=\
    \ 1\n                                        \n                              \
    \          result += bucket.fill\n                                        \n \
    \                                   }\n                                    \n\
    \                                }\n                                \n       \
    \                     }\n                            \n                      \
    \  }\n                        \n                        return result\n      \
    \                  \n                    }\n                    \n           \
    \         func empty() -> Int {\n                        \n                  \
    \      let result = 0\n                        \n                        for row\
    \ in grid {\n                            \n                            for col\
    \ in row {\n                                \n                               \
    \ if col == 0 {\n                                    \n                      \
    \              if capacity > 0 {\n                                        \n \
    \                                       capacity -= 1\n                      \
    \                  \n                                        result += bucket.empty\n\
    \                                        \n                                  \
    \  }\n                                    \n                                }\
    \ else {\n                                    \n                             \
    \       if capacity > 0 {\n                                        \n        \
    \                                capacity -= 1\n                             \
    \           \n                                        result += bucket.empty\n\
    \                                        \n                                  \
    \  }\n                                    \n                                }\n\
    \                                \n                            }\n           \
    \                 \n                        }\n                        \n    \
    \                    return result\n                        \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpuz3nmr4b.swift:211:71: error: expected '}' at end of closure\n\
    assert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)\n     \
    \                                                                 ^\n/tmp/tmpuz3nmr4b.swift:38:37:\
    \ note: to match this opening '{'\n                let bucket = bucket {\n   \
    \                                 ^\n/tmp/tmpuz3nmr4b.swift:211:71: error: expected\
    \ '}' at end of brace statement\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1,\
    \ 1]], capacity: 9) == 2)\n                                                  \
    \                    ^\n/tmp/tmpuz3nmr4b.swift:36:25: note: to match this opening\
    \ '{'\n            if col == 0 {\n                        ^\n/tmp/tmpuz3nmr4b.swift:211:71:\
    \ error: expected '}' at end of brace statement\nassert(max_fill(grid: [[1, 1,\
    \ 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)\n                                 \
    \                                     ^\n/tmp/tmpuz3nmr4b.swift:34:24: note: to\
    \ match this opening '{'\n        for col in row {\n                       ^\n\
    /tmp/tmpuz3nmr4b.swift:211:71: error: expected '}' at end of brace statement\n\
    assert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)\n     \
    \                                                                 ^\n/tmp/tmpuz3nmr4b.swift:33:21:\
    \ note: to match this opening '{'\n    for row in grid {\n                   \
    \ ^\n/tmp/tmpuz3nmr4b.swift:211:71: error: expected '}' at end of brace statement\n\
    assert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)\n     \
    \                                                                 ^\n/tmp/tmpuz3nmr4b.swift:29:52:\
    \ note: to match this opening '{'\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n                                                   ^\n/tmp/tmpuz3nmr4b.swift:38:30:\
    \ error: use of local variable 'bucket' before its declaration\n             \
    \   let bucket = bucket {\n                             ^\n/tmp/tmpuz3nmr4b.swift:38:21:\
    \ note: 'bucket' declared here\n                let bucket = bucket {\n      \
    \              ^\n"
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // init result\n    var result =\
    \ 0\n    \n    // init bucket array\n    var bucket = [Int](repeating: 0, count:\
    \ capacity)\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n \
    \   // init bucket length\n    var bucketLength = 0\n    \n    // init bucket\
    \ capacity\n    var bucketCapacity = 0\n    \n    // init bucket capacity\n  \
    \  var bucketCapacity = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n \
    \   // init bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket\
    \ capacity\n    var bucketCapacity = 0\n    \n    // init bucket capacity\n  \
    \  var bucketCapacity = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n \
    \   // init bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket\
    \ capacity\n    var bucketCapacity = 0\n    \n    // init bucket capacity\n  \
    \  var bucketCapacity = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n \
    \   // init bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket\
    \ capacity\n    var bucketCapacity = 0\n    \n    // init bucket capacity\n  \
    \  var bucketCapacity = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n \
    \   // init bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket\
    \ capacity\n    var bucketCapacity = 0\n    \n    // init bucket capacity\n  \
    \  var bucketCapacity = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n \
    \   // init bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket\
    \ capacity\n    var bucketCapacity = 0\n    \n    // init bucket capacity\n  \
    \  var bucketCapacity = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n \
    \   // init bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket\
    \ capacity\n    var bucketCapacity = 0\n    \n    // init bucket capacity\n  \
    \  var bucketCapacity = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n \
    \   // init bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket\
    \ capacity\n    var bucketCapacity = 0\n    \n    // init bucket capacity\n  \
    \  var bucketCapacity = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpe3i97zyy.swift:47:9: error: invalid redeclaration of 'bucketCapacity'\n\
    \    var bucketCapacity = 0\n        ^\n/tmp/tmpe3i97zyy.swift:44:9: note: 'bucketCapacity'\
    \ previously declared here\n    var bucketCapacity = 0\n        ^\n/tmp/tmpe3i97zyy.swift:50:9:\
    \ error: invalid redeclaration of 'bucketCapacity'\n    var bucketCapacity = 0\n\
    \        ^\n/tmp/tmpe3i97zyy.swift:44:9: note: 'bucketCapacity' previously declared\
    \ here\n    var bucketCapacity = 0\n        ^\n/tmp/tmpe3i97zyy.swift:53:9: error:\
    \ invalid redeclaration of 'bucketCapacity'\n    var bucketCapacity = 0\n    \
    \    ^\n/tmp/tmpe3i97zyy.swift:44:9: note: 'bucketCapacity' previously declared\
    \ here\n    var bucketCapacity = 0\n        ^\n/tmp/tmpe3i97zyy.swift:56:9: error:\
    \ invalid redeclaration of 'bucketCapacity'\n    var bucketCapacity = 0\n    \
    \    ^\n/tmp/tmpe3i97zyy.swift:44:9: note: 'bucketCapacity' previously declared\
    \ here\n    var bucketCapacity = 0\n        ^\n/tmp/tmpe3i97zyy.swift:59:9: error:\
    \ invalid redeclaration of 'bucketCapacity'\n    var bucketCapacity = 0\n    \
    \    ^\n/tmp/tmpe3i97zyy.swift:44:9: note: 'bucketCapacity' previously declared\
    \ here\n    var bucketCapacity = 0\n        ^\n/tmp/tmpe3i97zyy.swift:62:9: error:\
    \ invalid redeclaration of 'bucketCapacity'\n    var bucketCapacity = 0\n    \
    \    ^\n/tmp/tmpe3i97zyy.swift:44:9: note: 'bucketCapacity' previously declared\
    \ here\n    var bucketCapacity = 0\n        ^\n/tmp/tmpe3i97zyy.swift:65:9: error:\
    \ invalid redeclaration of 'bucketCapacity'\n    var bucketCapacity = 0\n    \
    \    ^\n/tmp/tmpe3i97zyy.swift:44:9: note: 'bucketCapacity' previously declared\
    \ here\n    var bucketCapacity = 0\n        ^\n/tmp/tmpe3i97zyy.swift:68:9: error:\
    \ invalid redeclaration of 'bucketCapacity'\n    var bucketCapacity = 0\n    \
    \    ^\n/tmp/tmpe3i97zyy.swift:44:9: note: 'bucketCapacity' previously declared\
    \ here\n    var bucketCapacity = 0\n        ^\n/tmp/tmpe3i97zyy.swift:71:9: error:\
    \ invalid redeclaration of 'bucketCapacity'\n    var bucketCapacity = 0\n    \
    \    ^\n/tmp/tmpe3i97zyy.swift:44:9: note: 'bucketCapacity' previously declared\
    \ here\n    var bucketCapacity ="
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var buckets = [Int](capacity)\n\
    \    \n    for row in grid {\n        for bucket in row {\n            buckets[bucket]\
    \ += 1\n        }\n    }\n    \n    var result = 0\n    \n    for bucket in buckets\
    \ {\n        if bucket > 0 {\n            result += bucket\n        }\n    }\n\
    \    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmps9pthh0y.swift:31:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824662
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // write your code here\n    \n\
    \    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpb8f0yy9_/tmpb8f0yy9_.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4229232c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4228f29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4228f29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4228f287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb8f0yy9_                        0x000055dcd7d3b3d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b422941e460 __libc_start_main +
    245

    6    tmpb8f0yy9_                        0x000055dcd7d3af69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var buckets = [Int](capacity)\n\
    \    for row in grid {\n        for bucket in row {\n            buckets[bucket]\
    \ += 1\n        }\n    }\n    for bucket in buckets {\n        if bucket > 0 {\n\
    \            result += bucket\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpmeviak5x.swift:31:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // init result\n    var result =\
    \ 0\n    \n    // init bucket array\n    var buckets = [Int](capacity)\n    \n\
    \    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket capacity\n\
    \    var bucketCapacity = capacity\n    \n    // init bucket count\n    var bucketCount\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket max index\n\
    \    var bucketMaxIndex = 0\n    \n    // init bucket min value\n    var bucketMinValue\
    \ = grid[0][0]\n    \n    // init bucket max value\n    var bucketMaxValue = grid[0][0]\n\
    \    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n    //\
    \ init bucket max index\n    var bucketMaxIndex = 0\n    \n    // init bucket\
    \ min value\n    var bucketMinValue = grid[0][0]\n    \n    // init bucket max\
    \ value\n    var bucketMaxValue = grid[0][0]\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket max index\n    var bucketMaxIndex\
    \ = 0\n    \n    // init bucket min value\n    var bucketMinValue = grid[0][0]\n\
    \    \n    // init bucket max value\n    var bucketMaxValue = grid[0][0]\n   \
    \ \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init\
    \ bucket max index\n    var bucketMaxIndex = 0\n    \n    // init bucket min value\n\
    \    var bucketMinValue = grid[0][0]\n    \n    // init bucket max value\n   \
    \ var bucketMaxValue = grid[0][0]\n    \n    // init bucket min index\n    var\
    \ bucketMinIndex = 0\n    \n    // init bucket max index\n    var bucketMaxIndex\
    \ = 0\n    \n    // init bucket min value\n    var bucketMinValue = grid[0][0]\n\
    \    \n    // init bucket max value\n    var bucketMaxValue = grid[0][0]\n   \
    \ \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init\
    \ bucket max index\n    var bucketMaxIndex = 0\n    \n    // init bucket min value\n\
    \    var bucketMinValue = grid[0][0]\n    \n    // init bucket max value\n   \
    \ var bucketMaxValue = grid[0][0]\n    \n    // init bucket min index\n    var\
    \ bucketMinIndex = 0\n    \n    // init bucket max index\n    var bucketMaxIndex\
    \ = 0\n    \n    // init bucket min value\n    var bucketMinValue = grid[0][0]\n\
    \    \n    // init bucket max value\n    var bucketMaxValue = grid[0][0]\n   \
    \ \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init\
    \ bucket max index\n    var bucketMaxIndex = 0\n    \n    // \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpus4hpcxl.swift:35:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpus4hpcxl.swift:62:9: error: invalid\
    \ redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpus4hpcxl.swift:50:9:\
    \ note: 'bucketMinIndex' previously declared here\n    var bucketMinIndex = 0\n\
    \        ^\n/tmp/tmpus4hpcxl.swift:65:9: error: invalid redeclaration of 'bucketMaxIndex'\n\
    \    var bucketMaxIndex = 0\n        ^\n/tmp/tmpus4hpcxl.swift:53:9: note: 'bucketMaxIndex'\
    \ previously declared here\n    var bucketMaxIndex = 0\n        ^\n/tmp/tmpus4hpcxl.swift:68:9:\
    \ error: invalid redeclaration of 'bucketMinValue'\n    var bucketMinValue = grid[0][0]\n\
    \        ^\n/tmp/tmpus4hpcxl.swift:56:9: note: 'bucketMinValue' previously declared\
    \ here\n    var bucketMinValue = grid[0][0]\n        ^\n/tmp/tmpus4hpcxl.swift:71:9:\
    \ error: invalid redeclaration of 'bucketMaxValue'\n    var bucketMaxValue = grid[0][0]\n\
    \        ^\n/tmp/tmpus4hpcxl.swift:59:9: note: 'bucketMaxValue' previously declared\
    \ here\n    var bucketMaxValue = grid[0][0]\n        ^\n/tmp/tmpus4hpcxl.swift:74:9:\
    \ error: invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n\
    \        ^\n/tmp/tmpus4hpcxl.swift:50:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpus4hpcxl.swift:77:9: error:\
    \ invalid redeclaration of 'bucketMaxIndex'\n    var bucketMaxIndex = 0\n    \
    \    ^\n/tmp/tmpus4hpcxl.swift:53:9: note: 'bucketMaxIndex' previously declared\
    \ here\n    var bucketMaxIndex = 0\n        ^\n/tmp/tmpus4hpcxl.swift:80:9: error:\
    \ invalid redeclaration of 'bucketMinValue'\n    var bucketMinValue = grid[0][0]\n\
    \        ^\n/tmp/tmpus4hpcxl.swift:56:9: note: 'bucketMinValue' previously declared\
    \ here\n    var bucketMinValue = grid[0][0]\n        ^\n/tmp/tmpus4hpcxl.swift:83:9:\
    \ error: invalid redeclaration of 'bucketMaxValue'\n    var bucketMaxValue = grid[0][0]\n\
    \        ^\n/tmp/tmpus4hpcxl.swift:59:9: note: 'bucketMaxValue' previously declared\
    \ here\n    var"
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var buckets = [Int](capacity)\n\
    \    var count = 0\n    for row in grid {\n        for col in row {\n        \
    \    if col == 1 {\n                buckets[col-1] += 1\n            }\n     \
    \   }\n    }\n    for bucket in buckets {\n        if bucket > 0 {\n         \
    \   count += bucket - 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpgmm_clyb.swift:31:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824662
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        var max = 0\n        for column in row {\n            if column == 0\
    \ {\n                max += capacity\n            } else {\n                max\
    \ += column\n            }\n        }\n        if max > result {\n           \
    \ result = max\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp3iroroob/tmp3iroroob.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b837ae82c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b837ab79b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b837ab79988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b837ab787b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3iroroob                        0x000055c9a23f1546 <unavailable> + 5446

    5    libc.so.6                          0x00002b837b06e460 __libc_start_main +
    245

    6    tmp3iroroob                        0x000055c9a23f10d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var buckets = [Int](capacity)\n\
    \    \n    for row in 0..<grid.count {\n        for col in 0..<grid[row].count\
    \ {\n            if grid[row][col] == 1 {\n                buckets[grid[row][col]]\
    \ += 1 \n            }\n        }\n    }\n    \n    var max = 0\n    \n    for\
    \ bucket in buckets {\n        if bucket > max {\n            max = bucket\n \
    \       }\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmpnq77hwe0.swift:31:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // write your code here\n    var\
    \ result = 0\n    var buckets = [Int](capacity)\n    for row in 0..<grid.count\
    \ {\n        for col in 0..<grid[row].count {\n            buckets[grid[row][col]]\
    \ += 1 \n        }\n    }\n    for bucket in buckets {\n        if bucket > 0\
    \ {\n            result += bucket\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp9zpw6pic.swift:33:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // init result\n    var result =\
    \ 0\n    \n    // init bucket array\n    var buckets = [Int](repeating: 0, count:\
    \ capacity)\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n \
    \   // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket max index\n\
    \    var bucketMaxIndex = 0\n    \n    // init bucket max value\n    var bucketMaxValue\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min value\n    var bucketMinValue = 0\n    \n    // init bucket\
    \ sum\n    var bucketSum = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min value\n    var bucketMinValue = 0\n    \n\
    \    // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket min value\n    var bucketMinValue\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket min value\n\
    \    var bucketMinValue = 0\n    \n    // init bucket sum\n    var bucketSum =\
    \ 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n  \
    \  // init bucket min value\n    var bucketMinValue = 0\n    \n    // init bucket\
    \ sum\n    var bucketSum = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min value\n    var bucketMinValue = 0\n    \n\
    \    // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket min value\n    var bucketMinValue\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket min value\n\
    \    var bucketMinValue = 0\n    \n    // init bucket sum\n    var bucketSum =\
    \ 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n  \
    \  // init bucket min value\n    var bucketMinValue = 0\n    \n    // init bucket\
    \ sum\n    var bucketSum = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min value\n    var bucketMinValue = 0\n    \n\
    \    // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket min value\n    var bucketMinValue\
    \ = 0\n    \n    // \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp5i75m7jj.swift:56:9: error: invalid redeclaration of 'bucketSum'\n\
    \    var bucketSum = 0\n        ^\n/tmp/tmp5i75m7jj.swift:41:9: note: 'bucketSum'\
    \ previously declared here\n    var bucketSum = 0\n        ^\n/tmp/tmp5i75m7jj.swift:59:9:\
    \ error: invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n\
    \        ^\n/tmp/tmp5i75m7jj.swift:50:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmp5i75m7jj.swift:62:9: error:\
    \ invalid redeclaration of 'bucketMinValue'\n    var bucketMinValue = 0\n    \
    \    ^\n/tmp/tmp5i75m7jj.swift:53:9: note: 'bucketMinValue' previously declared\
    \ here\n    var bucketMinValue = 0\n        ^\n/tmp/tmp5i75m7jj.swift:65:9: error:\
    \ invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n        ^\n/tmp/tmp5i75m7jj.swift:41:9:\
    \ note: 'bucketSum' previously declared here\n    var bucketSum = 0\n        ^\n\
    /tmp/tmp5i75m7jj.swift:68:9: error: invalid redeclaration of 'bucketMinIndex'\n\
    \    var bucketMinIndex = 0\n        ^\n/tmp/tmp5i75m7jj.swift:50:9: note: 'bucketMinIndex'\
    \ previously declared here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmp5i75m7jj.swift:71:9:\
    \ error: invalid redeclaration of 'bucketMinValue'\n    var bucketMinValue = 0\n\
    \        ^\n/tmp/tmp5i75m7jj.swift:53:9: note: 'bucketMinValue' previously declared\
    \ here\n    var bucketMinValue = 0\n        ^\n/tmp/tmp5i75m7jj.swift:74:9: error:\
    \ invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n        ^\n/tmp/tmp5i75m7jj.swift:41:9:\
    \ note: 'bucketSum' previously declared here\n    var bucketSum = 0\n        ^\n\
    /tmp/tmp5i75m7jj.swift:77:9: error: invalid redeclaration of 'bucketMinIndex'\n\
    \    var bucketMinIndex = 0\n        ^\n/tmp/tmp5i75m7jj.swift:50:9: note: 'bucketMinIndex'\
    \ previously declared here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmp5i75m7jj.swift:80:9:\
    \ error: invalid redeclaration of 'bucketMinValue'\n    var bucketMinValue = 0\n\
    \        ^\n/tmp/tmp5i75m7jj.swift:53:9: note: 'bucketMinValue' previously declared\
    \ here\n    var bucketMinValue = 0\n        ^\n/tmp/tmp5i75m7jj.swift:83:9: error:\
    \ invalid red"
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var count = 0\n    var minCapacity\
    \ = capacity\n    for row in grid {\n        var maxCapacity = capacity\n    \
    \    for col in row {\n            if col == 1 {\n                maxCapacity\
    \ = maxCapacity - grid[row][col]\n            }\n        }\n        if maxCapacity\
    \ < minCapacity {\n            minCapacity = maxCapacity\n        }\n    }\n \
    \   for row in grid {\n        for col in row {\n            if col == 1 {\n \
    \               count = count + minCapacity - grid[row][col]\n            }\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmpe7a0p2v7.swift:37:50: error: cannot convert value of type '[Int]'\
    \ to expected argument type 'Int'\n                maxCapacity = maxCapacity -\
    \ grid[row][col]\n                                                 ^\n/tmp/tmpe7a0p2v7.swift:47:52:\
    \ error: cannot convert value of type '[Int]' to expected argument type 'Int'\n\
    \                count = count + minCapacity - grid[row][col]\n              \
    \                                     ^\n"
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var max = 0\n    var count = 0\n    for\
    \ row in grid {\n        if row[0] == 0 {\n            count += row[1]\n     \
    \   }\n        if row[0] == 1 {\n            count += row[1]\n        }\n    \
    \    if row[0] == 2 {\n            count += row[1]\n        }\n        if row[0]\
    \ == 3 {\n            count += row[1]\n        }\n        if row[0] == 4 {\n \
    \           count += row[1]\n        }\n        if row[0] == 5 {\n           \
    \ count += row[1]\n        }\n        if row[0] == 6 {\n            count += row[1]\n\
    \        }\n        if row[0] == 7 {\n            count += row[1]\n        }\n\
    \        if row[0] == 8 {\n            count += row[1]\n        }\n        if\
    \ row[0] == 9 {\n            count += row[1]\n        }\n        if row[0] ==\
    \ 10 {\n            count += row[1]\n        }\n        if row[0] == 11 {\n  \
    \          count += row[1]\n        }\n        if row[0] == 12 {\n           \
    \ count += row[1]\n        }\n        if row[0] == 13 {\n            count +=\
    \ row[1]\n        }\n        if row[0] == 14 {\n            count += row[1]\n\
    \        }\n        if row[0] == 15 {\n            count += row[1]\n        }\n\
    \        if row[0] == 16 {\n            count += row[1]\n        }\n        if\
    \ row[0] == 17 {\n            count += row[1]\n        }\n        if row[0] ==\
    \ 18 {\n            count += row[1]\n        }\n        if row[0] == 19 {\n  \
    \          count += row[1]\n        }\n        if row[0] == 20 {\n           \
    \ count += row[1]\n        }\n        if row[0] == 21 {\n            count +=\
    \ row[1]\n        }\n        if row[0] == 22 {\n            count += row[1]\n\
    \        }\n        if row[0] == 23 {\n            count += row[1]\n        }\n\
    \        if row[0] == 24 {\n            count += row[1]\n        }\n        if\
    \ row[0] == 25 {\n            count += row[1]\n        }\n        if row[0] ==\
    \ 26 {\n            count += row[1]\n        }\n        if row[0] == 27 {\n  \
    \          count += row[1]\n        }\n        if row[0] == 28 {\n           \
    \ count += row[1]\n        }\n        if row[0] == 29 {\n            count +=\
    \ row[1]\n        }\n        if row[0] == 30 {\n            count += row[1]\n\
    \        }\n        if row[0] == 31 {\n            count += row[1]\n        }\n\
    \        if row[0] == 32 {\n            count += row[1]\n        }\n        if\
    \ row[0] == 33 {\n            count += row[1]\n        }\n        if row[0] ==\
    \ 34 {\n            count += row[1]\n        }\n        if row[0] == 35 {\n  \
    \          count += row[1]\n        }\n        if \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmprv1ep8be.swift:141:11: error: expected expression, var, or let\
    \ in 'if' condition\n        if \n          ^\n/tmp/tmprv1ep8be.swift:161:71:\
    \ error: expected '}' at end of brace statement\nassert(max_fill(grid: [[1, 1,\
    \ 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)\n                                 \
    \                                     ^\n/tmp/tmprv1ep8be.swift:29:52: note: to\
    \ match this opening '{'\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n\
    \                                                   ^\n/tmp/tmprv1ep8be.swift:145:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659824662
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // write your code here\n    \n\
    \    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpb8f0yy9_/tmpb8f0yy9_.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4229232c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4228f29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4228f29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4228f287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb8f0yy9_                        0x000055dcd7d3b3d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b422941e460 __libc_start_main +
    245

    6    tmpb8f0yy9_                        0x000055dcd7d3af69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824662
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        var max = 0\n        for cell in row {\n            if cell > max {\n\
    \                max = cell\n            }\n        }\n        result += max -\
    \ capacity\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmplbxx42kq/tmplbxx42kq.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acb8ef34c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acb8ec2bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acb8ec2b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acb8ec2a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplbxx42kq                        0x000055cd5406f546 <unavailable> + 5446

    5    libc.so.6                          0x00002acb8f120460 __libc_start_main +
    245

    6    tmplbxx42kq                        0x000055cd5406f0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // write your code here\n    \n\
    \    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpb8f0yy9_/tmpb8f0yy9_.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4229232c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4228f29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4228f29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4228f287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb8f0yy9_                        0x000055dcd7d3b3d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b422941e460 __libc_start_main +
    245

    6    tmpb8f0yy9_                        0x000055dcd7d3af69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824662
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // write your code here\n    \n\
    \    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpb8f0yy9_/tmpb8f0yy9_.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4229232c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4228f29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4228f29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4228f287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb8f0yy9_                        0x000055dcd7d3b3d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b422941e460 __libc_start_main +
    245

    6    tmpb8f0yy9_                        0x000055dcd7d3af69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824662
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var max = 0\n    var maxCount =\
    \ 0\n    var count = 0\n    \n    for row in grid {\n        for col in row {\n\
    \            if col == 1 {\n                count += 1\n            }\n      \
    \  }\n    }\n    \n    for row in grid {\n        for col in row {\n         \
    \   if col == 1 {\n                max += count\n                maxCount = count\n\
    \                count = 0\n            }\n        }\n    }\n    \n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpxruqoeti/tmpxruqoeti.swift:70: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b704579dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7045494b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7045494988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b70454937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxruqoeti                        0x000056176f0a8717 <unavailable> + 5911

    5    libc.so.6                          0x00002b7045989460 __libc_start_main +
    245

    6    tmpxruqoeti                        0x000056176f0a80d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var buckets = [Int](capacity)\n\
    \    for row in grid {\n        for bucket in row {\n            buckets[bucket]\
    \ += 1\n        }\n    }\n    for bucket in buckets {\n        if bucket > 0 {\n\
    \            result += bucket\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpmeviak5x.swift:31:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var count = 0\n    var buckets =\
    \ [Int](capacity)\n    \n    for row in grid {\n        for bucket in row {\n\
    \            buckets[bucket] += 1\n        }\n    }\n    \n    for bucket in buckets\
    \ {\n        if bucket > 0 {\n            count += bucket - 1\n        }\n   \
    \ }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpg6spx4yk.swift:32:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var count = 0\n    var max = 0\n\
    \    var buckets = [Int](capacity)\n    \n    for row in grid {\n        for col\
    \ in row {\n            if col == 1 {\n                buckets[col] = buckets[col]\
    \ + 1\n            }\n        }\n    }\n    \n    for bucket in buckets {\n  \
    \      if bucket > max {\n            max = bucket\n        }\n    }\n    \n \
    \   return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmprq1ond3s.swift:33:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var buckets = [Int](capacity)\n\
    \    for row in grid {\n        for bucket in row {\n            buckets[bucket]\
    \ += 1\n        }\n    }\n    for bucket in buckets {\n        if bucket > 0 {\n\
    \            result += bucket\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpmeviak5x.swift:31:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824662
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var count = 0\n    var max = 0\n\
    \    var min = 0\n    \n    for row in 0..<grid.count {\n        for col in 0..<grid[row].count\
    \ {\n            \n            if grid[row][col] == 1 {\n                \n  \
    \              let bucket = capacity - grid[row][col]\n                \n    \
    \            if bucket > max {\n                    max = bucket\n           \
    \     }\n                \n                if bucket < min {\n               \
    \     min = bucket\n                }\n                \n            }\n     \
    \   }\n    }\n    \n    count = max - min\n    \n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpyx1sxazv/tmpyx1sxazv.swift:72: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afa6db5ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa6d851b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afa6d851988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afa6d8507b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyx1sxazv                        0x000055a74e4b7656 <unavailable> + 5718

    5    libc.so.6                          0x00002afa6dd46460 __libc_start_main +
    245

    6    tmpyx1sxazv                        0x000055a74e4b71e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // write your code here\n    \n\
    \    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpb8f0yy9_/tmpb8f0yy9_.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4229232c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4228f29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4228f29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4228f287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb8f0yy9_                        0x000055dcd7d3b3d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b422941e460 __libc_start_main +
    245

    6    tmpb8f0yy9_                        0x000055dcd7d3af69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824662
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var result = 0\n    \n    for row\
    \ in grid {\n        for well in row {\n            if well != 0 {\n         \
    \       result += well * capacity\n            }\n        }\n    }\n    \n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp_mg6f6zm/tmp_mg6f6zm.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae0b00a6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae0afd9db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae0afd9d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae0afd9c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_mg6f6zm                        0x000055b496794717 <unavailable> + 5911

    5    libc.so.6                          0x00002ae0b0292460 __libc_start_main +
    245

    6    tmp_mg6f6zm                        0x000055b4967940d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824662
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var max = 0\n    var count = 0\n\
    \    \n    for row in grid {\n        for col in row {\n            if col ==\
    \ 0 {\n                max += capacity\n                count += 1\n         \
    \   } else {\n                max -= capacity\n            }\n        }\n    }\n\
    \    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp944lhy1d/tmp944lhy1d.swift:62: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b88d67cac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b88d64c1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b88d64c1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b88d64c07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp944lhy1d                        0x00005654b3b40717 <unavailable> + 5911

    5    libc.so.6                          0x00002b88d69b6460 __libc_start_main +
    245

    6    tmp944lhy1d                        0x00005654b3b400d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // 1. Initialize a variable to store\
    \ the maximum water that can be extracted in each bucket.\n    var maxWater =\
    \ [Int](capacity)\n    \n    // 2. Initialize a variable to store the index of\
    \ the first empty bucket in each row.\n    var firstEmptyRow = [Int](capacity)\n\
    \    \n    // 3. Initialize a variable to store the index of the first empty bucket\
    \ in each column.\n    var firstEmptyCol = [Int](capacity)\n    \n    // 4. Initialize\
    \ a variable to store the index of the first empty bucket in each row.\n    var\
    \ firstEmptyRow = [Int](capacity)\n    \n    // 5. Initialize a variable to store\
    \ the index of the first empty bucket in each column.\n    var firstEmptyCol =\
    \ [Int](capacity)\n    \n    // 6. Initialize a variable to store the index of\
    \ the first empty bucket in each row.\n    var firstEmptyRow = [Int](capacity)\n\
    \    \n    // 7. Initialize a variable to store the index of the first empty bucket\
    \ in each column.\n    var firstEmptyCol = [Int](capacity)\n    \n    // 8. Initialize\
    \ a variable to store the index of the first empty bucket in each row.\n    var\
    \ firstEmptyRow = [Int](capacity)\n    \n    // 9. Initialize a variable to store\
    \ the index of the first empty bucket in each column.\n    var firstEmptyCol =\
    \ [Int](capacity)\n    \n    // 10. Initialize a variable to store the index of\
    \ the first empty bucket in each row.\n    var firstEmptyRow = [Int](capacity)\n\
    \    \n    // 11. Initialize a variable to store the index of the first empty\
    \ bucket in each column.\n    var firstEmptyCol = [Int](capacity)\n    \n    //\
    \ 12. Initialize a variable to store the index of the first empty bucket in each\
    \ row.\n    var firstEmptyRow = [Int](capacity)\n    \n    // 13. Initialize a\
    \ variable to store the index of the first empty bucket in each column.\n    var\
    \ firstEmptyCol = [Int](capacity)\n    \n    // 14. Initialize a variable to store\
    \ the index of the first empty bucket in each row.\n    var firstEmptyRow = [Int](capacity)\n\
    \    \n    // 15. Initialize a variable to store the index of the first empty\
    \ bucket in each column.\n    var firstEmptyCol = [Int](capacity)\n    \n    //\
    \ 16. Initialize a variable to store the index of the first empty bucket in each\
    \ row.\n    var firstEmptyRow = [Int](capacity)\n    \n    // 17. Initialize a\
    \ variable to store the index of the first empty bucket in each column.\n    var\
    \ firstEmptyCol = [Int](capacity)\n    \n    // 18. Initialize a variable to store\
    \ the index of the first empty bucket in each row.\n    var first\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmptt978dxn.swift:32:26: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var maxWater = [Int](capacity)\n                         ^\n  \
    \                       arrayLiteral: \n/tmp/tmptt978dxn.swift:35:31: error: missing\
    \ argument label 'arrayLiteral:' in call\n    var firstEmptyRow = [Int](capacity)\n\
    \                              ^\n                              arrayLiteral:\
    \ \n/tmp/tmptt978dxn.swift:38:31: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var firstEmptyCol = [Int](capacity)\n                         \
    \     ^\n                              arrayLiteral: \n/tmp/tmptt978dxn.swift:41:31:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var firstEmptyRow\
    \ = [Int](capacity)\n                              ^\n                       \
    \       arrayLiteral: \n/tmp/tmptt978dxn.swift:44:31: error: missing argument\
    \ label 'arrayLiteral:' in call\n    var firstEmptyCol = [Int](capacity)\n   \
    \                           ^\n                              arrayLiteral: \n\
    /tmp/tmptt978dxn.swift:47:31: error: missing argument label 'arrayLiteral:' in\
    \ call\n    var firstEmptyRow = [Int](capacity)\n                            \
    \  ^\n                              arrayLiteral: \n/tmp/tmptt978dxn.swift:50:31:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var firstEmptyCol\
    \ = [Int](capacity)\n                              ^\n                       \
    \       arrayLiteral: \n/tmp/tmptt978dxn.swift:53:31: error: missing argument\
    \ label 'arrayLiteral:' in call\n    var firstEmptyRow = [Int](capacity)\n   \
    \                           ^\n                              arrayLiteral: \n\
    /tmp/tmptt978dxn.swift:56:31: error: missing argument label 'arrayLiteral:' in\
    \ call\n    var firstEmptyCol = [Int](capacity)\n                            \
    \  ^\n                              arrayLiteral: \n/tmp/tmptt978dxn.swift:59:31:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var firstEmptyRow\
    \ = [Int](capacity)\n                              ^\n                       \
    \       arrayLiteral: \n/tmp/tmptt978dxn.swift:62:31: error: missing argument"
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // init result\n    var result =\
    \ 0\n    \n    // init buckets\n    var buckets = [Int](capacity)\n    \n    //\
    \ init wells\n    var wells = [Int](grid.count)\n    \n    // init wells index\n\
    \    var wells_index = 0\n    \n    // init grid index\n    var grid_index = 0\n\
    \    \n    // init grid length\n    var grid_length = grid.count\n    \n    //\
    \ init grid capacity\n    var grid_capacity = grid.count\n    \n    // init grid\
    \ capacity\n    var grid_capacity = grid.count\n    \n    // init grid capacity\n\
    \    var grid_capacity = grid.count\n    \n    // init grid capacity\n    var\
    \ grid_capacity = grid.count\n    \n    // init grid capacity\n    var grid_capacity\
    \ = grid.count\n    \n    // init grid capacity\n    var grid_capacity = grid.count\n\
    \    \n    // init grid capacity\n    var grid_capacity = grid.count\n    \n \
    \   // init grid capacity\n    var grid_capacity = grid.count\n    \n    // init\
    \ grid capacity\n    var grid_capacity = grid.count\n    \n    // init grid capacity\n\
    \    var grid_capacity = grid.count\n    \n    // init grid capacity\n    var\
    \ grid_capacity = grid.count\n    \n    // init grid capacity\n    var grid_capacity\
    \ = grid.count\n    \n    // init grid capacity\n    var grid_capacity = grid.count\n\
    \    \n    // init grid capacity\n    var grid_capacity = grid.count\n    \n \
    \   // init grid capacity\n    var grid_capacity = grid.count\n    \n    // init\
    \ grid capacity\n    var grid_capacity = grid.count\n    \n    // init grid capacity\n\
    \    var grid_capacity = grid.count\n    \n    // init grid capacity\n    var\
    \ grid_capacity = grid.count\n    \n    // init grid capacity\n    var grid_capacity\
    \ = grid.count\n    \n    // init grid capacity\n    var grid_capacity = grid.count\n\
    \    \n    // init grid capacity\n    var grid_capacity = grid.count\n    \n \
    \   // init grid capacity\n    var grid_capacity = grid.count\n    \n    // init\
    \ grid capacity\n    var grid_capacity = grid.count\n    \n    // init grid capacity\n\
    \    var grid_capacity = grid.count\n    \n    // init grid capacity\n    var\
    \ grid_capacity = grid.count\n    \n    // init grid capacity\n    var grid_capacity\
    \ = grid.count\n    \n    // init grid capacity\n    var grid_capacity = grid.count\n\
    \    \n    // init grid capacity\n    var grid_capacity = grid.count\n    \n \
    \   // init grid capacity\n    var grid_capacity = grid.count\n    \n    // init\
    \ grid capacity\n    var grid_capacity = grid.count\n    \n    // init grid capacity\n\
    \    var grid_capacity = grid.\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpyrqr5mav.swift:140:29: error: expected member name following '.'\n\
    \    var grid_capacity = grid.\n                            ^\n/tmp/tmpyrqr5mav.swift:35:25:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var buckets = [Int](capacity)\n\
    \                        ^\n                        arrayLiteral: \n/tmp/tmpyrqr5mav.swift:38:23:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var wells = [Int](grid.count)\n\
    \                      ^\n                      arrayLiteral: \n/tmp/tmpyrqr5mav.swift:53:9:\
    \ error: invalid redeclaration of 'grid_capacity'\n    var grid_capacity = grid.count\n\
    \        ^\n/tmp/tmpyrqr5mav.swift:50:9: note: 'grid_capacity' previously declared\
    \ here\n    var grid_capacity = grid.count\n        ^\n/tmp/tmpyrqr5mav.swift:56:9:\
    \ error: invalid redeclaration of 'grid_capacity'\n    var grid_capacity = grid.count\n\
    \        ^\n/tmp/tmpyrqr5mav.swift:50:9: note: 'grid_capacity' previously declared\
    \ here\n    var grid_capacity = grid.count\n        ^\n/tmp/tmpyrqr5mav.swift:59:9:\
    \ error: invalid redeclaration of 'grid_capacity'\n    var grid_capacity = grid.count\n\
    \        ^\n/tmp/tmpyrqr5mav.swift:50:9: note: 'grid_capacity' previously declared\
    \ here\n    var grid_capacity = grid.count\n        ^\n/tmp/tmpyrqr5mav.swift:62:9:\
    \ error: invalid redeclaration of 'grid_capacity'\n    var grid_capacity = grid.count\n\
    \        ^\n/tmp/tmpyrqr5mav.swift:50:9: note: 'grid_capacity' previously declared\
    \ here\n    var grid_capacity = grid.count\n        ^\n/tmp/tmpyrqr5mav.swift:65:9:\
    \ error: invalid redeclaration of 'grid_capacity'\n    var grid_capacity = grid.count\n\
    \        ^\n/tmp/tmpyrqr5mav.swift:50:9: note: 'grid_capacity' previously declared\
    \ here\n    var grid_capacity = grid.count\n        ^\n/tmp/tmpyrqr5mav.swift:68:9:\
    \ error: invalid redeclaration of 'grid_capacity'\n    var grid_capacity = grid.count\n\
    \        ^\n/tmp/tmpyrqr5mav.swift:50:9: note: 'grid_capacity' previously declared\
    \ here\n    var grid_capacity = grid.count\n        ^\n/tmp/tmpyrqr5mav.swift:71:9:\
    \ error: invalid redeclaration of 'grid_capacity'\n    var grid_capac"
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // write your code here\n    \n\
    \    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpb8f0yy9_/tmpb8f0yy9_.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4229232c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4228f29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4228f29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4228f287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb8f0yy9_                        0x000055dcd7d3b3d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b422941e460 __libc_start_main +
    245

    6    tmpb8f0yy9_                        0x000055dcd7d3af69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var buckets = [Int](capacity)\n\
    \    for row in grid {\n        for col in row {\n            buckets[col] +=\
    \ 1 \n        }\n    }\n    for bucket in buckets {\n        if bucket > 0 {\n\
    \            result += bucket\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmprvl254zz.swift:31:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var result = 0\n    var buckets\
    \ = [Int](capacity)\n    \n    for row in 0..<grid.count {\n        for col in\
    \ 0..<grid[row].count {\n            if grid[row][col] == 1 {\n              \
    \  buckets[grid[row][col]] += 1 \n            }\n        }\n    }\n    \n    for\
    \ bucket in buckets {\n        if bucket > 0 {\n            result += bucket\n\
    \        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmp3oyrj9z_.swift:32:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var result = 0\n    var buckets\
    \ = [Int](capacity)\n    \n    for row in grid {\n        for col in row {\n \
    \           buckets[col] += 1 \n        }\n    }\n    \n    for bucket in buckets\
    \ {\n        if bucket > 0 {\n            result += bucket\n        }\n    }\n\
    \    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmphns5uquf.swift:32:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var count = 0\n    var max = 0\n    var\
    \ maxIndex = 0\n    for row in grid {\n        for col in row {\n            if\
    \ col == 0 {\n                count += 1\n            } else {\n             \
    \   count -= 1\n            }\n            if count > max {\n                max\
    \ = count\n                maxIndex = col\n            }\n        }\n    }\n \
    \   return maxIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp2hvb4g_0/tmp2hvb4g_0.swift:62: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8e6d72fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8e6d426b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8e6d426988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8e6d4257b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2hvb4g_0                        0x000055a228e74546 <unavailable> + 5446

    5    libc.so.6                          0x00002b8e6d91b460 __libc_start_main +
    245

    6    tmp2hvb4g_0                        0x000055a228e740d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        for bucket in row {\n            if bucket > capacity {\n           \
    \     result += bucket - capacity\n            } else {\n                result\
    \ += capacity\n            }\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmppdrcj3gr/tmppdrcj3gr.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab3252a5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab324f9cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab324f9c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab324f9b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppdrcj3gr                        0x0000557d1359a546 <unavailable> + 5446

    5    libc.so.6                          0x00002ab325491460 __libc_start_main +
    245

    6    tmppdrcj3gr                        0x0000557d1359a0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var result = 0\n    var buckets\
    \ = [Int](capacity)\n    \n    for row in grid {\n        for col in row {\n \
    \           buckets[col] += 1 \n        }\n    }\n    \n    for bucket in buckets\
    \ {\n        if bucket > 0 {\n            result += bucket\n        }\n    }\n\
    \    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmphns5uquf.swift:32:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var minBucket = Int()\n\
    \    for row in 0..<grid.count {\n        for col in 0..<grid[row].count {\n \
    \           if grid[row][col] == 1 {\n                minBucket = min(minBucket,\
    \ buckets[row][col])\n            }\n        }\n    }\n    for row in 0..<grid.count\
    \ {\n        for col in 0..<grid[row].count {\n            if grid[row][col] ==\
    \ 1 {\n                buckets[row][col] -= minBucket\n                result\
    \ += minBucket * minBucket / capacity\n            }\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpbb27kmd2.swift:35:44: error: cannot find 'buckets' in scope\n \
    \               minBucket = min(minBucket, buckets[row][col])\n              \
    \                             ^~~~~~~\n/tmp/tmpbb27kmd2.swift:42:17: error: cannot\
    \ find 'buckets' in scope\n                buckets[row][col] -= minBucket\n  \
    \              ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var max = 0\n    var count = 0\n\
    \    \n    for row in grid {\n        for col in row {\n            if col ==\
    \ 1 {\n                count += capacity - grid[row-1][col-1]\n              \
    \  grid[row-1][col-1] = 0\n            }\n            \n            if count >\
    \ max {\n                max = count\n            }\n            count = 0\n \
    \       }\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmphrqayyh2.swift:37:42: error: cannot convert value of type '[Int]'\
    \ to expected argument type 'Int'\n                count += capacity - grid[row-1][col-1]\n\
    \                                         ^\n/tmp/tmphrqayyh2.swift:38:22: error:\
    \ cannot convert value of type '[Int]' to expected argument type 'Int'\n     \
    \           grid[row-1][col-1] = 0\n                     ^\n/tmp/tmphrqayyh2.swift:38:28:\
    \ error: cannot assign through subscript: 'grid' is a 'let' constant\n       \
    \         grid[row-1][col-1] = 0\n                ~~~~       ^\n"
  stdout: ''
  timestamp: 1659824663
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // write your code here\n    \n\
    \    var count = 0\n    \n    for row in grid {\n        for col in row {\n  \
    \          if col == 0 {\n                count += max_fill(grid: grid, capacity:\
    \ capacity)\n            }\n        }\n    }\n    \n    return count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var buckets = [Int](capacity)\n\
    \    for row in grid {\n        for bucket in row {\n            buckets[bucket]\
    \ += 1\n        }\n    }\n    for bucket in buckets {\n        result += bucket\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpv1_h8g5p.swift:31:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // write your code here\n    \n\
    \    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpb8f0yy9_/tmpb8f0yy9_.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4229232c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4228f29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4228f29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4228f287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb8f0yy9_                        0x000055dcd7d3b3d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b422941e460 __libc_start_main +
    245

    6    tmpb8f0yy9_                        0x000055dcd7d3af69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // init result\n    var result =\
    \ 0\n    \n    // init bucket array\n    var buckets = [Int](repeating: 0, count:\
    \ capacity)\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n \
    \   // init bucket capacity\n    var bucketCapacity = capacity\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket capacity\n \
    \   var bucketCapacity = capacity\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = capacity\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ capacity\n    var bucketCapacity = capacity\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = capacity\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n\
    \    // init bucket capacity\n    var bucketCapacity = capacity\n    \n    //\
    \ init bucket index\n    var bucketIndex = 0\n    \n    // init bucket capacity\n\
    \    var bucketCapacity = capacity\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = capacity\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ capacity\n    var bucketCapacity = capacity\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = capacity\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n\
    \    // init bucket capacity\n    var bucketCapacity = capacity\n    \n    //\
    \ init bucket index\n    var bucketIndex = 0\n    \n    // init bucket capacity\n\
    \    var bucketCapacity = capacity\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = capacity\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ capacity\n    var bucketCapacity = capacity\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = capacity\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n\
    \    // init bucket capacity\n    var bucketCapacity = capacity\n    \n    //\
    \ init bucket index\n    var bucketIndex = 0\n    \n    // init bucket capacity\n\
    \    var bucketCapacity = capacity\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = capacity\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ capacity\n    var bucketCapacity = capacity\n    \n    // init bucket index\n\
    \    var \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp6emgpbyu.swift:152:8: error: expected pattern\n    var \n     \
    \  ^\n/tmp/tmp6emgpbyu.swift:44:9: error: invalid redeclaration of 'bucketIndex'\n\
    \    var bucketIndex = 0\n        ^\n/tmp/tmp6emgpbyu.swift:38:9: note: 'bucketIndex'\
    \ previously declared here\n    var bucketIndex = 0\n        ^\n/tmp/tmp6emgpbyu.swift:47:9:\
    \ error: invalid redeclaration of 'bucketCapacity'\n    var bucketCapacity = capacity\n\
    \        ^\n/tmp/tmp6emgpbyu.swift:41:9: note: 'bucketCapacity' previously declared\
    \ here\n    var bucketCapacity = capacity\n        ^\n/tmp/tmp6emgpbyu.swift:50:9:\
    \ error: invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n   \
    \     ^\n/tmp/tmp6emgpbyu.swift:38:9: note: 'bucketIndex' previously declared\
    \ here\n    var bucketIndex = 0\n        ^\n/tmp/tmp6emgpbyu.swift:53:9: error:\
    \ invalid redeclaration of 'bucketCapacity'\n    var bucketCapacity = capacity\n\
    \        ^\n/tmp/tmp6emgpbyu.swift:41:9: note: 'bucketCapacity' previously declared\
    \ here\n    var bucketCapacity = capacity\n        ^\n/tmp/tmp6emgpbyu.swift:56:9:\
    \ error: invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n   \
    \     ^\n/tmp/tmp6emgpbyu.swift:38:9: note: 'bucketIndex' previously declared\
    \ here\n    var bucketIndex = 0\n        ^\n/tmp/tmp6emgpbyu.swift:59:9: error:\
    \ invalid redeclaration of 'bucketCapacity'\n    var bucketCapacity = capacity\n\
    \        ^\n/tmp/tmp6emgpbyu.swift:41:9: note: 'bucketCapacity' previously declared\
    \ here\n    var bucketCapacity = capacity\n        ^\n/tmp/tmp6emgpbyu.swift:62:9:\
    \ error: invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n   \
    \     ^\n/tmp/tmp6emgpbyu.swift:38:9: note: 'bucketIndex' previously declared\
    \ here\n    var bucketIndex = 0\n        ^\n/tmp/tmp6emgpbyu.swift:65:9: error:\
    \ invalid redeclaration of 'bucketCapacity'\n    var bucketCapacity = capacity\n\
    \        ^\n/tmp/tmp6emgpbyu.swift:41:9: note: 'bucketCapacity' previously declared\
    \ here\n    var bucketCapacity = capacity\n        ^\n/tmp/tmp6emgpbyu.swift:68:9:\
    \ error: invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n   \
    \     ^\n/tmp/tmp6emgpbyu.swift:38:9"
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var buckets = [Int](capacity)\n\
    \    for row in grid {\n        for bucket in row {\n            buckets[bucket]\
    \ += 1\n        }\n    }\n    for bucket in buckets {\n        result += bucket\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpv1_h8g5p.swift:31:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var max = 0\n    var buckets = make([][]int,\
    \ capacity)\n    for row in grid {\n        for col in row {\n            if col\
    \ == 1 {\n                buckets[col%capacity]++\n            }\n        }\n\
    \    }\n    for bucket in buckets {\n        if bucket > max {\n            max\
    \ = bucket\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmp6ecfz0q_.swift:31:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmp6ecfz0q_.swift:31:19: error: cannot find 'make' in scope\n\
    \    var buckets = make([][]int, capacity)\n                  ^~~~\n/tmp/tmp6ecfz0q_.swift:31:28:\
    \ error: cannot find 'int' in scope\n    var buckets = make([][]int, capacity)\n\
    \                           ^~~\n/tmp/tmp6ecfz0q_.swift:31:27: error: missing\
    \ argument for parameter #1 in call\n    var buckets = make([][]int, capacity)\n\
    \                          ^\n                          <#Int#>\nSwift.Array:16:23:\
    \ note: 'subscript(_:)' declared here\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\n/tmp/tmp6ecfz0q_.swift:35:38:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \      buckets[col%capacity]++\n                                     ^~\n"
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // TODO: write your code here\n\
    \    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp8hxygw_q/tmp8hxygw_q.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad8e0b69c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad8e0860b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad8e0860988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad8e085f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8hxygw_q                        0x000055fa6e2cf3d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ad8e0d55460 __libc_start_main +
    245

    6    tmp8hxygw_q                        0x000055fa6e2cef69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    let rowCount = grid.count\n    let\
    \ colCount = grid[0].count\n    \n    var max = 0\n    \n    for row in 0..<rowCount\
    \ {\n        for col in 0..<colCount {\n            if grid[row][col] == 1 {\n\
    \                \n                let bucket = bucketCapacity(grid, row, col,\
    \ capacity)\n                \n                if bucket > max {\n           \
    \         max = bucket\n                }\n            }\n        }\n    }\n \
    \   \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpkw65u0os.swift:40:30: error: cannot find 'bucketCapacity' in scope\n\
    \                let bucket = bucketCapacity(grid, row, col, capacity)\n     \
    \                        ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var buckets = [Int](capacity)\n\
    \    for row in grid {\n        for col in row {\n            buckets[col] +=\
    \ (col == 0) ? 0 : -1\n        }\n    }\n    for bucket in buckets {\n       \
    \ if bucket > 0 {\n            result += bucket\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmphjajwppg.swift:31:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // TODO: Write your code here\n\
    \    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp71ubdu3k/tmp71ubdu3k.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba57d6acc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba57d3a3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba57d3a3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba57d3a27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp71ubdu3k                        0x0000555f347543d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba57d898460 __libc_start_main +
    245

    6    tmp71ubdu3k                        0x0000555f34753f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    if grid.isEmpty {\n        return 0\n\
    \    }\n    \n    var max = 0\n    var maxIndex = 0\n    \n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                grid[i][j] = 0\n                \n                let newCapacity\
    \ = grid[i][j] + capacity\n                \n                if newCapacity >\
    \ max {\n                    max = newCapacity\n                    maxIndex =\
    \ i\n                }\n            }\n        }\n    }\n    \n    return maxIndex\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpfhpxv6uk.swift:40:24: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                grid[i][j] = 0\n                ~~~~  \
    \ ^\n"
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // write your code here\n    \n\
    \    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpb8f0yy9_/tmpb8f0yy9_.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4229232c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4228f29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4228f29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4228f287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb8f0yy9_                        0x000055dcd7d3b3d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b422941e460 __libc_start_main +
    245

    6    tmpb8f0yy9_                        0x000055dcd7d3af69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824662
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    let n = grid.count\n    \n    var\
    \ max = 0\n    \n    for i in 0..<n {\n        for j in 0..<n {\n            if\
    \ grid[i][j] == 1 {\n                max += capacity\n            }\n        }\n\
    \    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp7k02a_k3/tmp7k02a_k3.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba983736c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba98342db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba98342d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba98342c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7k02a_k3                        0x0000559638a10606 <unavailable> + 5638

    5    libc.so.6                          0x00002ba983922460 __libc_start_main +
    245

    6    tmp7k02a_k3                        0x0000559638a10199 <unavailable> + 4505

    '
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // init result\n    var result =\
    \ 0\n    \n    // init buckets\n    var buckets = [Int](capacity)\n    \n    //\
    \ init wells\n    var wells = [Int](capacity)\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init well index\n    var wellIndex = 0\n\
    \    \n    // init grid index\n    var gridIndex = 0\n    \n    // init bucket\
    \ capacity\n    var bucketCapacity = capacity\n    \n    // init well capacity\n\
    \    var wellCapacity = capacity\n    \n    // init grid capacity\n    var gridCapacity\
    \ = capacity\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n\
    \    // init well index\n    var wellIndex = 0\n    \n    // init grid index\n\
    \    var gridIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = capacity\n    \n    // init well capacity\n    var wellCapacity = capacity\n\
    \    \n    // init grid capacity\n    var gridCapacity = capacity\n    \n    //\
    \ init bucket index\n    var bucketIndex = 0\n    \n    // init well index\n \
    \   var wellIndex = 0\n    \n    // init grid index\n    var gridIndex = 0\n \
    \   \n    // init bucket capacity\n    var bucketCapacity = capacity\n    \n \
    \   // init well capacity\n    var wellCapacity = capacity\n    \n    // init\
    \ grid capacity\n    var gridCapacity = capacity\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init well index\n    var wellIndex = 0\n\
    \    \n    // init grid index\n    var gridIndex = 0\n    \n    // init bucket\
    \ capacity\n    var bucketCapacity = capacity\n    \n    // init well capacity\n\
    \    var wellCapacity = capacity\n    \n    // init grid capacity\n    var gridCapacity\
    \ = capacity\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n\
    \    // init well index\n    var wellIndex = 0\n    \n    // init grid index\n\
    \    var gridIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = capacity\n    \n    // init well capacity\n    var wellCapacity = capacity\n\
    \    \n    // init grid capacity\n    var gridCapacity = capacity\n    \n    //\
    \ init bucket index\n    var bucketIndex = 0\n    \n    // init well index\n \
    \   var wellIndex = 0\n    \n    // init grid index\n    var gridIndex = 0\n \
    \   \n    // init bucket capacity\n    var bucketCapacity = capacity\n    \n \
    \   // init well capacity\n    var wellCapacity = capacity\n    \n    // init\
    \ grid capacity\n    var gridCapacity = capacity\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init well index\n    var \n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmptir414dq.swift:152:8: error: expected pattern\n    var \n     \
    \  ^\n/tmp/tmptir414dq.swift:35:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmptir414dq.swift:38:23: error: missing\
    \ argument label 'arrayLiteral:' in call\n    var wells = [Int](capacity)\n  \
    \                    ^\n                      arrayLiteral: \n/tmp/tmptir414dq.swift:59:9:\
    \ error: invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n   \
    \     ^\n/tmp/tmptir414dq.swift:41:9: note: 'bucketIndex' previously declared\
    \ here\n    var bucketIndex = 0\n        ^\n/tmp/tmptir414dq.swift:62:9: error:\
    \ invalid redeclaration of 'wellIndex'\n    var wellIndex = 0\n        ^\n/tmp/tmptir414dq.swift:44:9:\
    \ note: 'wellIndex' previously declared here\n    var wellIndex = 0\n        ^\n\
    /tmp/tmptir414dq.swift:65:9: error: invalid redeclaration of 'gridIndex'\n   \
    \ var gridIndex = 0\n        ^\n/tmp/tmptir414dq.swift:47:9: note: 'gridIndex'\
    \ previously declared here\n    var gridIndex = 0\n        ^\n/tmp/tmptir414dq.swift:68:9:\
    \ error: invalid redeclaration of 'bucketCapacity'\n    var bucketCapacity = capacity\n\
    \        ^\n/tmp/tmptir414dq.swift:50:9: note: 'bucketCapacity' previously declared\
    \ here\n    var bucketCapacity = capacity\n        ^\n/tmp/tmptir414dq.swift:71:9:\
    \ error: invalid redeclaration of 'wellCapacity'\n    var wellCapacity = capacity\n\
    \        ^\n/tmp/tmptir414dq.swift:53:9: note: 'wellCapacity' previously declared\
    \ here\n    var wellCapacity = capacity\n        ^\n/tmp/tmptir414dq.swift:74:9:\
    \ error: invalid redeclaration of 'gridCapacity'\n    var gridCapacity = capacity\n\
    \        ^\n/tmp/tmptir414dq.swift:56:9: note: 'gridCapacity' previously declared\
    \ here\n    var gridCapacity = capacity\n        ^\n/tmp/tmptir414dq.swift:77:9:\
    \ error: invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n   \
    \     ^\n/tmp/tmptir414dq.swift:41:9: note: 'bucketIndex' previously declared\
    \ here\n    var bucketIndex = 0\n        ^\n/tmp/tmptir414dq.swift:80:9: error:\
    \ invalid redecla"
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        for col in row {\n            if col == 0 {\n                result +=\
    \ max_fill_helper(grid, row, col, capacity)\n            }\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpdg0lo_i8.swift:34:27: error: cannot find 'max_fill_helper' in scope\n\
    \                result += max_fill_helper(grid, row, col, capacity)\n       \
    \                   ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // init result\n    var result =\
    \ 0\n    \n    // init buckets\n    var buckets = [Int](capacity)\n    \n    //\
    \ init bucket index\n    var bucketIndex = 0\n    \n    // init grid index\n \
    \   var gridIndex = 0\n    \n    // init grid length\n    var gridLength = grid[0].count\n\
    \    \n    // init grid capacity\n    var gridCapacity = grid[0].count\n    \n\
    \    // init grid capacity\n    var gridCapacity = grid[0].count\n    \n    //\
    \ init grid capacity\n    var gridCapacity = grid[0].count\n    \n    // init\
    \ grid capacity\n    var gridCapacity = grid[0].count\n    \n    // init grid\
    \ capacity\n    var gridCapacity = grid[0].count\n    \n    // init grid capacity\n\
    \    var gridCapacity = grid[0].count\n    \n    // init grid capacity\n    var\
    \ gridCapacity = grid[0].count\n    \n    // init grid capacity\n    var gridCapacity\
    \ = grid[0].count\n    \n    // init grid capacity\n    var gridCapacity = grid[0].count\n\
    \    \n    // init grid capacity\n    var gridCapacity = grid[0].count\n    \n\
    \    // init grid capacity\n    var gridCapacity = grid[0].count\n    \n    //\
    \ init grid capacity\n    var gridCapacity = grid[0].count\n    \n    // init\
    \ grid capacity\n    var gridCapacity = grid[0].count\n    \n    // init grid\
    \ capacity\n    var gridCapacity = grid[0].count\n    \n    // init grid capacity\n\
    \    var gridCapacity = grid[0].count\n    \n    // init grid capacity\n    var\
    \ gridCapacity = grid[0].count\n    \n    // init grid capacity\n    var gridCapacity\
    \ = grid[0].count\n    \n    // init grid capacity\n    var gridCapacity = grid[0].count\n\
    \    \n    // init grid capacity\n    var gridCapacity = grid[0].count\n    \n\
    \    // init grid capacity\n    var gridCapacity = grid[0].count\n    \n    //\
    \ init grid capacity\n    var gridCapacity = grid[0].count\n    \n    // init\
    \ grid capacity\n    var gridCapacity = grid[0].count\n    \n    // init grid\
    \ capacity\n    var gridCapacity = grid[0].count\n    \n    // init grid capacity\n\
    \    var gridCapacity = grid[0].count\n    \n    // init grid capacity\n    var\
    \ gridCapacity = grid[0].count\n    \n    // init grid capacity\n    var gridCapacity\
    \ = grid[0].count\n    \n    // init grid capacity\n    var gridCapacity = grid[0].count\n\
    \    \n    // init grid capacity\n    var gridCapacity = grid[0].count\n    \n\
    \    // init grid capacity\n    var gridCapacity = grid[0].count\n    \n    //\
    \ init grid capacity\n    var gridCapacity = grid[0].\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpmx6rwrt2.swift:134:31: error: expected member name following '.'\n\
    \    var gridCapacity = grid[0].\n                              ^\n/tmp/tmpmx6rwrt2.swift:35:25:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var buckets = [Int](capacity)\n\
    \                        ^\n                        arrayLiteral: \n/tmp/tmpmx6rwrt2.swift:50:9:\
    \ error: invalid redeclaration of 'gridCapacity'\n    var gridCapacity = grid[0].count\n\
    \        ^\n/tmp/tmpmx6rwrt2.swift:47:9: note: 'gridCapacity' previously declared\
    \ here\n    var gridCapacity = grid[0].count\n        ^\n/tmp/tmpmx6rwrt2.swift:53:9:\
    \ error: invalid redeclaration of 'gridCapacity'\n    var gridCapacity = grid[0].count\n\
    \        ^\n/tmp/tmpmx6rwrt2.swift:47:9: note: 'gridCapacity' previously declared\
    \ here\n    var gridCapacity = grid[0].count\n        ^\n/tmp/tmpmx6rwrt2.swift:56:9:\
    \ error: invalid redeclaration of 'gridCapacity'\n    var gridCapacity = grid[0].count\n\
    \        ^\n/tmp/tmpmx6rwrt2.swift:47:9: note: 'gridCapacity' previously declared\
    \ here\n    var gridCapacity = grid[0].count\n        ^\n/tmp/tmpmx6rwrt2.swift:59:9:\
    \ error: invalid redeclaration of 'gridCapacity'\n    var gridCapacity = grid[0].count\n\
    \        ^\n/tmp/tmpmx6rwrt2.swift:47:9: note: 'gridCapacity' previously declared\
    \ here\n    var gridCapacity = grid[0].count\n        ^\n/tmp/tmpmx6rwrt2.swift:62:9:\
    \ error: invalid redeclaration of 'gridCapacity'\n    var gridCapacity = grid[0].count\n\
    \        ^\n/tmp/tmpmx6rwrt2.swift:47:9: note: 'gridCapacity' previously declared\
    \ here\n    var gridCapacity = grid[0].count\n        ^\n/tmp/tmpmx6rwrt2.swift:65:9:\
    \ error: invalid redeclaration of 'gridCapacity'\n    var gridCapacity = grid[0].count\n\
    \        ^\n/tmp/tmpmx6rwrt2.swift:47:9: note: 'gridCapacity' previously declared\
    \ here\n    var gridCapacity = grid[0].count\n        ^\n/tmp/tmpmx6rwrt2.swift:68:9:\
    \ error: invalid redeclaration of 'gridCapacity'\n    var gridCapacity = grid[0].count\n\
    \        ^\n/tmp/tmpmx6rwrt2.swift:47:9: note: 'gridCapacity' previously declared\
    \ here\n    var gridCapacity = grid[0].count\n        ^\n/tmp/tmpmx6rw"
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var max = 0\n    var count = 0\n\
    \    \n    for row in grid {\n        for col in row {\n            if col ==\
    \ 0 {\n                count += capacity\n            } else {\n             \
    \   count -= 1\n            }\n            if count > max {\n                max\
    \ = count\n            }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpgg7axvus/tmpgg7axvus.swift:62: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b172596ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1725665b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1725665988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b17256647b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgg7axvus                        0x0000563b1c20f546 <unavailable> + 5446

    5    libc.so.6                          0x00002b1725b5a460 __libc_start_main +
    245

    6    tmpgg7axvus                        0x0000563b1c20f0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // init result\n    var result =\
    \ 0\n    \n    // init buckets\n    var buckets = [Int](capacity)\n    \n    //\
    \ init grid size\n    var grid_size = grid.count\n    \n    // init bucket index\n\
    \    var bucket_index = 0\n    \n    // init bucket sum\n    var bucket_sum =\
    \ 0\n    \n    // init bucket max index\n    var bucket_max_index = 0\n    \n\
    \    // init bucket max value\n    var bucket_max_value = 0\n    \n    // init\
    \ bucket min index\n    var bucket_min_index = 0\n    \n    // init bucket min\
    \ value\n    var bucket_min_value = 0\n    \n    // init bucket min index\n  \
    \  var bucket_max_index = 0\n    \n    // init bucket min value\n    var bucket_min_value\
    \ = 0\n    \n    // init bucket min index\n    var bucket_max_index = 0\n    \n\
    \    // init bucket min value\n    var bucket_min_value = 0\n    \n    // init\
    \ bucket min index\n    var bucket_max_index = 0\n    \n    // init bucket min\
    \ value\n    var bucket_min_value = 0\n    \n    // init bucket min index\n  \
    \  var bucket_max_index = 0\n    \n    // init bucket min value\n    var bucket_min_value\
    \ = 0\n    \n    // init bucket min index\n    var bucket_max_index = 0\n    \n\
    \    // init bucket min value\n    var bucket_min_value = 0\n    \n    // init\
    \ bucket min index\n    var bucket_max_index = 0\n    \n    // init bucket min\
    \ value\n    var bucket_min_value = 0\n    \n    // init bucket min index\n  \
    \  var bucket_max_index = 0\n    \n    // init bucket min value\n    var bucket_min_value\
    \ = 0\n    \n    // init bucket min index\n    var bucket_max_index = 0\n    \n\
    \    // init bucket min value\n    var bucket_min_value = 0\n    \n    // init\
    \ bucket min index\n    var bucket_max_index = 0\n    \n    // init bucket min\
    \ value\n    var bucket_min_value = 0\n    \n    // init bucket min index\n  \
    \  var bucket_max_index = 0\n    \n    // init bucket min value\n    var bucket_min_value\
    \ = 0\n    \n    // init bucket min index\n    var bucket_max_index = 0\n    \n\
    \    // init bucket min value\n    var bucket_min_value = 0\n    \n    // init\
    \ bucket min index\n    var bucket_max_index = 0\n    \n    // init bucket min\
    \ value\n    var bucket_min_value = 0\n    \n    // init bucket min index\n  \
    \  var bucket_max_index = 0\n    \n    // init bucket min value\n    var bucket_min_value\
    \ = 0\n    \n    // init bucket min index\n    var bucket_max_index = 0\n    \n\
    \    // init bucket min value\n    var bucket_min_value = 0\n    \n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpalqgn787.swift:35:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpalqgn787.swift:59:9: error: invalid\
    \ redeclaration of 'bucket_max_index'\n    var bucket_max_index = 0\n        ^\n\
    /tmp/tmpalqgn787.swift:47:9: note: 'bucket_max_index' previously declared here\n\
    \    var bucket_max_index = 0\n        ^\n/tmp/tmpalqgn787.swift:62:9: error:\
    \ invalid redeclaration of 'bucket_min_value'\n    var bucket_min_value = 0\n\
    \        ^\n/tmp/tmpalqgn787.swift:56:9: note: 'bucket_min_value' previously declared\
    \ here\n    var bucket_min_value = 0\n        ^\n/tmp/tmpalqgn787.swift:65:9:\
    \ error: invalid redeclaration of 'bucket_max_index'\n    var bucket_max_index\
    \ = 0\n        ^\n/tmp/tmpalqgn787.swift:47:9: note: 'bucket_max_index' previously\
    \ declared here\n    var bucket_max_index = 0\n        ^\n/tmp/tmpalqgn787.swift:68:9:\
    \ error: invalid redeclaration of 'bucket_min_value'\n    var bucket_min_value\
    \ = 0\n        ^\n/tmp/tmpalqgn787.swift:56:9: note: 'bucket_min_value' previously\
    \ declared here\n    var bucket_min_value = 0\n        ^\n/tmp/tmpalqgn787.swift:71:9:\
    \ error: invalid redeclaration of 'bucket_max_index'\n    var bucket_max_index\
    \ = 0\n        ^\n/tmp/tmpalqgn787.swift:47:9: note: 'bucket_max_index' previously\
    \ declared here\n    var bucket_max_index = 0\n        ^\n/tmp/tmpalqgn787.swift:74:9:\
    \ error: invalid redeclaration of 'bucket_min_value'\n    var bucket_min_value\
    \ = 0\n        ^\n/tmp/tmpalqgn787.swift:56:9: note: 'bucket_min_value' previously\
    \ declared here\n    var bucket_min_value = 0\n        ^\n/tmp/tmpalqgn787.swift:77:9:\
    \ error: invalid redeclaration of 'bucket_max_index'\n    var bucket_max_index\
    \ = 0\n        ^\n/tmp/tmpalqgn787.swift:47:9: note: 'bucket_max_index' previously\
    \ declared here\n    var bucket_max_index = 0\n        ^\n/tmp/tmpalqgn787.swift:80:9:\
    \ error: invalid redeclaration of 'bucket_min_value'\n    var bucket_min_value\
    \ = 0\n        ^\n/tmp/tmpalqgn787.swift:56:9: note: 'bucket_min_value' previously\
    \ declared here\n    var "
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var max = 0\n    var count = 0\n\
    \    \n    for row in grid {\n        if row[0] == 0 {\n            count += row[1]\n\
    \        }\n        if row[0] == 1 {\n            count -= row[1]\n        }\n\
    \        if count > capacity {\n            max = count\n            count = 0\n\
    \        }\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpiqhoah3a/tmpiqhoah3a.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5d9dbecc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5d9d8e3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5d9d8e3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5d9d8e27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiqhoah3a                        0x0000563a565a9596 <unavailable> + 5526

    5    libc.so.6                          0x00002b5d9ddd8460 __libc_start_main +
    245

    6    tmpiqhoah3a                        0x0000563a565a9129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var max = 0\n    var buckets = [Int](capacity)\n\
    \    for row in grid {\n        for col in row {\n            buckets[col] +=\
    \ (col == 1)\n        }\n    }\n    for bucket in buckets {\n        max += bucket\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmptiw8wu6z.swift:31:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmptiw8wu6z.swift:34:26: error: binary\
    \ operator '+=' cannot be applied to operands of type 'String' and 'Bool'\n  \
    \          buckets[col] += (col == 1)\n            ~~~~~~~~~~~~ ^  ~~~~~~~~~~\n\
    /tmp/tmptiw8wu6z.swift:34:26: note: overloads for '+=' exist with these partially\
    \ matching parameter lists: (inout ContinuousClock.Instant, Duration), (inout\
    \ Double, Double), (inout Duration, Duration), (inout Float, Float), (inout Float16,\
    \ Float16), (inout Float80, Float80), (inout Int, Int), (inout Int16, Int16),\
    \ (inout Int32, Int32), (inout Int64, Int64), (inout Int8, Int8), (inout String,\
    \ String), (inout SuspendingClock.Instant, Duration), (inout UInt, UInt), (inout\
    \ UInt16, UInt16), (inout UInt32, UInt32), (inout UInt64, UInt64), (inout UInt8,\
    \ UInt8)\n            buckets[col] += (col == 1)\n                         ^\n"
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var buckets = [Int](capacity)\n\
    \    \n    for row in grid {\n        for col in row {\n            buckets[col]\
    \ += (col == 0) ? 0 : buckets[col-1]\n        }\n    }\n    \n    var result =\
    \ 0\n    \n    for bucket in buckets {\n        if bucket > 0 {\n            result\
    \ += bucket\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpkns29ks3.swift:31:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    let rowCount = grid.count\n    let\
    \ colCount = grid[0].count\n    \n    var max = 0\n    \n    for row in 0..<rowCount\
    \ {\n        for col in 0..<colCount {\n            if grid[row][col] == 1 {\n\
    \                max += capacity\n            }\n        }\n    }\n    \n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpqfph4uzi/tmpqfph4uzi.swift:61: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0ac2d77c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0ac2a6eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0ac2a6e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0ac2a6d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqfph4uzi                        0x00005582f3000827 <unavailable> + 6183

    5    libc.so.6                          0x00002b0ac2f63460 __libc_start_main +
    245

    6    tmpqfph4uzi                        0x00005582f30001e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659824662
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // write your code here\n    \n\
    \    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpb8f0yy9_/tmpb8f0yy9_.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4229232c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4228f29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4228f29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4228f287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb8f0yy9_                        0x000055dcd7d3b3d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b422941e460 __libc_start_main +
    245

    6    tmpb8f0yy9_                        0x000055dcd7d3af69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var result = 0\n    \n    for row\
    \ in 0..<grid.count {\n        for col in 0..<grid[row].count {\n            if\
    \ grid[row][col] == 1 {\n                result += max_fill_helper(grid, row,\
    \ col, capacity)\n            }\n        }\n    }\n    \n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp9_1c9qon.swift:36:27: error: cannot find 'max_fill_helper' in scope\n\
    \                result += max_fill_helper(grid, row, col, capacity)\n       \
    \                   ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    if grid.isEmpty {\n        return 0\n\
    \    }\n    \n    var max = 0\n    var buckets = make([]*Bucket, capacity)\n \
    \   var buckets_used = make([]*Int, capacity)\n    \n    for row in grid {\n \
    \       var bucket_index = 0\n        for _ in row {\n            if buckets[bucket_index].isEmpty()\
    \ {\n                buckets[bucket_index] = make([]*Bucket, capacity)\n     \
    \           buckets_used[bucket_index] = 0\n            }\n            buckets[bucket_index].add(buckets_used[bucket_index])\n\
    \            buckets_used[bucket_index] += 1\n            bucket_index += 1\n\
    \        }\n    }\n    \n    for row in grid {\n        for _ in row {\n     \
    \       if buckets[row[0]].isEmpty() {\n                max += 1\n           \
    \ }\n        }\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmpewkpehji.swift:35:19: error: cannot find 'make' in scope\n    var\
    \ buckets = make([]*Bucket, capacity)\n                  ^~~~\n/tmp/tmpewkpehji.swift:35:27:\
    \ error: cannot find 'Bucket' in scope\n    var buckets = make([]*Bucket, capacity)\n\
    \                          ^~~~~~\n/tmp/tmpewkpehji.swift:35:24: error: use [:]\
    \ to get an empty dictionary literal\n    var buckets = make([]*Bucket, capacity)\n\
    \                       ^\n                        :\n/tmp/tmpewkpehji.swift:36:24:\
    \ error: cannot find 'make' in scope\n    var buckets_used = make([]*Int, capacity)\n\
    \                       ^~~~\n/tmp/tmpewkpehji.swift:36:31: error: type 'Int.Type'\
    \ cannot conform to 'BinaryInteger'\n    var buckets_used = make([]*Int, capacity)\n\
    \                              ^\n/tmp/tmpewkpehji.swift:36:31: note: only concrete\
    \ types such as structs, enums and classes can conform to protocols\n    var buckets_used\
    \ = make([]*Int, capacity)\n                              ^\n/tmp/tmpewkpehji.swift:36:31:\
    \ note: required by operator function '*' where 'T' = 'Int.Type'\n    var buckets_used\
    \ = make([]*Int, capacity)\n                              ^\n/tmp/tmpewkpehji.swift:36:29:\
    \ error: cannot convert value of type '[Any]' to expected argument type 'Duration'\n\
    \    var buckets_used = make([]*Int, capacity)\n                            ^\n\
    /tmp/tmpewkpehji.swift:42:41: error: cannot find 'make' in scope\n           \
    \     buckets[bucket_index] = make([]*Bucket, capacity)\n                    \
    \                    ^~~~\n/tmp/tmpewkpehji.swift:42:49: error: cannot find 'Bucket'\
    \ in scope\n                buckets[bucket_index] = make([]*Bucket, capacity)\n\
    \                                                ^~~~~~\n/tmp/tmpewkpehji.swift:42:46:\
    \ error: use [:] to get an empty dictionary literal\n                buckets[bucket_index]\
    \ = make([]*Bucket, capacity)\n                                             ^\n\
    \                                              :\n"
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // Write your code here\n    \n\
    \    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpx4z37bsl/tmpx4z37bsl.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acea6edbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acea6bd2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acea6bd2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acea6bd17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx4z37bsl                        0x00005566656b63d6 <unavailable> + 5078

    5    libc.so.6                          0x00002acea70c7460 __libc_start_main +
    245

    6    tmpx4z37bsl                        0x00005566656b5f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var max = 0\n    var count = 0\n\
    \    var buckets = [Int](capacity)\n    \n    for row in grid {\n        for col\
    \ in row {\n            if col == 1 {\n                buckets[col] = buckets[col]\
    \ + 1\n            }\n        }\n    }\n    \n    for bucket in buckets {\n  \
    \      if bucket > max {\n            max = bucket\n            count = 0\n  \
    \      }\n        if bucket == max {\n            count = count + 1\n        }\n\
    \    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpyovn0kyh.swift:33:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var result = 0\n    \n    for row\
    \ in 0..<grid.count {\n        for col in 0..<grid[row].count {\n            if\
    \ grid[row][col] == 1 {\n                result += capacity\n            }\n \
    \       }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmplgfc1sju/tmplgfc1sju.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0e56e2ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0e56b21b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0e56b21988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0e56b207b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplgfc1sju                        0x000055a8443a6827 <unavailable> + 6183

    5    libc.so.6                          0x00002b0e57016460 __libc_start_main +
    245

    6    tmplgfc1sju                        0x000055a8443a61e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var result = 0\n    \n    for row\
    \ in grid {\n        for bucket in row {\n            if bucket > capacity {\n\
    \                result += capacity - bucket\n            } else {\n         \
    \       result += bucket\n            }\n        }\n    }\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp5zsqkclj/tmp5zsqkclj.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b251d77fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b251d476b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b251d476988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b251d4757b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5zsqkclj                        0x00005579f2f59717 <unavailable> + 5911

    5    libc.so.6                          0x00002b251d96b460 __libc_start_main +
    245

    6    tmp5zsqkclj                        0x00005579f2f590d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var result = 0\n    \n    for row\
    \ in 0..<grid.count {\n        for col in 0..<grid[row].count {\n            if\
    \ grid[row][col] == 1 {\n                result += max_fill_helper(grid, row,\
    \ col, capacity)\n            }\n        }\n    }\n    \n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp9_1c9qon.swift:36:27: error: cannot find 'max_fill_helper' in scope\n\
    \                result += max_fill_helper(grid, row, col, capacity)\n       \
    \                   ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    let n = grid.count\n    \n    var\
    \ max = 0\n    \n    for _ in 0..<n {\n        \n        let buckets = makeBuckets(grid,\
    \ capacity)\n        \n        for bucket in buckets {\n            \n       \
    \     let bucketCapacity = bucket.capacity\n            \n            if bucketCapacity\
    \ > max {\n                max = bucketCapacity\n            }\n        }\n  \
    \  }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpifwec2yq.swift:37:23: error: cannot find 'makeBuckets' in scope\n\
    \        let buckets = makeBuckets(grid, capacity)\n                      ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // init result\n    var result =\
    \ 0\n    \n    // init buckets\n    var buckets = [Int](capacity)\n    \n    //\
    \ init wells\n    var wells = [Int](capacity)\n    \n    // init visited wells\n\
    \    var visited = [Int](capacity)\n    \n    // init visited wells\n    var visited2\
    \ = [Int](capacity)\n    \n    // init visited wells\n    var visited3 = [Int](capacity)\n\
    \    \n    // init visited wells\n    var visited4 = [Int](capacity)\n    \n \
    \   // init visited wells\n    var visited5 = [Int](capacity)\n    \n    // init\
    \ visited wells\n    var visited6 = [Int](capacity)\n    \n    // init visited\
    \ wells\n    var visited7 = [Int](capacity)\n    \n    // init visited wells\n\
    \    var visited8 = [Int](capacity)\n    \n    // init visited wells\n    var\
    \ visited9 = [Int](capacity)\n    \n    // init visited wells\n    var visited10\
    \ = [Int](capacity)\n    \n    // init visited wells\n    var visited11 = [Int](capacity)\n\
    \    \n    // init visited wells\n    var visited12 = [Int](capacity)\n    \n\
    \    // init visited wells\n    var visited13 = [Int](capacity)\n    \n    //\
    \ init visited wells\n    var visited14 = [Int](capacity)\n    \n    // init visited\
    \ wells\n    var visited15 = [Int](capacity)\n    \n    // init visited wells\n\
    \    var visited16 = [Int](capacity)\n    \n    // init visited wells\n    var\
    \ visited17 = [Int](capacity)\n    \n    // init visited wells\n    var visited18\
    \ = [Int](capacity)\n    \n    // init visited wells\n    var visited19 = [Int](capacity)\n\
    \    \n    // init visited wells\n    var visited20 = [Int](capacity)\n    \n\
    \    // init visited wells\n    var visited21 = [Int](capacity)\n    \n    //\
    \ init visited wells\n    var visited22 = [Int](capacity)\n    \n    // init visited\
    \ wells\n    var visited23 = [Int](capacity)\n    \n    // init visited wells\n\
    \    var visited24 = [Int](capacity)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmp_1hiz1ae.swift:35:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmp_1hiz1ae.swift:38:23: error: missing\
    \ argument label 'arrayLiteral:' in call\n    var wells = [Int](capacity)\n  \
    \                    ^\n                      arrayLiteral: \n/tmp/tmp_1hiz1ae.swift:41:25:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited = [Int](capacity)\n\
    \                        ^\n                        arrayLiteral: \n/tmp/tmp_1hiz1ae.swift:44:26:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited2 = [Int](capacity)\n\
    \                         ^\n                         arrayLiteral: \n/tmp/tmp_1hiz1ae.swift:47:26:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited3 = [Int](capacity)\n\
    \                         ^\n                         arrayLiteral: \n/tmp/tmp_1hiz1ae.swift:50:26:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited4 = [Int](capacity)\n\
    \                         ^\n                         arrayLiteral: \n/tmp/tmp_1hiz1ae.swift:53:26:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited5 = [Int](capacity)\n\
    \                         ^\n                         arrayLiteral: \n/tmp/tmp_1hiz1ae.swift:56:26:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited6 = [Int](capacity)\n\
    \                         ^\n                         arrayLiteral: \n/tmp/tmp_1hiz1ae.swift:59:26:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited7 = [Int](capacity)\n\
    \                         ^\n                         arrayLiteral: \n/tmp/tmp_1hiz1ae.swift:62:26:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited8 = [Int](capacity)\n\
    \                         ^\n                         arrayLiteral: \n/tmp/tmp_1hiz1ae.swift:65:26:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var visited9 = [Int](capacity)\n\
    \                         ^\n                         arrayLiteral: \n/tmp/tmp_1hiz1ae."
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // write your code here\n    \n\
    \    var count = 0\n    \n    for row in 0..<grid.count {\n        for col in\
    \ 0..<grid[row].count {\n            if grid[row][col] == 1 {\n              \
    \  count += fillBucket(grid, row, col, capacity)\n            }\n        }\n \
    \   }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpy47zn54_.swift:38:26: error: cannot find 'fillBucket' in scope\n\
    \                count += fillBucket(grid, row, col, capacity)\n             \
    \            ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var count = 0\n    var max = 0\n    for\
    \ row in grid {\n        for col in row {\n            if col == 1 {\n       \
    \         max += capacity\n            }\n        }\n    }\n    for row in grid\
    \ {\n        for col in row {\n            if col == 1 {\n                count\
    \ += max\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpbugtd8ls/tmpbugtd8ls.swift:62: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5cf25c3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5cf22bab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5cf22ba988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5cf22b97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbugtd8ls                        0x0000563df9eb5546 <unavailable> + 5446

    5    libc.so.6                          0x00002b5cf27af460 __libc_start_main +
    245

    6    tmpbugtd8ls                        0x0000563df9eb50d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var buckets = [Int](capacity)\n\
    \    \n    for row in grid {\n        for bucket in row {\n            buckets[bucket]\
    \ += 1\n        }\n    }\n    \n    var result = 0\n    \n    for bucket in buckets\
    \ {\n        if bucket > 0 {\n            result += bucket\n        }\n    }\n\
    \    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmps9pthh0y.swift:31:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // init result\n    var result =\
    \ 0\n    \n    // init bucket array\n    var buckets = [Int](repeating: 0, count:\
    \ capacity)\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n \
    \   // init bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket\
    \ sum\n    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n \
    \   // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket capacity\n \
    \   var bucketCapacity = 0\n    \n    // init bucket sum\n    var bucketSum =\
    \ 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket sum\n\
    \    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex =\
    \ 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n   \
    \ // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket capacity\n \
    \   var bucketCapacity = 0\n    \n    // init bucket sum\n    var bucketSum =\
    \ 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket sum\n\
    \    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex =\
    \ 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n   \
    \ // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket capacity\n \
    \   var bucketCapacity = 0\n    \n    // init bucket sum\n    var bucketSum =\
    \ 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket sum\n\
    \    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex =\
    \ 0\n    \n    // \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp8r1mb28c.swift:47:9: error: invalid redeclaration of 'bucketIndex'\n\
    \    var bucketIndex = 0\n        ^\n/tmp/tmp8r1mb28c.swift:38:9: note: 'bucketIndex'\
    \ previously declared here\n    var bucketIndex = 0\n        ^\n/tmp/tmp8r1mb28c.swift:50:9:\
    \ error: invalid redeclaration of 'bucketCapacity'\n    var bucketCapacity = 0\n\
    \        ^\n/tmp/tmp8r1mb28c.swift:41:9: note: 'bucketCapacity' previously declared\
    \ here\n    var bucketCapacity = 0\n        ^\n/tmp/tmp8r1mb28c.swift:53:9: error:\
    \ invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n        ^\n/tmp/tmp8r1mb28c.swift:44:9:\
    \ note: 'bucketSum' previously declared here\n    var bucketSum = 0\n        ^\n\
    /tmp/tmp8r1mb28c.swift:56:9: error: invalid redeclaration of 'bucketIndex'\n \
    \   var bucketIndex = 0\n        ^\n/tmp/tmp8r1mb28c.swift:38:9: note: 'bucketIndex'\
    \ previously declared here\n    var bucketIndex = 0\n        ^\n/tmp/tmp8r1mb28c.swift:59:9:\
    \ error: invalid redeclaration of 'bucketCapacity'\n    var bucketCapacity = 0\n\
    \        ^\n/tmp/tmp8r1mb28c.swift:41:9: note: 'bucketCapacity' previously declared\
    \ here\n    var bucketCapacity = 0\n        ^\n/tmp/tmp8r1mb28c.swift:62:9: error:\
    \ invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n        ^\n/tmp/tmp8r1mb28c.swift:44:9:\
    \ note: 'bucketSum' previously declared here\n    var bucketSum = 0\n        ^\n\
    /tmp/tmp8r1mb28c.swift:65:9: error: invalid redeclaration of 'bucketIndex'\n \
    \   var bucketIndex = 0\n        ^\n/tmp/tmp8r1mb28c.swift:38:9: note: 'bucketIndex'\
    \ previously declared here\n    var bucketIndex = 0\n        ^\n/tmp/tmp8r1mb28c.swift:68:9:\
    \ error: invalid redeclaration of 'bucketCapacity'\n    var bucketCapacity = 0\n\
    \        ^\n/tmp/tmp8r1mb28c.swift:41:9: note: 'bucketCapacity' previously declared\
    \ here\n    var bucketCapacity = 0\n        ^\n/tmp/tmp8r1mb28c.swift:71:9: error:\
    \ invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n        ^\n/tmp/tmp8r1mb28c.swift:44:9:\
    \ note: 'bucketSum' previously declared here\n    var bucketSum = 0\n        ^\n\
    /tmp/tmp8r1mb28c.swift:74:9: error: invalid redeclaration of 'bucketIndex'\n \
    \   var "
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // TODO: Write your code here\n\
    \    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp71ubdu3k/tmp71ubdu3k.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba57d6acc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba57d3a3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba57d3a3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba57d3a27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp71ubdu3k                        0x0000555f347543d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba57d898460 __libc_start_main +
    245

    6    tmp71ubdu3k                        0x0000555f34753f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        var max = 0\n        for _ in row {\n            max += capacity\n  \
    \      }\n        if max > result {\n            result = max\n        }\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpqk7m_1_8/tmpqk7m_1_8.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5a31e33c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5a31b2ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5a31b2a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5a31b297b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqk7m_1_8                        0x0000559a4e1e9546 <unavailable> + 5446

    5    libc.so.6                          0x00002b5a3201f460 __libc_start_main +
    245

    6    tmpqk7m_1_8                        0x0000559a4e1e90d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var buckets = [Int](capacity)\n\
    \    for row in grid {\n        var bucket = 0\n        for _ in row {\n     \
    \       bucket += buckets[bucket]\n        }\n        buckets[bucket] += 1\n \
    \       result += bucket\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpj1ertf2r.swift:31:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var count = 0\n    \n    for row\
    \ in grid {\n        for col in row {\n            if col == 0 {\n           \
    \     count += min_fill(grid: grid, row: row, col: col, capacity: capacity)\n\
    \            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp5rzdg6ab.swift:36:26: error: cannot find 'min_fill' in scope\n\
    \                count += min_fill(grid: grid, row: row, col: col, capacity: capacity)\n\
    \                         ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // init result and buckets\n   \
    \ var result = 0\n    var buckets = [Int](capacity)\n    \n    // init bucket\
    \ index\n    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket capacity\n    var bucketCapacity = 0\n    \n    // init bucket index\n\
    \    var bucketIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmphss_3tyt.swift:33:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmphss_3tyt.swift:42:9: error: invalid\
    \ redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n/tmp/tmphss_3tyt.swift:36:9:\
    \ note: 'bucketIndex' previously declared here\n    var bucketIndex = 0\n    \
    \    ^\n/tmp/tmphss_3tyt.swift:45:9: error: invalid redeclaration of 'bucketCapacity'\n\
    \    var bucketCapacity = 0\n        ^\n/tmp/tmphss_3tyt.swift:39:9: note: 'bucketCapacity'\
    \ previously declared here\n    var bucketCapacity = 0\n        ^\n/tmp/tmphss_3tyt.swift:48:9:\
    \ error: invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n   \
    \     ^\n/tmp/tmphss_3tyt.swift:36:9: note: 'bucketIndex' previously declared\
    \ here\n    var bucketIndex = 0\n        ^\n/tmp/tmphss_3tyt.swift:51:9: error:\
    \ invalid redeclaration of 'bucketCapacity'\n    var bucketCapacity = 0\n    \
    \    ^\n/tmp/tmphss_3tyt.swift:39:9: note: 'bucketCapacity' previously declared\
    \ here\n    var bucketCapacity = 0\n        ^\n/tmp/tmphss_3tyt.swift:54:9: error:\
    \ invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n\
    /tmp/tmphss_3tyt.swift:36:9: note: 'bucketIndex' previously declared here\n  \
    \  var bucketIndex = 0\n        ^\n/tmp/tmphss_3tyt.swift:57:9: error: invalid\
    \ redeclaration of 'bucketCapacity'\n    var bucketCapacity = 0\n        ^\n/tmp/tmphss_3tyt.swift:39:9:\
    \ note: 'bucketCapacity' previously declared here\n    var bucketCapacity = 0\n\
    \        ^\n/tmp/tmphss_3tyt.swift:60:9: error: invalid redeclaration of 'bucketIndex'\n\
    \    var bucketIndex = 0\n        ^\n/tmp/tmphss_3tyt.swift:36:9: note: 'bucketIndex'\
    \ previously declared here\n    var bucketIndex = 0\n        ^\n/tmp/tmphss_3tyt.swift:63:9:\
    \ error: invalid redeclaration of 'bucketCapacity'\n    var bucketCapacity = 0\n\
    \        ^\n/tmp/tmphss_3tyt.swift:39:9: note: 'bucketCapacity' previously declared\
    \ here\n    var bucketCapacity = 0\n        ^\n/tmp/tmphss_3tyt.swift:66:9: error:\
    \ invalid redeclaration of 'bucketIndex'\n    va"
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    let n = grid.count\n    \n    var\
    \ buckets = [Int]()\n    \n    for _ in 0..<n {\n        buckets.append(0)\n \
    \   }\n    \n    for row in 0..<n {\n        for col in 0..<n {\n            if\
    \ grid[row][col] == 1 {\n                buckets[row] += capacity\n          \
    \  }\n        }\n    }\n    \n    var result = 0\n    \n    for row in 0..<n {\n\
    \        for col in 0..<n {\n            if grid[row][col] == 1 {\n          \
    \      result += buckets[row] - buckets[col]\n            }\n        }\n    }\n\
    \    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpo89nb54d/tmpo89nb54d.swift:73: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afa02028c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa01d1fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afa01d1f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afa01d1e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpo89nb54d                        0x000056475914a706 <unavailable> + 5894

    5    libc.so.6                          0x00002afa02214460 __libc_start_main +
    245

    6    tmpo89nb54d                        0x000056475914a299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var max = 0\n    var result = 0\n    for\
    \ row in grid {\n        for col in row {\n            if col == 0 {\n       \
    \         max += capacity\n            } else {\n                max -= capacity\n\
    \            }\n        }\n        result += max\n        max = 0\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpywesyrkd/tmpywesyrkd.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b889823cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8897f33b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8897f33988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8897f327b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpywesyrkd                        0x0000560e80fc8546 <unavailable> + 5446

    5    libc.so.6                          0x00002b8898428460 __libc_start_main +
    245

    6    tmpywesyrkd                        0x0000560e80fc80d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // write your code here\n    \n\
    \    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpb8f0yy9_/tmpb8f0yy9_.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4229232c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4228f29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4228f29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4228f287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb8f0yy9_                        0x000055dcd7d3b3d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b422941e460 __libc_start_main +
    245

    6    tmpb8f0yy9_                        0x000055dcd7d3af69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824662
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // write your code here\n    \n\
    \    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpb8f0yy9_/tmpb8f0yy9_.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4229232c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4228f29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4228f29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4228f287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb8f0yy9_                        0x000055dcd7d3b3d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b422941e460 __libc_start_main +
    245

    6    tmpb8f0yy9_                        0x000055dcd7d3af69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824662
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        var max = 0\n        for _ in row {\n            max += capacity\n  \
    \      }\n        if max > result {\n            result = max\n        }\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpqk7m_1_8/tmpqk7m_1_8.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5a31e33c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5a31b2ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5a31b2a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5a31b297b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqk7m_1_8                        0x0000559a4e1e9546 <unavailable> + 5446

    5    libc.so.6                          0x00002b5a3201f460 __libc_start_main +
    245

    6    tmpqk7m_1_8                        0x0000559a4e1e90d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    if grid.isEmpty {\n        return 0\n\
    \    }\n    var max = 0\n    var buckets = make([][]int, capacity)\n    for row\
    \ in grid {\n        var bucket = buckets[row[0]]\n        for column in row {\n\
    \            bucket += column\n            if bucket > capacity {\n          \
    \      bucket = bucket % capacity\n            }\n            buckets[column]\
    \ = bucket\n        }\n    }\n    for column in buckets {\n        max += column[capacity]\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp42z_i45q.swift:34:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmp42z_i45q.swift:34:19: error: cannot find 'make' in scope\n\
    \    var buckets = make([][]int, capacity)\n                  ^~~~\n/tmp/tmp42z_i45q.swift:34:28:\
    \ error: cannot find 'int' in scope\n    var buckets = make([][]int, capacity)\n\
    \                           ^~~\n/tmp/tmp42z_i45q.swift:34:27: error: missing\
    \ argument for parameter #1 in call\n    var buckets = make([][]int, capacity)\n\
    \                          ^\n                          <#Int#>\nSwift.Array:16:23:\
    \ note: 'subscript(_:)' declared here\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var result = 0\n    \n    for row\
    \ in 0..<grid.count {\n        for col in 0..<grid[row].count {\n            \n\
    \            if grid[row][col] == 1 {\n                \n                let bucket\
    \ = buckets[row][col]\n                \n                if bucket == capacity\
    \ {\n                    \n                    result += bucket\n            \
    \        \n                } else {\n                    \n                  \
    \  result += bucket\n                    \n                }\n               \
    \ \n            }\n            \n        }\n    }\n    \n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpiv_icbgt.swift:38:30: error: cannot find 'buckets' in scope\n \
    \               let bucket = buckets[row][col]\n                             ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    let n = grid.count\n    \n    var\
    \ buckets = [Int](repeating: 0, count: capacity)\n    \n    for row in 0..<n {\n\
    \        for col in 0..<capacity {\n            buckets[col] += grid[row][col]\n\
    \        }\n    }\n    \n    var result = 0\n    \n    for col in 0..<capacity\
    \ {\n        if buckets[col] == 0 {\n            buckets[col] = 1\n          \
    \  result += col\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpdbwmzgyq/tmpdbwmzgyq.swift:66: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d0148ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d01181b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9d01181988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9d011807b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdbwmzgyq                        0x0000558e9dc846c6 <unavailable> + 5830

    5    libc.so.6                          0x00002b9d01676460 __libc_start_main +
    245

    6    tmpdbwmzgyq                        0x0000558e9dc84259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var max = 0\n    var buckets = [Int](repeating:\
    \ 0, count: capacity)\n    for row in grid {\n        for col in row {\n     \
    \       buckets[col] += 1 \n        }\n    }\n    for bucket in buckets {\n  \
    \      if bucket > max {\n            max = bucket\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:613: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b5ed57cfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5ed54c6561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b5ed54c6286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b5ed54c613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b5ed54c5bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b5ed52c57ec <unavailable> + 186348

    6    tmp71p8vh7b                        0x00005641fcbd8e94 <unavailable> + 7828

    7    tmp71p8vh7b                        0x00005641fcbd8588 <unavailable> + 5512

    8    libc.so.6                          0x00002b5ed59bb460 __libc_start_main +
    245

    9    tmp71p8vh7b                        0x00005641fcbd8199 <unavailable> + 4505

    '
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // TODO: Write your code here\n\
    \    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp71ubdu3k/tmp71ubdu3k.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba57d6acc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba57d3a3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba57d3a3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba57d3a27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp71ubdu3k                        0x0000555f347543d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba57d898460 __libc_start_main +
    245

    6    tmp71ubdu3k                        0x0000555f34753f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var max = 0\n    var buckets = [Int](capacity)\n\
    \    \n    for row in grid {\n        for col in row {\n            buckets[col]\
    \ += 1 \n        }\n    }\n    \n    for bucket in buckets {\n        if bucket\
    \ > max {\n            max = bucket \n        }\n    }\n    \n    return max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp6go45x64.swift:32:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    let n = grid.count\n    \n    var\
    \ buckets = [Int](repeating: 0, count: capacity)\n    \n    for row in 0..<n {\n\
    \        for col in 0..<capacity {\n            buckets[col] += grid[row][col]\n\
    \        }\n    }\n    \n    var result = 0\n    \n    for col in 0..<capacity\
    \ {\n        if buckets[col] > 0 {\n            buckets[col] -= 1\n          \
    \  result += buckets[col]\n        }\n    }\n    \n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpvhvvb4kj/tmpvhvvb4kj.swift:66: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b20ca622c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b20ca319b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b20ca319988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b20ca3187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvhvvb4kj                        0x000055a2385646c6 <unavailable> + 5830

    5    libc.so.6                          0x00002b20ca80e460 __libc_start_main +
    245

    6    tmpvhvvb4kj                        0x000055a238564259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        var max = 0\n        for _ in row {\n            max += _\n        }\n\
    \        if max > capacity {\n            result += capacity - max\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpgpg94dq4.swift:34:20: error: '_' can only appear in a pattern or\
    \ on the left side of an assignment\n            max += _\n                  \
    \ ^\n"
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var result = 0\n    \n    for row\
    \ in grid {\n        for col in row {\n            if col == 0 {\n           \
    \     result += capacity\n            } else {\n                result -= capacity\n\
    \            }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp57ca1j1b/tmp57ca1j1b.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5fa7495c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5fa718cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5fa718c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5fa718b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp57ca1j1b                        0x0000562b5eac5546 <unavailable> + 5446

    5    libc.so.6                          0x00002b5fa7681460 __libc_start_main +
    245

    6    tmp57ca1j1b                        0x0000562b5eac50d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var result = 0\n    \n    for row\
    \ in grid {\n        for bucket in row {\n            if bucket > 0 {\n      \
    \          result += bucket * capacity\n            }\n        }\n    }\n    \n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpl9rbewxp/tmpl9rbewxp.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b015f51fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b015f216b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b015f216988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b015f2157b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rbewxp                        0x000055cddd009717 <unavailable> + 5911

    5    libc.so.6                          0x00002b015f70b460 __libc_start_main +
    245

    6    tmpl9rbewxp                        0x000055cddd0090d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        for col in row {\n            if col == 0 {\n                result +=\
    \ capacity\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpf9ttrgzr/tmpf9ttrgzr.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b19d1bb1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b19d18a8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b19d18a8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b19d18a77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf9ttrgzr                        0x00005653471e9717 <unavailable> + 5911

    5    libc.so.6                          0x00002b19d1d9d460 __libc_start_main +
    245

    6    tmpf9ttrgzr                        0x00005653471e90d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var max = 0\n    for row in grid {\n \
    \       for col in row {\n            if col == 0 {\n                max += capacity\n\
    \            } else {\n                max += col\n            }\n        }\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpry86kop5/tmpry86kop5.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4072b90c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4072887b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4072887988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b40728867b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpry86kop5                        0x0000558540770546 <unavailable> + 5446

    5    libc.so.6                          0x00002b4072d7c460 __libc_start_main +
    245

    6    tmpry86kop5                        0x00005585407700d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // write your code here\n    \n\
    \    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpb8f0yy9_/tmpb8f0yy9_.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4229232c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4228f29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4228f29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4228f287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb8f0yy9_                        0x000055dcd7d3b3d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b422941e460 __libc_start_main +
    245

    6    tmpb8f0yy9_                        0x000055dcd7d3af69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824662
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // write your code here\n    \n\
    \    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpb8f0yy9_/tmpb8f0yy9_.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4229232c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4228f29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4228f29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4228f287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb8f0yy9_                        0x000055dcd7d3b3d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b422941e460 __libc_start_main +
    245

    6    tmpb8f0yy9_                        0x000055dcd7d3af69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var buckets = [Int](capacity)\n\
    \    \n    for row in grid {\n        for col in row {\n            buckets[col]\
    \ += 1 \n        }\n    }\n    \n    var result = 0\n    \n    for bucket in buckets\
    \ {\n        if bucket > 0 {\n            result += bucket\n        }\n    }\n\
    \    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpdpd96nqm.swift:31:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var buckets = [Int](capacity)\n\
    \    for row in grid {\n        for col in row {\n            buckets[col] -=\
    \ 1\n            if buckets[col] == 0 {\n                buckets[col] = capacity\n\
    \                result += buckets[col]\n            }\n        }\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpd3tv1q5h.swift:31:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var result = 0\n    \n    for row\
    \ in grid {\n        for cell in row {\n            if cell == 1 {\n         \
    \       result += capacity\n            }\n        }\n    }\n    \n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpmj47km6a/tmpmj47km6a.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b937c104c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b937bdfbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b937bdfb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b937bdfa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmj47km6a                        0x000055ef0d77b717 <unavailable> + 5911

    5    libc.so.6                          0x00002b937c2f0460 __libc_start_main +
    245

    6    tmpmj47km6a                        0x000055ef0d77b0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // write your code here\n    \n\
    \    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpb8f0yy9_/tmpb8f0yy9_.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4229232c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4228f29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4228f29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4228f287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb8f0yy9_                        0x000055dcd7d3b3d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b422941e460 __libc_start_main +
    245

    6    tmpb8f0yy9_                        0x000055dcd7d3af69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var max = 0\n    var count = 0\n\
    \    var buckets = [Int](capacity)\n    \n    for row in grid {\n        for col\
    \ in row {\n            buckets[col] -= 1\n            if buckets[col] < 0 {\n\
    \                buckets[col] = 0\n            }\n        }\n    }\n    \n   \
    \ for row in grid {\n        for col in row {\n            buckets[col] += 1\n\
    \            if buckets[col] > max {\n                max = buckets[col]\n   \
    \             count = 0\n            }\n        }\n    }\n    \n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpw0nsm520.swift:33:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    if grid.isEmpty {\n        return 0\n\
    \    }\n    \n    var max = 0\n    var buckets = [Int](capacity)\n    \n    for\
    \ row in grid {\n        for col in row {\n            buckets[col] += 1 \n  \
    \      }\n    }\n    \n    for bucket in buckets {\n        if bucket > max {\n\
    \            max = bucket\n        }\n    }\n    \n    return max\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp6kjq_dlv.swift:35:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var max = 0\n    var count = 0\n\
    \    var buckets = [Int](capacity)\n    \n    for row in grid {\n        for col\
    \ in row {\n            if col == 1 {\n                buckets[col] = buckets[col]\
    \ + 1\n            }\n        }\n    }\n    \n    for bucket in buckets {\n  \
    \      if bucket > max {\n            max = bucket\n            count = 0\n  \
    \      }\n        if bucket == max {\n            count = count + 1\n        }\n\
    \    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpyovn0kyh.swift:33:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var buckets = [Int](repeating: 0,\
    \ count: capacity)\n    \n    for row in grid {\n        for col in row {\n  \
    \          buckets[col] += 1 \n        }\n    }\n    \n    var result = 0\n  \
    \  \n    for bucket in buckets {\n        if bucket > 0 {\n            result\
    \ += bucket\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:613: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b22f7d75c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b22f7a6c561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b22f7a6c286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b22f7a6c13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b22f7a6bbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b22f786b7ec <unavailable> + 186348

    6    tmptvi5sq27                        0x0000563d596ede8c <unavailable> + 7820

    7    tmptvi5sq27                        0x0000563d596ed588 <unavailable> + 5512

    8    libc.so.6                          0x00002b22f7f61460 __libc_start_main +
    245

    9    tmptvi5sq27                        0x0000563d596ed199 <unavailable> + 4505

    '
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var max = 0\n    var result = 0\n\
    \    \n    for row in 0..<grid.count {\n        for col in 0..<grid[row].count\
    \ {\n            if grid[row][col] == 1 {\n                \n                let\
    \ bucket = capacity / grid[row][col]\n                \n                if bucket\
    \ > max {\n                    max = bucket\n                    result = row\
    \ * grid[row].count + col\n                }\n            }\n        }\n    }\n\
    \    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpi21kza1q/tmpi21kza1q.swift:64: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3131678c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b313136fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b313136f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b313136e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi21kza1q                        0x0000559f96a95656 <unavailable> + 5718

    5    libc.so.6                          0x00002b3131864460 __libc_start_main +
    245

    6    tmpi21kza1q                        0x0000559f96a951e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var max = 0\n    var count = 0\n\
    \    \n    for row in 0..<grid.count {\n        for col in 0..<grid[row].count\
    \ {\n            if grid[row][col] == 1 {\n                \n                let\
    \ bucket = buckets[row][col]\n                \n                let newCapacity\
    \ = capacity - bucket\n                \n                if newCapacity > max\
    \ {\n                    max = newCapacity\n                    count = 0\n  \
    \              }\n                \n                count += buckets[row][col]\
    \ == capacity\n            }\n        }\n    }\n    \n    return count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp8rhpl037.swift:38:30: error: cannot find 'buckets' in scope\n \
    \               let bucket = buckets[row][col]\n                             ^~~~~~~\n\
    /tmp/tmp8rhpl037.swift:47:26: error: cannot find 'buckets' in scope\n        \
    \        count += buckets[row][col] == capacity\n                         ^~~~~~~\n\
    /tmp/tmp8rhpl037.swift:47:44: error: cannot convert value of type 'Bool' to expected\
    \ argument type 'Int'\n                count += buckets[row][col] == capacity\n\
    \                                           ^\n"
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var count = 0\n    \n    for row\
    \ in grid {\n        for col in row {\n            if col == 0 {\n           \
    \     count += bucket_capacity(grid, row, col)\n            }\n        }\n   \
    \ }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp2pawon8z.swift:36:26: error: cannot find 'bucket_capacity' in scope\n\
    \                count += bucket_capacity(grid, row, col)\n                  \
    \       ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var result = 0\n    \n    for row\
    \ in grid {\n        for column in row {\n            \n            if column\
    \ == 0 {\n                result += capacity\n            } else {\n         \
    \       result += column\n            }\n        }\n    }\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpu0b2fn3q/tmpu0b2fn3q.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae6ff0bbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae6fedb2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae6fedb2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae6fedb17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu0b2fn3q                        0x0000563f83054546 <unavailable> + 5446

    5    libc.so.6                          0x00002ae6ff2a7460 __libc_start_main +
    245

    6    tmpu0b2fn3q                        0x0000563f830540d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // write your code here\n    \n\
    \    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpb8f0yy9_/tmpb8f0yy9_.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4229232c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4228f29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4228f29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4228f287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb8f0yy9_                        0x000055dcd7d3b3d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b422941e460 __libc_start_main +
    245

    6    tmpb8f0yy9_                        0x000055dcd7d3af69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var buckets = [Int](capacity)\n\
    \    \n    for row in grid {\n        for bucket in row {\n            buckets[bucket]\
    \ += 1\n        }\n    }\n    \n    var max = 0\n    \n    for bucket in buckets\
    \ {\n        if bucket > max {\n            max = bucket\n        }\n    }\n \
    \   \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpj2o2kixv.swift:31:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824662
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        var max = 0\n        for _ in row {\n            max += capacity\n  \
    \      }\n        if max > result {\n            result = max\n        }\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpqk7m_1_8/tmpqk7m_1_8.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5a31e33c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5a31b2ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5a31b2a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5a31b297b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqk7m_1_8                        0x0000559a4e1e9546 <unavailable> + 5446

    5    libc.so.6                          0x00002b5a3201f460 __libc_start_main +
    245

    6    tmpqk7m_1_8                        0x0000559a4e1e90d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    let n = grid.count\n    \n    var\
    \ buckets = [Int](capacity)\n    \n    for row in 0..<n {\n        for col in\
    \ 0..<n {\n            if grid[row][col] == 1 {\n                buckets[grid[row][col]]\
    \ += 1 \n            }\n        }\n    }\n    \n    var result = 0\n    \n   \
    \ for bucket in buckets {\n        if bucket > 0 {\n            result += bucket\n\
    \        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmpkwwyjyyf.swift:33:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    let n = grid.count\n    \n    var\
    \ result = 0\n    \n    for row in 0..<n {\n        for col in 0..<n {\n     \
    \       \n            let bucket = grid[row][col]\n            \n            if\
    \ bucket == 0 {\n                \n                let buckets = buckets(grid,\
    \ row, col, capacity)\n                \n                result += buckets.count\n\
    \                \n            }\n            \n        }\n    }\n    \n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpqp7iz937.swift:42:31: error: use of local variable 'buckets' before\
    \ its declaration\n                let buckets = buckets(grid, row, col, capacity)\n\
    \                              ^\n/tmp/tmpqp7iz937.swift:42:21: note: 'buckets'\
    \ declared here\n                let buckets = buckets(grid, row, col, capacity)\n\
    \                    ^\n"
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var result = 0\n    var buckets\
    \ = [Int](capacity)\n    \n    for row in 0..<grid.count {\n        for col in\
    \ 0..<grid[row].count {\n            if grid[row][col] == 1 {\n              \
    \  buckets[grid[row][col]] += 1 \n            }\n        }\n    }\n    \n    for\
    \ bucket in buckets {\n        if bucket > 0 {\n            result += bucket\n\
    \        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmp3oyrj9z_.swift:32:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // write your code here\n    \n\
    \    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpb8f0yy9_/tmpb8f0yy9_.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4229232c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4228f29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4228f29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4228f287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb8f0yy9_                        0x000055dcd7d3b3d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b422941e460 __libc_start_main +
    245

    6    tmpb8f0yy9_                        0x000055dcd7d3af69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var max = 0\n    var maxCount =\
    \ 0\n    var buckets = [Int](capacity)\n    \n    for row in 0..<grid.count {\n\
    \        for col in 0..<grid[row].count {\n            if grid[row][col] == 1\
    \ {\n                buckets[grid[row][col]-1] += 1\n            }\n        }\n\
    \    }\n    \n    for bucket in buckets {\n        if bucket > max {\n       \
    \     max = bucket\n            maxCount = 1\n        } else {\n            if\
    \ bucket == max {\n                maxCount += 1\n            }\n        }\n \
    \   }\n    \n    return maxCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpw_80o620.swift:33:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824663
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var result = 0\n    \n    for row\
    \ in grid {\n        for col in row {\n            if col == 0 {\n           \
    \     result += max_fill(grid: grid, capacity: capacity)\n            }\n    \
    \    }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        for col in row {\n            if col == 0 {\n                result +=\
    \ max(capacity - grid[row][col], 0)\n            }\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmptim_nj9q.swift:34:47: error: cannot convert value of type '[Int]'\
    \ to expected argument type 'Int'\n                result += max(capacity - grid[row][col],\
    \ 0)\n                                              ^\n"
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // init result\n    var result =\
    \ 0\n    \n    // init buckets\n    var buckets = [Int](capacity)\n    \n    //\
    \ init wells\n    var wells = [Int](grid.count)\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init well index\n    var wellIndex = 0\n\
    \    \n    // init bucket capacity\n    var bucketCapacity = capacity\n    \n\
    \    // init bucket index\n    var bucketIndex = 0\n    \n    // init well index\n\
    \    var wellIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = capacity\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n\
    \    // init well index\n    var wellIndex = 0\n    \n    // init bucket capacity\n\
    \    var bucketCapacity = capacity\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init well index\n    var wellIndex = 0\n    \n    // init\
    \ bucket capacity\n    var bucketCapacity = capacity\n    \n    // init bucket\
    \ index\n    var bucketIndex = 0\n    \n    // init well index\n    var wellIndex\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = capacity\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init well\
    \ index\n    var wellIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = capacity\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n\
    \    // init well index\n    var wellIndex = 0\n    \n    // init bucket capacity\n\
    \    var bucketCapacity = capacity\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init well index\n    var wellIndex = 0\n    \n    // init\
    \ bucket capacity\n    var bucketCapacity = capacity\n    \n    // init bucket\
    \ index\n    var bucketIndex = 0\n    \n    // init well index\n    var wellIndex\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = capacity\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init well\
    \ index\n    var wellIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = capacity\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n\
    \    // init well index\n    var wellIndex = 0\n    \n    // init bucket capacity\n\
    \    var bucketCapacity = capacity\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init well index\n    var wellIndex = 0\n    \n    // init\
    \ bucket capacity\n    var bucketCapacity = capacity\n    \n    // init bucket\
    \ index\n    var bucketIndex = 0\n    \n    // init well index\n    var wellIndex\
    \ = 0\n    \n    // \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpysnvx7vu.swift:35:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpysnvx7vu.swift:38:23: error: missing\
    \ argument label 'arrayLiteral:' in call\n    var wells = [Int](grid.count)\n\
    \                      ^\n                      arrayLiteral: \n/tmp/tmpysnvx7vu.swift:50:9:\
    \ error: invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n   \
    \     ^\n/tmp/tmpysnvx7vu.swift:41:9: note: 'bucketIndex' previously declared\
    \ here\n    var bucketIndex = 0\n        ^\n/tmp/tmpysnvx7vu.swift:53:9: error:\
    \ invalid redeclaration of 'wellIndex'\n    var wellIndex = 0\n        ^\n/tmp/tmpysnvx7vu.swift:44:9:\
    \ note: 'wellIndex' previously declared here\n    var wellIndex = 0\n        ^\n\
    /tmp/tmpysnvx7vu.swift:56:9: error: invalid redeclaration of 'bucketCapacity'\n\
    \    var bucketCapacity = capacity\n        ^\n/tmp/tmpysnvx7vu.swift:47:9: note:\
    \ 'bucketCapacity' previously declared here\n    var bucketCapacity = capacity\n\
    \        ^\n/tmp/tmpysnvx7vu.swift:59:9: error: invalid redeclaration of 'bucketIndex'\n\
    \    var bucketIndex = 0\n        ^\n/tmp/tmpysnvx7vu.swift:41:9: note: 'bucketIndex'\
    \ previously declared here\n    var bucketIndex = 0\n        ^\n/tmp/tmpysnvx7vu.swift:62:9:\
    \ error: invalid redeclaration of 'wellIndex'\n    var wellIndex = 0\n       \
    \ ^\n/tmp/tmpysnvx7vu.swift:44:9: note: 'wellIndex' previously declared here\n\
    \    var wellIndex = 0\n        ^\n/tmp/tmpysnvx7vu.swift:65:9: error: invalid\
    \ redeclaration of 'bucketCapacity'\n    var bucketCapacity = capacity\n     \
    \   ^\n/tmp/tmpysnvx7vu.swift:47:9: note: 'bucketCapacity' previously declared\
    \ here\n    var bucketCapacity = capacity\n        ^\n/tmp/tmpysnvx7vu.swift:68:9:\
    \ error: invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n   \
    \     ^\n/tmp/tmpysnvx7vu.swift:41:9: note: 'bucketIndex' previously declared\
    \ here\n    var bucketIndex = 0\n        ^\n/tmp/tmpysnvx7vu.swift:71:9: error:\
    \ invalid redeclaration of 'wellIndex'\n    var wellIndex = 0\n        ^\n/tmp/tmpysnvx7vu.swift:44:"
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // init result\n    var result =\
    \ 0\n    \n    // init buckets\n    var buckets = [Int](repeating: 0, count: capacity)\n\
    \    \n    // init visited map\n    var visited = [Int](repeating: false, count:\
    \ capacity)\n    \n    // init visited map\n    var visited2 = [Int](repeating:\
    \ false, count: capacity)\n    \n    // init visited map\n    var visited3 = [Int](repeating:\
    \ false, count: capacity)\n    \n    // init visited map\n    var visited4 = [Int](repeating:\
    \ false, count: capacity)\n    \n    // init visited map\n    var visited5 = [Int](repeating:\
    \ false, count: capacity)\n    \n    // init visited map\n    var visited6 = [Int](repeating:\
    \ false, count: capacity)\n    \n    // init visited map\n    var visited7 = [Int](repeating:\
    \ false, count: capacity)\n    \n    // init visited map\n    var visited8 = [Int](repeating:\
    \ false, count: capacity)\n    \n    // init visited map\n    var visited9 = [Int](repeating:\
    \ false, count: capacity)\n    \n    // init visited map\n    var visited10 =\
    \ [Int](repeating: false, count: capacity)\n    \n    // init visited map\n  \
    \  var visited11 = [Int](repeating: false, count: capacity)\n    \n    // init\
    \ visited map\n    var visited12 = [Int](repeating: false, count: capacity)\n\
    \    \n    // init visited map\n    var visited13 = [Int](repeating: false, count:\
    \ capacity)\n    \n    // init visited map\n    var visited14 = [Int](repeating:\
    \ false, count: capacity)\n    \n    // init visited map\n    var visited15 =\
    \ [Int](repeating: false, count: capacity)\n    \n    // init visited map\n  \
    \  var visited16 = [Int](repeating: false, count: capacity)\n    \n    // init\
    \ visited map\n    var visited17 = [Int](repeating: false, count: capacity)\n\
    \    \n    // init visited map\n    var visited18 = [Int](repeating: false, count:\
    \ capacity)\n    \n    // init visited map\n    var visited19 = [Int](repeating:\
    \ false, count: capacity)\n    \n    // init visited map\n    var visited20 =\
    \ [Int](repeating: false, count: capacity)\n    \n    // init visited map\n  \
    \  var visited21 = [Int](repeating: false, count: capacity)\n    \n    // init\
    \ visited map\n    var visited22 = [Int](repeating: false, count: capacity)\n\
    \    \n    // init visited map\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp2glk62u5.swift:38:36: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n    var visited = [Int](repeating: false, count:\
    \ capacity)\n                                   ^\n/tmp/tmp2glk62u5.swift:41:37:\
    \ error: cannot convert value of type 'Bool' to expected argument type 'Int'\n\
    \    var visited2 = [Int](repeating: false, count: capacity)\n               \
    \                     ^\n/tmp/tmp2glk62u5.swift:44:37: error: cannot convert value\
    \ of type 'Bool' to expected argument type 'Int'\n    var visited3 = [Int](repeating:\
    \ false, count: capacity)\n                                    ^\n/tmp/tmp2glk62u5.swift:47:37:\
    \ error: cannot convert value of type 'Bool' to expected argument type 'Int'\n\
    \    var visited4 = [Int](repeating: false, count: capacity)\n               \
    \                     ^\n/tmp/tmp2glk62u5.swift:50:37: error: cannot convert value\
    \ of type 'Bool' to expected argument type 'Int'\n    var visited5 = [Int](repeating:\
    \ false, count: capacity)\n                                    ^\n/tmp/tmp2glk62u5.swift:53:37:\
    \ error: cannot convert value of type 'Bool' to expected argument type 'Int'\n\
    \    var visited6 = [Int](repeating: false, count: capacity)\n               \
    \                     ^\n/tmp/tmp2glk62u5.swift:56:37: error: cannot convert value\
    \ of type 'Bool' to expected argument type 'Int'\n    var visited7 = [Int](repeating:\
    \ false, count: capacity)\n                                    ^\n/tmp/tmp2glk62u5.swift:59:37:\
    \ error: cannot convert value of type 'Bool' to expected argument type 'Int'\n\
    \    var visited8 = [Int](repeating: false, count: capacity)\n               \
    \                     ^\n/tmp/tmp2glk62u5.swift:62:37: error: cannot convert value\
    \ of type 'Bool' to expected argument type 'Int'\n    var visited9 = [Int](repeating:\
    \ false, count: capacity)\n                                    ^\n/tmp/tmp2glk62u5.swift:65:38:\
    \ error: cannot convert value of type 'Bool' to expected argument type 'Int'\n\
    \    var visited10 = [Int](repeating: false, count: capacity)\n              \
    \                       ^\n/tmp/tmp2glk62u5.s"
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // init result\n    var result =\
    \ 0\n    \n    // init bucket array\n    var buckets = [Int](capacity)\n    \n\
    \    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket capacity\n\
    \    var bucketCapacity = capacity\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = capacity\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ capacity\n    var bucketCapacity = capacity\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = capacity\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n\
    \    // init bucket capacity\n    var bucketCapacity = capacity\n    \n    //\
    \ init bucket index\n    var bucketIndex = 0\n    \n    // init bucket capacity\n\
    \    var bucketCapacity = capacity\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = capacity\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ capacity\n    var bucketCapacity = capacity\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = capacity\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n\
    \    // init bucket capacity\n    var bucketCapacity = capacity\n    \n    //\
    \ init bucket index\n    var bucketIndex = 0\n    \n    // init bucket capacity\n\
    \    var bucketCapacity = capacity\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = capacity\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ capacity\n    var bucketCapacity = capacity\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = capacity\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n\
    \    // init bucket capacity\n    var bucketCapacity = capacity\n    \n    //\
    \ init bucket index\n    var bucketIndex = 0\n    \n    // init bucket capacity\n\
    \    var bucketCapacity = capacity\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = capacity\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ capacity\n    var bucketCapacity = capacity\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = capacity\n    \n    // init bucket index\n    var bucketIndex = 0\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpr7lhj86q.swift:35:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpr7lhj86q.swift:44:9: error: invalid\
    \ redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n/tmp/tmpr7lhj86q.swift:38:9:\
    \ note: 'bucketIndex' previously declared here\n    var bucketIndex = 0\n    \
    \    ^\n/tmp/tmpr7lhj86q.swift:47:9: error: invalid redeclaration of 'bucketCapacity'\n\
    \    var bucketCapacity = capacity\n        ^\n/tmp/tmpr7lhj86q.swift:41:9: note:\
    \ 'bucketCapacity' previously declared here\n    var bucketCapacity = capacity\n\
    \        ^\n/tmp/tmpr7lhj86q.swift:50:9: error: invalid redeclaration of 'bucketIndex'\n\
    \    var bucketIndex = 0\n        ^\n/tmp/tmpr7lhj86q.swift:38:9: note: 'bucketIndex'\
    \ previously declared here\n    var bucketIndex = 0\n        ^\n/tmp/tmpr7lhj86q.swift:53:9:\
    \ error: invalid redeclaration of 'bucketCapacity'\n    var bucketCapacity = capacity\n\
    \        ^\n/tmp/tmpr7lhj86q.swift:41:9: note: 'bucketCapacity' previously declared\
    \ here\n    var bucketCapacity = capacity\n        ^\n/tmp/tmpr7lhj86q.swift:56:9:\
    \ error: invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n   \
    \     ^\n/tmp/tmpr7lhj86q.swift:38:9: note: 'bucketIndex' previously declared\
    \ here\n    var bucketIndex = 0\n        ^\n/tmp/tmpr7lhj86q.swift:59:9: error:\
    \ invalid redeclaration of 'bucketCapacity'\n    var bucketCapacity = capacity\n\
    \        ^\n/tmp/tmpr7lhj86q.swift:41:9: note: 'bucketCapacity' previously declared\
    \ here\n    var bucketCapacity = capacity\n        ^\n/tmp/tmpr7lhj86q.swift:62:9:\
    \ error: invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n   \
    \     ^\n/tmp/tmpr7lhj86q.swift:38:9: note: 'bucketIndex' previously declared\
    \ here\n    var bucketIndex = 0\n        ^\n/tmp/tmpr7lhj86q.swift:65:9: error:\
    \ invalid redeclaration of 'bucketCapacity'\n    var bucketCapacity = capacity\n\
    \        ^\n/tmp/tmpr7lhj86q.swift:41:9: note: 'bucketCapacity' previously declared\
    \ here\n    var bucketCapacity = capacity\n        ^\n/tmp/tmpr7lhj86q.swift:68"
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var max = 0\n    var buckets = [Int](capacity)\n\
    \    for row in grid {\n        for bucket in row {\n            buckets[bucket]\
    \ += 1\n        }\n    }\n    for bucket in buckets {\n        if bucket > max\
    \ {\n            max = bucket\n        }\n    }\n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpnj4600j2.swift:31:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var result = 0\n    \n    for row\
    \ in 0..<grid.count {\n        for col in 0..<grid[row].count {\n            if\
    \ grid[row][col] == 1 {\n                result += max_fill_helper(grid, row,\
    \ col, capacity)\n            }\n        }\n    }\n    \n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp9_1c9qon.swift:36:27: error: cannot find 'max_fill_helper' in scope\n\
    \                result += max_fill_helper(grid, row, col, capacity)\n       \
    \                   ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824662
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // write your code here\n    \n\
    \    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpb8f0yy9_/tmpb8f0yy9_.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4229232c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4228f29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4228f29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4228f287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb8f0yy9_                        0x000055dcd7d3b3d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b422941e460 __libc_start_main +
    245

    6    tmpb8f0yy9_                        0x000055dcd7d3af69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824662
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // TODO: write your code here\n\
    \    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp8hxygw_q/tmp8hxygw_q.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad8e0b69c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad8e0860b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad8e0860988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad8e085f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8hxygw_q                        0x000055fa6e2cf3d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ad8e0d55460 __libc_start_main +
    245

    6    tmp8hxygw_q                        0x000055fa6e2cef69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var buckets = [Int](capacity)\n\
    \    \n    for row in grid {\n        for bucket in row {\n            buckets[bucket]\
    \ += 1\n        }\n    }\n    \n    var max = 0\n    \n    for bucket in buckets\
    \ {\n        if bucket > max {\n            max = bucket\n        }\n    }\n \
    \   \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpj2o2kixv.swift:31:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var buckets = [Int](capacity)\n\
    \    for row in grid {\n        for bucket in row {\n            buckets[bucket]\
    \ += 1\n        }\n    }\n    for bucket in buckets {\n        if bucket > 0 {\n\
    \            result += bucket\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpmeviak5x.swift:31:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824662
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        for bucket in row {\n            if bucket > capacity {\n           \
    \     result += capacity - bucket\n            } else {\n                result\
    \ += bucket\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpuo9s3a91/tmpuo9s3a91.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0d3ade8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0d3aadfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0d3aadf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0d3aade7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuo9s3a91                        0x0000560a78fef717 <unavailable> + 5911

    5    libc.so.6                          0x00002b0d3afd4460 __libc_start_main +
    245

    6    tmpuo9s3a91                        0x0000560a78fef0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // TODO: Write your code here\n\
    \    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp71ubdu3k/tmp71ubdu3k.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba57d6acc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba57d3a3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba57d3a3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba57d3a27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp71ubdu3k                        0x0000555f347543d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba57d898460 __libc_start_main +
    245

    6    tmp71ubdu3k                        0x0000555f34753f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // write your code here\n    \n\
    \    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpb8f0yy9_/tmpb8f0yy9_.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4229232c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4228f29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4228f29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4228f287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb8f0yy9_                        0x000055dcd7d3b3d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b422941e460 __libc_start_main +
    245

    6    tmpb8f0yy9_                        0x000055dcd7d3af69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824662
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    let rowCount = grid.count\n    let\
    \ colCount = grid[0].count\n    \n    var max = 0\n    \n    for row in 0..<rowCount\
    \ {\n        for col in 0..<colCount {\n            \n            let bucket =\
    \ grid[row][col]\n            \n            if bucket == 0 {\n               \
    \ \n                let newBucket = bucket + capacity\n                \n    \
    \            if newBucket > max {\n                    max = newBucket\n     \
    \           }\n            }\n        }\n    }\n    \n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpqn214y1v/tmpqn214y1v.swift:68: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b34ffd18c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b34ffa0fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b34ffa0f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b34ffa0e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqn214y1v                        0x000055a1efb47656 <unavailable> + 5718

    5    libc.so.6                          0x00002b34fff04460 __libc_start_main +
    245

    6    tmpqn214y1v                        0x000055a1efb471e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var max = 0\n    var count = 0\n\
    \    var buckets = [Int](repeating: 0, count: capacity)\n    \n    for row in\
    \ grid {\n        for col in row {\n            if col == 1 {\n              \
    \  buckets[col] += 1 \n            }\n        }\n    }\n    \n    for bucket in\
    \ buckets {\n        if bucket > max {\n            max = bucket\n           \
    \ count = 0\n        }\n        if bucket == max {\n            count += 1\n \
    \       }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:613: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b896f03ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b896ed31561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b896ed31286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b896ed3113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b896ed30bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b896eb307ec <unavailable> + 186348

    6    tmp33c_rhm3                        0x000055ee62f54ec3 <unavailable> + 7875

    7    tmp33c_rhm3                        0x000055ee62f54588 <unavailable> + 5512

    8    libc.so.6                          0x00002b896f226460 __libc_start_main +
    245

    9    tmp33c_rhm3                        0x000055ee62f54199 <unavailable> + 4505

    '
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // write your code here\n    \n\
    \    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpb8f0yy9_/tmpb8f0yy9_.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4229232c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4228f29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4228f29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4228f287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb8f0yy9_                        0x000055dcd7d3b3d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b422941e460 __libc_start_main +
    245

    6    tmpb8f0yy9_                        0x000055dcd7d3af69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var buckets = [Int](capacity)\n\
    \    \n    for row in grid {\n        for bucket in row {\n            buckets[bucket]\
    \ += 1\n        }\n    }\n    \n    var result = 0\n    \n    for bucket in buckets\
    \ {\n        if bucket > 0 {\n            result += bucket\n        }\n    }\n\
    \    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmps9pthh0y.swift:31:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824662
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var result = 0\n    var buckets\
    \ = [Int](capacity)\n    \n    for row in grid {\n        for column in row {\n\
    \            buckets[column] = buckets[column] - 1\n        }\n    }\n    \n \
    \   for bucket in buckets {\n        if bucket == 0 {\n            bucket = capacity\n\
    \        }\n        result = max(result, bucket)\n    }\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpjsl_pdzf.swift:32:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var max = 0\n    var count = 0\n\
    \    \n    for row in grid {\n        for col in row {\n            if col ==\
    \ 1 {\n                max += capacity\n                count += 1\n         \
    \   }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpeej9_vcf/tmpeej9_vcf.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2f0fcbec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2f0f9b5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2f0f9b5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2f0f9b47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpeej9_vcf                        0x000056101266e717 <unavailable> + 5911

    5    libc.so.6                          0x00002b2f0feaa460 __libc_start_main +
    245

    6    tmpeej9_vcf                        0x000056101266e0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var max = 0\n    var buckets = [Int](capacity)\n\
    \    \n    for row in 0..<grid.count {\n        for col in 0..<grid[row].count\
    \ {\n            if grid[row][col] == 1 {\n                buckets[grid[row][col]-1]\
    \ += 1\n            }\n        }\n    }\n    \n    for bucket in buckets {\n \
    \       max += bucket\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpudhagq_b.swift:32:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var result = 0\n    \n    for row\
    \ in grid {\n        for cell in row {\n            if cell == 1 {\n         \
    \       result += capacity\n            }\n        }\n    }\n    \n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpmj47km6a/tmpmj47km6a.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b937c104c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b937bdfbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b937bdfb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b937bdfa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmj47km6a                        0x000055ef0d77b717 <unavailable> + 5911

    5    libc.so.6                          0x00002b937c2f0460 __libc_start_main +
    245

    6    tmpmj47km6a                        0x000055ef0d77b0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // init result\n    var result =\
    \ 0\n    \n    // init bucket array\n    var buckets = [Int](repeating: 0, count:\
    \ capacity)\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n \
    \   // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket max index\n\
    \    var bucketMaxIndex = 0\n    \n    // init bucket max value\n    var bucketMaxValue\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min value\n    var bucketMinValue = 0\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = 0\n    \n    // init bucket min value\n\
    \    var bucketMinValue = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min value\n    var bucketMinValue = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min value\n    var bucketMinValue = 0\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket min value\n    var bucketMinValue\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min value\n    var bucketMinValue = 0\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = 0\n    \n    // init bucket min value\n\
    \    var bucketMinValue = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min value\n    var bucketMinValue = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min value\n    var bucketMinValue = 0\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket min value\n    var bucketMinValue\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min value\n    var bucketMinValue = 0\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = 0\n    \n    // init bucket min value\n\
    \    var bucketMinValue = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min value\n    var bucketMinValue = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min value\n    var bucketMinValue = 0\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket min value\n    var bucketMinValue\
    \ = 0\n    \n    // init bucket min index\n    var bucketMin\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpkssb5idy.swift:56:9: error: invalid redeclaration of 'bucketMinIndex'\n\
    \    var bucketMinIndex = 0\n        ^\n/tmp/tmpkssb5idy.swift:50:9: note: 'bucketMinIndex'\
    \ previously declared here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpkssb5idy.swift:59:9:\
    \ error: invalid redeclaration of 'bucketMinValue'\n    var bucketMinValue = 0\n\
    \        ^\n/tmp/tmpkssb5idy.swift:53:9: note: 'bucketMinValue' previously declared\
    \ here\n    var bucketMinValue = 0\n        ^\n/tmp/tmpkssb5idy.swift:62:9: error:\
    \ invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n    \
    \    ^\n/tmp/tmpkssb5idy.swift:50:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpkssb5idy.swift:65:9: error:\
    \ invalid redeclaration of 'bucketMinValue'\n    var bucketMinValue = 0\n    \
    \    ^\n/tmp/tmpkssb5idy.swift:53:9: note: 'bucketMinValue' previously declared\
    \ here\n    var bucketMinValue = 0\n        ^\n/tmp/tmpkssb5idy.swift:68:9: error:\
    \ invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n    \
    \    ^\n/tmp/tmpkssb5idy.swift:50:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpkssb5idy.swift:71:9: error:\
    \ invalid redeclaration of 'bucketMinValue'\n    var bucketMinValue = 0\n    \
    \    ^\n/tmp/tmpkssb5idy.swift:53:9: note: 'bucketMinValue' previously declared\
    \ here\n    var bucketMinValue = 0\n        ^\n/tmp/tmpkssb5idy.swift:74:9: error:\
    \ invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n    \
    \    ^\n/tmp/tmpkssb5idy.swift:50:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpkssb5idy.swift:77:9: error:\
    \ invalid redeclaration of 'bucketMinValue'\n    var bucketMinValue = 0\n    \
    \    ^\n/tmp/tmpkssb5idy.swift:53:9: note: 'bucketMinValue' previously declared\
    \ here\n    var bucketMinValue = 0\n        ^\n/tmp/tmpkssb5idy.swift:80:9: error:\
    \ invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n    \
    \    ^\n/tmp/tmpkssb5idy.swift:50:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex ="
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    if grid.isEmpty {\n        return 0\n\
    \    }\n    var max = 0\n    var buckets = [Int](capacity)\n    for row in grid\
    \ {\n        for col in row {\n            if col == 1 {\n                buckets[col]\
    \ = buckets[col] + 1\n            }\n        }\n    }\n    for bucket in buckets\
    \ {\n        if bucket > max {\n            max = bucket\n        }\n    }\n \
    \   return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpkrrk_xa8.swift:34:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var buckets = [Int](repeating:\
    \ 0, count: capacity)\n    for row in grid {\n        for col in row {\n     \
    \       buckets[col] += 1 \n        }\n    }\n    for bucket in buckets {\n  \
    \      if bucket > 0 {\n            result += bucket \n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:613: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b3a7b894c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3a7b58b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3a7b58b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3a7b58b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3a7b58abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b3a7b38a7ec <unavailable> + 186348

    6    tmpxyi_rrj_                        0x0000555786e91e94 <unavailable> + 7828

    7    tmpxyi_rrj_                        0x0000555786e91588 <unavailable> + 5512

    8    libc.so.6                          0x00002b3a7ba80460 __libc_start_main +
    245

    9    tmpxyi_rrj_                        0x0000555786e91199 <unavailable> + 4505

    '
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // 1. Initialize a variable to store\
    \ the maximum water that can be extracted from each well\n    var maxWater = Int()\n\
    \    \n    // 2. Initialize a variable to store the number of wells needed to\
    \ empty the bucket\n    var emptyBuckets = Int()\n    \n    // 3. Initialize a\
    \ variable to store the number of wells needed to fill the bucket\n    var fillBuckets\
    \ = Int()\n    \n    // 4. Initialize a variable to store the number of wells\
    \ needed to empty the bucket\n    var emptyBucketsNeeded = Int()\n    \n    //\
    \ 5. Initialize a variable to store the number of wells needed to fill the bucket\n\
    \    var fillBucketsNeeded = Int()\n    \n    // 6. Initialize a variable to store\
    \ the number of wells needed to empty the bucket\n    var emptyBucketsNeeded2\
    \ = Int()\n    \n    // 7. Initialize a variable to store the number of wells\
    \ needed to fill the bucket\n    var fillBucketsNeeded2 = Int()\n    \n    //\
    \ 8. Initialize a variable to store the number of wells needed to empty the bucket\n\
    \    var emptyBucketsNeeded3 = Int()\n    \n    // 9. Initialize a variable to\
    \ store the number of wells needed to fill the bucket\n    var fillBucketsNeeded3\
    \ = Int()\n    \n    // 10. Initialize a variable to store the number of wells\
    \ needed to empty the bucket\n    var emptyBucketsNeeded4 = Int()\n    \n    //\
    \ 11. Initialize a variable to store the number of wells needed to fill the bucket\n\
    \    var fillBucketsNeeded4 = Int()\n    \n    // 12. Initialize a variable to\
    \ store the number of wells needed to empty the bucket\n    var emptyBucketsNeeded5\
    \ = Int()\n    \n    // 13. Initialize a variable to store the number of wells\
    \ needed to fill the bucket\n    var fillBucketsNeeded5 = Int()\n    \n    //\
    \ 14. Initialize a variable to store the number of wells needed to empty the bucket\n\
    \    var emptyBucketsNeeded6 = Int()\n    \n    // 15. Initialize a variable to\
    \ store the number of wells needed to fill the bucket\n    var fillBucketsNeeded6\
    \ = Int()\n    \n    // 16. Initialize a variable to store the number of wells\
    \ needed to empty the bucket\n    var emptyBucketsNeeded7 = Int()\n    \n    //\
    \ 17. Initialize a variable to store the number of wells needed to fill the bucket\n\
    \    var fillBucketsNeeded7 = Int()\n    \n    // 18. Initialize a variable to\
    \ store the number of wells needed to empty the bucket\n    var emptyBucketsNeeded8\
    \ = Int()\n    \n    // 19. Initialize a variable to store the number of wells\
    \ needed to fill the bucket\n    var fill\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmpw5df2nr3.swift:86:9: error: type annotation missing in pattern\n\
    \    var fill\n        ^\n"
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // init result and buckets\n   \
    \ var result = 0\n    var buckets = [Int](capacity)\n    \n    // init bucket\
    \ index\n    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = capacity\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    //\
    \ init bucket index\n    var bucketIndex = 0\n    \n    // init bucket sum\n \
    \   var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n\
    \    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket\
    \ index\n    var bucketIndex = 0\n    \n    // init bucket sum\n    var bucketSum\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket sum\n    var\
    \ bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n   \
    \ \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ sum\n    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket sum\n    var\
    \ bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n   \
    \ \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ sum\n    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket sum\n    var\
    \ bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n   \
    \ \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ sum\n    var bucket\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpmzqg4yx2.swift:33:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpmzqg4yx2.swift:45:9: error: invalid\
    \ redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n/tmp/tmpmzqg4yx2.swift:36:9:\
    \ note: 'bucketIndex' previously declared here\n    var bucketIndex = 0\n    \
    \    ^\n/tmp/tmpmzqg4yx2.swift:48:9: error: invalid redeclaration of 'bucketSum'\n\
    \    var bucketSum = 0\n        ^\n/tmp/tmpmzqg4yx2.swift:42:9: note: 'bucketSum'\
    \ previously declared here\n    var bucketSum = 0\n        ^\n/tmp/tmpmzqg4yx2.swift:51:9:\
    \ error: invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n   \
    \     ^\n/tmp/tmpmzqg4yx2.swift:36:9: note: 'bucketIndex' previously declared\
    \ here\n    var bucketIndex = 0\n        ^\n/tmp/tmpmzqg4yx2.swift:54:9: error:\
    \ invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n        ^\n/tmp/tmpmzqg4yx2.swift:42:9:\
    \ note: 'bucketSum' previously declared here\n    var bucketSum = 0\n        ^\n\
    /tmp/tmpmzqg4yx2.swift:57:9: error: invalid redeclaration of 'bucketIndex'\n \
    \   var bucketIndex = 0\n        ^\n/tmp/tmpmzqg4yx2.swift:36:9: note: 'bucketIndex'\
    \ previously declared here\n    var bucketIndex = 0\n        ^\n/tmp/tmpmzqg4yx2.swift:60:9:\
    \ error: invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n       \
    \ ^\n/tmp/tmpmzqg4yx2.swift:42:9: note: 'bucketSum' previously declared here\n\
    \    var bucketSum = 0\n        ^\n/tmp/tmpmzqg4yx2.swift:63:9: error: invalid\
    \ redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n/tmp/tmpmzqg4yx2.swift:36:9:\
    \ note: 'bucketIndex' previously declared here\n    var bucketIndex = 0\n    \
    \    ^\n/tmp/tmpmzqg4yx2.swift:66:9: error: invalid redeclaration of 'bucketSum'\n\
    \    var bucketSum = 0\n        ^\n/tmp/tmpmzqg4yx2.swift:42:9: note: 'bucketSum'\
    \ previously declared here\n    var bucketSum = 0\n        ^\n/tmp/tmpmzqg4yx2.swift:69:9:\
    \ error: invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n   \
    \     ^\n/tmp/tmpmzqg4yx2.swift:36:9: note: 'bucketIndex' pre"
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var buckets = make([][]int,\
    \ capacity)\n    for row in grid {\n        for bucket in bucket {\n         \
    \   buckets[bucket] += row[0]\n        }\n    }\n    for bucket in buckets {\n\
    \        result += bucket.max() \n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpmq2narl5.swift:31:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmpmq2narl5.swift:31:19: error: cannot find 'make' in scope\n\
    \    var buckets = make([][]int, capacity)\n                  ^~~~\n/tmp/tmpmq2narl5.swift:31:28:\
    \ error: cannot find 'int' in scope\n    var buckets = make([][]int, capacity)\n\
    \                           ^~~\n/tmp/tmpmq2narl5.swift:31:27: error: missing\
    \ argument for parameter #1 in call\n    var buckets = make([][]int, capacity)\n\
    \                          ^\n                          <#Int#>\nSwift.Array:16:23:\
    \ note: 'subscript(_:)' declared here\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\n/tmp/tmpmq2narl5.swift:33:23:\
    \ error: cannot find 'bucket' in scope\n        for bucket in bucket {\n     \
    \                 ^~~~~~\n"
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var buckets = [Int](capacity)\n\
    \    \n    for row in grid {\n        for bucket in row {\n            buckets[bucket]\
    \ += 1\n        }\n    }\n    \n    var result = 0\n    \n    for bucket in buckets\
    \ {\n        result += bucket\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpw20ykp_m.swift:31:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    if grid.count == 0 {\n        return 0\n\
    \    }\n    \n    var max = 0\n    var maxIndex = 0\n    \n    for index in 0..<grid.count\
    \ {\n        if grid[index][0] > max {\n            max = grid[index][0]\n   \
    \         maxIndex = index\n        }\n    }\n    \n    var buckets = [Int](capacity)\n\
    \    \n    for index in 0..<grid.count {\n        if grid[index][0] > max {\n\
    \            buckets[grid[index][0] - 1] += 1\n        }\n    }\n    \n    for\
    \ index in 0..<buckets.count {\n        if buckets[index] == 0 {\n           \
    \ buckets[index] = 1\n        } else {\n            buckets[index] = buckets[index]\
    \ - 1\n        }\n    }\n    \n    for index in 0..<buckets.count {\n        if\
    \ buckets[index] > 0 {\n            buckets[index] = buckets[index] - 1\n    \
    \    } else {\n            buckets[index] = 0\n        }\n    }\n    \n    for\
    \ index in 0..<buckets.count {\n        if buckets[index] == 0 {\n           \
    \ buckets[index] = 1\n        } else {\n            buckets[index] = buckets[index]\
    \ - 1\n        }\n    }\n    \n    for index in 0..<buckets.count {\n        if\
    \ buckets[index] > 0 {\n            buckets[index] = buckets[index] - 1\n    \
    \    } else {\n            buckets[index] = 0\n        }\n    }\n    \n    for\
    \ index in 0..<buckets.count {\n        if buckets[index] == 0 {\n           \
    \ buckets[index] = 1\n        } else {\n            buckets[index] = buckets[index]\
    \ - 1\n        }\n    }\n    \n    for index in 0..<buckets.count {\n        if\
    \ buckets[index] > 0 {\n            buckets[index] = buckets[index] - 1\n    \
    \    } else {\n            buckets[index] = 0\n        }\n    }\n    \n    for\
    \ index in 0..<buckets.count {\n        if buckets[index] == 0 {\n           \
    \ buckets[index] = 1\n        } else {\n            buckets[index] = buckets[index]\
    \ - 1\n        }\n    }\n    \n    for index in 0..<buckets.count {\n        if\
    \ buckets[index] > 0 {\n            buckets[index] = buckets[index] - 1\n    \
    \    } else {\n            buckets[index] = 0\n        }\n    }\n    \n    for\
    \ index in 0..<buckets.count {\n        if buckets[index] == 0 {\n           \
    \ buckets[index] = 1\n        } else {\n            buckets[index] = buckets[index]\
    \ - 1\n        }\n    }\n    \n    for index in 0..<buckets.count {\n        if\
    \ buckets[index] > 0 {\n            buckets[index] = buckets[index] - 1\n    \
    \    } else {\n            buckets[index] = 0\n        }\n    }\n    \n    for\
    \ index in 0..<buckets.count {\n        if buckets[index] == 0 {\n           \
    \ buckets[index] = 1\n        } else {\n            buckets[index] = buckets[index]\
    \ - 1\n        }\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpxa35c2_3.swift:158:71: error: expected '}' at end of brace statement\n\
    assert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)\n     \
    \                                                                 ^\n/tmp/tmpxa35c2_3.swift:29:52:\
    \ note: to match this opening '{'\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n                                                   ^\n/tmp/tmpxa35c2_3.swift:44:25:\
    \ error: missing argument label 'arrayLiteral:' in call\n    var buckets = [Int](capacity)\n\
    \                        ^\n                        arrayLiteral: \n/tmp/tmpxa35c2_3.swift:142:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var buckets = [Int](capacity)\n\
    \    for row in grid {\n        for col in row {\n            buckets[col] -=\
    \ 1\n            if buckets[col] == 0 {\n                buckets[col] = capacity\n\
    \                result += buckets[col]\n            }\n        }\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpd3tv1q5h.swift:31:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var buckets = [Int](capacity)\n\
    \    \n    for row in grid {\n        for col in row {\n            buckets[col]\
    \ += (col == 1)\n        }\n    }\n    \n    var result = 0\n    \n    for bucket\
    \ in buckets {\n        if bucket > 0 {\n            result += bucket\n      \
    \  }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmpuluiwu9i.swift:31:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpuluiwu9i.swift:35:26: error: binary\
    \ operator '+=' cannot be applied to operands of type 'String' and 'Bool'\n  \
    \          buckets[col] += (col == 1)\n            ~~~~~~~~~~~~ ^  ~~~~~~~~~~\n\
    /tmp/tmpuluiwu9i.swift:35:26: note: overloads for '+=' exist with these partially\
    \ matching parameter lists: (inout ContinuousClock.Instant, Duration), (inout\
    \ Double, Double), (inout Duration, Duration), (inout Float, Float), (inout Float16,\
    \ Float16), (inout Float80, Float80), (inout Int, Int), (inout Int16, Int16),\
    \ (inout Int32, Int32), (inout Int64, Int64), (inout Int8, Int8), (inout String,\
    \ String), (inout SuspendingClock.Instant, Duration), (inout UInt, UInt), (inout\
    \ UInt16, UInt16), (inout UInt32, UInt32), (inout UInt64, UInt64), (inout UInt8,\
    \ UInt8)\n            buckets[col] += (col == 1)\n                         ^\n"
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // init result and buckets\n   \
    \ var result = 0\n    var buckets = [Int](capacity)\n    \n    // init bucket\
    \ index\n    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = capacity\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n\
    \    // init bucket capacity\n    var bucketCapacity = capacity\n    \n    //\
    \ init bucket index\n    var bucketIndex = 0\n    \n    // init bucket capacity\n\
    \    var bucketCapacity = capacity\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = capacity\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ capacity\n    var bucketCapacity = capacity\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = capacity\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n\
    \    // init bucket capacity\n    var bucketCapacity = capacity\n    \n    //\
    \ init bucket index\n    var bucketIndex = 0\n    \n    // init bucket capacity\n\
    \    var bucketCapacity = capacity\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = capacity\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ capacity\n    var bucketCapacity = capacity\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = capacity\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n\
    \    // init bucket capacity\n    var bucketCapacity = capacity\n    \n    //\
    \ init bucket index\n    var bucketIndex = 0\n    \n    // init bucket capacity\n\
    \    var bucketCapacity = capacity\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = capacity\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ capacity\n    var bucketCapacity = capacity\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = capacity\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n\
    \    // init bucket capacity\n    var bucketCapacity = capacity\n    \n    //\
    \ init bucket index\n    var bucketIndex = 0\n    \n    // init bucket capacity\n\
    \    var bucketCapacity = capacity\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = capacity\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // \n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpnxewdgyf.swift:33:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpnxewdgyf.swift:42:9: error: invalid\
    \ redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n/tmp/tmpnxewdgyf.swift:36:9:\
    \ note: 'bucketIndex' previously declared here\n    var bucketIndex = 0\n    \
    \    ^\n/tmp/tmpnxewdgyf.swift:45:9: error: invalid redeclaration of 'bucketCapacity'\n\
    \    var bucketCapacity = capacity\n        ^\n/tmp/tmpnxewdgyf.swift:39:9: note:\
    \ 'bucketCapacity' previously declared here\n    var bucketCapacity = capacity\n\
    \        ^\n/tmp/tmpnxewdgyf.swift:48:9: error: invalid redeclaration of 'bucketIndex'\n\
    \    var bucketIndex = 0\n        ^\n/tmp/tmpnxewdgyf.swift:36:9: note: 'bucketIndex'\
    \ previously declared here\n    var bucketIndex = 0\n        ^\n/tmp/tmpnxewdgyf.swift:51:9:\
    \ error: invalid redeclaration of 'bucketCapacity'\n    var bucketCapacity = capacity\n\
    \        ^\n/tmp/tmpnxewdgyf.swift:39:9: note: 'bucketCapacity' previously declared\
    \ here\n    var bucketCapacity = capacity\n        ^\n/tmp/tmpnxewdgyf.swift:54:9:\
    \ error: invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n   \
    \     ^\n/tmp/tmpnxewdgyf.swift:36:9: note: 'bucketIndex' previously declared\
    \ here\n    var bucketIndex = 0\n        ^\n/tmp/tmpnxewdgyf.swift:57:9: error:\
    \ invalid redeclaration of 'bucketCapacity'\n    var bucketCapacity = capacity\n\
    \        ^\n/tmp/tmpnxewdgyf.swift:39:9: note: 'bucketCapacity' previously declared\
    \ here\n    var bucketCapacity = capacity\n        ^\n/tmp/tmpnxewdgyf.swift:60:9:\
    \ error: invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n   \
    \     ^\n/tmp/tmpnxewdgyf.swift:36:9: note: 'bucketIndex' previously declared\
    \ here\n    var bucketIndex = 0\n        ^\n/tmp/tmpnxewdgyf.swift:63:9: error:\
    \ invalid redeclaration of 'bucketCapacity'\n    var bucketCapacity = capacity\n\
    \        ^\n/tmp/tmpnxewdgyf.swift:39:9: note: 'bucketCapacity' previously declared\
    \ here\n    var bucketCapacity = capacity\n        ^\n/tmp/tmpnxewdgyf.swift:66"
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // init result\n    var result =\
    \ 0\n    \n    // init bucket array\n    var buckets = [Int](capacity)\n    \n\
    \    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket capacity\n\
    \    var bucketCapacity = capacity\n    \n    // init bucket sum\n    var bucketSum\
    \ = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init\
    \ bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket sum\n    var\
    \ bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n   \
    \ \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ sum\n    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket sum\n    var\
    \ bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n   \
    \ \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ sum\n    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket sum\n    var\
    \ bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n   \
    \ \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n\
    \    \n    // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket\
    \ sum\n    var bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket index\n    var bucketIndex = 0\n    \n    // init bucket sum\n    var\
    \ bucketSum = 0\n    \n    // init bucket index\n    var bucketIndex = 0\n   \
    \ \n    // init bucket \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpb5wictce.swift:35:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpb5wictce.swift:47:9: error: invalid\
    \ redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n/tmp/tmpb5wictce.swift:38:9:\
    \ note: 'bucketIndex' previously declared here\n    var bucketIndex = 0\n    \
    \    ^\n/tmp/tmpb5wictce.swift:50:9: error: invalid redeclaration of 'bucketSum'\n\
    \    var bucketSum = 0\n        ^\n/tmp/tmpb5wictce.swift:44:9: note: 'bucketSum'\
    \ previously declared here\n    var bucketSum = 0\n        ^\n/tmp/tmpb5wictce.swift:53:9:\
    \ error: invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n   \
    \     ^\n/tmp/tmpb5wictce.swift:38:9: note: 'bucketIndex' previously declared\
    \ here\n    var bucketIndex = 0\n        ^\n/tmp/tmpb5wictce.swift:56:9: error:\
    \ invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n        ^\n/tmp/tmpb5wictce.swift:44:9:\
    \ note: 'bucketSum' previously declared here\n    var bucketSum = 0\n        ^\n\
    /tmp/tmpb5wictce.swift:59:9: error: invalid redeclaration of 'bucketIndex'\n \
    \   var bucketIndex = 0\n        ^\n/tmp/tmpb5wictce.swift:38:9: note: 'bucketIndex'\
    \ previously declared here\n    var bucketIndex = 0\n        ^\n/tmp/tmpb5wictce.swift:62:9:\
    \ error: invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n       \
    \ ^\n/tmp/tmpb5wictce.swift:44:9: note: 'bucketSum' previously declared here\n\
    \    var bucketSum = 0\n        ^\n/tmp/tmpb5wictce.swift:65:9: error: invalid\
    \ redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n        ^\n/tmp/tmpb5wictce.swift:38:9:\
    \ note: 'bucketIndex' previously declared here\n    var bucketIndex = 0\n    \
    \    ^\n/tmp/tmpb5wictce.swift:68:9: error: invalid redeclaration of 'bucketSum'\n\
    \    var bucketSum = 0\n        ^\n/tmp/tmpb5wictce.swift:44:9: note: 'bucketSum'\
    \ previously declared here\n    var bucketSum = 0\n        ^\n/tmp/tmpb5wictce.swift:71:9:\
    \ error: invalid redeclaration of 'bucketIndex'\n    var bucketIndex = 0\n   \
    \     ^\n/tmp/tmpb5wictce.swift:38:9: note: 'bucketIndex' pre"
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var max = 0\n    var buckets = [Int](capacity)\n\
    \    for row in grid {\n        for col in row {\n            buckets[col] -=\
    \ 1\n            if buckets[col] < 0 {\n                buckets[col] = 0\n   \
    \         }\n        }\n    }\n    for bucket in buckets {\n        if bucket\
    \ > 0 {\n            max += 1\n        }\n    }\n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpihdrjnq7.swift:31:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // init result\n    var result =\
    \ 0\n    \n    // init bucket array\n    var buckets = [Int](capacity)\n    \n\
    \    // init bucket count\n    var bucketCount = 0\n    \n    // init bucket index\n\
    \    var bucketIndex = 0\n    \n    // init bucket capacity\n    var bucketCapacity\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket max index\n    var bucketMaxIndex = 0\n    \n    // init bucket max value\n\
    \    var bucketMaxValue = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min value\n    var bucketMinValue = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min value\n    var bucketMinValue = 0\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket min value\n    var bucketMinValue\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min value\n    var bucketMinValue = 0\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = 0\n    \n    // init bucket min value\n\
    \    var bucketMinValue = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min value\n    var bucketMinValue = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min value\n    var bucketMinValue = 0\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket min value\n    var bucketMinValue\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min value\n    var bucketMinValue = 0\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = 0\n    \n    // init bucket min value\n\
    \    var bucketMinValue = 0\n    \n    // init bucket min index\n    var bucketMinIndex\
    \ = 0\n    \n    // init bucket min value\n    var bucketMinValue = 0\n    \n\
    \    // init bucket min index\n    var bucketMinIndex = 0\n    \n    // init bucket\
    \ min value\n    var bucketMinValue = 0\n    \n    // init bucket min index\n\
    \    var bucketMinIndex = 0\n    \n    // init bucket min value\n    var bucketMinValue\
    \ = 0\n    \n    // init bucket min index\n    var bucketMinIndex = 0\n    \n\
    \    // init bucket min value\n    var bucketMinValue = 0\n    \n    // init bucket\
    \ min index\n    var bucketMinIndex = 0\n    \n    // init \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpx_a6tehl.swift:35:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpx_a6tehl.swift:62:9: error: invalid\
    \ redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpx_a6tehl.swift:56:9:\
    \ note: 'bucketMinIndex' previously declared here\n    var bucketMinIndex = 0\n\
    \        ^\n/tmp/tmpx_a6tehl.swift:65:9: error: invalid redeclaration of 'bucketMinValue'\n\
    \    var bucketMinValue = 0\n        ^\n/tmp/tmpx_a6tehl.swift:59:9: note: 'bucketMinValue'\
    \ previously declared here\n    var bucketMinValue = 0\n        ^\n/tmp/tmpx_a6tehl.swift:68:9:\
    \ error: invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n\
    \        ^\n/tmp/tmpx_a6tehl.swift:56:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpx_a6tehl.swift:71:9: error:\
    \ invalid redeclaration of 'bucketMinValue'\n    var bucketMinValue = 0\n    \
    \    ^\n/tmp/tmpx_a6tehl.swift:59:9: note: 'bucketMinValue' previously declared\
    \ here\n    var bucketMinValue = 0\n        ^\n/tmp/tmpx_a6tehl.swift:74:9: error:\
    \ invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n    \
    \    ^\n/tmp/tmpx_a6tehl.swift:56:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpx_a6tehl.swift:77:9: error:\
    \ invalid redeclaration of 'bucketMinValue'\n    var bucketMinValue = 0\n    \
    \    ^\n/tmp/tmpx_a6tehl.swift:59:9: note: 'bucketMinValue' previously declared\
    \ here\n    var bucketMinValue = 0\n        ^\n/tmp/tmpx_a6tehl.swift:80:9: error:\
    \ invalid redeclaration of 'bucketMinIndex'\n    var bucketMinIndex = 0\n    \
    \    ^\n/tmp/tmpx_a6tehl.swift:56:9: note: 'bucketMinIndex' previously declared\
    \ here\n    var bucketMinIndex = 0\n        ^\n/tmp/tmpx_a6tehl.swift:83:9: error:\
    \ invalid redeclaration of 'bucketMinValue'\n    var bucketMinValue = 0\n    \
    \    ^\n/tmp/tmpx_a6tehl.swift:59:9: note: 'bucketMinValue' previously declared\
    \ here\n    var bucketMinValue = 0\n        ^\n/tmp/tmpx_a6tehl.swift:86:9: erro"
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var result = 0\n    \n    for row\
    \ in grid {\n        var max = 0\n        for _ in row {\n            max += _\n\
    \        }\n        \n        if max > capacity {\n            result += capacity\
    \ - max\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmplrrjchbu.swift:36:20: error: '_' can only appear in a pattern or\
    \ on the left side of an assignment\n            max += _\n                  \
    \ ^\n"
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var count = 0\n    var max = 0\n\
    \    var min = 0\n    \n    for row in 0..<grid.count {\n        for col in 0..<grid[row].count\
    \ {\n            if grid[row][col] == 1 {\n                count += 1\n      \
    \          min = count if min == 0 else min\n                max = count if max\
    \ == 0 else max\n            }\n        }\n    }\n    \n    if min == max {\n\
    \        return 0\n    }\n    \n    if capacity == 0 {\n        return max\n \
    \   }\n    \n    if capacity == 1 {\n        return min\n    }\n    \n    if capacity\
    \ > max {\n        return max\n    }\n    \n    if capacity < min {\n        return\
    \ min\n    }\n    \n    if capacity == min {\n        return min\n    }\n    \n\
    \    if capacity == max {\n        return max\n    }\n    \n    if capacity ==\
    \ count {\n        return count\n    }\n    \n    if capacity == max - min {\n\
    \        return max - min\n    }\n    \n    if capacity == count - max {\n   \
    \     return count - max\n    }\n    \n    if capacity == max - min - count {\n\
    \        return max - min - count\n    }\n    \n    if capacity == max - min -\
    \ count - max {\n        return max - min - count - max\n    }\n    \n    if capacity\
    \ == max - min - count - max - min {\n        return max - min - count - max -\
    \ min\n    }\n    \n    if capacity == max - min - count - max - min - count {\n\
    \        return max - min - count - max - min - count\n    }\n    \n    if capacity\
    \ == max - min - count - max - min - count - max {\n        return max - min -\
    \ count - max - min - count - max\n    }\n    \n    if capacity == max - min -\
    \ count - max - min - count - max - min {\n        return max - min - count -\
    \ max - min - count - max - min\n    }\n    \n    if capacity == max - min - count\
    \ - max - min - count - max - min - count {\n        return max - min - count\
    \ - max - min - count - max - min - count\n    }\n    \n    if capacity == max\
    \ - min - count - max - min - count - max - min - count - max {\n        return\
    \ max - min - count - max - min - count - max - min - count - max\n    }\n   \
    \ \n    if capacity == max - min - count - max - min - count - max - min - count\
    \ - max - min {\n        return max - min - count - max - min - count - max -\
    \ min - count - max - min\n    }\n    \n    if capacity == max - min - count -\
    \ max - min - count - max - min - \n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmpesal8j0c.swift:39:28: error: consecutive statements on a line must\
    \ be separated by ';'\n                min = count if min == 0 else min\n    \
    \                       ^\n                           ;\n/tmp/tmpesal8j0c.swift:39:41:\
    \ error: unexpected 'else' immediately following 'if' condition\n            \
    \    min = count if min == 0 else min\n                                      \
    \  ^\n/tmp/tmpesal8j0c.swift:39:41: note: remove 'else' to execute the braced\
    \ block of statements when the condition is true\n                min = count\
    \ if min == 0 else min\n                                        ^~~~~\n      \
    \                                  \n/tmp/tmpesal8j0c.swift:39:46: error: expected\
    \ '{' after 'if' condition\n                min = count if min == 0 else min\n\
    \                                             ^\n/tmp/tmpesal8j0c.swift:40:41:\
    \ error: unexpected 'else' immediately following 'if' condition\n            \
    \    max = count if max == 0 else max\n                                      \
    \  ^\n/tmp/tmpesal8j0c.swift:40:41: note: remove 'else' to execute the braced\
    \ block of statements when the condition is true\n                max = count\
    \ if max == 0 else max\n                                        ^~~~~\n      \
    \                                  \n/tmp/tmpesal8j0c.swift:40:46: error: expected\
    \ '{' after 'if' condition\n                max = count if max == 0 else max\n\
    \                                             ^\n/tmp/tmpesal8j0c.swift:122:1:\
    \ error: expected expression after operator\n}\n^\n"
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var buckets = [Int](capacity)\n\
    \    for row in grid {\n        var bucket = buckets[row[0]]\n        for cell\
    \ in row {\n            bucket += cell\n            if bucket > capacity {\n \
    \               bucket = capacity\n            }\n        }\n        buckets[row[0]]\
    \ = bucket\n        result += bucket\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp9w168yoh.swift:31:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    // init result\n    var result =\
    \ 0\n    \n    // init bucket array\n    var buckets = [Int](repeating: 0, count:\
    \ capacity)\n    \n    // init bucket count\n    var bucketCount = 0\n    \n \
    \   // init bucket index\n    var bucketIndex = 0\n    \n    // init bucket capacity\n\
    \    var bucketCapacity = 0\n    \n    // init bucket sum\n    var bucketSum =\
    \ 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket\
    \ sum\n    var bucketSum = 0\n    \n    // init bucket sum\n    var bucketSum\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket sum\n    var bucketSum = 0\n    \n    // init bucket sum\n    var bucketSum\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket sum\n    var bucketSum = 0\n    \n    // init bucket sum\n    var bucketSum\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket sum\n    var bucketSum = 0\n    \n    // init bucket sum\n    var bucketSum\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket sum\n    var bucketSum = 0\n    \n    // init bucket sum\n    var bucketSum\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket sum\n    var bucketSum = 0\n    \n    // init bucket sum\n    var bucketSum\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket sum\n    var bucketSum = 0\n    \n    // init bucket sum\n    var bucketSum\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket sum\n    var bucketSum = 0\n    \n    // init bucket sum\n    var bucketSum\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket sum\n    var bucketSum = 0\n    \n    // init bucket sum\n    var bucketSum\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket sum\n    var bucketSum = 0\n    \n    // init bucket sum\n    var bucketSum\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket sum\n    var bucketSum = 0\n    \n    // init bucket sum\n    var bucketSum\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket sum\n    var bucketSum = 0\n    \n    // init bucket sum\n    var bucketSum\
    \ = 0\n    \n    // \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpj5o7jnbg.swift:50:9: error: invalid redeclaration of 'bucketSum'\n\
    \    var bucketSum = 0\n        ^\n/tmp/tmpj5o7jnbg.swift:47:9: note: 'bucketSum'\
    \ previously declared here\n    var bucketSum = 0\n        ^\n/tmp/tmpj5o7jnbg.swift:53:9:\
    \ error: invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n       \
    \ ^\n/tmp/tmpj5o7jnbg.swift:47:9: note: 'bucketSum' previously declared here\n\
    \    var bucketSum = 0\n        ^\n/tmp/tmpj5o7jnbg.swift:56:9: error: invalid\
    \ redeclaration of 'bucketSum'\n    var bucketSum = 0\n        ^\n/tmp/tmpj5o7jnbg.swift:47:9:\
    \ note: 'bucketSum' previously declared here\n    var bucketSum = 0\n        ^\n\
    /tmp/tmpj5o7jnbg.swift:59:9: error: invalid redeclaration of 'bucketSum'\n   \
    \ var bucketSum = 0\n        ^\n/tmp/tmpj5o7jnbg.swift:47:9: note: 'bucketSum'\
    \ previously declared here\n    var bucketSum = 0\n        ^\n/tmp/tmpj5o7jnbg.swift:62:9:\
    \ error: invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n       \
    \ ^\n/tmp/tmpj5o7jnbg.swift:47:9: note: 'bucketSum' previously declared here\n\
    \    var bucketSum = 0\n        ^\n/tmp/tmpj5o7jnbg.swift:65:9: error: invalid\
    \ redeclaration of 'bucketSum'\n    var bucketSum = 0\n        ^\n/tmp/tmpj5o7jnbg.swift:47:9:\
    \ note: 'bucketSum' previously declared here\n    var bucketSum = 0\n        ^\n\
    /tmp/tmpj5o7jnbg.swift:68:9: error: invalid redeclaration of 'bucketSum'\n   \
    \ var bucketSum = 0\n        ^\n/tmp/tmpj5o7jnbg.swift:47:9: note: 'bucketSum'\
    \ previously declared here\n    var bucketSum = 0\n        ^\n/tmp/tmpj5o7jnbg.swift:71:9:\
    \ error: invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n       \
    \ ^\n/tmp/tmpj5o7jnbg.swift:47:9: note: 'bucketSum' previously declared here\n\
    \    var bucketSum = 0\n        ^\n/tmp/tmpj5o7jnbg.swift:74:9: error: invalid\
    \ redeclaration of 'bucketSum'\n    var bucketSum = 0\n        ^\n/tmp/tmpj5o7jnbg.swift:47:9:\
    \ note: 'bucketSum' previously declared here\n    var bucketSum = 0\n        ^\n\
    /tmp/tmpj5o7jnbg.swift:77:9: error: invalid redeclaration of 'bucketSum'\n   \
    \ var bucketSum = 0\n        ^\n/tmp/tmpj5o7jnbg.swift:47:9: note: 'bucketSum'\
    \ previously decl"
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var buckets = [Int](capacity)\n\
    \    for row in grid {\n        for col in row {\n            buckets[col] -=\
    \ 1\n            if buckets[col] == 0 {\n                buckets[col] = capacity\n\
    \                result += buckets[col]\n            }\n        }\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpd3tv1q5h.swift:31:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var result = 0\n    \n    for row\
    \ in 0..<grid.count {\n        for col in 0..<grid[row].count {\n            \n\
    \            let bucket = grid[row][col]\n            \n            if bucket\
    \ == 0 {\n                \n                let bucketCapacity = capacity / bucket\n\
    \                \n                for i in 0..<bucketCapacity {\n           \
    \         \n                    grid[row][col] = i\n                    \n   \
    \                 result += max_fill(grid, capacity)\n                    \n \
    \                   grid[row][col] = 0\n                }\n            }\n   \
    \     }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmpq2wey_yr.swift:44:30: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                    grid[row][col] = i\n              \
    \      ~~~~     ^\n/tmp/tmpq2wey_yr.swift:46:39: error: missing argument labels\
    \ 'grid:capacity:' in call\n                    result += max_fill(grid, capacity)\n\
    \                                      ^\n                                   \
    \    grid: capacity: \n/tmp/tmpq2wey_yr.swift:48:30: error: cannot assign through\
    \ subscript: 'grid' is a 'let' constant\n                    grid[row][col] =\
    \ 0\n                    ~~~~     ^\n"
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var count = 0\n    var max = 0\n\
    \    var min = 0\n    \n    for row in grid {\n        for col in row {\n    \
    \        if col == 1 {\n                count += 1\n                min = max(min,\
    \ col)\n                max = min(max, col)\n            }\n        }\n    }\n\
    \    \n    if count > 0 {\n        \n        if min == max {\n            return\
    \ count\n        }\n        \n        return count + min - max\n    }\n    \n\
    \    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpxhlwg37n.swift:39:23: error: cannot call value of non-function\
    \ type 'Int'\n                min = max(min, col)\n                      ^\n/tmp/tmpxhlwg37n.swift:40:23:\
    \ error: cannot call value of non-function type 'Int'\n                max = min(max,\
    \ col)\n                      ^\n"
  stdout: ''
  timestamp: 1659824663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    \n    var result = 0\n    \n    for row\
    \ in 0..<grid.count {\n        for col in 0..<grid[row].count {\n            if\
    \ grid[row][col] == 1 {\n                result += capacity\n            }\n \
    \       }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmplgfc1sju/tmplgfc1sju.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0e56e2ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0e56b21b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0e56b21988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0e56b207b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplgfc1sju                        0x000055a8443a6827 <unavailable> + 6183

    5    libc.so.6                          0x00002b0e57016460 __libc_start_main +
    245

    6    tmplgfc1sju                        0x000055a8443a61e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659824663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var max = 0\n    var buckets = make([][]int,\
    \ capacity)\n    for row in grid {\n        for col in row {\n            buckets[col%capacity]\
    \ = append(buckets[col%capacity], 0)\n        }\n    }\n    for row in grid {\n\
    \        for col in row {\n            buckets[col%capacity][row%capacity] = buckets[col%capacity][row%capacity]\
    \ + 1\n        }\n    }\n    for bucket in buckets {\n        if bucket[0] > max\
    \ {\n            max = bucket[0]\n        }\n    }\n    return max\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp4z14cc45.swift:31:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmp4z14cc45.swift:31:19: error: cannot find 'make' in scope\n\
    \    var buckets = make([][]int, capacity)\n                  ^~~~\n/tmp/tmp4z14cc45.swift:31:28:\
    \ error: cannot find 'int' in scope\n    var buckets = make([][]int, capacity)\n\
    \                           ^~~\n/tmp/tmp4z14cc45.swift:31:27: error: missing\
    \ argument for parameter #1 in call\n    var buckets = make([][]int, capacity)\n\
    \                          ^\n                          <#Int#>\nSwift.Array:16:23:\
    \ note: 'subscript(_:)' declared here\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\n/tmp/tmp4z14cc45.swift:34:37:\
    \ error: cannot find 'append' in scope\n            buckets[col%capacity] = append(buckets[col%capacity],\
    \ 0)\n                                    ^~~~~~\n/tmp/tmp4z14cc45.swift:39:73:\
    \ error: cannot convert value of type '[Int]' to expected argument type 'Int'\n\
    \            buckets[col%capacity][row%capacity] = buckets[col%capacity][row%capacity]\
    \ + 1\n                                                                      \
    \  ^\n/tmp/tmp4z14cc45.swift:39:35: error: cannot convert value of type '[Int]'\
    \ to expected argument type 'Int'\n            buckets[col%capacity][row%capacity]\
    \ = buckets[col%capacity][row%capacity] + 1\n                                \
    \  ^\n"
  stdout: ''
  timestamp: 1659824668
