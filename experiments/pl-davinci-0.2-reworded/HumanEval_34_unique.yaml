name: HumanEval_34_unique
language: pl
prompt: "# Return sorted unique elements in an array\n# >>> unique([5, 3, 5, 2, 3,\
  \ 3, 9, 0, 123])\n# [0, 2, 3, 5, 9, 123]\nsub unique {\n    my($l) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&unique;\n\
  \        if(eq_deeply($candidate->([5, 3, 5, 2, 3, 3, 9, 0, 123]),[0, 2, 3, 5, 9,\
  \ 123])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my(%h, @r);\n    foreach (@$l) {\n        push(@r, $_) unless $h{$_}++;\n\
    \    }\n    return \\@r;\n}", "    my %h;\n    @h{@$l} = ();\n    return [sort\
    \ keys %h];\n}", "    my %h;\n    my @r;\n    foreach my $e (@$l) {\n        if\
    \ (!$h{$e}) {\n            $h{$e} = 1;\n            push @r, $e;\n        }\n\
    \    }\n    return \\@r;\n}", "    my %h;\n    foreach (@$l) {\n        $h{$_}\
    \ = 1;\n    }\n    return [sort {$a <=> $b} keys %h];\n}", "    my %h;\n    foreach\
    \ my $e (@$l) {\n        $h{$e} = 1;\n    }\n    return [sort {$a <=> $b} keys\
    \ %h];\n}", "    my %h;\n    foreach (@$l) {\n        $h{$_} = 1;\n    }\n   \
    \ return [sort {$a <=> $b} keys %h];\n}", "    my %h;\n    for (@$l) {\n     \
    \   $h{$_} = 1;\n    }\n    return sort { $a <=> $b } keys %h;\n}", "    my %h;\n\
    \    @h{@$l} = ();\n    return [sort {$a <=> $b} keys %h];\n}", "    my %h;\n\
    \    foreach my $e (@$l) {\n        $h{$e} = 1;\n    }\n    return sort { $a <=>\
    \ $b } keys %h;\n}", "    my %h;\n    foreach (@$l) {\n        $h{$_} = 1;\n \
    \   }\n    return [sort {$a <=> $b} keys %h];\n}", "    my %h;\n    foreach my\
    \ $e (@$l) {\n        $h{$e} = 1;\n    }\n    return [sort {$a <=> $b} keys %h];\n\
    }", "    my %h;\n    foreach (@$l) {\n        $h{$_} = 1;\n    }\n    return [\
    \ sort { $a <=> $b } keys %h ];\n}", "    my %h;\n    foreach my $e (@$l) {\n\
    \        $h{$e} = 1;\n    }\n    return [sort {$a <=> $b} keys %h];\n}", "   \
    \ my(%h, @r);\n    foreach (@$l) {\n        push(@r, $_) unless $h{$_}++;\n  \
    \  }\n    return \\@r;\n}", "    my %h;\n    my @u;\n    foreach my $e (@$l) {\n\
    \        if (!exists $h{$e}) {\n            $h{$e} = 1;\n            push @u,\
    \ $e;\n        }\n    }\n    return @u;\n}", "    my %h;\n    foreach (@$l) {\n\
    \        $h{$_} = 1;\n    }\n    return [sort keys %h];\n}", "    my(%h, @u);\n\
    \    foreach (@$l) {\n        push(@u, $_) unless $h{$_}++;\n    }\n    return\
    \ \\@u;\n}", "    my %h;\n    for (@$l) {\n        $h{$_} = 1;\n    }\n    return\
    \ [sort keys %h];\n}", "    my %h;\n    foreach my $e (@$l) {\n        $h{$e}\
    \ = 1;\n    }\n    return [sort {$a <=> $b} keys %h];\n}", "    my(%h, @u);\n\
    \    foreach (@$l) {\n        $h{$_} = 1;\n    }\n    @u = sort { $a <=> $b }\
    \ keys %h;\n    return \\@u;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
