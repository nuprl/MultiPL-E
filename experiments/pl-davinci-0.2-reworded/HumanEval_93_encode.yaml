name: HumanEval_93_encode
language: pl
prompt: "# Write a function that takes a message, and encodes in such a \n# way that\
  \ it swaps case of all letters, replaces all vowels in \n# the message with the\
  \ letter that appears 2 places ahead of that \n# vowel in the english alphabet.\
  \ \n# Assume only letters. \n# Examples:\n# >>> encode(\"test\")\n# \"TGST\"\n#\
  \ >>> encode(\"This is a message\")\n# \"tHKS KS C MGSSCGG\"\nsub encode {\n   \
  \ my($message) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&encode;\n\
  \        if(eq_deeply($candidate->(\"TEST\"),\"tgst\")) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Mudasir\"\
  ),\"mWDCSKR\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n  \
  \      if(eq_deeply($candidate->(\"YES\"),\"ygs\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(\"This is a message\"\
  ),\"tHKS KS C MGSSCGG\")) {\n        print \"ok!\" }else{\n        exit 1;\n   \
  \     }\n        if(eq_deeply($candidate->(\"I DoNt KnOw WhAt tO WrItE\"),\"k dQnT\
  \ kNqW wHcT Tq wRkTg\")) {\n        print \"ok!\" }else{\n        exit 1;\n    \
  \    }\n}\n\ntesthumaneval();"
completions: ["    my $encoded = \"\";\n    my @vowels = (\"a\",\"e\",\"i\",\"o\"\
    ,\"u\");\n    foreach my $char (split //, $message) {\n        if (grep {$_ eq\
    \ lc($char)} @vowels) {\n            my $index = (grep {$_ eq lc($char)} @vowels)[0];\n\
    \            my $new_index = ($index + 2) % 5;\n            $encoded .= uc($vowels[$new_index]);\n\
    \        } else {\n            $encoded .= uc($char);\n        }\n    }\n    return\
    \ $encoded;\n}", "    my @message = split(//, $message);\n    my $encoded = \"\
    \";\n    my $vowels = \"aeiou\";\n    my $vowels_hash = {};\n    my @vowels =\
    \ split(//, $vowels);\n    for(my $i = 0; $i < scalar(@vowels); $i++) {\n    \
    \    $vowels_hash->{$vowels[$i]} = $vowels[($i + 2) % 5];\n    }\n    for(my $i\
    \ = 0; $i < scalar(@message); $i++) {\n        if(exists($vowels_hash->{lc($message[$i])}))\
    \ {\n            $encoded .= $vowels_hash->{lc($message[$i])};\n        }\n  \
    \      elsif(lc($message[$i]) eq $message[$i]) {\n            $encoded .= uc($message[$i]);\n\
    \        }\n        else {\n            $encoded .= lc($message[$i]);\n      \
    \  }\n    }\n    return $encoded;\n}", "    my @message = split //, $message;\n\
    \    my $encoded_message = '';\n    my %vowels = (\n        'a' => 'c',\n    \
    \    'e' => 'g',\n        'i' => 'k',\n        'o' => 'q',\n        'u' => 'y',\n\
    \    );\n    foreach my $letter (@message) {\n        if ($letter =~ /[a-z]/i)\
    \ {\n            if ($letter =~ /[a-z]/) {\n                $letter = uc $letter;\n\
    \            }\n            else {\n                $letter = lc $letter;\n  \
    \          }\n        }\n        if ($letter =~ /[aeiou]/i) {\n            $letter\
    \ = $vowels{lc $letter};\n        }\n        $encoded_message .= $letter;\n  \
    \  }\n    return $encoded_message;\n}", "    my @message = split(//, $message);\n\
    \    my @vowels = ('a', 'e', 'i', 'o', 'u');\n    my @encoded_message;\n    foreach\
    \ my $char (@message) {\n        if (is_vowel($char)) {\n            push(@encoded_message,\
    \ next_vowel($char));\n        } else {\n            push(@encoded_message, $char);\n\
    \        }\n    }\n    return join(\"\", @encoded_message);\n}", "    my $encoded_message\
    \ = \"\";\n    my @vowels = ('a', 'e', 'i', 'o', 'u');\n    my %vowel_map = (\n\
    \        'a' => 'c',\n        'e' => 'g',\n        'i' => 'k',\n        'o' =>\
    \ 'q',\n        'u' => 'y',\n    );\n    for my $letter (split //, $message) {\n\
    \        if (grep {$_ eq $letter} @vowels) {\n            $encoded_message .=\
    \ $vowel_map{$letter};\n        } else {\n            $encoded_message .= $letter;\n\
    \        }\n    }\n    return $encoded_message;\n}", "    my $encoded = \"\";\n\
    \    my @vowels = ('a', 'e', 'i', 'o', 'u');\n    my %vowels = map { $_ => 1 }\
    \ @vowels;\n    my %letters = map { $_ => 1 } ('a'..'z');\n    my %letters_upper\
    \ = map { $_ => 1 } ('A'..'Z');\n    my %letters_lower = map { $_ => 1 } ('a'..'z');\n\
    \    my %letters_upper_lower = map { $_ => 1 } ('A'..'Z', 'a'..'z');\n    my %letters_lower_upper\
    \ = map { $_ => 1 } ('a'..'z', 'A'..'Z');\n    my %letters_lower_upper_lower =\
    \ map { $_ => 1 } ('a'..'z', 'A'..'Z', 'a'..'z');\n    my %letters_upper_lower_upper\
    \ = map { $_ => 1 } ('A'..'Z', 'a'..'z', 'A'..'Z');\n    my %letters_upper_lower_upper_lower\
    \ = map { $_ => 1 } ('A'..'Z', 'a'..'z', 'A'..'Z', 'a'..'z');\n    my %letters_lower_upper_lower_upper\
    \ = map { $_ => 1 } ('a'..'z', 'A'..'Z', 'a'..'z', 'A'..'Z');\n    my %letters_lower_upper_lower_upper_lower\
    \ = map { $_ => 1 } ('a'..'z', 'A'..'Z', 'a'..'z', 'A'..'Z', 'a'..'z');\n    my\
    \ %letters_upper_lower_upper_lower_upper = map { $_ => 1 } ('A'..'Z', 'a'..'z',\
    \ 'A'..'Z', 'a'..'z', 'A'..'Z');\n    my %letters_upper_lower_upper_lower_upper_lower\
    \ = map { $_ => 1 } ('A'..'Z', 'a'..'z', 'A'..'Z', 'a'..'z',", "    my $encoded_message\
    \ = \"\";\n    my @message_array = split(//, $message);\n    my $vowels = \"aeiou\"\
    ;\n    my @vowels_array = split(//, $vowels);\n    my %vowels_hash = (\n     \
    \   \"a\" => \"c\",\n        \"e\" => \"g\",\n        \"i\" => \"k\",\n      \
    \  \"o\" => \"q\",\n        \"u\" => \"y\",\n    );\n    foreach my $letter (@message_array)\
    \ {\n        if ($letter =~ /[a-z]/) {\n            $letter =~ tr/a-z/A-Z/;\n\
    \            $encoded_message .= $letter;\n        } elsif ($letter =~ /[A-Z]/)\
    \ {\n            $letter =~ tr/A-Z/a-z/;\n            $encoded_message .= $letter;\n\
    \        } else {\n            $encoded_message .= $letter;\n        }\n    }\n\
    \    foreach my $vowel (@vowels_array) {\n        $encoded_message =~ s/$vowel/$vowels_hash{$vowel}/g;\n\
    \    }\n    return $encoded_message;\n}", "    my $encoded = \"\";\n    my @vowels\
    \ = ('a', 'e', 'i', 'o', 'u');\n    foreach my $char (split //, $message) {\n\
    \        if ($char =~ /[a-z]/i) {\n            if ($char =~ /[a-z]/) {\n     \
    \           $char =~ tr/a-z/A-Z/;\n            } else {\n                $char\
    \ =~ tr/A-Z/a-z/;\n            }\n            if (grep {$_ eq lc($char)} @vowels)\
    \ {\n                my $index = 0;\n                foreach my $vowel (@vowels)\
    \ {\n                    if ($vowel eq lc($char)) {\n                        $index\
    \ = $index + 2;\n                        if ($index > 4) {\n                 \
    \           $index = $index - 5;\n                        }\n                \
    \        $char = $vowels[$index];\n                        last;\n           \
    \         }\n                }\n            }\n        }\n        $encoded = $encoded\
    \ . $char;\n    }\n    return $encoded;\n}", "    my $encoded_message = \"\";\n\
    \    my @vowels = (\"a\", \"e\", \"i\", \"o\", \"u\");\n    my %vowel_hash = map\
    \ { $_ => 1 } @vowels;\n    my %letter_hash = (\n        \"a\" => \"c\",\n   \
    \     \"b\" => \"d\",\n        \"c\" => \"e\",\n        \"d\" => \"f\",\n    \
    \    \"e\" => \"g\",\n        \"f\" => \"h\",\n        \"g\" => \"i\",\n     \
    \   \"h\" => \"j\",\n        \"i\" => \"k\",\n        \"j\" => \"l\",\n      \
    \  \"k\" => \"m\",\n        \"l\" => \"n\",\n        \"m\" => \"o\",\n       \
    \ \"n\" => \"p\",\n        \"o\" => \"q\",\n        \"p\" => \"r\",\n        \"\
    q\" => \"s\",\n        \"r\" => \"t\",\n        \"s\" => \"u\",\n        \"t\"\
    \ => \"v\",\n        \"u\" => \"w\",\n        \"v\" => \"x\",\n        \"w\" =>\
    \ \"y\",\n        \"x\" => \"z\",\n        \"y\" => \"a\",\n        \"z\" => \"\
    b\",\n    );\n    for my $letter (split //, $message) {\n        if ($vowel_hash{$letter})\
    \ {\n            $encoded_message .= $letter_hash{$letter};\n        } elsif ($letter\
    \ =~ /[A-Z]/) {\n            $encoded_message .= lc($letter);\n        } elsif\
    \ ($letter =~ /[a-z]/) {\n            $encoded_message .= uc($letter);\n     \
    \   } else {\n            $encoded_message .= $letter;\n        }\n    }\n   \
    \ return $encoded_message;\n}", "    my $encoded = \"\";\n    my @vowels = ('a',\
    \ 'e', 'i', 'o', 'u');\n    my %vowels = map { $_ => 1 } @vowels;\n    my %alphabet\
    \ = map { $_ => 1 } ('a'..'z');\n    my %alphabet_upper = map { $_ => 1 } ('A'..'Z');\n\
    \    my $alphabet_size = scalar keys %alphabet;\n    my $alphabet_upper_size =\
    \ scalar keys %alphabet_upper;\n    foreach my $char (split //, $message) {\n\
    \        if (exists $alphabet{$char}) {\n            $encoded .= chr(ord('a')\
    \ + (ord($char) - ord('a') + 2) % $alphabet_size);\n        } elsif (exists $alphabet_upper{$char})\
    \ {\n            $encoded .= chr(ord('A') + (ord($char) - ord('A') + 2) % $alphabet_upper_size);\n\
    \        } else {\n            $encoded .= $char;\n        }\n    }\n    return\
    \ $encoded;\n}", "    my $encoded = \"\";\n    my @vowels = ('a','e','i','o','u');\n\
    \    my %vowels = map { $_ => 1 } @vowels;\n    my %alphabet = (\n        'a'\
    \ => 'c',\n        'b' => 'd',\n        'c' => 'e',\n        'd' => 'f',\n   \
    \     'e' => 'g',\n        'f' => 'h',\n        'g' => 'i',\n        'h' => 'j',\n\
    \        'i' => 'k',\n        'j' => 'l',\n        'k' => 'm',\n        'l' =>\
    \ 'n',\n        'm' => 'o',\n        'n' => 'p',\n        'o' => 'q',\n      \
    \  'p' => 'r',\n        'q' => 's',\n        'r' => 't',\n        's' => 'u',\n\
    \        't' => 'v',\n        'u' => 'w',\n        'v' => 'x',\n        'w' =>\
    \ 'y',\n        'x' => 'z',\n        'y' => 'a',\n        'z' => 'b',\n    );\n\
    \    for my $char (split //, $message) {\n        if (exists $vowels{$char}) {\n\
    \            $encoded .= $alphabet{$char};\n        } else {\n            $encoded\
    \ .= $char;\n        }\n    }\n    return uc($encoded);\n}", "    my $encoded_message\
    \ = \"\";\n    my @vowels = (\"a\", \"e\", \"i\", \"o\", \"u\");\n    my %vowel_map\
    \ = (\n        \"a\" => \"c\",\n        \"e\" => \"g\",\n        \"i\" => \"k\"\
    ,\n        \"o\" => \"q\",\n        \"u\" => \"s\",\n    );\n    my @message_array\
    \ = split(\"\", $message);\n    foreach my $char (@message_array) {\n        if\
    \ (grep {$_ eq $char} @vowels) {\n            $encoded_message .= $vowel_map{$char};\n\
    \        } elsif ($char =~ /[A-Z]/) {\n            $encoded_message .= lc($char);\n\
    \        } elsif ($char =~ /[a-z]/) {\n            $encoded_message .= uc($char);\n\
    \        } else {\n            $encoded_message .= $char;\n        }\n    }\n\
    \    return $encoded_message;\n}", "    my $encoded_message = \"\";\n    my $vowels\
    \ = \"aeiou\";\n    my $vowels_index = 0;\n    my $vowel = \"\";\n    my $vowel_index\
    \ = 0;\n    my $vowel_index_plus_two = 0;\n    my $vowel_index_plus_two_letter\
    \ = \"\";\n    my $vowel_index_plus_two_letter_upper = \"\";\n    my $vowel_index_plus_two_letter_lower\
    \ = \"\";\n    my $letter = \"\";\n    my $letter_upper = \"\";\n    my $letter_lower\
    \ = \"\";\n    my $letter_index = 0;\n    my $letter_index_plus_two = 0;\n   \
    \ my $letter_index_plus_two_letter = \"\";\n    my $letter_index_plus_two_letter_upper\
    \ = \"\";\n    my $letter_index_plus_two_letter_lower = \"\";\n    my $message_length\
    \ = length($message);\n    my $message_index = 0;\n    my $message_letter = \"\
    \";\n    my $message_letter_upper = \"\";\n    my $message_letter_lower = \"\"\
    ;\n    my $message_letter_is_vowel = 0;\n    my $message_letter_is_letter = 0;\n\
    \    my $message_letter_is_upper = 0;\n    my $message_letter_is_lower = 0;\n\
    \    my $message_letter_is_not_letter = 0;\n    my $message_letter_is_not_vowel\
    \ = 0;\n    my $message_letter_is_not_upper = 0;\n    my $message_letter_is_not_lower\
    \ = 0;\n    my $message_letter_is_not_letter_or_vowel = 0;\n    my $message_letter_is_not_letter_or_upper\
    \ = 0;\n    my $message_letter_is_not_letter_or_lower = 0;\n    my $message_letter_is_not_vowel_or_upper\
    \ = 0;\n    my $message_letter_is_not_", "    my @letters = split(//, $message);\n\
    \    my @encoded_letters;\n    foreach my $letter (@letters) {\n        if ($letter\
    \ =~ /[a-z]/i) {\n            my $encoded_letter = $letter;\n            if ($letter\
    \ =~ /[a-z]/) {\n                $encoded_letter =~ tr/a-z/b-za/;\n          \
    \  } else {\n                $encoded_letter =~ tr/A-Z/B-ZA/;\n            }\n\
    \            if ($encoded_letter =~ /[aeiou]/i) {\n                $encoded_letter\
    \ =~ tr/aeiou/eioua/;\n            }\n            push(@encoded_letters, $encoded_letter);\n\
    \        } else {\n            push(@encoded_letters, $letter);\n        }\n \
    \   }\n    return join('', @encoded_letters);\n}", "    my @vowels = qw(a e i\
    \ o u);\n    my %vowels = map { $_ => 1 } @vowels;\n    my @letters = split //,\
    \ $message;\n    my @encoded;\n    for my $letter (@letters) {\n        if ($vowels{lc\
    \ $letter}) {\n            my $index = ord($letter) - ord('a');\n            $index\
    \ = ($index + 2) % 26;\n            push @encoded, chr($index + ord('a'));\n \
    \       } else {\n            push @encoded, $letter;\n        }\n    }\n    return\
    \ join '', @encoded;\n}", "    my $encoded_message = \"\";\n    my @vowels = (\"\
    a\", \"e\", \"i\", \"o\", \"u\");\n    my %vowel_hash = map { $_ => 1 } @vowels;\n\
    \    my %alphabet_hash = (\n        \"a\" => \"c\",\n        \"b\" => \"d\",\n\
    \        \"c\" => \"e\",\n        \"d\" => \"f\",\n        \"e\" => \"g\",\n \
    \       \"f\" => \"h\",\n        \"g\" => \"i\",\n        \"h\" => \"j\",\n  \
    \      \"i\" => \"k\",\n        \"j\" => \"l\",\n        \"k\" => \"m\",\n   \
    \     \"l\" => \"n\",\n        \"m\" => \"o\",\n        \"n\" => \"p\",\n    \
    \    \"o\" => \"q\",\n        \"p\" => \"r\",\n        \"q\" => \"s\",\n     \
    \   \"r\" => \"t\",\n        \"s\" => \"u\",\n        \"t\" => \"v\",\n      \
    \  \"u\" => \"w\",\n        \"v\" => \"x\",\n        \"w\" => \"y\",\n       \
    \ \"x\" => \"z\",\n        \"y\" => \"a\",\n        \"z\" => \"b\",\n    );\n\
    \    for my $char (split //, $message) {\n        if ($vowel_hash{$char}) {\n\
    \            $encoded_message .= $alphabet_hash{$char};\n        } else {\n  \
    \          $encoded_message .= $char;\n        }\n    }\n    return uc($encoded_message);\n\
    }", "    my $encoded = \"\";\n    my $vowels = \"aeiou\";\n    my $vowels_encoded\
    \ = \"cgjkr\";\n    my $vowels_encoded_hash = {};\n    my $vowels_hash = {};\n\
    \    my $i = 0;\n    foreach my $vowel (split(//, $vowels)) {\n        $vowels_hash->{$vowel}\
    \ = 1;\n        $vowels_encoded_hash->{$vowel} = substr($vowels_encoded, $i, 1);\n\
    \        $i++;\n    }\n    foreach my $char (split(//, $message)) {\n        if\
    \ ($vowels_hash->{$char}) {\n            $encoded .= $vowels_encoded_hash->{$char};\n\
    \        } elsif ($char =~ /[A-Z]/) {\n            $encoded .= lc($char);\n  \
    \      } elsif ($char =~ /[a-z]/) {\n            $encoded .= uc($char);\n    \
    \    } else {\n            $encoded .= $char;\n        }\n    }\n    return $encoded;\n\
    }", "    my @letters = split(//, $message);\n    my @encoded;\n    for my $letter\
    \ (@letters) {\n        if ($letter =~ /[a-z]/i) {\n            my $encoded =\
    \ encode_letter($letter);\n            push @encoded, $encoded;\n        } else\
    \ {\n            push @encoded, $letter;\n        }\n    }\n    return join(\"\
    \", @encoded);\n}", "    my $encoded = \"\";\n    my @vowels = ('a', 'e', 'i',\
    \ 'o', 'u');\n    my $vowel_index = 0;\n    my $vowel_count = 0;\n    my $vowel_found\
    \ = 0;\n    my $vowel_next = 0;\n    my $vowel_next_next = 0;\n    my $vowel_next_next_next\
    \ = 0;\n    my $vowel_next_next_next_next = 0;\n    my $vowel_next_next_next_next_next\
    \ = 0;\n    my $vowel_next_next_next_next_next_next = 0;\n    my $vowel_next_next_next_next_next_next_next\
    \ = 0;\n    my $vowel_next_next_next_next_next_next_next_next = 0;\n    my $vowel_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    my $vowel_next_next_next_next_next_next_next_next_next_next = 0;\n\
    \    my $vowel_next_next_next_next_next_next_next_next_next_next_next = 0;\n \
    \   my $vowel_next_next_next_next_next_next_next_next_next_next_next_next = 0;\n\
    \    my $vowel_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    my $vowel_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    my $vowel_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    my $vowel_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    my $vowel_next_next_", "    my $encoded = \"\";\n    my @vowels =\
    \ qw(a e i o u);\n    my %vowels = map { $_ => 1 } @vowels;\n    my %vowels_encoded\
    \ = (\n        'a' => 'c',\n        'e' => 'g',\n        'i' => 'k',\n       \
    \ 'o' => 'q',\n        'u' => 's',\n    );\n    for my $char (split //, $message)\
    \ {\n        if ($vowels{lc $char}) {\n            $encoded .= $vowels_encoded{lc\
    \ $char};\n        } else {\n            $encoded .= $char;\n        }\n    }\n\
    \    return uc $encoded;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
