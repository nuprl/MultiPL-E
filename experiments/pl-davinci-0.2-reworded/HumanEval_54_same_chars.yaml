name: HumanEval_54_same_chars
language: pl
prompt: "# Check if two words have the same characters.\n# >>> same_chars(\"eabcdzzzz\"\
  , \"dddzzzzzzzddeddabc\")\n# 1\n# >>> same_chars(\"abcd\", \"dddddddabc\")\n# 1\n\
  # >>> same_chars(\"dddddddabc\", \"abcd\")\n# 1\n# >>> same_chars(\"eabcd\", \"\
  dddddddabc\")\n# \"\"\n# >>> same_chars(\"abcd\", \"dddddddabce\")\n# \"\"\n# >>>\
  \ same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")\n# \"\"\nsub same_chars {\n \
  \   my($s0, $s1) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&same_chars;\n\
  \        if(eq_deeply($candidate->(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\"),1)) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  abcd\", \"dddddddabc\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n \
  \       }\n        if(eq_deeply($candidate->(\"dddddddabc\", \"abcd\"),1)) {\n \
  \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  eabcd\", \"dddddddabc\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n        if(eq_deeply($candidate->(\"abcd\", \"dddddddabcf\"),\"\"))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  eabcdzzzz\", \"dddzzzzzzzddddabc\"),\"\")) {\n        print \"ok!\" }else{\n   \
  \     exit 1;\n        }\n        if(eq_deeply($candidate->(\"aabb\", \"aaccc\"\
  ),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my %chars;\n    foreach my $c (split //, $s0) {\n        $chars{$c}++;\n\
    \    }\n    foreach my $c (split //, $s1) {\n        $chars{$c}--;\n    }\n  \
    \  foreach my $c (keys %chars) {\n        return \"\" if $chars{$c} != 0;\n  \
    \  }\n    return 1;\n}", "    my @a0 = split //, $s0;\n    my @a1 = split //,\
    \ $s1;\n    my %h0;\n    my %h1;\n    for my $c (@a0) {\n        $h0{$c}++;\n\
    \    }\n    for my $c (@a1) {\n        $h1{$c}++;\n    }\n    for my $c (keys\
    \ %h0) {\n        if (!exists $h1{$c}) {\n            return \"\";\n        }\n\
    \        if ($h0{$c} != $h1{$c}) {\n            return \"\";\n        }\n    }\n\
    \    for my $c (keys %h1) {\n        if (!exists $h0{$c}) {\n            return\
    \ \"\";\n        }\n        if ($h0{$c} != $h1{$c}) {\n            return \"\"\
    ;\n        }\n    }\n    return 1;\n}", "    my @a0 = split //, $s0;\n    my @a1\
    \ = split //, $s1;\n    my %h0;\n    my %h1;\n    for my $c (@a0) {\n        $h0{$c}++;\n\
    \    }\n    for my $c (@a1) {\n        $h1{$c}++;\n    }\n    for my $c (keys\
    \ %h0) {\n        if (!exists $h1{$c}) {\n            return \"\";\n        }\n\
    \        if ($h0{$c} != $h1{$c}) {\n            return \"\";\n        }\n    }\n\
    \    for my $c (keys %h1) {\n        if (!exists $h0{$c}) {\n            return\
    \ \"\";\n        }\n        if ($h1{$c} != $h0{$c}) {\n            return \"\"\
    ;\n        }\n    }\n    return 1;\n}", "    my @a0 = sort split //, $s0;\n  \
    \  my @a1 = sort split //, $s1;\n    my $i = 0;\n    my $j = 0;\n    while ($i\
    \ < @a0 && $j < @a1) {\n        if ($a0[$i] eq $a1[$j]) {\n            $i++;\n\
    \            $j++;\n        } elsif ($a0[$i] lt $a1[$j]) {\n            return\
    \ \"\";\n        } else {\n            $j++;\n        }\n    }\n    return $i\
    \ == @a0 ? 1 : \"\";\n}", "    my @s0 = split //, $s0;\n    my @s1 = split //,\
    \ $s1;\n    my %s0;\n    my %s1;\n    for (@s0) {\n        $s0{$_}++;\n    }\n\
    \    for (@s1) {\n        $s1{$_}++;\n    }\n    for (keys %s0) {\n        return\
    \ '' if $s0{$_} != $s1{$_};\n    }\n    return 1;\n}", "    my @s0 = split //,\
    \ $s0;\n    my @s1 = split //, $s1;\n    my %s0 = map { $_ => 1 } @s0;\n    my\
    \ %s1 = map { $_ => 1 } @s1;\n    for my $c (keys %s0) {\n        return \"\"\
    \ if !$s1{$c};\n    }\n    for my $c (keys %s1) {\n        return \"\" if !$s0{$c};\n\
    \    }\n    return 1;\n}", "    my @a0 = sort split //, $s0;\n    my @a1 = sort\
    \ split //, $s1;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @a0 && $j <\
    \ @a1) {\n        if ($a0[$i] lt $a1[$j]) {\n            $i++;\n        } elsif\
    \ ($a0[$i] gt $a1[$j]) {\n            $j++;\n        } else {\n            $i++;\n\
    \            $j++;\n        }\n    }\n    if ($i == @a0 && $j == @a1) {\n    \
    \    return 1;\n    } else {\n        return \"\";\n    }\n}", "    my @s0 = split(//,\
    \ $s0);\n    my @s1 = split(//, $s1);\n    my %s0;\n    my %s1;\n    for my $c\
    \ (@s0) {\n        $s0{$c}++;\n    }\n    for my $c (@s1) {\n        $s1{$c}++;\n\
    \    }\n    for my $c (keys %s0) {\n        return \"\" if $s0{$c} != $s1{$c};\n\
    \    }\n    for my $c (keys %s1) {\n        return \"\" if $s0{$c} != $s1{$c};\n\
    \    }\n    return 1;\n}", "    my(%c0, %c1);\n    for (split //, $s0) { $c0{$_}++\
    \ }\n    for (split //, $s1) { $c1{$_}++ }\n    for (keys %c0) {\n        return\
    \ '' if $c0{$_} != $c1{$_};\n    }\n    return 1;\n}", "    my @a0 = split //,\
    \ $s0;\n    my @a1 = split //, $s1;\n    my %h0;\n    my %h1;\n    for my $c (@a0)\
    \ {\n        $h0{$c}++;\n    }\n    for my $c (@a1) {\n        $h1{$c}++;\n  \
    \  }\n    for my $c (keys %h0) {\n        if ($h0{$c} != $h1{$c}) {\n        \
    \    return \"\";\n        }\n    }\n    return 1;\n}", "    my @s0 = split //,\
    \ $s0;\n    my @s1 = split //, $s1;\n    my %s0 = map {$_ => 1} @s0;\n    my %s1\
    \ = map {$_ => 1} @s1;\n    for my $c (keys %s0) {\n        return \"\" if !exists\
    \ $s1{$c};\n    }\n    for my $c (keys %s1) {\n        return \"\" if !exists\
    \ $s0{$c};\n    }\n    return 1;\n}", "    my @s0 = split //, $s0;\n    my @s1\
    \ = split //, $s1;\n    my @s0_sorted = sort @s0;\n    my @s1_sorted = sort @s1;\n\
    \    my $s0_sorted = join \"\", @s0_sorted;\n    my $s1_sorted = join \"\", @s1_sorted;\n\
    \    return $s0_sorted eq $s1_sorted;\n}", "    my %c0 = map { $_ => 1 } split\
    \ //, $s0;\n    my %c1 = map { $_ => 1 } split //, $s1;\n    for my $c (keys %c0)\
    \ {\n        return \"\" if !exists $c1{$c};\n    }\n    for my $c (keys %c1)\
    \ {\n        return \"\" if !exists $c0{$c};\n    }\n    return 1;\n}", "    my\
    \ @s0 = split //, $s0;\n    my @s1 = split //, $s1;\n    my %s0 = map { $_ =>\
    \ 1 } @s0;\n    my %s1 = map { $_ => 1 } @s1;\n    my @s0_keys = keys %s0;\n \
    \   my @s1_keys = keys %s1;\n    my %s0_count = ();\n    my %s1_count = ();\n\
    \    for my $c (@s0_keys) {\n        $s0_count{$c} = 0;\n    }\n    for my $c\
    \ (@s1_keys) {\n        $s1_count{$c} = 0;\n    }\n    for my $c (@s0) {\n   \
    \     $s0_count{$c}++;\n    }\n    for my $c (@s1) {\n        $s1_count{$c}++;\n\
    \    }\n    for my $c (@s0_keys) {\n        if ($s0_count{$c} != $s1_count{$c})\
    \ {\n            return \"\";\n        }\n    }\n    return 1;\n}", "    my(%c0,\
    \ %c1);\n    for my $c (split //, $s0) {\n        $c0{$c}++;\n    }\n    for my\
    \ $c (split //, $s1) {\n        $c1{$c}++;\n    }\n    for my $c (keys %c0) {\n\
    \        return \"\" if $c0{$c} != $c1{$c};\n    }\n    for my $c (keys %c1) {\n\
    \        return \"\" if $c0{$c} != $c1{$c};\n    }\n    return 1;\n}", "    my\
    \ $s0_copy = $s0;\n    my $s1_copy = $s1;\n    my $s0_len = length($s0);\n   \
    \ my $s1_len = length($s1);\n    my $s0_chars = {};\n    my $s1_chars = {};\n\
    \    my $s0_char;\n    my $s1_char;\n    my $i;\n    my $j;\n    my $result =\
    \ 1;", "    my $s0_len = length($s0);\n    my $s1_len = length($s1);\n    return\
    \ \"\" if $s0_len != $s1_len;\n    my @s0 = split //, $s0;\n    my @s1 = split\
    \ //, $s1;\n    my %s0_count;\n    my %s1_count;\n    for my $i (0..$s0_len-1)\
    \ {\n        $s0_count{$s0[$i]}++;\n        $s1_count{$s1[$i]}++;\n    }\n   \
    \ for my $i (0..$s0_len-1) {\n        return \"\" if $s0_count{$s0[$i]} != $s1_count{$s0[$i]};\n\
    \    }\n    return 1;\n}", "    my @s0 = split //, $s0;\n    my @s1 = split //,\
    \ $s1;\n    my %s0;\n    my %s1;\n    for (@s0) {\n        $s0{$_}++;\n    }\n\
    \    for (@s1) {\n        $s1{$_}++;\n    }\n    for (keys %s0) {\n        return\
    \ \"\" if $s0{$_} != $s1{$_};\n    }\n    for (keys %s1) {\n        return \"\"\
    \ if $s0{$_} != $s1{$_};\n    }\n    return 1;\n}", "    my %h0 = map { $_ =>\
    \ 1 } split //, $s0;\n    my %h1 = map { $_ => 1 } split //, $s1;\n    for (keys\
    \ %h0) {\n        return \"\" if !exists $h1{$_};\n    }\n    for (keys %h1) {\n\
    \        return \"\" if !exists $h0{$_};\n    }\n    return 1;\n}", "    my @s0\
    \ = split //, $s0;\n    my @s1 = split //, $s1;\n    my %s0 = map { $_ => 1 }\
    \ @s0;\n    my %s1 = map { $_ => 1 } @s1;\n    my @s0_only = grep { !$s1{$_} }\
    \ @s0;\n    my @s1_only = grep { !$s0{$_} } @s1;\n    return @s0_only == 0 &&\
    \ @s1_only == 0 ? 1 : \"\";\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
