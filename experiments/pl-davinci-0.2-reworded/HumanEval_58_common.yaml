name: HumanEval_58_common
language: pl
prompt: "# Return sorted unique common elements for two arrays.\n# >>> common([1,\
  \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n# [1, 5, 653]\n# >>> common([5,\
  \ 3, 2, 8], [3, 2])\n# [2, 3]\nsub common {\n    my($l1, $l2) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&common;\n\
  \        if(eq_deeply($candidate->([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
  \ 121]),[1, 5, 653])) {\n        print \"ok!\" }else{\n        exit 1;\n       \
  \ }\n        if(eq_deeply($candidate->([5, 3, 2, 8], [3, 2]),[2, 3])) {\n      \
  \  print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([4,\
  \ 3, 2, 8], [3, 2, 4]),[2, 3, 4])) {\n        print \"ok!\" }else{\n        exit\
  \ 1;\n        }\n        if(eq_deeply($candidate->([4, 3, 2, 8], []),[])) {\n  \
  \      print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my %h;\n    @h{@$l1} = ();\n    @h{@$l2} = ();\n    return sort\
    \ keys %h;\n}", "    my %h;\n    @h{@$l1} = ();\n    @h{@$l2} = ();\n    return\
    \ sort keys %h;\n}", "    my %h;\n    @h{@$l1} = ();\n    @h{@$l2} = ();\n   \
    \ return sort keys %h;\n}", "    my %h;\n    @h{@$l1} = ();\n    @h{@$l2} = ();\n\
    \    return sort keys %h;\n}", "    my %h;\n    @h{@$l1} = ();\n    @h{@$l2} =\
    \ ();\n    my @common = sort { $a <=> $b } keys %h;\n    return @common;\n}",
  "    my %h;\n    foreach my $e (@$l1) {\n        $h{$e} = 1;\n    }\n    my @l;\n\
    \    foreach my $e (@$l2) {\n        push(@l, $e) if $h{$e};\n    }\n    return\
    \ sort { $a <=> $b } @l;\n}", "    my %h = ();\n    my @common = ();\n    foreach\
    \ my $e (@$l1) {\n        $h{$e} = 1;\n    }\n    foreach my $e (@$l2) {\n   \
    \     if (exists $h{$e}) {\n            push @common, $e;\n        }\n    }\n\
    \    return sort {$a <=> $b} @common;\n}", "    my %h;\n    @h{@$l1} = ();\n \
    \   grep { exists $h{$_} } @$l2;\n}", "    my %h;\n    @h{@$l1} = ();\n    @h{@$l2}\
    \ = ();\n    return sort keys %h;\n}", "    my %h;\n    @h{@$l1} = ();\n    @h{@$l2}\
    \ = ();\n    return sort keys %h;\n}", "    my %h;\n    foreach my $e (@$l1) {\n\
    \        $h{$e}++;\n    }\n    my @res;\n    foreach my $e (@$l2) {\n        push\
    \ @res, $e if $h{$e} > 0;\n    }\n    return sort { $a <=> $b } @res;\n}", " \
    \   my %h;\n    @h{@$l1} = ();\n    @h{@$l2} = ();\n    return [sort keys %h];\n\
    }", "    my %h;\n    @h{@$l1} = ();\n    @h{@$l2} = ();\n    return sort keys\
    \ %h;\n}", "    my %h;\n    @h{@$l1} = ();\n    @h{@$l2} = ();\n    return sort\
    \ keys %h;\n}", "    my %h;\n    @h{@$l1} = ();\n    @h{@$l2} = ();\n    return\
    \ sort keys %h;\n}", "    my %h;\n    @h{@$l1} = ();\n    @h{@$l2} = ();\n   \
    \ my @r = sort keys %h;\n    return \\@r;\n}", "    my %h;\n    @h{@$l1} = ();\n\
    \    @h{@$l2} = ();\n    return sort keys %h;\n}", "    my %h;\n    @h{@$l1} =\
    \ ();\n    @h{@$l2} = ();\n    return sort keys %h;\n}", "    my %h;\n    @h{@$l1}\
    \ = ();\n    @h{@$l2} = ();\n    return sort {$a <=> $b} keys %h;\n}", "    my\
    \ %h;\n    for (@$l1) {\n        $h{$_} = 1;\n    }\n    my @res;\n    for (@$l2)\
    \ {\n        push @res, $_ if $h{$_};\n    }\n    return sort @res;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
