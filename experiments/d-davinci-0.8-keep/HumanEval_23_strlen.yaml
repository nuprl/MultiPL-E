name: HumanEval_23_strlen
language: d
prompt: "import std.math;\n/*\n Return length of given string\n    >>> strlen('')\n\
  \    0\n    >>> strlen('abc')\n    3\n    \n*/\nlong strlen(string string) \n"
tests: "unittest\n{\n    alias candidate = strlen;\n\n    assert(candidate(\"\") ==\
  \ 0L);\n    assert(candidate(\"x\") == 1L);\n    assert(candidate(\"asdasnakj\"\
  ) == 9L);\n}\nvoid main(){}"
completions: ["{\n    return cast(long) string.length;\n}\n/*\n Return a copy of string\
    \ str \n   >>> copy_string('abc')\n   'abc'\n   >>> copy_string('abc') == 'abc'\n\
    \   false\n   >>> copy_string('abc') === 'abc'\n   false\n*/\nstring copy_string(string\
    \ str) \n{\n    return str;\n}\n/*\n  Return a duplicate of string str\n   >>>\
    \ dup_string('abc')\n   'abc'\n   >>> dup_string('abc') == 'abc'\n   false\n \
    \  >>> dup_string('abc') === 'abc'\n   false\n*/\nstring dup_string(string str)\
    \ \n{\n    return str;\n}\n/*\n  Return the index of character chr in the given\
    \ string\n  >>> strchr('abc', 'a')\n  0\n  >>> strchr('abc', 'b')\n  1\n  >>>\
    \ strchr('abc', 'c')\n  2\n  >>> strchr('abc', 'd')\n  -1\n*/\nlong strchr(string\
    \ string, char chr) \n{\n    foreach (i, c; string) \n    {\n        if (c ==\
    \ chr)\n            return i;\n    }\n    return -1;\n}\n/*\n  Return the index\
    \ of the last occurrence of character chr in the given string\n  >>> strrchr('abc',\
    \ 'a')\n  0\n  >>> strrchr('abc', 'b')\n  1\n  >>> strrchr('abc', 'c')\n  2\n\
    \  >>> strrchr('abc', 'd')\n  -1\n*/\nlong strrchr(string string, char chr) \n\
    {\n    long index = -1;\n    foreach (i, c; string) \n    {\n        if (c ==\
    \ chr)\n            index = i;\n    }\n    return index;\n}\n/*\n  Return a copy\
    \ of the given string with all characters in lower case.\n  >>> strlower('aBc')\n\
    \  'abc'\n  >>> strlower('aBc') == 'aBc'\n  false\n  >>> strlower('", "{\n   \
    \ long i;\n    for (i = 0; string[i]; i++)\n        ;\n    return i;\n}", "{\n\
    \    long len = 0;\n    for (;;) \n    {\n        try \n        {\n          \
    \  if (string[len++] == 0) \n            {\n                return len - 1;\n\
    \            }\n        }\n        catch (...) \n        {\n            return\
    \ len - 1;\n        }\n    }\n}", "{\n    long length = 0;\n    foreach(ch; string)\n\
    \    {\n        length++;\n    }\n    return length;\n}\n/*\n Remove all occurrences\
    \ of the given character from a string\n    >>> stripchar('arara', 'a')\n    'rr'\n\
    \    >>> stripchar('arara', 'r')\n    'aaa'\n    >>> stripchar('arara', 'x')\n\
    \    'arara'\n    >>> stripchar('abcabc', 'c')\n    'abab'\n*/\nstring stripchar(string\
    \ string, char c) \n{\n    string stripped = \"\";\n    foreach(ch; string)\n\
    \    {\n        if(ch != c)\n        {\n            stripped ~= ch;\n        }\n\
    \    }\n    return stripped;\n}\n/*\n Return a new string with the first n characters\
    \ of s,\n prefixed with given character\n    >>> prefix('', 'a', 0)\n    ''\n\
    \    >>> prefix('abc', 'a', 0)\n    'abc'\n    >>> prefix('abc', 'a', 2)\n   \
    \ 'aabc'\n    >>> prefix('abc', 'a', 4)\n    'aaabc'\n*/\nstring prefix(string\
    \ string, char c, int n) \n{\n    string prefixed = \"\";\n    int i = 0;\n  \
    \  foreach(ch; string)\n    {\n        if(i < n)\n        {\n            prefixed\
    \ ~= c;\n        }\n        prefixed ~= ch;\n        i++;\n    }\n    return prefixed;\n\
    }\n/*\n Return a new string with the first n characters of s,\n prefixed with\
    \ given string\n    >>> prefixs('', 'a', 0)\n    ''\n    >>> prefixs('abc', 'a',\
    \ 0)\n    'abc'\n    >>> prefixs('abc', 'a', 2)\n    'aabc'\n    >>> prefixs('abc',\
    \ 'ab', 4)\n    'ababc'\n*/\nstring prefixs(string string, string s, int n) \n\
    {\n    string prefixed = \"\";\n    int i = 0;\n    foreach(ch; string)\n    {\n\
    \        if(i < n)\n        {\n", "{\n    long len = 0;\n    foreach(c; string)\n\
    \    {\n        len++;\n    }\n    return len;\n}", "{\n\tlong len = 0;\n\tfor\
    \ (len = 0; string[len]; len++)\n\t\t;\n\treturn len;\n}", "{\n    long length\
    \ = 0;\n    // walk through the string and increase length for each element\n\
    \    foreach(element; string) {\n        length += 1;\n    }\n    return length;\n\
    }\n/*\n    Return the length of the longest line in given string\n    >>> lineLength('a\\\
    nb\\nc')\n    1\n    >>> lineLength('a\\nbb\\nccc')\n    3\n*/\nlong lineLength(string\
    \ string) \n{\n    long length = 0;\n    long lineLength = 0;\n    // walk through\
    \ the string and increase length for each element\n    foreach(element; string)\
    \ {\n        // if end of line or end of string\n        if(element == '\\n' ||\
    \ element == '\\0') {\n            if(lineLength > length) {\n               \
    \ length = lineLength;\n            }\n            lineLength = 0;\n        }\
    \ else {\n            lineLength += 1;\n        }\n    }\n    return length;\n\
    }\n/*\n    Return the position of the first occurence of the substring in given\
    \ string\n    >>> find('abc', 'bc')\n    1\n    >>> find('abc', 'a')\n    0\n\
    \    >>> find('abc', 'd')\n    -1\n*/\nlong find(string string, string subString)\
    \ \n{\n    // if subString is empty string, return position 0\n    if(strlen(subString)\
    \ == 0) {\n        return 0;\n    }\n    long length = strlen(string);\n    long\
    \ subLength = strlen(subString);\n    long i = 0;\n    long j = 0;\n    // go\
    \ to each element and check if the following elements are part of the subString\n\
    \    while(i < length) {\n        if(string[i] == subString[j]) {\n          \
    \  j += 1;\n            // check if the subString is found\n            if(j ==\
    \ subLength) {\n                return i - subLength + 1;\n            }\n   \
    \     } else {\n            j = 0;\n        }\n        i += 1;\n    }\n    return\
    \ -1;\n}\n/*\n    Return the position of the last occurence of the substring in\
    \ given string\n    >>> rfind", "{\n    long i;\n    for (i = 0; string[i]; i++);\n\
    \    return i;\n}", "{\n    return __ctString.length();\n}", "{\n    long i =\
    \ 0;\n    while (string[i] != '\\0') {\n        i++;\n    }\n    return i;\n}",
  "{\n    long a = 0;\n    while (string[a] != '\\0')\n    {\n        a++;\n    }\n\
    \    return a;\n}\n/*\n Returns first char of given string\n    >>> strlen('abc')\n\
    \    a\n*/\nchar firstchar(string string)\n{\n    return string[0];\n}\n/*\n Returns\
    \ last char of given string\n    >>> strlen('abc')\n    c\n*/\nchar lastchar(string\
    \ string)\n{\n    return string[strlen(string)-1];\n}\n/*\n Return reverse of\
    \ given string\n    >>> strlen('')\n    ''\n    >>> strlen('abc')\n    cba\n*/\n\
    string strrev(string string)\n{\n    long a = strlen(string);\n    string b =\
    \ new char[a];\n    for (long i = 0; i < a; i++)\n    {\n        b[i] = string[a-i-1];\n\
    \    }\n    return b;\n}\n/*\n Return true if given string is palindrome\n   \
    \ >>> ispalindrome('')\n    true\n    >>> ispalindrome('abc')\n    false\n   \
    \ >>> ispalindrome('abccba')\n    true\n*/", "{\n    long result = 0;\n    foreach(character;\
    \ string) {\n        result++;\n    }\n    return result;\n}", "{\n    return\
    \ string.length;\n}", "{\n    return string.length;\n}\n// Test function for testing\
    \ strlen", "{\n    return strlen(string);\n}", "{\n    return string.length;\n\
    }", "{\n    long n = 0;\n    while (string[n])\n        n++;\n    return n;\n}",
  "{\n    return sizeof(string) - 1;\n}", "{\n    return string.length;\n}", "{\n\
    \    auto result = 0L;\n    for (int i = 0; string[i]; i++)\n    {\n        result++;\n\
    \    }\n    return result;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
