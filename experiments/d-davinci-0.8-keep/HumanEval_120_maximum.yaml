name: HumanEval_120_maximum
language: d
prompt: "import std.math;\n/*\n\n    Given an array arr of integers and a positive\
  \ integer k, return a sorted list \n    of length k with the maximum k numbers in\
  \ arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output:\
  \ [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n    \
  \    Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1,\
  \ -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the\
  \ array will be in the range of [1, 1000].\n        2. The elements in the array\
  \ will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n\
  */\nlong[] maximum(long[] arr, long k) \n"
tests: "unittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L,\
  \ -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) ==\
  \ [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n\
  \    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n\
  \    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n\
  \    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L,\
  \ 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L,\
  \ 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L,\
  \ -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n\
  \    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid\
  \ main(){}"
completions: ["{\n    int N = arr.length;\n    if (N == 0) return new long[0];\n \
    \   if (k == 0) return new long[0];\n    if (k == 1) return new long[]{max(arr)};\n\
    \    if (k == N) return arr;\n    if (k > N) return new long[0];\n    long[] result\
    \ = new long[k];\n    auto max = max(arr);\n    result[0] = max;\n    int j =\
    \ 1;\n    int i = 0;\n    while (j < k)\n    {\n        if (arr[i] == max)\n \
    \       {\n            result[j] = max;\n            max = 0;\n            foreach\
    \ (n; arr)\n            {\n                if (n > max && n < result[j])\n   \
    \             {\n                    max = n;\n                }\n           \
    \ }\n            if (max == 0)\n            {\n                result[j] = arr[k\
    \ - j];\n            }\n            else\n            {\n                result[j]\
    \ = max;\n            }\n            j++;\n        }\n        i++;\n    }\n  \
    \  return result;\n}", "{\n    k = min(k, arr.length);\n    foreach (i; 0 .. k)\n\
    \    {\n        long max = arr[i];\n        long idx = i;\n        foreach (j;\
    \ i .. arr.length)\n        {\n            if (arr[j] > max)\n            {\n\
    \                max = arr[j];\n                idx = j;\n            }\n    \
    \    }\n        arr[idx] = arr[i];\n        arr[i] = max;\n    }\n    return arr[0\
    \ .. k];\n}", "{\n    long[] result = new long[k];\n    long[] max = new long[arr.length];\n\
    \    max[0] = arr[0];\n    for (long i = 1; i < arr.length; i++) \n    {\n   \
    \     max[i] = max(max[i - 1], arr[i]);\n    }\n    for (long i = 0; i < k; i++)\
    \ \n    {\n        result[i] = max[(long)arr.length - k + i];\n    }\n    return\
    \ result;\n}", "{\n    import std.algorithm.comparison : sort;\n    import std.algorithm.iteration\
    \ : take, takeExactly;\n    return arr.sort.takeExactly(k);\n}", "{\n    if (arr.length\
    \ == k) return arr;\n    long[] res = new long[k];\n    int index = 0;\n    for\
    \ (int i = 0; i < arr.length; i++) {\n        while (index > 0 && res[index -\
    \ 1] < arr[i] && arr.length - i + index > k) {\n            index--;\n       \
    \ }\n        if (index < k) {\n            res[index++] = arr[i];\n        }\n\
    \    }\n    return res;\n}", "{\n    long[] result = new long[k];\n    for (long\
    \ i = 0; i < k; i++)\n    {\n        result[i] = arr[i];\n    }\n    sort(result);\n\
    \    for (long i = k; i < arr.length; i++)\n    {\n        if (arr[i] > result[0])\n\
    \        {\n            result[0] = arr[i];\n            sort(result);\n     \
    \   }\n    }\n    return result;\n}", "{\n    long len = arr.length;\n    if (k\
    \ == 0)\n        return [];\n    if (k == len)\n        return arr;\n    long\
    \ low = min(arr);\n    long high = max(arr);\n    long[] result = new long[cast(int)k];\n\
    \    while (low <= high) \n    {\n        long max = low;\n        long count\
    \ = 0;\n        long[] temp = new long[len];\n        for (long i = 0; i < len;\
    \ i++) \n        {\n            if (arr[cast(int)i] > max) \n            {\n \
    \               temp[cast(int)count] = arr[cast(int)i];\n                count++;\n\
    \            }\n        }\n        if (count >= k) \n        {\n            result\
    \ = temp[0..cast(int)k];\n            low = max + 1;\n        } \n        else\
    \ \n        {\n            high = max - 1;\n        }\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[k];\n    long[] temp;\n    int j = 0;\n \
    \   for (int i = 0; i < k; i++)\n    {\n        result[i] = arr[i];\n    }\n \
    \   sort(result);\n    for (int i = k; i < arr.length; i++)\n    {\n        if\
    \ (arr[i] > result[0])\n        {\n            temp = new long[result.length];\n\
    \            for (int ii = 0; ii < result.length; ii++)\n            {\n     \
    \           temp[ii] = result[ii];\n            }\n            result[0] = arr[i];\n\
    \            sort(result);\n            for (int ii = 0; ii < result.length; ii++)\n\
    \            {\n                temp[ii] = result[ii];\n            }\n      \
    \      result = temp;\n        }\n    }\n    return result;\n}", "{\n    long[]\
    \ max_arr = new long[k];\n    for (int i = 0; i < k; i++)\n    {\n        max_arr[i]\
    \ = -1001;\n    }\n    for (int i = 0; i < arr.length; i++)\n    {\n        if\
    \ (arr[i] > max_arr[0])\n        {\n            max_arr[0] = arr[i];\n       \
    \     sort(max_arr);\n        }\n    }\n    return max_arr;\n}", "{\n    long[]\
    \ res = new long[(int)k];\n    int index = 0;\n    foreach(i; 0 .. arr.length)\n\
    \    {\n        if(index == 0)\n        {\n            res[index] = arr[i];\n\
    \            index++;\n        }\n        else\n        {\n            if(index\
    \ < k)\n            {\n                int j = 0;\n                for(; j < index;\
    \ j++)\n                {\n                    if(arr[i] > res[j])\n         \
    \           {\n                        break;\n                    }\n       \
    \         }\n                if(j < index)\n                {\n              \
    \      int t = index;\n                    while(t > j)\n                    {\n\
    \                        res[t] = res[t - 1];\n                        t--;\n\
    \                    }\n                    res[j] = arr[i];\n               \
    \     index++;\n                }\n                else\n                {\n \
    \                   res[index] = arr[i];\n                    index++;\n     \
    \           }\n            }\n            else\n            {\n              \
    \  int j = 0;\n                for(; j < index; j++)\n                {\n    \
    \                if(arr[i] > res[j])\n                    {\n                \
    \        break;\n                    }\n                }\n                if(j\
    \ < index)\n                {\n                    int t = index;\n          \
    \          while(t > j)\n                    {\n                        res[t]\
    \ = res[t - 1];\n                        t--;\n                    }\n       \
    \             res[j] = arr[i];\n                }\n            }\n        }\n\
    \    }\n    return res;\n}", "{\n    auto res = new long[k];\n    for (long i\
    \ = 0; i < k; i++)\n    {\n        res[i] = long.min;\n    }\n    for (long i\
    \ = 0; i < arr.length; i++)\n    {\n        res[upperBound(res, arr[i])] = arr[i];\n\
    \    }\n    return res;\n}", "{\n    long i, j, s = 0, v = 0;\n    long[] r =\
    \ new long[(int)k];\n    long[] a = new long[(int)k];\n    for (i = 0; i < k;\
    \ i++) \n    {\n        for (j = 0; j < k; j++) \n        {\n            if (a[(int)j]\
    \ > v) \n            {\n                v = a[(int)j];\n                s = j;\n\
    \            }\n        }\n        r[(int)i] = v;\n        a[(int)s] = arr[(int)i];\n\
    \        v = 0;\n    }\n    return r;\n}", "{\n    long[] a = new long[arr.length];\n\
    \    long n = 0;\n    foreach(e; arr)\n    {\n        while(n > 0 && n + arr.length\
    \ - i > k && a[n - 1] < e)\n            n--;\n        if(n < k)\n            a[n++]\
    \ = e;\n    }\n    return a[0..k];\n}", "{\n    long[] res = new long[(int)k];\n\
    \    foreach(i; 0 .. k)\n    {\n        long max = INT_MIN;\n        foreach(j;\
    \ 0 .. arr.length)\n        {\n            if(arr[j] > max)\n            {\n \
    \               max = arr[j];\n            }\n        }\n        res[i] = max;\n\
    \        foreach(j; 0 .. arr.length)\n        {\n            if(arr[j] == max)\n\
    \            {\n                arr[j] = INT_MIN;\n                break;\n  \
    \          }\n        }\n    }\n    return res;\n}", "{\n    auto res = new long[](k);\n\
    \    auto heap = new std.priority_queue!int(std.greater!int);\n    int i = 0;\n\
    \    while (i < k) \n    {\n        heap.push(arr[i]);\n        i++;\n    }\n\
    \    while (i < arr.length) \n    {\n        heap.push(arr[i]);\n        heap.pop();\n\
    \        i++;\n    }\n    i = k - 1;\n    while (i >= 0) \n    {\n        res[i]\
    \ = heap.top;\n        heap.pop();\n        i--;\n    }\n    return res;\n}\n\
    // @lc code=end", "{\n    auto res = new long[](k);\n    for (long i = 0; i <\
    \ k; i++)\n    {\n        res[i] = arr[i];\n    }\n    std.sort(res);\n    for\
    \ (long i = k; i < arr.length; i++)\n    {\n        if (arr[i] > res[0])\n   \
    \     {\n            res[0] = arr[i];\n            std.sort(res);\n        }\n\
    \    }\n    return res;\n}", "{\n    struct MaxHeap {\n        long[] heap;\n\
    \        long size;\n        void add(long x)\n        {\n            auto p =\
    \ size++;\n            heap[p] = x;\n            auto parent = p / 2;\n      \
    \      while (p > 0 && heap[parent] < heap[p])\n            {\n              \
    \  auto t = heap[parent];\n                heap[parent] = heap[p];\n         \
    \       heap[p] = t;\n                p = parent;\n                parent = p\
    \ / 2;\n            }\n        }\n        long top()\n        {\n            return\
    \ heap[0];\n        }\n        void pop()\n        {\n            heap[0] = heap[--size];\n\
    \            auto p = 0;\n            while (true)\n            {\n          \
    \      auto left = p * 2 + 1;\n                auto right = p * 2 + 2;\n     \
    \           if (left >= size)\n                    break;\n                auto\
    \ largest = left;\n                if (right < size && heap[right] > heap[left])\n\
    \                    largest = right;\n                if (heap[p] < heap[largest])\n\
    \                {\n                    auto t = heap[p];\n                  \
    \  heap[p] = heap[largest];\n                    heap[largest] = t;\n        \
    \            p = largest;\n                }\n                else\n         \
    \           break;\n            }\n        }\n    }\n    if (k == 0)\n       \
    \ return [];\n    MaxHeap mh;\n    mh.heap = new long[k];\n    mh.size = 0;\n\
    \    foreach (x; arr)\n    {\n        if (mh.size < k)\n            mh.add(x);\n\
    \        else if (x > mh.top())\n        {\n            mh.pop();\n          \
    \  mh.add(x);\n        }\n    }\n    long[] result = new long[k];\n    auto p\
    \ = k - 1;\n    while (mh.size > 0)\n    {\n        result[p--] = mh.top();\n\
    \        mh.pop();\n    }\n    return result;\n}", "{\n    long[] buffer = new\
    \ long[k];\n    foreach(idx, item; arr)\n    {\n        buffer[0] = max(buffer[0],\
    \ item);\n        long pos = 0;\n        while(buffer[pos] > buffer[pos + 1])\n\
    \        {\n            long temp = buffer[pos];\n            buffer[pos] = buffer[pos\
    \ + 1];\n            buffer[pos + 1] = temp;\n            pos++;\n        }\n\
    \    }\n    return buffer;\n}", "{\n    // sort the array\n    arr.sort;\n   \
    \ // create a new array of size k and fill it with elements from the right side\
    \ of arr\n    auto result = new long[k];\n    result[0 .. k] = arr[arr.length\
    \ - k .. arr.length];\n    // return the sorted array\n    return result.sort;\n\
    }\n// UNIT TESTS", "{\n    auto n = arr.length;\n    if (n == 0) return null;\n\
    \    if (k >= n) return arr;\n    // Here we use a DArray to store the result\
    \ of top k elements.\n    auto result = new long[][n];\n    // The smallest elements\
    \ are at the end of the array.\n    // Here we set the default of last element\
    \ to INT_MIN.\n    result[n - 1] = min;\n    // When the element is larger than\
    \ the last element in the array,\n    // we need to update all the elements in\
    \ the array.\n    foreach (i, v; arr) \n    {\n        if (v > result[n - 1])\
    \ \n        {\n            int last = n - 1;\n            while (last > 0 && v\
    \ > result[last - 1]) \n            {\n                result[last] = result[last\
    \ - 1];\n                last--;\n            }\n            result[last] = v;\n\
    \        }\n    }\n    // Because the array is sorted, \n    // the last elements\
    \ are the smallest elements in the array.\n    // So we need to reserve the DArray.\n\
    \    std.algorithm.reverse(result);\n    return result[0 .. k];\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
