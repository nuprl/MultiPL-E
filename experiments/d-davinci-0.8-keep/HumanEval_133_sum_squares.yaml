name: HumanEval_133_sum_squares
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\nYou are given a list of numbers.\n\
  \    You need to return the sum of squared numbers in the given list,\n    round\
  \ each element in the list to the upper int(Ceiling) first.\n    Examples:\n   \
  \ For lst = [1,2,3] the output should be 14\n    For lst = [1,4,9] the output should\
  \ be 98\n    For lst = [1,3,5,7] the output should be 84\n    For lst = [1.4,4.2,0]\
  \ the output should be 29\n    For lst = [-2.4,1,1] the output should be 6\n   \
  \ \n\n    \n*/\nlong sum_squares(float[] lst) \n"
tests: "unittest\n{\n    alias candidate = sum_squares;\n\n    assert(candidate([1.0,\
  \ 2.0, 3.0]) == 14L);\n    assert(candidate([1.0, 2.0, 3.0]) == 14L);\n    assert(candidate([1.0,\
  \ 3.0, 5.0, 7.0]) == 84L);\n    assert(candidate([1.4, 4.2, 0.0]) == 29L);\n   \
  \ assert(candidate([-2.4, 1.0, 1.0]) == 6L);\n    assert(candidate([100.0, 1.0,\
  \ 15.0, 2.0]) == 10230L);\n    assert(candidate([10000.0, 10000.0]) == 200000000L);\n\
  \    assert(candidate([-1.4, 4.6, 6.3]) == 75L);\n    assert(candidate([-1.4, 17.9,\
  \ 18.9, 19.9]) == 1086L);\n    assert(candidate([0.0]) == 0L);\n    assert(candidate([-1.0])\
  \ == 1L);\n    assert(candidate([-1.0, 1.0, 0.0]) == 2L);\n}\nvoid main(){}"
completions: ["{\n\tlong result = 0;\n\tforeach(i; lst)\n\t{\n\t\tresult += cast(long)ceil(i)*cast(long)ceil(i);\n\
    \t}\n\treturn result;\n}", "{\n    auto z = round(lst);\n    long sum = 0;\n \
    \   foreach(i; z)\n    {\n        sum += cast(long) i * i;\n    }\n    return\
    \ sum;\n}", "{\n    float min = min(lst);\n    float max = max(lst);\n    float\
    \ avg = avg(lst);\n    float median = median(lst);\n    long sum = 0;\n    foreach(e;\
    \ lst)\n    {\n        if(e <= min)\n        {\n            e = min;\n       \
    \ }\n        else if(e >= max)\n        {\n            e = max;\n        }\n \
    \       else if(e <= avg)\n        {\n            e = avg;\n        }\n      \
    \  else if(e >= median)\n        {\n            e = median;\n        }\n     \
    \   else\n        {\n            e = float(ceil(e));\n        }\n        sum +=\
    \ (long)(e*e);\n    }\n    return sum;\n}", "{\n  float[] new_lst = [] ;\n  foreach(x;\
    \ lst)\n  {\n    new_lst ~= ceil(x);\n  }\n  long total = 0;\n  foreach(x; new_lst)\n\
    \  {\n    total += x^2;\n  }\n  return total;\n}", "{\n    long sum = 0;\n   \
    \ foreach(x; lst)\n    {\n        long temp = cast(long)ceil(x);\n        sum\
    \ += temp * temp;\n    }\n    return sum;\n}", "{\n    long sum = 0;\n    foreach(e;\
    \ lst) \n    {\n      e = e.ceil;\n      sum += cast(long)e*e;\n    }\n    return\
    \ sum;\n}", "{\n    long sum = 0;\n    foreach(var item; lst)\n    {\n       \
    \ int ceiling = (int)Math.ceil(item);\n        sum += ceiling * ceiling;\n   \
    \ }\n    return sum;\n}", "{\n    long acc = 0;\n    foreach(el; lst)\n    {\n\
    \        acc += ceil(el)*ceil(el);\n    }\n    return acc;\n}", "{\n    /*\n \
    \       long sum = 0;\n        foreach(var x; lst)\n        {\n            sum\
    \ += cast(long)std.math.pow(std.math.ceil(x),2);\n        }\n        return sum;\n\
    \    */\n    return map!((x) => (long)std.math.pow(std.math.ceil(x),2))(lst).sum;\n\
    }", "{\n    long sum = 0;\n    foreach(element; lst)\n    {\n        sum += cast(long)element\
    \ * element;\n    }\n    return sum;\n}", "{\n  auto result = 0L;\n  foreach(\
    \ i; lst )\n  {\n    result += staticRoundTo!long(pow(i,2));\n  }\n  return result;\n\
    }", "{\n    int len = lst.length;\n    long result = 0;\n    for (int i = 0; i\
    \ < len; i++) \n    {\n        int val = round(lst[i]);\n        result += val\
    \ * val;\n    }\n    return result;\n}", "{\n    long sum=0;\n    for(int i=0;i<lst.length;i++)\n\
    \    {\n        sum+=cast(long)ceil(lst[i])*cast(long)ceil(lst[i]);\n    }\n \
    \   return sum;\n}", "{\n    float sum = 0;\n    foreach(v; lst) {\n        v\
    \ = ceil(v);\n        sum += v*v;\n    }\n    return sum;\n}", "{\n    long sum\
    \ = 0;\n    foreach(x;lst)\n    {\n      sum += cast(long)ceil(x)^2;\n    }\n\
    \    return sum;\n}", "{\n    long square_sum = 0;\n    for(float n : lst)\n \
    \   {\n        n = Math.ceil(n);\n        square_sum += (long)Math.pow(n,2);\n\
    \    }\n    return square_sum;\n}", "{\n    size_t[] arr = new size_t[lst.length];\n\
    \    foreach(i, val; lst)\n    {\n        if(val >= 0)\n            arr[i] = cast(size_t)ceil(val);\n\
    \        else\n            arr[i] = cast(size_t)floor(val);\n    }\n    auto rng\
    \ = arr.map!(a => a * a);\n    return rng.sum;\n}", "{\n    long sum = 0;\n  \
    \  foreach(i; lst)\n    {\n      sum += (long)i*(long)i;\n    }\n    return sum;\n\
    }", "{\n    long sqsum = 0;\n    foreach(float v; lst)\n    {\n        int iv\
    \ = cast(int)ceil(v);\n        sqsum += iv*iv;\n    }\n    return sqsum;\n}",
  "{\n    long result = 0;\n    foreach(x; lst) {\n        result += cast(long)(ceil(x))\
    \ * cast(long)(ceil(x));\n    }\n    return result;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
