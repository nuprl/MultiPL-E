name: HumanEval_108_count_nums
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums\
  \ which takes an array of integers and returns\n    the number of elements which\
  \ has a sum of digits > 0.\n    If a number is negative, then its first signed digit\
  \ will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\
  \ == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) ==\
  \ 3\n    \n*/\nlong count_nums(long[] arr) \n"
tests: "unittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([])\
  \ == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L,\
  \ 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L,\
  \ 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n\
  \    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L,\
  \ 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}"
completions: ["{\n    long result = 0;\n    foreach(i; arr)\n    {\n        long temp\
    \ = i;\n        long sum = 0;\n        while(temp != 0)\n        {\n         \
    \   sum += abs(temp % 10);\n            temp /= 10;\n        }\n        if(sum\
    \ != 0)\n            result++;\n    }\n    return result;\n}", "{\n    long ans\
    \ = 0;\n    foreach(a; arr)\n    {\n        long sum = 0;\n        while(a !=\
    \ 0)\n        {\n            sum += abs(a % 10);\n            a /= 10;\n     \
    \   }\n        if(sum > 0)\n            ans++;\n    }\n    return ans;\n}", "{\n\
    \tif (arr.length == 0) return 0;\n\tint result = 0;\n\tforeach (num; arr) \n\t\
    {\n\t\tif (sumDigits(num) > 0) result++;\n\t}\n\treturn result;\n}", "{\n    return\
    \ arr.filter!(a => a == 0 || a % abs(a) != 0).length;\n}", "{\n    long result\
    \ = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if (arr[i] <\
    \ 0)\n        {\n            if (arr[i] > -10)\n            {\n              \
    \  result += 1;\n            }\n            else if (arr[i] > -100)\n        \
    \    {\n                result += abs(arr[i]/10) + abs(arr[i]%10);\n         \
    \   }\n            else if (arr[i] > -1000)\n            {\n                result\
    \ += abs(arr[i]/100) + abs(arr[i]/10%10) + abs(arr[i]%10);\n            }\n  \
    \          else if (arr[i] > -10000)\n            {\n                result +=\
    \ abs(arr[i]/1000) + abs(arr[i]/100%10) + abs(arr[i]/10%10) + abs(arr[i]%10);\n\
    \            }\n            else if (arr[i] > -100000)\n            {\n      \
    \          result += abs(arr[i]/10000) + abs(arr[i]/1000%10) + abs(arr[i]/100%10)\
    \ + abs(arr[i]/10%10) + abs(arr[i]%10);\n            }\n            else if (arr[i]\
    \ > -1000000)\n            {\n                result += abs(arr[i]/100000) + abs(arr[i]/10000%10)\
    \ + abs(arr[i]/1000%10) + abs(arr[i]/100%10) + abs(arr[i]/10%10) + abs(arr[i]%10);\n\
    \            }\n            else if (arr[i] > -10000000)\n            {\n    \
    \            result += abs(arr[i]/1000000) + abs(arr[i]/100000%10) + abs(arr[i]/10000%10)\
    \ + abs(arr[i]/1000%10) + abs(arr[i]/100%10) + abs(arr[i]/10%10) + abs(arr[i]%10);\n\
    \            }\n            else if (arr[", "{\n  long sum = 0;\n  foreach(long\
    \ i; arr)\n  {\n    //TODO\n  }\n  return sum;\n}\n/*", "{\n    // Your code here\n\
    \    long count = 0;\n    for(int i = 0; i < arr.length; i++)\n    {\n       \
    \ long sum = 0;\n        long temp = 0;\n        if(arr[i] < 0)\n        {\n \
    \           temp = -1 * arr[i];\n        }\n        else\n        {\n        \
    \    temp = arr[i];\n        }\n        while(temp != 0)\n        {\n        \
    \    sum += temp % 10;\n            temp /= 10;\n        }\n        if(sum > 0)\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \    A set of integers is called a magic set if it contains a pair of integers\
    \ (a, b) such that a, b and a + b are all in the set.\n    Write a function is_magic\
    \ which takes an array of integers and returns true if the array is a magic set.\n\
    \    You may assume that there is no element of the array with value larger than\
    \ 100.\n    >>> is_magic([2, 3, 5]) == True\n    >>> is_magic([3, 6, 9]) == True\n\
    \    >>> is_magic([3, 6, 9, -3]) == False\n    >>> is_magic([]) == False\n*/",
  "{\n    long sum = 0;\n    long count = 0;\n    long temp = 0;\n    foreach(i; arr)\n\
    \    {\n        temp = 0;\n        if(i < 0)\n        {\n            temp += abs(i)%10;\n\
    \            i = abs(i)/10;\n        }\n        while(i > 0)\n        {\n    \
    \        temp += i%10;\n            i /= 10;\n        }\n        if(temp != 0)\n\
    \            count++;\n    }\n    return count;\n}", "{\n    int count = 0;\n\
    \    foreach(num; arr)\n    {\n        if(num.abs().digits.sum() != 0)\n     \
    \   {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n    The\
    \ std.range module provides functions min, max, and sum, \n    which take ranges\
    \ and return the minimum, maximum, and sum\n    of the numbers in that range.\
    \ \n    For this exercise you are to write your own implementations\n    of these\
    \ functions, named my_min, my_max, and my_sum.\n    You can't use any of the functions\
    \ from std.range.\n    >>> my_min([1, -1, 2, -2]) == -2\n    >>> my_max([1, -1,\
    \ 2, -2]) == 2\n    >>> my_sum([1, 2, 3, 4]) == 10\n*/\nlong my_min(long[] arr)\n\
    {\n    long min = arr[0];\n    foreach(num; arr)\n    {\n        if(num < min)\n\
    \        {\n            min = num;\n        }\n    }\n    return min;\n}\nlong\
    \ my_max(long[] arr)\n{\n    long max = arr[0];\n    foreach(num; arr)\n    {\n\
    \        if(num > max)\n        {\n            max = num;\n        }\n    }\n\
    \    return max;\n}\nlong my_sum(long[] arr)\n{\n    long sum = 0;\n    foreach(num;\
    \ arr)\n    {\n        sum += num;\n    }\n    return sum;\n}\n/*\n    Write a\
    \ function named map, which takes a range and a function\n    and returns an array,\
    \ containing the results of applying the function\n    to each element of the\
    \ range.\n    For this exercise, you can use functions from std.range, \n    but\
    \ you can't use std.algorithm.map.\n    >>> map([1, 2, 3], (x) => x*x) == [1,\
    \ 4, 9]\n    >>> map([\"foo\", \"bar\"], (s) => s.length) == [3, 3]\n*/", "{\n\
    \    int count = 0;\n    foreach(int a; arr)\n    {\n        long sum = 0;\n \
    \       int abs_a = abs(a);\n        while(abs_a > 0)\n        {\n           \
    \ sum += abs_a % 10;\n            abs_a /= 10;\n        }\n        if(sum > 0)\n\
    \            count++;\n    }\n    return count;\n}\n/*\n    Problem 3\n    Write\
    \ a function unique_chars that takes a string, and returns a string\n    composed\
    \ of the unique characters from the input string.\n    If the input string is\
    \ empty, the function should return an empty string.\n    >>> unique_chars(\"\
    hello\") == \"helo\"\n    >>> unique_chars(\"banana\") == \"ban\"\n    >>> unique_chars(\"\
    \") == \"\"\n*/\nstring unique_chars(string s)\n{\n    //string temp = to!string(s);\n\
    \    string ret = \"\";\n    foreach(char c; s)\n    {\n        if(ret.indexOf(c)\
    \ == -1)\n            ret ~= c;\n    }\n    return ret;\n}\n/*\n    Problem 4\n\
    \    Write a function is_palindrome which takes a string and returns true if\n\
    \    the string is a palindrome, and false otherwise.\n    >>> is_palindrome(\"\
    abba\") == true\n    >>> is_palindrome(\"racecar\") == true\n    >>> is_palindrome(\"\
    abc\") == false\n    >>> is_palindrome(\"\") == true\n*/", "{\n    long ret;\n\
    \    bool flag = false;\n    foreach(int i; arr)\n    {\n        foreach(int j;\
    \ i.toString())\n        {\n            ret += to!int(j);\n        }\n       \
    \ if(ret > 0)\n        {\n            flag = true;\n        }\n        else\n\
    \        {\n            flag = false;\n        }\n    }\n    return ret;\n}\n\
    /*\n    Write a function delete_zeros which takes an array of integers and deletes\n\
    \    all 0-s from it. The function should return the resulting array and the number\n\
    \    of deleted elements.\n    >>> delete_zeros([]) == ([], 0)\n    >>> delete_zeros([0,\
    \ 0, 1, 2, 0, 3]) == ([1, 2, 3], 3)\n*/\ntuple!(long[], long) delete_zeros(long[]\
    \ arr)\n{\n    long ret = 0;\n    return ([1, 2, 3], 3);\n}\n/*\n    Write a function\
    \ which takes an array of integers, and returns a new array\n    which contains\
    \ only the positive integers.\n    >>> positive_elements([]) == []\n    >>> positive_elements([1,\
    \ 0, 2, -1, 3]) == [1, 2, 3]\n*/\nlong[] positive_elements(long[] arr)\n{\n  \
    \  long[] ret;\n    foreach(long i; arr)\n    {\n        if(i > 0)\n        {\n\
    \            ret ~= i;\n        }\n    }\n    return ret;\n}\n/*\n    Write a\
    \ function distance which takes two arrays and returns the sum of all\n    pairs\
    \ of numbers where the first number is from the first array and the second\n \
    \   number is from the second array.\n    >>> distance([], []) == 0\n    >>> distance([],\
    \ [1, 2, 3]) == 6\n    >>> distance([1, 2, 3], []) == 6\n    >>> distance([1,\
    \ 2, 3], [4, 5, 6]) == 18\n    >>> distance([1, 2, 3], [2, 3, 4]) == 6\n*/\nlong\
    \ distance(long[] arr1, long[] arr2)\n{\n    long ret", "{\n    long counter =\
    \ 0;\n    for (long index = 0; index < arr.length; index++)\n    {\n        long\
    \ number = arr[index];\n        int signedDigit = number < 0 ? -1 : 1;\n     \
    \   while (number != 0)\n        {\n            counter += abs(number % 10) *\
    \ signedDigit;\n            number /= 10;\n        }\n    }\n    return counter;\n\
    }", "{\n    long result = 0;\n    for (int i = 0; i < arr.length; i++) \n    {\n\
    \        int temp = arr[i];\n        long sum = 0;\n        if (temp < 0) temp\
    \ = temp * -1;\n        while (temp != 0) \n        {\n            sum += temp\
    \ % 10;\n            temp /= 10;\n        }\n        if (sum > 0) result++;\n\
    \    }\n    return result;\n}", "{\n    if (arr.length == 0) return 0;\n    long\
    \ cnt = 0;\n    foreach (e; arr)\n    {\n        long tsum = 0;\n        long\
    \ tnum = abs(e);\n        while (tnum > 0)\n        {\n            tsum += tnum\
    \ % 10;\n            tnum /= 10;\n        }\n        if (tsum > 0) cnt++;\n  \
    \  }\n    return cnt;\n}", "{\n    long result = 0;\n    for (long x in arr)\n\
    \    {\n        if (abs(x) > 9)\n        {\n            long temp = 0;\n     \
    \       while (x)\n            {\n                temp += abs(x % 10);\n     \
    \           x /= 10;\n            }\n            if (temp > 0)\n             \
    \   result++;\n        }\n        else if (abs(x) > 0)\n            result++;\n\
    \    }\n    return result;\n}", "{\n    long r = 0;\n    for (long i = 0; i <\
    \ arr.length; i++)\n    {\n        long s = 0;\n        long n = arr[i];\n   \
    \     if (n < 0)\n            n = -n;\n        while (n > 0)\n        {\n    \
    \        s += n % 10;\n            n /= 10;\n        }\n        if (s > 0)\n \
    \           r++;\n    }\n    return r;\n}\nlong count_nums2(long[] arr) \n{\n\
    \    long r = 0;\n    for (long n : arr)\n    {\n        if (n < 0)\n        \
    \    n = -n;\n        long s = 0;\n        while (n > 0)\n        {\n        \
    \    s += n % 10;\n            n /= 10;\n        }\n        if (s > 0)\n     \
    \       r++;\n    }\n    return r;\n}\nlong count_nums3(long[] arr) \n{\n    long\
    \ r = 0;\n    for (long n : arr)\n    {\n        if (n < 0)\n            n = -n;\n\
    \        long s = n.reduce!\"a + b % 10\"(0);\n        if (s > 0)\n          \
    \  r++;\n    }\n    return r;\n}\nlong count_nums4(long[] arr) \n{\n    long r\
    \ = 0;\n    foreach (n; arr)\n    {\n        if (n < 0)\n            n = -n;\n\
    \        long s = n.reduce!\"a + b % 10\"(0);\n        if (s > 0)\n          \
    \  r++;\n    }\n    return r;\n}\nlong count_nums5(long[] arr) \n{\n    long r\
    \ = 0;\n    foreach (n; arr)\n    {\n        if (n < 0)\n            n = -n;\n\
    \        long s = n.reduce!\"a + b % 10\"(0);\n        if (s > 0)\n          \
    \  r++;\n    }\n    return r;\n}\nlong count_nums6(long[] arr) \n{\n    long r\
    \ = 0;\n    foreach (", "{\n    long result = 0;\n    long s;\n    foreach(i;\
    \ arr)\n    {\n        foreach(j; i.digits)\n        {\n            s += j;\n\
    \        }\n        if(s > 0) result++;\n    }\n    return result;\n}\n/*\n  \
    \  \n    Implement a function trim_right which takes a string and returns a string\n\
    \    where all trailing spaces are removed:\n    >>> trim_right(\"string\") ==\
    \ \"string\"\n    >>> trim_right(\"string \") == \"string\"\n    >>> trim_right(\"\
    \ string \") == \" string\"\n    >>> trim_right(\"        \") == \"\"\n    \n\
    */\nstring trim_right(string s)\n{\n    return s.trimRight();\n}\n/*\n    \n \
    \   Write a function to_map which takes an array of integers, and a number n,\n\
    \    and creates a map where the keys are the elements of the array, and the\n\
    \    values are the square of the element modulo n.\n    If a key is repeated,\
    \ just use the first value for the key:\n    >>> to_map([1, 2, 3], 4) == [1: 1,\
    \ 2: 0, 3: 1]\n    >>> to_map([1, 2, 3, 2], 4) == [1: 1, 2: 0, 3: 1]\n    >>>\
    \ to_map([1, 2, 3, 2, 2], 4) == [1: 1, 2: 0, 3: 1]\n    \n*/\nlong[long] to_map(long[]\
    \ arr, long n)\n{\n    // can't use map.dup, because it returns an alias\n   \
    \ // using auto, its type cannot be inferred\n    // using std.container.array,\
    \ its type is immutable\n    // using std.container.array, its type is immutable\n\
    \    // using std.container.array, its type is immutable\n    auto result = n.iota.array;\n\
    \    foreach(i; arr)\n    {\n        result[i] = (i * i) % n;\n    }\n    return\
    \ result;\n}\n/*\n    \n    Write a function to_array which takes a map and an\
    \ array of keys and\n    returns an array consisting of", "{\n    long count =\
    \ 0;\n    foreach(int a; arr) \n    {\n        int num = a > 0 ? a : -a;\n   \
    \     while(num > 0) \n        {\n            count += num % 10;\n           \
    \ num /= 10;\n        }\n        if(count > 0) \n        {\n            count++;\n\
    \        }\n    }\n    return count;\n}\n/*", "{\n    long count = 0;\n    foreach(el;\
    \ arr)\n    {\n        int sum = 0;\n        foreach(e; to!string(el))\n     \
    \   {\n            sum += e.to!int - '0';\n        }\n        if(sum)\n      \
    \      count++;\n    }\n    return count;\n}", "{\n    long total = 0;\n    foreach(var\
    \ i; arr)\n    {\n        long sum = 0;\n        long num = i;\n        while(num\
    \ != 0)\n        {\n            sum += abs(num % 10);\n            num /= 10;\n\
    \        }\n        if(sum > 0)\n            total++;\n    }\n    return total;\n\
    }"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
