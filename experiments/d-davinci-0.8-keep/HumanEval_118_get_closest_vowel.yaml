name: HumanEval_118_get_closest_vowel
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task\
  \ is to find the closest vowel that stands between \n    two consonants from the\
  \ right side of the word (case sensitive).\n    \n    Vowels in the beginning and\
  \ ending doesn't count. Return empty string if you didn't\n    find any vowel met\
  \ the above condition. \n\n    You may assume that the given string contains English\
  \ letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==> \"u\"\n  \
  \  get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\") ==> \"\
  \"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
  \ word) \n"
tests: "unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
  yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
  easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
  ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
  most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
  ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
  anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
  Above\") == \"o\");\n}\nvoid main(){}"
completions: ["{\n\tauto vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n\tint min_dist\
    \ = int.max;\n\tstring min_vowel = \"\";\n\tstring last_consonant = \"\";\n\t\
    string prev_letter = \"\";\n\tforeach(i, ch; word.byReverse)\n\t{\n\t\tif(vowels.canFind(ch))\n\
    \t\t{\n\t\t\tif(last_consonant != \"\")\n\t\t\t{\n\t\t\t\tint dist = word.length\
    \ - i - word.byReverse.canFind(last_consonant);\n\t\t\t\tif(dist < min_dist)\n\
    \t\t\t\t{\n\t\t\t\t\tmin_dist = dist;\n\t\t\t\t\tmin_vowel = ch;\n\t\t\t\t}\n\t\
    \t\t}\n\t\t\tlast_consonant = prev_letter;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprev_letter\
    \ = ch;\n\t\t}\n\t}\n\treturn min_vowel;\n}", "{ \n    string vowels = \"AEIOUaeiou\"\
    ;\n    string consonants = \"BCDFGHJKLMNPQRSTVWXYZbcdfghjklmnpqrstvwxyz\";\n \
    \   string result = \"\";\n    int index;\n    //convert string to dchar[],\n\
    \    auto word_dchars = word.to!dchar[];\n    //iterate through it, starting from\
    \ the end\n    for(int i = word_dchars.length-1; i > 0; i--)\n    {\n        //if\
    \ our letter is a consonant and the letter before it is a vowel,\n        //return\
    \ the vowel\n        if(consonants.canFind(word_dchars[i]) && vowels.canFind(word_dchars[i-1]))\n\
    \        {\n            index = i-1;\n            result = word_dchars[index].to!string;\n\
    \            return result;\n        }\n    }\n    return result;\n}", "{\n  \
    \  auto arr=new char[](['A','E','I','O','U']);\n    int p=0;\n    foreach(e;arr)\n\
    \    {\n        if(word.rfind(e)!=-1)\n        {\n            if(p==0) p=word.rfind(e);\n\
    \            else p=min(p,word.rfind(e));\n        }\n    }\n    if(p==0) return\
    \ \"\";\n    else return word[p..$];\n}", "{\n    if (word.length == 0) return\
    \ \"\";\n    string vowels = \"aeiou\";\n    string s = \"\";\n    foreach ( i,\
    \ c; word )\n    {\n        if (i == 0 || i == word.length - 1) continue;\n  \
    \      if (vowels.find(word[i]) == -1) continue;\n        if (vowels.find(word[i-1])\
    \ != -1 || vowels.find(word[i+1]) != -1) continue;\n        if (s.length == 0)\n\
    \        {\n            s = word[i..$];\n        }\n        else\n        {\n\
    \            if (abs(s.length - i) < abs(s.length - word.length))\n          \
    \  {\n                s = word[i..$];\n            }\n        }\n    }\n    return\
    \ s.length == 0 ? \"\" : s[0..0];\n}", "{\n\tenum Vowels : char[]\n\t{\n\t\t'a','e','i','o','u','A','E','I','O','U'\n\
    \t}", "{\n    string vowels = \"aeiouAEIOU\";\n    char closest = '\\0';\n   \
    \ bool lastCharWasVowel = false;\n    bool firstVowel = true;\n    for (int i\
    \ = word.length - 1; i >= 0; i--)\n    {\n        if (vowels.canFind(word[i]))\n\
    \        {\n            closest = word[i];\n            firstVowel = false;\n\
    \            if (lastCharWasVowel)\n                break;\n        }\n      \
    \  else if (!firstVowel)\n            lastCharWasVowel = true;\n    }\n    return\
    \ closest ? \"\" ~ closest : \"\";\n}", "{\n    int found = word.rfind(\"a\");\n\
    \    if (found != -1) return \"a\";\n    found = word.rfind(\"e\");\n    if (found\
    \ != -1) return \"e\";\n    found = word.rfind(\"i\");\n    if (found != -1) return\
    \ \"i\";\n    found = word.rfind(\"o\");\n    if (found != -1) return \"o\";\n\
    \    found = word.rfind(\"u\");\n    if (found != -1) return \"u\";\n    found\
    \ = word.rfind(\"A\");\n    if (found != -1) return \"A\";\n    found = word.rfind(\"\
    E\");\n    if (found != -1) return \"E\";\n    found = word.rfind(\"I\");\n  \
    \  if (found != -1) return \"I\";\n    found = word.rfind(\"O\");\n    if (found\
    \ != -1) return \"O\";\n    found = word.rfind(\"U\");\n    if (found != -1) return\
    \ \"U\";\n    return \"\";\n}", "{\n    string vowels = \"aeiou\";\n    int pos\
    \ = 0;\n    for (int i = word.length - 1; i >= 0; i--)\n    {\n        if (vowels.findFirstOf(word[i])\
    \ != -1)\n        {\n            if (i != 0 && i != word.length - 1)\n       \
    \     {\n                if (vowels.findFirstOf(word[i-1]) == -1 && vowels.findFirstOf(word[i+1])\
    \ == -1)\n                {\n                    pos = i;\n                  \
    \  break;\n                }\n            }\n        }\n    }\n    return pos\
    \ == 0 ? \"\" : word[pos..$];\n}", "{\n    auto vowels = \"aeiou\";\n    immutable\
    \ n = word.length;\n    immutable m = vowels.length;\n    if (n <= 2)\n      \
    \  return \"\";\n    else \n    {\n        auto prev_vowel = \"\";\n        immutable\
    \ best_idx = n;\n        for (immutable i = n - 1; i >= 0; --i)\n        {\n \
    \           auto ch = word[i];\n            immutable idx = find(vowels, ch);\n\
    \            if (idx != -1)\n            {\n                if (i < best_idx)\n\
    \                {\n                    best_idx = i;\n                    prev_vowel\
    \ = ch;\n                }\n            }\n            else \n            {\n\
    \                if (best_idx != n)\n                    return prev_vowel;\n\
    \            }\n        }\n        return \"\";\n    }\n}", "{\n    string vowels\
    \ = \"aeiouAEIOU\";\n    string closestVowel = \"\";\n    double distance = double.infinity;\n\
    \    foreach(ch; word)\n    {\n        if(vowels.find(ch) == -1)\n        {\n\
    \            continue;\n        }\n        size_t startPos = word.find(ch);\n\
    \        if(startPos == 0)\n        {\n            continue;\n        }\n    \
    \    size_t lastVowelPos = word.rfind(ch);\n        if(lastVowelPos == word.length\
    \ - 1)\n        {\n            continue;\n        }\n        size_t endPos = word.rfindNot(ch);\n\
    \        if(endPos == startPos - 1)\n        {\n            continue;\n      \
    \  }\n        double currentDistance = abs(double(endPos - startPos));\n     \
    \   if(currentDistance == 0)\n        {\n            return ch;\n        }\n \
    \       if(currentDistance < distance)\n        {\n            distance = currentDistance;\n\
    \            closestVowel = ch;\n        }\n    }\n    return closestVowel;\n}",
  "{\n    auto vowels = \"AEIOUaeiou\";\n    string result = \"\";\n    int min_dist\
    \ = INFINITY;\n    for (int i = 0; i < word.length; i++)\n    {\n        if (vowels.canFind(word[i]))\n\
    \        {\n            int consBefore = -1;\n            int consAfter = -1;\n\
    \            foreach (j; 0 .. i)\n            {\n                if (!vowels.canFind(word[j]))\n\
    \                {\n                    consBefore = j;\n                    break;\n\
    \                }\n            }\n            foreach (j; i + 1 .. word.length)\n\
    \            {\n                if (!vowels.canFind(word[j]))\n              \
    \  {\n                    consAfter = j;\n                    break;\n       \
    \         }\n            }\n            if (consBefore != -1 && consAfter != -1)\n\
    \            {\n                if (min_dist > consAfter - consBefore)\n     \
    \           {\n                    min_dist = consAfter - consBefore;\n      \
    \              result = word[i .. i + 1];\n                }\n            }\n\
    \        }\n    }\n    return result;\n}", "{\n    int vowel_ind = -1;\n    foreach(i,\
    \ ch; word.reversed())\n    {\n        if (isVowel(ch))\n        {\n         \
    \   vowel_ind = i;\n            break;\n        }\n    }\n    if (vowel_ind ==\
    \ -1) return \"\";\n    if (isVowel(word[0]) || isVowel(word[$-1])) return \"\"\
    ;\n    int con_ind = 0;\n    foreach(i, ch; word.reversed())\n    {\n        if\
    \ (!isVowel(ch))\n        {\n            con_ind = i;\n            break;\n  \
    \      }\n    }\n    if (vowel_ind < con_ind)\n    {\n        return word[$-vowel_ind-1..$-vowel_ind];\n\
    \    }\n    else\n    {\n        return \"\";\n    }\n}", "{\n    string letters\
    \ = \"aeiouAEIOU\";\n    string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n    string closest_vowel = \"\";\n    size_t closest_vowel_offset = word.length;\n\
    \    foreach(offset, char c; word)\n    {\n        if(letters.count(c))\n    \
    \    {\n            size_t left_consonant_offset = word[0..offset].rfind(consonants);\n\
    \            size_t right_consonant_offset = word[offset..$].find(consonants);\n\
    \            if(left_consonant_offset != -1 && right_consonant_offset != -1)\n\
    \            {\n                if(right_consonant_offset < closest_vowel_offset)\n\
    \                {\n                    closest_vowel = c;\n                 \
    \   closest_vowel_offset = right_consonant_offset;\n                }\n      \
    \      }\n        }\n    }\n    return closest_vowel;\n}", "{\n    int index =\
    \ 0;\n    int index_res = 0;\n    int current_distance = 0;\n    int min_distance\
    \ = (int) word.length();\n    int distance_from_end = 0;\n    //cout << word.length()\
    \ << endl;\n    for (int i = word.length() - 1; i >= 0; i--)\n    {\n        //cout\
    \ << i << endl;\n        if (word[i] == 'A' || word[i] == 'E' || word[i] == 'I'\
    \ || word[i] == 'O' || word[i] == 'U')\n        {\n            index = i;\n  \
    \          //cout << index << endl;\n            if (index < min_distance)\n \
    \           {\n                min_distance = index;\n                index_res\
    \ = i;\n            }\n        }\n    }\n    if (index_res == 0)\n    {\n    \
    \    return \"\";\n    }\n    return word[index_res];\n}", "{\n  /*\n  // A solution\
    \ with the STL\n  auto const vowels = \"aeiou\";\n  auto const consonants = \"\
    bcdfghjklmnpqrstvwxyz\";\n  auto const position = find(word.rbegin(), word.rend(),\
    \ findFirstOf(consonants, *--word.rend()));\n  if (position != word.rend())\n\
    \    return findFirstOf(vowels, *find(find(position, word.rend(), findFirstOf(consonants,\
    \ *position)) + 1, word.rend(), findFirstOf(vowels)));\n  return \"\";\n  */\n\
    \  \n  // A solution with ranges.\n  import std.range.primitives;\n  import std.range.iteration;\n\
    \  import std.array;\n  import std.algorithm.searching;\n  auto const vowels =\
    \ ['a', 'e', 'i', 'o', 'u'];\n  auto const consonants = ['b', 'c', 'd', 'f', 'g',\
    \ 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'];\n\
    \  auto const wordRight = word.retro;\n  auto const wordRightWithoutVowels = filter!(a\
    \ => a.canFindOneOf(consonants))(wordRight);\n  if (wordRightWithoutVowels.empty)\n\
    \    return \"\";\n  auto const firstConsonant = wordRightWithoutVowels.front;\n\
    \  auto const restWithoutVowels = wordRightWithoutVowels.dropOne;\n  if (restWithoutVowels.empty)\n\
    \    return \"\";\n  auto const secondConsonant = restWithoutVowels.front;\n \
    \ auto const middle = restWithoutVowels.dropOne;\n  if (middle.empty)\n    return\
    \ \"\";\n  auto const firstVowel = middle.canFindOneOf(vowels);\n  if (firstVowel.empty)\n\
    \    return \"\";\n  auto const firstVowelDistance = firstVowel.front - secondConsonant;\n\
    \  auto const", "{\n  string s = lowerCase(word);\n  int len = s.length;\n  int\
    \ i = len - 1;\n  while (i > 0) {\n    if (isVowel(s[i]) && !isVowel(s[i - 1]))\
    \ {\n      return word[i .. i];\n    }\n    i--;\n  }\n  return \"\";\n}", "{\n\
    \    //if(word.length < 3) return \"\";\n    string vowels = \"aeiou\";\n    string\
    \ cons = \"bcdfghjklmnpqrstvwxyz\";\n    string result = \"\";\n    int vidx =\
    \ 0;\n    int cidx = 0;\n    int diff = 0;\n    int length = word.length;\n  \
    \  int max = length;\n    for(int i = length - 1; i > 0; i--)\n    {\n       \
    \ if(vowels.findFirstOf(word[i]) == -1)\n        {\n            continue;\n  \
    \      }\n        else\n        {\n            vidx = i;\n            break;\n\
    \        }\n    }\n    for(int i = vidx - 1; i > 0; i--)\n    {\n        if(cons.findFirstOf(word[i])\
    \ == -1)\n        {\n            continue;\n        }\n        else\n        {\n\
    \            cidx = i;\n            break;\n        }\n    }\n    if(vidx == 0\
    \ || cidx == 0)\n    {\n        return \"\";\n    }\n    else\n    {\n       \
    \ diff = abs(vidx - cidx);\n        for(int i = vidx - 1; i > 0; i--)\n      \
    \  {\n            if(vowels.findFirstOf(word[i]) == -1)\n            {\n     \
    \           continue;\n            }\n            else\n            {\n      \
    \          if(abs(i - cidx) < diff)\n                {\n                    vidx\
    \ = i;\n                    diff = abs(i - cidx);\n                }\n       \
    \     }\n        }\n        if(diff > max)\n        {\n            return \"\"\
    ;\n        }\n        else\n        {\n            result = word[vidx];\n    \
    \        return result;\n        }\n    }\n}", "{\n    string[char] vowels = ['a':'a',\
    \ 'e':'e', 'i':'i', 'o':'o', 'u':'u'];\n    immutable(char[]) consonants = \"\
    bcdfghjklmnpqrstvwxyz\".dup;\n    auto reverse_word = word.dup.reverse;\n    auto\
    \ consonant_index = -1;\n    for(immutable(size_t) i = 0; i < reverse_word.length;\
    \ i++)\n    {\n        if(consonants.find(reverse_word[i]) != -1)\n        {\n\
    \            consonant_index = i;\n            break;\n        }\n    }\n    if(consonant_index\
    \ < 0)\n        return \"\";\n    auto start_vowel_index = -1;\n    for(immutable(size_t)\
    \ i = consonant_index + 1; i < reverse_word.length; i++)\n    {\n        if(vowels.find(reverse_word[i])\
    \ != null)\n        {\n            start_vowel_index = i;\n            break;\n\
    \        }\n    }\n    if(start_vowel_index < 0)\n        return \"\";\n    auto\
    \ end_vowel_index = -1;\n    for(immutable(size_t) i = consonant_index - 1; i\
    \ >= 0; i--)\n    {\n        if(vowels.find(reverse_word[i]) != null)\n      \
    \  {\n            end_vowel_index = i;\n            break;\n        }\n    }\n\
    \    return (end_vowel_index == -1) ? reverse_word[start_vowel_index] \n     \
    \   : ((consonant_index - start_vowel_index) < (end_vowel_index - consonant_index))\
    \ \n        ? reverse_word[start_vowel_index] : reverse_word[end_vowel_index];\n\
    }", "{\n    int wordLen = word.length;\n    string wordRev = word[$].dup.reversed;\n\
    \    string result = \"\";\n    for (int i = 0; i < wordLen; i++)\n    {\n   \
    \     if (wordRev[i] == 'a' || wordRev[i] == 'e' || wordRev[i] == 'i' ||\n   \
    \         wordRev[i] == 'o' || wordRev[i] == 'u' || wordRev[i] == 'A' ||\n   \
    \         wordRev[i] == 'E' || wordRev[i] == 'I' || wordRev[i] == 'O' ||\n   \
    \         wordRev[i] == 'U')\n        {\n            if (i - 1 >= 0 && i + 1 <\
    \ wordLen)\n            {\n                if (wordRev[i - 1] != 'a' && wordRev[i\
    \ - 1] != 'e' && wordRev[i - 1] != 'i' &&\n                    wordRev[i - 1]\
    \ != 'o' && wordRev[i - 1] != 'u' && wordRev[i - 1] != 'A' &&\n              \
    \      wordRev[i - 1] != 'E' && wordRev[i - 1] != 'I' && wordRev[i - 1] != 'O'\
    \ &&\n                    wordRev[i - 1] != 'U' && wordRev[i + 1] != 'a' && wordRev[i\
    \ + 1] != 'e' &&\n                    wordRev[i + 1] != 'i' && wordRev[i + 1]\
    \ != 'o' && wordRev[i + 1] != 'u' &&\n                    wordRev[i + 1] != 'A'\
    \ && wordRev[i + 1] != 'E' && wordRev[i + 1] != 'I' &&\n                    wordRev[i\
    \ + 1] != 'O' && wordRev[i + 1] != 'U')\n                {\n                 \
    \   result = wordRev[i .. i+1];\n                    break;\n                }\n\
    \            }\n        }\n    }\n    return result.reversed;\n}", "{\n    string\
    \ vowels = \"aeiou\";\n    string ret;\n    size_t i = 0;\n    if (word.length\
    \ == 0) return ret;\n    i = word.length - 1;\n    while (i--)\n    {\n      \
    \  if (vowels.find(word[i]) != -1)\n        {\n            if (vowels.find(word[i-1])\
    \ == -1 && vowels.find(word[i+1]) == -1)\n            {\n                ret =\
    \ word[i..$];\n                break;\n            }\n        }\n    }\n    return\
    \ ret;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
