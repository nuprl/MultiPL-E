name: HumanEval_70_strange_sort_list
language: d
results:
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0) return [];\n    int result_size = 2 * lst.length;\n    long[] result =\
    \ new long[result_size];\n    result[0] = std.algorithm.min(lst);\n    lst -=\
    \ result[0];\n    result[1] = std.algorithm.max(lst);\n    lst -= result[1];\n\
    \    int index = 1;\n    while (lst.length > 0)\n    {\n        result[++index]\
    \ = std.algorithm.min(lst);\n        lst -= result[index];\n        result[++index]\
    \ = std.algorithm.max(lst);\n        lst -= result[index];\n    }\n    return\
    \ result;\n}\n/*\n    Your task is to create a function that does four basic mathematical\
    \ operations.\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpamn6x7w_.d(34): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpamn6x7w_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    auto min = min(lst);\n\
    \    auto max = max(lst);\n    auto step = lst.length % 2 ? 1 : -1;\n    auto\
    \ result = appender!(long[])();\n    foreach(i; 0 .. lst.length)\n    {\n    \
    \    if(step > 0)\n        {\n            result.put(min);\n            min =\
    \ min(lst[min .. $]);\n        }\n        else\n        {\n            result.put(max);\n\
    \            max = max(lst[max .. $]);\n        }\n        step *= -1;\n    }\n\
    \    return result.data;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptx_x32k_.d(17): Error: undefined identifier `min`, did you mean\
    \ function `main`?\\n/tmp/tmptx_x32k_.d(18): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\n/tmp/tmptx_x32k_.d(20): Error: template instance\
    \ `appender!(long[])` template `appender` is not defined\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmptx_x32k_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return new long[0];\n    \n    auto nlst = lst.dup;\n    auto\
    \ res = new long[lst.length];\n    size_t cnt = nlst.length;\n    size_t restr\
    \ = 0;\n    size_t restl = nlst.length - 1;\n    int inc = 1;\n    while (cnt\
    \ > 0)\n    {\n        auto m = nlst[restr..restl].min;\n        res[restr] =\
    \ m;\n        nlst = nlst.filter!(a => a != m);\n        if (inc > 0)\n      \
    \  {\n            restr++;\n            inc = -1;\n        }\n        else\n \
    \       {\n            restl--;\n            inc = 1;\n        }\n        cnt--;\n\
    \    }\n    return res;\n}\n \nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgrmlk7y5.d(28): Error: no property `min` for type `long[]`\\\
    n/tmp/tmpgrmlk7y5.d(30): Error: no property `filter` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgrmlk7y5.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    auto sorted_lst\
    \ = sort(lst);\n    auto odd = sorted_lst[0 .. $/2 + 1];\n    auto even = sorted_lst[$/2\
    \ + 1 .. $];\n    long[] result;\n    foreach(i, n; enumerate(odd)) {\n      \
    \  if (i % 2 == 0) {\n            result ~= n;\n        } else {\n           \
    \ result ~= even.popBack();\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9kxmbs0l.d(17): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\n/tmp/tmp9kxmbs0l.d(21): Error: undefined identifier `enumerate`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9kxmbs0l.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    bool isMax = false;\n    alias L = lst.dup;\n\
    \    lst = [];\n    auto cmp = isMax ? (a, b) => a >= b : (a, b) => a <= b;\n\
    \    while (L.length > 0)\n    {\n        bool isFirst = true;\n        long minMax\
    \ = L[0];\n        long minMaxIndex = 0;\n        foreach (i, e; L)\n        {\n\
    \            if (isFirst)\n            {\n                isFirst = false;\n \
    \               minMax = e;\n                minMaxIndex = i;\n            }\n\
    \            else if (cmp(e, minMax))\n            {\n                minMax =\
    \ e;\n                minMaxIndex = i;\n            }\n        }\n        lst\
    \ ~= minMax;\n        L = L[0..minMaxIndex] ~ L[minMaxIndex + 1..$];\n       \
    \ isMax = !isMax;\n    }\n    return lst;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpipl8txwf.d(20): Error: alias `L` cannot alias an expression `dup(lst)`\\\
    n/tmp/tmpipl8txwf.d(22): Error: variable `tmpipl8txwf.strange_sort_list.cmp` type\
    \ `void` is inferred from initializer `isMax ? (a, b) => a >= b : (a, b) => a\
    \ <= b`, and variables cannot be of type `void`\\n/tmp/tmpipl8txwf.d(22): Error:\
    \ expression `isMax ? (a, b) => a >= b : (a, b) => a <= b` is `void` and has no\
    \ value\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpipl8txwf.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    lst = lst.dup;\n\
    \    immutable int len = lst.length;\n    if (len < 1) \n        return lst;\n\
    \    else if (len < 2) \n        return lst[0 .. 1];\n    else if (len == 2) \n\
    \        return lst[0] < lst[1] ? lst : lst[1, 0];\n    else \n    {\n       \
    \ int newlen = 2;\n        for (long i = 2; i < len; i += 2) \n            newlen\
    \ += 2;\n        long[] res = new long[newlen];\n        long[] tmp = lst[0 ..\
    \ 2];\n        tmp.sort;\n        res[0] = tmp[0];\n        res[1] = tmp[2];\n\
    \        immutable tuple!(long, long) minmax = minmax(lst[2 .. $]);\n        bool\
    \ ascend = true;\n        res[2] = minmax[ascend ? 0 : 1];\n        bool ascend\
    \ = !ascend;\n        int idx = 3;\n        for (long i = 3; i < len; i += 2)\
    \ \n        {\n            immutable tuple!(long, long) minmax = minmax(lst[i\
    \ .. $]);\n            res[idx] = minmax[ascend ? 0 : 1];\n            idx++;\n\
    \            bool ascend = !ascend;\n            res[idx] = minmax[ascend ? 0\
    \ : 1];\n            idx++;\n        }\n        return res;\n    }\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqqkxdmjw.d(18): Error: cannot implicitly convert expression `lst.length`\
    \ of type `ulong` to `immutable(int)`\\n/tmp/tmpqqkxdmjw.d(24): Error: only one\
    \ index allowed to index `long[]`\\n/tmp/tmpqqkxdmjw.d(32): Error: no property\
    \ `sort` for type `long[]`\\n/tmp/tmpqqkxdmjw.d(35): Error: `tuple!(long, long)`\
    \ is used as a type\\n/tmp/tmpqqkxdmjw.d(35): Error: undefined identifier `minmax`\\\
    n/tmp/tmpqqkxdmjw.d(38): Error: declaration `tmpqqkxdmjw.strange_sort_list.ascend`\
    \ is already defined\\n/tmp/tmpqqkxdmjw.d(42): Error: `tuple!(long, long)` is\
    \ used as a type\\n/tmp/tmpqqkxdmjw.d(42): Error: variable `minmax` is shadowing\
    \ variable `tmpqqkxdmjw.strange_sort_list.minmax`\\n/tmp/tmpqqkxdmjw.d(45): Error:\
    \ variable `ascend` is shadowing variable `tmpqqkxdmjw.strange_sort_list.ascend`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqqkxdmjw.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0) return [];\n    lst.sort();\n    auto lst2 = lst.dup;\n    lst2.reverse;\n\
    \    return lst[].zip(lst2[]).expand;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpaw2cljgt.d(18): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpaw2cljgt.d(20): Error: template `std.typecons.reverse` cannot deduce\
    \ function from argument types `!()(long[])`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\n/tmp/tmpaw2cljgt.d(21):\
    \ Error: no property `zip` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpaw2cljgt.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0) \n        return lst;\n    long max = lst[0];\n    long min = lst[0];\n\
    \    long[] res = new long[lst.length];\n    foreach (x; lst)\n    {\n       \
    \ if (x > max)\n            max = x;\n        if (x < min)\n            min =\
    \ x;\n    }\n    lst = lst.retro();\n    res[0] = min;\n    res[1] = max;\n  \
    \  bool is_min = false;\n    for (int i = 2; i < lst.length; i++)\n    {\n   \
    \     if (is_min)\n        {\n            min = lst[0];\n            foreach (x;\
    \ lst)\n            {\n                if (x < min)\n                    min =\
    \ x;\n            }\n            res[i] = min;\n            lst = lst.retro();\n\
    \            is_min = false;\n        }\n        else\n        {\n           \
    \ max = lst[0];\n            foreach (x; lst)\n            {\n               \
    \ if (x > max)\n                    max = x;\n            }\n            res[i]\
    \ = max;\n            lst = lst.retro();\n            is_min = true;\n       \
    \ }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp25dgn2w6.d(29): Error: no property `retro` for type `long[]`\\\
    n/tmp/tmp25dgn2w6.d(44): Error: no property `retro` for type `long[]`\\n/tmp/tmp25dgn2w6.d(56):\
    \ Error: no property `retro` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp25dgn2w6.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0) return [];\n    lst.sort!((a, b) => a - b);\n    auto ret = new long[lst.length];\n\
    \    auto up = true;\n    for (uint i = 0; i < lst.length; i++)\n    {\n     \
    \   ret[i] = up ? lst[i] : lst[lst.length - i - 1];\n        up = !up;\n    }\n\
    \    return ret;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfoenk_my.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfoenk_my.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0) \n        return lst;\n    auto min = lst[0];\n    foreach (i; lst)\n\
    \        min = min(min, i);\n    lst = lst.filter!(a => a != min);\n    long[]\
    \ ret;\n    ret ~= min;\n    while (lst.length != 0)\n    {\n        auto max\
    \ = lst[0];\n        foreach (i; lst)\n            max = max(max, i);\n      \
    \  lst = lst.filter!(a => a != max);\n        ret ~= max;\n        auto min =\
    \ lst[0];\n        foreach (i; lst)\n            min = min(min, i);\n        lst\
    \ = lst.filter!(a => a != min);\n        ret ~= min;\n    }\n    return ret;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgx6c_lw_.d(21): Error: function expected before `()`, not `min`\
    \ of type `long`\\n/tmp/tmpgx6c_lw_.d(22): Error: no property `filter` for type\
    \ `long[]`\\n/tmp/tmpgx6c_lw_.d(29): Error: function expected before `()`, not\
    \ `max` of type `long`\\n/tmp/tmpgx6c_lw_.d(30): Error: no property `filter` for\
    \ type `long[]`\\n/tmp/tmpgx6c_lw_.d(32): Error: variable `min` is shadowing variable\
    \ `tmpgx6c_lw_.strange_sort_list.min`\\n/tmp/tmpgx6c_lw_.d(34): Error: function\
    \ expected before `()`, not `min` of type `long`\\n/tmp/tmpgx6c_lw_.d(35): Error:\
    \ no property `filter` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpgx6c_lw_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0) return lst;\n    long max = lst[0];\n    long min = lst[0];\n    long[]\
    \ lst_max = new long[];\n    long[] lst_min = new long[];\n    lst_max.length\
    \ = lst.length;\n    lst_min.length = lst.length;\n    for (size_t i = 0; i <\
    \ lst.length; i++)\n    {\n        if (lst[i] > max) max = lst[i];\n        if\
    \ (lst[i] < min) min = lst[i];\n    }\n    long delta = max - min;\n    size_t\
    \ i = 0;\n    while (delta != 0)\n    {\n        lst_max[i] = max;\n        lst_min[i]\
    \ = min;\n        delta--;\n        i++;\n    }\n    lst_max[i] = max;\n    lst_min[i]\
    \ = min;\n    size_t n = lst.length / 2;\n    size_t l = 0;\n    size_t r = lst.length\
    \ - 1;\n    lst.length = lst.length + 1;\n    for (size_t i = 0; i < n; i++)\n\
    \    {\n        lst[l] = lst_min[i];\n        lst[r] = lst_max[i];\n        l\
    \ += 2;\n        r -= 2;\n    }\n    lst[l] = lst_min[n];\n    return lst;\n}\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9btey9vf.d(20): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmp9btey9vf.d(21): Error: new can\
    \ only create structs, dynamic arrays or class objects, not `long[]`\\'s\\n/tmp/tmp9btey9vf.d(44):\
    \ Error: variable `i` is shadowing variable `tmp9btey9vf.strange_sort_list.i`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9btey9vf.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] new_list\
    \ = lst[];\n    bool odd = true;\n    for (int i = 0; i < lst.length; i++)\n \
    \   {\n        long min = new_list[0];\n        int min_index = 0;\n        long\
    \ max = new_list[0];\n        int max_index = 0;\n        for (int j = 0; j <\
    \ new_list.length; j++)\n        {\n            if (min > new_list[j])\n     \
    \       {\n                min = new_list[j];\n                min_index = j;\n\
    \            }\n            if (max < new_list[j])\n            {\n          \
    \      max = new_list[j];\n                max_index = j;\n            }\n   \
    \     }\n        if (odd)\n        {\n            new_list[min_index] = -1;\n\
    \            lst[i] = min;\n        }\n        else\n        {\n            new_list[max_index]\
    \ = -1;\n            lst[i] = max;\n        }\n        odd = !odd;\n    }\n  \
    \  return lst;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n \
    \   assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp5wasijji.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428a05]\\n??:? void tmp5wasijji.__unittest_L52_C1()\
    \ [0x428132]\\n??:? void tmp5wasijji.__modtest() [0x428788]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42ca87]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b91a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430aad]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430f5c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430a39]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b8f1]\\n??:? runModuleUnitTests [0x42c85d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ec8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428e4f]\\n??:? _d_run_main [0x428dba]\\n??:? main [0x42879b]\\\
    n??:? __libc_start_main [0xe5191554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res =\
    \ new long[lst.length];\n    bool asc = true;\n    long i = 0;\n    while(lst.length\
    \ > 0)\n    {\n        if(asc)\n        {\n            res[i] = lst.front;\n \
    \           lst.remove(lst.front);\n        }\n        else\n        {\n     \
    \       res[i] = lst.back;\n            lst.remove(lst.back);\n        }\n   \
    \     i++;\n        asc = !asc;\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9_xkf129.d(24): Error: no property `front` for type `long[]`\\\
    n/tmp/tmp9_xkf129.d(25): Error: no property `remove` for type `long[]`\\n/tmp/tmp9_xkf129.d(29):\
    \ Error: no property `back` for type `long[]`\\n/tmp/tmp9_xkf129.d(30): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp9_xkf129.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    alias Ind = long;\n    alias Val = long;\n \
    \   auto minVal = min(lst);\n    auto maxVal = max(lst);\n    auto minValInd =\
    \ lst.indexOf(minVal);\n    auto maxValInd = lst.indexOf(maxVal);\n    long[Val][Ind]\
    \ inds = lst.indexed;\n    immutable Ind[Val] sortedInds = inds.values;\n    immutable\
    \ Ind[Val] minInds = sortedInds.takeExactly(minValInd + 1);\n    immutable Ind[Val]\
    \ maxInds = sortedInds.dropExactly(minValInd + 1);\n    immutable Ind[] minToMax;\n\
    \    immutable Ind[] maxToMin;\n    foreach (Ind i; minInds)\n        minToMax\
    \ ~= i;\n    foreach (Ind i; maxInds)\n        maxToMin ~= i;\n    maxToMin.reverse;\n\
    \    immutable Ind[] res;\n    long i = 0;\n    while (true)\n    {\n        if\
    \ (i < minToMax.length)\n            res ~= minToMax[i];\n        else\n     \
    \       break;\n        if (i < maxToMin.length)\n            res ~= maxToMin[i];\n\
    \        else\n            break;\n        i++;\n    }\n    return lst[res];\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdn4euabf.d(21): Error: undefined identifier `min`, did you mean\
    \ function `main`?\\n/tmp/tmpdn4euabf.d(22): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\n/tmp/tmpdn4euabf.d(23): Error: no property `indexOf`\
    \ for type `long[]`\\n/tmp/tmpdn4euabf.d(24): Error: no property `indexOf` for\
    \ type `long[]`\\n/tmp/tmpdn4euabf.d(25): Error: no property `indexed` for type\
    \ `long[]`\\n/tmp/tmpdn4euabf.d(26): Error: cannot implicitly convert expression\
    \ `values(inds)` of type `long[long][]` to `immutable(long[long])`\\n/tmp/tmpdn4euabf.d(27):\
    \ Error: no property `takeExactly` for type `immutable(long[long])`\\n/tmp/tmpdn4euabf.d(28):\
    \ Error: no property `dropExactly` for type `immutable(long[long])`\\n/tmp/tmpdn4euabf.d(32):\
    \ Error: cannot modify `immutable` expression `minToMax`\\n/tmp/tmpdn4euabf.d(34):\
    \ Error: cannot modify `immutable` expression `maxToMin`\\n/tmp/tmpdn4euabf.d(35):\
    \ Error: template `std.typecons.reverse` cannot deduce function from argument\
    \ types `!()(immutable(long[]))`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\n/tmp/tmpdn4euabf.d(41):\
    \ Error: cannot modify `immutable` expression `res`\\n/tmp/tmpdn4euabf.d(45):\
    \ Error: cannot modify `immutable` expression `res`\\n/tmp/tmpdn4euabf.d(50):\
    \ Error: cannot implicitly convert expression `res` of type `immutable(long[])`\
    \ to `ulong`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdn4euabf.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    alias Pair =\
    \ Tuple!(long, long);\n    alias IndexedValue = Tuple!(size_t, long);\n    alias\
    \ Comparator = int delegate(IndexedValue, IndexedValue);\n    alias MaxComparator\
    \ = Comparator function(Comparator);\n    alias MinComparator = Comparator function(Comparator);\n\
    \    auto compare_indexed_value = (Comparator)(IndexedValue a, IndexedValue b)\
    \ => a[1] < b[1] ? -1 : 1;\n    auto max_indexed_value = (MaxComparator)(Comparator\
    \ cmp) => (IndexedValue a, IndexedValue b) => cmp(a, b) >= 0 ? a : b;\n    auto\
    \ min_indexed_value = (MinComparator)(Comparator cmp) => (IndexedValue a, IndexedValue\
    \ b) => cmp(a, b) <= 0 ? a : b;\n    auto index_values = lst.map!(t => IndexedValue(t.tupleof)).retro;\n\
    \    auto min_value = min_indexed_value(compare_indexed_value)(index_values);\n\
    \    auto max_value = max_indexed_value(compare_indexed_value)(index_values);\n\
    \    auto result = new long[](lst.length);\n    long[] rest;\n    for (int i =\
    \ 0; i < lst.length; i += 2) {\n        if (i == 0) {\n            rest = lst[min_value[0]\
    \ + 1 .. $];\n            result[i] = min_value[1];\n        } else {\n      \
    \      rest = lst[0 .. max_value[0]] ~ lst[max_value[0] + 1 .. $];\n         \
    \   result[i] = max_value[1];\n        }\n        if (i + 1 == lst.length) {\n\
    \            break;\n        }\n        min_value = min_indexed_value(compare_indexed_value)(rest.map!(t\
    \ => IndexedValue(t.tupleof)).retro);\n        max_value = max_indexed_value(compare_indexed_value)(rest.map!(t\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmph9tg9k4l.d(22): Error: C style cast illegal, use `cast(Comparator)(IndexedValue\
    \ a, IndexedValue b) => a[1] < b[1] ? -1 : 1`\\n/tmp/tmph9tg9k4l.d(23): Error:\
    \ C style cast illegal, use `cast(MaxComparator)(Comparator cmp) => (IndexedValue\
    \ a, IndexedValue b) => cmp(a, b) >= 0 ? a : b`\\n/tmp/tmph9tg9k4l.d(24): Error:\
    \ C style cast illegal, use `cast(MinComparator)(Comparator cmp) => (IndexedValue\
    \ a, IndexedValue b) => cmp(a, b) <= 0 ? a : b`\\n/tmp/tmph9tg9k4l.d(43): Error:\
    \ found `unittest` when expecting `)` following template argument list\\n/tmp/tmph9tg9k4l.d(44):\
    \ Error: found `{` when expecting `,`\\n/tmp/tmph9tg9k4l.d(45): Error: expression\
    \ expected, not `alias`\\n/tmp/tmph9tg9k4l.d(45): Error: found `candidate` when\
    \ expecting `,`\\n/tmp/tmph9tg9k4l.d(45): Error: expression expected, not `=`\\\
    n/tmp/tmph9tg9k4l.d(45): Error: found `strange_sort_list` when expecting `,`\\\
    n/tmp/tmph9tg9k4l.d(45): Error: expression expected, not `;`\\n/tmp/tmph9tg9k4l.d(47):\
    \ Error: found `assert` when expecting `,`\\n/tmp/tmph9tg9k4l.d(47): Error: found\
    \ `;` when expecting `,`\\n/tmp/tmph9tg9k4l.d(48): Error: found `;` when expecting\
    \ `,`\\n/tmp/tmph9tg9k4l.d(49): Error: found `;` when expecting `,`\\n/tmp/tmph9tg9k4l.d(50):\
    \ Error: found `;` when expecting `,`\\n/tmp/tmph9tg9k4l.d(51): Error: found `;`\
    \ when expecting `,`\\n/tmp/tmph9tg9k4l.d(52): Error: found `;` when expecting\
    \ `,`\\n/tmp/tmph9tg9k4l.d(53): Error: found `;` when expecting `,`\\n/tmp/tmph9tg9k4l.d(54):\
    \ Error: found `;` when expecting `,`\\n/tmp/tmph9tg9k4l.d(55): Error: found `;`\
    \ when expecting `,`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph9tg9k4l.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    \n    long[] sorted = new long[lst.length];\n\
    \    auto minmax = minmaxElement(lst);\n    auto minmax_iter = minmax.max;\n \
    \   sorted[0] = *minmax.min;\n    sorted[sorted.length - 1] = *minmax.max;\n \
    \   foreach (i; 1 .. lst.length - 1)\n    {\n        if (i % 2 == 0)\n       \
    \ {\n            sorted[i] = *minmax_iter;\n            minmax_iter.popFront();\n\
    \        }\n        else\n        {\n            sorted[i] = *minmax_iter;\n \
    \           minmax_iter.popBack();\n        }\n    }\n    return sorted;\n}\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp534_m0bn.d(21): Error: undefined identifier `minmaxElement`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp534_m0bn.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    // TODO\n   \
    \ if (lst.length == 0) {\n        return lst;\n    }\n    long min = lst[0];\n\
    \    int index = 0;\n    foreach (long i; lst) {\n        if (i < min) {\n   \
    \         min = i;\n            index = lst.indexOf(i);\n        }\n    }\n  \
    \  lst.remove(index);\n    lst = lst.sort(std.functional.greater);\n    long max\
    \ = lst[0];\n    lst.remove(0);\n    lst = lst.sort();\n    long min2 = lst[0];\n\
    \    lst.remove(0);\n    lst = lst.sort(std.functional.greater);\n    long max2\
    \ = lst[0];\n    return [min, max, min2, max2];\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9nzaurf2.d(26): Error: no property `indexOf` for type `long[]`\\\
    n/tmp/tmp9nzaurf2.d(29): Error: no property `remove` for type `long[]`\\n/tmp/tmp9nzaurf2.d(30):\
    \ Error: no property `sort` for type `long[]`\\n/tmp/tmp9nzaurf2.d(32): Error:\
    \ no property `remove` for type `long[]`\\n/tmp/tmp9nzaurf2.d(33): Error: no property\
    \ `sort` for type `long[]`\\n/tmp/tmp9nzaurf2.d(35): Error: no property `remove`\
    \ for type `long[]`\\n/tmp/tmp9nzaurf2.d(36): Error: no property `sort` for type\
    \ `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9nzaurf2.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0) \n        return [];\n    else if (lst.length == 1) \n        return lst;\n\
    \    else \n    {\n        long min = min(lst);\n        auto a = lst.filter!(x\
    \ => x != min).sort!((a, b) => a > b);\n        return concat([min], a);\n   \
    \ }\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpuh9aph1z.d(23): Error: undefined identifier `min`, did you mean\
    \ function `main`?\\n/tmp/tmpuh9aph1z.d(24): Error: no property `filter` for type\
    \ `long[]`\\n/tmp/tmpuh9aph1z.d(25): Error: undefined identifier `concat`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuh9aph1z.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    import std.algorithm : sort;\n    auto l = lst.sort();\n\
    \    auto b = l.front;\n    auto e = l.back;\n    long[] new_lst;\n    new_lst\
    \ ~= b;\n    while (b + 1 != e)\n    {\n        new_lst ~= e;\n        b++;\n\
    \        new_lst ~= b;\n        e--;\n    }\n    if (b == e)\n        new_lst\
    \ ~= b;\n    return new_lst;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp2x3u9eqq.d(40): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x432869]\\n??:? void tmp2x3u9eqq.__unittest_L36_C1()\
    \ [0x42bdd2]\\n??:? void tmp2x3u9eqq.__modtest() [0x430f6c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x437f6b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x43201a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x434e65]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x434ff8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x434df1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x431ff1]\\n??:? runModuleUnitTests [0x437d41]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x432e5c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x432de3]\\n??:? _d_run_main [0x432d4e]\\n??:? main [0x430fa7]\\\
    n??:? __libc_start_main [0x4c037554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0) return [];\n    lst.sort();\n    bool swap = true;\n    long[] lst2 =\
    \ lst.dup;\n    long[] lst3 = [];\n    foreach(v; lst) {\n        if (swap) {\n\
    \            lst3 ~= lst2.front;\n            lst2 = lst2[1..$];\n        } else\
    \ {\n            lst3 ~= lst2.back;\n            lst2 = lst2[0..$-1];\n      \
    \  }\n        swap = !swap;\n    }\n    return lst3;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8l2lu4w2.d(18): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp8l2lu4w2.d(24): Error: no property `front` for type `long[]`\\n/tmp/tmp8l2lu4w2.d(27):\
    \ Error: no property `back` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp8l2lu4w2.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
