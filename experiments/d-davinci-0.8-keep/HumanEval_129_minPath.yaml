name: HumanEval_129_minPath
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    Given a grid with N rows\
  \ and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains\
  \ a value. Every integer in the range [1, N * N]\n    inclusive appears exactly\
  \ once on the cells of the grid.\n\n    You have to find the minimum path of length\
  \ k in the grid. You can start\n    from any cell, and in each step you can move\
  \ to any of the neighbor cells,\n    in other words, you can go to cells which share\
  \ an edge with you current\n    cell.\n    Please note that a path of length k means\
  \ visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off\
  \ the grid.\n    A path A (of length k) is considered less than a path B (of length\
  \ k) if\n    after making the ordered lists of the values on the cells that A and\
  \ B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically\
  \ less\n    than lst_B, in other words, there exist an integer index i (1 <= i <=\
  \ k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n   \
  \ lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return\
  \ an ordered list of the values on the cells that the minimum path go through.\n\
  \n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n \
  \       Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]],\
  \ k = 1\n        Output: [1]\n    \n*/\nlong[] minPath(long[][] grid, long k) \n"
tests: "unittest\n{\n    alias candidate = minPath;\n\n    assert(candidate([[1L,\
  \ 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]], 3L) == [1L, 2L, 1L]);\n    assert(candidate([[5L,\
  \ 9L, 3L], [4L, 1L, 6L], [7L, 8L, 2L]], 1L) == [1L]);\n    assert(candidate([[1L,\
  \ 2L, 3L, 4L], [5L, 6L, 7L, 8L], [9L, 10L, 11L, 12L], [13L, 14L, 15L, 16L]], 4L)\
  \ == [1L, 2L, 1L, 2L]);\n    assert(candidate([[6L, 4L, 13L, 10L], [5L, 7L, 12L,\
  \ 1L], [3L, 16L, 11L, 15L], [8L, 14L, 9L, 2L]], 7L) == [1L, 10L, 1L, 10L, 1L, 10L,\
  \ 1L]);\n    assert(candidate([[8L, 14L, 9L, 2L], [6L, 4L, 13L, 15L], [5L, 7L, 1L,\
  \ 12L], [3L, 10L, 11L, 16L]], 5L) == [1L, 7L, 1L, 7L, 1L]);\n    assert(candidate([[11L,\
  \ 8L, 7L, 2L], [5L, 16L, 14L, 4L], [9L, 3L, 15L, 6L], [12L, 13L, 10L, 1L]], 9L)\
  \ == [1L, 6L, 1L, 6L, 1L, 6L, 1L, 6L, 1L]);\n    assert(candidate([[12L, 13L, 10L,\
  \ 1L], [9L, 3L, 15L, 6L], [5L, 16L, 14L, 4L], [11L, 8L, 7L, 2L]], 12L) == [1L, 6L,\
  \ 1L, 6L, 1L, 6L, 1L, 6L, 1L, 6L, 1L, 6L]);\n    assert(candidate([[2L, 7L, 4L],\
  \ [3L, 1L, 5L], [6L, 8L, 9L]], 8L) == [1L, 3L, 1L, 3L, 1L, 3L, 1L, 3L]);\n    assert(candidate([[6L,\
  \ 1L, 5L], [3L, 8L, 9L], [2L, 7L, 4L]], 8L) == [1L, 5L, 1L, 5L, 1L, 5L, 1L, 5L]);\n\
  \    assert(candidate([[1L, 2L], [3L, 4L]], 10L) == [1L, 2L, 1L, 2L, 1L, 2L, 1L,\
  \ 2L, 1L, 2L]);\n    assert(candidate([[1L, 3L], [3L, 2L]], 10L) == [1L, 3L, 1L,\
  \ 3L, 1L, 3L, 1L, 3L, 1L, 3L]);\n}\nvoid main(){}"
completions: ["{\n    int[][] dirs = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\
    \    int n = grid.length;\n    long[] minVals = new long[k];\n    long[] minScore\
    \ = new long[k];\n    long[] currVals = new long[k];\n    long[] currScore = new\
    \ long[k];\n    long currScoreI = 1;\n    int currR = 0;\n    int currC = 0;\n\
    \    ArrayList!(ulong[][]) q = new ArrayList!(ulong[][])();\n    ArrayList!(ulong[][])\
    \ nq = new ArrayList!(ulong[][])();\n    q.insertBack(new ulong[][](k + 2, new\
    \ ulong[2]));\n    for (int i = 0; i < k; i++)\n    {\n        q[0][i][0] = 1\
    \ + i;\n        q[0][i][1] = 1;\n        minVals[i] = grid[0][0];\n        minScore[i]\
    \ = 1;\n    }\n    for (ulong m = 1; m <= k; m++)\n    {\n        while (!q.empty)\n\
    \        {\n            currVals[$ - 1] = q[0][$ - 1][0];\n            currScore[$\
    \ - 1] = q[0][$ - 1][1];\n            q.removeFront();\n            currR = int(currVals[$\
    \ - 1] - 1) / n;\n            currC = int(currVals[$ - 1] - 1) % n;\n        \
    \    foreach (dir; dirs)\n            {\n                int r = currR + dir[0];\n\
    \                int c = currC + dir[1];\n                if (r < 0 || r >= n\
    \ || c < 0 || c >= n)\n                    continue;\n                if (minVals[$\
    \ - 1] != 0 && minVals[$ - 1] < grid[r][c])\n                    continue;\n \
    \               if (nq.empty || nq[", "{\n    long path_length = 0;\n    long\
    \ n = grid.length;\n    long initial_cell = -1;\n    long min_val = long.max;\n\
    \    long[] path;\n    long[][] min_paths = new long[n][n];\n    long[] min_path\
    \ = new long[k];\n    // run through the grid to find the smallest value in the\
    \ grid\n    for (long i = 0; i < n; i++) \n    {\n        for (long j = 0; j <\
    \ n; j++) \n        {\n            if (grid[i][j] < min_val) \n            {\n\
    \                min_val = grid[i][j];\n                initial_cell = (i * n)\
    \ + j;\n            }\n        }\n    }\n    // DFS to get all the paths from\
    \ the smallest cell with the length k\n    path = new long[k];\n    dfs(grid,\
    \ initial_cell, 0, path, k, min_paths);\n    // set the initial cell of the path\
    \ to the smallest value in the grid\n    min_path[0] = min_val;\n    // run through\
    \ the array of all the paths to find the lexicographically smallest path\n   \
    \ for (long i = 0; i < n; i++) \n    {\n        for (long j = 0; j < n; j++) \n\
    \        {\n            if (min_paths[i][j] == 0) \n            {\n          \
    \      break;\n            }\n            if (min_paths[i][j] < min_path[path_length])\
    \ \n            {\n                min_path[path_length] = min_paths[i][j];\n\
    \            }\n            path_length++;\n        }\n    }\n    return min_path;\n\
    }", "{\n    long N = grid.length;\n    long K = k;\n    long[][] dp = new long[N][N];\n\
    \    long[] path = new long[K];\n    foreach(i; 0 .. N) \n    {\n        foreach(j;\
    \ 0 .. N) \n        {\n            dp[i][j] = long.max;\n        }\n    }\n  \
    \  dp[0][0] = 0;\n    long x = 0;\n    long y = 0;\n    foreach(i; 0 .. K) \n\
    \    {\n        path[i] = grid[x][y];\n        long[] n = new long[][]{[x + 1,\
    \ y], [x - 1, y], [x, y + 1], [x, y - 1]};\n        foreach(z; n) \n        {\n\
    \            long[] q = z;\n            long newX = q[0];\n            long newY\
    \ = q[1];\n            if(newX >= 0 && newX < N && newY >= 0 && newY < N) \n \
    \           {\n                dp[newX][newY] = min(dp[newX][newY], dp[x][y] +\
    \ abs(grid[newX][newY] - grid[x][y]));\n            }\n        }\n        long\
    \ min = long.max;\n        foreach(i; 0 .. N) \n        {\n            foreach(j;\
    \ 0 .. N) \n            {\n                if(dp[i][j] < min) \n             \
    \   {\n                    min = dp[i][j];\n                    x = i;\n     \
    \               y = j;\n                }\n            }\n        }\n    }\n \
    \   return path;\n}", "{\n    import std.stdio;\n    int n = grid.length;\n  \
    \  if (k >= n*n)\n    {\n        long[] res = new long[n*n];\n        int index\
    \ = 0;\n        foreach(i; 0..n)\n        {\n            foreach(j; 0..n)\n  \
    \          {\n                res[index++] = grid[i][j];\n            }\n    \
    \    }\n        return res;\n    }\n    if (k == 1)\n    {\n        long[] res\
    \ = new long[1];\n        res[0] = grid[0][0];\n        return res;\n    }\n \
    \   Tuple!(long, long)[] neighbours = new Tuple!(long, long)[8];\n    neighbours[0]\
    \ = tuple(1, 0);\n    neighbours[1] = tuple(1, 1);\n    neighbours[2] = tuple(0,\
    \ 1);\n    neighbours[3] = tuple(-1, 1);\n    neighbours[4] = tuple(-1, 0);\n\
    \    neighbours[5] = tuple(-1, -1);\n    neighbours[6] = tuple(0, -1);\n    neighbours[7]\
    \ = tuple(1, -1);\n    long res = INF;\n    long x = 0;\n    long y = 0;\n   \
    \ long[][] dp = new long[n][n];\n    for (long i = 0; i < n; i++)\n    {\n   \
    \     for (long j = 0; j < n; j++)\n        {\n            dp[i][j] = INF;\n \
    \       }\n    }\n    dp[0][0] = 0;\n    //long num = grid[0][0];\n    while (k\
    \ > 0)\n    {\n        if (k == 1)\n        {\n            long newNum = dp[x][y]\
    \ + grid[x][y];\n            if (newNum < res)\n            {\n              \
    \  res = newNum;\n                x = 0;\n                y = 0;\n           \
    \ }\n            break;\n        }\n        foreach(el; neighbours)\n        {\n\
    \            long newX = x + el[0];\n            long newY = y +", "{\n    long[]\
    \ result = new long[k];\n    if (k == 0) return result;\n    uint n = grid.length;\n\
    \    if (n == 0) return result;\n    // dp[v][i][j] stores the minimum path of\
    \ length v starting at (i, j)\n    auto dp = new long[k + 1][n][n];\n    foreach\
    \ (i; 0 .. n)\n        foreach (j; 0 .. n)\n            dp[0][i][j] = grid[i][j];\n\
    \    foreach (v; 1 .. k + 1)\n        foreach (i; 0 .. n)\n            foreach\
    \ (j; 0 .. n)\n            {\n                auto a = i == 0 ? long.max : dp[v\
    \ - 1][i - 1][j];\n                auto b = i == n - 1 ? long.max : dp[v - 1][i\
    \ + 1][j];\n                auto c = j == 0 ? long.max : dp[v - 1][i][j - 1];\n\
    \                auto d = j == n - 1 ? long.max : dp[v - 1][i][j + 1];\n     \
    \           dp[v][i][j] = grid[i][j] * v + min(a, b, c, d);\n            }\n \
    \   auto mn = dp[k][0][0];\n    uint i = 0, j = 0;\n    foreach (x; 0 .. n)\n\
    \        foreach (y; 0 .. n)\n            if (dp[k][x][y] < mn)\n            {\n\
    \                mn = dp[k][x][y];\n                i = x;\n                j\
    \ = y;\n            }\n    auto cur = mn;\n    auto cnt = k;\n    auto last_i\
    \ = i, last_j = j;\n    while (cnt-- > 0)\n    {\n        result[k - cnt - 1]\
    \ = grid[i][j];\n        cur -= grid[i][j];\n        if (i > 0 && dp[cnt][i -\
    \ 1][j] == cur)\n        {\n            last_i = i;\n            last", "{\n \
    \   auto N = grid.length;\n    long[] ans = new long[];\n    // The minimum distance\
    \ from any cell to the first cell we found.\n    long[][] dp = new long[N][N];\n\
    \    // The first cell we found.\n    long[][] from = new long[N][N];\n    //\
    \ The path, a queue of cells.\n    long[][] p = new long[N][N];\n    auto allVisited\
    \ = (1 << N) - 1;\n    // The state of row 1.\n    auto vis1 = 0;\n    auto getVis\
    \ = (row, col) => (vis1 >> col) & 1;\n    // The last cell visited.\n    auto\
    \ last = tuple(0, 0);\n    auto isValid = (row, col) => row >= 0 && row < N &&\
    \ col >= 0 && col < N;\n    auto add = (path, row, col) => {\n        path ~=\
    \ [row, col];\n        if (row == 0)\n            vis1 |= 1 << col;\n    };\n\
    \    auto remove = (path, row, col) => {\n        path.popBack;\n        if (row\
    \ == 0)\n            vis1 &= ~(1 << col);\n    };\n    auto go = (row, col, d,\
    \ vis) => {\n        if (dp[row][col] > d) {\n            dp[row][col] = d;\n\
    \            from[row][col] = grid[last[0]][last[1]];\n        }\n        else\
    \ if (dp[row][col] == d) {\n            auto prev = from[row][col];\n        \
    \    if (prev > grid[last[0]][last[1]])\n                from[row][col] = grid[last[0]][last[1]];\n\
    \        }\n        add(p[row][col], row, col);\n        if (vis == allVisited)\
    \ {\n            if (d < ans.length) {\n                ans = p[row][col].dup;\n\
    \                return;\n            }\n            if (d == ans.length) {\n\
    \                auto path = p[row][col].dup;\n                auto got =", "{\n\
    \    long N = grid.length;\n    auto dp = new long[N][N][][];", "{\n    if (grid.length\
    \ == 0)\n        return new long[0];\n    \n    if (k == 0)\n        return new\
    \ long[0];\n    \n    long n = grid.length;\n    long numOfCells = n * n;\n  \
    \  long[][] path = new long[numOfCells][n];\n    long[] current = new long[numOfCells];\n\
    \    long[] newPath = new long[numOfCells];\n    long index;\n    long[] currentBest\
    \ = new long[numOfCells];\n    long[] minPath = new long[numOfCells];\n    long\
    \ currentBestVal = long.max;\n    bool hasPath = false;\n    \n    for (long i\
    \ = 0; i < numOfCells; i++)\n    {\n        if (i == 0)\n        {\n         \
    \   current[i] = grid[0][0];\n            index = i;\n        }\n        else\n\
    \        {\n            if (index / n > 0)\n            {\n                path[i][0]\
    \ = index - n;\n                newPath[0] = grid[index / n - 1][index % n];\n\
    \            }\n            if (index / n < n - 1)\n            {\n          \
    \      path[i][1] = index + n;\n                newPath[1] = grid[index / n +\
    \ 1][index % n];\n            }\n            if (index % n > 0)\n            {\n\
    \                path[i][2] = index - 1;\n                newPath[2] = grid[index\
    \ / n][index % n - 1];\n            }\n            if (index % n < n - 1)\n  \
    \          {\n                path[i][3] = index + 1;\n                newPath[3]\
    \ = grid[index / n][index % n + 1];\n            }\n            \n           \
    \ long maxNewPath = long.min;\n            long maxIndex = -1;\n            for\
    \ (long j = 0; j < newPath.length; j++)\n            {\n                if (newPath[j]\
    \ > maxNewPath)\n                {\n                    maxNewPath = newPath[j];\n\
    \                    maxIndex = j;\n                }\n            }\n       \
    \     \n           ", '{', "{\n    long n = grid.length;\n    long[][] f = new\
    \ long[n][n];\n    long[] ans = new long[k];\n    immutable long[][] p = [\n \
    \       [ 0,  1],\n        [ 0, -1],\n        [ 1,  0],\n        [-1,  0]\n  \
    \  ];\n    long[][] q = new long[n][n];\n    for (long i = 0; i < n; i++)\n  \
    \      for (long j = 0; j < n; j++)\n            q[i][j] = grid[i][j];\n    for\
    \ (long i = 0; i < n; i++)\n        for (long j = 0; j < n; j++)\n           \
    \ for (long x = 0; x < 4; x++) {\n                long y = i + p[x][0];\n    \
    \            long z = j + p[x][1];\n                if (y >= 0 && y < n && z >=\
    \ 0 && z < n)\n                    f[i][j] += q[y][z];\n            }\n    tuple!(long,long)\
    \ now = tuple(0, 0);\n    for (long i = 0; i < k; i++) {\n        ans[i] = q[now[0]][now[1]];\n\
    \        tuple!(long,long) next = tuple(n, n);\n        for (long x = 0; x < 4;\
    \ x++) {\n            long y = now[0] + p[x][0];\n            long z = now[1]\
    \ + p[x][1];\n            if (y >= 0 && y < n && z >= 0 && z < n) {\n        \
    \        if (f[y][z] < f[next[0]][next[1]])\n                    next = tuple(y,\
    \ z);\n                else if (f[y][z] == f[next[0]][next[1]] &&\n          \
    \               q[y][z] < q[next[0]][next[1]])\n                    next = tuple(y,\
    \ z);\n            }\n        }\n        f[now[0]][now[1]] = ulong.max;\n    \
    \    now = next;\n    }", "{\n    return null;\n}", "{\n    long n = grid.length;\n\
    \    assert(n >= 2);\n    assert(k >= 1);\n    assert(k <= n * n);\n    long[]\
    \ ans = new long[k];\n    long f = 0;\n    long s = k - 1;\n    long sum = 0;\n\
    \    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n\
    \        {\n            sum += grid[i][j];\n        }\n    }\n    int x = 0;\n\
    \    int y = 0;\n    if (sum < 0)\n    {\n        f = k - 1;\n        s = 0;\n\
    \        sum = -sum;\n    }\n    while (k > 0)\n    {\n        k--;\n        ans[(int)f]\
    \ = grid[x][y];\n        f += s;\n        if (x + 1 < n && sum - (grid[x][y] -\
    \ grid[x + 1][y]) < 0)\n        {\n            sum -= grid[x][y] - grid[x + 1][y];\n\
    \            x++;\n        }\n        else if (y + 1 < n && sum - (grid[x][y]\
    \ - grid[x][y + 1]) < 0)\n        {\n            sum -= grid[x][y] - grid[x][y\
    \ + 1];\n            y++;\n        }\n        else if (x - 1 >= 0 && sum - (grid[x][y]\
    \ - grid[x - 1][y]) < 0)\n        {\n            sum -= grid[x][y] - grid[x -\
    \ 1][y];\n            x--;\n        }\n        else if (y - 1 >= 0 && sum - (grid[x][y]\
    \ - grid[x][y - 1]) < 0)\n        {\n            sum -= grid[x][y] - grid[x][y\
    \ - 1];\n            y--;\n        }\n    }\n    return ans;\n}", "{\n    int\
    \ n = grid.length;\n    if (n < 2) return null;\n    int w = grid[0].length;\n\
    \    if (w < 2) return null;\n    if (k <= 0) return null;\n    if (k > n * w)\
    \ return null;\n    if (k == 1)\n    {\n        auto path = new long[1];\n   \
    \     path[0] = grid[0][0];\n        return path;\n    }\n    auto min_path =\
    \ new long[k];\n    long min_cost = ulong.max;\n    for (int i = 0; i < n; i++)\n\
    \    {\n        for (int j = 0; j < w; j++)\n        {\n            auto cur_path\
    \ = new long[k];\n            cur_path[0] = grid[i][j];\n            long cur_cost\
    \ = grid[i][j];\n            for (int m = 1; m < k; m++)\n            {\n    \
    \            auto next_path = getNextPath(i, j, n, w, grid, cur_path, m, 1);\n\
    \                if (next_path is null) continue;\n                cur_path =\
    \ next_path;\n                cur_cost += cur_path[m];\n            }\n      \
    \      if (cur_cost < min_cost)\n            {\n                min_path = cur_path;\n\
    \                min_cost = cur_cost;\n            }\n        }\n    }\n    return\
    \ min_path;\n}", "{\n    /* \n        For example, if k = 3.", "{\n    auto n\
    \ = grid.length;\n    auto visited = new bool[][](n, n);\n    auto dp = new long[][](n,\
    \ n);\n    foreach (i; 0 .. n)\n    {\n        foreach (j; 0 .. n)\n        {\n\
    \            if (i == 0)\n            {\n                dp[i][j] = j;\n     \
    \       }\n            else if (j == 0)\n            {\n                dp[i][j]\
    \ = i;\n            }\n            else\n            {\n                dp[i][j]\
    \ = min(dp[i - 1][j], dp[i][j - 1]) + 1;\n            }\n        }\n    }\n  \
    \  auto res = new long[][](n * n);\n    auto cur = 0;\n    auto cur_k = k;\n \
    \   foreach (i; 0 .. n)\n    {\n        foreach (j; 0 .. n)\n        {\n     \
    \       if (visited[i][j])\n            {\n                continue;\n       \
    \     }\n            if (dp[i][j] < cur_k)\n            {\n                res[cur++]\
    \ = grid[i][j];\n                visited[i][j] = true;\n                cur_k\
    \ -= dp[i][j];\n                break;\n            }\n        }\n    }\n    return\
    \ res;\n}", "{\n    long[] ret = new long[(int)k];\n    ret = null;\n    long\
    \ N = grid.length;\n    long[][] dp = new long[(int)N][(int)N];\n    long[][]\
    \ prev = new long[(int)N][(int)N];\n    const long inf = 10 ^ 100;\n    foreach(idx,\
    \ ref i; dp) \n    {\n        foreach(ref j; i) \n        {\n            dp[idx][j]\
    \ = inf;\n            prev[idx][j] = -1;\n        }\n    }\n    dp[0][0] = grid[0][0];\n\
    \    prev[0][0] = -1;\n    foreach(idx, ref i; dp) \n    {\n        foreach(ref\
    \ j; i) \n        {\n            if (idx > 0) \n            {\n              \
    \  if (dp[idx][j] > dp[idx - 1][j] + grid[idx][j]) \n                {\n     \
    \               dp[idx][j] = dp[idx - 1][j] + grid[idx][j];\n                \
    \    prev[idx][j] = 1;\n                }\n            }\n            if (j >\
    \ 0) \n            {\n                if (dp[idx][j] > dp[idx][j - 1] + grid[idx][j])\
    \ \n                {\n                    dp[idx][j] = dp[idx][j - 1] + grid[idx][j];\n\
    \                    prev[idx][j] = 2;\n                }\n            }\n   \
    \     }\n    }\n    long curr_x = 0;\n    long curr_y = 0;\n    long curr_k =\
    \ k;\n    while (curr_k > 0) \n    {\n        if (prev[curr_x][curr_y] == -1)\
    \ \n        {\n            curr_k = -1;\n            break;\n        }\n     \
    \   if (prev[curr_x][curr_y] == 1) \n        {\n           ", "{\n    int[][]\
    \ directions = new int[][]\n    {\n        { -1, 0 }, { 1, 0 }, { 0, -1 }, { 0,\
    \ 1 }\n    };\n    int n = grid.length;\n    long maxValue = n * n;\n    Tuple!(long,\
    \ long) startPoint = tuple(maxValue, (int)maxValue);\n    Tuple!(long, long) endPoint\
    \ = tuple(0, (int)maxValue);\n    auto minPoint = tuple(0, 0);\n    for (int i\
    \ = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n  \
    \          auto currentValue = grid[i][j];\n            if (currentValue < startPoint.field0)\n\
    \            {\n                startPoint = tuple(currentValue, tuple(i, j));\n\
    \            }\n            if (currentValue == maxValue)\n            {\n   \
    \             endPoint = tuple(currentValue, tuple(i, j));\n            }\n  \
    \          if (currentValue < minPoint.field0)\n            {\n              \
    \  minPoint = tuple(currentValue, tuple(i, j));\n            }\n        }\n  \
    \  }\n    auto start = startPoint.field1;\n    auto end = endPoint.field1;\n \
    \   minPoint = tuple(minPoint.field0, startPoint.field1);\n    long[][] distance\
    \ = new long[n][n];\n    long[][] visited = new long[n][n];\n    auto queue =\
    \ appender!(Tuple!(long, long, long, long[]))();\n    queue.put(tuple(start.field0,\
    \ start.field1, 0, new long[0]));\n    while (queue.length > 0)\n    {\n     \
    \   auto top = queue.get;\n        auto row = top.field0;\n        auto col =\
    \ top.field1;\n        if (row == end.field0 && col == end.field1)\n        {\n\
    \            return top.field3;\n        }\n        if (visited[row][col] == 1)\n\
    \        {\n            continue;\n        }\n        visited[row][col] = 1;\n\
    \        fore", "{\n    static bool compare(long[] A, long[] B)\n    {\n     \
    \   if (A.length != B.length)\n            return false;\n        foreach (i,\
    \ a; A)\n        {\n            if (a != B[i])\n                return false;\n\
    \        }\n        return true;\n    }\n    static long max(long[][] grid)\n\
    \    {\n        long m = 0;\n        foreach (r; grid)\n        {\n          \
    \  foreach (c; r)\n            {\n                if (c > m)\n               \
    \     m = c;\n            }\n        }\n        return m;\n    }\n    static bool\
    \ inGrid(long[][] grid, long x, long y)\n    {\n        long n = grid.length;\n\
    \        return 0 <= x && x < n && 0 <= y && y < n;\n    }\n    static long[]\
    \ getGrid(long[][] grid, long x, long y)\n    {\n        long[] v = new long[0];\n\
    \        v ~= grid[x][y];\n        v ~= grid[x][y + 1];\n        v ~= grid[x +\
    \ 1][y];\n        v ~= grid[x + 1][y + 1];\n        return v;\n    }\n    static\
    \ long[] getGrid(long[][] grid, long x, long y, long l)\n    {\n        long[]\
    \ v = new long[0];\n        v ~= grid[x][y];\n        if (l > 1)\n        {\n\
    \            v ~= grid[x][y + 1];\n            if (l > 2)\n            {\n   \
    \             v ~= grid[x + 1][y];\n                if (l > 3)\n             \
    \   {\n                    v ~= grid[x + 1][y + 1];\n                }\n     \
    \       }\n        }\n        return v;\n    }\n    static void printGrid(long[][]\
    \ grid)\n    {\n        import std.stdio;\n        writeln(\"grid:\");\n     \
    \   foreach (r; grid)\n        {\n            foreach (c; r)\n            {\n\
    \                write(c, \" \");\n            }\n            writeln();\n   \
    \     }", "{\n    // try to use std.algorithm\n    import std.algorithm;\n   \
    \ import std.conv;\n    import std.functional;\n    import std.range;\n    import\
    \ std.typecons;\n    import std.math;\n    int N = grid.length;\n    int K = to!int(k);\n\
    \    assert(N >= 2);\n    assert(K >= 1);\n    assert(K <= N * N);\n    assert(N\
    \ > 0);\n    assert(K > 0);\n    assert(N <= 100);\n    assert(K <= 100);\n  \
    \  // BFS is always a solution\n    auto q = new Queue!(tuple!(int,int,ulong[]))();\n\
    \    q.put(tuple(0, 0, ulong[0]));\n    bool[][] mark = new bool[N][N];\n    mark[0][0]\
    \ = true;\n    int[][] dir = [\n        [0, 1],\n        [0, -1],\n        [1,\
    \ 0],\n        [-1, 0]\n    ];\n    // BFS\n    while(!q.empty)\n    {\n     \
    \   tuple!(int,int,ulong[]) curr = q.front;\n        q.popFront();\n        int\
    \ x = curr[0];\n        int y = curr[1];\n        ulong[] path = curr[2];\n  \
    \      // BFS\n        if(path.length < K)\n        {\n            foreach(d;\
    \ dir)\n            {\n                int dx = d[0];\n                int dy\
    \ = d[1];\n                int xx = x + dx;\n                int yy = y + dy;\n\
    \                if(xx >= 0 && xx < N && yy >= 0 && yy < N && !mark[xx][yy])\n\
    \                {\n                    mark[xx][yy] = true;\n               \
    \     ulong[] path_ = path.dup;\n                    path_.append(grid[xx][yy]);\n\
    \                    q.put(tuple(xx, yy, path_));\n                }\n       \
    \     }\n        }\n        // check the answer\n        if(path.length == K)\n\
    \        {\n            path.", "{\n    int N = grid.length;\n    int[] mem =\
    \ new int[N * N];\n    long[] min = new long[k];\n    for (int i = 0; i < N; i++)\n\
    \    {\n        for (int j = 0; j < N; j++)\n        {\n            mem[grid[i][j]\
    \ - 1] = i * N + j;\n        }\n    }\n    long v = mem[0];\n    int i = (int)(v\
    \ / N);\n    int j = (int)(v % N);\n    min[0] = grid[i][j];\n    for (int l =\
    \ 1; l < k; l++)\n    {\n        long v1 = (i == 0 ? 10000000 : mem[grid[i - 1][j]\
    \ - 1]);\n        long v2 = (i == N - 1 ? 10000000 : mem[grid[i + 1][j] - 1]);\n\
    \        long v3 = (j == 0 ? 10000000 : mem[grid[i][j - 1] - 1]);\n        long\
    \ v4 = (j == N - 1 ? 10000000 : mem[grid[i][j + 1] - 1]);\n        long min1 =\
    \ min(v1, v2, v3, v4);\n        v = ((min1 == v1) ? v1 : (min1 == v2) ? v2 : (min1\
    \ == v3) ? v3 : v4);\n        i = (int)(v / N);\n        j = (int)(v % N);\n \
    \       min[l] = grid[i][j];\n    }\n    return min;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
