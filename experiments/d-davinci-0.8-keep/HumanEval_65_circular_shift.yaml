name: HumanEval_65_circular_shift
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\nCircular shift the digits of\
  \ the integer x, shift the digits right by shift\n    and return the result as a\
  \ string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12,\
  \ 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \n*/\nstring circular_shift(long\
  \ x, long shift) \n"
tests: "unittest\n{\n    alias candidate = circular_shift;\n\n    assert(candidate(100L,\
  \ 2L) == \"001\");\n    assert(candidate(12L, 2L) == \"12\");\n    assert(candidate(97L,\
  \ 8L) == \"79\");\n    assert(candidate(12L, 1L) == \"21\");\n    assert(candidate(11L,\
  \ 101L) == \"11\");\n}\nvoid main(){}"
completions: ["{\n    string s = to!string(x);\n    return (shift <= s.length) ? s[shift\
    \ .. $] ~ s[0 .. shift - 1] : s[$ .. 0];\n}", "{\n    string result;\n    x =\
    \ abs(x);\n    shift = abs(shift);\n    while (x) {\n        result ~= x % 10;\n\
    \        x /= 10;\n    }\n    if (shift > result.length) {\n        return result.reverse;\n\
    \    }\n    return result[shift .. $] ~ result[0 .. shift - 1];\n}", "    long\
    \ digits = log10(x);\n    shift = shift % (digits + 1);\n    return format(\"\
    %0.*d\", digits + 1, x);\n}", "{\n    auto arr = to!(char[])(x).array;\n    if\
    \ (arr.length <= shift) \n    {\n        return arr.reverse.idup;\n    }\n   \
    \ return format(\"%.*s%.*s\", arr[shift..$].length, arr[shift..$],\n         \
    \         arr[0..shift].length, arr[0..shift]);\n}\n/*\nRepeatedly circular shift\
    \ the digits of the integer x until the digits are in\n    order, return the number\
    \ of shifts it took.\n    >>> repeated_circular_shift(123)\n    3\n    >>> repeated_circular_shift(121)\n\
    \    1\n*/\nsize_t repeated_circular_shift(long x) \n{\n    auto arr = to!(char[])(x).array;\n\
    \    auto arr2 = arr.dup;\n    size_t count = 0;\n    while (arr != arr2.sort)\
    \ \n    {\n        arr = circular_shift(to!long(arr.idup), 1).to!(char[]).array;\n\
    \        count++;\n    }\n    return count;\n}\n/*\nCompute the sum of sqrts of\
    \ the shifted numbers.\n    >>> sum_sqrt_shifted(12345)\n    9.888543819998317\n\
    */\ndouble sum_sqrt_shifted(long x) \n{\n    double sum = 0;\n    for (size_t\
    \ i = 0; i < repeated_circular_shift(x); i++) \n    {\n        sum += sqrt(x);\n\
    \        x = to!long(circular_shift(x, 1));\n    }\n    return sum;\n}\n/*\nCheck\
    \ if this is a prime number.\n    >>> is_prime(2)\n    true\n    >>> is_prime(3)\n\
    \    true\n    >>> is_prime(4)\n    false\n*/", "{\n    return to!string(x).rotateRight(shift);\n\
    }", "{\n\treturn x.text.rotate(shift);\n}", "{\n    string digitStr = to!string(x);\n\
    \    if (shift > digitStr.length) \n    {\n        return reverse(digitStr);\n\
    \    }\n    else \n    {\n        return digitStr[shift..$] ~ digitStr[0..shift-1];\n\
    \    }\n}\n/*\nTest if x is a circular prime in bases <= base.\n    >>> is_circular_prime(197,\
    \ 10)\n    True\n    >>> is_circular_prime(197, 2)\n    False\n    >>> is_circular_prime(7,\
    \ 10)\n    True\n    >>> is_circular_prime(11, 10)\n    True\n    >>> is_circular_prime(13,\
    \ 10)\n    True\n*/", "{\n    enum digits = digits(x);\n    return digits[shift\
    \ .. $] ~ digits[0 .. shift];\n}", "{\n    string digitstr = to!string(x);\n \
    \   long n = digitstr.length;\n    shift = shift % n;\n    if (shift == 0)\n \
    \       return digitstr;\n    string front = digitstr[0..$-shift];\n    string\
    \ back = digitstr[$-shift..$];\n    return front ~ back;\n}\n//bool is_prime(long\
    \ n) {\n//    if (n < 2)\n//        return false;\n//    if (n % 2 == 0)\n// \
    \       return n == 2;\n//    long i = 3;\n//    long lim = cast(long)sqrt(n);\n\
    //    while (i <= lim) {\n//        if (n % i == 0)\n//            return false;\n\
    //        i += 2;\n//    }\n//    return true;\n//}\n/*\nDecode the string S as\
    \ a path to a file/directory, return the\n    full path to that file/directory.\n\
    \    I.e. resolve the '..' and '.' in the path.\n    >>> decode_path(\"/a/b/../c\"\
    )\n    \"/a/c\"\n    >>> decode_path(\"/a/b/../c/../d\")\n    \"/a/d\"\n    >>>\
    \ decode_path(\"/a/b/c/d/../../../e\")\n    \"/e\"\n    >>> decode_path(\"a/b/c/d/../../../e\"\
    )\n    \"a/e\"\n    >>> decode_path(\"a/b/c/d/../../../../e\")\n    \"../e\"\n\
    \    >>> decode_path(\"a/b/c/d/../../../../../e\")\n    \"../../e\"\n    >>> decode_path(\"\
    a/b/c/d/../../../../../../e\")\n    \"../../../e\"\n    >>> decode_path(\"a/b/c/d/../../../../../../../e\"\
    )\n    \"../../../../e\"\n    >>> decode_path(\"../../../../../../../../../../../../../../e\"\
    )\n    \"../../../../../../../../../../../../../../e\"\n    >>> decode_", "  \
    \  {\n    auto shiftStr = to!string(x);\n    return to!string(shiftStr[$-shift\
    \ .. $] ~ shiftStr[0 .. $-shift]);\n    }\n/*\nCount the number of bits set in\
    \ the integer n.\n    >>> count_bits(5)\n    2\n    >>> count_bits(0)\n    0\n\
    \    >>> count_bits(1)\n    1\n    >>> count_bits(2)\n    1\n    >>> count_bits(3)\n\
    \    2\n    >>> count_bits(7)\n    3\n*/", "{\n    enum digits = (int)std.string.format(\"\
    %Ld\", x).length;\n    if (shift >= digits)\n        return std.string.format(\"\
    %Ld\", x).dup.reverse;\n    long[] rest = new long[digits];\n    for (int i =\
    \ 0; i < digits; i++)\n    {\n        rest[i] = x % 10;\n        x /= 10;\n  \
    \  }\n    long[] first = rest[digits - shift .. digits];\n    rest = rest[0 ..\
    \ digits - shift];\n    rest = first ~ rest;\n    return std.string.format(\"\
    %Ld\", rest.join.interpretAs!long).dup;\n}", "{\n    string s = to!string(x);\n\
    \    shift %= s.length;\n    auto shifted = s[shift .. $];\n    shifted ~= s[0\
    \ .. shift];\n    return shifted;\n}\n/*\nReturn the digit at index n of the integer\
    \ x.\n    >>> digit_at(1234, 0)\n    4\n    >>> digit_at(1234, 1)\n    3\n   \
    \ >>> digit_at(1234, 2)\n    2\n    >>> digit_at(1234, 3)\n    1\n*/\nlong digit_at(long\
    \ x, long n) \n{\n    return x % 10;\n}", "{\n    string s = to!string(x);\n \
    \   if (shift > s.length)\n        return reverse(s);\n    return s[shift..$]\
    \ ~ s[0..shift-1];\n}", "{\n    // FIXME: doesn't work for negative numbers, need\n\
    \    // to fix algorithm\n    auto digits = appender!string();\n    x = abs(x);\n\
    \    shift = abs(shift);\n    for (long i = 0; i < shift; i++)\n    {\n      \
    \  long last = x % 10;\n        x /= 10;\n        digits.put(x);\n        x =\
    \ last * pow(10, int(digits.length));\n    }\n    return to!string(digits.data);\n\
    }", "{\n    long nDigits = log10(x).floor;\n    string result = format(\"%d\"\
    , x);\n    shift %= nDigits;\n    if (shift == 0) \n        return result;\n \
    \   reverse(result);\n    string head = result[$-shift..$];\n    string tail =\
    \ result[0..$-shift-1];\n    reverse(head);\n    reverse(tail);\n    return head\
    \ ~ tail;\n}", "{\n  string s = to!string(x);\n  shift %= s.length;\n  return\
    \ s[shift..$] ~ s[0..shift];\n}", "{\n  long n = numDigits(x);\n  string xString\
    \ = to!string(x);\n  if (shift >= n)\n    return xString[shift - n .. n - 1].reverse;\n\
    \  else\n    return xString[shift .. n - 1] ~ xString[0 .. shift - 1];\n}\n \n\
    /*\n  Returns the number of digits in x.\n    >>> numDigits(0)\n    1\n    >>>\
    \ numDigits(10)\n    2\n    >>> numDigits(123)\n    3\n*/\nlong numDigits(long\
    \ x) \n{\n  long n = 1;\n  while (x / 10 > 0) \n  {\n    x /= 10;\n    n++;\n\
    \  }\n  return n;\n}\n ", "{\n    auto v = string(to!string(x));\n    for (;shift\
    \ >= v.length; shift -= v.length)\n    {\n        v = reverse(v);\n    }\n   \
    \ return v[shift..$] ~ v[0..shift];\n}", "in {\n    assert(shift >= 0);\n}\nbody\
    \ {\n    if (shift == 0) return to!string(x);\n    auto str = to!string(x);\n\
    \    if (shift >= str.length) return str.dup.reverse;\n    return str[shift..$]\
    \ ~ str[0..shift-1];\n}", "{\n    long size = digit_count(x);\n    long[] r =\
    \ new long[size];\n    long[] rr = new long[size];\n    long i = 0;\n    while\
    \ (x != 0) \n    {\n        r[i] = x % 10;\n        x /= 10;\n        i++;\n \
    \   }\n    for (i = 0; i < size; i++) \n    {\n        rr[(i + shift) % size]\
    \ = r[i];\n    }\n    string result = \"\";\n    for (i = 0; i < size; i++) \n\
    \    {\n        result ~= (to!string(rr[i]));\n    }\n    return result;\n}\n\
    /*\n    A node for the graph.\n    The nodes are integers that are shifted right\n\
    \    by the specified amount.\n    Each node is connected to the next node \n\
    \    and all nodes in between that are divisible by 3.\n*/\nclass Node \n{\n \
    \   long id;\n    long value;\n    long shift;\n    string name;\n    bool visited;\n\
    \    Node[] edges;\n    this(long x, long shift) \n    {\n        this.value =\
    \ x;\n        this.shift = shift;\n        this.name = (to!string(x));\n     \
    \   this.id = x;\n        this.visited = false;\n        this.edges = new Node[];\n\
    \    }\n    void add_edge(Node n) \n    {\n        edges ~= n;\n    }\n    void\
    \ create_edges(Node[] nodes) \n    {\n        bool found = false;\n        foreach\
    \ (Node n; nodes) \n        {\n            if (this.value % 3 == 0 && n.value\
    \ % 3 == 0) \n            {\n                this.add_edge(n);\n             \
    \   found = true;\n            }\n            if (n.value == this.value + 1) \n\
    \            {\n                if (found) \n                {\n             \
    \       return;\n                }\n                this.add_edge(n);\n      \
    \      }\n        }\n    }\n    long get_id() \n    {\n        return this.id;\n\
    \   "]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
