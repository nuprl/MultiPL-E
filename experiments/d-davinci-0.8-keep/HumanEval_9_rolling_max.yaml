name: HumanEval_9_rolling_max
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n From a given list of integers,\
  \ generate a list of rolling maximum element found until given moment\n    in the\
  \ sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4,\
  \ 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n"
tests: "unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
  \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
  \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L])\
  \ == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
completions: ["{\n    if(numbers.length == 0) return new long[0];", "{\n    long[]\
    \ result = new long[numbers.length];\n    result[0] = numbers[0];\n    foreach\
    \ (i, n; numbers[1 .. $])\n    {\n        result[i] = max(result[i - 1], n);\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long currentMax = long.min;\n    size_t i = 0;\n    foreach(n; numbers) \n\
    \    {\n        currentMax = max(currentMax, n);\n        result[i] = currentMax;\n\
    \        i++;\n    }\n    return result;\n}", "{\n    auto result = numbers.dup;\n\
    \    foreach (i, e; numbers) \n    {\n        if (i == 0) continue;\n        result[i]\
    \ = max(e, result[i - 1]);\n    }\n    return result;\n}\n \n/*\n Given two lists\
    \ of integers, generate a list of rolling maximum of elements from both lists.\n\
    \    >>> rolling_max([1, 2, 3, 2, 3, 4, 2], [4, 5, 6, 4, 2, 5, 6])\n    [4, 5,\
    \ 6, 6, 6, 6, 6]\n*/\nlong[] rolling_max(long[] numbers1, long[] numbers2) \n\
    {\n    auto result = new long[numbers1.length];\n    foreach (i, e; numbers1)\
    \ \n    {\n        result[i] = max(e, numbers2[i]);\n    }\n    return result;\n\
    }\n \n/*\n Given two lists of integers, generate a list of rolling maximum of\
    \ elements from both lists.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2], [4, 5,\
    \ 6, 4, 2, 5, 6])\n    [4, 5, 6, 6, 6, 6, 6]\n*/\nlong[] rolling_max(long[] numbers1,\
    \ long[] numbers2) \n{\n    return rolling_max(rolling_max(numbers1), rolling_max(numbers2));\n\
    }", "{\n    long[] results = new long[numbers.length];\n    auto current_max =\
    \ 0;\n    foreach(i, num; numbers)\n    {\n        current_max = max(current_max,\
    \ num);\n        results[i] = current_max;\n    }\n    return results;\n}\n/*\n\
    \    From a given list of integers, generate a list of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 1, 1, 1, 1, 1, 1]\n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] results = new long[numbers.length];\n    auto current_min =\
    \ numbers[0];\n    foreach(i, num; numbers)\n    {\n        current_min = min(current_min,\
    \ num);\n        results[i] = current_min;\n    }\n    return results;\n}\n/*\n\
    \    From a given list of integers, generate a list of maximum difference between\
    \ an element and a minimum\n    found until given moment in the sequence.\n  \
    \  >>> rolling_diff([1, 2, 3, 2, 3, 4, 2])\n    [0, 1, 2, 1, 2, 3, 2]\n*/\nlong[]\
    \ rolling_diff(long[] numbers) \n{\n    long[] results = new long[numbers.length];\n\
    \    auto current_min = numbers[0];\n    foreach(i, num; numbers)\n    {\n   \
    \     current_min = min(current_min, num);\n        results[i] = num - current_min;\n\
    \    }\n    return results;\n}\n/*\n    Function which will receive a list of\
    \ numbers and return a list of number of moves we need to \n    perform to get\
    \ sorted list from a given one.\n    >>> minimum_moves([1,2,3])\n    0\n    >>>\
    \ minimum_moves([3,2,1])\n    3\n    >>> minimum_moves([1,1,1])\n    0\n    >>>\
    \ minimum_moves([2,2,1])\n    1\n    >>> minimum_moves([1,1,2])\n", "{\n    long[]\
    \ result = new long[numbers.length];\n    auto max_value = -Infinity;\n    foreach\
    \ (i, n; numbers) \n    {\n        max_value = max(max_value, n);\n        result[i]\
    \ = max_value;\n    }\n    return result;\n}", "{\n    long[] res = new long[numbers.length];\n\
    \    foreach(int i, long num; numbers)\n    {\n        if(i == 0)\n        {\n\
    \            res[i] = num;\n        }\n        else\n        {\n            res[i]\
    \ = max(res[i-1], num);\n        }\n    }\n    return res;\n}", "{\n\tif (numbers.length\
    \ == 0)\n\t{\n\t\treturn numbers;\n\t}\n\tlong[] result = new long[numbers.length];\n\
    \t\n\tresult[0] = numbers[0];\n\tfor (int i = 1; i < numbers.length; i++)\n\t\
    {\n\t\tresult[i] = max(result[i - 1], numbers[i]);\n\t}\n\treturn result;\n}",
  "{\n    long[] result = new long[numbers.length];\n    long current_max = numbers[0];\n\
    \    foreach(i, number; numbers) \n    {\n        current_max = max(current_max,\
    \ number);\n        result[i] = current_max;\n    }\n    return result;\n}\n/*\n\
    \ From a given list of integers, generate a list of rolling minimum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3,\
    \ 4, 2])\n    [1, 1, 1, 1, 1, 1, 1]\n    \n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long current_min = numbers[0];\n\
    \    foreach(i, number; numbers) \n    {\n        current_min = min(current_min,\
    \ number);\n        result[i] = current_min;\n    }\n    return result;\n}\n/*\n\
    \ From a given list of integers, generate a list of rolling sum of elements found\
    \ until given moment\n    in the sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3,\
    \ 4, 2])\n    [1, 3, 6, 8, 11, 15, 17]\n    \n*/\nlong[] rolling_sum(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long current_sum = numbers[0];\n\
    \    foreach(i, number; numbers) \n    {\n        current_sum += number;\n   \
    \     result[i] = current_sum;\n    }\n    return result;\n}\n/*\n From a given\
    \ list of integers, generate a list of rolling mean of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_mean([1, 2, 3, 2, 3, 4, 2])\n\
    \    [1, 1.5, 2, 2.66666, 3.6, 3.83333, 3.85714]\n    \n*/\ndouble[] rolling_mean(long[]\
    \ numbers) \n{\n    long[] running_sum = rolling_sum(numbers);\n    double[] result\
    \ = new double[numbers", "{\n    long[] result = new long[numbers.length];\n \
    \   result[0] = numbers[0];\n    foreach (i, num; numbers[1..$]) \n    {\n   \
    \     if (num > result[i])\n            result[i + 1] = num;\n        else\n \
    \           result[i + 1] = result[i];\n    }\n    return result;\n}", "{\n  //\
    \ Use of range primitives to make the program clear.\n  // Using static arrays\
    \ to store the result (pass by reference, so fast).\n  import std.range : iota,\
    \ retro;\n  import std.conv : to;\n  long[] r_max;\n  r_max.length = numbers.length;\n\
    \  long[] max_from_left;\n  max_from_left.length = numbers.length;\n  long[] max_from_right;\n\
    \  max_from_right.length = numbers.length;\n \n  long current_max = numbers[0];\n\
    \  foreach (i, element; numbers[iota(1, numbers.length)]) {\n    if (element >\
    \ current_max)\n      current_max = element;\n    max_from_left[i + 1] = current_max;\n\
    \  }\n \n  current_max = numbers[$ - 1];\n  foreach (i, element; numbers[retro(numbers.length\
    \ - 1, 0)]) {\n    if (element > current_max)\n      current_max = element;\n\
    \    max_from_right[i] = current_max;\n  }\n \n  foreach (i, element; numbers)\
    \ {\n    r_max[i] = max(max_from_left[i], max_from_right[i]);\n  }\n  return r_max;\n\
    }\n \n// https://forum.dlang.org/post/wgdxsnwtuefztnnuwggb@forum.dlang.org", "{\n\
    \    import std.stdio;\n    import std.range;\n    import std.algorithm;\n   \
    \ import std.exception;\n    import std.array;\n    // cannot use  `initializer`\
    \ since max is parameterized on the return type of a function\n    // and auto\
    \ can't be used with that\n    long max = long.min;\n    return numbers.map!(n\
    \ => (n > max ? max = n : max)).array;\n}\n/*\n Given an input string, return\
    \ all contiguous substrings of size k\n    >>> substrings(\"abcde\", 3)\n    [\"\
    abc\", \"bcd\", \"cde\"]\n    >>> substrings(\"abcde\", 4)\n    [\"abcd\", \"\
    bcde\"]\n    >>> substrings(\"abcde\", 5)\n    [\"abcde\"]\n    >>> substrings(\"\
    abcde\", 6)\n    []\n*/\nstring[] substrings(string s, size_t k) \n{\n    import\
    \ std.exception;\n    import std.algorithm;\n    import std.array;\n    if (k\
    \ > s.length) return new string[0];\n    return s.splitter!(a => true).take(s.length\
    \ - k + 1).map!(a => a.take(k).array.idup).array;\n}\n/*\n Given a list of integers,\
    \ return the maximum product of any contiguous sublist of the list.\n    >>> max_product([1,\
    \ 2, 3, 4])\n    24\n    >>> max_product([-1, 2, 3, -4])\n    24\n    >>> max_product([0,\
    \ -1, -2, 0])\n    2\n    >>> max_product([0, -1, -2, 0, -2])\n    4\n    >>>\
    \ max_product([-1, 0, -2, 1, -3])\n    6\n    >>> max_product([0, 0, 0, 0])\n\
    \    0\n    >>> max_product([1, 2, 3, 0])\n    6\n    >>> max_product([-1, 2,\
    \ 3, 0])\n    6\n    >>> max_product([-1, 2, 0, 3])\n    6\n    >>> max_product([1,\
    \ 2, 0", "{\n    long[] result = new long[numbers.length];\n    long current_max\
    \ = numbers[0];\n    result[0] = current_max;\n    foreach(n; 1 .. numbers.length)\
    \ \n    {\n        current_max = max(current_max, numbers[n]);\n        result[n]\
    \ = current_max;\n    }\n    return result;\n}", "{\n\tlong[] rolling_max = new\
    \ long[numbers.length];\n\tif (numbers.length == 0) return rolling_max;\n\trolling_max[0]\
    \ = numbers[0];\n\tforeach (i, n; numbers[1..$])\n\t{\n\t\tif (n >= rolling_max[i])\
    \ \n\t\t{\n\t\t\trolling_max[i+1] = n;\n\t\t} \n\t\telse \n\t\t{\n\t\t\trolling_max[i+1]\
    \ = rolling_max[i];\n\t\t}\n\t}\n\treturn rolling_max;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long maxSoFar = 0;\n    foreach(index, number;\
    \ numbers) \n    {\n        maxSoFar = max(maxSoFar, number);\n        result[index]\
    \ = maxSoFar;\n    }\n    return result;\n}", "{\n    long max = long.min;\n \
    \   long[] result = new long[];\n    foreach(n; numbers) \n    {\n        max\
    \ = max(max, n);\n        result ~= max;\n    }\n    return result;\n}", "{\n\
    \    auto result = new long[](numbers.length);\n    long max = numbers[0];\n \
    \   foreach (i, number; numbers) {\n        max = max(max, number);\n        result[i]\
    \ = max;\n    }\n    return result;\n}\n/*\nGiven a sequence of non-negative integers\
    \ and a starting value,\ncalculate the sum of the sequence, where the next element\
    \ in the sequence is calculated as the sum of the current element,\nand the difference\
    \ between the current element and the previous element.", "{\n    long[] res =\
    \ new long[numbers.length];\n    long max = 0;\n    foreach(i, number; numbers)\n\
    \    {\n        max = max(max, number);\n        res[i] = max;\n    }\n    return\
    \ res;\n}", "{\n    long[] result = new long[numbers.length];\n    long currentMax\
    \ = -Infinity;\n    foreach(index, value; numbers) \n    {\n        currentMax\
    \ = max(currentMax, value);\n        result[index] = currentMax;\n    }\n    return\
    \ result;\n}", "{\n    size_t sz = numbers.length;\n    immutable arr = new immutable(sz);\n\
    \    foreach(i; 0..sz) \n    {\n        auto n = numbers[i];\n        foreach(j;\
    \ i..sz) \n        {\n            arr[j] = max(arr[j], n);\n        }\n    }\n\
    \    return arr;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
