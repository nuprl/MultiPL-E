name: HumanEval_161_solve
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\nYou are given a string s.\n \
  \   if s[i] is a letter, reverse its case from lower to upper or vise versa, \n\
  \    otherwise keep it as it is.\n    If the string contains no letters, reverse\
  \ the string.\n    The function should return the resulted string.\n    Examples\n\
  \    solve(\"1234\") = \"4321\"\n    solve(\"ab\") = \"AB\"\n    solve(\"#a@C\"\
  ) = \"#A@c\"\n    \n*/\nstring solve(string s) \n"
tests: "unittest\n{\n    alias candidate = solve;\n\n    assert(candidate(\"AsDf\"\
  ) == \"aSdF\");\n    assert(candidate(\"1234\") == \"4321\");\n    assert(candidate(\"\
  ab\") == \"AB\");\n    assert(candidate(\"#a@C\") == \"#A@c\");\n    assert(candidate(\"\
  #AsdfW^45\") == \"#aSDFw^45\");\n    assert(candidate(\"#6@2\") == \"2@6#\");\n\
  \    assert(candidate(\"#$a^D\") == \"#$A^d\");\n    assert(candidate(\"#ccc\")\
  \ == \"#CCC\");\n}\nvoid main(){}"
completions: ["{\n    string result = \"\";\n    foreach(mutable char c; s)\n    {\n\
    \        switch(c)\n        {\n            case 'a'..'z':\n                c =\
    \ to!char(c ^ 1<<5);\n                break;\n            case 'A'..'Z':\n   \
    \             c = to!char(c ^ 1<<5);\n                break;\n            default:\n\
    \                break;\n        }\n        result ~= c;\n    }\n    return result;\n\
    }", "{\n    string res = \"\";\n    foreach(c; s)\n    {\n        res ~= isAlpha(c)\
    \ ? to!string(c) == toUpper(c) ? toLower(c) : toUpper(c) : c;\n    }\n    return\
    \ res.length == 0 ? std.algorithm.reverse(s) : res;\n}", "{\n    string result\
    \ = \"\";\n    foreach(i; 0 .. s.length)\n    {\n        if(std.uni.isAlpha(s[i]))\n\
    \        {\n            if(s[i] >= 'a' && s[i] <= 'z')\n            {\n      \
    \          result ~=  to!string(to!char(s[i] - 'a' + 'A'));\n            }\n \
    \           else if(s[i] >= 'A' && s[i] <= 'Z')\n            {\n             \
    \   result ~=  to!string(to!char(s[i] - 'A' + 'a'));\n            }\n        }\n\
    \        else\n        {\n            result ~= s[i];\n        }\n    }\n    return\
    \ result;\n}", "{\n    auto result = \"\";\n    foreach(c; s)\n    {\n       \
    \ if (std.regex.Regex.isUnicodeLetter(c))\n        {\n            if (std.regex.Regex.isUnicodeUpper(c))\n\
    \                result ~= toLower(c);\n            else\n                result\
    \ ~= toUpper(c);\n        }\n        else\n            result ~= c;\n    }\n \
    \   if (std.algorithm.isUnary!(a => std.regex.Regex.isUnicodeLetter(a))(s))\n\
    \        return result.idup.retro;\n    return result;\n}", "{\n    string result\
    \ = \"\";\n    if (s.length == 0) return s;\n    foreach(c; s)\n    {\n      \
    \  if (c.isLetter)\n        {\n            result ~= c.swapcase;\n        }\n\
    \        else\n        {\n            result ~= c;\n        }\n    }\n    return\
    \ result;\n}", "{\n    //...\n    string revStr = \"\";\n    bool contains_letter\
    \ = false;\n    foreach(c; s)\n    {\n        if(!(c >= 'a' && c <= 'z') && !(c\
    \ >= 'A' && c <= 'Z'))\n        {\n            revStr ~= c;\n        }\n     \
    \   else\n        {\n            if(c >= 'a' && c <= 'z')\n            {\n   \
    \             revStr ~= to!string(c - 'a' + 'A');\n            }\n           \
    \ else\n            {\n                revStr ~= to!string(c - 'A' + 'a');\n \
    \           }\n            contains_letter = true;\n        }\n    }\n    if(contains_letter)\n\
    \    {\n        return revStr;\n    }\n    else\n    {\n        string rev=\"\"\
    ;\n        for(size_t i = 0; i < revStr.length; i++)\n        {\n            rev\
    \ ~= revStr[revStr.length - i - 1];\n        }\n        return rev;\n    }\n \
    \   \n}", "{\n    string str1=\"\";\n    string str2=\"\";\n    string str3=\"\
    \";\n    for(int i=0;i<s.length;i++)\n    {\n        if(isAlpha(s[i]))\n     \
    \   {\n            if(isUpper(s[i]))\n            {\n            str1+=tolower(s[i]);\n\
    \            }\n            else\n            {\n                str1+=toupper(s[i]);\n\
    \            }\n        }\n        else\n        {\n            str2+=s[i];\n\
    \        }\n    }\n    str3=str1+str2;\n    if(str3.length!=0)\n    {\n    return\
    \ str3;\n    }\n    else\n    {\n        return s;\n    }\n}", "{\n    string\
    \ res;\n    for(auto elem : s)\n    {\n        if(elem.isUpper())\n          \
    \  res ~= elem.toLower();\n        else if(elem.isLower())\n            res ~=\
    \ elem.toUpper();\n        else\n            res ~= elem;\n    }\n    return res.dup.reverse;\n\
    }", "{\n    string result = \"\";\n    foreach(i;0..s.length)\n    {\n       \
    \ if(isAlpha(s[i]))\n        {\n            if(isUpper(s[i]))\n            {\n\
    \                result ~= toLower(s[i]);\n            }\n            else\n \
    \           {\n                result ~= toUpper(s[i]);\n            }\n     \
    \   }\n        else\n        {\n            result ~= s[i];\n        }\n    }\n\
    \    if(result == s)\n    {\n        return std.algorithm.reverse(result);\n \
    \   }\n    return result;\n}", "{\n    if(s.isEmpty) return s;\n    string result\
    \ = \"\";\n    foreach(i, char c; s)\n    {\n        if(isalpha(c))\n        {\n\
    \            if(isupper(c))\n                result ~= tolower(c);\n         \
    \   else\n                result ~= toupper(c);\n        }\n        else\n   \
    \         result ~= c;\n    }\n    return result;\n}", "{\n    string ret = \"\
    \";\n    foreach(i,c;s)\n    {\n        if(isAlpha(c))\n        {\n          \
    \  if(isUpper(c))\n                ret ~= toLower(c);\n            else\n    \
    \            ret ~= toUpper(c);\n        }\n        else\n            ret ~= c;\n\
    \    }\n    return ret;\n}", "{\n    string result = \"\";\n    if (s.findFirst(\"\
    [a-zA-Z]\") == -1) return reverse(s);\n    for (int i = 0; i < s.length; i++)\n\
    \    {\n        if (isUpper(s[i])) result ~= toLower(s[i]);\n        else if (isLower(s[i]))\
    \ result ~= toUpper(s[i]);\n        else result ~= s[i];\n    }\n    return result;\n\
    }", "{\n    int l = s.length;\n    if(l == 0) return s;\n    if(!isAlpha(s[0])){\n\
    \        if(s[0] == '-' || s[0] == '+'){\n            s = s[0] ~ reverse(s[1..$]);\n\
    \        }else{\n            s = reverse(s);\n        }\n    }else{\n        auto\
    \ rev = reverse(s);\n        string res;\n        foreach(i, c; rev){\n      \
    \      if(isAlpha(c)){\n                res ~= toLower(c);\n            }else{\n\
    \                res ~= c;\n            }\n        }\n        s = res;\n    }\n\
    \    return s;\n}", "{\n    string res;\n    size_t n = s.length;\n    foreach(ch;\
    \ s)\n    {\n        if(isAlpha(ch))\n        {\n            res ~= (isUpper(ch)\
    \ ? toLower(ch) : toUpper(ch));\n        }\n        else\n        {\n        \
    \    res ~= ch;\n        }\n    }\n    if(res.length == 0)\n    {\n        return\
    \ s.reverse;\n    }\n    return res;\n}", "{\n    //string result = \"\";\n  \
    \  /*\n    for(int i = 0; i < s.length; i++)\n    {\n        if (isalpha(s[i]))\n\
    \        {\n            if (isupper(s[i]))\n            {\n                result\
    \ ~= tolower(s[i]);\n            }\n            else\n            {\n        \
    \        result ~= toupper(s[i]);\n            }\n        }\n        else\n  \
    \      {\n            result ~= s[i];\n        }\n    }\n    */\n    //return\
    \ result;\n    char[] result = new char[](s.length);\n    bool exist = false;\n\
    \    for(int i = 0; i < s.length; i++)\n    {\n        if (isalpha(s[i]))\n  \
    \      {\n            if (isupper(s[i]))\n            {\n                result[i]\
    \ = tolower(s[i]);\n            }\n            else\n            {\n         \
    \       result[i] = toupper(s[i]);\n            }\n            exist = true;\n\
    \        }\n        else\n        {\n            result[i] = s[i];\n        }\n\
    \    }\n    if (exist)\n    {\n        return result.idup;\n    }\n    else\n\
    \    {\n        return result.dup.reverse.idup;\n    }\n}", "{\n    string a;\n\
    \    if (s.length==0)\n        return s;\n    foreach(ch;s)\n    {\n        if\
    \ (ch.isLetter)\n        {\n            if (ch.isUpper)\n                a~=ch.toLower;\n\
    \            else\n                a~=ch.toUpper;\n        }\n        else\n \
    \           a~=ch;\n    }\n    return a;\n}\n/* best\nauto solve(string s) \n\
    {\n  auto flip = (char ch) {\n    if (ch.isLetter)\n      return ch.isUpper ?\
    \ ch.toLower : ch.toUpper;\n    return ch;\n  };\n  return s.length == 0 ? s :\
    \ s.map!flip.reversed.to!string;\n}\n*/", "{\n    string result = \"\";\n    bool\
    \ letter = false;\n    for(int i = 0; i < s.length; i++)\n    {\n        if(isalpha(s[i]))\n\
    \        {\n            letter = true;\n            result ~= s[i];\n        }\n\
    \        else\n        {\n            result ~= s[i];\n        }\n    }\n    if(letter)\n\
    \    {\n        return result.toupper;\n    }\n    else\n    {\n        return\
    \ result.reversed;\n    }\n}", "{\n    if(s.length > 0)\n    {\n        string\
    \ t = \"\";\n        for(in i = 0; i < s.length; i++)\n        {\n           \
    \ if(s[i] >= 'a' && s[i] <= 'z')\n            {\n                t ~= to!string(toUpper(s[i]));\n\
    \            }\n            else if(s[i] >= 'A' && s[i] <= 'Z')\n            {\n\
    \                t ~= to!string(toLower(s[i]));\n            }\n            else\n\
    \            {\n                t ~= s[i];\n            }\n        }\n       \
    \ return t;\n    }\n    else\n    {\n        return s;\n    }\n}", "{\n \n  if\
    \ (s.length != 0)\n  {\n    char[] chars = s.dup;\n    foreach (i,ch; s)\n   \
    \ {\n      if (isLetter(ch))\n      {\n        if (isUpper(ch))\n          chars[i]\
    \ = toLower(ch);\n        else\n          chars[i] = toUpper(ch);\n      }\n \
    \   }\n    return chars.join();\n  }\n  else\n    return s.dup.reversed.join();\n\
    }", "{\n    string ret = \"\";\n    foreach(c; s)\n    {\n        if (c >= 'a'\
    \ && c <= 'z')\n            ret ~= (char)(c - ('a' - 'A'));\n        else if (c\
    \ >= 'A' && c <= 'Z')\n            ret ~= (char)(c + ('a' - 'A'));\n        else\n\
    \            ret ~= c;\n    }\n    return ret;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
