name: HumanEval_121_solution
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\nGiven a non-empty list of integers,\
  \ return the sum of all of the odd elements that are in even positions.\n    \n\n\
  \    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3])\
  \ ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \n*/\nlong solution(long[] lst)\
  \ \n"
tests: "unittest\n{\n    alias candidate = solution;\n\n    assert(candidate([5L,\
  \ 8L, 7L, 1L]) == 12L);\n    assert(candidate([3L, 3L, 3L, 3L, 3L]) == 9L);\n  \
  \  assert(candidate([30L, 13L, 24L, 321L]) == 0L);\n    assert(candidate([5L, 9L])\
  \ == 5L);\n    assert(candidate([2L, 4L, 8L]) == 0L);\n    assert(candidate([30L,\
  \ 13L, 23L, 32L]) == 23L);\n    assert(candidate([3L, 13L, 2L, 9L]) == 3L);\n}\n\
  void main(){}"
completions: ["{\n  return lst.filter!(a => a % 2 == 1).filter!(b => lst.indexOf(b)\
    \ % 2 == 0).sum;\n}", "{\n    long sum = 0;\n    foreach(e; 0..lst.length)\n \
    \   {\n        if(e % 2 == 0 && abs(lst[e]) % 2 == 1)\n        {\n           \
    \ sum += lst[e];\n        }\n    }\n    return sum;\n}", "{\n    long solution(long[]\
    \ lst) \n    {\n      long result = 0;\n      for(int i = 1; i < lst.length; i\
    \ += 2)\n      {\n        if(lst[i] % 2 == 0)\n        {\n          result +=\
    \ lst[i];\n        }\n      }\n      return result;\n    }\n}", "{\n    long sum=0;\n\
    \    int i=0;\n    foreach(ele;lst)\n    {\n        if(i%2==0 && ele%2==1)\n \
    \       {\n            sum+=ele;\n        }\n        i++;\n    }\n    return sum;\n\
    }", "{\n    long sum = 0;\n    bool odd = false;\n    foreach(v; lst) {\n    \
    \    if(odd) {\n            if(v % 2 != 0)\n                sum += v;\n      \
    \  }\n        odd = !odd;\n    }\n    return sum;\n}", "{\n    return lst.filter!(a\
    \ => a % 2 == 1 && lst.indexOf(a) % 2 == 0).sum;\n}", "{\n  return lst.filter!(a\
    \ => lst.indexOf(a) % 2 == 0 && a % 2 != 0).reduce!((a, b) => a + b)(0);\n}",
  "{\n    return list(lst)\n        .chunkBy!(a => a % 2 == 0)\n        .filter!(a\
    \ => a[0] % 2 == 0)\n        .map!(a => a[1])\n        .map!(a => a[1])\n    \
    \    .sum;\n}", "{\n    return lst.enumerate.filter!(x => x.index % 2 == 0).filter!(x\
    \ => x.value % 2 != 0).map!(x => x.value).sum;\n}", "{\n    long count = 0;\n\
    \    size_t i = 0;\n    while(i < lst.length)\n    {\n        if(i % 2 == 0 &&\
    \ lst[i] % 2 != 0)\n        {\n            count += lst[i];\n        }\n     \
    \   i++;\n    }\n    return count;\n}", "{\n    import std.algorithm.iteration\
    \ : filter, map, sum;\n    return lst.filter!((a,b) => b % 2 == 0).map!(a => a\
    \ % 2 != 0 ? a : 0).sum;\n}", "{\n    long sum = 0;\n    foreach(int i, elem;\
    \ zip(iota(lst.length), lst))\n    {\n        if(elem % 2 == 1 && i % 2 == 0)\n\
    \            sum += elem;\n    }\n    return sum;\n}", "{\n    if(lst.length<2)\n\
    \        return 0;\n    if(lst.length<3)\n        return lst[1]%2==0?lst[1]:0;\n\
    \    if(lst.length<4)\n        return lst[1]%2==0?lst[1]:lst[2]%2==0?lst[2]:0;\n\
    \    /*\n        -- m\xF3j spos\xF3b\n    long sum=0;\n    long[] lst2=new long[lst.length/2];\n\
    \    for(int i=0;i<lst.length/2;i++)\n        lst2[i]=lst[i*2+1];\n    for(int\
    \ i=0;i<lst2.length;i++)\n        if(lst2[i]%2==0)\n            sum+=lst2[i];\n\
    \    return sum;\n    */\n    /*\n        return lst.filter!(a => a%2==0).reduce!(a\
    \ => a, b => a+b)();\n        -- kr\xF3tszy kod\n    */\n    /*\n        -- z\
    \ wykorzystaniem map\n    int lstlen=lst.length;\n    auto lst2=lst.map!(a =>\
    \ a).array();\n    auto lst3=lst2.slice(1, lstlen);\n    return lst3.filter!(a\
    \ => a%2==0).reduce!(a => a, b => a+b)();\n    */\n    /*\n        -- z wykorzystaniem\
    \ foreach\n    long sum=0;\n    foreach(n; lst.filter!(a => a%2==0))\n       \
    \ sum+=n;\n    return sum;\n    */\n    /*\n        -- trzeci spos\xF3b\n    return\
    \ lst.filter!(a => a%2==0).reduce!(a => a, b => a+b)();\n    */\n    /*\n    \
    \    -- czwarty spos\xF3b\n    return lst.filter!(a => a%2==0).reduce!(", "{\n\
    \    auto oddPositions = iota(0, 2*lst.length, 2);\n    long result = 0;\n   \
    \ foreach(index; oddPositions)\n    {\n        result += lst[index];\n    }\n\
    \    return result;\n}", "{\n    auto odds = lst.filter!(e => e % 2 == 1);\n \
    \   auto evens = odds.filter!((e, i) => i % 2 == 0);\n    return evens.reduce!((e,\
    \ i) => e + i)(0);\n}", "{\n  lst.length.iota\n      .filter!((int i) => (i &\
    \ 1) == 0)\n      .filter!((int i) => (lst[i] & 1) == 1)\n      .sum;\n}", "{\n\
    \    long sum = 0;\n    foreach(i, v; lst)\n    {\n        if(i % 2 == 0 && v\
    \ % 2 != 0)\n        {\n            sum += v;\n        }\n    }\n    return sum;\n\
    }", "{\n    return lst.zipWithIndex.filter!(x => (x[1] & 1) == 0).filter!(x =>\
    \ (x[0] & 1) == 1).map!(x => x[0]).sum;\n}", "{\n    // TODO: Solution\n    if(lst.length\
    \ <= 0) return 0;\n    long ans = 0;\n    long[] lst1 = lst.dup;\n    lst1.remove(lst1.length\
    \ - 1);\n    lst1.remove(0);\n    foreach(idx, val; lst1)\n    {\n        if(idx\
    \ % 2 == 0)\n        {\n            if(val % 2 != 0)\n            {\n        \
    \        ans += val;\n            }\n        }\n    }\n    return ans;\n}", "{\n\
    \  int count = 0;\n  long total = 0;\n  for(int i = 0; i < lst.length; i++)\n\
    \  {\n    if(i % 2 == 0 && lst[i] % 2 != 0)\n    {\n      total += lst[i];\n \
    \   }\n  }\n  return total;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
