name: HumanEval_149_sorted_list_sum
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
  \ a list of strings as a parameter,\n    deletes the strings that have odd lengths\
  \ from it,\n    and returns the resulted list with a sorted order,\n    The list\
  \ is always a list of strings and never an array of numbers,\n    and it may contain\
  \ duplicates.\n    The order of the list should be ascending by length of each word,\
  \ and you\n    should return the list sorted by that rule.\n    If two words have\
  \ the same length, sort the list alphabetically.\n    The function should return\
  \ a list of strings in sorted order.\n    You may assume that all words will have\
  \ the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"\
  ]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\"\
  , \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n"
tests: "unittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"\
  aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\",\
  \ \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"\
  d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\"\
  , \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"\
  ]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"\
  c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"\
  cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}"
completions: ["{\n\tstring[] res = [];\n\tauto len = lst.length;\n\tforeach(i; 0..len)\n\
    \t{\n\t\tif (lst[i].length % 2 == 0)\n\t\t{\n\t\t\tres ~= lst[i];\n\t\t}\n\t}\n\
    \treturn res;\n}", "{\n    int[] b = new int[0];\n    string[] sortedlist = new\
    \ string[0];\n    int[] a = new int[0];\n    string[] sorted = new string[0];\n\
    \    string[] list = new string[0];\n    string[] c = new string[0];\n    string[]\
    \ d = new string[0];\n    foreach(string i; lst)\n    {\n        if(i.length %\
    \ 2 == 0)\n        {\n            sortedlist ~= i;\n        }\n    }\n    foreach(string\
    \ j; sortedlist)\n    {\n        a ~= j.length;\n    }\n    b = a.sort;\n    foreach(int\
    \ k; b)\n    {\n        foreach(string l; sortedlist)\n        {\n           \
    \ if(k == l.length)\n            {\n                sorted ~= l;\n           \
    \ }\n        }\n    }\n    return sorted;\n}\n// Write a function that accepts\
    \ a list of integers as a parameter,\n// computes their sum, and returns the sum,\n\
    // The function should return an integer that represents the sum of the list.",
  "{\n    lst = lst.map!(a => a.length).sort().dedup;\n    return lst;\n}", "{\n \
    \   immutable len = lst.length;\n    immutable i = 0;\n    string[] temp = new\
    \ string[len];\n    sort(lst);\n    foreach(string x; lst)\n    {\n        if(x.length\
    \ % 2 == 0)\n        {\n            temp[i] = x;\n            i++;\n        }\n\
    \    }\n    string[] list = new string[i];\n    for(int j = 0; j < i; j++)\n \
    \   {\n        list[j] = temp[j];\n    }\n    return list;\n}", "{\n    string[]\
    \ result;\n    foreach(string item; lst)\n    {\n        if( item.length % 2 ==\
    \ 0)\n        {\n            result ~= item;\n        }\n    }\n    sort(result);\n\
    \    return result;\n}", "{\n\tsort(lst);\n\treturn lst;\n}", "{\n\tstring[] lst2;\n\
    \tlst2 = lst.dup;\n\t\n\tint odd_found;\n\tint i;\n\tforeach(string word; lst)\
    \ {\n\t\ti++;\n\t\tif (word.length%2 == 1) {\n\t\t\tlst2.remove(i);\n\t\t\ti--;\n\
    \t\t}\n\t}\n\tlst2.sort;\n\treturn lst2;\n}", "{\n    auto result = lst.filter!(a\
    \ => a.length % 2 == 0).sort();\n    return result;\n}", "{\n    int[] size_list;\n\
    \    string[] new_list;\n    int n = lst.length;\n    foreach(i; lst)\n    {\n\
    \        int len = i.length;\n        if(len % 2 == 0)\n        {\n          \
    \  new_list ~= i;\n            size_list ~= len;\n        }\n    }\n    new_list.sort;\n\
    \    return new_list;\n}", "{\n    foreach(string i; lst) \n    {\n        if(i.length()\
    \ % 2 != 0)\n        {\n            lst.remove(i);\n        }\n    }\n    std.algorithm.sort(lst);\n\
    \    return lst;\n}", "{\n    List!(string) r = new List!(string);\n    //sort(lst,\
    \ (a, b) => a.length > b.length);\n    foreach(string s; lst)\n    {\n       \
    \ if (s.length % 2 == 0)\n        {\n            r.insert(s);\n        }\n   \
    \ }\n    return r.array;\n}", "{\n    struct str_len\n    {\n        size_t length;\n\
    \        string str;\n    }\n    static int compare_str_length(str_len a, str_len\
    \ b) \n    {\n        return a.length < b.length;\n    }\n    str_len[] str_lens;\n\
    \    foreach(str; lst)\n    {\n        if(str.length % 2 == 0)\n        {\n  \
    \          str_lens ~= str_len(str.length, str);\n        }\n    }\n    sort(str_lens,\
    \ compare_str_length);\n    string[] result;\n    foreach(i; str_lens)\n    {\n\
    \        result ~= i.str;\n    }\n    return result;\n}", "{\n    auto char_lst\
    \ = lst\n    .map!(a => a[])\n    .sort!(a => a.length, a => a)\n    .retro;\n\
    \    return char_lst\n    .join()\n    .array;\n}", "{\n    auto lst_length =\
    \ sort(lst, (a, b) { return a.length < b.length; });\n    lst_length = uniq(lst_length);\n\
    \    return lst_length;\n}", "{\n    bool b_test = true;\n    auto lst_string\
    \ = new string[lst.length];\n    auto lst_return = new string[lst.length];\n \
    \   int size_list = 0;\n    foreach(i, x; lst)\n    {\n        if (x.length %\
    \ 2 == 0)\n        {\n            lst_string[size_list] = x;\n            size_list\
    \ += 1;\n        }\n    }\n    foreach(i, x; lst_string)\n    {\n        if (x\
    \ != \"\")\n        {\n            lst_return[i] = x;\n        }\n    }\n    return\
    \ lst_return;\n}", "{\n    int i;\n    string[] sorted_list;\n    sorted_list\
    \ = lst;\n    int len = lst.length;\n    foreach(i, j; sorted_list)\n    {\n \
    \       //sorted_list[i] = lst[j];\n    }\n    return sorted_list;\n}", "{\n \
    \   //byte[] temp;\n    string[] temp2;\n    auto temp3 = immutable(sort(temp2));\n\
    \    //return sort(temp2);\n    return temp3;\n}", "{\n    struct word_length\
    \ {\n        int length;\n        string word;\n    }\n    bool less_than(word_length\
    \ a, word_length b) \n    {\n        return (a.length < b.length || (a.length\
    \ == b.length && a.word < b.word));\n    }\n    return map!(x => x.word)(filter!(x\
    \ => x.length % 2 == 0)(sort!less_than(map!(y => word_length(y.length, y))(lst))));\n\
    }", "{\n    int[] len=lst.map!(a=>a.length).array;\n    int[] odd_index= len.indexWhere!(a=>a%2!=0).array;\n\
    \    return lst.removeAt(odd_index).sort;\n}", "{\n    int[] lengths;\n    int\
    \ i, j;\n    int[] sort_index;\n    string[] result;\n    lengths = new int[$];\n\
    \    i = 0;\n    while (i < lst.length) {\n        lengths[i] = lst[i].length;\n\
    \        i = i + 1;\n    }\n    sort_index = sort(lengths);\n    result = new\
    \ string[$];\n    j = 0;\n    i = 0;\n    while (i < sort_index.length) {\n  \
    \      if (sort_index[i] % 2 == 0) {\n            result[j] = lst[sort_index[i]];\n\
    \            j = j + 1;\n        }\n        i = i + 1;\n    }\n    return result;\n\
    }"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
