name: HumanEval_72_will_it_fly
language: d
results:
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n    The object\
    \ q will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1,\
    \ 2], 5) \u279E False \n    # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u279E False\n    # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2,\
    \ 3], 9) \u279E True\n    # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n\n    will_it_fly([3], 5) \u279E True\n    # 3 is less than\
    \ the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[]\
    \ q, long w) \n{\n    long[] palinQ = q;\n    int qLen = q.length;\n    long qSum\
    \ = 0;\n    long wMin = w - qLen;\n    for (auto el : q) {\n        qSum += el;\n\
    \    }\n    if (qSum > w || !isPalindrome(palinQ)) {\n        return false;\n\
    \    }\n    else {\n        if (qSum > wMin) {\n            return false;\n  \
    \      }\n        else {\n            return true;\n        }\n    }\n}\nunittest\n\
    {\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L)\
    \ == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L],\
    \ 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L,\
    \ 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppusnectd.d(28): Error: no identifier for declarator `el`\\n/tmp/tmppusnectd.d(28):\
    \ Error: expression expected, not `:`\\n/tmp/tmppusnectd.d(28): Error: found `q`\
    \ when expecting `;` following `for` condition\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmppusnectd.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n    The object\
    \ q will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1,\
    \ 2], 5) \u279E False \n    # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u279E False\n    # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2,\
    \ 3], 9) \u279E True\n    # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n\n    will_it_fly([3], 5) \u279E True\n    # 3 is less than\
    \ the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[]\
    \ q, long w) \n{\n    long sum = 0;\n    foreach(x; q)\n    {\n        sum +=\
    \ x;\n    }\n    bool balanced = true;\n    for(int i = 0; i < q.length / 2; i++)\n\
    \    {\n        if(q[i] != q[q.length - i - 1])\n        {\n            balanced\
    \ = false;\n            break;\n        }\n    }\n    return balanced && sum <=\
    \ w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L,\
    \ 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L],\
    \ 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L,\
    \ 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n    The object\
    \ q will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1,\
    \ 2], 5) \u279E False \n    # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u279E False\n    # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2,\
    \ 3], 9) \u279E True\n    # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n\n    will_it_fly([3], 5) \u279E True\n    # 3 is less than\
    \ the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[]\
    \ q, long w) \n{\n    return sum(q) <= w && q.equal(q.dup.reverse);\n}\nunittest\n\
    {\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L)\
    \ == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L],\
    \ 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L,\
    \ 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvqyl_36l.d(24): Error: undefined identifier `sum`\\n/tmp/tmpvqyl_36l.d(24):\
    \ Error: no property `equal` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpvqyl_36l.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n    The object\
    \ q will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1,\
    \ 2], 5) \u279E False \n    # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u279E False\n    # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2,\
    \ 3], 9) \u279E True\n    # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n\n    will_it_fly([3], 5) \u279E True\n    # 3 is less than\
    \ the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[]\
    \ q, long w) \n{\n    long sum = 0;\n    long len = q.length;\n    for (long i\
    \ = 0; i < len; i++)\n    {\n        sum += q[i];\n    }\n    if (sum > w)\n \
    \   {\n        return false;\n    }\n    else\n    {\n        for (long i = 0;\
    \ i < len / 2; i++)\n        {\n            if (q[i] != q[len - i - 1])\n    \
    \        {\n                return false;\n            }\n        }\n        return\
    \ true;\n    }\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L,\
    \ 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L],\
    \ 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L,\
    \ 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n    The object\
    \ q will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1,\
    \ 2], 5) \u279E False \n    # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u279E False\n    # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2,\
    \ 3], 9) \u279E True\n    # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n\n    will_it_fly([3], 5) \u279E True\n    # 3 is less than\
    \ the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[]\
    \ q, long w) \n{\n    auto len = q.length;\n    for (auto i = 0; i < len / 2;\
    \ i++) \n    {\n        if (q[i] != q[len - i - 1]) \n        {\n            return\
    \ false;\n        }\n    }\n    if (reduce!((a, b) => a + b)(q) > w) \n    {\n\
    \        return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate\
    \ = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L,\
    \ 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L,\
    \ 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n\
    \    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpn_84hd9k.d(32): Error: template instance `reduce!((a, b) => a\
    \ + b)` template `reduce` is not defined\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpn_84hd9k.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n    The object\
    \ q will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1,\
    \ 2], 5) \u279E False \n    # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u279E False\n    # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2,\
    \ 3], 9) \u279E True\n    # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n\n    will_it_fly([3], 5) \u279E True\n    # 3 is less than\
    \ the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[]\
    \ q, long w) \n{\n    long sum = 0;\n    auto d = q.dup;\n    foreach(x; q) \n\
    \    {\n        sum += x;\n        d.popFront();\n    }\n    foreach(x; d) \n\
    \    {\n        sum -= x;\n    }\n    if(sum <= w && q.length % 2 == 0) \n   \
    \ {\n        return true;\n    }\n    else \n    {\n        return false;\n  \
    \  }\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L,\
    \ 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L],\
    \ 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L,\
    \ 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpe264foca.d(29): Error: no property `popFront` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe264foca.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n    The object\
    \ q will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1,\
    \ 2], 5) \u279E False \n    # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u279E False\n    # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2,\
    \ 3], 9) \u279E True\n    # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n\n    will_it_fly([3], 5) \u279E True\n    # 3 is less than\
    \ the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[]\
    \ q, long w) \n{\n    long sum = 0;\n    for(long i = 0; i < q.length; i++)\n\
    \    {\n        sum += q[i];\n    }\n    if(sum > w) return false;\n    if(q.length\
    \ <= 2) return true;\n    auto dif = q.length;\n    while(dif >= 2)\n    {\n \
    \       long sum1 = 0;\n        long sum2 = 0;\n        for(long i = 0; i < dif;\
    \ i++)\n        {\n            sum1 += q[i];\n            sum2 += q[q.length -\
    \ 1 - i];\n        }\n        if(sum1 == sum2)\n        {\n            return\
    \ true;\n        }\n        dif -= 1;\n    }\n    return false;\n}\nunittest\n\
    {\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L)\
    \ == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L],\
    \ 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L,\
    \ 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpabrt8mq_.d(54): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428255]\\n??:? void tmpabrt8mq_.__unittest_L49_C1()\
    \ [0x427ea4]\\n??:? void tmpabrt8mq_.__modtest() [0x427fd4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c2b3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b146]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4302d9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430788]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430265]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b11d]\\n??:? runModuleUnitTests [0x42c089]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428718]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42869f]\\n??:? _d_run_main [0x42860a]\\n??:? main [0x427fe7]\\\
    n??:? __libc_start_main [0xc5ef0554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n    The object\
    \ q will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1,\
    \ 2], 5) \u279E False \n    # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u279E False\n    # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2,\
    \ 3], 9) \u279E True\n    # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n\n    will_it_fly([3], 5) \u279E True\n    # 3 is less than\
    \ the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[]\
    \ q, long w) \n{\n    bool isPali = false;\n    long sum = 0;\n    int size =\
    \ q.length;\n    for(int i = 0; i < size; i++)\n    {\n        sum += q[i];\n\
    \    }\n    if(sum <= w)\n    {\n        for(int i = 0; i < size; i++)\n     \
    \   {\n            if(q[i] == q[size - i - 1])\n            {\n              \
    \  isPali = true;\n            }\n            else\n            {\n          \
    \      isPali = false;\n                break;\n            }\n        }\n   \
    \ }\n    return isPali;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n\
    \    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L],\
    \ 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L,\
    \ 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n\
    \    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpu_sjrcvr.d(26): Error: cannot implicitly convert expression `q.length`\
    \ of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpu_sjrcvr.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n    The object\
    \ q will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1,\
    \ 2], 5) \u279E False \n    # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u279E False\n    # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2,\
    \ 3], 9) \u279E True\n    # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n\n    will_it_fly([3], 5) \u279E True\n    # 3 is less than\
    \ the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[]\
    \ q, long w) \n{\n    auto rev = q.dup.reverse;\n    if (q.front == rev.front)\n\
    \    {\n        auto sum = q.sum;\n        if (sum > w)\n        {\n         \
    \   return false;\n        }\n        else\n        {\n            return true;\n\
    \        }\n    }\n    else\n    {\n        return false;\n    }\n}\nunittest\n\
    {\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L)\
    \ == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L],\
    \ 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L,\
    \ 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfq5t8dkt.d(24): Error: template `std.typecons.reverse` cannot\
    \ deduce function from argument types `!()(long[])`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\n/tmp/tmpfq5t8dkt.d(25):\
    \ Error: no property `front` for type `long[]`\\n/tmp/tmpfq5t8dkt.d(27): Error:\
    \ no property `sum` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpfq5t8dkt.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n    The object\
    \ q will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1,\
    \ 2], 5) \u279E False \n    # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u279E False\n    # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2,\
    \ 3], 9) \u279E True\n    # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n\n    will_it_fly([3], 5) \u279E True\n    # 3 is less than\
    \ the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[]\
    \ q, long w) \n{\n    long sum = 0;\n    foreach(d; q)\n    {\n        sum +=\
    \ d;\n    }\n    long r = 0;\n    foreach(p; reverse(q))\n    {\n        r +=\
    \ p;\n    }\n    if(sum <= w && r == sum)\n    {\n        return true;\n    }\n\
    \    return false;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n   \
    \ assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L],\
    \ 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L,\
    \ 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n\
    \    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1rv9l324.d(30): Error: template `std.typecons.reverse` cannot\
    \ deduce function from argument types `!()(long[])`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmp1rv9l324.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n    The object\
    \ q will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1,\
    \ 2], 5) \u279E False \n    # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u279E False\n    # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2,\
    \ 3], 9) \u279E True\n    # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n\n    will_it_fly([3], 5) \u279E True\n    # 3 is less than\
    \ the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[]\
    \ q, long w) \n{\n    long sum = q.sum();\n    bool itWillFly = true;\n    if(sum\
    \ <= w)\n    {\n        for(int i = 0; i < q.length; i++)\n        {\n       \
    \     if(q[i] != q[q.length - i - 1])\n            {\n                itWillFly\
    \ = false;\n                break;\n            }\n        }\n    }\n    else\n\
    \    {\n        itWillFly = false;\n    }\n    return itWillFly;\n}\nunittest\n\
    {\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L)\
    \ == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L],\
    \ 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L,\
    \ 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpy8gpzihx.d(24): Error: no property `sum` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy8gpzihx.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n    The object\
    \ q will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1,\
    \ 2], 5) \u279E False \n    # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u279E False\n    # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2,\
    \ 3], 9) \u279E True\n    # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n\n    will_it_fly([3], 5) \u279E True\n    # 3 is less than\
    \ the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[]\
    \ q, long w) \n{\n\treturn (w >= sum(q) && q == q.dup.reverse);\n}\nunittest\n\
    {\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L)\
    \ == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L],\
    \ 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L,\
    \ 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpybkby4x5.d(24): Error: undefined identifier `sum`\\n/tmp/tmpybkby4x5.d(24):\
    \ Error: template `std.typecons.reverse` cannot deduce function from argument\
    \ types `!()(long[])`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmpybkby4x5.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n    The object\
    \ q will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1,\
    \ 2], 5) \u279E False \n    # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u279E False\n    # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2,\
    \ 3], 9) \u279E True\n    # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n\n    will_it_fly([3], 5) \u279E True\n    # 3 is less than\
    \ the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[]\
    \ q, long w) \n{\n    w = w * 10;\n    long sum = 0;\n    bool isPalindrome =\
    \ true;\n    for (long x : q)\n    {\n        sum += x;\n    }\n    for (int x\
    \ = 0; x < q.length / 2; x++)\n    {\n        if (q[x] != q[q.length - x - 1])\n\
    \        {\n            isPalindrome = false;\n        }\n    }\n    return isPalindrome\
    \ && sum <= w;\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L,\
    \ 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L],\
    \ 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L,\
    \ 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpx92bizq1.d(27): Error: semicolon expected, not `:`\\n/tmp/tmpx92bizq1.d(27):\
    \ Error: expression expected, not `:`\\n/tmp/tmpx92bizq1.d(27): Error: found `q`\
    \ when expecting `;` following `for` condition\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpx92bizq1.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n    The object\
    \ q will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1,\
    \ 2], 5) \u279E False \n    # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u279E False\n    # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2,\
    \ 3], 9) \u279E True\n    # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n\n    will_it_fly([3], 5) \u279E True\n    # 3 is less than\
    \ the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[]\
    \ q, long w) \n{\n    long sum = 0;\n    foreach(i; q)\n    {\n        sum +=\
    \ i;\n    }\n    if(sum <= w)\n    {\n        long[] temp = q.dup;\n        q.reverse;\n\
    \        return (temp == q) ? true : false;\n    }\n    return false;\n}\nunittest\n\
    {\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L)\
    \ == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L],\
    \ 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L,\
    \ 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptgcatqfv.d(32): Error: template `std.typecons.reverse` cannot\
    \ deduce function from argument types `!()(long[])`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmptgcatqfv.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n    The object\
    \ q will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1,\
    \ 2], 5) \u279E False \n    # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u279E False\n    # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2,\
    \ 3], 9) \u279E True\n    # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n\n    will_it_fly([3], 5) \u279E True\n    # 3 is less than\
    \ the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[]\
    \ q, long w) \n{\n    long sum = 0;\n    foreach(num; q)\n    {\n        sum +=\
    \ num;\n    }\n    if(sum > w) return false;\n    foreach(num; q)\n    {\n   \
    \     if(num == q[$-1]) return true;\n        q = q[1..$-1];\n    }\n    return\
    \ false;\n}\n// function will_it_fly(q, w) {\n// \tlet sum = q.reduce((a, b) =>\
    \ a + b, 0);\n// \treturn (sum <= w && q.toString() == q.reverse().toString());\n\
    // }\n// function will_it_fly(q, w) {\n// \treturn q.reduce((a, b) => a + b, 0)\
    \ <= w && q.reverse().join('') == q.join('');\n// }\n// function will_it_fly(q,\
    \ w) {\n//     if(q.reduce((a,b)=>a+b,0) <= w){\n//       var slice = q.slice();\n\
    //       var rev = q.slice().reverse();\n//       return slice.toString() == rev.toString();\n\
    //     }\n//     return false;\n// }\n// function will_it_fly(q, w) {\n// \tlet\
    \ sum = q.reduce((a, b) => a + b, 0);\n// \tlet reversed = q.map(x => x).reverse();\n\
    // \treturn (sum <= w && q.toString() == reversed.toString());\n// }\n// function\
    \ will_it_fly(q, w) {\n// \treturn (q.reduce((a,b)=>a+b,0) <= w && q.join('')\
    \ == q.reverse().join(''));\n// }\n// function will_it_fly(q, w) {\n// \tlet sum\
    \ = q.reduce((a, b) => a + b, 0);\n// \tlet reversed = q.map(x => x).reverse();\n\
    // \treturn (sum <= w && q.toString() == reversed.toString());\n// }\nunittest\n\
    {\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L)\
    \ == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L],\
    \ 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L,\
    \ 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.RangeError@/tmp/tmp98w1b1ja.d(32): Range violation\\n----------------\\\
    n??:? _d_arrayboundsp [0x42830e]\\n??:? bool tmp98w1b1ja.will_it_fly(long[], long)\
    \ [0x427da8]\\n??:? void tmp98w1b1ja.__unittest_L65_C1() [0x427e9b]\\n??:? void\
    \ tmp98w1b1ja.__modtest() [0x427fe0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c2bb]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b14e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4302e1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43026d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b125]\\n??:? runModuleUnitTests [0x42c091]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428720]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4286a7]\\n??:? _d_run_main [0x428612]\\n??:? main [0x427ff3]\\\
    n??:? __libc_start_main [0xc8f64554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n    The object\
    \ q will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1,\
    \ 2], 5) \u279E False \n    # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u279E False\n    # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2,\
    \ 3], 9) \u279E True\n    # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n\n    will_it_fly([3], 5) \u279E True\n    # 3 is less than\
    \ the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[]\
    \ q, long w) \n{\n\t// Use q.dup to duplicate the array and then use q.reverse\
    \ to reverse the array\n\t// then use == to check if the two arrays are equal\n\
    \tauto first = q.dup;\n\tauto second = q.reverse;\n\tauto balanced = first ==\
    \ second;\n\t\n\t//Use std.math.sum to sum the elements of the array, then use\
    \ <= to check if the sum is less than or equal to the weight\n\tauto sum = sum(q);\n\
    \tauto weight = sum <= w;\n\t\n\treturn (balanced && weight);\n}\nunittest\n{\n\
    \    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L)\
    \ == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L],\
    \ 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L,\
    \ 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4m7qxp1g.d(27): Error: template `std.typecons.reverse` cannot\
    \ deduce function from argument types `!()(long[])`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\n/tmp/tmp4m7qxp1g.d(31):\
    \ Error: undefined identifier `sum`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp4m7qxp1g.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n    The object\
    \ q will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1,\
    \ 2], 5) \u279E False \n    # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u279E False\n    # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2,\
    \ 3], 9) \u279E True\n    # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n\n    will_it_fly([3], 5) \u279E True\n    # 3 is less than\
    \ the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[]\
    \ q, long w) \n{\n    bool result = true;\n    long sum = 0;\n    foreach(i; q)\
    \ sum += i;\n    if(sum > w) result = false;\n    else\n    {\n        long midPoint\
    \ = (q.length % 2 == 0) ? q.length / 2 : (q.length + 1) / 2;\n        foreach(i;\
    \ 0..midPoint)\n        {\n            if(q[i] != q[q.length - i - 1])\n     \
    \       {\n                result = false;\n                break;\n         \
    \   }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L,\
    \ 2L], 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L,\
    \ 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n\
    \    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n    The object\
    \ q will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1,\
    \ 2], 5) \u279E False \n    # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u279E False\n    # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2,\
    \ 3], 9) \u279E True\n    # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n\n    will_it_fly([3], 5) \u279E True\n    # 3 is less than\
    \ the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[]\
    \ q, long w) \n{\n\treturn q.length > 1 && sum(q) > w ? false : q.length == 1\
    \ || palindrome(q);\n}\nunittest\n{\n    alias candidate = will_it_fly;\n\n  \
    \  assert(candidate([3L, 2L, 3L], 9L) == true);\n    assert(candidate([1L, 2L],\
    \ 5L) == false);\n    assert(candidate([3L], 5L) == true);\n    assert(candidate([3L,\
    \ 2L, 3L], 1L) == false);\n    assert(candidate([1L, 2L, 3L], 6L) == false);\n\
    \    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpygus8ijk.d(24): Error: undefined identifier `sum`\\n/tmp/tmpygus8ijk.d(24):\
    \ Error: undefined identifier `palindrome`\\nFailed: [\"dmd\", \"-unittest\",\
    \ \"-v\", \"-o-\", \"/tmp/tmpygus8ijk.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n    The object\
    \ q will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1,\
    \ 2], 5) \u279E False \n    # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u279E False\n    # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2,\
    \ 3], 9) \u279E True\n    # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n\n    will_it_fly([3], 5) \u279E True\n    # 3 is less than\
    \ the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[]\
    \ q, long w) \n{\n    long sum = 0;\n    foreach(item; q)\n    {\n        sum\
    \ += item;\n    }\n    return (sum <= w) && isPalindrome(q);\n}\nunittest\n{\n\
    \    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L)\
    \ == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L],\
    \ 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L,\
    \ 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxsep7k64.d(29): Error: undefined identifier `isPalindrome`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxsep7k64.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n    The object\
    \ q will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1,\
    \ 2], 5) \u279E False \n    # 1+2 is less than the maximum possible weight, but\
    \ it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u279E False\n    # it's balanced,\
    \ but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2,\
    \ 3], 9) \u279E True\n    # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n\n    will_it_fly([3], 5) \u279E True\n    # 3 is less than\
    \ the maximum possible weight, and it's balanced.\n    \n*/\nbool will_it_fly(long[]\
    \ q, long w) \n{\n    w *= 2;\n    int n = q.length;\n    long sum = 0;\n    foreach(x;\
    \ q)\n        sum += x;\n    if(sum > w)\n        return false;\n    if(sum.to!double\
    \ / n <= max(q).to!double)\n        return true;\n    return false;\n}\nunittest\n\
    {\n    alias candidate = will_it_fly;\n\n    assert(candidate([3L, 2L, 3L], 9L)\
    \ == true);\n    assert(candidate([1L, 2L], 5L) == false);\n    assert(candidate([3L],\
    \ 5L) == true);\n    assert(candidate([3L, 2L, 3L], 1L) == false);\n    assert(candidate([1L,\
    \ 2L, 3L], 6L) == false);\n    assert(candidate([5L], 5L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp457zmen1.d(25): Error: cannot implicitly convert expression `q.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp457zmen1.d(31): Error: no property `to` for\
    \ type `long`\\n/tmp/tmp457zmen1.d(31): Error: undefined identifier `max`, did\
    \ you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp457zmen1.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
