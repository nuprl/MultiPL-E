name: HumanEval_44_change_base
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\nChange numerical base of input\
  \ number x to base.\n    return string representation after the conversion.\n  \
  \  base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>>\
  \ change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \n*/\n\
  string change_base(long x, long base) \n"
tests: "unittest\n{\n    alias candidate = change_base;\n\n    assert(candidate(8L,\
  \ 3L) == \"22\");\n    assert(candidate(9L, 3L) == \"100\");\n    assert(candidate(234L,\
  \ 2L) == \"11101010\");\n    assert(candidate(16L, 2L) == \"10000\");\n    assert(candidate(8L,\
  \ 2L) == \"1000\");\n    assert(candidate(7L, 2L) == \"111\");\n    assert(candidate(2L,\
  \ 3L) == \"2\");\n    assert(candidate(3L, 4L) == \"3\");\n    assert(candidate(4L,\
  \ 5L) == \"4\");\n    assert(candidate(5L, 6L) == \"5\");\n    assert(candidate(6L,\
  \ 7L) == \"6\");\n    assert(candidate(7L, 8L) == \"7\");\n}\nvoid main(){}"
completions: ["{\n    static immutable char[] lut = [ '0', '1', '2', '3', '4', '5',\
    \ '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' ];\n    enum hex = 16;\n  \
    \  long temp;\n    string result;\n    while (x != 0) \n    {\n        temp =\
    \ x % base;\n        result ~= lut[temp];\n        x /= base;\n    }\n    return\
    \ result.reverse;\n}", "{\n    string digits = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    ;", "{\n\tstring res = \"\";\n\tfor (; x; x /= base)\n\t\tres = x % base ~ res;\n\
    \treturn res;\n}", "{\n  string result = \"\";\n  for (; x; x /= base) \n  {\n\
    \    result = to!string(x % base) ~ result;\n  }\n  return result;\n}", "{\n \
    \   string s = \"\";\n    while (x != 0) \n    {\n        s = (char)(x % base\
    \ + '0') + s;\n        x /= base;\n    }\n    return s;\n}\n//template v(T)\n\
    //{\n//    import std.typecons;\n//    alias int v = T.sizeof;\n//}", "{\n   \
    \ string result = \"\";\n    static immutable std.string.UnsafeDigits digs = std.string.UnsafeDigits(2,\
    \ \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n    while (x != 0) {\n        result\
    \ = digs[x % base] ~ result;\n        x /= base;\n    }\n    return result;\n\
    }\n/*\nGiven a prime number, the prime sum can be calculated by adding the prime\
    \ number to the \nsum of all the numbers that divide it evenly except itself.",
  "{\n    assert(base >= 2 && base <= 10);\n    assert(x >= 0);\n    string s = \"\
    \";\n    while (x) {\n        s += to!string(x % base);\n        x /= base;\n\
    \    }\n    return s.reverse;\n}", "{\n    string result = \"\";\n    while (x\
    \ >= base) {\n        auto digit = cast(char)('0' + x % base);\n        x /= base;\n\
    \        result = digit ~ result;\n    }\n    result = cast(char)('0' + x) ~ result;\n\
    \    return result;\n}", "{\n    string ans = \"\";\n    while (x) {\n       \
    \ ans = dchar(x % base) ~ ans;\n        x /= base;\n    }\n    return ans;\n}",
  "{\n    static string digits = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    string\
    \ temp;\n    while (x) \n    {\n        temp ~= digits[x % base];\n        x /=\
    \ base;\n    }\n    temp = temp.reverse;\n    return temp;\n}\n/*\nChange num\
    \ to given base.\n    num is string.\n    return string representation after the\
    \ conversion.\n    base number is more than 10.\n    >>> change_base(\"1\", 20)\n\
    \    '1'\n    >>> change_base(\"11\", 20)\n    'B'\n    >>> change_base(\"111\"\
    , 20)\n    '2B'\n    >>> change_base(\"11111\", 20)\n    'LF'\n    >>> change_base(\"\
    1111111\", 20)\n    '1BP'\n    >>> change_base(\"11111111\", 20)\n    '3PP'\n\
    */\nstring change_base(string num, long base) \n{\n    static string digits =\
    \ \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    long x = 0;\n    foreach (c;\
    \ num) \n    {\n        x = x * base + digits.indexOf(c);\n    }\n    return change_base(x,\
    \ base);\n}\n/*\nGet the number of digits in base 10.\n    number is string.\n\
    \    return number of digits.\n    >>> get_num_of_digits(\"1\")\n    1\n    >>>\
    \ get_num_of_digits(\"123456789\")\n    9\n    >>> get_num_of_digits(\"111111111111111111111111111111111111111111111111111111111111111111111111111111111111\"\
    )\n    831\n*/\nlong get_num_of_digits(string number) \n{\n    long digits = 0;\n\
    \    foreach (c; number) \n    {\n        ++digits;\n    }\n    return digits;\n\
    }\n/*\nChange number to base b.\n    number is tuple of base a, and string representation\
    \ of the number.\n    return tuple of base b, and string representation of the\
    \ number.\n    >>> change", "{\n    string out;\n    while (x) {\n        out\
    \ ~= to!string(x % base);\n        x /= base;\n    }\n    return out.reverse;\n\
    }\n/*\n    A simple basic class to calculate the number of\n    primes in a given\
    \ interval.", "{\n    string result;\n    while (x != 0) {\n        result ~=\
    \ x % base;\n        x /= base;\n    }\n    return result.reverse;\n}\n/*\nCalculate\
    \ the value of the polynomial.\n    p: polynomial.\n    x: value.\n    >>> poly_eval([1,\
    \ -2, 3], 2)\n    7\n    >>> poly_eval([1, -2, 3], 0)\n    1\n    >>> poly_eval([1,\
    \ -2, 3], 1)\n    0\n*/\nreal poly_eval(real[] p, real x)\n{\n    long n = p.length;\n\
    \    real y = 0;\n    for (int i = 0; i < n; i++) {\n        y += p[i] * x **\
    \ i;\n    }\n    return y;\n}\n/*\nCalculate the roots of the equation.\n    coeffs:\
    \ coefficient of the equation.\n    >>> poly_roots([1, 0, -1])\n    [-1, 1]\n\
    \    >>> poly_roots([1, -6, 9, -4])\n    [-1, 1, 2]\n    >>> poly_roots([1, 2,\
    \ 3])\n    [-1]\n*/\nreal[] poly_roots(real[] coeffs)\n{\n    real[] roots;\n\
    \    int n = coeffs.length;\n    real a = coeffs[n - 1];\n    real[][] m = [[a]];\n\
    \    for (int i = 1; i < n; i++) {\n        real b = coeffs[n - i - 1];\n    \
    \    real[][] M = [[b]];\n        M = [[b]];\n        for (int j = 0; j < i; j++)\
    \ {\n            real c = m[j][0];\n            real d = m[j][1];\n          \
    \  M ~= [c, d];\n        }\n        m = M;\n    }\n    real[][] Q, R;\n    Q,\
    \ R = qr_decomp(m);\n    Q, R = qr_decomp(R);\n    roots = r_roots(R);\n    return\
    \ roots;", "{\n    return to!string(x, base);\n}", "{\n    enum string digits\
    \ = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    string result = \"\";\n   \
    \ long remainder;\n    // special case\n    if (x == 0)\n        return \"0\"\
    ;\n    else\n    {\n        while (x != 0)\n        {\n            remainder =\
    \ x % base;\n            x /= base;\n            result = digits[remainder] ~\
    \ result;\n        }\n        return result;\n    }\n}", "{\n    // Convert x\
    \ to string representation.\n    // return string representation.\n    return\
    \ \"\";\n}\nunittest \n{\n    assert(change_base(8, 3) == \"22\");\n    assert(change_base(8,\
    \ 2) == \"1000\");\n    assert(change_base(7, 2) == \"111\");\n}\n \n/*\n    Change\
    \ all letters in string from lower case to upper case.\n    >>> upper(\"asdfqwerASDFqwer\"\
    )\n    'ASDFQWERASDFQWER'\n*/\nstring upper(string s) \n{\n    // Convert string\
    \ s to string representation.\n    // return string representation.\n    return\
    \ \"\";\n}\nunittest \n{\n    assert(upper(\"asdfqwerASDFqwer\") == \"ASDFQWERASDFQWER\"\
    );\n}\n \n/*\n    Implement quicksort function.\n    You must refer to the quicksort\
    \ algorithm shown in the lecture or slides.\n    In order to do that, you should\
    \ implement partition function first.\n    You can implement this function using\
    \ the quicksort algorithm or using the std.algorithm.sort().\n    *Note that you\
    \ cannot use built-in quicksort function in std.algorithm module.\n    >>> quicksort([2,\
    \ 4, 1, 5, 7, 3])\n    [1, 2, 3, 4, 5, 7]\n    >>> quicksort([1, 1, 1, 1, 1, 1])\n\
    \    [1, 1, 1, 1, 1, 1]\n    >>> quicksort([])\n    []\n*/\n// implement partition\
    \ function first", "{ \n    return x == 0 ? \"0\" : change_base(x/base, base)\
    \ ~ to!string(x%base); \n}\n/*\nInsert a digit at the specified location of num.\n\
    \    >>> insert(14, 2, 0)\n    140\n    >>> insert(14, 2, 1)\n    12\n    >>>\
    \ insert(14, 2, 2)\n    214\n    >>> insert(14, 2, 3)\n    1402\n    >>> insert(14,\
    \ 2, 4)\n    1402\n*/\nlong insert(long num, long digit, long location) \n{ \n\
    \    if (location <= 0) return num * 10 + digit; \n    if (location >= length(num))\
    \ return num * pow(10, location) + digit; \n    return num / pow(10, location)\
    \ * pow(10, location + 1) + digit * pow(10, location) + num % pow(10, location);\
    \ \n}\n/*\nConvert a string to a number.\n    >>> str_to_num(\"123\")\n    123\n\
    \    >>> str_to_num(\"-123\")\n    -123\n    >>> str_to_num(\"123\")\n    123\n\
    \    >>> str_to_num(\"-123\")\n    -123\n    >>> str_to_num(\"0000123\")\n   \
    \ 123\n    >>> str_to_num(\"-0000123\")\n    -123\n    >>> str_to_num(\"9223372036854775807\"\
    )\n    9223372036854775807\n    >>> str_to_num(\"-9223372036854775808\")\n   \
    \ -9223372036854775808\n    >>> str_to_num(\"9223372036854775808\")\n    9223372036854775808\n\
    \    >>> str_to_num(\"-9223372036854775809\")\n    -9223372036854775809\n*/\n\
    long str_to_num(string str) \n{ \n    long x = 0; \n    for (size_t i = 0; i <\
    \ str.length; i++) { \n        x = x * 10 + (str[i] - '0'); \n", "{ \n    string\
    \ str = \"\"; // Initialize result \n    // Convert input number is given base\
    \ by repeatedly dividing it by base and taking remainder \n    while (x > 0) \n\
    \    { \n        int rem = x % base; \n        char cur_char = '0' + rem;\n  \
    \      // cur_char += rem < 10 ? '0' : 'A' - 10; \n        str += cur_char; \n\
    \        x /= base; \n    } \n    return str.dreverse(); \n} ", "{\n    int[]\
    \ res = [];\n    while (x) \n    {\n        res.insert(0, x % base);\n       \
    \ x /= base;\n    }\n    return res.join;\n}\n/*\nChange numerical base of input\
    \ number x to base.\n    return tuple of [int, string].\n    base numbers are\
    \ greater than 10.\n    >>> change_base_nums(8, [1, 2, 3])\n    [1, '22']\n  \
    \  >>> change_base_nums(16, [1, 2, 3])\n    [3, '1B']\n    >>> change_base_nums(18,\
    \ [1, 2, 3])\n    [5, '1A']\n    >>> change_base_nums(18, [0, 1, 2, 3])\n    [5,\
    \ '1A']\n*/\ntuple!(ulong, string) change_base_nums(ulong x, ulong[] base) \n\
    {\n    ulong res = 0;\n    int[] s = [];\n    foreach (i, item; x.toString) \n\
    \    {\n        auto tmp = item.to!ulong;\n        res = (res * base.length) +\
    \ base[tmp];\n        s.insert(0, tmp);\n    }\n    return tuple(res, s.join);\n\
    }\n/*\nChange numerical base of input number x to base.\n    return string representation\
    \ after the conversion.\n    base numbers are greater than 10.\n    >>> change_base_nums(8,\
    \ [1, 2, 3])\n    '22'\n    >>> change_base_nums(16, [1, 2, 3])\n    '1B'\n  \
    \  >>> change_base_nums(18, [1, 2, 3])\n    '1A'\n    >>> change_base_nums(18,\
    \ [0, 1, 2, 3])\n    '1A'\n*/\nstring change_base_nums(ulong x, ulong[] base)\
    \ \n{\n    auto tmp = change_base_nums(x, base);\n    return tmp[1];\n}\n/*\n\
    Change base of input number to 2.\n    return string representation after the\
    \ conversion", "{\n    string res;\n    long new_x = x;\n    while (new_x) {\n\
    \        res = to!string(new_x % base) ~ res;\n        new_x /= base;\n    }\n\
    \    return res;\n}", "{\n    if (base > 10 || base < 2) \n    {\n        assert(0);\n\
    \    }\n    string res = new string();\n    while (x > 0) \n    {\n        res\
    \ ~= ('0' + (x % base));\n        x /= base;\n    }\n    std.algorithm.reverse(res);\n\
    \    return res;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
