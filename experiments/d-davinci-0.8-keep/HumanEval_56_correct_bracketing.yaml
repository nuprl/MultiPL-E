name: HumanEval_56_correct_bracketing
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n brackets is a string of \"<\"\
  \ and \">\".\n    return True if every opening bracket has a corresponding closing\
  \ bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"\
  <>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"\
  ><<>\")\n    False\n    \n*/\nbool correct_bracketing(string brackets) \n"
tests: "unittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
  <>\") == true);\n    assert(candidate(\"<<><>>\") == true);\n    assert(candidate(\"\
  <><><<><>><>\") == true);\n    assert(candidate(\"<><><<<><><>><>><<><><<>>>\")\
  \ == true);\n    assert(candidate(\"<<<><>>>>\") == false);\n    assert(candidate(\"\
  ><<>\") == false);\n    assert(candidate(\"<\") == false);\n    assert(candidate(\"\
  <<<<\") == false);\n    assert(candidate(\">\") == false);\n    assert(candidate(\"\
  <<>\") == false);\n    assert(candidate(\"<><><<><>><>><<>\") == false);\n    assert(candidate(\"\
  <><><<><>><>>><>\") == false);\n}\nvoid main(){}"
completions: ["{ \n//     int count = 0;\n//     for (int i = 0; i < brackets.length;\
    \ i++) {\n//         if (brackets[i] == '<')\n//             count++;\n//    \
    \     else\n//             count--;\n//         if (count < 0)\n//           \
    \  return false;\n//     }\n//     return count == 0;\n    int n = brackets.length;\n\
    \    if (n % 2 != 0)\n        return false;\n    else {\n        while (brackets.length\
    \ != 0) {\n            if (brackets.slice(0, 2) == \"><\")\n                brackets\
    \ = brackets.slice(2, n);\n            else\n                return false;\n \
    \       }\n        return true;\n    }\n}", "{\n    struct bracket \n    {\n \
    \       int position;\n        bool opening;\n    }\n    int length = brackets.length;\n\
    \    struct bracket[] bracket_stack = new struct bracket[length];\n    int stack_top\
    \ = 0;\n    for (int i = 0; i < length; i++) \n    {\n        if (brackets[i]\
    \ == '<') \n        {\n            struct bracket new_bracket = {i, true};\n \
    \           bracket_stack[stack_top] = new_bracket;\n            stack_top++;\n\
    \        } \n        else if (brackets[i] == '>') \n        {\n            if\
    \ (stack_top == 0) \n            {\n                return false;\n          \
    \  } \n            else \n            {\n                --stack_top;\n      \
    \      }\n        }\n    }\n    return stack_top == 0;\n}", "{\n    int depth\
    \ = 0;\n    foreach(char c; brackets) {\n        if (c == '<')\n            depth++;\n\
    \        else\n            depth--;\n        if (depth < 0)\n            return\
    \ false;\n    }\n    return depth == 0;\n}\n/*\n    Given a list of ints, return\
    \ the sum of the largest and smallest elements.", "{\n  double balance = 0;\n\
    \  foreach(ch; brackets) \n  {\n    if (ch == '<') \n    {\n      balance++;\n\
    \    } \n    else if (ch == '>') \n    {\n      balance--;\n    } \n    else \n\
    \    {\n      return false;\n    }\n    if (balance < 0) \n    {\n      return\
    \ false;\n    }\n  }\n  return balance == 0;\n}", "{\n    int balance = 0;\n \
    \   foreach(char ch;brackets) \n    {\n        if (ch == '<') \n        {\n  \
    \          balance++;\n        } \n        else if (ch == '>') \n        {\n \
    \           balance--;\n        }\n        else \n        {\n            return\
    \ false;\n        }\n        if (balance < 0) \n        {\n            return\
    \ false;\n        }\n    }\n    return (balance == 0);\n}", "{\n    double counter\
    \ = 0;\n    foreach(char c; brackets)\n    {\n        if(c == '<')\n         \
    \   counter++;\n        else\n            counter--;\n        if(counter < 0)\n\
    \            return false;\n    }\n    return counter == 0;\n}\nunittest\n{\n\
    \    assert(correct_bracketing(\"<\") == false);\n    assert(correct_bracketing(\"\
    <>\") == true);\n    assert(correct_bracketing(\"<<><>>\") == true);\n    assert(correct_bracketing(\"\
    ><<>\") == false);\n}\n/*\nreturn a new string in which:", "{\n    int depth =\
    \ 0;\n    foreach(ch; brackets) {\n        if (ch == '<') {\n            depth++;\n\
    \        } else {\n            depth--;\n        }\n        if (depth < 0) {\n\
    \            return false;\n        }\n    }\n    return depth == 0;\n}", "{\n\
    \tif (brackets.length == 0)\n\t\treturn true;\n\tint open_found = 0;\n\tint closed_found\
    \ = 0;\n\tforeach (bracket; brackets)\n\t{\n\t\tif (bracket == '<')\n\t\t\topen_found++;\n\
    \t\telse\n\t\t\tclosed_found++;\n\t\tif (closed_found > open_found)\n\t\t\treturn\
    \ false;\n\t}\n\treturn open_found == closed_found;\n}", "{\n    const int n =\
    \ brackets.length;\n    int i, j;\n    int i_max = n;\n    //int j_max = n;\n\
    \    int j_min = 0;\n    int [int] counts;\n    if(n == 0)\n        return true;\n\
    \    /*\n    if(n == 1)\n    {\n        if(brackets[0] == '<')\n            return\
    \ false;\n        else\n            return true;\n    }\n    */\n    for(i = 0;\
    \ i < n; i++)\n    {\n        counts[i] = 0;\n        if(brackets[i] == '<')\n\
    \            counts[i] = 1;\n        else\n            counts[i] = -1;\n    }\n\
    \    for(i = 1; i < n; i++)\n    {\n        counts[i] += counts[i-1];\n    }\n\
    \    /*\n    for(i = 0; i < n; i++)\n    {\n        writeln(counts[i]);\n    }\n\
    \    */\n    int index = std.algorithm.lower_bound(counts, -1);\n    //writeln(index);\n\
    \    if(index == n)\n        return true;\n    else\n        return false;\n}",
  "{\n    //if(brackets.length < 2) return false;\n    int count = 0;\n    foreach(char\
    \ c; brackets)\n    {\n        if(c == '<') count++;\n        else count--;\n\
    \        if(count < 0) return false;\n    }\n    return count == 0;\n}", "{\n\
    \    int[] vector = new int[brackets.length];\n    int i = 0;\n    foreach(char\
    \ ch; brackets)\n    {\n        if(ch == '<')\n        {\n            vector[i]\
    \ = 1;\n            i++;\n        }\n        else if(ch == '>')\n        {\n \
    \           if(i != 0)\n            {\n                vector[i-1] = -1;\n   \
    \             i--;\n            }\n            else\n            {\n         \
    \       return false;\n            }\n        }\n    }\n    foreach(ch; vector)\n\
    \    {\n        if(ch != -1)\n        {\n            return false;\n        }\n\
    \    }\n    return true;\n}", "{\n    int count = 0;\n    foreach(ch; brackets)\
    \ \n    {\n        if (ch == '<') \n        {\n            count++;\n        }\n\
    \        else if (ch == '>') \n        {\n            count--;\n        }\n  \
    \      if (count < 0) \n        {\n            return false;\n        }\n    }\n\
    \    return count == 0;\n}\n/*\n    o returns the opposite boolean value of o\n\
    \    >>> opposite(True)\n    False\n    >>> opposite(False)\n    True\n    >>>\
    \ opposite(1)\n    False\n    >>> opposite(0)\n    True\n*/", "{\n    if (brackets.length\
    \ < 1) \n        return true;", "{\n    int a = 0;\n    int b = 0;\n    foreach(char\
    \ c; brackets) \n    {\n        if (c == '<') a += 1;\n        else if (c == '>')\
    \ b += 1;\n        if (b > a) return false;\n    }\n    return a == b;\n}\n/*\n\
    \    return tuple of string positions of matching brackets in brackets.", "{\n\
    \    int count=0;\n    foreach(c;brackets)\n    {\n        if(c=='>')\n      \
    \  {\n            count--;\n        }\n        else\n        {\n            count++;\n\
    \        }\n        if(count<0)\n        {\n            return false;\n      \
    \  }\n    }\n    return count==0;\n}", "{\n    int x = 0;\n    foreach(c; brackets)\
    \ \n    {\n        if (c == '<')\n            x++;\n        else if (c == '>')\n\
    \            x--;\n        if (x < 0)\n            return false;\n    }\n    return\
    \ x == 0;\n}\n/*\n    >>> simplify(typeid(int))\n    int\n    >>> simplify(typeid(int*))\n\
    \    int*\n    >>> simplify(typeid(int[5]))\n    int[]\n    >>> simplify(typeid(int[5][]))\n\
    \    int[][]\n    >>> simplify(typeid(int[5][4]))\n    int[][]\n    >>> simplify(typeid(int[]))\n\
    \    int[]\n    >>> simplify(typeid(int[][]))\n    int[][]\n    >>> simplify(typeid(int[][][]))\n\
    \    int[][][]\n    >>> simplify(typeid(int[][][][]))\n    int[][][][]\n    >>>\
    \ simplify(typeid(int[][][][][]))\n    int[][][][][]\n    >>> simplify(typeid(int[][][][][][]))\n\
    \    int[][][][][][]\n    >>> simplify(typeid(int[][][][][][][]))\n    int[][][][][][][]\n\
    \    >>> simplify(typeid(int[][][][][][][][]))\n    int[][][][][][][][]\n    >>>\
    \ simplify(typeid(int[][][][][][][][][]))\n    int[][][][][][][][][]\n    >>>\
    \ simplify(typeid(int[][][][][][][][][][]))\n    int[][][][][][][][][][]\n   \
    \ >>> simplify(typeid(int[][][][][][][][][][][]))\n    int[][][][][][][][][][][]\n\
    \    >>> simplify(typeid(int[][][][][][][][][][][][]))\n    int[][][][][][][][][][][][]\n\
    \    >>> simplify(typeid(int[][][][][][", "{\n    bool result = true;\n    int\
    \ leftBracket = 0;\n    foreach(char ch; brackets) {\n        switch(ch) {\n \
    \           case '<':\n                leftBracket++;\n                break;\n\
    \            case '>':\n                if(leftBracket <= 0) {\n             \
    \       result = false;\n                    break;\n                }\n     \
    \           leftBracket--;\n                break;\n        }\n    }\n    if(leftBracket\
    \ != 0) result = false;\n    return result;\n}", "{\n    uint bracket_number =\
    \ 0;\n    foreach(bracket; brackets)\n    {\n        if(bracket == '<') \n   \
    \     {\n            bracket_number++;\n        }\n        else if(bracket ==\
    \ '>')\n        {\n            if(bracket_number <= 0) \n            {\n     \
    \           return false;\n            }\n            bracket_number--;\n    \
    \    }\n    }\n    return bracket_number == 0;\n}", "{\n    if(brackets == \"\"\
    )\n        return true;\n    \n    if(brackets.length <= 1)\n        return false;\n\
    \    \n    int n = 0;\n    foreach(c; brackets)\n    {\n        if(c == '<')\n\
    \            n++;\n        else if(c == '>')\n            n--;\n    }\n    return\
    \ n == 0;\n}", "{ \n    int open = 0;\n    foreach(char c;brackets)\n    {\n \
    \       if(c == '<')\n            open++;\n        else if(c == '>')\n       \
    \     open--;\n        if(open < 0)\n            return false;\n    }\n    return\
    \ open == 0;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
