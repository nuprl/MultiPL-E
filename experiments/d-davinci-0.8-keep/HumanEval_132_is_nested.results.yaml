name: HumanEval_132_is_nested
language: d
results:
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    // Create a deque to store\n    // brackets in.\n    Deque!char bracket;\n\
    \    // Create an int to store\n    // the number of brackets.\n    int bracket_count\
    \ = 0;\n    // Create an int to store\n    // the number of nested brackets.\n\
    \    int nested_bracket_count = 0;\n    // Iterate over each char\n    // in the\
    \ string.\n    foreach(char c; string)\n    {\n        // Increase bracket_count\n\
    \        // every time we encounter a bracket.\n        if(c == '[' || c == ']')\n\
    \        {\n            // If we have an open bracket,\n            // push to\
    \ the front of the deque.\n            if(c == '[')\n            {\n         \
    \       bracket.pushFront(c);\n            }\n            // If we have a closed\
    \ bracket,\n            // push to the back of the deque.\n            else\n\
    \            {\n                bracket.pushBack(c);\n            }\n        \
    \    bracket_count++;\n        }\n    }\n    // If the bracket_count is odd,\n\
    \    // it will never be possible\n    // to have nested brackets.\n    if(bracket_count\
    \ % 2 != 0)\n    {\n        return false;\n    }\n    // Iterate over each char\n\
    \    // in the deque.\n    foreach(char c; bracket)\n    {\n        // Check if\
    \ the current char\n        // is a closed bracket.\n        if(c == ']')\n  \
    \      {\n            // If it is, loop until\n            // we find an open\
    \ bracket.\n            while(bracket.front != '[')\n            {\n         \
    \       // If we reach the back\n                // of the deque, there is\n \
    \               // no nested bracket.\n                if(bracket.back == '[')\n\
    \                {\n                    return false;\n                }\n   \
    \             // Pop from the front.\n                bracket.popFront();\n  \
    \          }\n            // Pop the open bracket.\n            bracket.popFront();\n\
    \            // Increase nested_bracket_count.\n            nested_bracket_count++;\n\
    \        }\n    }\n    // If the nested_bracket_count\n    // is less than 2,\
    \ there is no\n    // nested bracket.\nunittest\n{\n    alias candidate = is_nested;\n\
    \n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\"\
    ) == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgddacnkr.d(89): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgddacnkr.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    auto stack = typeof(return)();\n    for(char c : string)\n    {\n \
    \       if(c == '[')\n            stack.pushBack(c);\n        else if(c == ']')\n\
    \        {\n            if(stack.empty)\n                return false;\n     \
    \       stack.popBack();\n        }\n    }\n    return stack.empty;\n}\nunittest\n\
    {\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphq5s871r.d(20): Error: semicolon expected, not `:`\\n/tmp/tmphq5s871r.d(20):\
    \ Error: expression expected, not `:`\\n/tmp/tmphq5s871r.d(20): Error: found `string`\
    \ when expecting `;` following `for` condition\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmphq5s871r.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int i = 0;\n    while(i < string.length)\n    {\n        if(string[i]\
    \ == '[')\n        {\n            if(string[i+1] == ']' || string[i+1] == '[')\n\
    \            {\n                return true;\n            }\n        }\n     \
    \   i++;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = is_nested;\n\
    \n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\"\
    ) == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpo8r9jq9z.d(38): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f85]\\n??:? void tmpo8r9jq9z.__unittest_L33_C1()\
    \ [0x427b07]\\n??:? void tmpo8r9jq9z.__modtest() [0x427d04]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bd1f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42abb2]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fd45]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x4301f4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fcd1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42ab89]\\n??:? runModuleUnitTests [0x42baf5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428448]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283cf]\\n??:? _d_run_main [0x42833a]\\n??:? main [0x427d17]\\\
    n??:? __libc_start_main [0xf7b6c554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    // if zero brackets, can't nest\n    if (string.empty) \n        return\
    \ false;\n    // if all pairs, can't nest\n    if (string.filter!(a => a == '[').empty)\n\
    \        return false;\n    // if length is odd, can't nest\n    if (string.length\
    \ % 2 == 1)\n        return false;\n    // if any nested, return true\n    return\
    \ string.filter!(a => a == '[').zip(string.filter!(a => a == ']')).map!(tuple\
    \ => tuple[0] == '[' && tuple[1] == ']').any;\n}\n/*\nunittest\n{\n    alias candidate\
    \ = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6sg5yovb.d(31): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6sg5yovb.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    // first solution\n    /*\n    char[] input = to!char[](string);\n\
    \    // remove all characters exept [ and ]\n    input = input.filter!(c => c\
    \ == '[' || c == ']');\n    // check if length is even\n    if (input.length %\
    \ 2 == 1)\n        return false;\n    // check for invalid sequences\n    if (input.indexOf(\"\
    ][\") != -1 || input.indexOf(\"][\") != -1)\n        return false;\n    // split\
    \ the brackets\n    char[][] splitted = input.split(\"\\\\[\\\\]\");\n    // remove\
    \ empty strings\n    splitted = splitted.filter!(c => c.length != 0);\n    //\
    \ there should be only one string left\n    return splitted.length == 1;\n   \
    \ */\n    // better solution\n    char[] input = to!char[](string);\n    // remove\
    \ all characters exept [ and ]\n    input = input.filter!(c => c == '[' || c ==\
    \ ']');\n    // check if length is even\n    if (input.length % 2 == 1)\n    \
    \    return false;\n    // check for invalid sequences\n    if (input.indexOf(\"\
    ][\") != -1 || input.indexOf(\"][\") != -1)\n        return false;\n    // check\
    \ for invalid strings\n    for (int i = 0; i < input.length; i += 2)\n    {\n\
    \        if (input[i] != '[' || input[i + 1] != ']')\n            return false;\n\
    \    }\n    return true;\n}\n/*\n    Write a function that takes a string of braces,\
    \ and determines if the order of the braces is valid.\n    It should return true\
    \ if the string is valid, and false if it's invalid.\nunittest\n{\n    alias candidate\
    \ = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpp86w04of.d(55): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp86w04of.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n\tif(string.length == 0)\n\t\treturn false;\n\t\t\n\tuint[] stack;\n\t\
    for(uint i = 0; i < string.length; i++)\n\t{\n\t\tif(string[i] == '[')\n\t\t\t\
    stack ~= 0;\n\t\telse if(string[i] == ']')\n\t\t{\n\t\t\tif(stack.length == 0)\n\
    \t\t\t\treturn false;\n\t\t\telse\n\t\t\t\tstack.popBack();\n\t\t}\n\t}\n\treturn\
    \ stack.length == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n   \
    \ assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\"\
    ) == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3dfx4lu1.d(32): Error: no property `popBack` for type `uint[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3dfx4lu1.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int openBrackets = 0;\n    int closedBrackets = 0;\n    foreach(char\
    \ c; string)\n    {\n        if(c == '[')\n        {\n            ++openBrackets;\n\
    \        }\n        else if(c == ']')\n        {\n            ++closedBrackets;\n\
    \        }\n        if(closedBrackets > openBrackets)\n        {\n           \
    \ return false;\n        }\n    }\n    return openBrackets != closedBrackets ?\
    \ false : true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpkzqhj6ix.d(44): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f55]\\n??:? void tmpkzqhj6ix.__unittest_L38_C1()\
    \ [0x427b04]\\n??:? void tmpkzqhj6ix.__modtest() [0x427cd8]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc7b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab0e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fca1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430150]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc2d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aae5]\\n??:? runModuleUnitTests [0x42ba51]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4283a4]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42832b]\\n??:? _d_run_main [0x428296]\\n??:? main [0x427ceb]\\\
    n??:? __libc_start_main [0x896bd554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    auto bracket_count = 0;\n    foreach(c; string)\n    {\n        if(c\
    \ == '[') bracket_count++;\n        else if(c == ']') bracket_count--;\n     \
    \   if(bracket_count < 0) break;\n    }\n    return bracket_count == 0;\n}\nunittest\n\
    {\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp2twx3m_e.d(34): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f45]\\n??:? void tmp2twx3m_e.__unittest_L28_C1()\
    \ [0x427af0]\\n??:? void tmp2twx3m_e.__modtest() [0x427cc4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc6b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42aafe]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc91]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430140]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc1d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aad5]\\n??:? runModuleUnitTests [0x42ba41]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428394]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42831b]\\n??:? _d_run_main [0x428286]\\n??:? main [0x427cd7]\\\
    n??:? __libc_start_main [0x1350b554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    bool result = false;\n    bool inside = false;\n    uint index = 0;\n\
    \    while(!result && index < string.length)\n    {\n        if(string[index]\
    \ == '[')\n        {\n            index++;\n            inside = true;\n     \
    \       while(inside && index < string.length)\n            {\n              \
    \  if(string[index] == ']')\n                {\n                    result = true;\n\
    \                    inside = false;\n                }\n                else\
    \ if(string[index] == '[')\n                {\n                    result = false;\n\
    \                    inside = false;\n                }\n                index++;\n\
    \            }\n        }\n        else index++;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpk10funo2.d(51): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427fbd]\\n??:? void tmpk10funo2.__unittest_L47_C1()\
    \ [0x427b1a]\\n??:? void tmpk10funo2.__modtest() [0x427d40]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bd57]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42abea]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fd7d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x43022c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fd09]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42abc1]\\n??:? runModuleUnitTests [0x42bb2d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428480]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428407]\\n??:? _d_run_main [0x428372]\\n??:? main [0x427d53]\\\
    n??:? __libc_start_main [0xb6f40554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int counter = 0;\n    int nesting = 0;\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            ++counter;\n            ++nesting;\n\
    \        }\n        else if(c == ']')\n        {\n            --counter;\n   \
    \         --nesting;\n        }\n        if(nesting < 0)\n        {\n        \
    \    return false;\n        }\n    }\n    return counter == 0 && nesting >= 0;\n\
    }\n/*\n    function is_nested(string) {\n    let nest = 0;\n    for (let i = 0;\
    \ i < string.length; i++) {\n      if (string[i] === '[') {\n        nest++;\n\
    \      } else if (string[i] === ']') {\n        nest--;\n      }\n      if (nest\
    \ < 0) {\n        return false;\n      }\n    }\n    return nest === 0;\n  }\n\
    \  function is_nested(string) {\n    var count = 0;\n    for (var i = 0; i < string.length;\
    \ i++) {\n      if (string[i] == '[') count++;\n      if (string[i] == ']') count--;\n\
    \      if (count < 0) return false;\n    }\n    return count == 0;\n  }\n  function\
    \ is_nested(string) {\n    return !string.split(\"\").reduce((x,y)=>{\n      if(y===\"\
    [\"){\n        x++\n      }else if(y===\"]\"){\n        x--\n      }\n      if(x<0){\n\
    \        return false\n      }\n      return x\n    },0)\n  }\n*/\nunittest\n\
    {\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpwea7acsp.d(84): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f5d]\\n??:? void tmpwea7acsp.__unittest_L78_C1()\
    \ [0x427b0c]\\n??:? void tmpwea7acsp.__modtest() [0x427ce0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc83]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab16]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fca9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430158]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc35]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aaed]\\n??:? runModuleUnitTests [0x42ba59]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4283ac]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428333]\\n??:? _d_run_main [0x42829e]\\n??:? main [0x427cf3]\\\
    n??:? __libc_start_main [0x4ebac554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    bool rval = false;\n    bool lval = false;\n    bool val = false;\n\
    \    int cnt = 0;\n    foreach(char c; string)\n    {\n        if(c == '[')\n\
    \        {\n            cnt++;\n            if(lval)\n            {\n        \
    \        val = true;\n            }\n            else\n            {\n       \
    \         lval = true;\n            }\n        }\n        else if(c == ']')\n\
    \        {\n            cnt--;\n            if(rval)\n            {\n        \
    \        val = true;\n            }\n            else\n            {\n       \
    \         rval = true;\n            }\n        }\n    }\n    if(cnt == 0 && val)\n\
    \    {\n        return true;\n    }\n    return false;\n}\nunittest\n{\n    alias\
    \ candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpdd2u9n2o.d(62): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f75]\\n??:? void tmpdd2u9n2o.__unittest_L56_C1()\
    \ [0x427b24]\\n??:? void tmpdd2u9n2o.__modtest() [0x427cf8]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc9b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab2e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fcc1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430170]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc4d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42ab05]\\n??:? runModuleUnitTests [0x42ba71]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4283c4]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42834b]\\n??:? _d_run_main [0x4282b6]\\n??:? main [0x427d0b]\\\
    n??:? __libc_start_main [0xfa992554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    Tuple!(bool,bool) counts = tuple(false,false);\n    int i = 0;\n  \
    \  for(i=0;i<string.length;i++)\n    {\n        if(string[i] == '[')\n       \
    \ {\n            counts[0] = true;\n        }\n        else if(string[i] == ']')\n\
    \        {\n            counts[1] = true;\n        }\n    }\n    if(counts[0]\
    \ && counts[1])\n    {\n        return true;\n    }\n    else\n    {\n       \
    \ return false;\n    }\n}\nunittest\n{\n    alias candidate = is_nested;\n\n \
    \   assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\"\
    ) == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpqlh36wxu.d(46): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428d95]\\n??:? void tmpqlh36wxu.__unittest_L41_C1()\
    \ [0x4282cf]\\n??:? void tmpqlh36wxu.__modtest() [0x4287fc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d723]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42c632]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430f59]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x431408]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430ee5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42c609]\\n??:? runModuleUnitTests [0x42d4f9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429258]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4291df]\\n??:? _d_run_main [0x42914a]\\n??:? main [0x42880f]\\\
    n??:? __libc_start_main [0x7ae80554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    struct Brackets\n    {\n        int opened;\n        int closed;\n\
    \    };\n    Brackets bs = {};\n    bool is_nested = false;\n    foreach(c; string)\n\
    \    {\n        if(c == '[')\n        {\n            bs.opened++;\n        }\n\
    \        else if(c == ']')\n        {\n            bs.closed++;\n        }\n \
    \   }\n    is_nested = bs.opened > bs.closed;\n    return is_nested;\n}\nunittest\n\
    {\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpo0g8lgl4.d(23): Deprecation: use `{ }` for an empty statement,\
    \ not `;`\\n/tmp/tmpo0g8lgl4.d(23): Deprecation: use `{ }` for an empty statement,\
    \ not `;`\\ncore.exception.AssertError@/tmp/tmpo0g8lgl4.d(44): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42830d]\\n??:? void tmpo0g8lgl4.__unittest_L40_C1()\
    \ [0x427b4e]\\n??:? void tmpo0g8lgl4.__modtest() [0x427d74]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c19f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b0ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4301c5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430674]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430151]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b085]\\n??:? runModuleUnitTests [0x42bf75]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42875c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4286e3]\\n??:? _d_run_main [0x42864e]\\n??:? main [0x427d87]\\\
    n??:? __libc_start_main [0x5b8554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int bracket_count = 0;\n    int last_char = 0;\n    for(int i = 0;\
    \ i < string.length; i++) {\n        if(string[i] == '[') {\n            bracket_count++;\n\
    \        }\n        else if(string[i] == ']') {\n            bracket_count--;\n\
    \        }\n        if(bracket_count == 0) last_char = i;\n    }\n    return bracket_count\
    \ == 0 && last_char != 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n\
    \    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\"\
    ) == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp04rlf7ds.d(38): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f7d]\\n??:? void tmp04rlf7ds.__unittest_L32_C1()\
    \ [0x427b2c]\\n??:? void tmp04rlf7ds.__modtest() [0x427d00]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bd17]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42abaa]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fd3d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x4301ec]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fcc9]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42ab81]\\n??:? runModuleUnitTests [0x42baed]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428440]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283c7]\\n??:? _d_run_main [0x428332]\\n??:? main [0x427d13]\\\
    n??:? __libc_start_main [0x97ef4554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    bool res = false;\n    int left = 0;\n    int right = 0;\n    for(int\
    \ i = 0; i < string.length; i++)\n    {\n        if(string[i] == '[') left++;\n\
    \        if(string[i] == ']') right++;\n        if(left < right) return false;\n\
    \    }\n    if(left == right) return true;\n    return res;\n}\nunittest\n{\n\
    \    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpc3ag5sqy.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f85]\\n??:? void tmpc3ag5sqy.__unittest_L31_C1()\
    \ [0x427b30]\\n??:? void tmpc3ag5sqy.__modtest() [0x427d04]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bd1f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42abb2]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fd45]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x4301f4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fcd1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42ab89]\\n??:? runModuleUnitTests [0x42baf5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428448]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283cf]\\n??:? _d_run_main [0x42833a]\\n??:? main [0x427d17]\\\
    n??:? __libc_start_main [0x97103554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    // create stack\n    Stack!int stack = new Stack!int;\n    // put value's\
    \ in the stack\n    foreach(char; string)\n    {\n        stack.push(char);\n\
    \    }\n    // create the closing bracket\n    int close;\n    // if the stack\
    \ is not empty\n    if(!stack.empty)\n    {\n        // Pop last value from the\
    \ stack\n        close = stack.pop;\n    }\n    // check if the input string is\
    \ valid\n    bool isValid = false;\n    // for every character in the string\n\
    \    foreach(i; 0 .. string.length)\n    {\n        // if the character is [\n\
    \        if(string[i] == '[')\n        {\n            // check if a closing bracket\
    \ exists\n            if(close == ']')\n            {\n                // if so\
    \ set isValid to true\n                isValid = true;\n            }\n      \
    \  }\n    }\n    // return isValid\n    return isValid;\n}\n// Tests\nunittest\
    \ \n{\n    assert(is_nested(\"[[]]\"));\n    assert(!is_nested(\"[]]]]]]][[[[[]\"\
    ));\n    assert(!is_nested(\"[][]\"));\n    assert(!is_nested(\"[]\"));\n    assert(is_nested(\"\
    [[][]]\"));\n    assert(is_nested(\"[[]][[\"));\n}\nunittest\n{\n    alias candidate\
    \ = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpszf83j2y.d(22): Error: no identifier for declarator `char`\\\
    n/tmp/tmpszf83j2y.d(24): Error: found `)` when expecting `.` following char\\\
    n/tmp/tmpszf83j2y.d(24): Error: found `;` when expecting identifier following\
    \ `char`.\\n/tmp/tmpszf83j2y.d(25): Error: found `}` when expecting `,`\\n/tmp/tmpszf83j2y.d(27):\
    \ Error: found `close` when expecting `.` following int\\n/tmp/tmpszf83j2y.d(27):\
    \ Error: found `;` when expecting identifier following `int`.\\n/tmp/tmpszf83j2y.d(29):\
    \ Error: found `if` when expecting `,`\\n/tmp/tmpszf83j2y.d(29): Error: basic\
    \ type expected, not `!`\\n/tmp/tmpszf83j2y.d(29): Error: found `!` when expecting\
    \ `)`\\n/tmp/tmpszf83j2y.d(29): Error: missing `{ ... }` for function literal\\\
    n/tmp/tmpszf83j2y.d(29): Error: found `stack` when expecting `,`\\n/tmp/tmpszf83j2y.d(30):\
    \ Error: found `{` when expecting `;` following statement\\nFailed: [\"dmd\",\
    \ \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpszf83j2y.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int prev_len = 0;\n    for(int i = 0; i < string.length; i++) {\n \
    \       string.replace(\"[]\", \"\");\n        if(prev_len == string.length) {\n\
    \            return false;\n        }\n        prev_len = string.length;\n   \
    \ }\n    return true;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n  \
    \  assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\"\
    ) == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpal3jsf34.d(21): Error: no property `replace` for type `string`\\\
    n/tmp/tmpal3jsf34.d(25): Error: cannot implicitly convert expression `string.length`\
    \ of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpal3jsf34.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    /*\n        This function should return true if and only if there is\
    \ a valid subsequence of brackets \n        where at least one bracket in the\
    \ subsequence is nested.\n    */\n    // Because we're only given strings with\
    \ square brackets and not actual square brackets, we're going to have to find\
    \ a way to change them.\n    // Lets take care of the square brackets that are\
    \ nested first.\n    // Examples of this would be:\n    // '[[]]'\n    // '[][]'\n\
    \    // '[[][]]'\n    // One way to do this would be to just loop through the\
    \ string and remove all of the square brackets until there are no more.\n    //\
    \ If we have a string that is nested, then we will have an empty string.\n   \
    \ // If we have a string that is not nested, then we will have a string with brackets\
    \ left.\n    // This is how we will determine if a bracket is nested.\n    //\
    \ So lets make a while loop that will check the lenght of the string.\n    //\
    \ If the length of the string is 0, then we will return true, because it is a\
    \ nested string.\n    // If the length of the string is not 0, then we will return\
    \ false, because it is not a nested string.\n    // Now we need to determine if\
    \ the string is nested.\n    // If we have a string like '[][]', then those brackets\
    \ aren't nested.\n    // We could loop through the string, and if we see that\
    \ the bracket is a ']', then we can try to find the index of the closest '[' before\
    \ that index.\n    // If we are able to find an index that is less than the current\
    \ index, then we can replace that with a '|' sign.\n    // '|' is just to make\
    \ the string look nice, so that we know that that bracket was removed.\n    //\
    \ After we are done looping through the string, we will make a while loop that\
    \ will check if there are any brackets in the string.\n    // If there is, then\
    \ we will replace it with '|' and if there isn't, then we will return false.\n\
    \    // Remember, if we are able to get an empty string, then we will return true.\n\
    \    // Lets start with the for loop.\n    for(int i = 0; i < string.length; i\n\
    unittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprs9hc0oe.d(46): Error: found `unittest` when expecting `)`\\\
    n/tmp/tmprs9hc0oe.d(65): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprs9hc0oe.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    int count = 0;\n    for(char a : string)\n    {\n        if(a == '[')\
    \ count++;\n        else if(a == ']') count--;\n        if(count == -1) return\
    \ false;\n    }\n    return count == 0;\n}\nunittest\n{\n    alias candidate =\
    \ is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmkcw8_kw.d(20): Error: semicolon expected, not `:`\\n/tmp/tmpmkcw8_kw.d(20):\
    \ Error: expression expected, not `:`\\n/tmp/tmpmkcw8_kw.d(20): Error: found `string`\
    \ when expecting `;` following `for` condition\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpmkcw8_kw.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
    \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
    \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
    \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
    \ \n{\n    bool result = false;\n    for(int i = 0; i < string.length; i++)\n\
    \    {\n        if(string[i] == '[')\n        {\n            for(int j = i + 1;\
    \ j < string.length; j++)\n            {\n                if(string[j] == ']')\n\
    \                {\n                    result = true;\n                    break;\n\
    \                }\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp2b__y7nz.d(41): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f75]\\n??:? void tmp2b__y7nz.__unittest_L36_C1()\
    \ [0x427afb]\\n??:? void tmp2b__y7nz.__modtest() [0x427cf8]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bd0f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42aba2]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fd35]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x4301e4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fcc1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42ab79]\\n??:? runModuleUnitTests [0x42bae5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428438]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283bf]\\n??:? _d_run_main [0x42832a]\\n??:? main [0x427d0b]\\\
    n??:? __libc_start_main [0xb8e95554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
