name: HumanEval_84_solve
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\nGiven a positive integer N, return\
  \ the total sum of its digits in binary.\n    \n    Example\n        For N = 1000,\
  \ the sum of digits will be 1 the output should be \"1\".\n        For N = 150,\
  \ the sum of digits will be 6 the output should be \"110\".\n        For N = 147,\
  \ the sum of digits will be 12 the output should be \"1100\".\n    \n    Variables:\n\
  \        @N integer\n             Constraints: 0 \u2264 N \u2264 10000.\n    Output:\n\
  \         a string of binary number\n    \n*/\nstring solve(long N) \n"
tests: "unittest\n{\n    alias candidate = solve;\n\n    assert(candidate(1000L) ==\
  \ \"1\");\n    assert(candidate(150L) == \"110\");\n    assert(candidate(147L) ==\
  \ \"1100\");\n    assert(candidate(333L) == \"1001\");\n    assert(candidate(963L)\
  \ == \"10010\");\n}\nvoid main(){}"
completions: ["{\n    string s = \"\";\n    foreach(i;0..log2(N))\n    {\n       \
    \ if(N>>i&1)\n            s=to!string(1)+s;\n        else\n            s=to!string(0)+s;\n\
    \    }\n    return s;\n}", "{\n    return sum(to!string(N, 2));\n}", "{\n    string\
    \ str = \"\";\n    //write your code here\n    int k = log2(N) + 1;\n    for(int\
    \ i = 0; i <= k; i++)\n    {\n        if((1 << i) > N)\n            break;\n \
    \       N -= (1 << i);\n        str += \"1\";\n    }\n    while(i--)\n       \
    \ str += \"0\";\n    return str;\n}", "{\n    string result = \"\";\n    long\
    \ i = 0;\n    //Tuple of int, string\n    long[] bin = [0, \"\"];\n    long quot\
    \ = 0;\n    //get the maximum number of times to loop the division\n    long max\
    \ = (long) pow(2, log2(N));\n    for (i = max; i > 0; i /= 2)\n    {\n       \
    \ quot = N / i;\n        N = N % i;\n        //debug(quot);\n        //debug(N);\n\
    \        bin[0] = bin[0] * 10 + quot;\n        bin[1] = bin[1] + quot.to!string;\n\
    \    }\n    //debug(bin[0]);\n    //debug(bin[1]);\n    return bin[1];\n}", "{\n\
    \    import std.conv;\n    return to!string(N.countBits,2);\n}", "{\n    return\
    \ to!string(N,2);\n}\n//\nstring solve(long N) \n{\n    string ret;\n    while(N\
    \ != 0)\n    {\n        ret ~= (N & 1).to!string;\n        N >>= 1;\n    }\n \
    \   return ret.retro;\n}\n//\nstring solve(long N) \n{\n    string s;\n    while(N\
    \ > 0)\n    {\n        if(N & 1)\n            s ~= \"1\";\n        else\n    \
    \        s ~= \"0\";\n        N >>= 1;\n    }\n    return s.retro;\n}\n//\n//",
  "{\n    string s=\"\";\n    string t=\"\";\n    int i;\n    for(i=0;N>0;i++)\n \
    \   {\n        s+=to!string(N%2);\n        N/=2;\n    }\n    for(int j=i-1;j>=0;j--)\n\
    \    {\n        t+=s[j];\n    }\n    return t;\n}", "{\n    string result;\n \
    \   do\n    {\n        result ~= to!string(N % 2);\n        N /= 2;\n    } while\
    \ (N != 0);\n    return result;\n}", "{\n    string result;\n    string tmp =\
    \ \"\";\n    while(N != 0)\n    {\n        tmp += to!string(N % 2);\n        N\
    \ /= 2;\n    }\n    tmp = tmp.dup.reverse;\n    foreach(c; tmp)\n    {\n     \
    \   if(c == '1')\n            result += c;\n    }\n    return result;\n}\n// not\
    \ my solution\nstring solve(long N) \n{\n    int cnt = 0;\n    while(N != 0)\n\
    \    {\n        if(N % 2 == 1)\n            cnt++;\n        N /= 2;\n    }\n \
    \   return to!string(cnt);\n}\nunittest \n{\n    assert(solve(1000) == \"1\");\n\
    \    assert(solve(150) == \"110\");\n    assert(solve(147) == \"1100\");\n}",
  "{\n    return to!string(N, 2);\n}", "{\n    int acc = 0;\n    foreach( x; to!string(N,\
    \ 2))\n    {\n        acc += x;\n    }\n    return to!string(acc);\n}", "{\n \
    \   string out_str = \"\";\n    while(N > 0)\n    {\n        //out_str += to!string(N%2);\n\
    \        out_str = to!string(N%2) ~ out_str;\n        N /= 2;\n    }\n    //writefln(\"\
    %s\", out_str);\n    return out_str;\n}", "{\n    return to!string(N,2);\n}",
  "{\n    char[200] result;\n    string ret;\n    foreach(i;0..result.length)\n  \
    \  {\n        result[i] = '0';\n    }\n    int index = 1;\n    int len = 0;\n\
    \    while(N != 0)\n    {\n        long rem = N % 2;\n        N = N / 2;\n   \
    \     result[index++] = result[index++] + rem;\n        len++;\n    }\n    index\
    \ = 0;\n    int temp = index;\n    while(temp < result.length)\n    {\n      \
    \  temp++;\n        if(result[temp] == '1')\n        {\n            index = temp;\n\
    \        }\n    }\n    temp = index;\n    while(temp < result.length)\n    {\n\
    \        temp++;\n        ret ~= result[temp];\n    }\n    return ret;\n}", "{\n\
    \    int s = 0;\n    string out;\n    for(N; N > 0; N /= 2) {\n        out = cast(string)(N\
    \ % 2) ~ out;\n        s += N % 2;\n    }\n    return s.to!string;\n}\n/*\n  \
    \  Tests\n        int k = 0;\n        while(k < 100) {\n            string r =\
    \ solve(k);\n            foreach(s; r) {\n                assert(s == '0' || s\
    \ == '1');\n            }\n            k++;\n        }\n*/", "{\n    long sum\
    \ = 0;\n    string bin = to!string(N, 2);\n    for(int i = 0; i < bin.length;\
    \ i++)\n    {\n        sum += parseInt(bin[i..i]);\n    }\n    return to!string(sum);\n\
    }", "{\n    string binary=\"\";\n    int sum=0;\n    int i=0;\n    while(N!=0)\n\
    \    {\n        binary+= to!string(N%2);\n        N/=2;\n    }\n    while(i<binary.length)\n\
    \    {\n        sum+=to!int(binary[i]);\n        i++;\n    }\n    return to!string(sum);\n\
    }", "{\n    string binary = \"\";\n    for(; N; N /= 2)\n        binary = to!string(N\
    \ % 2) ~ binary;\n    return binary;\n}", "{\n    /*\n    I am going to use the\
    \ following approach:\n    1. Using the built-in funcion toBinaryString\n    2.\
    \ Converting the binary string to an array of chars\n    3. Summing the array\
    \ of char\n    4. Converting the integer to a string\n    */\n    \n    // Testing\n\
    \    //import std.conv;\n    //assert(\"1000\".to!long == 8);\n    //assert(\"\
    1100\".to!long == 12);\n    //assert(\"1101\".to!long == 13);\n    //assert(\"\
    100000\".to!long == 32);\n    //assert(\"110011\".to!long == 51);\n    //assert(\"\
    1100\".to!long == 12);\n    //assert(\"1100101\".to!long == 101);\n    //assert(\"\
    11101110\".to!long == 238);\n    //assert(\"1\".to!long == 1);\n    //assert(\"\
    0\".to!long == 0);\n    //assert(\"11\".to!long == 3);\n    //assert(\"101\".to!long\
    \ == 5);\n    //assert(\"111\".to!long == 7);\n    //assert(\"1111\".to!long ==\
    \ 15);\n    //assert(\"11111\".to!long == 31);\n    //assert(\"111111\".to!long\
    \ == 63);\n    //assert(\"1111111\".to!long == 127);\n    //assert(\"11111111\"\
    .to!long == 255);\n    //assert(\"111111111\".to!long == 511);\n    //assert(\"\
    1111111111\".to!long == 1023);\n    //assert(\"11111111111\".to!long == 2047);\n\
    \    //assert(\"111111111111\".to!long == 4095);\n    //assert(\"1111111111111\"\
    .to!long == 8191);\n    //assert(\"11111111111111\".to!long == 16383);\n    //assert(\"\
    111111111111111\".to!long == 32767);\n    //assert(\"1111111111111111\".to!long\
    \ == 65535);\n    //assert(\"11111111111111111\".to!long == 131071);\n    //assert(\"\
    111111111111111111\".to!long == 262143);\n    //assert(\"1111111111111111111\"\
    .to!long ==", "{\n    string binary = \"\";\n    while(N != 0)\n    {\n      \
    \  binary += to!string(N%2);\n        N /= 2;\n    }\n    return binary;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
