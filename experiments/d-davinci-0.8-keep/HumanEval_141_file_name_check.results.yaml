name: HumanEval_141_file_name_check
language: d
results:
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    size_t dot_pos = file_name.find(\".\");\n    if (dot_pos\
    \ == size_t.max) return \"No\";\n    string name = file_name[0..dot_pos];\n  \
    \  string ex = file_name[dot_pos+1..$];\n    return \"No\";\n}\nunittest\n{\n\
    \    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpu635c2pc.d(20): Error: no property `find` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu635c2pc.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto is_a_letter = (c) =>\n    {\n        import std.utf;\n\
    \        // check if its a lower case letter\n        return (c >= 'a' && c <=\
    \ 'z') ||\n        // check if its an upper case letter\n        (c >= 'A' &&\
    \ c <= 'Z');\n    };\n    auto is_a_digit = (c) =>\n    {\n        import std.utf;\n\
    \        return c >= '0' && c <= '9';\n    };\n    auto is_file_extention = (ext)\
    \ =>\n    {\n        return ext == \"txt\" || ext == \"exe\" || ext == \"dll\"\
    ;\n    };\n    auto valid_file_name = (file_name) =>\n    {\n        auto file_extention\
    \ = file_name.split(\".\").back;\n        auto file_name_without_extention = file_name.split(\"\
    .\").front;\n        auto contains_no_more_than_three_digits = file_name_without_extention.filter!(a\
    \ => is_a_digit(a)).length <= 3;\n        auto contains_exactly_one_dot = file_name.count(\"\
    .\") == 1;\n        auto contains_valid_file_extention = is_file_extention(file_extention);\n\
    \        auto contains_valid_name = !file_name_without_extention.empty && is_a_letter(file_name_without_extention[0]);\n\
    \        return contains_no_more_than_three_digits && contains_exactly_one_dot\
    \ && contains_valid_file_extention && contains_valid_name;\n    };\n    return\
    \ valid_file_name(file_name) ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfc7tg98k.d(20): Error: variable `tmpfc7tg98k.file_name_check.is_a_letter`\
    \ type `void` is inferred from initializer `(c) => ()\\n{\\nimport std.utf;\\\
    nreturn c >= \\'a\\' && (c <= \\'z\\') || c >= \\'A\\' && (c <= \\'Z\\');\\n}\\\
    n`, and variables cannot be of type `void`\\n/tmp/tmpfc7tg98k.d(20): Error: template\
    \ lambda has no value\\n/tmp/tmpfc7tg98k.d(28): Error: variable `tmpfc7tg98k.file_name_check.is_a_digit`\
    \ type `void` is inferred from initializer `(c) => ()\\n{\\nimport std.utf;\\\
    nreturn c >= \\'0\\' && (c <= \\'9\\');\\n}\\n`, and variables cannot be of type\
    \ `void`\\n/tmp/tmpfc7tg98k.d(28): Error: template lambda has no value\\n/tmp/tmpfc7tg98k.d(33):\
    \ Error: variable `tmpfc7tg98k.file_name_check.is_file_extention` type `void`\
    \ is inferred from initializer `(ext) => ()\\n{\\nreturn ext == \"txt\" || ext\
    \ == \"exe\" || ext == \"dll\";\\n}\\n`, and variables cannot be of type `void`\\\
    n/tmp/tmpfc7tg98k.d(33): Error: template lambda has no value\\n/tmp/tmpfc7tg98k.d(37):\
    \ Error: variable `tmpfc7tg98k.file_name_check.valid_file_name` type `void` is\
    \ inferred from initializer `(file_name) => ()\\n{\\nauto file_extention = file_name.split(\"\
    .\").back;\\nauto file_name_without_extention = file_name.split(\".\").front;\\\
    nauto contains_no_more_than_three_digits = file_name_without_extention.filter!((a)\
    \ => is_a_digit(a)).length <= 3;\\nauto contains_exactly_one_dot = file_name.count(\"\
    .\") == 1;\\nauto contains_valid_file_extention = is_file_extention(file_extention);\\\
    nauto contains_valid_name = !file_name_without_extention.empty && is_a_letter(file_name_without_extention[0]);\\\
    nreturn contains_no_more_than_three_digits && contains_exactly_one_dot && contains_valid_file_extention\
    \ && contains_valid_name;\\n}\\n`, and variables cannot be of type `void`\\n/tmp/tmpfc7tg98k.d(37):\
    \ Error: template lambda has no value\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpfc7tg98k.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    enum valid_extensions = [\"txt\", \"exe\", \"dll\"];\n \
    \   auto tmp = split(file_name, \".\");\n    if (count(file_name, \".\") != 1\
    \ || tmp.length != 2) \n        return \"No\";\n    auto name = tmp[0];\n    auto\
    \ extension = tmp[1];\n    if (name.length == 0 || (extension.length != 3 && extension.length\
    \ != 4)) \n        return \"No\";\n    foreach (i,c; name)\n    {\n        if\
    \ (isdigit(c)) \n            i++;\n        if (i > 3) \n            return \"\
    No\";\n    }\n    return (isalpha(name[0]) && valid_extensions.canFind(extension))\
    \ ? \"Yes\" : \"No\";\n}\n/*\n    There is a list of all the ASCII characters,\
    \ with their numbers from 0 to 255.\n    Your function should take this list as\
    \ an input, and return the sum of ASCII\n    character codes of all the characters\
    \ which are of odd index in the given list.\n    Examples:\n    ascii_sum([97,\
    \ 116, 116, 114, 105, 98, 117, 116, 101]) # => 1151\n    ascii_sum([100, 100,\
    \ 116, 58, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98,\
    \ 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98,\
    \ 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98,\
    \ 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98,\
    \ 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98,\
    \ 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98\nunittest\n{\n    alias\
    \ candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"\
    Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpk57h4h7m.d(37): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk57h4h7m.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto file_name_split = split(file_name, \".\");\n    return\
    \ is(file_name_split[0].count!(a => a.isdigit) <= 3 \n          && file_name_split.length\
    \ == 2 \n          && file_name_split[0].length > 0 \n          && isLetter(file_name_split[0][0])\
    \ \n          && file_name_split[1] in [\"txt\", \"exe\", \"dll\"]) ? \"Yes\"\
    \ : \"No\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5wtfm_ut.d(21): Error: found `<=` when expecting `)`\\n/tmp/tmp5wtfm_ut.d(21):\
    \ Error: found `3` when expecting `;` following `return` statement\\n/tmp/tmp5wtfm_ut.d(22):\
    \ Error: found `&&` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp5wtfm_ut.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto dot = file_name.indexOf('.');\n    if (dot == -1) return\
    \ \"No\";\n    int nums = 0;\n    foreach (auto c; file_name) \n    {\n      \
    \  if ('0' <= c && c <= '9') \n        {\n            ++nums;\n            if\
    \ (nums > 3) return \"No\";\n        }\n    }\n    auto s = file_name.split('.');\n\
    \    return (s[0].length != 0 && s[0][0] != '.' &&\n            (s[1] == \"txt\"\
    \ || s[1] == \"exe\" || s[1] == \"dll\")) ?\n    \"Yes\" : \"No\";\n}\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvgz2jfvs.d(23): Error: basic type expected, not `auto`\\n/tmp/tmpvgz2jfvs.d(23):\
    \ Error: no identifier for declarator `_error_`\\n/tmp/tmpvgz2jfvs.d(23): Error:\
    \ found `auto` when expecting `;`\\n/tmp/tmpvgz2jfvs.d(23): Error: found `;` when\
    \ expecting `)`\\n/tmp/tmpvgz2jfvs.d(23): Error: found `)` when expecting `;`\
    \ following statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvgz2jfvs.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    enum type_name=[\"txt\", \"exe\", \"dll\"];\n    int count\
    \ = 0;\n    immutable name = file_name.dup;\n    immutable len = name.length;\n\
    \    foreach(i;0..len)\n    {\n        if(name[i] in ['0'..'9'])\n        {\n\
    \            count++;\n        }\n    }\n    if(count>3)\n    {\n        return\
    \ \"No\";\n    }\n    else\n    {\n        immutable n = name.dup;\n        immutable\
    \ f = n.retro;\n        immutable f2 = n.retro;\n        immutable n2 = name.dup;\n\
    \        immutable temp1 = n2.retro.idup;\n        immutable temp2 = f2.idup;\n\
    \        immutable t = temp1.split(\".\");\n        immutable t2 = temp2.split(\"\
    .\");\n        int i = 0;\n        foreach(n2; t2)\n        {\n            if(i==0)\n\
    \            {\n                if(!(n2 in ['A'..'Z']) && !(n2 in ['a'..'z']))\n\
    \                {\n                    return \"No\";\n                }\n  \
    \          }\n            else\n            {\n                if(!(n2 in type_name))\n\
    \                {\n                    return \"No\";\n                }\n  \
    \          }\n            i++;\n        }\n        return \"Yes\";\n    }\n}\n\
    unittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpd8jff9_o.d(26): Error: found `..` when expecting `,`\\n/tmp/tmpd8jff9_o.d(50):\
    \ Error: found `..` when expecting `,`\\n/tmp/tmpd8jff9_o.d(50): Error: found\
    \ `..` when expecting `,`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmpd8jff9_o.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto pos = file_name.findLastOf('.');\n    return file_name.count('.')\
    \ == 1 && file_name[0].isLetter() &&\n            file_name[pos + 1..$].length\
    \ > 0 && \n            file_name[0..pos].count(x => x.isDigit()) <= 3 &&\n   \
    \         (file_name[pos + 1..$] == \"txt\" || file_name[pos + 1..$] == \"exe\"\
    \ || file_name[pos + 1..$] == \"dll\") ? \"Yes\" : \"No\";\n}\nunittest\n{\n \
    \   alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpb3dne6m2.d(20): Error: no property `findLastOf` for type `string`\\\
    n/tmp/tmpb3dne6m2.d(21): Error: no property `count` for type `string`\\n/tmp/tmpb3dne6m2.d(21):\
    \ Error: no property `isLetter` for type `immutable(char)`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb3dne6m2.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string left = \"\", right = \"\";\n    bool point_found\
    \ = false;\n    for (uint i = 0; i < file_name.length; i++)\n    {\n        if\
    \ (file_name[i] == '.')\n        {\n            point_found = true;\n        \
    \    continue;\n        }\n        if (point_found)\n            right ~= file_name[i];\n\
    \        else\n            left ~= file_name[i];\n    }\n    if (!point_found)\n\
    \        return \"No\";\n    if (right != \"txt\" && right != \"exe\" && right\
    \ != \"dll\")\n        return \"No\";\n    int digits = 0;\n    foreach (c; left)\n\
    \    {\n        if ('0' <= c && c <= '9')\n            digits++;\n    }\n    if\
    \ (digits > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n\
    \    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpd6pe8zzi.d(53): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428865]\\n??:? void tmpd6pe8zzi.__unittest_L48_C1()\
    \ [0x427dd0]\\n??:? void tmpd6pe8zzi.__modtest() [0x4285e8]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42cf6f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42be7e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430855]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430d04]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4307e1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42be55]\\n??:? runModuleUnitTests [0x42cd45]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428d28]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428caf]\\n??:? _d_run_main [0x428c1a]\\n??:? main [0x4285fb]\\\
    n??:? __libc_start_main [0xe7203554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    // check for more than 3 digits...\n    string[] nums =\
    \ [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"];\n  \
    \  string[] digits = filter!( a => nums.find(a) != -1)(file_name.dup);\n    if\
    \ (digits.length > 3)\n        return \"No\";\n    // check for 1 dot\n    string[]\
    \ dots = filter!( a => a == \".\")(file_name.dup);\n    if (dots.length != 1)\n\
    \        return \"No\";\n    // check that there is text before the dot\n    string[]\
    \ parts = file_name.split(\".\");\n    if (parts[0].length == 0)\n        return\
    \ \"No\";\n    // check that the first character of the text before the dot is\
    \ a letter.\n    char[] letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i',\
    \ 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',\
    \ 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',\
    \ 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    char[] chars =\
    \ parts[0].dup;\n    if (letters.find(chars[0]) == -1)\n        return \"No\"\
    ;\n    // check that there is a valid extension\n    string[] exts = [\"txt\"\
    , \"exe\", \"dll\"];\n    if (exts.find(parts[1]) == -1)\n        return \"No\"\
    ;\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpx3hqgec4.d(22): Error: template instance `filter!((a) => nums.find(a)\
    \ != -1)` template `filter` is not defined\\n/tmp/tmpx3hqgec4.d(26): Error: template\
    \ instance `filter!((a) => a == \".\")` template `filter` is not defined\\n/tmp/tmpx3hqgec4.d(30):\
    \ Error: no property `split` for type `string`\\n/tmp/tmpx3hqgec4.d(36): Error:\
    \ no property `find` for type `char[]`\\n/tmp/tmpx3hqgec4.d(40): Error: no property\
    \ `find` for type `string[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpx3hqgec4.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    enum bool isValid = true;\n    bool number_test;\n    bool\
    \ dot_count;\n    bool file_name_test;\n    bool dll_test;\n    int file_name_len\
    \ = file_name.length;\n    string[] dll_list = [\"txt\", \"exe\", \"dll\"];\n\
    \    int dot_location = file_name.indexOf('.');\n    string front_substring =\
    \ file_name[0..dot_location];\n    string back_substring = file_name[dot_location+1..$];\n\
    \    int dot_number_test = front_substring.count('.');\n    int number_test_count\
    \ = 0;\n    char[] front_substring_list = front_substring.dup;\n    if(back_substring\
    \ in dll_list)\n    {\n        dll_test = true;\n    }\n    else\n    {\n    \
    \    dll_test = false;\n    }\n    if(dot_number_test > 1)\n    {\n        dot_count\
    \ = false;\n    }\n    else\n    {\n        dot_count = true;\n    }\n    for(int\
    \ i = 0; i < front_substring_list.length; i++)\n    {\n        if(front_substring_list[i]\
    \ in \"0123456789\")\n        {\n            number_test_count++;\n        }\n\
    \    }\n    if(number_test_count > 3)\n    {\n        number_test = false;\n \
    \   }\n    else\n    {\n        number_test = true;\n    }\n    if(dot_location\
    \ == 0)\n    {\n        file_name_test = false;\n    }\n    else\n    {\n    \
    \    file_name_test = true;\n    }\n    isValid = number_test && dot_count &&\
    \ file_name_test && dll_test;\n    if(isValid)\n    {\n        return \"Yes\"\
    ;\n    }\n    else\n    {\n        return \"No\";\n    }\n}\nunittest\n{\n   \
    \ alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\")\
    \ == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpl7ce67e4.d(25): Error: cannot implicitly convert expression `file_name.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpl7ce67e4.d(27): Error: no property `indexOf`\
    \ for type `string`\\n/tmp/tmpl7ce67e4.d(30): Error: no property `count` for type\
    \ `string`\\n/tmp/tmpl7ce67e4.d(33): Error: incompatible types for `(back_substring)\
    \ in (dll_list)`: `string` and `string[]`\\n/tmp/tmpl7ce67e4.d(51): Error: incompatible\
    \ types for `(front_substring_list[cast(ulong)i]) in (\"0123456789\")`: `char`\
    \ and `string`\\n/tmp/tmpl7ce67e4.d(72): Error: cannot modify constant `isValid`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl7ce67e4.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int dot = file_name.indexOf('.');\n    string prefix = file_name[0..dot];\n\
    \    string suffix = file_name[dot + 1..$];\n    return file_name.filter!(c =>\
    \ c.isDigit).length > 3 ? \"No\" :\n           file_name.count('.') != 1 ? \"\
    No\" :\n           prefix.length == 0 || !prefix[0].isLetter ? \"No\" :\n    \
    \       !suffix.in(\"txt\", \"exe\", \"dll\") ? \"No\" : \"Yes\";\n}\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpr717hgfv.d(26): Error: identifier expected following `.`, not\
    \ `in`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpr717hgfv.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    /* For example, if the file_name is 'example.txt', the below\
    \ three\n     * variables will be set to respectively:\n     * example, ., txt\n\
    \     */\n    auto [file_name_root, dot, file_name_extension] = file_name.split(\"\
    .\");\n    if (file_name_root.filter!(x => '0' <= x && x <= '9').length > 3)\n\
    \        return \"No\";\n    if (dot != \".\")\n        return \"No\";\n    if\
    \ (!(('a' <= file_name_root[0] && file_name_root[0] <= 'z') ||\n            ('A'\
    \ <= file_name_root[0] && file_name_root[0] <= 'Z')))\n        return \"No\";\n\
    \    if (file_name_extension !in [\"txt\", \"exe\", \"dll\"])\n        return\
    \ \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7lryo2hv.d(24): Error: basic type expected, not `[`\\n/tmp/tmp7lryo2hv.d(24):\
    \ Error: found `,` when expecting `]`\\n/tmp/tmp7lryo2hv.d(24): Error: semicolon\
    \ expected, not `]`\\n/tmp/tmp7lryo2hv.d(24): Error: found `]` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7lryo2hv.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    enum extension = [\"txt\", \"exe\", \"dll\"];\n    bool\
    \ ext_valid = false;\n    int dot_pos = file_name.find(\".\");\n    bool dot_valid\
    \ = dot_pos != -1;\n    for (int i = 0; i < extension.length; i++)\n    {\n  \
    \      if (extension[i] == file_name[dot_pos + 1 .. $])\n        {\n         \
    \   ext_valid = true;\n            break;\n        }\n    }\n    bool valid_before_dot\
    \ = true;\n    if (file_name[0 .. dot_pos].length == 0)\n    {\n        valid_before_dot\
    \ = false;\n    }\n    else\n    {\n        if (file_name[0 .. dot_pos][0] >=\
    \ '0' && file_name[0 .. dot_pos][0] <= '9')\n        {\n            valid_before_dot\
    \ = false;\n        }\n    }\n    int num_count = 0;\n    for (int i = 0; i <\
    \ file_name.length; i++)\n    {\n        if (file_name[i] >= '0' && file_name[i]\
    \ <= '9')\n        {\n            num_count++;\n        }\n    }\n    if (num_count\
    \ > 3)\n    {\n        return \"No\";\n    }\n    else\n    {\n        if (dot_valid\
    \ && ext_valid && valid_before_dot)\n        {\n            return \"Yes\";\n\
    \        }\n        else\n        {\n            return \"No\";\n        }\n \
    \   }\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpri0dk3v7.d(22): Error: no property `find` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpri0dk3v7.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    auto parts = split(file_name, \".\");\n    import std.string;\n\
    \    if (parts.length != 2) return \"No\";\n    if (parts[0].length == 0) return\
    \ \"No\";\n    if (parts[0].any!(c => c.isDigit)) return \"No\";\n    if (parts[0].count!(c\
    \ => c.isDigit) > 3) return \"No\";\n    if (parts[1] == \"txt\" || parts[1] ==\
    \ \"exe\" || parts[1] == \"dll\") return \"Yes\";\n    return \"No\";\n}\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpl_a4sywo.d(20): Error: undefined identifier `split`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl_a4sywo.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string res = \"No\";\n    int n = file_name.length;\n  \
    \  int cnt = 0;\n    if (n == 0) return res;\n    bool not_letter = false;\n \
    \   bool dot_found = false;\n    int dot_pos = -1;\n    for (int i = 0; i < n;\
    \ i++) {\n        if (isalpha(file_name[i])) not_letter = true;\n        if (isdigit(file_name[i]))\
    \ cnt++;\n        if (file_name[i] == '.') {\n            dot_found = true;\n\
    \            dot_pos = i;\n        }\n    }\n    if (cnt > 3) return res;\n  \
    \  if (!dot_found) return res;\n    if (dot_pos == 0) return res;\n    if (dot_pos\
    \ == n - 1) return res;\n    string before_dot = file_name[0..dot_pos-1];\n  \
    \  string after_dot = file_name[dot_pos+1..$];\n    if (before_dot.length == 0)\
    \ return res;\n    if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot\
    \ != \"dll\") return res;\n    if (!not_letter) return res;\n    return \"Yes\"\
    ;\n}\n/*\nA palindrome number is a number which reads the same forwards and backwards.\n\
    \    Create a function which takes a number as argument, and returns 'Yes' if\
    \ the number is\n    palindrome, and returns 'No' otherwise.\n*/\nstring palindrome_check(int\
    \ n) \n{\n    if (n < 0) return \"No\";\n    string res = \"Yes\";\n    int x\
    \ = n;\n    int y = 0;\n    while (x > 0) {\n        y = 10 * y + x % 10;\n  \
    \      x /= 10;\n    }\n    if (y != n) return \"No\";\n    return res;\n}\n/*\n\
    An integer number is a prime number if it has exactly two divisors: 1 and the\
    \ number itself.\n    Create a function which takes a number as argument, and\
    \ returns 'Yes' if the number is \nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp97inied7.d(64): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp97inied7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    enum file_name_check(string file_name)\n    {\n        int\
    \ indexOf = find(file_name, '.');\n        if (file_name[indexOf] == '.')\n  \
    \      {\n            if (file_name[indexOf-1] == 'e' &&\n                file_name[indexOf-2]\
    \ == 'x' &&\n                file_name[indexOf-3] == 't' &&\n                file_name[indexOf-4]\
    \ == '.')\n                return \"Yes\";\n            else if (file_name[indexOf-1]\
    \ == 'd' &&\n                file_name[indexOf-2] == 'l' &&\n                file_name[indexOf-3]\
    \ == 'l' &&\n                file_name[indexOf-4] == '.')\n                return\
    \ \"Yes\";\n            else if (file_name[indexOf-1] == 'x' &&\n            \
    \    file_name[indexOf-2] == 'e' &&\n                file_name[indexOf-3] == 'e'\
    \ &&\n                file_name[indexOf-4] == '.')\n                return \"\
    Yes\";\n            else\n                return \"No\";\n        }\n        else\n\
    \            return \"No\";\n    }\n}\n/*\nCreate a function which takes a string\
    \ representing a file's name, and returns\n    a string of the file's extension\
    \ name.\n    Assume that all files have at most one dot in their names.\n    Examples:\n\
    \    get_extension_name(\"example.txt\") # => 'txt'\n    get_extension_name(\"\
    CMakeLists.txt\") # => 'txt'\n    get_extension_name(\"file.txt.exe\") # => 'exe'\n\
    \    get_extension_name(\"file.txt\") # => 'txt'\n*/\nstring get_extension_name(string\
    \ file_name) \n{\n    enum get_extension_name(string file_name)\n    {\n     \
    \   int indexOf = find(file_name, '.');\n        return file_name[indexOf-1..$];\n\
    \    }\n}\n/*\nCreate a function which returns true if the given string represents\
    \ a valid file name,\n    and\nunittest\n{\n    alias candidate = file_name_check;\n\
    \n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"\
    1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n\
    \    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\"\
    ) == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp__k840ge.d(65): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp__k840ge.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string first_name = \"\";\n    string last_name = \"\";\n\
    \    string extension = \"\";\n    string numbers = \"0123456789\";\n    string\
    \ letters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    string\
    \ extensions = \"txtexeDLL\";\n    bool has_dot = false;\n    bool first_name_is_valid\
    \ = false;\n    bool last_name_is_valid = false;\n    int dots = 0;\n    int digits\
    \ = 0;\n    int last_name_length = 0;\n    int first_name_length = 0;\n    int\
    \ extension_length = 0;\n    //string[] valid_extensions = [\"txt\", \"exe\",\
    \ \"dll\"];\n    for (int i = 0; i < file_name.length; i++)\n    {\n        if\
    \ (file_name[i] == '.')\n        {\n            has_dot = true;\n            dots++;\n\
    \        }\n        else if (file_name[i] == '.')\n        {\n            dots++;\n\
    \        }\n        else if (extensions.contains(file_name[i]))\n        {\n \
    \           last_name_is_valid = true;\n            last_name += file_name[i];\n\
    \            last_name_length++;\n        }\n        else if (numbers.contains(file_name[i]))\n\
    \        {\n            digits++;\n        }\n        else if (letters.contains(file_name[i]))\n\
    \        {\n            first_name_is_valid = true;\n            first_name +=\
    \ file_name[i];\n            first_name_length++;\n        }\n    }\n    if (last_name_length\
    \ != 0)\n    {\n        if (digits <= 3 && dots == 1 && has_dot && first_name_is_valid\
    \ && last_name_is_valid)\n        {\n            return \"Yes\";\n        }\n\
    \        else\n        {\n            return \"No\";\n        }\n    }\n    else\n\
    \    {\n        return \"No\";\n    }\n    //return \"No\";\n}\n/*\n\nunittest\n\
    {\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\"\
    ) == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"\
    s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp354ijtye.d(80): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp354ijtye.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n\tstring fname = file_name;\n\tint dot_pos = find(fname,\".\"\
    );\n\tstring sub_fname = fname[0..dot_pos];\n\tstring sub_fname_1 = fname[dot_pos..$];\n\
    \tsub_fname_1[0] = ' ';\n\tsub_fname_1 = sub_fname_1.stripLeft();\n\tif(sub_fname[0].isLetter\
    \ && !sub_fname[1..$].isAlpha)\n\t{\n\t\tif(sub_fname_1 == \"txt\" || sub_fname_1\
    \ == \"exe\" || sub_fname_1 == \"dll\")\n\t\t{\n\t\t\treturn \"Yes\";\n\t\t}\n\
    \t\telse\n\t\t{\n\t\t\treturn \"No\";\n\t\t}\n\t}\n\telse\n\t{\n\t\treturn \"\
    No\";\n\t}\n\t\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n   \
    \ assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\"\
    ) == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5asuh_ex.d(21): Error: undefined identifier `find`, did you mean\
    \ template `Bind(alias Template, args1...)`?\\n/tmp/tmp5asuh_ex.d(24): Error:\
    \ cannot modify `immutable` expression `sub_fname_1[0]`\\n/tmp/tmp5asuh_ex.d(25):\
    \ Error: no property `stripLeft` for type `string`\\n/tmp/tmp5asuh_ex.d(26): Error:\
    \ no property `isLetter` for type `immutable(char)`\\n/tmp/tmp5asuh_ex.d(26):\
    \ Error: no property `isAlpha` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp5asuh_ex.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    int digit = 0;\n    string sub1 = \"\";\n    string sub2\
    \ = \"\";\n    bool flag1 = false;\n    bool flag2 = false;\n    bool flag3 =\
    \ false;\n    bool flag4 = false;\n    bool flag5 = false;\n    bool flag6 = false;\n\
    \    for(int i = 0; i < file_name.length; i++)\n    {\n        if(!flag1 && (file_name[i]\
    \ < '0' || file_name[i] > '9'))\n        {\n            flag1 = true;\n      \
    \      if(i != 0)\n            {\n                sub1 = file_name[0..i];\n  \
    \              if(file_name[i] == '.')\n                {\n                  \
    \  flag2 = true;\n                    flag3 = true;\n                }\n     \
    \       }\n        }\n        else if(flag1 && !flag2 && file_name[i] == '.')\n\
    \        {\n            flag2 = true;\n            sub2 = file_name[i+1..$];\n\
    \        }\n        else if(!flag2 && file_name[i] >= '0' && file_name[i] <= '9')\n\
    \        {\n            digit++;\n        }\n        else if(flag2 && !flag3 &&\
    \ (file_name[i] < '0' || file_name[i] > '9'))\n        {\n            flag3 =\
    \ true;\n            sub2 = file_name[i..$];\n        }\n        else if(flag3\
    \ && !flag4 && file_name[i] < 'a' && file_name[i] > 'z')\n        {\n        \
    \    return \"No\";\n        }\n        else if(flag3 && !flag4 && file_name[i]\
    \ >= 'a' && file_name[i] <= 'z')\n        {\n            flag4 = true;\n     \
    \   }\n        else if(flag3 && !flag5 && file_name[i] < 'A' && file_name[i] >\
    \ 'Z')\n        {\n            return \"No\";\n        }\n        else if(flag3\
    \ && !flag5 && file_name[i] >= 'A' && file_\nunittest\n{\n    alias candidate\
    \ = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n \
    \   assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\"\
    ) == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"\
    MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"\
    No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"\
    ?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"\
    No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
    this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
    ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n \
    \   assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
    this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\"\
    ) == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
    Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") ==\
    \ \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
    I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\"\
    );\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
    ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
    s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgbkb35qh.d(71): Error: found `unittest` when expecting `)`\\\
    n/tmp/tmpgbkb35qh.d(102): Error: found `End of File` when expecting `}` following\
    \ compound statement\\n/tmp/tmpgbkb35qh.d(102): Error: found `End of File` when\
    \ expecting `}` following compound statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpgbkb35qh.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
    \ a string representing a file's name, and returns\n    'Yes' if the the file's\
    \ name is valid, and returns 'No' otherwise.\n    A file's name is considered\
    \ to be valid if and only if all the following conditions \n    are met:\n   \
    \ - There should not be more than three digits ('0'-'9') in the file's name.\n\
    \    - The file's name contains exactly one dot '.'\n    - The substring before\
    \ the dot should not be empty, and it starts with a letter from \n    the latin\
    \ alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be\
    \ one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\"\
    ) # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should\
    \ start with a latin alphapet letter)\n    \n*/\nstring file_name_check(string\
    \ file_name) \n{\n    string[] sub_strings = file_name.split(\".\");\n    if (sub_strings.length\
    \ == 2) \n    {\n        string[] numbers = sub_strings[0].split(\"[0-9]\");\n\
    \        if ((sub_strings[1] == \"txt\" || sub_strings[1] == \"exe\" || sub_strings[1]\
    \ == \"dll\") && (sub_strings[0].length > 0) && (numbers.length == 1))\n     \
    \   {\n            return \"Yes\";\n        }\n    }\n    return \"No\";\n}\n\
    unittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
    example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\"\
    );\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"\
    K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n\
    \    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"\
    _Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"\
    /this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\"\
    ) == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"\
    this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\"\
    ) == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n  \
    \  assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"\
    all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n\
    \    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"\
    no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") ==\
    \ \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"\
    final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n  \
    \  assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\"\
    .txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8jh9yc2d.d(20): Error: no property `split` for type `string`\\\
    n/tmp/tmp8jh9yc2d.d(23): Error: no property `split` for type `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8jh9yc2d.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
