name: HumanEval_0_has_close_elements
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n Check if in given list of numbers,\
  \ are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0,\
  \ 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0,\
  \ 2.0], 0.3)\n    True\n    \n*/\nbool has_close_elements(float[] numbers, float\
  \ threshold) \n"
tests: "unittest\n{\n    alias candidate = has_close_elements;\n\n    assert(candidate([1.0,\
  \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == true);\n    assert(candidate([1.0, 2.0, 3.9,\
  \ 4.0, 5.0, 2.2], 0.05) == false);\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0],\
  \ 0.95) == true);\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == false);\n\
  \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == true);\n    assert(candidate([1.1,\
  \ 2.2, 3.1, 4.1, 5.1], 1.0) == true);\n    assert(candidate([1.1, 2.2, 3.1, 4.1,\
  \ 5.1], 0.5) == false);\n}\nvoid main(){}"
completions: ["{\n    bool result = false;\n    foreach(number; numbers)\n    {\n\
    \        if(number < threshold)\n        {\n            result = true;\n     \
    \       break;\n        }\n    }\n    return result;\n}", "{\n    float min_diff\
    \ = 1000000.0;\n    float diff;\n    foreach(v; numbers)\n    {\n        diff\
    \ = v - numbers[0];\n        if(diff < min_diff)\n        {\n            min_diff\
    \ = diff;\n        }\n    }\n    return min_diff < threshold;\n}", "    pure nothrow\
    \ nogc {\n    foreach (i, number; numbers) {\n        foreach (j, other; numbers[i\
    \ + 1 .. $]) {\n            if (abs(number - other) < threshold)\n           \
    \     return true;\n        }\n    }\n    return false;\n}\n/*\n  Calculate the\
    \ length of the longest increasing sublist in a given list of numbers.\n    >>>\
    \ length_of_longest_increasing_sublist([1.0, 2.0, 3.0])\n    3\n    >>> length_of_longest_increasing_sublist([1.0,\
    \ 3.0, 2.0, 4.0, 5.0, 0.0])\n    3\n    >>> length_of_longest_increasing_sublist([])\n\
    \    0\n*/\nsize_t length_of_longest_increasing_sublist(float[] numbers)\n   \
    \ pure nothrow nogc {\n    if (numbers.length == 0)\n        return 0;\n    size_t\
    \ longest_length = 1;\n    foreach (i, number; numbers) {\n        size_t current_length\
    \ = 1;\n        foreach (j, other; numbers[i + 1 .. $]) {\n            if (other\
    \ > number) {\n                current_length++;\n                number = other;\n\
    \            }\n        }\n        if (current_length > longest_length)\n    \
    \        longest_length = current_length;\n    }\n    return longest_length;\n\
    }\n/*\n  Representation of a 2D interval defined by a start and end point.\n*/\n\
    struct Interval {\n    float start;\n    float end;\n}\n/*\n  Check if given interval\
    \ is inside (the start and end points are both larger than)\n  given other interval.\n\
    \    >>> (1.0 .. 3.0).is_inside(0.0 .. 2.0)\n    False\n    >>> (1.0 .. 3.0).is_inside(2.0\
    \ .. 4.0)\n    True\n    >>> (1.0 .. 3.0).is_inside(1.0 .. 3.0)\n    True\n*/",
  "{\n    float min = infinity;\n    for (uint i = 0; i < numbers.length; i++)\n \
    \   {\n        for (uint j = i+1; j < numbers.length; j++)\n        {\n      \
    \      float abs = abs(numbers[i] - numbers[j]);\n            if (abs < min)\n\
    \            {\n                min = abs;\n            }\n        }\n    }\n\
    \    return min < threshold;\n}", "{\n    foreach(a; numbers)\n    {\n       \
    \ foreach(b; numbers)\n        {\n            if(abs(a-b) < threshold)\n     \
    \       {\n                return true;\n            }\n        }\n    }\n   \
    \ return false;\n}\n/*\n    Sums numbers in given range.\n    >>> sum_range(0,\
    \ 1)\n    1\n    >>> sum_range(0, 9)\n    45\n    >>> sum_range(0, 99)\n    4950\n\
    */", "{\n\tint n = numbers.length;\n\tforeach(int i; 0..n) \n\t{\n\t\tforeach(int\
    \ j; (i+1)..n) \n\t\t{\n\t\t\tif(abs(numbers[i] - numbers[j]) < threshold) \n\t\
    \t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}", "{\n  \
    \  immutable size = numbers.length;\n    if (size < 2)\n        return false;\n\
    \    float distance = abs(numbers[0] - numbers[1]);\n    auto result = distance\
    \ < threshold;\n    for (size_t i = 0; i < size - 1; i++)\n    {\n        for\
    \ (size_t j = i + 1; j < size; j++)\n        {\n            float d = abs(numbers[i]\
    \ - numbers[j]);\n            if (d < distance)\n                distance = d;\n\
    \            if (distance < threshold)\n                return true;\n       \
    \ }\n    }\n    return result;\n}", "{\n\tint j = 0;\n\tforeach(numbers; number)\n\
    \t{\n\t\tfor(int i = 0; i < j; i++)\n\t\t{\n\t\t\tif(abs(numbers[i] - number)\
    \ < threshold)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tj++;\n\t}\n\
    \treturn false;\n}\n/*\n    Check if in given list of numbers, are any two numbers\
    \ closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0,\
    \ 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0,\
    \ 5.0, 2.0], 0.3)\n    True\n    \n*/", "{\n    float[] distances;\n    foreach(i,\
    \ n; numbers) \n    {\n        distances ~= abs(numbers[i] - numbers[i+1]);\n\
    \    }\n    return min(distances) < threshold;\n}", "{\n    foreach(i, e1; numbers)\n\
    \    {\n        foreach(j, e2; numbers)\n        {\n            if(j > i)\n  \
    \          {\n                if(abs(e1 - e2) < threshold)\n                {\n\
    \                    return true;\n                }\n            }\n        }\n\
    \    }\n    return false;\n}\n \n \n/*\n Check if in given list of numbers, are\
    \ any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0,\
    \ 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0,\
    \ 5.0, 2.0], 0.3)\n    True\n    \n*/", "{\n    foreach(i, a; numbers)\n    {\n\
    \        foreach(j, b; numbers)\n        {\n            if (i >= j)\n        \
    \        continue;\n            if (abs(a - b) < threshold)\n                return\
    \ true;\n        }\n    }\n    return false;\n}", "in\n{\n    assert(all!(elem\
    \ => elem >= 0.0, numbers));\n    assert(threshold >= 0.0);\n}\nbody\n{\n    bool\
    \ are_close;\n    foreach(index, number; numbers)\n    {\n        foreach(index2,\
    \ number2; numbers)\n        {\n            if(index != index2)\n            {\n\
    \                are_close = abs(number - number2) < threshold;\n            \
    \    if(are_close)\n                {\n                    return true;\n    \
    \            }\n            }\n        }\n    }\n    return false;\n}", "    if\
    \ (numbers.length < 2) return false;\n    for (size_t i = 0; i < numbers.length;\
    \ i++)\n    {\n        for (size_t j = i + 1; j < numbers.length; j++)\n     \
    \   {\n            if (abs(numbers[i] - numbers[j]) < threshold)\n           \
    \     return true;\n        }\n    }\n    return false;\n}", "{\n  int n = numbers.length;\n\
    \  for (int i = 0; i < n; i++) \n  {\n    for (int j = i + 1; j < n; j++) \n \
    \   {\n      if (abs(numbers[i] - numbers[j]) < threshold) \n      {\n       \
    \ return true;\n      }\n    }\n  }\n  return false;\n}", "{\n    /*\n     + Check\
    \ if there are less than 2 elements\n     + Sort the list\n     + Iterate over\
    \ elements and check if difference of \n       element with next is less than\
    \ threshold.\n    */\n    numbers.sort;\n    auto it = numbers.next;\n    while(it\
    \ != numbers.length)\n    {\n        float diff = abs(numbers[it]-numbers[it+1]);\n\
    \        if(diff < threshold)\n            return true;\n        it++;\n    }\n\
    \    return false;\n}", "{\n    bool has_close_elems = false;\n    foreach(i;\
    \ 0 .. numbers.length) \n    {\n        foreach(j; i+1 .. numbers.length) \n \
    \       {\n            if (abs(numbers[i] - numbers[j]) < threshold) \n      \
    \      {\n                has_close_elems = true;\n            }\n        }\n\
    \    }\n    return has_close_elems;\n}\n/*\n Check if in given list of numbers,\
    \ are any two numbers closer to each other than\n    given threshold.\n    >>>\
    \ has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0,\
    \ 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \n*/", "{\n    float[] sorted_numbers\
    \ = sort(numbers);", "{\n    bool flag = false;\n    float min = 0.0;\n    float\
    \ max = 0.0;\n    int min_index = 0;\n    int max_index = 0;\n    foreach(immutable\
    \ index, immutable number; numbers) \n    {\n        if(number < min) \n     \
    \   {\n            min = number;\n            min_index = index;\n        }\n\
    \        if(number > max) \n        {\n            max = number;\n           \
    \ max_index = index;\n        }\n    }\n    foreach(immutable index, immutable\
    \ number; numbers) \n    {\n        if(index == min_index || index == max_index)\
    \ \n        {\n            continue;\n        }\n        if(abs(number - min)\
    \ < threshold || abs(number - max) < threshold) \n        {\n            flag\
    \ = true;\n            break;\n        }\n    }\n    return flag;\n}", "{\n  \
    \  bool has_close_elements = false;\n    foreach(n1; numbers)\n    {\n       \
    \ foreach(n2; numbers)\n        {\n            if (n1 != n2)\n            {\n\
    \                has_close_elements = abs(n1 - n2) < threshold;\n            \
    \    if (has_close_elements)\n                    break;\n            }\n    \
    \    }\n        if (has_close_elements)\n            break;\n    }\n    return\
    \ has_close_elements;\n}", "{\n\tfor (uint i = 0; i < numbers.length; i++)\n\t\
    {\n\t\tfor (uint j = i + 1; j < numbers.length; j++)\n\t\t{\n\t\t\tif (abs(numbers[i]\
    \ - numbers[j]) < threshold)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\
    }\n\treturn false;\n}\n/*\nYou have a list of words. Return a dictionary that\
    \ contains, for each word, \n    list of words from the given list that are anagrams\
    \ of the word.\n    Anagrams are words made by using exactly the same letters\
    \ in exactly the \n    same quantity, e.g. orchestra and carthorse.\n    >>> get_anagrams([\"\
    orchestra\", \"carthorse\", \"radishes\"])\n    {\"orchestra\": [\"carthorse\"\
    ], \"carthorse\": [\"orchestra\"], \"radishes\": []}\n*/\nMap!(string, string[])\
    \ get_anagrams(string[] words) \n{\n\tMap!(string, string[]) result = new Map!(string,\
    \ string[]);\n\tfor (uint i = 0; i < words.length; i++)\n\t{\n\t\tstring[] anagrams\
    \ = new string[];\n\t\tfor (uint j = 0; j < words.length; j++)\n\t\t{\n\t\t\t\
    if (i != j && words[i].length == words[j].length)\n\t\t\t{\n\t\t\t\tuint[] word1count\
    \ = new uint[256];\n\t\t\t\tuint[] word2count = new uint[256];\n\t\t\t\tforeach\
    \ (uint c; words[i])\n\t\t\t\t{\n\t\t\t\t\tword1count[c]++;\n\t\t\t\t}\n\t\t\t\
    \tforeach (uint c; words[j])\n\t\t\t\t{\n\t\t\t\t\tword2count[c]++;\n\t\t\t\t\
    }\n\t\t\t\tif (word1count == word2count)\n\t\t\t\t{\n\t\t\t\t\tanagrams ~= words[j];\n\
    \t\t\t\t}\n\t\t\t}\n\t\t"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
