name: HumanEval_17_parse_music
language: d
results:
- program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string representing musical notes in a special ASCII format.\n    Your task\
    \ is to parse this string and return list of integers corresponding to how many\
    \ beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note,\
    \ lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note,\
    \ lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n   \
    \ [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \n*/\nlong[] parse_music(string music_string)\
    \ \n{\n    long[] result = [];\n    enum Sign {\n        WHOLE,\n        HALF,\n\
    \        QUARTER\n    }\n    Sign sign;\n    foreach(i; 0 .. music_string.length)\
    \ {\n        char ch = music_string[i];\n        if(ch == 'o') {\n           \
    \ if(i == music_string.length - 1 || music_string[i + 1] == ' ') {\n         \
    \       sign = Sign.WHOLE;\n            } else {\n                sign = Sign.HALF;\n\
    \            }\n        } else if(ch == '.') {\n            sign = Sign.QUARTER;\n\
    \        } else if(ch == '|') {\n            switch(sign) {\n                case\
    \ Sign.WHOLE:\n                    result ~= 4;\n                    break;\n\
    \                case Sign.HALF:\n                    result ~= 2;\n         \
    \           break;\n                case Sign.QUARTER:\n                    result\
    \ ~= 1;\n                    break;\n            }\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = parse_music;\n\n    assert(candidate(\"\
    \") == []);\n    assert(candidate(\"o o o o\") == [4L, 4L, 4L, 4L]);\n    assert(candidate(\"\
    .| .| .| .|\") == [1L, 1L, 1L, 1L]);\n    assert(candidate(\"o| o| .| .| o o o\
    \ o\") == [2L, 2L, 1L, 1L, 4L, 4L, 4L, 4L]);\n    assert(candidate(\"o| .| o|\
    \ .| o o| o o|\") == [2L, 1L, 2L, 1L, 4L, 2L, 4L, 2L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpffejnxtu.d(37): Error: `switch` statement without a `default`;\
    \ use `final switch` or add `default: assert(0);` or add `default: break;`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpffejnxtu.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string representing musical notes in a special ASCII format.\n    Your task\
    \ is to parse this string and return list of integers corresponding to how many\
    \ beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note,\
    \ lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note,\
    \ lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n   \
    \ [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \n*/\nlong[] parse_music(string music_string)\
    \ \n{\n    import std.string : split;\n    import std.algorithm.searching : contains;\n\
    \    import std.range : map;\n    string music_template = \"oo|.|o|\";\n    long[]\
    \ music = [].init;\n    foreach(char c; music_string.split(\" \"))\n    {\n  \
    \      if(c == 'o')\n        {\n            music ~= 4;\n        }\n        else\
    \ if(c == 'o|')\n        {\n            music ~= 2;\n        }\n        else if(c\
    \ == '.|')\n        {\n            music ~= 1;\n        }\n    }\n    return music;\n\
    }\n/*\n    Output result is a list of integers corresponding to how many beats\
    \ does each not last.\nunittest\n{\n    alias candidate = parse_music;\n\n   \
    \ assert(candidate(\"\") == []);\n    assert(candidate(\"o o o o\") == [4L, 4L,\
    \ 4L, 4L]);\n    assert(candidate(\".| .| .| .|\") == [1L, 1L, 1L, 1L]);\n   \
    \ assert(candidate(\"o| o| .| .| o o o o\") == [2L, 2L, 1L, 1L, 4L, 4L, 4L, 4L]);\n\
    \    assert(candidate(\"o| .| o| .| o o| o o|\") == [2L, 1L, 2L, 1L, 4L, 2L, 4L,\
    \ 2L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc5kb92cj.d(30): Error: unterminated character constant\\n/tmp/tmpc5kb92cj.d(30):\
    \ Error: `c == \\'?\\'` must be parenthesized when next to operator `|`\\n/tmp/tmpc5kb92cj.d(30):\
    \ Error: unterminated character constant\\n/tmp/tmpc5kb92cj.d(31): Error: found\
    \ `{` when expecting `)`\\n/tmp/tmpc5kb92cj.d(34): Error: found `else` without\
    \ a corresponding `if`, `version` or `debug` statement\\n/tmp/tmpc5kb92cj.d(34):\
    \ Error: unterminated character constant\\n/tmp/tmpc5kb92cj.d(34): Error: unterminated\
    \ character constant\\n/tmp/tmpc5kb92cj.d(38): Error: unrecognized declaration\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc5kb92cj.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string representing musical notes in a special ASCII format.\n    Your task\
    \ is to parse this string and return list of integers corresponding to how many\
    \ beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note,\
    \ lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note,\
    \ lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n   \
    \ [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \n*/\nlong[] parse_music(string music_string)\
    \ \n{\n    long[] res = [];\n    foreach(i; 0 .. music_string.length - 1)\n  \
    \  {\n        if(music_string[i] == 'o')\n        {\n            if(music_string[i\
    \ + 1] == ' ' || music_string[i + 1] == '\\n')\n            {\n              \
    \  res ~= 4;\n            }\n            else if(music_string[i + 1] == '|')\n\
    \            {\n                if(music_string[i + 2] == ' ' || music_string[i\
    \ + 2] == '\\n')\n                {\n                    res ~= 2;\n         \
    \       }\n                else if(music_string[i + 2] == '|')\n             \
    \   {\n                    res ~= 1;\n                }\n            }\n     \
    \   }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = parse_music;\n\
    \n    assert(candidate(\"\") == []);\n    assert(candidate(\"o o o o\") == [4L,\
    \ 4L, 4L, 4L]);\n    assert(candidate(\".| .| .| .|\") == [1L, 1L, 1L, 1L]);\n\
    \    assert(candidate(\"o| o| .| .| o o o o\") == [2L, 2L, 1L, 1L, 4L, 4L, 4L,\
    \ 4L]);\n    assert(candidate(\"o| .| o| .| o o| o o|\") == [2L, 1L, 2L, 1L, 4L,\
    \ 2L, 4L, 2L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.RangeError@/tmp/tmpjo_fintl.d(22): Range violation\\n----------------\\\
    n??:? _d_arrayboundsp [0x4286be]\\n??:? long[] tmpjo_fintl.parse_music(immutable(char)[])\
    \ [0x427e91]\\n??:? void tmpjo_fintl.__unittest_L43_C1() [0x42806c]\\n??:? void\
    \ tmpjo_fintl.__modtest() [0x42838c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d07b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42bf0e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430961]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430e10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4308ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42bee5]\\n??:? runModuleUnitTests [0x42ce51]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ad0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428a57]\\n??:? _d_run_main [0x4289c2]\\n??:? main [0x42839f]\\\
    n??:? __libc_start_main [0xb63ef554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string representing musical notes in a special ASCII format.\n    Your task\
    \ is to parse this string and return list of integers corresponding to how many\
    \ beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note,\
    \ lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note,\
    \ lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n   \
    \ [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \n*/\nlong[] parse_music(string music_string)\
    \ \n{\n\tlong[] b;\n\tchar[] notes = music_string.dup.split(' ');\n\tforeach(char\
    \ n; notes)\n\t{\n\t\tswitch(n)\n\t\t{\n\t\t\tcase 'o':\n\t\t\t\tb ~= 4;\n\t\t\
    \t\tbreak;\n\t\t\tcase 'o|':\n\t\t\t\tb ~= 2;\n\t\t\t\tbreak;\n\t\t\tcase '.|':\n\
    \t\t\t\tb ~= 1;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn b;\n}\nunittest\n{\n   \
    \ alias candidate = parse_music;\n\n    assert(candidate(\"\") == []);\n    assert(candidate(\"\
    o o o o\") == [4L, 4L, 4L, 4L]);\n    assert(candidate(\".| .| .| .|\") == [1L,\
    \ 1L, 1L, 1L]);\n    assert(candidate(\"o| o| .| .| o o o o\") == [2L, 2L, 1L,\
    \ 1L, 4L, 4L, 4L, 4L]);\n    assert(candidate(\"o| .| o| .| o o| o o|\") == [2L,\
    \ 1L, 2L, 1L, 4L, 2L, 4L, 2L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp49o4gqr7.d(28): Error: unterminated character constant\\n/tmp/tmp49o4gqr7.d(28):\
    \ Error: unterminated character constant\\n/tmp/tmp49o4gqr7.d(29): Error: found\
    \ `b` when expecting `:`\\n/tmp/tmp49o4gqr7.d(29): Error: found `~=` instead of\
    \ statement\\n/tmp/tmp49o4gqr7.d(31): Error: unterminated character constant\\\
    n/tmp/tmp49o4gqr7.d(31): Error: unterminated character constant\\n/tmp/tmp49o4gqr7.d(32):\
    \ Error: found `b` when expecting `:`\\n/tmp/tmp49o4gqr7.d(32): Error: found `~=`\
    \ instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmp49o4gqr7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string representing musical notes in a special ASCII format.\n    Your task\
    \ is to parse this string and return list of integers corresponding to how many\
    \ beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note,\
    \ lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note,\
    \ lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n   \
    \ [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \n*/\nlong[] parse_music(string music_string)\
    \ \n{\n\tlong[] music = new long[music_string.length];\n\tint n = 0;\n\tforeach(c;\
    \ music_string) \n\t{\n\t\tif(c == 'o') \n\t\t{\n\t\t\tmusic[n] = 4;\n\t\t\tn++;\n\
    \t\t}\n\t\telse if(c == '.') \n\t\t{\n\t\t\tmusic[n] = 1;\n\t\t\tn++;\n\t\t}\n\
    \t}\n\treturn music;\n}\nunittest\n{\n    alias candidate = parse_music;\n\n \
    \   assert(candidate(\"\") == []);\n    assert(candidate(\"o o o o\") == [4L,\
    \ 4L, 4L, 4L]);\n    assert(candidate(\".| .| .| .|\") == [1L, 1L, 1L, 1L]);\n\
    \    assert(candidate(\"o| o| .| .| o o o o\") == [2L, 2L, 1L, 1L, 4L, 4L, 4L,\
    \ 4L]);\n    assert(candidate(\"o| .| o| .| o o| o o|\") == [2L, 1L, 2L, 1L, 4L,\
    \ 2L, 4L, 2L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpqw4gny_4.d(41): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4284cd]\\n??:? void tmpqw4gny_4.__unittest_L36_C1()\
    \ [0x427fe7]\\n??:? void tmpqw4gny_4.__modtest() [0x42824c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c5ab]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b43e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4306c9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430b78]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430655]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b415]\\n??:? runModuleUnitTests [0x42c381]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428990]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428917]\\n??:? _d_run_main [0x428882]\\n??:? main [0x42825f]\\\
    n??:? __libc_start_main [0xe6421554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string representing musical notes in a special ASCII format.\n    Your task\
    \ is to parse this string and return list of integers corresponding to how many\
    \ beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note,\
    \ lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note,\
    \ lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n   \
    \ [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \n*/\nlong[] parse_music(string music_string)\
    \ \n{\n    return music_string.compressWhitespace().split(\" \").map!(a => a ==\
    \ \"o\" ? 4 : a == \"o|\" ? 2 : 1).array;\n}\n/*\n    Create a generic class BinaryTree\
    \ which holds a value of some type T\n    and two pointers to other BinaryTrees.\n\
    \    \n    Add constructors to BinaryTree(T value) and BinaryTree(T value, BinaryTree\
    \ left, BinaryTree right).\n    \n    Add a method find_parent_of(T value) which\
    \ returns reference to the parent BinaryTree of the\n    node with value = value,\
    \ or throws an exception if a node with that value is not present.\n    \n   \
    \ >>> t = BinaryTree(1, BinaryTree(2, BinaryTree(4), BinaryTree(5)), BinaryTree(3))\n\
    \    >>> t.find_parent_of(5).value\n    2\n    >>> t.find_parent_of(3).value\n\
    \    1\n    \n*/\n//@nogc\nclass BinaryTree(T)\n{\n    T value;\n    BinaryTree\
    \ left;\n    BinaryTree right;\n    \n    this(T value)\n    {\n        this.value\
    \ = value;\n    }\n    \n    this(T value, BinaryTree left, BinaryTree right)\n\
    \    {\n        this.value = value;\n        this.left = left;\n        this.right\
    \ = right;\n    }\n    \n    BinaryTree find_parent_of(T value)\n    {\n     \
    \   if (left.value == value || right.value == value)\n            return this;\n\
    \        else if (left)\n            return left.find_parent_of(value);\n    \
    \    else if (right)\n            return right.find_parent_of(value);\n      \
    \  else\n            throw new Exception(\"Node not found\");\n    }\n}\n/*\n\
    \    Implement an interface named IPost\n    which has a read-only property title\
    \ of type string and a property content of type int[].\n    \n    >>> auto p =\
    \ new Post();\n    >>> p.title = \"Hello\";\n    >>> p.content = [1, 2, 3];\n\
    \    >>> IPost p2 = p;\n    >>> p2.title\n    \"Hello\"\n\nunittest\n{\n    alias\
    \ candidate = parse_music;\n\n    assert(candidate(\"\") == []);\n    assert(candidate(\"\
    o o o o\") == [4L, 4L, 4L, 4L]);\n    assert(candidate(\".| .| .| .|\") == [1L,\
    \ 1L, 1L, 1L]);\n    assert(candidate(\"o| o| .| .| o o o o\") == [2L, 2L, 1L,\
    \ 1L, 4L, 4L, 4L, 4L]);\n    assert(candidate(\"o| .| o| .| o o| o o|\") == [2L,\
    \ 1L, 2L, 1L, 4L, 2L, 4L, 2L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpp8apvw0y.d(68): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp8apvw0y.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string representing musical notes in a special ASCII format.\n    Your task\
    \ is to parse this string and return list of integers corresponding to how many\
    \ beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note,\
    \ lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note,\
    \ lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n   \
    \ [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \n*/\nlong[] parse_music(string music_string)\
    \ \n{\n    int num_chars = music_string.length;\n    long[] res = new long[];\n\
    \    foreach(i; 0 .. num_chars)\n    {\n        if(music_string[i] == 'o')\n \
    \       {\n            if(i+1 < num_chars)\n            {\n                if(music_string[i+1]\
    \ == '|')\n                {\n                    res ~= 2;\n                \
    \    ++i;\n                }\n                else\n                {\n      \
    \              res ~= 4;\n                }\n            }\n            else\n\
    \            {\n                res ~= 4;\n            }\n        }\n        else\
    \ if(music_string[i] == '.')\n        {\n            res ~= 1;\n            ++i;\n\
    \        }\n    }\n    return res;\n}\n/*\n Write a function for creating 2D array\
    \ of integers with the size of 'side_len' and initialized to the value 'init_val'.\n\
    \ >>> create_2d_array(3,4)\n [[4, 4, 4], [4, 4, 4], [4, 4, 4]]\n >>> create_2d_array(2,0)\n\
    \ [[0, 0], [0, 0]]\n */\nlong[][] create_2d_array(long side_len, long init_val)\n\
    {\n    long[][] res = new long[][];\n    foreach(i; 0 .. side_len)\n    {\n  \
    \      res ~= new long[];\n        foreach(j; 0 .. side_len)\n        {\n    \
    \        res[i] ~= init_val;\n        }\n    }\n    return res;\n}\n/*\nWrite\
    \ a function that takes a list of integers (positive and negative) and return\
    \ a tuple of two integers:\n    1. count of positives numbers\n    2. count of\
    \ negatives numbers\n    3. count of zeros.\n    >>> stats([1, 2, 0, 1, 0, -1,\
    \ 2, -3, -4, 2, 1, 0])\n    (7, 4, 3)\n*/\nTuple!(long, long, long) stats(int[]\
    \ arr)\n{\n    long num_positives = 0;\n    long\nunittest\n{\n    alias candidate\
    \ = parse_music;\n\n    assert(candidate(\"\") == []);\n    assert(candidate(\"\
    o o o o\") == [4L, 4L, 4L, 4L]);\n    assert(candidate(\".| .| .| .|\") == [1L,\
    \ 1L, 1L, 1L]);\n    assert(candidate(\"o| o| .| .| o o o o\") == [2L, 2L, 1L,\
    \ 1L, 4L, 4L, 4L, 4L]);\n    assert(candidate(\"o| .| o| .| o o| o o|\") == [2L,\
    \ 1L, 2L, 1L, 4L, 2L, 4L, 2L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp44yr4bd1.d(82): Error: no identifier for declarator `long`\\\
    n/tmp/tmp44yr4bd1.d(82): Error: found `unittest` instead of statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp44yr4bd1.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string representing musical notes in a special ASCII format.\n    Your task\
    \ is to parse this string and return list of integers corresponding to how many\
    \ beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note,\
    \ lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note,\
    \ lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n   \
    \ [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \n*/\nlong[] parse_music(string music_string)\
    \ \n{\n\tauto list = [];\n\tauto result = [];\n\t\n\t//converting string to list\
    \ of chars\n\tfor(auto c : music_string)\n\t\tlist ~= c;\n\t\n\t//now we just\
    \ check each element and put it in a new list\n\tint sum = 0;\n\tfor(auto e :\
    \ list)\n\t{\n\t\tif(e == 'o')\n\t\t{\n\t\t\tif(list[list.indexOf(e) + 1] == '|')\n\
    \t\t\t{\n\t\t\t\tresult ~= 2;\n\t\t\t\tsum += 2;\n\t\t\t}\n\t\t\telse\n\t\t\t\
    {\n\t\t\t\tresult ~= 4;\n\t\t\t\tsum += 4;\n\t\t\t}\n\t\t}\n\t\telse if(e == '.')\n\
    \t\t{\n\t\t\tif(list[list.indexOf(e) + 1] == '|')\n\t\t\t{\n\t\t\t\tresult ~=\
    \ 1;\n\t\t\t\tsum += 1;\n\t\t\t}\n\t\t}\n\t\tif(sum % 4 == 0)\n\t\t\tsum = 0;\n\
    \t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = parse_music;\n\n\
    \    assert(candidate(\"\") == []);\n    assert(candidate(\"o o o o\") == [4L,\
    \ 4L, 4L, 4L]);\n    assert(candidate(\".| .| .| .|\") == [1L, 1L, 1L, 1L]);\n\
    \    assert(candidate(\"o| o| .| .| o o o o\") == [2L, 2L, 1L, 1L, 4L, 4L, 4L,\
    \ 4L]);\n    assert(candidate(\"o| .| o| .| o o| o o|\") == [2L, 1L, 2L, 1L, 4L,\
    \ 2L, 4L, 2L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyvemboa5.d(23): Error: no identifier for declarator `c`\\n/tmp/tmpyvemboa5.d(23):\
    \ Error: expression expected, not `:`\\n/tmp/tmpyvemboa5.d(23): Error: found `music_string`\
    \ when expecting `;` following `for` condition\\n/tmp/tmpyvemboa5.d(28): Error:\
    \ no identifier for declarator `e`\\n/tmp/tmpyvemboa5.d(28): Error: expression\
    \ expected, not `:`\\n/tmp/tmpyvemboa5.d(28): Error: found `list` when expecting\
    \ `;` following `for` condition\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpyvemboa5.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string representing musical notes in a special ASCII format.\n    Your task\
    \ is to parse this string and return list of integers corresponding to how many\
    \ beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note,\
    \ lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note,\
    \ lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n   \
    \ [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \n*/\nlong[] parse_music(string music_string)\
    \ \n{\n    long[] beats;\n    string temp;\n    typeof(return) res;\n    foreach(i,\
    \ ch; music_string) \n    {\n        if(ch == ' ') \n        {\n            if(!temp.empty)\
    \ \n            {\n                res ~= temp;\n                temp = \"\";\n\
    \            }\n        } \n        else \n        {\n            temp ~= ch;\n\
    \        }\n    }\n    if(!temp.empty) \n    {\n        res ~= temp;\n    }\n\
    \    beats = new long[res.length];\n    foreach(i, v; res) \n    {\n        beats[i]\
    \ = v.length;\n    }\n    return beats;\n}\nunittest\n{\n    alias candidate =\
    \ parse_music;\n\n    assert(candidate(\"\") == []);\n    assert(candidate(\"\
    o o o o\") == [4L, 4L, 4L, 4L]);\n    assert(candidate(\".| .| .| .|\") == [1L,\
    \ 1L, 1L, 1L]);\n    assert(candidate(\"o| o| .| .| o o o o\") == [2L, 2L, 1L,\
    \ 1L, 4L, 4L, 4L, 4L]);\n    assert(candidate(\"o| .| o| .| o o| o o|\") == [2L,\
    \ 1L, 2L, 1L, 4L, 2L, 4L, 2L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpot0na4hg.d(26): Error: no property `empty` for type `string`\\\
    n/tmp/tmpot0na4hg.d(28): Error: cannot append type `string` to type `long[]`\\\
    n/tmp/tmpot0na4hg.d(37): Error: no property `empty` for type `string`\\n/tmp/tmpot0na4hg.d(39):\
    \ Error: cannot append type `string` to type `long[]`\\n/tmp/tmpot0na4hg.d(44):\
    \ Error: no property `length` for type `long`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpot0na4hg.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string representing musical notes in a special ASCII format.\n    Your task\
    \ is to parse this string and return list of integers corresponding to how many\
    \ beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note,\
    \ lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note,\
    \ lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n   \
    \ [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \n*/\nlong[] parse_music(string music_string)\
    \ \n{\n  long[] l = new long[];\n  int p = 0;\n  //check for \"o\"\n  foreach(char\
    \ c; music_string)\n  {\n    if(c == 'o')\n    {\n      //l.length++;\n      l\
    \ ~= 4;\n    }\n    else if(c == '.')\n    {\n      l ~= 1;\n    }\n    else if(c\
    \ == '|')\n    {\n      p++;\n      if(p%2 == 0)\n      {\n        l ~= 2;\n \
    \     }\n    }\n    else\n    {\n      p++;\n    }\n  }\n  return l;\n}\nunittest\n\
    {\n    alias candidate = parse_music;\n\n    assert(candidate(\"\") == []);\n\
    \    assert(candidate(\"o o o o\") == [4L, 4L, 4L, 4L]);\n    assert(candidate(\"\
    .| .| .| .|\") == [1L, 1L, 1L, 1L]);\n    assert(candidate(\"o| o| .| .| o o o\
    \ o\") == [2L, 2L, 1L, 1L, 4L, 4L, 4L, 4L]);\n    assert(candidate(\"o| .| o|\
    \ .| o o| o o|\") == [2L, 1L, 2L, 1L, 4L, 2L, 4L, 2L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2r6oxy8k.d(19): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp2r6oxy8k.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string representing musical notes in a special ASCII format.\n    Your task\
    \ is to parse this string and return list of integers corresponding to how many\
    \ beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note,\
    \ lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note,\
    \ lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n   \
    \ [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \n*/\nlong[] parse_music(string music_string)\
    \ \n{\n    import std.stdio;\n    import std.algorithm;\n    import std.range;\n\
    \    import std.array;\n    import std.conv;\n    import std.functional;\n   \
    \ import std.range;\n    import std.string;\n    import std.regex;\n    import\
    \ std.typecons;\n    import std.math;\n    long[] parts, part;\n    long[] result;\n\
    \    writeln(music_string);\n    parts = splitter(music_string);\n    writeln(parts);\n\
    \    result = new long[parts.length];\n    foreach(int i, l; parts)\n    {\n \
    \       part = split(l, \"|\");\n        foreach(int j, p; part)\n        {\n\
    \            if(p == \"o\")\n            {\n                if(j == 0)\n     \
    \           {\n                    result[i] += 4;\n                }\n      \
    \          else\n                {\n                    result[i] += 2;\n    \
    \            }\n            }\n            else if(p == \".\")\n            {\n\
    \                result[i] += 1;\n            }\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = parse_music;\n\n    assert(candidate(\"\
    \") == []);\n    assert(candidate(\"o o o o\") == [4L, 4L, 4L, 4L]);\n    assert(candidate(\"\
    .| .| .| .|\") == [1L, 1L, 1L, 1L]);\n    assert(candidate(\"o| o| .| .| o o o\
    \ o\") == [2L, 2L, 1L, 1L, 4L, 4L, 4L, 4L]);\n    assert(candidate(\"o| .| o|\
    \ .| o o| o o|\") == [2L, 1L, 2L, 1L, 4L, 2L, 4L, 2L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsfusplrr.d(33): Error: cannot implicitly convert expression `splitter(music_string)`\
    \ of type `Result` to `long[]`\\n/tmp/tmpsfusplrr.d(38): Error: no overload matches\
    \ for `split`\\n/tmp/tmpsfusplrr.d(41): Error: incompatible types for `(p) ==\
    \ (\"o\")`: `long` and `string`\\n/tmp/tmpsfusplrr.d(52): Error: incompatible\
    \ types for `(p) == (\".\")`: `long` and `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpsfusplrr.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string representing musical notes in a special ASCII format.\n    Your task\
    \ is to parse this string and return list of integers corresponding to how many\
    \ beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note,\
    \ lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note,\
    \ lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n   \
    \ [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \n*/\nlong[] parse_music(string music_string)\
    \ \n{\n    long[] notes;\n    foreach(index, char c; music_string)\n    {\n  \
    \      switch(c)\n        {\n            case 'o':\n                notes ~= 4;\n\
    \                break;\n            case '|':\n                notes[$-1] = notes[$-1]\
    \ / 2;\n                break;\n            case '.':\n                notes[$-1]\
    \ = notes[$-1] / 4;\n                break;\n        }\n    }\n    return notes;\n\
    }\n/*\n    You have a sequence of positive integers and you have to sort them\
    \ in such a way that:\n        1. Each number is followed by any prime number\
    \ that is greater than the previous number\n        2. Each number is followed\
    \ by a number that is greater than the previous number, but NOT a prime number\n\
    \        3. The last number should be the largest and should be followed by any\
    \ prime number.\nunittest\n{\n    alias candidate = parse_music;\n\n    assert(candidate(\"\
    \") == []);\n    assert(candidate(\"o o o o\") == [4L, 4L, 4L, 4L]);\n    assert(candidate(\"\
    .| .| .| .|\") == [1L, 1L, 1L, 1L]);\n    assert(candidate(\"o| o| .| .| o o o\
    \ o\") == [2L, 2L, 1L, 1L, 4L, 4L, 4L, 4L]);\n    assert(candidate(\"o| .| o|\
    \ .| o o| o o|\") == [2L, 1L, 2L, 1L, 4L, 2L, 4L, 2L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9quml3l6.d(37): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9quml3l6.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string representing musical notes in a special ASCII format.\n    Your task\
    \ is to parse this string and return list of integers corresponding to how many\
    \ beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note,\
    \ lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note,\
    \ lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n   \
    \ [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \n*/\nlong[] parse_music(string music_string)\
    \ \n{\n\tlong[] result = [];\n\tint i = 0;\n\tint len = music_string.length;\n\
    \tbool hasO = false;\n\twhile(i < len)\n\t{\n\t\tint start = i;\n\t\twhile(music_string[i]\
    \ == ' ')\n\t\t{\n\t\t\ti++;\n\t\t}\n\t\tif(music_string[i] == 'o')\n\t\t{\n\t\
    \t\ti++;\n\t\t\thasO = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ti++;\n\t\t\thasO =\
    \ false;\n\t\t}\n\t\tint end = i;\n\t\tif(hasO)\n\t\t{\n\t\t\tresult ~= 4;\n\t\
    \t}\n\t\telse\n\t\t{\n\t\t\tresult ~= 2;\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n\
    {\n    alias candidate = parse_music;\n\n    assert(candidate(\"\") == []);\n\
    \    assert(candidate(\"o o o o\") == [4L, 4L, 4L, 4L]);\n    assert(candidate(\"\
    .| .| .| .|\") == [1L, 1L, 1L, 1L]);\n    assert(candidate(\"o| o| .| .| o o o\
    \ o\") == [2L, 2L, 1L, 1L, 4L, 4L, 4L, 4L]);\n    assert(candidate(\"o| .| o|\
    \ .| o o| o o|\") == [2L, 1L, 2L, 1L, 4L, 2L, 4L, 2L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4ms7cnjm.d(21): Error: cannot implicitly convert expression `music_string.length`\
    \ of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp4ms7cnjm.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string representing musical notes in a special ASCII format.\n    Your task\
    \ is to parse this string and return list of integers corresponding to how many\
    \ beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note,\
    \ lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note,\
    \ lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n   \
    \ [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \n*/\nlong[] parse_music(string music_string)\
    \ \n{\n    // create list to hold counts\n    long[] counts = new long[];\n  \
    \  // iterate through each character\n    foreach(c; music_string)\n    {\n  \
    \      // get the count for each character\n        long noteCount = getCount(c);\n\
    \        // append count to list of counts\n        counts ~= noteCount;\n   \
    \ }\n    return counts;\n}\nunittest\n{\n    alias candidate = parse_music;\n\n\
    \    assert(candidate(\"\") == []);\n    assert(candidate(\"o o o o\") == [4L,\
    \ 4L, 4L, 4L]);\n    assert(candidate(\".| .| .| .|\") == [1L, 1L, 1L, 1L]);\n\
    \    assert(candidate(\"o| o| .| .| o o o o\") == [2L, 2L, 1L, 1L, 4L, 4L, 4L,\
    \ 4L]);\n    assert(candidate(\"o| .| o| .| o o| o o|\") == [2L, 1L, 2L, 1L, 4L,\
    \ 2L, 4L, 2L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4lekuo7w.d(20): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmp4lekuo7w.d(25): Error: undefined\
    \ identifier `getCount`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmp4lekuo7w.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string representing musical notes in a special ASCII format.\n    Your task\
    \ is to parse this string and return list of integers corresponding to how many\
    \ beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note,\
    \ lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note,\
    \ lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n   \
    \ [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \n*/\nlong[] parse_music(string music_string)\
    \ \n{\n    static auto split(in string s)\n    {\n        return s.split(\" \"\
    );\n    }\n    auto notes = split(music_string);\n    auto note_to_int = [\"o\"\
    \ : 4, \"o|\" : 2, \".|\" : 1];\n    return notes.map!(x => note_to_int[x]).array;\n\
    }\nunittest\n{\n    alias candidate = parse_music;\n\n    assert(candidate(\"\"\
    ) == []);\n    assert(candidate(\"o o o o\") == [4L, 4L, 4L, 4L]);\n    assert(candidate(\"\
    .| .| .| .|\") == [1L, 1L, 1L, 1L]);\n    assert(candidate(\"o| o| .| .| o o o\
    \ o\") == [2L, 2L, 1L, 1L, 4L, 4L, 4L, 4L]);\n    assert(candidate(\"o| .| o|\
    \ .| o o| o o|\") == [2L, 1L, 2L, 1L, 4L, 2L, 4L, 2L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpai1r0xca.d(21): Error: no property `split` for type `const(string)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpai1r0xca.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string representing musical notes in a special ASCII format.\n    Your task\
    \ is to parse this string and return list of integers corresponding to how many\
    \ beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note,\
    \ lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note,\
    \ lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n   \
    \ [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \n*/\nlong[] parse_music(string music_string)\
    \ \n{\n    import std.algorithm;\n    import std.conv;\n    import std.range;\n\
    \    import std.typecons;\n    import std.math;\n    import std.stdio;\n    import\
    \ std.string;\n    auto r = iota(0, music_string.length)\n        .filter!(i =>\
    \ music_string[i] == 'o' || music_string[i] == '.')\n        .map!(i => music_string[i])\n\
    \        .chunkBy!(i => i)\n        .map!(i => i.length)\n        .map!(i => i\
    \ == 2 ? 4 : 1)\n        .array;\n    return r;\n}\nunittest\n{\n    alias candidate\
    \ = parse_music;\n\n    assert(candidate(\"\") == []);\n    assert(candidate(\"\
    o o o o\") == [4L, 4L, 4L, 4L]);\n    assert(candidate(\".| .| .| .|\") == [1L,\
    \ 1L, 1L, 1L]);\n    assert(candidate(\"o| o| .| .| o o o o\") == [2L, 2L, 1L,\
    \ 1L, 4L, 4L, 4L, 4L]);\n    assert(candidate(\"o| .| o| .| o o| o o|\") == [2L,\
    \ 1L, 2L, 1L, 4L, 2L, 4L, 2L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdymddmfx.d(33): Error: cannot implicitly convert expression `r`\
    \ of type `int[]` to `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpdymddmfx.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string representing musical notes in a special ASCII format.\n    Your task\
    \ is to parse this string and return list of integers corresponding to how many\
    \ beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note,\
    \ lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note,\
    \ lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n   \
    \ [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \n*/\nlong[] parse_music(string music_string)\
    \ \n{\n    size_t total = 0;\n    long[] beats = music_string.split(\" \").map!((elem)\
    \ => \n    {\n        if (elem == \"o\") \n        {\n            total += 4;\n\
    \            return 4;\n        } \n        else if (elem == \"o|\") \n      \
    \  {\n            total += 2;\n            return 2;\n        } \n        else\
    \ if (elem == \".|\") \n        {\n            total += 1;\n            return\
    \ 1;\n        }\n    }).array;\n    return beats;\n}\nunittest\n{\n    alias candidate\
    \ = parse_music;\n\n    assert(candidate(\"\") == []);\n    assert(candidate(\"\
    o o o o\") == [4L, 4L, 4L, 4L]);\n    assert(candidate(\".| .| .| .|\") == [1L,\
    \ 1L, 1L, 1L]);\n    assert(candidate(\"o| o| .| .| o o o o\") == [2L, 2L, 1L,\
    \ 1L, 4L, 4L, 4L, 4L]);\n    assert(candidate(\"o| .| o| .| o o| o o|\") == [2L,\
    \ 1L, 2L, 1L, 4L, 2L, 4L, 2L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpopnpa63e.d(20): Error: no property `split` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpopnpa63e.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string representing musical notes in a special ASCII format.\n    Your task\
    \ is to parse this string and return list of integers corresponding to how many\
    \ beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note,\
    \ lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note,\
    \ lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n   \
    \ [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \n*/\nlong[] parse_music(string music_string)\
    \ \n{\n\tlong[] ret;\n\tstring[] notes = music_string.split(\" \");\n\tforeach(note;\
    \ notes) {\n\t\tret ~= note.length;\n\t}\n\treturn ret;\n}\n/*\n    In geometry,\
    \ a polygon can be defined as a flat or plane, two-dimensional  with straight\
    \ sides.\n    Polygons are classified by the number of sides. See the following\
    \ figure.\n    The Polygon() class stores the coordinates of the vertices of a\
    \ polygon using two arrays:\n    One for the x-coordinates and one for the y-coordinates.\n\
    \    Write a class Polygon with a member function area() that returns the area\
    \ of the polygon.\nunittest\n{\n    alias candidate = parse_music;\n\n    assert(candidate(\"\
    \") == []);\n    assert(candidate(\"o o o o\") == [4L, 4L, 4L, 4L]);\n    assert(candidate(\"\
    .| .| .| .|\") == [1L, 1L, 1L, 1L]);\n    assert(candidate(\"o| o| .| .| o o o\
    \ o\") == [2L, 2L, 1L, 1L, 4L, 4L, 4L, 4L]);\n    assert(candidate(\"o| .| o|\
    \ .| o o| o o|\") == [2L, 1L, 2L, 1L, 4L, 2L, 4L, 2L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp96h643q7.d(26): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp96h643q7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string representing musical notes in a special ASCII format.\n    Your task\
    \ is to parse this string and return list of integers corresponding to how many\
    \ beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note,\
    \ lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note,\
    \ lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n   \
    \ [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \n*/\nlong[] parse_music(string music_string)\
    \ \n{\n    auto len = music_string.length;\n    long[] music = new long[len];\n\
    \    string temp = \"\";\n    int count = 0;\n    for(int i = 0; i < len; i++)\n\
    \    {\n        temp += music_string[i];\n        if(music_string[i] == ' ')\n\
    \        {\n            if(temp == \"o \")\n            {\n                music[count]\
    \ = 4;\n                count++;\n            }\n            else if(temp == \"\
    o| \")\n            {\n                music[count] = 2;\n                count++;\n\
    \            }\n            else if(temp == \".| \")\n            {\n        \
    \        music[count] = 1;\n                count++;\n            }\n        \
    \    temp = \"\";\n        }\n    }\n    if(temp == \"o\")\n    {\n        music[count]\
    \ = 4;\n        count++;\n    }\n    else if(temp == \"o|\")\n    {\n        music[count]\
    \ = 2;\n        count++;\n    }\n    else if(temp == \".|\")\n    {\n        music[count]\
    \ = 1;\n        count++;\n    }\n    return music;\n}\nunittest\n{\n    alias\
    \ candidate = parse_music;\n\n    assert(candidate(\"\") == []);\n    assert(candidate(\"\
    o o o o\") == [4L, 4L, 4L, 4L]);\n    assert(candidate(\".| .| .| .|\") == [1L,\
    \ 1L, 1L, 1L]);\n    assert(candidate(\"o| o| .| .| o o o o\") == [2L, 2L, 1L,\
    \ 1L, 4L, 4L, 4L, 4L]);\n    assert(candidate(\"o| .| o| .| o o| o o|\") == [2L,\
    \ 1L, 2L, 1L, 4L, 2L, 4L, 2L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp40qbhi2t.d(25): Error: slice `temp` is not mutable\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp40qbhi2t.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string representing musical notes in a special ASCII format.\n    Your task\
    \ is to parse this string and return list of integers corresponding to how many\
    \ beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note,\
    \ lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note,\
    \ lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n   \
    \ [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \n*/\nlong[] parse_music(string music_string)\
    \ \n{\n    int[] arr = [0];\n    int last_elem = 0;\n    int[] interval = [4,\
    \ 2, 1];\n    foreach(char i; music_string)\n    {\n        if(i == ' ' || i ==\
    \ 'o')\n        {\n            if(i == 'o')\n            {\n                if(last_elem\
    \ == 0)\n                {\n                    arr ~= interval[0];\n        \
    \            last_elem = arr.length - 1;\n                }\n                else\n\
    \                {\n                    arr[last_elem] = arr[last_elem] + interval[0];\n\
    \                }\n            }\n            else\n            {\n         \
    \       last_elem = 0;\n            }\n        }\n        else if(i == '|')\n\
    \        {\n            if(last_elem == 0)\n            {\n                arr\
    \ ~= interval[1];\n                last_elem = arr.length - 1;\n            }\n\
    \            else\n            {\n                arr[last_elem] = arr[last_elem]\
    \ + interval[1];\n            }\n        }\n        else if(i == '.')\n      \
    \  {\n            if(last_elem == 0)\n            {\n                arr ~= interval[2];\n\
    \                last_elem = arr.length - 1;\n            }\n            else\n\
    \            {\n                arr[last_elem] = arr[last_elem] + interval[2];\n\
    \            }\n        }\n    }\n    return arr;\n}\n/*\n    This function takes\
    \ two lists of integers - first is list of notes durations (e.g. [1, 2, 3, 4]),\n\
    \    second is list of notes pitches.\n    Your task is to combine those two lists\
    \ into list of pairs where first number is a pitch,\n    and second number is\
    \ a duration.\n    >>> combine_notes([1, 2, 3, 4], [5, 6, 7, 8])\n    [(5, 1),\
    \ (6, 2), (7, 3), (8, 4)]\n*/\nlong[][] combine_notes(long[] durations, long[]\
    \ pitches) \n{\n    long[][] arr = [][];\n    foreach(i\nunittest\n{\n    alias\
    \ candidate = parse_music;\n\n    assert(candidate(\"\") == []);\n    assert(candidate(\"\
    o o o o\") == [4L, 4L, 4L, 4L]);\n    assert(candidate(\".| .| .| .|\") == [1L,\
    \ 1L, 1L, 1L]);\n    assert(candidate(\"o| o| .| .| o o o o\") == [2L, 2L, 1L,\
    \ 1L, 4L, 4L, 4L, 4L]);\n    assert(candidate(\"o| .| o| .| o o| o o|\") == [2L,\
    \ 1L, 2L, 1L, 4L, 2L, 4L, 2L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1qcqy_l_.d(82): Error: no identifier for declarator `i`\\n/tmp/tmp1qcqy_l_.d(82):\
    \ Error: found `unittest` when expecting `;`\\n/tmp/tmp1qcqy_l_.d(92): Error:\
    \ found `void` when expecting `)`\\n/tmp/tmp1qcqy_l_.d(92): Error: found `{` when\
    \ expecting `;` following statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp1qcqy_l_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
