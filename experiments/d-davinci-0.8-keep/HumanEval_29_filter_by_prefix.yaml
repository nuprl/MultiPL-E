name: HumanEval_29_filter_by_prefix
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n Filter an input list of strings\
  \ only for ones that start with a given prefix.\n    >>> filter_by_prefix([], 'a')\n\
  \    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc',\
  \ 'array']\n    \n*/\nstring[] filter_by_prefix(string[] strings, string prefix)\
  \ \n"
tests: "unittest\n{\n    alias candidate = filter_by_prefix;\n\n    assert(candidate([],\
  \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
  , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n}\nvoid main(){}"
completions: ["{\n    string[] result;\n    foreach(str; strings)\n    {\n       \
    \ if(str.startsWith(prefix))\n        {\n            result ~= str;\n        }\n\
    \    }\n    return result;\n}", "{\n    return filter!(a => a.startsWith(prefix))(strings);\n\
    }\n/*\n Find the first index at which a given element is found in a given array.\
    \ \n Returns -1 if the element is not present.\n    >>> index_of(['a', 'b', 'c'],\
    \ 'c')\n    2\n    >>> index_of(['a', 'b', 'c'], 'd')\n    -1\n*/", "{\n    return\
    \ strings.filter!(s => s.startsWith(prefix)).array;\n}\n/*\nFind the top n elements\
    \ from a list of strings according to their lengths.\n    >>> top_n_by_length(3,\
    \ ['abc', 'def', 'gh', 'i', 'jkl'])\n    ['abc', 'def', 'jkl']\n    >>> top_n_by_length(1,\
    \ ['abc', 'def', 'gh', 'i', 'jkl'])\n    ['abc']\n*/\nstring[] top_n_by_length(int\
    \ n, string[] strings) \n{\n    return strings.filter!(s => s.length > 2).array;\n\
    }\n/*\n Find the sum of all numbers between two numbers\n    >>> sum_between(1,\
    \ 4)\n    10\n    >>> sum_between(0, -10)\n    -55\n*/", "{\n    string[] filtered_strings;\n\
    \    foreach(string s; strings)\n    {\n        if(s.startsWith(prefix))\n   \
    \     {\n            filtered_strings ~= s;\n        }\n    }\n    return filtered_strings;\n\
    }\n/*\n    Construct a list of all prefixes of a given string.\n        >>> list_of_prefixes('abc')\n\
    \        ['a', 'ab', 'abc']\n        >>> list_of_prefixes('abcd')\n        ['a',\
    \ 'ab', 'abc', 'abcd']\n*/\nstring[] list_of_prefixes(string text)\n{\n    string[]\
    \ prefixes;\n    foreach(immutable i; 0..text.length)\n    {\n        prefixes\
    \ ~= text[0..i];\n    }\n    return prefixes;\n}\n/*\n    A naiive implementation\
    \ of the autocompletion function.\n    Given a prefix and a list of strings, we\
    \ return all of the possible completions of that prefix that are actually in the\
    \ list.\n    >>> autocomplete('a', ['abc', 'bcd', 'cde', 'array'])\n    ['abc',\
    \ 'array']\n    >>> autocomplete('ab', ['abc', 'bcd', 'cde', 'array'])\n    ['abc',\
    \ 'array']\n    >>> autocomplete('abc', ['abc', 'bcd', 'cde', 'array'])\n    ['abc']\n\
    \    >>> autocomplete('x', ['abc', 'bcd', 'cde', 'array'])\n    []\n*/\nstring[]\
    \ autocomplete(string prefix, string[] strings)\n{\n    string[] matching_strings;\n\
    \    foreach(string s; strings)\n    {\n        if(s.startsWith(prefix))\n   \
    \     {\n            matching_strings ~= s;\n        }\n    }\n    return matching_strings;\n\
    }\n// autocomplete using a sorted list of strings\nstring[] autocomplete_sorted(string\
    \ prefix, string[] strings)\n{\n    // use std.algorithm.find, which uses binary\
    \ search to find prefix in strings, if it is not present, return null\n    string\
    \ start_of_completions = find(strings, prefix", "{\n    string[] res;\n    foreach(s;\
    \ strings) \n    {\n        if(s.startsWith(prefix)) \n        {\n           \
    \ res ~= s;\n        }\n    }\n    return res;\n}\n \n/*\n Find the length of\
    \ the longest common prefix of two strings.\n    >>> longest_common_prefix_length('abc',\
    \ 'abcdef')\n    3\n    >>> longest_common_prefix_length('abc', 'abcdef', 'abcde')\n\
    \    3\n    >>> longest_common_prefix_length('abc', 'def')\n    0\n    >>> longest_common_prefix_length('abc',\
    \ 'def', 'ghi')\n    0\n    >>> longest_common_prefix_length('abcd', 'abcd')\n\
    \    4\n    \n*/\nsize_t longest_common_prefix_length(string[] strings) \n{\n\
    \    assert(strings.length > 0);\n    size_t len = 0;\n    while(true) \n    {\n\
    \        char c = strings[0][len];\n        foreach(s; strings) \n        {\n\
    \            if(s.length <= len || s[len] != c) \n            {\n            \
    \    return len;\n            }\n        }\n        len++;\n    }\n}\n \n/*\n\
    \ Returns all possible strings that can be formed by removing 0 or more characters\
    \ from a string.\n    >>> combinations('abc')\n    ['abc', 'ab', 'ac', 'a', 'bc',\
    \ 'b', 'c', '']\n    \n*/\nstring[] combinations(string str) \n{\n    string[]\
    \ res;\n    for(size_t i = 0; i <= str.length; i++) \n    {\n        res ~= str[0..i];\n\
    \    }\n    return res;\n}\n \n/*\n Returns all possible strings that can be formed\
    \ by removing 0 or more characters from a string.\n    >>> combinations(['abc',\
    \ 'def'])\n    ['abc', 'ab', 'ac', 'a', 'def', 'de', 'd', 'ef', 'e', 'f', '']\n\
    \    \n*/\nstring[] combinations(string[] strings) \n{\n    string[] res;\n  \
    \  fore", "{\n    return strings.filter!(x => x.startsWith(prefix));\n}\n/*\n\
    \ Get the last element of a list.\n    >>> last_element([])\n    \"No elements!\"\
    \n    >>> last_element([1, 2, 3])\n    3\n    \n*/\nstring last_element(int[]\
    \ nums) \n{\n    if (nums.length == 0)\n        return \"No elements!\";\n   \
    \ else\n        return nums[$ - 1].to!string;\n}\n/*\nApply a function to an input\
    \ list of numbers and return the resulting list.\n    >>> map_list(x => x * 2,\
    \ [1, 2, 3])\n    [2, 4, 6]\n    >>> map_list(x => x * x, [1, 2, 3])\n    [1,\
    \ 4, 9]\n    \n*/", "{\n    return strings.filter!(s => s.startsWith(prefix));\n\
    }", "{\n\treturn strings.filter!(a => a.startsWith(prefix));\n}\n/*\n Counts the\
    \ number of words in a string.\n    \n*/", "{\n    auto result = std.algorithm.filter!(\
    \ (string s) => s.startsWith(prefix) )(strings);\n    return result.array;\n}",
  "    if(isInputRange!(string[])) {\n        string[] results;\n        foreach(s;\
    \ strings) {\n            if(s.startsWith(prefix)) {\n                results\
    \ ~= s;\n            }\n        }\n        return results;\n    }", "{\n    string[]\
    \ ret;\n    foreach(str; strings) \n    {\n        if(str.startsWith(prefix))\n\
    \            ret ~= str;\n    }\n    return ret;\n}", "{\n    if (strings.length\
    \ == 0) \n    {\n        return [];\n    }\n    else \n    {\n        if (strings[0].startsWith(prefix))\
    \ \n        {\n            return [strings[0]] ~ filter_by_prefix(strings[1 ..\
    \ $], prefix);\n        }\n        else \n        {\n            return filter_by_prefix(strings[1\
    \ .. $], prefix);\n        }\n    }\n}", "{\n    string[] filtered;\n    foreach(string\
    \ s; strings) \n    {\n        if(s.startsWith(prefix))\n            filtered\
    \ ~= s;\n    }\n    return filtered;\n}\n/*\n    >>> sum_or_zero([])\n    0\n\
    \    >>> sum_or_zero([3, 4, 7])\n    14\n*/", "{\n    return filter!(s => s.startsWith(prefix))(strings);\n\
    }", "{\n    string[] filtered;\n    foreach(s; strings)\n    {\n        if(s.startsWith(prefix))\n\
    \        {\n            filtered ~= s;\n        }\n    }\n    return filtered;\n\
    }\n \n/*\n Filter a dictionary by key prefix\n    >>> typeof(filter_by_prefix_dict({},\
    \ 'a'))\n    Map!(string, int)\n    >>> filter_by_prefix_dict(['a':1, 'bb':2,\
    \ 'ccc':3], 'b')\n    ['bb':2]\n*/\nMap!(string, int) filter_by_prefix_dict(Map!(string,\
    \ int) d, string prefix) \n{\n    Map!(string, int) filtered;\n    foreach(key,\
    \ val; d)\n    {\n        if(key.startsWith(prefix))\n        {\n            filtered[key]\
    \ = val;\n        }\n    }\n    return filtered;\n}\n \n/*\n Filter a dictionary\
    \ by key prefix, returning the key and value types\n    >>> typeof(filter_by_prefix_dict2({},\
    \ 'a'))\n    Tuple!(Map!(string, int), int)\n    >>> filter_by_prefix_dict2(['a':1,\
    \ 'bb':2, 'ccc':3], 'b')\n    (['bb':2], 2)\n*/\nTuple!(Map!(string, int), int)\
    \ filter_by_prefix_dict2(Map!(string, int) d, string prefix) \n{\n    Map!(string,\
    \ int) filtered;\n    foreach(key, val; d)\n    {\n        if(key.startsWith(prefix))\n\
    \        {\n            filtered[key] = val;\n        }\n    }\n    return tuple(filtered,\
    \ d[prefix]);\n}\n \n/*\n  Filter a dictionary by key prefix, returning the key\
    \ and value types\n     >>> typeof(filter_by_prefix_dict3({}, 'a'))\n     Map!(string,\
    \ int)\n     >>> filter_by_prefix_dict3(['a':1, 'bb':2, 'ccc':3], 'b')\n     ['bb",
  "{\n    return strings.filter!(x => x.startsWith(prefix)).array;\n}", "{\n    return\
    \ filter!(a => a.startsWith(prefix))(strings);\n}", "{\n\tstring[] result;\n\t\
    foreach(str; strings)\n\t{\n\t\tif(str.startsWith(prefix))\n\t\t{\n\t\t\tresult\
    \ ~= str;\n\t\t}\n\t}\n\treturn result;\n}\n/*\n \nUsing list comprehensions,\
    \ generate a list of tuples where the first element is the index of the tuple\
    \ and the second element is the string version of the index.\n \n>>> list_comprehension(5)\n\
    [(0, '0'), (1, '1'), (2, '2'), (3, '3'), (4, '4')]\n \n*/\ntuple!(size_t, string)[]\
    \ list_comprehension(size_t end)\n{\n\ttuple!(size_t, string)[] result;\n\tforeach(i;\
    \ 0..end)\n\t{\n\t\tresult ~= tuple(i, i.to!string);\n\t}\n\treturn result;\n}",
  "{\n    return strings.filter!(a => a.startsWith(prefix)).array;\n}\n/*\n Write\
    \ a function max_by that accepts a pair of numbers and a function:\n    f(A, B)\
    \ -> int\n    and returns the number that gives the larger result when passed\
    \ to f.\n    If the results are tied, one can be returned in either order.\n \
    \   >>> max_by(1, 2, square)\n    2\n    >>> max_by(2, 1, square)\n    2\n   \
    \ >>> max_by(1, 1, square)\n    1\n    >>> max_by(1, 2, square + 1)\n    1\n \
    \   >>> max_by(1, 2, square - 1)\n    2\n*/\nT max_by(T)(T a, T b, T delegate(T,\
    \ T) f) \n{\n    return f(a, b) > 0 ? a : b;\n}\n/*\n Given a list of numbers,\
    \ return the average of all the numbers.\n Hint: .sum is a function of a list\
    \ of numbers that gives you the sum of all the numbers in the list.\n    >>> average([5,1,3,4])\n\
    \    3.25\n    >>> average([4,1,3,5])\n    3.5\n*/\nreal average(int[] nums) \n\
    {\n    return nums.sum / nums.length;\n}\n/*\n Given a list of numbers and a function\
    \ f, return only the numbers that are greater than average.\n    >>> remove_below_average([1,2,3,4,5],\
    \ (a,b) => a + b)\n    [3,4,5]\n    >>> remove_below_average([1,1,1,1,1], (a,b)\
    \ => a * b)\n    [1,1,1,1,1]\n    >>> remove_below_average([1,1,1,1,1], (a,b)\
    \ => a + b)\n    []\n*/", "{\n    return filter!(s => s.startsWith(prefix))(strings);\n\
    }\n/*\nFilter an input list of points only for ones that lie within a given\n\
    radius of a given point.\n    >>> filter_by_radius([], 1, [0, 0])\n    []\n  \
    \  >>> filter_by_radius([[1, 1], [2, 2], [3, 3]], 2, [0, 0])\n    [[1, 1]]\n*/\n\
    real[][] filter_by_radius(real[][] points, real radius, real[] center) \n{\n \
    \   return filter!(p => dist(p, center) <= radius)(points);\n}\n/*\nCount the\
    \ number of elements in a list that are strictly greater than a\ngiven value.\n\
    \    >>> count_greater_than([], 0)\n    0\n    >>> count_greater_than([1, 2, 3,\
    \ 4, 5], 4)\n    1\n*/\nsize_t count_greater_than(int[] numbers, int limit) \n\
    {\n    return count!(n => n > limit)(numbers);\n}\n/*\nPartition a list into two\
    \ lists, containing elements that are less than a\ngiven value, and elements that\
    \ are greater than or equal to a given value.\n    >>> partition([], 0)\n    ([],\
    \ [])\n    >>> partition([1, 2, 3, 4, 5], 3)\n    ([1, 2], [3, 4, 5])\n*/\nTuple!(int[],\
    \ int[]) partition(int[] numbers, int limit) \n{\n    auto lt = filter!(n => n\
    \ < limit)(numbers);\n    auto ge = filter!(n => n >= limit)(numbers);\n    return\
    \ tuple(lt, ge);\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
