name: HumanEval_48_is_palindrome
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    Checks if given string\
  \ is a palindrome\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n\
  \    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n\
  \    False\n    \n*/\nbool is_palindrome(string text) \n"
tests: "unittest\n{\n    alias candidate = is_palindrome;\n\n    assert(candidate(\"\
  \") == true);\n    assert(candidate(\"aba\") == true);\n    assert(candidate(\"\
  aaaaa\") == true);\n    assert(candidate(\"zbcd\") == false);\n    assert(candidate(\"\
  xywyx\") == true);\n    assert(candidate(\"xywyz\") == false);\n    assert(candidate(\"\
  xywzx\") == false);\n}\nvoid main(){}"
completions: ["{\n    size_t len = text.length;\n    size_t middle = len / 2;\n  \
    \  for (size_t i = 0; i < middle; i++) {\n        if (text[i] != text[len - i\
    \ - 1])\n            return false;\n    }\n    return true;\n}\n/*", "{\n    foreach(i,\
    \ j; iota(0, text.length / 2))\n        if(text[i] != text[text.length - 1 - j])\n\
    \            return false;\n    return true;\n}\n/*", "{\n    text = strip(text);\n\
    \    return text == text.mirror;\n}", "{\n    bool result = true;\n    int i =\
    \ 0;\n    int j = text.length - 1;\n    while (i < j) {\n        if (text[i] !=\
    \ text[j]) {\n            result = false;\n            break;\n        }\n   \
    \     i++;\n        j--;\n    }\n    return result;\n}", "{\n    return text ==\
    \ text.dup.reverse;\n}\n/*", "{\n    int n = text.length;\n    for (int i = 0;\
    \ i < n / 2; i++)\n    {\n        if (text[i] != text[n - i - 1])\n        {\n\
    \            return false;\n        }\n    }\n    return true;\n}", "{ \n    if\
    \ (text.empty) \n        return true; \n    size_t n = text.length; \n    size_t\
    \ mid = cast(size_t)(n / 2); \n    for (size_t i = 0; i < mid; i++) { \n     \
    \   if (text[i] != text[n - i - 1]) \n            return false; \n    } \n   \
    \ return true; \n} \n/*", "{\n    int start = 0;\n    int end = text.length -\
    \ 1;\n    while (start < end) \n    {\n        if (text[start] != text[end]) \n\
    \        {\n            return false;\n        }\n        start += 1;\n      \
    \  end -= 1;\n    }\n    return true;\n}", "{\n    return text.equal(text.retro);\n\
    }", "{\n    // Generate an array of chars from given string\n    text = text.toLower();\n\
    \    char[] chars = text.chars();\n    // Iterate and check if left part is equal\
    \ to right part\n    for (int i = 0; i < chars.length/2; i++) {\n        int j\
    \ = chars.length - i - 1;\n        if (chars[i] != chars[j])\n            return\
    \ false;\n    }\n    return true;\n}\n/*", "{\n    if (text.length == 0) \n  \
    \  {\n        return true;\n    }\n    else if (text.length == 1) \n    {\n  \
    \      return true;\n    }\n    else \n    {\n        return text[0] == text[$-1]\
    \ && is_palindrome(text[1..$-1]);\n    }\n}\n/*", "{\n    int i, j;\n    for (i\
    \ = 0, j = text.length - 1; i < j; i++, j--)\n    {\n        if (text[i] != text[j])\
    \ return false;\n    }\n    return true;\n}\n/*", "{\n    immutable text_len =\
    \ text.length;\n    if (text_len <= 1)\n        return true;\n    immutable mid\
    \ = text_len / 2;\n    if (text[0 .. mid] == text[mid .. $].reverse)\n       \
    \ return true;\n    return false;\n}", "{\n    // check the boundary condition\n\
    \    if (text.length == 0)\n        return true;\n    \n    // check the base\
    \ case\n    if (text.length == 1)\n        return true;\n    \n    else {\n  \
    \      if (text[0] == text[$-1])\n            return is_palindrome(text[1..$-1]);\n\
    \        else\n            return false;\n    }\n}", "{\n    if(text.length ==\
    \ 0)\n        return true;\n    else if(text.length == 1)\n        return true;\n\
    \    else if(text[0] == text[$-1])\n        return is_palindrome(text[1..$-1]);\n\
    \    else\n        return false;\n}", "{\n    foreach(index, ch; text)\n    {\n\
    \        if (ch != text[$ - index - 1])\n            return false;\n    }\n  \
    \  return true;\n}\n/*", "{\n    auto a = text.chars;\n    int l = a.length;\n\
    \    bool is = true;\n    int half = ceil(l / 2);\n    for (int i = 0; i < half;\
    \ i++) {\n        if (a[i] != a[l - i - 1]) {\n            is = false;\n     \
    \       break;\n        }\n    }\n    return is;\n}", "{\n    immutable uint h\
    \ = text.length / 2;\n    foreach (immutable i, immutable c; text[0 .. h])\n \
    \       if (c != text[$ - i - 1])\n            return false;\n    return true;\n\
    }", "{\n    // \\TODO!\n    // \\TODO!\n    // \\TODO!\n    // \\TODO!\n    //\
    \ \\TODO!\n    // \\TODO!\n    // \\TODO!\n    // \\TODO!\n    // \\TODO!\n  \
    \  // \\TODO!\n    // \\TODO!\n    // \\TODO!\n    // \\TODO!\n    // \\TODO!\n\
    \    // \\TODO!\n    // \\TODO!\n    // \\TODO!\n    // \\TODO!\n    // \\TODO!\n\
    \    // \\TODO!\n    // \\TODO!\n    // \\TODO!\n    // \\TODO!\n    // \\TODO!\n\
    \    // \\TODO!\n    // \\TODO!\n    // \\TODO!\n    // \\TODO!\n    // \\TODO!\n\
    \    // \\TODO!\n    // \\TODO!\n    // \\TODO!\n    // \\TODO!\n    // \\TODO!\n\
    \    // \\TODO!\n    // \\TODO!\n    // \\TODO!\n    // \\TODO!\n    // \\TODO!\n\
    \    // \\TODO!\n    // \\TODO!\n    // \\TODO!\n    // \\TODO!\n    // \\TODO!\n\
    \    // \\TODO!\n    // \\TODO!\n    // \\TODO!\n    // \\TODO!\n    // \\TODO!\n\
    \    // \\TODO!\n    // \\TODO!\n    // \\TODO!\n    // \\TODO!\n    // \\TODO!\n\
    \    // \\TODO!\n    // \\TODO!\n    // \\TODO!\n    // \\TODO!\n    // \\TODO!\n\
    \    // \\TODO!\n    // \\TODO!\n    // \\TODO!\n    // \\TODO!\n    // \\TOD",
  "{\n    int start = 0;\n    int end = text.length - 1;\n    while (end > start)\
    \ \n    {\n        if (text[start] != text[end]) \n        {\n            return\
    \ false;\n        }\n        ++start;\n        --end;\n    }\n    return true;\n\
    }"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
