name: HumanEval_11_string_xor
language: d
prompt: "import std.math;\n/*\n Input are two strings a and b consisting only of 1s\
  \ and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n\
  \    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
  \ a, string b) \n"
tests: "unittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"\
  111000\", \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"\
  0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
completions: ["{\n    enum aLen = a.length;\n    enum bLen = b.length;\n    int aPos\
    \ = 0;\n    int bPos = 0;\n    int aDigit;\n    int bDigit;\n    string result\
    \ = \"\";\n    while(aPos < aLen || bPos < bLen)\n    {\n        if(aPos >= aLen)\n\
    \        {\n            aDigit = 0;\n        }\n        else\n        {\n    \
    \        aDigit = a[aPos];\n        }\n        if(bPos >= bLen)\n        {\n \
    \           bDigit = 0;\n        }\n        else\n        {\n            bDigit\
    \ = b[bPos];\n        }\n        if(aDigit == bDigit)\n        {\n           \
    \ result ~= \"0\";\n        }\n        else\n        {\n            result ~=\
    \ \"1\";\n        }\n        aPos++;\n        bPos++;\n    }\n    return result;\n\
    }", "{\n    string result = \"\";\n    for (in i = 0; i < a.length; i++) \n  \
    \  {\n        result ~= ((a[i] == '1') ^ (b[i] == '1')) ? '1' : '0';\n    }\n\
    \    return result;\n}", "{\n    string result;\n    if (a.length != b.length)\n\
    \        assert(0);\n    for (int i = 0; i < a.length; i++)\n    {\n        if\
    \ (a[i] == b[i])\n            result ~= '0';\n        else\n            result\
    \ ~= '1';\n    }\n    return result;\n}", "{\n    string result;\n    for (int\
    \ i = 0; i < a.length; i++)\n    {\n        result ~= ((a[i] == '1') ^ (b[i] ==\
    \ '1')) ? '1' : '0';\n    }\n    return result;\n}", "{\n    string result = \"\
    \";\n    // take the length of the smallest of the two strings.\n    int n = min(a.length,\
    \ b.length);\n    for (int i = 0; i < n; i++)\n    {\n        char a1 = a[i];\n\
    \        char b1 = b[i];\n        // if they're different, then we add a 1 to\
    \ the result string.\n        if (a1 != b1) \n        {\n            result ~=\
    \ \"1\";\n        }\n        else \n        {\n            result ~= \"0\";\n\
    \        }\n    }\n    return result;\n}", "{\n    string c = \"\";\n    for (int\
    \ i = 0; i < a.length; i++) \n    {\n        c ~= ((a[i] == '1') ^ (b[i] == '1'))\
    \ ? '1' : '0';\n    }\n    return c;\n}\n/*\nWrite a function that takes in a\
    \ string of one or more words, and returns the same string, \nbut with all five\
    \ or more letter words reversed (Just like the name of this Kata). \nStrings passed\
    \ in will consist of only letters and spaces. Spaces will be included only when\
    \ more than one word is present.\nExamples:\n    spinWords( \"Hey fellow warriors\"\
    \ ) => returns \"Hey wollef sroirraw\" \n    spinWords( \"This is a test\") =>\
    \ returns \"This is a test\" \n    spinWords( \"This is another test\" )=> returns\
    \ \"This is rehtona test\"\n*/\nstring spinWords(string sentence) \n{\n    string[]\
    \ words = split(sentence);\n    for (int i = 0; i < words.length; i++) \n    {\n\
    \        if (words[i].length >= 5)\n            words[i] = reverse(words[i]);\n\
    \    }\n    return join(words);\n}\n/*\nSimple, given a string of words, return\
    \ the length of the shortest word(s).\nString will never be empty and you do not\
    \ need to account for different data types.\n*/", "{\n    string result = \"\"\
    ;\n    foreach(i, x; a) {\n        result ~= ((a[i] == '1') ^ (b[i] == '1')) ?\
    \ '1' : '0';\n    }\n    return result;\n}", "{\n    return a.xor(b);\n}", "{\n\
    \    string res = \"\";\n    foreach(i, ch; a) {\n        if(ch == b[i]) res ~=\
    \ \"0\";\n        else res ~= \"1\";\n    }\n    return res;\n}", "{\n    int\
    \ n = max(a.length, b.length);\n    string ret;\n    ret.length = n;\n    int\
    \ i = 0;\n    while (i < n) {\n        int x = a[i];\n        int y = b[i];\n\
    \        if (x == '0' && y == '0') {\n            ret[i] = '0';\n        } else\
    \ if (x == '1' && y == '1') {\n            ret[i] = '0';\n        } else {\n \
    \           ret[i] = '1';\n        }\n        i++;\n    }\n    return ret;\n}",
  "{\n    string res;\n    for (int i = 0; i < a.length; i++)\n    {\n        if (a[i]\
    \ == b[i])\n            res ~= '0';\n        else\n            res ~= '1';\n \
    \   }\n    return res;\n}\n/*\n A binary gap within a positive integer N is any\
    \ maximal sequence of consecutive zeros that is surrounded by ones at both ends\
    \ in the binary representation of N.\n    For example, number 9 has binary representation\
    \ 1001 and contains a binary gap of length 2. The number 529 has binary representation\
    \ 1000010001 and contains two binary gaps: one of length 4 and one of length 3.\
    \ The number 20 has binary representation 10100 and contains one binary gap of\
    \ length 1. The number 15 has binary representation 1111 and has no binary gaps.\
    \ The number 32 has binary representation 100000 and has no binary gaps.\n   \
    \ Write a function:\n    function solution(N);\n    that, given a positive integer\
    \ N, returns the length of its longest binary gap. The function should return\
    \ 0 if N doesn't contain a binary gap.\n    For example, given N = 1041 the function\
    \ should return 5, because N has binary representation 10000010001 and so its\
    \ longest binary gap is of length 5. Given N = 32 the function should return 0,\
    \ because N has binary representation '100000' and thus no binary gaps.\n    Write\
    \ an efficient algorithm for the following assumptions:\n    N is an integer within\
    \ the range [1..2,147,483,647].\n*/", "{\n    string result = \"\";\n    foreach(char\
    \ aa, a) \n    {\n        assert(aa == '0' || aa == '1');\n        foreach(char\
    \ bb, b) \n        {\n            assert(bb == '0' || bb == '1');\n          \
    \  result ~= (aa ^ bb);\n        }\n    }\n    return result;\n}", "{\n  static\
    \ assert(a.length == b.length);\n  string result;\n  foreach(ch1,ch2; zip(a,b))\n\
    \  {\n    result ~= ch1 ^ ch2;\n  }\n  return result;\n}", "{\n    int length\
    \ = a.length;\n    string result = \"\";\n    for (int i = 0; i < length; i++)\n\
    \    {\n        result ~= (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;\n\
    }", "{\n    if (a.length < b.length) a = a.dup.padRight(b.length, '0');\n    else\
    \ if (b.length < a.length) b = b.dup.padRight(a.length, '0');\n    string result\
    \ = new string[max(a.length, b.length)];\n    for (int i = 0; i < a.length; i++)\n\
    \    {\n        int ai = cast(int)a[i];\n        int bi = cast(int)b[i];\n   \
    \     result[i] = ai ^ bi == 1 ? '1' : '0';\n    }\n    return result.join();\n\
    }", "{\n    string result;\n    foreach(i, ch; a)\n    {\n        result ~= (to!int(ch)\
    \ xor to!int(b[i])).to!string;\n    }\n    return result;\n}\n// Function to check\
    \ the conditions", "{\n    return \"100\";\n}", "{\n    string s = \"\";\n   \
    \ foreach(immutable i; 0 .. min(a.length, b.length)) {\n        s ~= ((a[i]=='1')^(b[i]=='1'))?\"\
    1\":\"0\";\n    }\n    return s;\n}", "{\n    string result;\n    foreach(idx,\
    \ e; a)\n    {\n        result ~= ((e == b[idx]) ? '0' : '1');\n    }\n    return\
    \ result;\n}\n/*\n    Helper function to check if a string b is a substring of\
    \ a\n*/", "{\n    assert(a.length == b.length);\n    string result;\n    result.length\
    \ = a.length;\n    foreach(i, ch; a)\n    {\n        int ai = a[i] - '0';\n  \
    \      int bi = b[i] - '0';\n        int x = (ai ^ bi) + '0';\n        result[i]\
    \ = cast(char)x;\n    }\n    return result;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
