name: HumanEval_116_sort_array
language: d
results:
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!(a\
    \ => a, b => {\n        ulong A = (ulong)a;\n        ulong B = (ulong)b;\n   \
    \     return cast(int)popcount(A) < cast(int)popcount(B) ? -1 :\n            cast(int)popcount(A)\
    \ > cast(int)popcount(B) ? 1 :\n            a < b ? -1 : 1;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpp61sf8le.d(18): Error: C style cast illegal, use `cast(ulong)a`\\\
    n/tmp/tmpp61sf8le.d(19): Error: C style cast illegal, use `cast(ulong)b`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp61sf8le.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    mixin(\"import\
    \ std.algorithm.sorting : sort, stableSort;\");\n    return arr.stableSort!((a,\
    \ b) => (countOnes(a) == countOnes(b)) ? a - b : countOnes(a) - countOnes(b));\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpx6gpoojd.d-mixin-17(17): Error: module `std.algorithm.sorting`\
    \ import `stableSort` not found\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpx6gpoojd.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    import std.algorithm\
    \ : sort;\n    return arr.sort!(x => (cast(string)x).count(\"1\"), \n        \
    \             y => (cast(string)y).count(\"1\"))\n             .sort!((x, y) =>\
    \ x < y);\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpj6zzk38f.d(18): Error: template `std.algorithm.sorting.sort`\
    \ cannot deduce function from argument types `!((x) => (cast(string)x).count(\"\
    1\"), (y) => (cast(string)y).count(\"1\"))(long[])`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/algorithm/sorting.d(1847):\
    \        `std.algorithm.sorting.sort(alias less = \"a < b\", SwapStrategy ss =\
    \ SwapStrategy.unstable, Range)(Range r) if ((ss == SwapStrategy.unstable && (hasSwappableElements!Range\
    \ || hasAssignableElements!Range) || ss != SwapStrategy.unstable && hasAssignableElements!Range)\
    \ && isRandomAccessRange!Range && hasSlicing!Range && hasLength!Range)`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj6zzk38f.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_dec =\
    \ arr;\n    auto arr_bin = arr.map!(a => binaryRepresentation(a));\n    auto range\
    \ = zip(arr_dec, arr_bin);\n    range.sort!((lhs, rhs) => \n        // this sort\
    \ is stable\n        rcompare(lhs[1].count('1'), rhs[1].count('1')) \n       \
    \ || \n        rcompare(lhs[0], rhs[0]));\n    return range.map!(a => a[0]).array;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpx9axydlk.d(18): Error: no property `map` for type `long[]`\\\
    n/tmp/tmpx9axydlk.d(19): Error: undefined identifier `zip`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx9axydlk.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    arr = arr.sort();\n\
    \    long[] holder = arr.dup;\n    long[][] sorted = new long[2][0];\n    foreach(long\
    \ i; 0..arr.length)\n    {\n        sorted[0] ~= i;\n        sorted[1] ~= arr[i];\n\
    \    }\n    sorted[0] = sorted[0].sort;\n    foreach(long i; 0..arr.length)\n\
    \    {\n        long x = sorted[0][i];\n        long y = sorted[1][i];\n     \
    \   holder[x] = y;\n    }\n    arr = holder;\n    return arr;\n}\nunittest\n{\n\
    \    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L])\
    \ == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) ==\
    \ [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L,\
    \ 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8xj3mqxy.d(17): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp8xj3mqxy.d(19): Error: cannot implicitly convert expression `new long[2][](0LU)`\
    \ of type `long[2][]` to `long[][]`\\n/tmp/tmp8xj3mqxy.d(25): Error: no property\
    \ `sort` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp8xj3mqxy.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return \n    \
    \    arr.dup.sort!(a, b => ((a & -a).countOnes > (b & -b).countOnes) ? 1 : \n\
    \                             ((a & -a).countOnes < (b & -b).countOnes) ? -1 :\n\
    \                                a > b ? 1 : -1);\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvfwbn9ri.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvfwbn9ri.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    arr.sort!((a,\
    \ b) => a.countOne() < b.countOne() || a.countOne() == b.countOne() && a < b)();\n\
    \    return arr;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpx_pb6s6k.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx_pb6s6k.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] sortedArr\
    \ = arr.dup;\n    // sorting array:\n    sortedArr.sort();\n    // one's counter\
    \ array:\n    long[] oneCounters = new long[arr.length];\n    // iterating array\
    \ elements:\n    foreach(i, element; sortedArr)\n    {\n        // number of ones\
    \ in element's binary representation:\n        oneCounters[i] = to!(\"binary\"\
    )(element).count(\"1\");\n    }\n    // now sorting array using one's counter\
    \ array:\n    sortedArr.sort(oneCounters);\n    return sortedArr;\n}\n \n*/\n\
    unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L,\
    \ -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L,\
    \ 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqrfpmmek.d(33): Error: declaration expected, not `*`\\n/tmp/tmpqrfpmmek.d(38):\
    \ Error: declaration expected, not `assert`\\n/tmp/tmpqrfpmmek.d(39): Error: declaration\
    \ expected, not `assert`\\n/tmp/tmpqrfpmmek.d(40): Error: declaration expected,\
    \ not `assert`\\n/tmp/tmpqrfpmmek.d(41): Error: declaration expected, not `assert`\\\
    n/tmp/tmpqrfpmmek.d(42): Error: declaration expected, not `assert`\\n/tmp/tmpqrfpmmek.d(43):\
    \ Error: declaration expected, not `assert`\\n/tmp/tmpqrfpmmek.d(44): Error: declaration\
    \ expected, not `assert`\\n/tmp/tmpqrfpmmek.d(45): Error: declaration expected,\
    \ not `assert`\\n/tmp/tmpqrfpmmek.d(46): Error: unrecognized declaration\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqrfpmmek.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n        std.bitmanip.popCount(a) != std.bitmanip.popCount(b) ? \n  \
    \          std.bitmanip.popCount(a) - std.bitmanip.popCount(b) : \n          \
    \  a.cmp(b));\n}\n```\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps894db1r.d(22): Error: declaration expected, not `\"\"`\\n/tmp/tmps894db1r.d(22):\
    \ Error: unterminated string constant starting at /tmp/tmps894db1r.d(22)\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps894db1r.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    struct binaryOnes\n\
    \    {\n        long count;\n        long value;\n    }\n    int i;\n    binaryOnes[]\
    \ b;\n    for (i = 0; i < arr.length; i++)\n    {\n        b ~= binaryOnes(countOnes(arr[i]),\
    \ arr[i]);\n    }\n    sort!((a, b) => a.count < b.count || (a.count == b.count\
    \ && a.value < b.value))(b);\n    return b.map!(x => x.value).array;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_vdfm7z8.d(26): Error: undefined identifier `countOnes`\\n/tmp/tmp_vdfm7z8.d(28):\
    \ Error: template instance `sort!((a, b) => a.count < b.count || a.count == b.count\
    \ && (a.value < b.value))` template `sort` is not defined, did you mean sqrt?\\\
    n/tmp/tmp_vdfm7z8.d(29): Error: no property `map` for type `binaryOnes[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_vdfm7z8.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    // return my solution\n\
    \    return my_solution(arr);\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzl4sl7w1.d(18): Error: undefined identifier `my_solution`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzl4sl7w1.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n  auto cmp = (a, b)\
    \ { return a[0] == b[0] ? a[1] < b[1] : a[0] < b[0]; };\n  auto ones = a => a.bitCount;\n\
    \  auto bits = a => a.toBinaryString;\n  auto pairs = arr.map!(a => tuple(ones(a),\
    \ a)).array;\n  return pairs.sort!cmp.map!((a) => a[1]).array;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzvbrn68e.d(17): Error: variable `tmpzvbrn68e.sort_array.cmp`\
    \ type `void` is inferred from initializer `(a, b)\\n{\\nreturn a[0] == b[0] ?\
    \ a[1] < b[1] : a[0] < b[0];\\n}\\n`, and variables cannot be of type `void`\\\
    n/tmp/tmpzvbrn68e.d(17): Error: template lambda has no value\\n/tmp/tmpzvbrn68e.d(18):\
    \ Error: variable `tmpzvbrn68e.sort_array.ones` type `void` is inferred from initializer\
    \ `(a) => a.bitCount`, and variables cannot be of type `void`\\n/tmp/tmpzvbrn68e.d(18):\
    \ Error: template lambda has no value\\n/tmp/tmpzvbrn68e.d(19): Error: variable\
    \ `tmpzvbrn68e.sort_array.bits` type `void` is inferred from initializer `(a)\
    \ => a.toBinaryString`, and variables cannot be of type `void`\\n/tmp/tmpzvbrn68e.d(19):\
    \ Error: template lambda has no value\\n/tmp/tmpzvbrn68e.d(20): Error: no property\
    \ `map` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmpzvbrn68e.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return new long[0];\n    auto to_tuple = (long num) => tuple(num.countOnes,\
    \ num);\n    arr.sort!\"a[0] < b[0] || (a[0] == b[0] && a[1] < b[1])\"(arr.map!to_tuple.array);\n\
    \    return arr.map!(a => a[1]).array;\n}\nunittest\n{\n    alias candidate =\
    \ sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L,\
    \ 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L,\
    \ -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L, 4L, 5L,\
    \ 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n\
    \    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n\
    \    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n  \
    \  assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpghthzj8z.d(19): Error: no property `countOnes` for type `long`\\\
    n/tmp/tmpghthzj8z.d(20): Error: no property `sort` for type `long[]`\\n/tmp/tmpghthzj8z.d(21):\
    \ Error: no property `map` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpghthzj8z.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto cmp = (long\
    \ a, long b) =>\n    {\n        size_t aones = numBitsIn(a);\n        size_t bones\
    \ = numBitsIn(b);\n        return  aones == bones ? a.compare(b) : aones.compare(bones);\n\
    \    };\n    return arr.sort!cmp;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp44vqkcju.d(19): Error: undefined identifier `numBitsIn`\\n/tmp/tmp44vqkcju.d(20):\
    \ Error: undefined identifier `numBitsIn`\\n/tmp/tmp44vqkcju.d(21): Error: no\
    \ property `compare` for type `long`\\n/tmp/tmp44vqkcju.d(21): Error: no property\
    \ `compare` for type `ulong`\\n/tmp/tmp44vqkcju.d(23): Error: no property `sort`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp44vqkcju.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    arr.sort!((a,\
    \ b) => cast(int) Math.countOnes(a) < cast(int) Math.countOnes(b) ||\n       \
    \                   (Math.countOnes(a) == Math.countOnes(b) && a < b));\n    return\
    \ arr;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp17sg7giw.d(17): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp17sg7giw.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto m = new int[100];\n\
    \    foreach(i; arr)\n    {\n        long j = i;\n        int k = 0;\n       \
    \ while(j)\n        {\n            if(j & 1)\n                k++;\n         \
    \   j >>= 1;\n        }\n        m[k]++;\n    }\n    int n = 0;\n    foreach(i;\
    \ 0 .. 100)\n    {\n        if(m[i] == 0)\n            continue;\n        foreach(j;\
    \ 0 .. m[i])\n        {\n            while(arr[n] & (1 << i) == 0)\n         \
    \       n++;\n            arr[n++] = arr[j];\n        }\n    }\n    return arr;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp452044tc.d(37): Error: `1 << i == 0` must be parenthesized when\
    \ next to operator `&`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmp452044tc.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    auto tmp = arr.dup;\n\
    \    tmp.sort!((long a, long b) =>\n    {\n        int c = countOnes(a);\n   \
    \     int d = countOnes(b);\n        if (c == d)\n            return a - b;\n\
    \        return c - d;\n    });\n    return tmp;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpja21e7d_.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpja21e7d_.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] a = arr.dup;\n\
    \    sort(a, (int a, int b) => \n    {\n        return cast(ulong)a.countOneBits.cmp(b.countOneBits)\
    \ ?: a.cmp(b);\n    });\n    return a;\n}\nunittest\n{\n    alias candidate =\
    \ sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L,\
    \ 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L,\
    \ -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L, 4L, 5L,\
    \ 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n\
    \    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n\
    \    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n  \
    \  assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdo6kfltk.d(20): Error: expression expected, not `:`\\n/tmp/tmpdo6kfltk.d(20):\
    \ Error: found `a` when expecting `:`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpdo6kfltk.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n    enum int_with_ones\
    \ \n    {\n        int_with_ones(long n)\n        {\n            int nOnes = n.countOneBits;\n\
    \            this.ones = nOnes;\n            this.int_ = n;\n        }\n     \
    \   \n        override bool opEquals(Object rhs)\n        {\n            return\
    \ this.int_ == cast(int_with_ones)rhs.int_;\n        }\n        \n        override\
    \ int opCmp(Object rhs)\n        {\n            auto iwo = cast(int_with_ones)rhs;\n\
    \            if (this.ones != iwo.ones)\n                return this.ones - iwo.ones;\n\
    \            return this.int_ - iwo.int_;\n        }\n        \n        int ones;\n\
    \        long int_;\n    }\n    \n    auto arr2 = arr.map!(n => int_with_ones(n));\n\
    \    return arr2.sort.map!(n => n.int_);\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0xof30xg.d(19): Error: function declaration without return type.\
    \ (Note that constructors are always named `this`)\\n/tmp/tmp0xof30xg.d(20): Error:\
    \ no identifier for declarator `int_with_ones(long n)`\\n/tmp/tmp0xof30xg.d(20):\
    \ Error: type only allowed if anonymous enum and no enum type\\n/tmp/tmp0xof30xg.d(20):\
    \ Error: if type, there must be an initializer\\n/tmp/tmp0xof30xg.d(20): Error:\
    \ found `{` when expecting `,`\\n/tmp/tmp0xof30xg.d(21): Error: type only allowed\
    \ if anonymous enum and no enum type\\n/tmp/tmp0xof30xg.d(21): Error: found `;`\
    \ when expecting `,`\\n/tmp/tmp0xof30xg.d(22): Error: no identifier for declarator\
    \ `this.ones`\\n/tmp/tmp0xof30xg.d(22): Error: type only allowed if anonymous\
    \ enum and no enum type\\n/tmp/tmp0xof30xg.d(22): Error: found `;` when expecting\
    \ `,`\\n/tmp/tmp0xof30xg.d(23): Error: no identifier for declarator `this.int_`\\\
    n/tmp/tmp0xof30xg.d(23): Error: type only allowed if anonymous enum and no enum\
    \ type\\n/tmp/tmp0xof30xg.d(23): Error: found `;` when expecting `,`\\n/tmp/tmp0xof30xg.d(26):\
    \ Error: found `override` instead of statement\\n/tmp/tmp0xof30xg.d(41): Error:\
    \ unrecognized declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp0xof30xg.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n{\n  int[] index = new\
    \ int[arr.length];\n  for (int i = 0; i < arr.length; i++)\n  {\n    index[i]\
    \ = i;\n  }\n  index.sort!(key = (a, b) => ((long.countOnes(arr[a])) - (long.countOnes(arr[b])))\
    \ == 0\n                    ? arr[a] - arr[b]\n                    : (long.countOnes(arr[a]))\
    \ - (long.countOnes(arr[b])));\n  \n  long[] arr_copy = arr.dup;\n  for (int i\
    \ = 0; i < arr.length; i++)\n  {\n    arr[i] = arr_copy[index[i]];\n  }\n  return\
    \ arr;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprx0g2gcl.d(22): Error: no property `sort` for type `int[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprx0g2gcl.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
