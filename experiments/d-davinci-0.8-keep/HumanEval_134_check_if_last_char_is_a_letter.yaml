name: HumanEval_134_check_if_last_char_is_a_letter
language: d
prompt: "import std.math;\n/*\n\n    Create a function that returns True if the last\
  \ character\n    of a given string is an alphabetical character and is not\n   \
  \ a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters\
  \ separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple\
  \ pie\") \u279E False\n    check_if_last_char_is_a_letter(\"apple pi e\") \u279E\
  \ True\n    check_if_last_char_is_a_letter(\"apple pi e \") \u279E False\n    check_if_last_char_is_a_letter(\"\
  \") \u279E False \n    \n*/\nbool check_if_last_char_is_a_letter(string txt) \n"
tests: "unittest\n{\n    alias candidate = check_if_last_char_is_a_letter;\n\n   \
  \ assert(candidate(\"apple\") == false);\n    assert(candidate(\"apple pi e\") ==\
  \ true);\n    assert(candidate(\"eeeee\") == false);\n    assert(candidate(\"A\"\
  ) == true);\n    assert(candidate(\"Pumpkin pie \") == false);\n    assert(candidate(\"\
  Pumpkin pie 1\") == false);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
  eeeee e \") == false);\n    assert(candidate(\"apple pie\") == false);\n    assert(candidate(\"\
  apple pi e \") == false);\n}\nvoid main(){}"
completions: ["{\n    if (txt.empty())\n        return false;\n    else\n    {\n \
    \       for (auto c : txt)\n        {\n            if (c == ' ')\n           \
    \     return false;\n        }\n        int last_char = txt.length() - 1;\n  \
    \      //cout << txt[last_char] << \" \" << isalpha(txt[last_char]) << endl;\n\
    \        return isalpha(txt[last_char]);\n    }\n}", "{\n    return isalpha(txt[txt.length\
    \ - 1]) && ! isalpha(txt[txt.length - 2]);\n}", "{\n    if (txt.length == 0) return\
    \ false;\n    if (isalpha(txt[txt.length - 1]) && txt[txt.length - 1] != ' ')\n\
    \        return true;\n    return false;\n}", "{\n    if (txt.length == 0)\n \
    \       return false;\n    if (!isalpha(txt[txt.length - 1]))\n        return\
    \ false;\n    for (int i = 0; i < txt.length - 1; i++)\n    {\n        if (isalpha(txt[i])\
    \ && isalpha(txt[i + 1]))\n            return false;\n    }\n    return true;\n\
    }", "{\n    int i = txt.length - 1;\n    return isalpha(txt[i]) && txt[i-1] ==\
    \ ' ';\n}", "{\n    return (txt.size() > 0) ? (isalpha(txt[txt.size()-1]) && txt[txt.size()-1]\
    \ != ' ') : false;\n}", "{\n    return (txt.size() > 0) ? txt[txt.size() - 1]\
    \ >= 'a' && txt[txt.size() - 1] <= 'z' && (txt.size() == 1 || txt[txt.size() -\
    \ 2] == ' ') : false;\n}", "{\n    char lastChar = txt[txt.length - 1];\n    int\
    \ x = 0;\n    if (txt.length == 0) {\n        return false;\n    } else {\n  \
    \      while (lastChar.isSpace()) {\n            lastChar = txt[txt.length - x\
    \ - 1];\n            x++;\n        }\n        if (lastChar.isAlpha) {\n      \
    \      return true;\n        } else {\n            return false;\n        }\n\
    \    }\n}", "{\n\tconst int len = txt.length();\n\tif (len == 0)\n\t\treturn false;\n\
    \tif (isLetter(txt[len - 1]))\n\t\treturn true;\n\treturn false;\n}", "{\n   \
    \ char l = txt[txt.length - 1];\n    return (l >= 'a' && l <= 'z') || (l >= 'A'\
    \ && l <= 'Z');\n}", "{\n    return isalpha(txt[txt.length - 1]) && txt[txt.length\
    \ - 1] != ' ';\n}", "{\n    if ( txt.length() == 0 )\n        return false;\n\
    \    else if ( txt[txt.length()-1] == ' ')\n        return false;\n    else if\
    \ ( txt[txt.length()-1] >= 'a' && txt[txt.length()-1] <= 'z' )\n        return\
    \ true;\n    else if ( txt[txt.length()-1] >= 'A' && txt[txt.length()-1] <= 'Z'\
    \ )\n        return true;\n    else \n        return false;\n}", "{\n    if (txt\
    \ == \"\")\n        return false;\n    if (txt[txt.length - 1] >= 'a' && txt[txt.length\
    \ - 1] <= 'z')\n        return true;\n    if (txt[txt.length - 1] >= 'A' && txt[txt.length\
    \ - 1] <= 'Z')\n        return true;\n    return false;\n}", "{\n    return txt.length()\
    \ > 0 && isalpha(txt[txt.length() - 1]) && txt[txt.length() - 1] != ' ' && txt[txt.length()\
    \ - 2] == ' ';\n}", "{\n    bool result = false;\n    char last = txt[txt.length\
    \ - 1];\n    if(last == ' ')\n    {\n        result = false;\n    }\n    else\
    \ if(isalpha(last))\n    {\n        result = true;\n    }\n    return result;\n\
    }", "{\n    bool isLetter = false;\n    int lastIndex = txt.length() - 1;\n  \
    \  for (int i = lastIndex; i >= 0; i--) {\n        if (txt[i] == ' ') {\n    \
    \        break;\n        }\n        if (isalpha(txt[i])) {\n            isLetter\
    \ = true;\n            break;\n        }\n    }\n    return isLetter;\n}", "{\n\
    \    return char.isLetter(txt[txt.length-1]) && !char.isLetter(txt[txt.length-2]);\n\
    }", "{\n    if (txt.length == 0) return false;\n    return !std.regex.is_match(std.regex(\"\
    \\\\w\"), txt[txt.length - 1]);\n}", "{\n    return txt.length() > 0 && isalpha(txt[txt.length()\
    \ - 1]) && txt[txt.length() - 1] != ' ';\n}", "{\n    if (txt.length == 0)\n \
    \       return false;\n    string lastChar = txt.substr(txt.length - 1, txt.length);\n\
    \    if (lastChar[0] == ' ')\n        return false;\n    if (isalpha(lastChar[0]))\n\
    \        return true;\n    return false;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
