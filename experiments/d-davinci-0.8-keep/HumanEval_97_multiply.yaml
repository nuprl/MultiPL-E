name: HumanEval_97_multiply
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\nComplete the function that takes\
  \ two integers and returns \n    the product of their unit digits.\n    Assume the\
  \ input is always valid.\n    Examples:\n    multiply(148, 412) should return 16.\n\
  \    multiply(19, 28) should return 72.\n    multiply(2020, 1851) should return\
  \ 0.\n    multiply(14,-15) should return 20.\n    \n*/\nlong multiply(long a, long\
  \ b) \n"
tests: "unittest\n{\n    alias candidate = multiply;\n\n    assert(candidate(148L,\
  \ 412L) == 16L);\n    assert(candidate(19L, 28L) == 72L);\n    assert(candidate(2020L,\
  \ 1851L) == 0L);\n    assert(candidate(14L, -15L) == 20L);\n    assert(candidate(76L,\
  \ 67L) == 42L);\n    assert(candidate(17L, 27L) == 49L);\n    assert(candidate(0L,\
  \ 1L) == 0L);\n    assert(candidate(0L, 0L) == 0L);\n}\nvoid main(){}"
completions: ["{\n    return (int)(a % 10) * (int)(b % 10);\n}", "{\n    long al =\
    \ abs(a);\n    long bl = abs(b);\n    auto as = to!string(al);\n    auto bs =\
    \ to!string(bl);\n    return (as[$-1] - '0') * (bs[$-1] - '0');\n}", "{\n    long\
    \ aa = abs(a);\n    long bb = abs(b);\n    ulong aul = cast(ulong)aa;\n    ulong\
    \ bul = cast(ulong)bb;\n    ulong auld = ulong.max;\n    ulong buld = ulong.max;\n\
    \    while(aul > 0){\n        auld = aul%10;\n        aul = aul/10;\n    }\n \
    \   while(bul > 0){\n        buld = bul%10;\n        bul = bul/10;\n    }\n  \
    \  if(auld == ulong.max || buld == ulong.max){\n        return 0;\n    }\n   \
    \ return cast(long)(auld*buld);\n}", "{\n    long ar = a.abs;\n    long br = b.abs;\n\
    \    return (ar % 10) * (br % 10);\n}", "{\n    auto s = to!string(a) * to!string(b);\n\
    \    return s[$-1] - '0';\n}", "{\n    auto product = a * b;\n    long unitDigitProduct\
    \ = product % 10;\n    long val = abs(unitDigitProduct);\n    long result = val\
    \ * val;\n    return result;\n}", "{\n    return abs(a%10) * abs(b%10);\n}", "{\n\
    \    // Your code here\n    return a.digits.front*b.digits.front;\n}", "{\n  \
    \  long productOfDigits;\n    long newProductOfDigits;\n    long newProductOfDigits2;\n\
    \    long temp;\n    long negMulti = 0;\n    long altMulti = 0;\n    long altMulti2\
    \ = 0;\n    int productOfDigitsLength;\n    int length;\n    bool negative = false;\n\
    \    bool negative2 = false;\n    bool negative3 = false;\n    bool negative4\
    \ = false;\n    if(a < 0)\n    {\n        a = abs(a);\n        negative = true;\n\
    \    }\n    if(b < 0)\n    {\n        b = abs(b);\n        negative2 = true;\n\
    \    }\n    auto digitsa = to!dchar(a);\n    auto digitsb = to!dchar(b);\n   \
    \ productOfDigits = digitsa[$-1] * digitsb[$-1];\n    //writefln(\"productOfDigits\
    \ = %d\", productOfDigits);\n    if(productOfDigits > 9)\n    {\n        newProductOfDigits\
    \ = productOfDigits / 10;\n        //writefln(\"newProductOfDigits = %d\", newProductOfDigits);\n\
    \        productOfDigitsLength = to!string(productOfDigits).length;\n        //writefln(\"\
    productOfDigitsLength = %d\", productOfDigitsLength);\n        length = to!string(newProductOfDigits).length;\n\
    \        //writefln(\"length = %d\", length);\n        if(length > 1)\n      \
    \  {\n            temp = newProductOfDigits % 10;\n            //writefln(\"temp\
    \ = %d\", temp);\n            altMulti = newProductOfDigits - temp;\n        \
    \    //writefln(\"altMulti = %d\", altMulti);\n            negMulti = (productOfDigitsLength\
    \ - 1) * temp;\n            //writefln(\"negMulti = %d\", negMulti);\n       \
    \     newProductOfDigits2 = newProductOfDigits / 10;\n            //writefln(\"\
    newProductOfDigits2 = %d\", newProductOfDigits2);\n            length = to!string(newProductOfDigits2).length;\n\
    \            //write", "{\n    long p = a * b;\n    while(p > 10) {\n        p\
    \ = ((int)p % 10) * ((int)p / 10);\n    }\n    return p;\n}", "{\n    import std.array;\n\
    \    ulong ua = cast(ulong)a;\n    ulong ub = cast(ulong)b;\n    uint[] uaArray\
    \ = ua.toString().to!(uint[]);\n    uint[] ubArray = ub.toString().to!(uint[]);\n\
    \    ulong uaMult = uaArray[uaArray.length-1];\n    ulong ubMult = ubArray[ubArray.length-1];\n\
    \    return cast(long)(uaMult * ubMult);\n}", "{\n    if(a == 0 || b == 0)\n \
    \       return 0;\n    return (abs(a) % 10) * (abs(b) % 10);\n}", "{\n    if(a==0||b==0)\n\
    \        return 0;\n    if(a<0&&b<0)\n        return abs(a).to!long%10*abs(b).to!long%10;\n\
    \    if(a<0||b<0)\n        return -abs(a).to!long%10*abs(b).to!long%10;\n    return\
    \ a%10*b%10;\n}", "{\n    const int base = 10;\n    return (a % base) * (b % base);\n\
    }", "{\n    return ((abs(a)%10)*(abs(b)%10));\n}", "{\n    long aLastDigit = a\
    \ % 10;\n    long bLastDigit = b % 10;\n    return aLastDigit * bLastDigit;\n}",
  "{\n    // write your code here\n    long product = 0;\n    if(a != 0 && b != 0)\n\
    \    {\n        product = 1;\n        long x = a.abs;\n        long y = b.abs;\n\
    \        while(x > 1)\n        {\n            product *= x % 10;\n           \
    \ x /= 10;\n        }\n        while(y > 1)\n        {\n            product *=\
    \ y % 10;\n            y /= 10;\n        }\n        return product;\n    }\n \
    \   return product;\n}", "{\n    return a * b % 10;\n}\n/*\nIf we were to set\
    \ up a Tic-Tac-Toe game, we would want to know whether the board's current state\
    \ is solved, wouldn't we? \nOur goal is to create a function that will check that\
    \ for us!\nAssume that the board comes in the form of a 3x3 array, where the value\
    \ is 0 if a spot is empty, 1 if it is an \"X\", or 2 if it is an \"O\", like so:\n\
    [[0, 0, 1],\n [0, 1, 2],\n [2, 1, 0]]\nWe want our function to return:\n-1 if\
    \ the board is not yet finished (there are empty spots),\n1 if \"X\" won,\n2 if\
    \ \"O\" won,\n0 if it's a cat's game (i.e. a draw).\nYou may assume that the board\
    \ passed in is valid in the context of a game of Tic-Tac-Toe.\n*/", "{\n\t// great\
    \ example of using nummbers as strings\n    // take digit from the end of the\
    \ number\n    // multiply it by the other numbers unit digit\n    // and return\
    \ the product\n    // NOTE: you could also just convert a and b to strings\n \
    \   // then take the last digits and convert them to ints\n    // and do math\
    \ but then you have to convert back to strings\n    // this way is much easier\n\
    \    \n    // if a or b is negative, make them positive\n    // so we can take\
    \ the last digit\n    if(a < 0)\n        a = -a;\n    if(b < 0)\n        b = -b;\n\
    \    \n    // get the last digit of a, take the mod of a by 10\n    a = a % 10;\n\
    \    // get the last digit of b, take the mod of b by 10\n    b = b % 10;\n  \
    \  \n    // now we have the last digits of a and b\n    // so multiply them and\
    \ return the product\n    return a * b;\n}", "{\n  long res = a*b;\n  return abs(res\
    \ % 10);\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
