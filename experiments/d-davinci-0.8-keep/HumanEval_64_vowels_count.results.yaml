name: HumanEval_64_vowels_count
language: d
results:
- program: "import std.math;\n/*\nWrite a function vowels_count which takes a string\
    \ representing\n    a word as input and returns the number of vowels in the string.\n\
    \    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  \
    \  vowel, but only when it is at the end of the given word.\n\n    Example:\n\
    \    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n   \
    \ 3\n    \n*/\nlong vowels_count(string s) \n{\n    long counter = 0;\n    foreach(char\
    \ c; s)\n    {\n        switch(c)\n        {\n            case 'a':\n        \
    \    case 'e':\n            case 'i':\n            case 'o':\n            case\
    \ 'u':\n            case 'y':\n                counter += 1;\n        }\n    }\n\
    \    return counter;\n}\nunittest\n{\n    alias candidate = vowels_count;\n\n\
    \    assert(candidate(\"abcde\") == 2L);\n    assert(candidate(\"Alone\") == 3L);\n\
    \    assert(candidate(\"key\") == 2L);\n    assert(candidate(\"bye\") == 1L);\n\
    \    assert(candidate(\"keY\") == 2L);\n    assert(candidate(\"bYe\") == 1L);\n\
    \    assert(candidate(\"ACEDY\") == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpid32amiq.d(20): Error: `switch` statement without a `default`;\
    \ use `final switch` or add `default: assert(0);` or add `default: break;`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpid32amiq.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\nWrite a function vowels_count which takes a string\
    \ representing\n    a word as input and returns the number of vowels in the string.\n\
    \    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  \
    \  vowel, but only when it is at the end of the given word.\n\n    Example:\n\
    \    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n   \
    \ 3\n    \n*/\nlong vowels_count(string s) \n{\n    long n = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\
    \ || c == 'y')\n            n++;\n    }\n    return n;\n}\n/*\nWrite a function\
    \ is_pangram which takes a string representing a\n    sentence as input and returns\
    \ a boolean value. If the input sentence\n    is a pangram then the function should\
    \ return True else it should\n    return False. A pangram is a sentence which\
    \ uses all the 26\n    letters of the alphabet at least once.\nunittest\n{\n \
    \   alias candidate = vowels_count;\n\n    assert(candidate(\"abcde\") == 2L);\n\
    \    assert(candidate(\"Alone\") == 3L);\n    assert(candidate(\"key\") == 2L);\n\
    \    assert(candidate(\"bye\") == 1L);\n    assert(candidate(\"keY\") == 2L);\n\
    \    assert(candidate(\"bYe\") == 1L);\n    assert(candidate(\"ACEDY\") == 3L);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvsqimbdm.d(25): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvsqimbdm.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\nWrite a function vowels_count which takes a string\
    \ representing\n    a word as input and returns the number of vowels in the string.\n\
    \    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  \
    \  vowel, but only when it is at the end of the given word.\n\n    Example:\n\
    \    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n   \
    \ 3\n    \n*/\nlong vowels_count(string s) \n{\n    auto v = \"aeiouy\";\n   \
    \ auto x = filter!( (a) => (v.find(a) != -1) )(s);\n    return x.length;\n}\n\
    unittest\n{\n    alias candidate = vowels_count;\n\n    assert(candidate(\"abcde\"\
    ) == 2L);\n    assert(candidate(\"Alone\") == 3L);\n    assert(candidate(\"key\"\
    ) == 2L);\n    assert(candidate(\"bye\") == 1L);\n    assert(candidate(\"keY\"\
    ) == 2L);\n    assert(candidate(\"bYe\") == 1L);\n    assert(candidate(\"ACEDY\"\
    ) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjgjhars6.d(18): Error: template instance `filter!((a) => v.find(a)\
    \ != -1)` template `filter` is not defined\\nFailed: [\"dmd\", \"-unittest\",\
    \ \"-v\", \"-o-\", \"/tmp/tmpjgjhars6.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\nWrite a function vowels_count which takes a string\
    \ representing\n    a word as input and returns the number of vowels in the string.\n\
    \    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  \
    \  vowel, but only when it is at the end of the given word.\n\n    Example:\n\
    \    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n   \
    \ 3\n    \n*/\nlong vowels_count(string s) \n{\n    long count = 0;\n    foreach(immutable\
    \ c; s)\n    {\n        // If a char is a vowel, increment count\n        // \
    \ note the use of lower case 'a' but upper\n        //  case 'A'\n        if(c\
    \ == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E'\
    \ || c == 'I' || c == 'O' || c == 'U')\n        {\n            count++;\n    \
    \    }\n    }\n    // If the char 'y' is the last char, increment count\n    if(s[$-1]\
    \ == 'y')\n    {\n        count++;\n    }\n    return count;\n}\nunittest\n{\n\
    \    alias candidate = vowels_count;\n\n    assert(candidate(\"abcde\") == 2L);\n\
    \    assert(candidate(\"Alone\") == 3L);\n    assert(candidate(\"key\") == 2L);\n\
    \    assert(candidate(\"bye\") == 1L);\n    assert(candidate(\"keY\") == 2L);\n\
    \    assert(candidate(\"bYe\") == 1L);\n    assert(candidate(\"ACEDY\") == 3L);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpz3fd5sg_.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427ead]\\n??:? void tmpz3fd5sg_.__unittest_L35_C1()\
    \ [0x427bc6]\\n??:? void tmpz3fd5sg_.__modtest() [0x427c30]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc47]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42aada]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc6d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x43011c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fbf9]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aab1]\\n??:? runModuleUnitTests [0x42ba1d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428370]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4282f7]\\n??:? _d_run_main [0x428262]\\n??:? main [0x427c43]\\\
    n??:? __libc_start_main [0x9d53b554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\nWrite a function vowels_count which takes a string\
    \ representing\n    a word as input and returns the number of vowels in the string.\n\
    \    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  \
    \  vowel, but only when it is at the end of the given word.\n\n    Example:\n\
    \    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n   \
    \ 3\n    \n*/\nlong vowels_count(string s) \n{\n    long count = 0;\n    for (auto\
    \ c: s) {\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\
    \ ||\n            (c == 'y' && (s.length() - 1) == s.find(c))) {\n           \
    \ count += 1;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias\
    \ candidate = vowels_count;\n\n    assert(candidate(\"abcde\") == 2L);\n    assert(candidate(\"\
    Alone\") == 3L);\n    assert(candidate(\"key\") == 2L);\n    assert(candidate(\"\
    bye\") == 1L);\n    assert(candidate(\"keY\") == 2L);\n    assert(candidate(\"\
    bYe\") == 1L);\n    assert(candidate(\"ACEDY\") == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpit0uito7.d(18): Error: no identifier for declarator `c`\\n/tmp/tmpit0uito7.d(18):\
    \ Error: expression expected, not `:`\\n/tmp/tmpit0uito7.d(18): Error: found `s`\
    \ when expecting `;` following `for` condition\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpit0uito7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\nWrite a function vowels_count which takes a string\
    \ representing\n    a word as input and returns the number of vowels in the string.\n\
    \    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  \
    \  vowel, but only when it is at the end of the given word.\n\n    Example:\n\
    \    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n   \
    \ 3\n    \n*/\nlong vowels_count(string s) \n{\n    long result = 0;\n    bool\
    \ yIsVowel = false;\n    foreach(c; s) {\n        if (c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u') {\n            ++result;\n        }\n    \
    \    if (c == 'y') {\n            yIsVowel = true;\n        }\n    }\n    if (yIsVowel)\
    \ {\n        ++result;\n    }\n    return result;\n}\n/*\nWrite a function sum_multiples\
    \ which takes an integer\n    N as input and returns the sum of all the positive\n\
    \    integers from 1 to N, whose last digit is also 3.\n    For example, the last\
    \ digit of 4567 is 7, which is not 3.\n    The last digit of 7568 is 8, which\
    \ is not 3.\nunittest\n{\n    alias candidate = vowels_count;\n\n    assert(candidate(\"\
    abcde\") == 2L);\n    assert(candidate(\"Alone\") == 3L);\n    assert(candidate(\"\
    key\") == 2L);\n    assert(candidate(\"bye\") == 1L);\n    assert(candidate(\"\
    keY\") == 2L);\n    assert(candidate(\"bYe\") == 1L);\n    assert(candidate(\"\
    ACEDY\") == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppsx2wyuj.d(32): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppsx2wyuj.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\nWrite a function vowels_count which takes a string\
    \ representing\n    a word as input and returns the number of vowels in the string.\n\
    \    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  \
    \  vowel, but only when it is at the end of the given word.\n\n    Example:\n\
    \    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n   \
    \ 3\n    \n*/\nlong vowels_count(string s) \n{\n    long count = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\
    \ || c == 'y')\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\nunittest\n{\n    alias candidate = vowels_count;\n\n    assert(candidate(\"\
    abcde\") == 2L);\n    assert(candidate(\"Alone\") == 3L);\n    assert(candidate(\"\
    key\") == 2L);\n    assert(candidate(\"bye\") == 1L);\n    assert(candidate(\"\
    keY\") == 2L);\n    assert(candidate(\"bYe\") == 1L);\n    assert(candidate(\"\
    ACEDY\") == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpa8ztrhcf.d(32): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e5d]\\n??:? void tmpa8ztrhcf.__unittest_L27_C1()\
    \ [0x427af1]\\n??:? void tmpa8ztrhcf.__modtest() [0x427be0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb83]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42aa16]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fba9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430058]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fb35]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a9ed]\\n??:? runModuleUnitTests [0x42b959]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4282ac]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428233]\\n??:? _d_run_main [0x42819e]\\n??:? main [0x427bf3]\\\
    n??:? __libc_start_main [0x1bdeb554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\nWrite a function vowels_count which takes a string\
    \ representing\n    a word as input and returns the number of vowels in the string.\n\
    \    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  \
    \  vowel, but only when it is at the end of the given word.\n\n    Example:\n\
    \    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n   \
    \ 3\n    \n*/\nlong vowels_count(string s) \n{\n  long count = 0;\n  long len\
    \ = s.length;\n  char last = s[len-1];\n  if (last == 'a' || last == 'e' || last\
    \ == 'i' || last == 'o' || last == 'u' || last == 'y')\n  {\n      count++;\n\
    \  }\n  for (long i = 0; i < len-1; i++)\n  {\n      if (s[i] == 'a' || s[i] ==\
    \ 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u')\n      {\n          count++;\n\
    \      }\n  }\n  return count;\n}\nunittest\n{\n    alias candidate = vowels_count;\n\
    \n    assert(candidate(\"abcde\") == 2L);\n    assert(candidate(\"Alone\") ==\
    \ 3L);\n    assert(candidate(\"key\") == 2L);\n    assert(candidate(\"bye\") ==\
    \ 1L);\n    assert(candidate(\"keY\") == 2L);\n    assert(candidate(\"bYe\") ==\
    \ 1L);\n    assert(candidate(\"ACEDY\") == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmphlint31d.d(38): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f15]\\n??:? void tmphlint31d.__unittest_L33_C1()\
    \ [0x427ba5]\\n??:? void tmphlint31d.__modtest() [0x427c94]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bcaf]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab42]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fcd5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430184]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc61]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42ab19]\\n??:? runModuleUnitTests [0x42ba85]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4283d8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42835f]\\n??:? _d_run_main [0x4282ca]\\n??:? main [0x427ca7]\\\
    n??:? __libc_start_main [0x2460c554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\nWrite a function vowels_count which takes a string\
    \ representing\n    a word as input and returns the number of vowels in the string.\n\
    \    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  \
    \  vowel, but only when it is at the end of the given word.\n\n    Example:\n\
    \    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n   \
    \ 3\n    \n*/\nlong vowels_count(string s) \n{\n    long count = 0;\n    for (int\
    \ i = 0; i < s.length; i++)\n    {\n        if (s[i] == 'a' || s[i] == 'e' ||\
    \ s[i] == 'i' || s[i] == 'o' || s[i] == 'u')\n        {\n            count++;\n\
    \        }\n        else if (s[i] == 'y' && i == s.length - 1)\n        {\n  \
    \          count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n   \
    \ alias candidate = vowels_count;\n\n    assert(candidate(\"abcde\") == 2L);\n\
    \    assert(candidate(\"Alone\") == 3L);\n    assert(candidate(\"key\") == 2L);\n\
    \    assert(candidate(\"bye\") == 1L);\n    assert(candidate(\"keY\") == 2L);\n\
    \    assert(candidate(\"bYe\") == 1L);\n    assert(candidate(\"ACEDY\") == 3L);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpp26b9_5a.d(36): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f0d]\\n??:? void tmpp26b9_5a.__unittest_L31_C1()\
    \ [0x427b9d]\\n??:? void tmpp26b9_5a.__modtest() [0x427c8c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bca7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab3a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fccd]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x43017c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc59]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42ab11]\\n??:? runModuleUnitTests [0x42ba7d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4283d0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428357]\\n??:? _d_run_main [0x4282c2]\\n??:? main [0x427c9f]\\\
    n??:? __libc_start_main [0xe5481554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\nWrite a function vowels_count which takes a string\
    \ representing\n    a word as input and returns the number of vowels in the string.\n\
    \    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  \
    \  vowel, but only when it is at the end of the given word.\n\n    Example:\n\
    \    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n   \
    \ 3\n    \n*/\nlong vowels_count(string s) \n{\n    long result = 0;\n    for\
    \ (long i = 0; i < s.length; i++)\n    {\n        string c = s[i .. i + 1];\n\
    \        result += (c == \"a\" || c == \"e\" || c == \"i\" || c == \"o\" || c\
    \ == \"u\" || c == \"y\") ? 1 : 0;\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = vowels_count;\n\n    assert(candidate(\"abcde\") == 2L);\n\
    \    assert(candidate(\"Alone\") == 3L);\n    assert(candidate(\"key\") == 2L);\n\
    \    assert(candidate(\"bye\") == 1L);\n    assert(candidate(\"keY\") == 2L);\n\
    \    assert(candidate(\"bYe\") == 1L);\n    assert(candidate(\"ACEDY\") == 3L);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp0p0r_bjt.d(30): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42805d]\\n??:? void tmp0p0r_bjt.__unittest_L25_C1()\
    \ [0x427c55]\\n??:? void tmp0p0r_bjt.__modtest() [0x427de0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bd7b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ac8a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fda1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430250]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fd2d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42ac61]\\n??:? runModuleUnitTests [0x42bb51]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428520]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4284a7]\\n??:? _d_run_main [0x428412]\\n??:? main [0x427df3]\\\
    n??:? __libc_start_main [0xc7a7b554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\nWrite a function vowels_count which takes a string\
    \ representing\n    a word as input and returns the number of vowels in the string.\n\
    \    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  \
    \  vowel, but only when it is at the end of the given word.\n\n    Example:\n\
    \    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n   \
    \ 3\n    \n*/\nlong vowels_count(string s) \n{\n    long vowels = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\
    \ || c == 'y')\n        {\n            vowels += 1;\n        }\n    }\n    return\
    \ vowels;\n}\nunittest\n{\n    alias candidate = vowels_count;\n\n    assert(candidate(\"\
    abcde\") == 2L);\n    assert(candidate(\"Alone\") == 3L);\n    assert(candidate(\"\
    key\") == 2L);\n    assert(candidate(\"bye\") == 1L);\n    assert(candidate(\"\
    keY\") == 2L);\n    assert(candidate(\"bYe\") == 1L);\n    assert(candidate(\"\
    ACEDY\") == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp2ssu4ic4.d(32): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e5d]\\n??:? void tmp2ssu4ic4.__unittest_L27_C1()\
    \ [0x427af1]\\n??:? void tmp2ssu4ic4.__modtest() [0x427be0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb83]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42aa16]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fba9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430058]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fb35]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a9ed]\\n??:? runModuleUnitTests [0x42b959]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4282ac]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428233]\\n??:? _d_run_main [0x42819e]\\n??:? main [0x427bf3]\\\
    n??:? __libc_start_main [0xefa1f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\nWrite a function vowels_count which takes a string\
    \ representing\n    a word as input and returns the number of vowels in the string.\n\
    \    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  \
    \  vowel, but only when it is at the end of the given word.\n\n    Example:\n\
    \    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n   \
    \ 3\n    \n*/\nlong vowels_count(string s) \n{\n\tlong c = 0;\n\tforeach(dchar\
    \ ci; s)\n\t{\n\t\tauto l = toLower(ci);\n\t\tif(l == 'a' || l == 'e' || l ==\
    \ 'i' || l == 'o' || l == 'u')\n\t\t\tc++;\n\t}\n\treturn c;\n}\n/*\nWrite a function\
    \ that returns true if the number of vowels in a given\n    string is odd, and\
    \ false otherwise. You can assume that the\n    string contains only lowercase\
    \ letters.\n    \n    Example:\n    >>> is_odd_vowels(\"cat\")\n    true\n   \
    \ >>> is_odd_vowels(\"dog\")\n    false\n*/\nunittest\n{\n    alias candidate\
    \ = vowels_count;\n\n    assert(candidate(\"abcde\") == 2L);\n    assert(candidate(\"\
    Alone\") == 3L);\n    assert(candidate(\"key\") == 2L);\n    assert(candidate(\"\
    bye\") == 1L);\n    assert(candidate(\"keY\") == 2L);\n    assert(candidate(\"\
    bYe\") == 1L);\n    assert(candidate(\"ACEDY\") == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgabvlvy8.d(20): Error: undefined identifier `toLower`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgabvlvy8.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\nWrite a function vowels_count which takes a string\
    \ representing\n    a word as input and returns the number of vowels in the string.\n\
    \    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  \
    \  vowel, but only when it is at the end of the given word.\n\n    Example:\n\
    \    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n   \
    \ 3\n    \n*/\nlong vowels_count(string s) \n{\n    long num = 0;\n    // Put\
    \ your code here.\n    foreach(char c; s)\n    {\n        switch(c)\n        {\n\
    \            case 'a':\n            case 'e':\n            case 'i':\n       \
    \     case 'o':\n            case 'u':\n            case 'y':\n              \
    \  num++;\n        }\n    }\n    return num;\n}\nunittest\n{\n    alias candidate\
    \ = vowels_count;\n\n    assert(candidate(\"abcde\") == 2L);\n    assert(candidate(\"\
    Alone\") == 3L);\n    assert(candidate(\"key\") == 2L);\n    assert(candidate(\"\
    bye\") == 1L);\n    assert(candidate(\"keY\") == 2L);\n    assert(candidate(\"\
    bYe\") == 1L);\n    assert(candidate(\"ACEDY\") == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps3qvmrha.d(21): Error: `switch` statement without a `default`;\
    \ use `final switch` or add `default: assert(0);` or add `default: break;`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps3qvmrha.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\nWrite a function vowels_count which takes a string\
    \ representing\n    a word as input and returns the number of vowels in the string.\n\
    \    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  \
    \  vowel, but only when it is at the end of the given word.\n\n    Example:\n\
    \    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n   \
    \ 3\n    \n*/\nlong vowels_count(string s) \n{\n    long v = 0;\n    foreach(char\
    \ c; s)\n    {\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u' || c == 'y')\n            v++;\n    }\n    return v;\n}\nunittest\n{\n\
    \    alias candidate = vowels_count;\n\n    assert(candidate(\"abcde\") == 2L);\n\
    \    assert(candidate(\"Alone\") == 3L);\n    assert(candidate(\"key\") == 2L);\n\
    \    assert(candidate(\"bye\") == 1L);\n    assert(candidate(\"keY\") == 2L);\n\
    \    assert(candidate(\"bYe\") == 1L);\n    assert(candidate(\"ACEDY\") == 3L);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpxpowm7ms.d(30): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e5d]\\n??:? void tmpxpowm7ms.__unittest_L25_C1()\
    \ [0x427af1]\\n??:? void tmpxpowm7ms.__modtest() [0x427be0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb83]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42aa16]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fba9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430058]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fb35]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a9ed]\\n??:? runModuleUnitTests [0x42b959]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4282ac]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428233]\\n??:? _d_run_main [0x42819e]\\n??:? main [0x427bf3]\\\
    n??:? __libc_start_main [0xa346a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\nWrite a function vowels_count which takes a string\
    \ representing\n    a word as input and returns the number of vowels in the string.\n\
    \    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  \
    \  vowel, but only when it is at the end of the given word.\n\n    Example:\n\
    \    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n   \
    \ 3\n    \n*/\nlong vowels_count(string s) \n{\n    long r=0;\n    foreach(immutable\
    \ ch; s)\n    {\n        switch(ch)\n        {\n            case 'a': case 'e':\
    \ case 'i': case 'o': case 'u': r++; break;\n            case 'y': if(s.length==1)\
    \ r++; break;\n        }\n    }\n    return r;\n}\nunittest\n{\n    alias candidate\
    \ = vowels_count;\n\n    assert(candidate(\"abcde\") == 2L);\n    assert(candidate(\"\
    Alone\") == 3L);\n    assert(candidate(\"key\") == 2L);\n    assert(candidate(\"\
    bye\") == 1L);\n    assert(candidate(\"keY\") == 2L);\n    assert(candidate(\"\
    bYe\") == 1L);\n    assert(candidate(\"ACEDY\") == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc3hh6ser.d(20): Error: `switch` statement without a `default`;\
    \ use `final switch` or add `default: assert(0);` or add `default: break;`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc3hh6ser.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\nWrite a function vowels_count which takes a string\
    \ representing\n    a word as input and returns the number of vowels in the string.\n\
    \    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  \
    \  vowel, but only when it is at the end of the given word.\n\n    Example:\n\
    \    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n   \
    \ 3\n    \n*/\nlong vowels_count(string s) \n{\n    long count = 0;\n    long\
    \ len = s.length;\n    for (long i = 0; i < len; i++) {\n        char ch = s[i];\n\
    \        if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u') {\n\
    \            count++;\n        }\n        else if (ch == 'y' && i != len - 1)\
    \ {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n\
    {\n    alias candidate = vowels_count;\n\n    assert(candidate(\"abcde\") == 2L);\n\
    \    assert(candidate(\"Alone\") == 3L);\n    assert(candidate(\"key\") == 2L);\n\
    \    assert(candidate(\"bye\") == 1L);\n    assert(candidate(\"keY\") == 2L);\n\
    \    assert(candidate(\"bYe\") == 1L);\n    assert(candidate(\"ACEDY\") == 3L);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpgp9cqhld.d(35): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e75]\\n??:? void tmpgp9cqhld.__unittest_L30_C1()\
    \ [0x427b05]\\n??:? void tmpgp9cqhld.__modtest() [0x427bf4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc0f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42aaa2]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc35]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x4300e4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fbc1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aa79]\\n??:? runModuleUnitTests [0x42b9e5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428338]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4282bf]\\n??:? _d_run_main [0x42822a]\\n??:? main [0x427c07]\\\
    n??:? __libc_start_main [0x4d60a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\nWrite a function vowels_count which takes a string\
    \ representing\n    a word as input and returns the number of vowels in the string.\n\
    \    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  \
    \  vowel, but only when it is at the end of the given word.\n\n    Example:\n\
    \    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n   \
    \ 3\n    \n*/\nlong vowels_count(string s) \n{\n    long cnt = 0;\n    s = toLower(s);\n\
    \    foreach(i, char c; s)\n    {\n        if(c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u')\n            cnt++;\n    }\n    return cnt;\n}\n/*\n\
    \    Write a function add_vectors which takes two arrays of\n    numbers representing\
    \ arrays of 2D vectors and returns the sum\n    of the vectors.\nunittest\n{\n\
    \    alias candidate = vowels_count;\n\n    assert(candidate(\"abcde\") == 2L);\n\
    \    assert(candidate(\"Alone\") == 3L);\n    assert(candidate(\"key\") == 2L);\n\
    \    assert(candidate(\"bye\") == 1L);\n    assert(candidate(\"keY\") == 2L);\n\
    \    assert(candidate(\"bYe\") == 1L);\n    assert(candidate(\"ACEDY\") == 3L);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpht42l05h.d(26): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpht42l05h.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\nWrite a function vowels_count which takes a string\
    \ representing\n    a word as input and returns the number of vowels in the string.\n\
    \    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  \
    \  vowel, but only when it is at the end of the given word.\n\n    Example:\n\
    \    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n   \
    \ 3\n    \n*/\nlong vowels_count(string s) \n{\n    long len = s.length;\n   \
    \ long vowelsCount = 0;\n    foreach(i; 0 .. len)\n    {\n        if(s[i] == 'a'\
    \ || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u')\n        {\n  \
    \          vowelsCount += 1;\n        }\n        else if(s[i] == 'y' && i != len\
    \ - 1)\n        {\n            vowelsCount += 1;\n        }\n    }\n    return\
    \ vowelsCount;\n}\nunittest\n{\n    alias candidate = vowels_count;\n\n    assert(candidate(\"\
    abcde\") == 2L);\n    assert(candidate(\"Alone\") == 3L);\n    assert(candidate(\"\
    key\") == 2L);\n    assert(candidate(\"bye\") == 1L);\n    assert(candidate(\"\
    keY\") == 2L);\n    assert(candidate(\"bYe\") == 1L);\n    assert(candidate(\"\
    ACEDY\") == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpe67hmv94.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f05]\\n??:? void tmpe67hmv94.__unittest_L32_C1()\
    \ [0x427b99]\\n??:? void tmpe67hmv94.__modtest() [0x427c88]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc9f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab32]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fcc5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430174]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc51]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42ab09]\\n??:? runModuleUnitTests [0x42ba75]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4283c8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42834f]\\n??:? _d_run_main [0x4282ba]\\n??:? main [0x427c9b]\\\
    n??:? __libc_start_main [0x43ff6554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\nWrite a function vowels_count which takes a string\
    \ representing\n    a word as input and returns the number of vowels in the string.\n\
    \    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  \
    \  vowel, but only when it is at the end of the given word.\n\n    Example:\n\
    \    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n   \
    \ 3\n    \n*/\nlong vowels_count(string s) \n{\n    long i;\n    long n = 0;\n\
    \    int p;\n    char c;\n    int m = s.length();\n    //if (m>1)\n    //{\n \
    \       for (i=0; i<m; ++i)\n        {\n            c = s[i];\n            p =\
    \ tolower(c);\n            if (p==97||p==101||p==105||p==111||p==117)\n      \
    \      {\n                n++;\n            }\n        }\n    //}\n    return\
    \ n;\n}\nunittest\n{\n    alias candidate = vowels_count;\n\n    assert(candidate(\"\
    abcde\") == 2L);\n    assert(candidate(\"Alone\") == 3L);\n    assert(candidate(\"\
    key\") == 2L);\n    assert(candidate(\"bye\") == 1L);\n    assert(candidate(\"\
    keY\") == 2L);\n    assert(candidate(\"bYe\") == 1L);\n    assert(candidate(\"\
    ACEDY\") == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxtjl9_u1.d(21): Error: no property `length` for type `string`\\\
    n/tmp/tmpxtjl9_u1.d(27): Error: undefined identifier `tolower`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxtjl9_u1.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\nWrite a function vowels_count which takes a string\
    \ representing\n    a word as input and returns the number of vowels in the string.\n\
    \    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  \
    \  vowel, but only when it is at the end of the given word.\n\n    Example:\n\
    \    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n   \
    \ 3\n    \n*/\nlong vowels_count(string s) \n{\n\tlong count = 0;\n\tforeach(ch;\
    \ s)\n\t{\n\t\tif(toLower(ch) == 'a' || toLower(ch) == 'e' || toLower(ch) == 'i'\
    \ || toLower(ch) == 'o' || toLower(ch) == 'u')\n\t\t{\n\t\t\tcount = count + 1;\n\
    \t\t}\n\t}\n\treturn count;\n}\n/*\nWrite a function vowels_replace which takes\
    \ a string representing\n    a word as input and returns a new string which is\
    \ the same as the\n    given string but with all vowels, in upper case. Vowels\
    \ in this\n    case are 'a', 'e', 'i', 'o', 'u'.\n    Example:\n    >>> vowels_replace(\"\
    abcde\")\n    \"AbcdE\"\n    >>> vowels_replace(\"ABCDE\")\n    \"ABCDE\"\n*/\n\
    string vowels_replace(string s) \n{\n\tstring tmp = \"\";\n\tforeach(ch; s)\n\t\
    {\n\t\tif(toLower(ch) == 'a' || toLower(ch) == 'e' || toLower(ch) == 'i' || toLower(ch)\
    \ == 'o' || toLower(ch) == 'u')\n\t\t{\n\t\t\ttmp ~= toUpper(ch);\n\t\t}\n\t\t\
    else\n\t\t{\n\t\t\ttmp ~= ch;\n\t\t}\n\t}\n\treturn tmp;\n}\nunittest\n{\n   \
    \ alias candidate = vowels_count;\n\n    assert(candidate(\"abcde\") == 2L);\n\
    \    assert(candidate(\"Alone\") == 3L);\n    assert(candidate(\"key\") == 2L);\n\
    \    assert(candidate(\"bye\") == 1L);\n    assert(candidate(\"keY\") == 2L);\n\
    \    assert(candidate(\"bYe\") == 1L);\n    assert(candidate(\"ACEDY\") == 3L);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprm40g53s.d(20): Error: undefined identifier `toLower`\\n/tmp/tmprm40g53s.d(20):\
    \ Error: undefined identifier `toLower`\\n/tmp/tmprm40g53s.d(20): Error: undefined\
    \ identifier `toLower`\\n/tmp/tmprm40g53s.d(20): Error: undefined identifier `toLower`\\\
    n/tmp/tmprm40g53s.d(20): Error: undefined identifier `toLower`\\n/tmp/tmprm40g53s.d(43):\
    \ Error: undefined identifier `toLower`\\n/tmp/tmprm40g53s.d(43): Error: undefined\
    \ identifier `toLower`\\n/tmp/tmprm40g53s.d(43): Error: undefined identifier `toLower`\\\
    n/tmp/tmprm40g53s.d(43): Error: undefined identifier `toLower`\\n/tmp/tmprm40g53s.d(43):\
    \ Error: undefined identifier `toLower`\\n/tmp/tmprm40g53s.d(45): Error: undefined\
    \ identifier `toUpper`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmprm40g53s.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
