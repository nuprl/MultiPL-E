name: HumanEval_41_car_race_collision
language: d
prompt: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight infinitely\
  \ long line.\n    n cars are driving left to right;  simultaneously, a different\
  \ set of n cars\n    are driving right to left.   The two sets of cars start out\
  \ being very far from\n    each other.  All cars move in the same speed.  Two cars\
  \ are said to collide\n    when a car that's moving left to right hits a car that's\
  \ moving right to left.\n    However, the cars are infinitely sturdy and strong;\
  \ as a result, they continue moving\n    in their trajectory as if they did not\
  \ collide.\n\n    This function outputs the number of such collisions.\n    \n*/\n\
  long car_race_collision(long n) \n"
tests: "unittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
  \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
  \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
  \ main(){}"
completions: ["{\n    long left, right, i, j, d, res;\n    left = n;\n    right =\
    \ n;\n    res = 0;\n    i = 0;\n    while(i < left)\n    {\n        j = 0;\n \
    \       while(j < right)\n        {\n            d = car_distance(i, j);\n   \
    \         if(d == 0)\n            {\n                res = res + 1;\n        \
    \    }\n            else if(d < 0)\n            {\n                left = left\
    \ - 1;\n            }\n            else\n            {\n                right\
    \ = right - 1;\n            }\n            j = j + 1;\n        }\n        i =\
    \ i + 1;\n    }\n    return res;\n}\nlong car_distance(long i, long j)\n{\n  \
    \  long car_speed, c0, c1, d;\n    car_speed = 5;\n    c0 = car_speed * i;\n \
    \   c1 = car_speed * j;\n    d = c0 - c1;\n    return d;\n}", "{\n    return n\
    \ * (n - 1) / 2;\n}", "{\n    real[long] left_to_right;\n    real[long] right_to_left;\n\
    \    long count;\n    for (long i = 0; i < n; i++) \n    {\n        left_to_right[i]\
    \ = uniform_random() / real(n);\n        right_to_left[i] = uniform_random() /\
    \ real(n);\n    }\n    merge_sort!(\"a < b\")(left_to_right);\n    merge_sort!(\"\
    a < b\")(right_to_left);\n    long i = 0;\n    long j = 0;\n    while (i < n &&\
    \ j < n) \n    {\n        if (left_to_right[i] < right_to_left[j]) \n        {\n\
    \            count += j;\n            i++;\n        } \n        else \n      \
    \  {\n            j++;\n        }\n    }\n    return count;\n}", "{\n    if (n\
    \ <= 1)\n    {\n        return 0;\n    }\n    // Each car generates a unique key.\n\
    \    long[] keys = new long[n];", "{\n    long a[n]; // a[i] is the position of\
    \ the ith car\n    long pos;\n    long ret = 0;\n    long i;\n    long j;\n  \
    \  iota(a, a + n, 1); // a[i] = i\n    for (i = 0; i < n; i++) {\n        // Pick\
    \ a random number for the position of the car moving left to right\n        pos\
    \ = uniform(0, n + 1);\n        // See how many collisions that car has with the\
    \ cars moving right to left\n        for (j = 0; j < n; j++) {\n            if\
    \ (a[j] > pos)\n                ret++;\n        }\n    }\n    return ret;\n}",
  "{\n    long a[n];\n    long b[n];\n    foreach (i, n)\n    {\n        a[i] = cast(long)random()\
    \ + 10000000;\n        b[i] = cast(long)random() + 10000000;\n    }\n    long\
    \ count = 0;\n    foreach (i, n)\n    {\n        foreach (j, n)\n        {\n \
    \           if (a[i] > b[j])\n            {\n                count++;\n      \
    \      }\n        }\n    }\n    return count;\n}", "{\n    auto line_length =\
    \ to!double(n)*3;\n    auto max_x = to!double(n)*2.9;\n    auto min_x = -max_x;\n\
    \    auto max_speed = to!double(n)*1.4;\n    auto min_speed = -max_speed;\n  \
    \  //initialize random number generator with random seed\n    RandomNumberGenerator\
    \ rng;\n    rng.seed(unpredictableSeed);\n    //initialize the cars\n    struct\
    \ Car { double x; double speed; }\n    //set x values for cars going left to right\n\
    \    for(auto ref c : moving_left) \n    {\n        c.x = rng.get!double(min_x,\
    \ max_x);\n        c.speed = rng.get!double(min_speed, max_speed);\n    }\n  \
    \  //set x values for cars going right to left\n    for(auto ref c : moving_right)\
    \ \n    {\n        c.x = rng.get!double(min_x, max_x);\n        c.speed = rng.get!double(min_speed,\
    \ max_speed);\n    }\n    //keep track of the number of collisions\n    long collision_count\
    \ = 0;\n    //let the cars move until they are all way past each other\n    while(true)\
    \ \n    {\n        bool collision_happened = false;\n        //for each car moving\
    \ left to right\n        for(size_t i = 0; i < moving_left.length; i++) \n   \
    \     {\n            auto ref c = moving_left[i];\n            //for each car\
    \ moving right to left\n            for(size_t j = 0; j < moving_right.length;\
    \ j++) \n            {\n                auto ref d = moving_right[j];\n      \
    \          //check if the cars collided\n                if((c.x - d.x)*(c.x -\
    \ d.x) < 0.01) \n                {\n                    collision_happened = true;\n\
    \                    collision_count++;\n                }\n            }\n  \
    \      }\n        //if no collision happened, break out of the loop\n        if(!collision_happened) ",
  "{\n    if (n < 1) return 0;\n    // count of collision\n    long c = 0;\n    //\
    \ car positions\n    long[] pos = new long[2*n];\n    // car velocities\n    long[]\
    \ vel = new long[2*n];\n    // generate the cars\n    for (long i = 0; i < n;\
    \ i++) \n    {\n        pos[i] = 100 * (i + 1);\n        vel[i] = 1;\n       \
    \ pos[i + n] = -100 * (i + 1);\n        vel[i + n] = -1;\n    }\n    // simulate\n\
    \    for (long t = 0; t < 1000; t++) \n    {\n        // iterate over all possible\
    \ pairs of cars\n        for (long i = 0; i < 2 * n; i++) \n        {\n      \
    \      for (long j = i + 1; j < 2 * n; j++) \n            {\n                //\
    \ check if they are going in opposite directions\n                if (vel[i] !=\
    \ vel[j]) \n                {\n                    // if they are on each other,\
    \  then there's a collision\n                    if (pos[i] == pos[j]) \n    \
    \                {\n                        c++;\n                    }\n    \
    \            }\n            }\n        }\n        // update cars' positions\n\
    \        for (long i = 0; i < 2 * n; i++) \n        {\n            pos[i] += vel[i];\n\
    \        }\n    }\n    return c;\n}", "{ \n  auto carsL = new int[n];\n  auto\
    \ carsR = new int[n];\n  for (int i = 0; i < n; i++)\n    carsL[i] = i + 1;\n\
    \  for (int i = 0; i < n; i++)\n    carsR[i] = n - i;\n  sort(carsL.ptr, carsL.ptr\
    \ + n);\n  sort(carsR.ptr, carsR.ptr + n);\n  int collisions = 0;\n  for (int\
    \ i = 0; i < n; i++)\n    if (carsL[i] == carsR[i])\n      collisions++;\n  return\
    \ collisions;\n}", "{\n    long result;\n    long[] left_cars;\n    long[] right_cars;\n\
    \    long i, j;\n    i = 0;\n    left_cars = new long[n];\n    right_cars = new\
    \ long[n];\n    while (i < n) {\n        left_cars[i] = random();\n        right_cars[i]\
    \ = random();\n        i = i + 1;\n    }\n    result = 0;\n    i = 0;\n    while\
    \ (i < n) {\n        j = 0;\n        while (j < n) {\n            if (left_cars[i]\
    \ < right_cars[j]) {\n                result = result + 1;\n            }\n  \
    \          j = j + 1;\n        }\n        i = i + 1;\n    }\n    return result;\n\
    }", "{\n    if (n <= 1)\n    {\n        return 0;\n    }\n    else\n    {\n  \
    \      long x = 0;\n        long y = n - 1;\n        long diff = x - y;\n    \
    \    return diff * (diff - 1) / 2;\n    }\n}", "{\n    return (n*(n-1))/2;\n}",
  "{\n    return n * (n - 1) / 2;\n}", "{\n    long collision_number = 0;\n    for\
    \ (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n      \
    \  {\n            if (abs(i - j) < n/2)\n            {\n                collision_number++;\n\
    \            }\n        }\n    }\n    return collision_number;\n}", "{\n  long\
    \ num_collisions = 0;\n  long i, j;\n  float left_to_right[n];\n  float right_to_left[n];\n\
    \  float multiplier = 1.0 / (float)n;\n  float min, max;\n  float left_car, right_car;\n\
    \  float two_n = (float)n * 2.0;\n  float one_over_two_n = 1.0 / two_n;\n  float\
    \ n_over_two = (float)n / 2.0;\n  float n_over_two_minus_1 = n_over_two - 1.0;\n\
    \  for (i = 0; i < n; i++) {\n    left_to_right[i] = (i + 0.5) * multiplier;\n\
    \    right_to_left[i] = (1.0 - (i + 0.5) * multiplier);\n  }\n  for (i = 0; i\
    \ < n; i++) {\n    left_car = left_to_right[i];\n    right_car = right_to_left[i];\n\
    \    if (left_car > right_car) {\n      num_collisions++;\n    }\n    min = min(left_car,\
    \ right_car);\n    max = max(left_car, right_car);\n    for (j = 1; j < n_over_two;\
    \ j++) {\n      left_car = min + j * one_over_two_n;\n      right_car = max -\
    \ j * one_over_two_n;\n      if (left_car > right_car) {\n        num_collisions++;\n\
    \      }\n    }\n  }\n  return num_collisions;\n}", "{\n\tlong count=0;\n\tfor(long\
    \ i=0;i<n;i++)\n\t{\n\t\tfor(long j=i+1;j<n;j++)\n\t\t{\n\t\t\tif(i<n/2 && j>=n/2)\n\
    \t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n\t//return\
    \ 0;", "{\n    // Cars that are left to right.  Each element tells us the distance\
    \ between \n    // the car and the starting line\n    auto l2r = new long[n];\n\
    \    // Cars that are right to left.  Each element tells us the distance between\
    \ \n    // the car and the starting line\n    auto r2l = new long[n];\n    //\
    \ Filling up the arrays\n    for (long i = 0; i < n; i++) {\n        l2r[i] =\
    \ i;\n        r2l[i] = n - i;\n    }\n    // Simulating the race\n    long number_of_collisions\
    \ = 0;\n    // Two cars will collide only if their distances from the starting\
    \ line\n    // is equal.  That is, only if l2r[i] = r2l[j].\n    // So, we only\
    \ need to loop through the arrays one time.\n    for (long i = 0; i < n; i++)\
    \ {\n        // If l2r[i] = r2l[j], then |l2r[i] - r2l[j]| = 0.\n        // We\
    \ look for the number of elements in r2l where the difference between\n      \
    \  // the element and l2r[i] is zero.\n        number_of_collisions += count_if(r2l,\
    \ r2l + n, [&](long val) {return abs(val - l2r[i]) == 0;});\n    }\n    return\
    \ number_of_collisions;\n}\n```", "{\n\treturn n*(n-1)/2;\n}", "{\n    long count\
    \ = 0;\n    foreach (long i; 0 .. n) {\n        foreach (long j; 0 .. n) {\n \
    \           count += i == j;\n        }\n    }\n    return count;\n}", "{ \n \
    \   return n * (n - 1) / 2;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
