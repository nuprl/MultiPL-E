name: HumanEval_116_sort_array
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
  \ to sort an array of non-negative integers according to\n    number of ones in\
  \ their binary representation in ascending order.\n    For similar number of ones,\
  \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
  \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4,\
  \ -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2,\
  \ 3, 4]\n    \n*/\nlong[] sort_array(long[] arr) \n"
tests: "unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
  \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L,\
  \ -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L,\
  \ 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
  \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
  \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
  \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
  \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
  \ 16L, 32L]);\n}\nvoid main(){}"
completions: ["{\n    return arr.sort!(a => a, b => {\n        ulong A = (ulong)a;\n\
    \        ulong B = (ulong)b;\n        return cast(int)popcount(A) < cast(int)popcount(B)\
    \ ? -1 :\n            cast(int)popcount(A) > cast(int)popcount(B) ? 1 :\n    \
    \        a < b ? -1 : 1;\n    });\n}", "{\n    mixin(\"import std.algorithm.sorting\
    \ : sort, stableSort;\");\n    return arr.stableSort!((a, b) => (countOnes(a)\
    \ == countOnes(b)) ? a - b : countOnes(a) - countOnes(b));\n}", "{\n    import\
    \ std.algorithm : sort;\n    return arr.sort!(x => (cast(string)x).count(\"1\"\
    ), \n                     y => (cast(string)y).count(\"1\"))\n             .sort!((x,\
    \ y) => x < y);\n}", "{\n    auto arr_dec = arr;\n    auto arr_bin = arr.map!(a\
    \ => binaryRepresentation(a));\n    auto range = zip(arr_dec, arr_bin);\n    range.sort!((lhs,\
    \ rhs) => \n        // this sort is stable\n        rcompare(lhs[1].count('1'),\
    \ rhs[1].count('1')) \n        || \n        rcompare(lhs[0], rhs[0]));\n    return\
    \ range.map!(a => a[0]).array;\n}", "{\n    arr = arr.sort();\n    long[] holder\
    \ = arr.dup;\n    long[][] sorted = new long[2][0];\n    foreach(long i; 0..arr.length)\n\
    \    {\n        sorted[0] ~= i;\n        sorted[1] ~= arr[i];\n    }\n    sorted[0]\
    \ = sorted[0].sort;\n    foreach(long i; 0..arr.length)\n    {\n        long x\
    \ = sorted[0][i];\n        long y = sorted[1][i];\n        holder[x] = y;\n  \
    \  }\n    arr = holder;\n    return arr;\n}", "{\n    return \n        arr.dup.sort!(a,\
    \ b => ((a & -a).countOnes > (b & -b).countOnes) ? 1 : \n                    \
    \         ((a & -a).countOnes < (b & -b).countOnes) ? -1 :\n                 \
    \               a > b ? 1 : -1);\n}", "{\n    arr.sort!((a, b) => a.countOne()\
    \ < b.countOne() || a.countOne() == b.countOne() && a < b)();\n    return arr;\n\
    }", "{\n    long[] sortedArr = arr.dup;\n    // sorting array:\n    sortedArr.sort();\n\
    \    // one's counter array:\n    long[] oneCounters = new long[arr.length];\n\
    \    // iterating array elements:\n    foreach(i, element; sortedArr)\n    {\n\
    \        // number of ones in element's binary representation:\n        oneCounters[i]\
    \ = to!(\"binary\")(element).count(\"1\");\n    }\n    // now sorting array using\
    \ one's counter array:\n    sortedArr.sort(oneCounters);\n    return sortedArr;\n\
    }\n \n*/", "{\n    return arr.sort!((a, b) => \n        std.bitmanip.popCount(a)\
    \ != std.bitmanip.popCount(b) ? \n            std.bitmanip.popCount(a) - std.bitmanip.popCount(b)\
    \ : \n            a.cmp(b));\n}\n```", "{\n    struct binaryOnes\n    {\n    \
    \    long count;\n        long value;\n    }\n    int i;\n    binaryOnes[] b;\n\
    \    for (i = 0; i < arr.length; i++)\n    {\n        b ~= binaryOnes(countOnes(arr[i]),\
    \ arr[i]);\n    }\n    sort!((a, b) => a.count < b.count || (a.count == b.count\
    \ && a.value < b.value))(b);\n    return b.map!(x => x.value).array;\n}", "{\n\
    \    // return my solution\n    return my_solution(arr);\n}", "{\n  auto cmp =\
    \ (a, b) { return a[0] == b[0] ? a[1] < b[1] : a[0] < b[0]; };\n  auto ones =\
    \ a => a.bitCount;\n  auto bits = a => a.toBinaryString;\n  auto pairs = arr.map!(a\
    \ => tuple(ones(a), a)).array;\n  return pairs.sort!cmp.map!((a) => a[1]).array;\n\
    }", "{\n    if (arr.length == 0)\n        return new long[0];\n    auto to_tuple\
    \ = (long num) => tuple(num.countOnes, num);\n    arr.sort!\"a[0] < b[0] || (a[0]\
    \ == b[0] && a[1] < b[1])\"(arr.map!to_tuple.array);\n    return arr.map!(a =>\
    \ a[1]).array;\n}", "{\n    auto cmp = (long a, long b) =>\n    {\n        size_t\
    \ aones = numBitsIn(a);\n        size_t bones = numBitsIn(b);\n        return\
    \  aones == bones ? a.compare(b) : aones.compare(bones);\n    };\n    return arr.sort!cmp;\n\
    }", "{\n    arr.sort!((a, b) => cast(int) Math.countOnes(a) < cast(int) Math.countOnes(b)\
    \ ||\n                          (Math.countOnes(a) == Math.countOnes(b) && a <\
    \ b));\n    return arr;\n}", "{\n    auto m = new int[100];\n    foreach(i; arr)\n\
    \    {\n        long j = i;\n        int k = 0;\n        while(j)\n        {\n\
    \            if(j & 1)\n                k++;\n            j >>= 1;\n        }\n\
    \        m[k]++;\n    }\n    int n = 0;\n    foreach(i; 0 .. 100)\n    {\n   \
    \     if(m[i] == 0)\n            continue;\n        foreach(j; 0 .. m[i])\n  \
    \      {\n            while(arr[n] & (1 << i) == 0)\n                n++;\n  \
    \          arr[n++] = arr[j];\n        }\n    }\n    return arr;\n}", "{\n   \
    \ auto tmp = arr.dup;\n    tmp.sort!((long a, long b) =>\n    {\n        int c\
    \ = countOnes(a);\n        int d = countOnes(b);\n        if (c == d)\n      \
    \      return a - b;\n        return c - d;\n    });\n    return tmp;\n}", "{\n\
    \    long[] a = arr.dup;\n    sort(a, (int a, int b) => \n    {\n        return\
    \ cast(ulong)a.countOneBits.cmp(b.countOneBits) ?: a.cmp(b);\n    });\n    return\
    \ a;\n}", "{\n    enum int_with_ones \n    {\n        int_with_ones(long n)\n\
    \        {\n            int nOnes = n.countOneBits;\n            this.ones = nOnes;\n\
    \            this.int_ = n;\n        }\n        \n        override bool opEquals(Object\
    \ rhs)\n        {\n            return this.int_ == cast(int_with_ones)rhs.int_;\n\
    \        }\n        \n        override int opCmp(Object rhs)\n        {\n    \
    \        auto iwo = cast(int_with_ones)rhs;\n            if (this.ones != iwo.ones)\n\
    \                return this.ones - iwo.ones;\n            return this.int_ -\
    \ iwo.int_;\n        }\n        \n        int ones;\n        long int_;\n    }\n\
    \    \n    auto arr2 = arr.map!(n => int_with_ones(n));\n    return arr2.sort.map!(n\
    \ => n.int_);\n}", "{\n  int[] index = new int[arr.length];\n  for (int i = 0;\
    \ i < arr.length; i++)\n  {\n    index[i] = i;\n  }\n  index.sort!(key = (a, b)\
    \ => ((long.countOnes(arr[a])) - (long.countOnes(arr[b]))) == 0\n            \
    \        ? arr[a] - arr[b]\n                    : (long.countOnes(arr[a])) - (long.countOnes(arr[b])));\n\
    \  \n  long[] arr_copy = arr.dup;\n  for (int i = 0; i < arr.length; i++)\n  {\n\
    \    arr[i] = arr_copy[index[i]];\n  }\n  return arr;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
