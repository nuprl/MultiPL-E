name: HumanEval_58_common
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common elements\
  \ for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
  \ 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n \
  \   \n*/\nlong[] common(long[] l1, long[] l2) \n"
tests: "unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
  \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
  \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
  \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L,\
  \ 8L], []) == []);\n}\nvoid main(){}"
completions: ["{\n\tauto l1 = list(3, 2, 5, 9, 1, 34, 5, 653, 1, 5);\n\tauto l2 =\
    \ list(4, 7, 12, 3, 5, 9, 1, 5, 653, 121);\n\tsort(l1);\n\tsort(l2);\n\tint lengthl1\
    \ = l1.length;\n\tint lengthl2 = l2.length;\n\tint i = 0;\n\tint j = 0;\n\twhile\
    \ (i < lengthl1 && j < lengthl2) \n\t{\n\t\tif (l1[i] < l2[j])\n\t\t{\n\t\t\t\
    i++;\n\t\t}\n\t\telse if (l1[i] > l2[j])\n\t\t{\n\t\t\tj++;\n\t\t}\n\t\telse\n\
    \t\t{\n\t\t\twriteln(l1[i]);\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t}\n}", "{\n   \
    \ long[] l3 = set(l1);\n    long[] l4 = set(l2);\n    long[] l5 = set(l3);\n \
    \   long[] l6 = set(l4);\n    long[] l7 = set(l5);\n    long[] l8 = set(l6);\n\
    \    long[] l9 = set(l7);\n    long[] l10 = set(l8);\n    long[] l11 = set(l9);\n\
    \    long[] l12 = set(l10);\n    long[] l13 = set(l11);\n    long[] l14 = set(l12);\n\
    \    long[] l15 = set(l13);\n    long[] l16 = set(l14);\n    long[] l17 = set(l15);\n\
    \    long[] l18 = set(l16);\n    long[] l19 = set(l17);\n    long[] l20 = set(l18);\n\
    \    long[] l21 = set(l19);\n    long[] l22 = set(l20);\n    long[] l23 = set(l21);\n\
    \    long[] l24 = set(l22);\n    long[] l25 = set(l23);\n    long[] l26 = set(l24);\n\
    \    long[] l27 = set(l25);\n    long[] l28 = set(l26);\n    long[] l29 = set(l27);\n\
    \    long[] l30 = set(l28);\n    long[] l31 = set(l29);\n    long[] l32 = set(l30);\n\
    \    long[] l33 = set(l31);\n    long[] l34 = set(l32);\n    long[] l35 = set(l33);\n\
    \    long[] l36 = set(l34);\n    long[] l37 = set(l35);\n    long[] l38 = set(l36);\n\
    \    long[] l39 = set(l37);\n    long[] l40 = set(l38);\n    long[] l41 = set(l39);\n\
    \    long[] l42 = set(l40);\n    long[] l43 = set(l41);\n    long[] l44 = set(l42);\n\
    \    long[] l45", "{\n    if (l1.length < l2.length)\n    {\n        long[] swap\
    \ = l1;\n        l1 = l2;\n        l2 = swap;\n    }\n    auto set1 = l1.sort.uniq;\n\
    \    auto set2 = l2.sort.uniq;\n    long[] common = new long[];\n    foreach (item;\
    \ set1)\n    {\n        if (item in set2)\n        {\n            common ~= item;\n\
    \        }\n    }\n    return common;\n}", "{\n\t// determine which is larger,\
    \ l1 or l2\n\t// sort the larger array\n\t// sort the smaller array\n\t// start\
    \ indexing the smaller array by 0\n\t// if the current index matches the first\
    \ value of the larger array, then all the others will be in order\n\t// if the\
    \ current index does not match the first value of the larger array, then all the\
    \ other index values should be less than the first value of the larger array\n\
    \t//\n\t\t\n\t\n\t\n\t\n\t// determine which is larger, l1 or l2\n\tlong[] smaller\
    \ = l1;\n\tlong[] larger = l2;\n\t\n\tif (l1.length < l2.length)\n\t{\n\t\tsmaller\
    \ = l1;\n\t\tlarger = l2;\n\t}\n\t\n\t// sort the larger array\n\t//sort(larger);\n\
    \t\n\t// sort the smaller array\n\t//sort(smaller);\n\t\n\t\n\t// start indexing\
    \ the smaller array by 0\n\t\n\tint smaller_index = 0;\n\t\n\t\n\t//if the current\
    \ index matches the first value of the larger array, then all the others will\
    \ be in order\n\tif (smaller[smaller_index] == larger[0])\n\t{\n\t\t// all values\
    \ of smaller array will match in order to the larger array\n\t\tsmaller_index++;\n\
    \t}\n\t\n\t// if the current index does not match the first value of the larger\
    \ array, then all the other index values should be less than the first value of\
    \ the larger array\n\t\n\t\n\t\n\treturn larger;\n}", "{\n    long[] ret = [];\n\
    \    foreach(element; sort(set(l1)))\n    {\n        if(element in set(l2))\n\
    \        {\n            ret ~= element;\n        }\n    }\n    return ret;\n}",
  "{\n    long[] result = [];\n    long[] tmp = [];\n    foreach(long i; l1)\n   \
    \ {\n        if (l2.length > 1)\n        {\n            tmp = common(l2[1..$],\
    \ l1);\n            if (tmp.length > 0)\n            {\n                result\
    \ ~= tmp;\n            }\n        }\n        if (l2[0] == l1[0])\n        {\n\
    \            result ~= l1[0];\n        }\n    }\n    return result;\n}", "{\n\
    \    /*\n    The following algorithm uses a binary search to find the common elements\
    \ in two sorted lists.\n    Time complexity is O(mlogn) where m is the number\
    \ of elements in the smaller list.\n    Space complexity is O(1).\n    */\n  \
    \  long[] result = new long[0];", "{ \n    long[] result = [];\n    HashSet!long\
    \ set = new HashSet!long(); \n    foreach(e1; l1) \n    { \n        foreach(e2;\
    \ l2) \n        { \n            if(e1 == e2) \n            { \n              \
    \  if(!set.contains(e1)) \n                { \n                    set.insert(e1);\
    \ \n                    result ~= e1; \n                } \n            } \n \
    \       } \n    } \n    return result; \n}\n \n/*\nReturn sorted unique elements\
    \ for two lists.\n    >>> union([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
    \ 121])\n    [1, 2, 3, 4, 5, 7, 9, 34, 121, 653]\n    >>> union([5, 3, 2, 8],\
    \ [3, 2])\n    [2, 3, 5, 8]\n*/\nlong[] union(long[] l1, long[] l2) \n{ \n   \
    \ long[] result = [];\n    HashSet!long set = new HashSet!long(); \n    foreach(e1;\
    \ l1) \n    { \n        if(!set.contains(e1)) \n        { \n            set.insert(e1);\
    \ \n            result ~= e1; \n        } \n    } \n    foreach(e2; l2) \n   \
    \ { \n        if(!set.contains(e2)) \n        { \n            set.insert(e2);\
    \ \n            result ~= e2; \n        } \n    } \n    return result; \n}\n \n\
    /*\nReturn sorted unique elements for all lists.\n    >>> unionAll([[1, 4, 3,\
    \ 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]])\n    [1, 2, 3, 4, 5, 7, 9, 34, 121,\
    \ 653]\n    >>> unionAll([[5, 3, 2, 8], [3, 2]])\n    [2, 3,", "{\n    long max1\
    \ = std.max(l1);\n    long max2 = std.max(l2);\n    auto max = std.max(max1, max2);\n\
    \    int[] arr = new int[max + 1];\n    foreach (i; l1) \n    {\n        arr[i]\
    \ += 1;\n    }\n    foreach (i; l2) \n    {\n        arr[i] += 1;\n    }\n   \
    \ return arr.byKey.keys.filter!(a => a != 0);\n}", "{ \n\tlong[long] l;\n\t\n\t\
    foreach(idx, i; l1) {\n\t\tforeach(idx, j; l2) {\n\t\t\tif(i == j) {\n\t\t\t\t\
    l[i] = i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn cast(long[]) l.values;\n}", "{\n\
    \    l1.sort();\n    l2.sort();\n    long[] t1 = l1.dup;\n    t1.uniq;\n    long[]\
    \ t2 = l2.dup;\n    t2.uniq;\n    return t1.intersect(t2);\n}\nstatic assert(common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]);\nstatic assert(common([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]);", "{\n    assert(l1);\n    assert(l2);\n    //\
    \ sort(l1);\n    // sort(l2);\n    long[] ret;\n    long[] t = array(long);\n\
    \    // trace(l1);\n    // trace(l2);\n    foreach(x,y; zip(l1,l2))\n    {\n \
    \       if(x == y)\n        {\n            t ~= x;\n        }\n    }\n    // trace(t);\n\
    \    ret = sort(t)[];\n    // trace(ret);\n    return ret;\n}", "{\n    long[]\
    \ ll1;\n    long[] ll2;\n    // common items are added to uniques and then returned\
    \ sorted\n    long[] uniques;\n    long[] l;\n    auto n;\n    int i;\n    int\
    \ j;\n    int k;\n    //std.sort.sort(l1);\n    //std.sort.sort(l2);\n    // get\
    \ size of the lists\n    n = l1.length;\n    m = l2.length;\n    // determine\
    \ if l1 or l2 is smaller list\n    if (n<m)\n    {\n        ll1 = l1;\n      \
    \  ll2 = l2;\n    }\n    else\n    {\n        ll1 = l2;\n        ll2 = l1;\n \
    \   }\n    // allocate enough space in uniques\n    uniques = new long[ll1.length];\n\
    \    // start looping through small list\n    for (i=0; i<ll1.length; i++)\n \
    \   {\n        // check list 2 to see if it contains the number\n        if (ll2.find(ll1[i])!=-1)\n\
    \        {\n            // if it does, check the array of unique numbers\n   \
    \         // to make sure it has not already been added\n            if (uniques.find(ll1[i])==-1)\n\
    \            {\n                // if it is not in uniques, add it\n         \
    \       uniques.length++;\n                uniques[uniques.length-1] = ll1[i];\n\
    \            }\n        }\n    }\n    return uniques;\n}", "{\n    auto s1 = l1.sort();\n\
    \    auto s2 = l2.sort();\n    long[][] t = [ s1, s2 ];\n    t = t.sort!((a, b)\
    \ => a.length < b.length);\n    long[] common = [ ];\n    long[] f = t[0];\n \
    \   long[] s = t[1];\n    long len = f.length;\n    auto iter = s.opSlice().byChunk(len).sort().opSlice();\n\
    \    foreach(i; 0..5)\n    {\n        if(i > 3) return common;\n        auto newS\
    \ = iter.popFront();\n        if(f == newS) return f;\n        if(! newS.length)\
    \ continue;\n        auto fiter = f.opSlice().byChunk(newS.length).sort().opSlice();\n\
    \        foreach(j; 0..5)\n        {\n            if(j > 3) return common;\n \
    \           auto newF = fiter.popFront();\n            if(newF == newS) \n   \
    \         {\n                common ~= newF;\n                break;\n       \
    \     }\n        }\n    }\n    return common;\n}", "{\n    //return l1.filter!(e\
    \ => l2.count(e)).sort().uniq();\n    long[] ret = new long[](0);\n    long[]\
    \ l,s;\n    if(l1.length < l2.length) {\n        l = l2;\n        s = l1;\n  \
    \  }\n    else {\n        l = l1;\n        s = l2;\n    }\n    foreach(i; l) {\n\
    \        if(s.count(i) > 0) {\n            ret ~= i;\n        }\n    }\n    ret\
    \ = ret.sort().uniq();\n    return ret;\n}", "{\n    auto n = l1.length;\n   \
    \ auto l1s = l1[0..n];\n    auto l2s = l2[0..n];\n    auto l1sUnique = l1s.sort().unique;\n\
    \    auto l2sUnique = l2s.sort().unique;\n    auto l = [] {};\n    auto i = 0;\n\
    \    foreach(e; l1sUnique)\n    {\n        if(l2sUnique.canFind(e))\n        {\n\
    \            l ~= e;\n        }\n    }\n    return l;\n}\n/*\nReturn sorted unique\
    \ common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5,\
    \ 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n\
    \    [2, 3]", "{\n    return l1.sort()\n    .zip(l2.sort())\n    .filter!(a =>\
    \ a[0] == a[1])\n    .map!(a => a[0])\n    .front;\n}", "{\n    assert(l1.length\
    \ > 0 && l2.length > 0);\n    // TODO: Sort l1 and l2\n    auto s1 = l1.sort();\n\
    \    auto s2 = l2.sort();\n    long[] res = new long[];", "{ \n    long[] a1 =\
    \ nts(l1); \n    long[] a2 = nts(l2); \n    return setintersection(a1, a2); \n\
    } \nlong[] nts(long[] arr) \n{ \n    return arr.dup.sort(); \n} \nlong[] setintersection(long[]\
    \ l1, long[] l2) \n{ \n    long[] l3 = new long[1]; \n    foreach (i; l1) \n \
    \   { \n        if (l2.contains(i)) \n        { \n            l3 ~= i; \n    \
    \    } \n    } \n    return l3; \n} \nlong[] setunion(long[] l1, long[] l2) \n\
    { \n    long[] l3 = l1.dup; \n    foreach (i; l2) \n    { \n        if (!l3.contains(i))\
    \ \n        { \n            l3 ~= i; \n        } \n    } \n    return l3; \n}\
    \ \nlong[] setdifference(long[] l1, long[] l2) \n{ \n    long[] l3 = new long[1];\
    \ \n    foreach (i; l1) \n    { \n        if (!l2.contains(i)) \n        { \n\
    \            l3 ~= i; \n        } \n    } \n    return l3; \n} ", "{\n    // In\
    \ the first step we create a dictionary, where the keys are unique \n    // elements\
    \ of the second list, and values are equal to the keys.\n    long[] l2_unique\
    \ = l2.sort.uniq;\n    auto d1 = new long[long][long](l2_unique.length);\n   \
    \ for (int i = 0; i < l2_unique.length; i++)\n    {\n        d1[l2_unique[i]]\
    \ = l2_unique[i];\n    }\n    // Now we iterate through the first list, and check\
    \ if\n    // the element is in the first dictionary.\n    // If it is, we move\
    \ it to the second dictionary.\n    // In the result we have sorted unique elements\n\
    \    // that are in both lists.\n    auto d2 = new long[long][long](l1.length);\n\
    \    foreach (a; l1)\n    {\n        if (a in d1)\n        {\n            d2[a]\
    \ = a;\n        }\n    }\n    // Sorting and uniquing at the last step\n    return\
    \ d2.values.sort.uniq;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
