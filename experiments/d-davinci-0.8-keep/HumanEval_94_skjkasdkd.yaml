name: HumanEval_94_skjkasdkd
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\nYou are given a list of integers.\n\
  \    You need to find the largest prime value and return the sum of its digits.\n\
  \n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]\
  \ the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]\
  \ the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]\
  \ the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the\
  \ output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n \
  \   For lst = [0,8,1,2,1,7] the output should be 7\n    \n*/\nlong skjkasdkd(long[]\
  \ lst) \n"
tests: "unittest\n{\n    alias candidate = skjkasdkd;\n\n    assert(candidate([0L,\
  \ 3L, 2L, 1L, 3L, 5L, 7L, 4L, 5L, 5L, 5L, 2L, 181L, 32L, 4L, 32L, 3L, 2L, 32L, 324L,\
  \ 4L, 3L]) == 10L);\n    assert(candidate([1L, 0L, 1L, 8L, 2L, 4597L, 2L, 1L, 3L,\
  \ 40L, 1L, 2L, 1L, 2L, 4L, 2L, 5L, 1L]) == 25L);\n    assert(candidate([1L, 3L,\
  \ 1L, 32L, 5107L, 34L, 83278L, 109L, 163L, 23L, 2323L, 32L, 30L, 1L, 9L, 3L]) ==\
  \ 13L);\n    assert(candidate([0L, 724L, 32L, 71L, 99L, 32L, 6L, 0L, 5L, 91L, 83L,\
  \ 0L, 5L, 6L]) == 11L);\n    assert(candidate([0L, 81L, 12L, 3L, 1L, 21L]) == 3L);\n\
  \    assert(candidate([0L, 8L, 1L, 2L, 1L, 7L]) == 7L);\n    assert(candidate([8191L])\
  \ == 19L);\n    assert(candidate([8191L, 123456L, 127L, 7L]) == 19L);\n    assert(candidate([127L,\
  \ 97L, 8192L]) == 10L);\n}\nvoid main(){}"
completions: ["{\n  long biggestPrime = 0;\n  foreach(l; lst)\n  {\n    if(isPrime(l))\n\
    \    {\n      biggestPrime = l;\n    }\n  }\n  long sumOfDigits = 0;\n  while(biggestPrime\
    \ != 0)\n  {\n    sumOfDigits += biggestPrime % 10;\n    biggestPrime /= 10;\n\
    \  }\n  return sumOfDigits;\n}", "{\n  long nMax = max(lst);\n  for (long i =\
    \ nMax; i > 1; i--)\n  {\n    if (isPrime(i))\n    {\n      return sumDigits(i);\n\
    \    }\n  }\n  return 0;\n}\nlong sumDigits(long n)\n{\n  long nSum = 0;\n  while\
    \ (n != 0)\n  {\n    nSum += n % 10;\n    n /= 10;\n  }\n  return nSum;\n}", "{\n\
    \    auto primes = sort!((a, b) => a > b)(lst.filter!(a => a.isPrime()));\n  \
    \  auto largestPrime = primes[0];\n    return largestPrime.sumDigits();\n}", "{\n\
    \    long maxPrime = lst.max!(a => a.isPrime);\n    return maxPrime.toString().map!(a\
    \ => a.toLong() - '0'.toLong()).sum;\n}", "{\n\tlong b=0;\n\tforeach(e;lst)\n\t\
    {\n\t\tif(e>b)\n\t\t{\n\t\t\tb=e;\n\t\t}\n\t}\n\tlong p=0;\n\tforeach(i;2..b)\n\
    \t{\n\t\tbool p2=true;\n\t\tforeach(j;i+1..b)\n\t\t{\n\t\t\tif(i%j==0)\n\t\t\t\
    {\n\t\t\t\tp2=false;\n\t\t\t}\n\t\t}\n\t\tif(p2)\n\t\t{\n\t\t\tp=i;\n\t\t}\n\t\
    }\n\tlong p3=0;\n\tif(p<10)\n\t{\n\t\tp3=p;\n\t}\n\telse\n\t{\n\t\tforeach(a;0..p)\n\
    \t\t{\n\t\t\tif(p%(10^a)==p)\n\t\t\t{\n\t\t\t\tp3=a;\n\t\t\t}\n\t\t}\n\t\tlong\
    \ r=0;\n\t\tforeach(z;0..p3)\n\t\t{\n\t\t\tr+=p%(10^(z+1))/(10^z);\n\t\t}\n\t\t\
    return r;\n\t}\n\treturn p3;\n}", "{\n    int max = 0;\n    int sum = 0;\n   \
    \ for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i] > max)\n     \
    \   {\n            if(primes.isPrime(lst[i]))\n            {\n               \
    \ max = lst[i];\n            }\n        }\n    }\n    writeln(max);\n    int[]\
    \ num = cast(int[])max.toString().toCharArray();\n    //writeln(num);\n    for(int\
    \ i = 0; i < num.length; i++)\n    {\n        //writeln(cast(char)num[i]);\n \
    \       sum += num[i] - cast(char)'0';\n    }\n    return sum;\n}", "{\n    long\
    \ max = 0;\n    for(long i = 0; i < lst.length; i++)\n    {\n        long p =\
    \ lst[i];\n        if(p > max)\n        {\n            max = p;\n        }\n \
    \   }\n    long v = 0;\n    long m = max;\n    while(m > 0)\n    {\n        v\
    \ += m % 10;\n        m /= 10;\n    }\n    return v;\n}", "{\n    long biggest\
    \ = 0;\n    int counter = 0;\n    for(int a = 0; a < lst.length; a++)\n    {\n\
    \        for(int b = 2; b < lst[a]; b++)\n        {\n            if(lst[a] % b\
    \ == 0)\n            {\n                counter++;\n            }\n        }\n\
    \        if(counter == 0)\n        {\n            if(lst[a] > biggest)\n     \
    \       {\n                biggest = lst[a];\n            }\n        }\n     \
    \   counter = 0;\n    }\n    biggest = std.math.findDigitSum(biggest);\n    return\
    \ biggest;\n}", "{\n    long largest = 0, sum = 0;\n    foreach(i; lst) {\n  \
    \      if(i%2 == 0 || i == 1) continue;\n        else if(isPrime(i)) largest =\
    \ max(largest, i);\n    }\n    while(largest != 0) {\n        sum += largest%10;\n\
    \        largest /= 10;\n    }\n    return sum;\n}", "{\n    long max = 0;\n \
    \   lst.filter!((a) => a > 1).sort!((a, b) => a > b).each!((a) =>\n    {\n   \
    \     if (a.isPrime)\n        {\n            max = a;\n            return false;\n\
    \        }\n        return true;\n    });\n    if (max == 0)\n        return 0;\n\
    \    return max.sumDigits;\n}\nlong sumDigits(this long x)\n{\n    long sum =\
    \ 0;\n    int current = 0;\n    for (; x > 0; x /= 10)\n    {\n        current\
    \ = (int)(x % 10);\n        sum += current;\n    }\n    return sum;\n}", "{\n\
    \    lst.retain(i => i > 0);\n    lst.sort((a, b) => b - a);\n    auto primeList\
    \ = lst.filter!(a => a.isPrime).retain;\n    if (primeList.empty)\n        return\
    \ 0;\n    return primeList[0].toString.sum;\n}", "{\n    long[] num = lst.retro();\n\
    \    long result = 0;\n    for (auto n : num)\n    {\n        if (n > result)\n\
    \        {\n            bool isPrime = true;\n            for (long i = 2; i <\
    \ n; i++)\n            {\n                if (n % i == 0)\n                {\n\
    \                    isPrime = false;\n                    break;\n          \
    \      }\n            }\n            if (isPrime)\n            {\n           \
    \     result = n;\n            }\n        }\n    }\n    string strResult = to!string(result);\n\
    \    long sum = 0;\n    foreach (c; strResult)\n    {\n        sum += c.to!long;\n\
    \    }\n    return sum;\n}", "{\n    long[] primes = new long[100];\n    long[]\
    \ arr = new long[100];\n    primes[0] = 2;\n    long count = 1;\n    long max\
    \ = 0;\n    foreach(i ; lst)\n    {\n        bool flag = true;\n        foreach(j\
    \ ; 0 .. count)\n        {\n            if(i % primes[j] == 0)\n            {\n\
    \                flag = false;\n                break;\n            }\n      \
    \  }\n        if(flag)\n        {\n            arr = arr ~ i;\n            max\
    \ = i;\n            primes = primes ~ i;\n            count++;\n        }\n  \
    \  }\n    //writeln(arr);\n    //writeln(max);\n    return max;\n}\nlong factorial(long\
    \ x)\n{\n    long fac = 1;\n    for(long i = 2; i <= x; i++)\n    {\n        fac\
    \ *= i;\n    }\n    return fac;\n}\nlong[][] combination(long n, long r)\n{\n\
    \    long[][] abc = new long[][](factorial(n) / (factorial(r) * factorial(n -\
    \ r)));\n    long index = 0;\n    for(long i = 0; i < n; i++)\n    {\n       \
    \ for(long j = i + 1; j < n; j++)\n        {\n            for(long k = j + 1;\
    \ k < n; k++)\n            {\n                abc[index] = [i, j, k];\n      \
    \          index++;\n            }\n        }\n    }\n    return abc;\n}", "{\n\
    \   long largestPrime = 0;\n   long digitSum = 0;\n   foreach( num; lst )\n  \
    \ {\n       if( largestPrime <= num )\n       {\n           if( isPrime(num) )\n\
    \           {\n               largestPrime = num;\n           }\n       }\n  \
    \ }\n   foreach( d; to!string(largestPrime) )\n   {\n       if( d != '0' )\n \
    \      {\n           digitSum += d - '0';\n       }\n   }\n   return digitSum;\n\
    }\n/*\nYou are given a list of integers.\n    You need to find the largest prime\
    \ value and return the sum of its digits.", "{\n    long largest = 0;\n    foreach(x;\
    \ lst)\n    {\n        if(isPrime(x))\n        {\n            if(x > largest)\n\
    \            {\n                largest = x;\n            }\n        }\n    }\n\
    \    if(largest == 0) return 0;\n    else return sum(largest.to!string);\n}",
  "{\n    // main code\n    bool q=true;\n    long n=0;\n    foreach(i;lst)\n    {\n\
    \        if(q)\n        {\n            n=i;\n            q=false;\n        }\n\
    \        if(n<i)\n        {\n            n=i;\n        }\n    }\n    // writeln(n);\n\
    \    long[] g=primes(n);\n    long[] d=digits(g[$-1]);\n    // writeln(d);\n \
    \   long s=0;\n    foreach(i;d)\n    {\n        s+=i;\n    }\n    return s;\n}",
  "{ \n    long primes[100];\n    long[] digits[100];\n    long number;\n    long\
    \ a,b,prime_count,digit_count,count;\n    long digit_sum,max_digit_sum;\n    int\
    \ n,i,j;\n    n = lst.length;\n    max_digit_sum = 0;\n    for(i=0;i<n;i++) {\n\
    \        number = lst[i];\n        prime_count = 0;\n        while(number>1) {\n\
    \            a = (long)sqrt(number);\n            if(a*a==number) {\n        \
    \        primes[prime_count] = a;\n                break;\n            }\n   \
    \         b = number;\n            for(j=2;j<=a;j++) {\n                if(b%j==0)\
    \ {\n                    primes[prime_count] = j;\n                    b = b/j;\n\
    \                    break;\n                }\n            }\n            if(b==number)\
    \ {\n                primes[prime_count] = number;\n                break;\n \
    \           }\n            number = b;\n            prime_count++;\n        }\n\
    \        digit_count = 0;\n        for(j=0;j<prime_count;j++) {\n            number\
    \ = primes[j];\n            while(number>0) {\n                digits[digit_count]\
    \ = number%10;\n                number = number/10;\n                digit_count++;\n\
    \            }\n        }\n        digit_sum = 0;\n        for(j=0;j<digit_count;j++)\
    \ {\n            digit_sum = digit_sum + digits[j];\n        }\n        if(digit_sum>max_digit_sum)\
    \ {\n            max_digit_sum = digit_sum;\n        }\n    }\n    return max_digit_sum;\n\
    }", "{\n    long max = 0;\n    foreach(i; lst)\n    {\n        if(i > max)\n \
    \           max = i;\n    }\n    long n = 2;\n    bool[] prime = new bool[max];\n\
    \    foreach(i; 0..max)\n    {\n        prime[i] = true;\n    }\n    while(n *\
    \ n <= max)\n    {\n        if(prime[n])\n        {\n            for(long i =\
    \ n * n; i < max; i += n)\n            {\n                prime[i] = false;\n\
    \            }\n        }\n        n++;\n    }\n    long primes = 0;\n    foreach(i;\
    \ lst)\n    {\n        if(prime[i])\n        {\n            primes = i;\n    \
    \    }\n    }\n    long digit = 0;\n    while(primes != 0)\n    {\n        digit\
    \ += primes % 10;\n        primes /= 10;\n    }\n    return digit;\n}", "{\n \
    \   int[] primes = new int[lst.length / 2];\n    int count = 0;\n    foreach(i;\
    \ lst)\n    {\n        if(isPrime(i))\n        {\n            primes[count] =\
    \ i;\n            count++;\n        }\n    }\n    int max = 0;\n    foreach(i;\
    \ primes)\n    {\n        if(i > max)\n            max = i;\n    }\n    string\
    \ maxStr = max.to!string;\n    int sum = 0;\n    foreach(c; maxStr)\n    {\n \
    \       sum += c.to!int;\n    }\n    return sum;\n}", "{\n    long out = 0;\n\
    \    bool isPrime(long n)\n    {\n        bool out = true;\n        for (int i\
    \ = 2; i < n; i++)\n        {\n            if (n % i == 0)\n            {\n  \
    \              out = false;\n                break;\n            }\n        }\n\
    \        return out;\n    }\n    for (int i = 0; i < lst.length; i++)\n    {\n\
    \        if (isPrime(lst[i]))\n        {\n            string str = lst[i].to!string;\n\
    \            int sum = 0;\n            foreach (char c; str)\n            {\n\
    \                sum += c.to!int;\n            }\n            if (sum > out)\n\
    \            {\n                out = sum;\n            }\n        }\n    }\n\
    \    return out;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
