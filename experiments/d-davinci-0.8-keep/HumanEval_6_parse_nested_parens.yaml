name: HumanEval_6_parse_nested_parens
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n Input to this function is a\
  \ string represented multiple groups for nested parentheses separated by spaces.\n\
  \    For each of the group, output the deepest level of nesting of parentheses.\n\
  \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n \
  \   >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n \
  \   \n*/\nlong[] parse_nested_parens(string paren_string) \n"
tests: "unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
  (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"()\
  \ (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
  ) == [4L]);\n}\nvoid main(){}"
completions: ["{\n    struct ParenInfo\n    {\n        size_t parenLevel;\n      \
    \  bool isOpen;\n        long parenIdx;\n    }\n    auto parenStack = ds.Stack!ParenInfo();",
  "{\n    // TODO: parse input string and for each nested parenthesis group, output\
    \ its maximum nesting level\n    import std.algorithm;\n    import std.string;\n\
    \    return paren_string.split(\" \").filter!(s => s.length > 0).map!(s =>\n \
    \   {\n        //stack depth from left to right\n        int depth = 0;\n    \
    \    int maxDepth = 0;\n        s.walkLength((d, r) =>\n        {\n          \
    \  if (r == '(')\n                ++depth;\n            else if (r == ')')\n \
    \               --depth;\n            maxDepth = max(maxDepth, depth);\n     \
    \   });\n        return maxDepth;\n    }).array;\n}", "{\n    ulong max_nesting_level\
    \ = 0;\n    long[] opn_stack = [];", "{\n    return paren_string.split(\" \").map!(a\
    \ => {\n        long[] val_stack;\n        long max_idx;\n        foreach(ch;\
    \ a)\n        {\n            if(ch == '(') \n            {\n                val_stack\
    \ ~= 1;\n                max_idx = max(max_idx, val_stack.length);\n         \
    \   }\n            else if(ch == ')') \n            {\n                val_stack.pop;\n\
    \            }\n        }\n        return max_idx;\n    }).array;\n}", "{\n  \
    \  long[] res;\n    immutable long len = paren_string.length;\n    int count =\
    \ 0;\n    int max = 0;\n    long start = 0;\n    foreach(immutable long i; 0..len)\n\
    \    {\n        if(paren_string[i] == '(')\n        {\n            count += 1;\n\
    \            if(count > max)\n            {\n                max = count;\n  \
    \          }\n        }\n        else if(paren_string[i] == ')')\n        {\n\
    \            count -= 1;\n        }\n        else if(paren_string[i] == ' ')\n\
    \        {\n            if(max != 0)\n            {\n                res ~= max;\n\
    \                max = 0;\n            }\n            count = 0;\n        }\n\
    \    }\n    return res;\n}", "{\n    // deep_nest is the maximum depth of nested\
    \ parentheses in a single group.\n    auto max_deep_nest = (long n, long m) {\
    \ return max(n, m); };\n    auto paren_groups = paren_string.split;\n    long[]\
    \ ret_arr;\n    foreach (paren_group; paren_groups) \n    {\n        ret_arr ~=\
    \ paren_group.reduce!max_deep_nest(0, (long deep_nest, char c) {\n           \
    \ return c == '(' ? deep_nest + 1 : deep_nest - 1;\n        });\n    }\n    return\
    \ ret_arr;\n}\n ", "{\n    // FIXME\n    return null;\n}", "{\n    auto result\
    \ = new long[](paren_string.count);\n    for (uint i = 0; i < paren_string.count;\
    \ i++)\n    {\n        int cur_depth = 0;\n        int max_depth = 0;\n      \
    \  for (uint j = 0; j < paren_string[i].count; j++)\n        {\n            if\
    \ (paren_string[i][j] == '(')\n            {\n                cur_depth++;\n \
    \               max_depth = max(max_depth, cur_depth);\n            }\n      \
    \      else if (paren_string[i][j] == ')')\n            {\n                cur_depth--;\n\
    \            }\n        }\n        result[i] = max_depth;\n    }\n    return result;\n\
    }\n/*\nInput is a sequence of parenthesis group.", "{ \n    long[] paren_levels\
    \ = new long[paren_string.length];\n    long paren_index = 0;", "{ \n    long[]\
    \ max_depth = new long[];\n    long current_depth = 0;\n    long max_depth_in_group\
    \ = 0;\n    foreach(immutable c; paren_string)\n    {\n        if(c == '(')\n\
    \        {\n            current_depth += 1;\n            max_depth_in_group =\
    \ max(max_depth_in_group, current_depth);\n        }\n        else if(c == ')')\n\
    \        {\n            current_depth -= 1;\n        }\n        else if(c == '\
    \ ')\n        {\n            if(current_depth != 0)\n            {\n         \
    \       assert(false, \"Invalid paren string.\");\n            }\n           \
    \ max_depth ~= max_depth_in_group;\n            max_depth_in_group = 0;\n    \
    \    }\n    }\n    max_depth ~= max_depth_in_group;\n    return max_depth;\n}",
  "{\n    paren_string = paren_string.rstrip();\n    long[] num_levels = paren_string.split().map!((string\
    \ s) {return count_nested_parens(s);}).array;\n    return num_levels;\n}", "{\n\
    \treturn paren_string.split().map!(a => a.countUntil(')') - a.countUntil('(')).array;\n\
    }", "{\n    ulong counter = 0;\n    long[] result = new long[];\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            counter++;\n\
    \        }\n        else if(c == ')')\n        {\n            counter--;\n   \
    \     }\n        else if(c == ' ')\n        {\n            if(counter != 0)\n\
    \            {\n                result ~= counter;\n            }\n          \
    \  counter = 0;\n        }\n    }\n    if(counter != 0)\n    {\n        result\
    \ ~= counter;\n    }\n    return result;\n}", "{\n    return paren_string.split(\"\
    \ \").map!(parens =>\n        parens.walkLength!((a, b) => a == '(' && b == ')').max).array;\n\
    }", "{\n    auto tokens = paren_string.split;\n    long[] result;\n    int highest_nesting\
    \ = 0;\n    int nesting = 0;\n    foreach(paren_group; tokens)\n    {\n      \
    \  foreach(paren; paren_group)\n        {\n            if(paren == '(')\n    \
    \        {\n                nesting++;\n            }\n            else\n    \
    \        {\n                nesting--;\n            }\n            highest_nesting\
    \ = max(nesting, highest_nesting);\n        }\n        result ~= highest_nesting;\n\
    \        highest_nesting = 0;\n        nesting = 0;\n    }\n    return result;\n\
    }", "{\n    return paren_string.split(\" \").map!((s) => paren_depth(s)).array;\n\
    }", "{\n    long[] ret = new long[];\n    int max_count = 0;\n    int count =\
    \ 0;\n    for (int i = 0; i < paren_string.length; i++) \n    {\n        auto\
    \ c = paren_string[i];\n        if (c == '(') \n        {\n            count++;\n\
    \            if (max_count < count) \n            {\n                max_count\
    \ = count;\n            }\n        }\n        else if (c == ')') \n        {\n\
    \            count--;\n        }\n        else if (c == ' ') \n        {\n   \
    \         ret ~= max_count;\n            max_count = 0;\n            count = 0;\n\
    \        }\n    }\n    return ret;\n}", "{\n    import std.algorithm : filter,\
    \ map;\n    auto nested_groups = paren_string.split.filter!(a => a.length).map!(a\
    \ => [a[0], a[$-1]]);\n    auto result = nested_groups.map!(a => a[0] == '(' ?\
    \ a[1] == ')' ? 1 : paren_helper(a[$-1])+1 : 0).array;\n    return result;\n}",
  "{\n\tsize_t[] open_paren_pos = ();\n\tsize_t[] close_paren_pos = ();\n\tsize_t[]\
    \ paren_counts = [];\n\tconst size_t len = paren_string.length;\n\tsize_t i =\
    \ 0;\n\twhile (i < len)\n\t{\n\t\tif (paren_string[i] == '(')\n\t\t{\n\t\t\topen_paren_pos\
    \ ~= i;\n\t\t}\n\t\telse if (paren_string[i] == ')')\n\t\t{\n\t\t\tif (open_paren_pos.length\
    \ > 0)\n\t\t\t{\n\t\t\t\tconst size_t start = open_paren_pos[$-1];\n\t\t\t\topen_paren_pos\
    \ = open_paren_pos[0..$-1];\n\t\t\t\tclose_paren_pos ~= i;\n\t\t\t\tsize_t cnt\
    \ = 0;\n\t\t\t\tfor (size_t j = start + 1; j < i; j++)\n\t\t\t\t{\n\t\t\t\t\t\
    if (paren_string[j] == '(')\n\t\t\t\t\t{\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\
    \t\t}\n\t\t\t\tparen_counts ~= cnt;\n\t\t\t}\n\t\t}\n\t\telse if (paren_string[i]\
    \ == ' ')\n\t\t{\n\t\t\tif (open_paren_pos.length == 0)\n\t\t\t{\n\t\t\t\tparen_counts\
    \ ~= 0;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\treturn paren_counts;\n}\n/*\n Given\
    \ an array of integer, find out the length of the longest consecutive elements\
    \ sequence.\n \n >>> find_longest_consecutive_sequence([100, 4, 200, 1, 3, 2])\n\
    \ 4\n*/\nlong find_longest_consecutive_sequence(long[] nums)\n{\n\tsort(nums);\n\
    \tconst size_t size = nums.length;\n\tlong max_length = 1;\n\tlong current_length\
    \ =", "{\n    ulong[] stack;\n    long[] accum;\n    foreach (i, p; paren_string.splitter)\n\
    \    {\n        stack = new ulong[];\n        foreach (c; p)\n        {\n    \
    \        if (c == '(')\n                stack ~= 0;\n            else if (c ==\
    \ ')')\n            {\n                stack.pop;\n                if (stack.length\
    \ > 0)\n                    stack[$-1]++;\n            }\n        }\n        accum\
    \ ~= max(stack);\n    }\n    return accum;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
