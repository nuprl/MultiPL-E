name: HumanEval_88_sort_array
language: d
results:
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    int i = 0;\n    int j = array.length - 1;\n    long temp;\n\
    \    bool even = (array[0] + array[array.length - 1]) % 2 == 0;\n    while (i\
    \ < j)\n    {\n        if (even)\n        {\n            if (array[i] % 2 == 0)\n\
    \            {\n                i++;\n            }\n            else if (array[j]\
    \ % 2 == 0)\n            {\n                j--;\n            }\n            else\n\
    \            {\n                temp = array[i];\n                array[i] = array[j];\n\
    \                array[j] = temp;\n                i++;\n                j--;\n\
    \            }\n        }\n        else\n        {\n            if (array[i] %\
    \ 2 == 0)\n            {\n                i++;\n            }\n            else\
    \ if (array[j] % 2 == 0)\n            {\n                j--;\n            }\n\
    \            else\n            {\n                temp = array[i];\n         \
    \       array[i] = array[j];\n                array[j] = temp;\n             \
    \   i++;\n                j--;\n            }\n        }\n    }\n    if (even)\n\
    \    {\n        array.sort!(x => \"descending\");\n    }\n    else\n    {\n  \
    \      array.sort!(x => \"ascending\");\n    }\n    return array;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n   \
    \ assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) ==\
    \ [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L,\
    \ 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L,\
    \ 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcanw4cj4.d(22): Error: cannot implicitly convert expression `array.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmpcanw4cj4.d(68): Error: no property\
    \ `sort` for type `long[]`\\n/tmp/tmpcanw4cj4.d(72): Error: no property `sort`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcanw4cj4.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long first = array[0];\n    long last = array[array.length -\
    \ 1];\n    bool order = (first + last) % 2 == 0;\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpittsba2m.d(24): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpittsba2m.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    // do the magic!\n    if (array.length == 0)\n    {\n      \
    \  return array;\n    }\n    if (array.length == 1)\n    {\n        return array;\n\
    \    }\n    long first = array[0];\n    long last = array[array.length - 1];\n\
    \    long sum = first + last;\n    if (sum % 2 == 0)\n    {\n        array.sort!((a,\
    \ b) => b - a);\n    }\n    else\n    {\n        array.sort!((a, b) => a - b);\n\
    \    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2xlpviua.d(35): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp2xlpviua.d(39): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2xlpviua.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    // your code here...\n    if (array.length == 0) {\n       \
    \ return array;\n    }\n    array.sort();\n    long[] result;\n    if (array[0]\
    \ + array[$-1] % 2 == 0) {\n        result = array.dup.reverse;\n    } else {\n\
    \        result = array.dup;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpki6c9b4j.d(25): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpki6c9b4j.d(28): Error: template `std.typecons.reverse` cannot deduce\
    \ function from argument types `!()(long[])`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmpki6c9b4j.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    else if ((array[0] + array[$-1]) % 2 == 0)\
    \ \n    {\n        array = array.sort(std.numeric.functor.greater);\n        return\
    \ array;\n    }\n    else\n    {\n        array = array.sort(std.numeric.functor.less);\n\
    \        return array;\n    }\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3_r62qp0.d(27): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp3_r62qp0.d(32): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3_r62qp0.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0) return array;\n    if (array.length ==\
    \ 1) return array;\n    if (array.length == 2)\n    {\n        if (array[0] >\
    \ array[1])\n        {\n            long temp = array[0];\n            array[0]\
    \ = array[1];\n            array[1] = temp;\n        }\n        return array;\n\
    \    }\n    else if (array[0] + array[array.length - 1] % 2 == 0)\n    {\n   \
    \     for (int i = 0; i < array.length - 1; i++)\n        {\n            for (int\
    \ j = i + 1; j < array.length; j++)\n            {\n                if (array[i]\
    \ < array[j])\n                {\n                    long temp = array[i];\n\
    \                    array[i] = array[j];\n                    array[j] = temp;\n\
    \                }\n            }\n        }\n    }\n    else\n    {\n       \
    \ for (int i = 0; i < array.length - 1; i++)\n        {\n            for (int\
    \ j = i + 1; j < array.length; j++)\n            {\n                if (array[i]\
    \ > array[j])\n                {\n                    long temp = array[i];\n\
    \                    array[i] = array[j];\n                    array[j] = temp;\n\
    \                }\n            }\n        }\n    }\n    return array;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n   \
    \ assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L,\
    \ 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) ==\
    \ [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L, 11L,\
    \ 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L, 21L,\
    \ 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp0mse0ygj.d(72): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428985]\\n??:? void tmp0mse0ygj.__unittest_L65_C1()\
    \ [0x42845a]\\n??:? void tmp0mse0ygj.__modtest() [0x428704]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c9e3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b876]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430a09]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430eb8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430995]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b84d]\\n??:? runModuleUnitTests [0x42c7b9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428e48]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428dcf]\\n??:? _d_run_main [0x428d3a]\\n??:? main [0x428717]\\\
    n??:? __libc_start_main [0x16a16554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length > 0)\n    {\n        if ((array[0] + array[$-1])\
    \ % 2 == 0)\n        {\n            return array.sort(std.less);\n        }\n\
    \        else\n        {\n            return array.sort(std.greater);\n      \
    \  }\n    }\n    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_g0zv0yx.d(25): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp_g0zv0yx.d(29): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_g0zv0yx.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    long[] res\
    \ = new long[array.length];\n    long sum = array[0] + array[$ - 1];\n    size_t\
    \ j = (sum % 2 == 0) ? 0 : array.length - 1;\n    for (size_t i = 0; i < array.length;\
    \ i++)\n    {\n        if (i % 2 == 0)\n        {\n            if (array[i] %\
    \ 2 == 0)\n                res[j++] = array[i];\n        }\n        else\n   \
    \     {\n            if (array[i] % 2 != 0)\n                res[j++] = array[i];\n\
    \        }\n    }\n    for (size_t i = 0; i < array.length; i++)\n    {\n    \
    \    if (i % 2 == 0)\n        {\n            if (array[i] % 2 != 0)\n        \
    \        res[j++] = array[i];\n        }\n        else\n        {\n          \
    \  if (array[i] % 2 == 0)\n                res[j++] = array[i];\n        }\n \
    \   }\n    return res;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L,\
    \ 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.RangeError@/tmp/tmpx3pim692.d(36): Range violation\\n----------------\\\
    n??:? _d_arrayboundsp [0x4289be]\\n??:? long[] tmpx3pim692.sort_array(long[])\
    \ [0x427fbd]\\n??:? void tmpx3pim692.__unittest_L54_C1() [0x428297]\\n??:? void\
    \ tmpx3pim692.__modtest() [0x42868c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c9c7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b85a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430ae5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430f94]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430a71]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b831]\\n??:? runModuleUnitTests [0x42c79d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428dd0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428d57]\\n??:? _d_run_main [0x428cc2]\\n??:? main [0x42869f]\\\
    n??:? __libc_start_main [0xef149554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0) return array;\n    array[] sorted;\n\
    \    long first_element = array[0];\n    long last_element = array[array.length\
    \ - 1];\n    sorted = array.sort(myFunction);\n    if ((first_element + last_element)\
    \ % 2 == 0) {\n      sorted = sorted.reverse();\n    }\n    return sorted;\n}\n\
    unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L,\
    \ 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5lk2trnu.d(22): Error: `array` is used as a type\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5lk2trnu.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length > 0)\n    {\n        auto first = array[0];\n\
    \        auto last = array[$ - 1];\n        array.sort();\n        if ((first\
    \ + last) % 2 == 0)\n        {\n            array.reverse();\n        }\n    }\n\
    \    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpx627ipyp.d(25): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpx627ipyp.d(28): Error: template `std.typecons.reverse` cannot deduce\
    \ function from argument types `!()(long[])`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmpx627ipyp.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    int odd = 1;\n    if ((array[0] + array[array.length\
    \ - 1]) % 2 == 0)\n        odd = 0;\n    if (odd == 1)\n        return sort!((a,\
    \ b) => a < b)(array).dup;\n    else\n        return sort!((a, b) => a > b)(array).dup;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpr1xftxlf.d(29): Error: template instance `sort!((a, b) => a <\
    \ b)` template `sort` is not defined, did you mean sqrt?\\n/tmp/tmpr1xftxlf.d(31):\
    \ Error: template instance `sort!((a, b) => a > b)` template `sort` is not defined,\
    \ did you mean sqrt?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpr1xftxlf.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length <= 1)\n        return array;\n    \n    size_t\
    \ first = 0;\n    size_t last = array.length - 1;\n    size_t k = (array[first]\
    \ + array[last]) % 2;\n    size_t i = 0;\n    while (i < array.length)\n    {\n\
    \        if (i != first && i != last)\n        {\n            if (array[i] % 2\
    \ == k)\n            {\n                if (array[i] > array[first])\n       \
    \         {\n                    long tmp = array[i];\n                    array[i]\
    \ = array[first];\n                    array[first] = tmp;\n                 \
    \   first++;\n                }\n                else if (array[i] < array[last])\n\
    \                {\n                    long tmp = array[i];\n               \
    \     array[i] = array[last];\n                    array[last] = tmp;\n      \
    \              last--;\n                }\n            }\n        }\n        i++;\n\
    \    }\n    \n    if (k == 0)\n        std.algorithm.reverse(array);\n    \n \
    \   return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5i4g_myd.d(54): Error: undefined identifier `algorithm` in package\
    \ `std`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5i4g_myd.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0)\n        return array;\n    if (array.length\
    \ == 1)\n        return array;\n    bool odd = (array[0] + array[array.length\
    \ - 1]) % 2 == 1;\n    if (odd)\n        sort(array);\n    else\n        sort(array).reversed;\n\
    \    return array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3a32trqk.d(27): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\n/tmp/tmp3a32trqk.d(29): Error: undefined identifier `sort`,\
    \ did you mean function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp3a32trqk.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length < 2)\n        return array;\n    bool ascending\
    \ = array[0] + array[$ - 1] % 2 == 0;\n    auto sort = (a, b) =>\n    {\n    \
    \    if (ascending)\n            return a > b;\n        else\n            return\
    \ a < b;\n    };\n    auto result = array.dup;\n    sort(result);\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbk4ztrpq.d(24): Error: variable `tmpbk4ztrpq.sort_array.sort`\
    \ type `void` is inferred from initializer `(a, b) => ()\\n{\\nif (ascending)\\\
    nreturn a > b;\\nelse\\nreturn a < b;\\n}\\n`, and variables cannot be of type\
    \ `void`\\n/tmp/tmpbk4ztrpq.d(24): Error: template lambda has no value\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbk4ztrpq.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0) \n        return array;\n    else if\
    \ (array.length == 1) \n        return array;\n    else if (array.length == 2)\
    \ \n        return (array[0] + array[1]) % 2 == 0 ? array.reverse() : array;\n\
    \    else \n    {\n        int[] arr = array.map!(x => (int)x);\n        for (int\
    \ i = 0; i < arr.length - 1; i++) \n        {\n            for (int j = 0; j <\
    \ arr.length - i - 1; j++) \n            {\n                int k = j + 1;\n \
    \               if ((arr[j] + arr[arr.length - 1]) % 2 == 0) \n              \
    \  {\n                    if (arr[j] < arr[k]) \n                    {\n     \
    \                   auto temp = arr[j];\n                        arr[j] = arr[k];\n\
    \                        arr[k] = temp;\n                    }\n             \
    \   } \n                else \n                {\n                    if (arr[j]\
    \ > arr[k]) \n                    {\n                        auto temp = arr[j];\n\
    \                        arr[j] = arr[k];\n                        arr[k] = temp;\n\
    \                    }\n                }\n            }\n        }\n        return\
    \ arr.map!(x => (long)x).array;\n    }\n}\nunittest\n{\n    alias candidate =\
    \ sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpl91qv0gu.d(29): Error: C style cast illegal, use `cast(int)x`\\\
    n/tmp/tmpl91qv0gu.d(55): Error: C style cast illegal, use `cast(long)x`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl91qv0gu.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0) \n        return array;\n    \n    else\
    \ if (array.length == 1) \n        return array;\n    \n    else \n    {\n   \
    \     int first = array[0];\n        int last = array[array.length - 1];\n   \
    \     int sum = first + last;\n        \n        auto cmp = (x, y) => (x > y)\
    \ ? -1 : (x < y) ? 1 : 0;\n        \n        if (isOdd(sum)) \n            array.sort!cmp();\n\
    \        \n        else if (isEven(sum)) \n            array.sort();\n       \
    \ \n        return array;\n    }\n}\n```\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([5L]) == [5L]);\n   \
    \ assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n \
    \   assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L,\
    \ 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpx8op2gxa.d(44): Error: declaration expected, not `\"\"`\\n/tmp/tmpx8op2gxa.d(44):\
    \ Error: unterminated string constant starting at /tmp/tmpx8op2gxa.d(44)\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx8op2gxa.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long[] ret = array.dup;\n    if(array.length > 0)\n    {\n \
    \       long idx = 0;\n        long lastIdx = array.length - 1;\n        bool\
    \ isOdd = ((array[idx] + array[lastIdx]) % 2) == 1;\n        ret.sort!((x, y)\
    \ => isOdd ? x > y : x < y);\n    }\n    return ret;\n}\n \nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnrbzfcnn.d(27): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnrbzfcnn.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    if (array.length == 0) \n        return array;\n    if (array.length\
    \ == 1) \n        return array;\n    if (array.length > 1)\n    {\n        int\
    \ first = array[0];\n        int last = array[array.length - 1];\n        int\
    \ odd = first + last;\n        int oddEven = odd % 2;\n        int[] newArray\
    \ = new int[array.length];\n        newArray = array;\n        if (oddEven ==\
    \ 0)\n        {\n            newArray.sort(Compare.Descending);\n        }\n \
    \       else\n        {\n            newArray.sort(Compare.Ascending);\n     \
    \   }\n        return newArray;\n    }\n}\n```\n### Javascript\n```\nfunction\
    \ sort_array(array) {\n    if (array.length == 0)\n        return array;\n   \
    \ if (array.length == 1)\n        return array;\n    if (array.length > 1)\n \
    \   {\n        var first = array[0];\n        var last = array[array.length -\
    \ 1];\n        var odd = first + last;\n        var oddEven = odd % 2;\n     \
    \   var newArray = [];\n        newArray = array;\n        if (oddEven == 0)\n\
    \        {\n            newArray.sort(function(a, b){return b-a});\n        }\n\
    \        else\n        {\n            newArray.sort(function(a, b){return a-b});\n\
    \        }\n        return newArray;\n    }\n}\n```\n### Ruby\n```\ndef sort_array(array)\n\
    \    if array.length == 0\n        return array\n    end\n    if array.length\
    \ == 1\n        return array\n    end\n    if array.length > 1\n        first\
    \ = array[0]\n        last = array[array.length - 1]\n        odd = first + last\n\
    \        oddEven = odd % 2\n        newArray = []\n        newArray = array\n\
    \        if oddEven == 0\n            newArray.sort! { |x,y| y <=> x }\n     \
    \   else\n            newArray.sort! { |x,y| x <=> y }\n        end\n        return\
    \ newArray\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L,\
    \ 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
    \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
    \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
    \ 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmbrosgdh.d(44): Error: declaration expected, not `\"\"`\\n/tmp/tmpmbrosgdh.d(50):\
    \ Error: declaration expected, not `if`\\n/tmp/tmpmbrosgdh.d(52): Error: declaration\
    \ expected, not `if`\\n/tmp/tmpmbrosgdh.d(59): Error: no identifier for declarator\
    \ `newArray`\\n/tmp/tmpmbrosgdh.d(59): Error: declaration expected, not `=`\\\
    n/tmp/tmpmbrosgdh.d(60): Error: declaration expected, not `if`\\n/tmp/tmpmbrosgdh.d(63):\
    \ Error: unrecognized declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpmbrosgdh.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    array = array.dup;\n    sort(array);\n    if(array.length ==\
    \ 0 || array.length == 1) \n        return array;\n    if((array[0] + array[$-1])\
    \ % 2 == 0) \n        reverse(array);\n    return array;\n}\nunittest\n{\n   \
    \ alias candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp18sevxm_.d(22): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\n/tmp/tmp18sevxm_.d(26): Error: template `std.typecons.reverse`\
    \ cannot deduce function from argument types `!()(long[])`, candidates are:\\\
    n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmp18sevxm_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
    \ integers, return a copy of the given array after sorting,\n    you will sort\
    \ the given array in ascending order if the sum( first index value, last index\
    \ value) is odd,\n    or sort it in descending order if the sum( first index value,\
    \ last index value) is even.\n\n    Note:\n    * don't change the given array.\n\
    \n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n  \
    \  * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \n*/\nlong[] sort_array(long[]\
    \ array) \n{\n    long[] ret;\n    if(array.length == 0)\n        return ret;\n\
    \    else if(array.length == 1)\n        return array;\n    else if(array.length\
    \ > 1)\n    {\n        ret = array.dup;\n        if((array[0] + array[$-1]) %\
    \ 2 == 0)\n            ret.sort!((a, b) => b - a);\n        else\n           \
    \ ret.sort!((a, b) => a - b);\n    }\n    return ret;\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([]) == []);\n    assert(candidate([5L])\
    \ == [5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L]) == [0L, 1L, 2L, 3L,\
    \ 4L, 5L]);\n    assert(candidate([2L, 4L, 3L, 0L, 1L, 5L, 6L]) == [6L, 5L, 4L,\
    \ 3L, 2L, 1L, 0L]);\n    assert(candidate([2L, 1L]) == [1L, 2L]);\n    assert(candidate([15L,\
    \ 42L, 87L, 32L, 11L, 0L]) == [0L, 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L,\
    \ 14L, 23L, 11L]) == [23L, 21L, 14L, 11L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfj7jgf8d.d(30): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpfj7jgf8d.d(32): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfj7jgf8d.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
