name: HumanEval_131_digits
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\nGiven a positive integer n, return\
  \ the product of the odd digits.\n    Return 0 if all digits are even.\n    For\
  \ example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n  \
  \  \n*/\nlong digits(long n) \n"
tests: "unittest\n{\n    alias candidate = digits;\n\n    assert(candidate(5L) ==\
  \ 5L);\n    assert(candidate(54L) == 5L);\n    assert(candidate(120L) == 1L);\n\
  \    assert(candidate(5014L) == 5L);\n    assert(candidate(98765L) == 315L);\n \
  \   assert(candidate(5576543L) == 2625L);\n    assert(candidate(2468L) == 0L);\n\
  }\nvoid main(){}"
completions: ["{\n    long product = 1;\n    long i = n;\n    while(i > 0)\n    {\n\
    \        long digit = i % 10;\n        i /= 10;\n        if(digit % 2 != 0)\n\
    \        {\n            product *= digit;\n        }\n    }\n    return product;\n\
    }", "{\n    int[] arr;\n    int count = 0;\n    if(n <= 0) return 0;\n    while(n\
    \ != 0) {\n        int digit = n % 10;\n        if(digit % 2 != 0)\n        {\n\
    \            arr ~= digit;\n            count++;\n        }\n        n /= 10;\n\
    \    }\n    long result = 1;\n    foreach(int x; arr) {\n        result *= x;\n\
    \    }\n    return result;\n}", "{\n    long sum = 1;\n    while(n > 0) {\n  \
    \      long digit = n % 10;\n        if(digit % 2 != 0)\n            sum *= digit;\n\
    \        n /= 10;\n    }\n    return sum;\n}", "{\n    long result = 1;\n    while(n\
    \ > 0)\n    {\n        auto m = n % 10;\n        if(m % 2 != 0)\n            result\
    \ *= m;\n        n /= 10;\n    }\n    return result;\n}", "{\n    long result\
    \ = 1;\n    if (n & 1) result *= n % 10;\n    n /= 10;\n    return n ? result\
    \ * digits(n) : result;\n}", "{\n    int multiply = 1;\n    while(n != 0)\n  \
    \  {\n      auto digit = n % 10;\n      if(digit % 2 != 0)\n      {\n        multiply\
    \ *= digit;\n      }\n      n /= 10;\n    }\n    return multiply;\n}\n/*\nWrite\
    \ a function that validates a password. \n    The password should consist of at\
    \ least 8 symbols, \n    and must contain: at least one digit, at least one lowercase\
    \ letter, \n    at least one uppercase letter, at least one special symbol (!,\
    \ @, $).\n    Accepts any other symbols.\n*/", "{\n    import std.range;\n   \
    \ import std.conv;\n    long res = 1;\n    //if(n < 0) return res;\n    while(n\
    \ != 0) {\n        int r = n % 10;\n        if(r % 2 != 0) {\n            res\
    \ *= r;\n        }\n        n /= 10;\n    }\n    return res;\n}", "{\n    long\
    \ ret = 1;\n    while(n > 0)\n    {\n        if((n % 10) % 2 != 0)\n         \
    \   ret *= (n % 10);\n        n /= 10;\n    }\n    return ret;\n}", "{\n    auto\
    \ prod = 1;\n    while (n) \n    {\n        prod *= n % 10;\n        n /= 10;\n\
    \    }\n    return prod;\n}\n// Test functions\nunittest \n{\n    mixin(\"import\
    \ std.random;\");\n    int len = 1_000_000;\n    auto rng = Random(unpredictableSeed);\n\
    \    auto arr = new long[](len);\n    for (int i = 0; i < len; i++) \n    {\n\
    \        arr[i] = rng.uniform(int.min, int.max);\n    }\n    foreach (n; arr)\
    \ \n    {\n        assert(digits(n) == digits2(n));\n    }\n}\n// Solution 2\n\
    long digits2(long n) \n{\n    return reduce!((a, b) => b % 2 ? a * b : a)(1, split(n,\
    \ 10)).product;\n}\n// Test functions\nunittest \n{\n    mixin(\"import std.random;\"\
    );\n    int len = 1_000_000;\n    auto rng = Random(unpredictableSeed);\n    auto\
    \ arr = new long[](len);\n    for (int i = 0; i < len; i++) \n    {\n        arr[i]\
    \ = rng.uniform(int.min, int.max);\n    }\n    foreach (n; arr) \n    {\n    \
    \    assert(digits(n) == digits2(n));\n    }\n}\n```", "{\n    auto res = 0L;\n\
    \    auto flag = true;\n    while(n != 0) {\n        auto m = n % 10;\n      \
    \  if(m % 2 != 0) {\n            res = res * 10 + m;\n        }\n        else\
    \ {\n            flag = false;\n        }\n        n /= 10;\n    }\n    if(flag)\
    \ {\n        return 0;\n    }\n    return res;\n}", "{\n  long product = 1;\n\
    \  while(n > 0)\n  {\n    long digit = n % 10;\n    if(digit % 2 != 0)\n    {\n\
    \      product *= digit;\n    }\n    n /= 10;\n  }\n  return product;\n}\n/*\n\
    You are going to be given a word. Your job is to return the middle character of\
    \ the word. If the word's length is odd, return the middle character. If the word's\
    \ length is even, return the middle 2 characters.\nExamples:\nKata.getMiddle(\"\
    test\") should return \"es\"\nKata.getMiddle(\"testing\") should return \"t\"\n\
    Kata.getMiddle(\"middle\") should return \"dd\"\nKata.getMiddle(\"A\") should\
    \ return \"A\"\nInput\nA word (string) of length 0 < str < 1000 (In javascript\
    \ you may get slightly more than 1000 in some test cases due to an error in the\
    \ test cases). You do not need to test for this. This is only here to tell you\
    \ that you do not need to worry about your solution timing out.\nOutput\nThe middle\
    \ character(s) of the word represented as a string.\n*/\nstring getMiddle(string\
    \ s) \n{\n  return s.length % 2 == 0 ? s[s.length / 2 - 1..s.length / 2] : s[s.length\
    \ / 2..s.length / 2];\n}\n/*\nIn DNA strings, symbols \"A\" and \"T\" are complements\
    \ of each other, as \"C\" and \"G\". You have function with one side of the DNA\
    \ (string, except for Haskell); you need to get the other complementary side.\
    \ DNA strand is never empty or there is no DNA at all (again, except for Haskell).\n\
    DNAStrand (\"ATTGC\") // return \"TAACG\"\nDNAStrand (\"GTAT\") // return \"CATA\"\
    \n*/\nstring DNAStrand(string dna) \n{\n  return dna.map!(a => a == 'A' ? 'T'\
    \ : a == 'T' ? 'A' : a == 'C' ? 'G' : 'C');\n}\n/*\nGiven an array of ints, return\
    \ true if the array contains two 7's next to each other, or there are two", "{\n\
    \    long result = 1;\n    if (n == 0) return 0;\n    while (n > 0)\n    {\n \
    \       long digit = n % 10;\n        if (digit % 2 != 0)\n        {\n       \
    \     result *= digit;\n        }\n        n /= 10;\n    }\n    return result;\n\
    }", "{\n    long mul = 1;\n    foreach(digit; n.digits)\n    {\n        if(digit.isOdd)\n\
    \            mul *= digit;\n    }\n    return mul;\n}", "{\n    long result =\
    \ 1;\n    while(n > 0) {\n        auto digit = n % 10;\n        if(digit % 2 !=\
    \ 0) result *= digit;\n        n /= 10;\n    }\n    return result;\n}", "{\n \
    \   long k = 1;\n    foreach(it; n.text)\n    {\n        if((it-'0') % 2 != 0)\n\
    \            k *= it-'0';\n    }\n    return k;\n}", "{\n    // Write your code\
    \ here.\n    int result = 1;\n    while(n > 0)\n    {\n        auto digit = n\
    \ % 10;\n        if (digit % 2 == 1)\n            result *= digit;\n        n\
    \ /= 10;\n    }\n    return result;\n}", "{\n  n = n.toString.filter!(e => e.toLong\
    \ % 2).map!(e => e.toLong).product;\n  if (n == 0)\n    return 0;\n  else\n  \
    \  return n;\n}", "{\n    auto a = to!string(n);\n    auto p = 1;\n    foreach(ch;\
    \ a)\n    {\n        if(ch - '0'%2 == 0)\n            continue;\n        p *=\
    \ ch - '0';\n    }\n    return p;\n}", "{\n    //long res = 1;\n    //long buff\
    \ = n;\n    //while(buff > 0)\n    //{\n    //    long dig = buff % 10;\n    //\
    \    if(dig % 2 == 1) res *= dig;\n    //    buff /= 10;\n    //}\n    //return\
    \ res;\n    n = n.to!string().removeChars(\"02468\").to!long();\n    return n.to!string().empty\
    \ ? 0 : n.to!string().to!longArray().product;\n}", "{\n    long r = 1;\n    while\
    \ (n > 0)\n    {\n        long d = n % 10;\n        if (d % 2 != 0)\n        \
    \    r *= d;\n        n /= 10;\n    }\n    return r;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
