name: HumanEval_107_even_odd_palindrome
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer\
  \ n, return a tuple that has the number of even and odd\n    integer palindromes\
  \ that fall within the range(1, n), inclusive.\n\n    Example 1:\n\n        Input:\
  \ 3\n        Output: (1, 2)\n        Explanation:\n        Integer palindrome are\
  \ 1, 2, 3. one of them is even, and two of them are odd.\n\n    Example 2:\n\n \
  \       Input: 12\n        Output: (4, 6)\n        Explanation:\n        Integer\
  \ palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of\
  \ them are odd.\n\n    Note:\n        1. 1 <= n <= 10^3\n        2. returned tuple\
  \ has the number of even and odd integer palindromes respectively.\n    \n*/\nTuple!(long,\
  \ long) even_odd_palindrome(long n) \n"
tests: "unittest\n{\n    alias candidate = even_odd_palindrome;\n\n    assert(candidate(123L)\
  \ == tuple(8L, 13L));\n    assert(candidate(12L) == tuple(4L, 6L));\n    assert(candidate(3L)\
  \ == tuple(1L, 2L));\n    assert(candidate(63L) == tuple(6L, 8L));\n    assert(candidate(25L)\
  \ == tuple(5L, 6L));\n    assert(candidate(19L) == tuple(4L, 6L));\n    assert(candidate(9L)\
  \ == tuple(4L, 5L));\n    assert(candidate(1L) == tuple(0L, 1L));\n}\nvoid main(){}"
completions: ["{\n    /*  Time Complexity: O(N)\n        Space Complexity: O(1)\n\
    \    */\n    enum bool isEven = false;\n    if(n % 2 == 0)\n        isEven = true;\n\
    \    long oddCount = n/2;\n    long evenCount = n/2;\n    if(isEven)\n       \
    \ evenCount += 1;\n    else\n        oddCount += 1;\n    return tuple(evenCount,\
    \ oddCount);\n}", "{\n    long odd_palindrome = 0;\n    long even_palindrome =\
    \ 0;\n    foreach(long i ; 2 .. n + 1)\n    {\n        if(i % 2 == 0) even_palindrome++;\n\
    \        else odd_palindrome++;\n    }\n    return tuple(even_palindrome, odd_palindrome);\n\
    }\n/*\n    204. Count Primes", "{\n    long even = 0, odd = 0;\n    auto digits\
    \ = (long) log10(n);\n    long odd_count = (digits + 1) / 2;\n    long even_count\
    \ = digits / 2;\n    auto highest_odd = (long)pow(10, odd_count);\n    auto highest_even\
    \ = (long)pow(10, even_count);\n    for (long i = 1; i < highest_odd; i++) \n\
    \    {\n        long palin = createPalindrome(i, odd_count);\n        if (palin\
    \ <= n) \n        {\n            odd++;\n        }\n    }\n    for (long i = 1;\
    \ i < highest_even; i++) \n    {\n        long palin = createPalindrome(i, even_count);\n\
    \        if (palin <= n) \n        {\n            even++;\n        }\n    }\n\
    \    return tuple(even, odd);\n}", "{\n    long even, odd;\n    long range_max;\n\
    \    long result_d;\n    long result_v;\n    bool odd_flag = true;\n    bool even_flag\
    \ = true;\n    long power_of_ten = 10;\n    long half_of_n;\n    long[] arr_d,\
    \ arr_v;\n    long[] range_min_digits;\n    long[] range_max_digits;\n    long[]\
    \ digits;\n    long[] result_digits;\n    long[] result_odd_digits;\n    long[]\
    \ result_even_digits;\n    long[] diff_digits;\n    long[] min_digits;\n    long[]\
    \ max_digits;\n    long[] copy_digits;\n    long index;\n    long first_digit;\n\
    \    long first_half_value;\n    long second_half_value;\n    long power_of_ten_diff;\n\
    \    long max_compared_value;\n    long min_compared_value;\n    long min_digit_value;\n\
    \    long min_digit_value_for_one;\n    long min_digit_value_without_one;\n  \
    \  long d_value;\n    long v_value;\n    long d_len;\n    long v_len;\n    long\
    \ d_index;\n    long v_index;\n    long iter;\n    long difference;\n    long\
    \ min_odd;\n    long min_even;\n    long max_odd;\n    long max_even;\n    long\
    \ diff_len;\n    long[] range_value_digits;\n    long range_value_digits_index;\n\
    \    long range_value_digits_len;\n    long range_value_digits_without_one_len;\n\
    \    long min_range_value_digits_index;\n    long min_range_value_digits_len;\n\
    \    long min_range_value_digits_without_one_len;\n    long min_range_value_without_one;\n\
    \    long min_range_value_with_one;\n    long max_range_value_digits_index;\n\
    \    long max_range_value_digits_len;\n    long", "{\n    long e = 0, o = 0;\n\
    \    foreach(i; 1 .. n + 1)\n    {\n        string s = to!string(i);\n       \
    \ auto rs = s.dup.assumeUnique.retro;\n        if(s == rs)\n        {\n      \
    \      if(i % 2 == 0)\n                e++;\n            else\n              \
    \  o++;\n        }\n    }\n    return tuple(e, o);\n}", "{\n    long even_count\
    \ = 0;\n    long odd_count = 0;\n    if (n == 1)\n    {\n        return tuple(even_count,\
    \ odd_count);\n    }\n    else\n    {\n        even_count++;\n        odd_count++;\n\
    \    }\n    long half_len = (long) log10(n) / 2;\n    if (n % 10 == 0)\n    {\n\
    \        half_len--;\n    }\n    if (half_len == 0)\n    {\n        return tuple(even_count,\
    \ odd_count);\n    }\n    long modulo = (long) pow(10, half_len);\n    long even_start\
    \ = 0;\n    long even_end = 0;\n    long odd_start = 0;\n    long odd_end = 0;\n\
    \    long next_digit = 0;\n    for (long i = 1; i <= half_len; i++)\n    {\n \
    \       modulo /= 10;\n        next_digit = n / modulo;\n        if (i == 1)\n\
    \        {\n            even_start = 1;\n            even_end = next_digit;\n\
    \            odd_start = 0;\n            odd_end = next_digit - 1;\n        }\n\
    \        else\n        {\n            even_start *= 10;\n            even_end\
    \ = even_start + next_digit;\n            odd_start = even_start + 1;\n      \
    \      odd_end = even_end - 1;\n        }\n        long current_len = half_len\
    \ - i + 1;\n        even_count += even_end - even_start + 1;\n        if (next_digit\
    \ != 9)\n        {\n            even_count += (next_digit - 1) * (pow(10, current_len)\
    \ - pow(10, current_len - 1));\n        }\n        else\n        {\n         \
    \   even_count += pow(10, current_len) - pow(10, current_len - 1);\n        }\n\
    \        odd_count += odd_end - odd_start + 1;\n        if (next_digit != 9)\n\
    \        {\n            odd_count += (next_digit - 1) * (pow(10,", "{\n    Tuple!(long,\
    \ long) ret;\n    for (long i = 1; i <= n; i++) \n    {\n        auto elem = to!string(i);\n\
    \        if (elem.length > 1) \n        {\n            auto first = elem[0];\n\
    \            auto last = elem[$ - 1];\n            if (first == last) \n     \
    \       {\n                if (i % 2 == 0) \n                {\n             \
    \       ret[0]++;\n                }\n                else \n                {\n\
    \                    ret[1]++;\n                }\n            }\n        }\n\
    \        else \n        {\n            ret[0]++;\n        }\n    }\n    return\
    \ ret;\n}", "{\n    long odd_palindrome = 0, even_palindrome = 0;\n    for (long\
    \ i = 1; i <= n; i++) \n    {\n        if (is_palindrome(i)) \n        {\n   \
    \         if (is_even(i)) \n            {\n                even_palindrome++;\n\
    \            } \n            else \n            {\n                odd_palindrome++;\n\
    \            }\n        }\n    }\n    return tuple(even_palindrome, odd_palindrome);\n\
    }", "{\n    bool isPalindrome(long n)\n    {\n        long reversed = 0;\n   \
    \     long tmp = n;\n        while (tmp != 0)\n        {\n            reversed\
    \ = reversed * 10 + tmp % 10;\n            tmp /= 10;\n        }\n        return\
    \ reversed == n;\n    }", "{\n    long even = 0;\n    long odd = 0;\n    while\
    \ (n != 0) \n    {\n        if (n % 2 == 0)\n            even++;\n        else\n\
    \            odd++;\n        n /= 10;\n    }\n    return tuple(even, odd);\n}",
  "{\n    long even = 0, odd = 0;\n    string s;\n    long i;\n    for (i = 1; i <=\
    \ n; i++) \n    {\n        s = to!string(i);\n        if (s == s.dup.reverse)\
    \ \n        {\n            if (i & 1) odd++;\n            else even++;\n     \
    \   }\n    }\n    return tuple(even, odd);\n}\n// long even = 0, odd = 0;\n//\
    \ string s;\n// long i;\n// for (i = 1; i <= n; i++) \n// {\n//     s = to!string(i);\n\
    //     if (s == s.dup.reverse) \n//     {\n//         if (i & 1) odd++;\n//  \
    \       else even++;\n//     }\n// }\n// return tuple(even, odd);", "{\n    long\
    \ even_count = 0, odd_count = 0;\n    ulong tmp = cast(ulong)n;\n    if (n ==\
    \ 1)\n    {\n        return tuple(1, 0);\n    }\n    if (n % 2 != 0)\n    {\n\
    \        even_count = 1;\n    }\n    while (tmp > 1)\n    {\n        odd_count++;\n\
    \        tmp = tmp / 10;\n    }\n    return tuple(even_count, odd_count);\n}",
  "{\n    long even_palindrome = 0;\n    long odd_palindrome = 0;\n    foreach(number;\
    \ 1..n+1)\n    {\n        string strNumber = to!string(number);\n        reverse(strNumber);\n\
    \        if(strNumber == to!string(number))\n        {\n            if(number\
    \ % 2 == 0)\n            {\n                even_palindrome++;\n            }\n\
    \            else\n            {\n                odd_palindrome++;\n        \
    \    }\n        }\n    }\n    return tuple(even_palindrome, odd_palindrome);\n\
    }", "{\n    long numberOfEvenPals = 0;\n    long numberOfOddPals = 0;\n    for\
    \ (long i = 1; i <= n; i++)\n    {\n        if (i.to!string.isPalindrome)\n  \
    \      {\n            if (i % 2 == 0) numberOfEvenPals++;\n            else numberOfOddPals++;\n\
    \        }\n    }\n    return tuple(numberOfEvenPals, numberOfOddPals);\n}", "{\n\
    \    int count_even = 0;\n    int count_odd = 0;\n    for (int i = 1; i <= n;\
    \ i++) \n    {\n        int len = log10(i) + 1;\n        if (len & 1)\n      \
    \      ++count_odd;\n        else\n            ++count_even;\n    }\n    return\
    \ tuple(count_even, count_odd);\n}", "{\n    long odd = 0;\n    long even = 0;\n\
    \    for (long l = 1; l <= n; l++) \n    {\n        if (isPalindrome(l)) \n  \
    \      {\n            if (l % 2 == 0)\n                even++;\n            else\n\
    \                odd++;\n        }\n    }\n    return tuple(even, odd);\n}", "{\n\
    \    long even = 0, odd = 0;\n    for (long i = 1; i <= n; i++) \n    {\n    \
    \    if (is_palindrome(i)) \n        {\n            if (i % 2 == 0) \n       \
    \     {\n                even++;\n            } \n            else \n        \
    \    {\n                odd++;\n            }\n        }\n    }\n    return tuple(even,\
    \ odd);\n}", "{\n    long even = 0;\n    long odd = 0;\n    int s = cast(int)log10(n);\n\
    \    for (int i = 1; i <= s; i++)\n    {\n        int k = cast(int)pow(10, i);\n\
    \        int d = n / k;\n        // this is odd palindrome\n        if (i == 1)\n\
    \        {\n            if (n % k == 0)\n                odd += d + 1;\n     \
    \       else\n                odd += d;\n        }\n        else\n        {\n\
    \            // even palindrome\n            if (n % k == 0)\n               \
    \ even += d;\n            else\n                even += d + 1;\n            //\
    \ odd palindrome\n            if (n % k == 0)\n                odd += d + 1;\n\
    \            else\n                odd += d;\n        }\n    }\n    return tuple(even,\
    \ odd);\n}", "{\n    Tuple!(long, long) result = Tuple!(long, long)(0, 0);\n \
    \   ulong rev;\n    long i, f = 0;\n    for (i = 1; i <= n; i++) {\n        rev\
    \ = cast(ulong)i;\n        f = 0;\n        while (rev > 0) {\n            f =\
    \ 10 * f + (rev % 10);\n            rev /= 10;\n        }\n        if (f == i)\
    \ {\n            result[0] += (i % 2 == 0) ? 1 : 0;\n            result[1] +=\
    \ (i % 2 == 1) ? 1 : 0;\n        }\n    }\n    return result;\n}", "{\n    long\
    \ even = 0, odd = 0;\n    for (size_t i = 1; i <= n; i++) \n    {\n        long\
    \ rev = reverse(i);\n        if (rev == i) \n        {\n            if (i % 2\
    \ == 0) \n            {\n                even++;\n            } \n           \
    \ else \n            {\n                odd++;\n            }\n        }\n   \
    \ }\n    return tuple(even, odd);\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
