name: HumanEval_95_check_dict_case
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    Given a dictionary, return\
  \ True if all keys are strings in lower \n    case or all keys are strings in upper\
  \ case, else return False.\n    The function should return False is the given dictionary\
  \ is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"\
  }) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\",\
  \ \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\"\
  , \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"\
  Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n \
  \   check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
  \    \n*/\nbool check_dict_case(Nullable!(string[string]) dict) \n"
tests: "unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
  p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
  p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
  \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
  ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\"\
  , \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\":\
  \ \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
  : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
  \ == false);\n}\nvoid main(){}"
completions: ["{\n    string[] a;\n    if(dict.isNull)\n        return false;\n  \
    \  a = dict.get;\n    return(allSatisfy!(isLower,a.keys) || allSatisfy!(isUpper,a.keys));\n\
    }", "{\n    if(dict is null) return false;\n    int cntLower = 0;\n    int cntUpper\
    \ = 0;\n    foreach(key, value; dict)\n    {\n        if(key.isUpper) cntUpper++;\n\
    \        else if(key.isLower) cntLower++;\n        else return false;\n    }\n\
    \    return cntLower == dict.length || cntUpper == dict.length;\n}", "{\n    bool\
    \ is_lower = true;\n    bool is_upper = true;\n    if (dict is null) return false;\n\
    \    if (dict.keys.length == 0) return false;\n    foreach (key; dict.keys) \n\
    \    {\n        if (is_lower) is_lower = key.toLower == key;\n        if (is_upper)\
    \ is_upper = key.toUpper == key;\n        if (!is_lower && !is_upper) return false;\n\
    \    }\n    return true;\n}", "{\n    if(!dict.isNull && dict.get.length > 0)\n\
    \    {\n        bool allLowerCase = true;\n        bool allUpperCase = true;\n\
    \        foreach(key, value; dict.get)\n        {\n            if(toLower(key)\
    \ != key)\n            {\n                allLowerCase = false;\n            }\n\
    \            if(toUpper(key) != key)\n            {\n                allUpperCase\
    \ = false;\n            }\n        }\n        return allLowerCase || allUpperCase;\n\
    \    }\n    return false;\n}", "{ \n    if (dict.isNull) return false;\n    int\
    \ lowCount = 0;\n    int upperCount = 0;\n    int total = 0;\n    foreach (k;\
    \ dict.get) \n    {\n        total++;\n        if (isAllLower(k)) lowCount++;\n\
    \        if (isAllUpper(k)) upperCount++;\n    }\n    return (lowCount == total\
    \ || upperCount == total);\n}", "{\n\tif (dict is null)\n\t\treturn false;\n\t\
    int len = dict.length;\n\tif (len == 0)\n\t\treturn false;\n\tbool isLower = dict.keys[0].toLowerCase\
    \ == dict.keys[0];\n\tint count = 0;\n\tforeach (key; dict.keys)\n\t{\n\t\tif\
    \ (isLower)\n\t\t{\n\t\t\tif (key.toLowerCase != key)\n\t\t\t\treturn false;\n\
    \t\t}\n\t\telse\n\t\t{\n\t\t\tif (key.toUpperCase != key)\n\t\t\t\treturn false;\n\
    \t\t}\n\t\tcount++;\n\t}\n\treturn count == len;\n}", "{\n\tif(dict.isNull) return\
    \ false;\n\tbool lower=false, upper=false;\n\tforeach(k,v; dict) \n\t{\n\t\tif(k.isUpper)\
    \ upper=true;\n\t\telse if(k.isLower) lower=true;\n\t\telse return false;\n\t\
    }\n\treturn lower ^ upper;\n}", "{\n    if (dict is null)\n        return false;\n\
    \    if (dict.length == 0)\n        return false;\n    bool all_upper = true;\n\
    \    foreach (key; dict.keys)\n    {\n        if (!isUpper(key))\n        {\n\
    \            all_upper = false;\n            break;\n        }\n    }\n    if\
    \ (all_upper)\n        return true;\n    bool all_lower = true;\n    foreach (key;\
    \ dict.keys)\n    {\n        if (!isLower(key))\n        {\n            all_lower\
    \ = false;\n            break;\n        }\n    }\n    return all_lower;\n}", "{\n\
    \    // check null\n    if(!dict.isNull)\n    {\n        bool allupper = true;\n\
    \        bool alllower = true;\n        // loop through keys\n        foreach(k;\
    \ dict.get.keys)\n        {\n            // check uppercase\n            if(k.isUpper)\n\
    \            {\n                alllower = false;\n            }\n           \
    \ // check lowercase\n            else if(k.isLower)\n            {\n        \
    \        allupper = false;\n            }\n            // not uppercase nor lowercase\n\
    \            else\n            {\n                return false;\n            }\n\
    \        }\n        //\n        return allupper || alllower;\n    }\n    else\n\
    \    {\n        return false;\n    }\n}\n//", "{\n    //TODO\n    return false;\n\
    }", "{\n    if(dict is null)\n        return false;\n    foreach(k,v; dict)\n\
    \    {\n        static if(k.length == 1)\n        {\n            if(isLetter(k[0]))\n\
    \            {\n                if(isUpper(k[0]))\n                {\n       \
    \             foreach(k1,v1; dict)\n                    {\n                  \
    \      if(k1 != k)\n                        {\n                            if(k1.length\
    \ == 1)\n                            {\n                                if(isLetter(k1[0]))\n\
    \                                {\n                                    if(!isUpper(k1[0]))\n\
    \                                        return false;\n                     \
    \           }\n                                else\n                        \
    \            return false;\n                            }\n                  \
    \          else\n                                return false;\n             \
    \           }\n                    }\n                }\n                else\n\
    \                {\n                    foreach(k1,v1; dict)\n               \
    \     {\n                        if(k1 != k)\n                        {\n    \
    \                        if(k1.length == 1)\n                            {\n \
    \                               if(isLetter(k1[0]))\n                        \
    \        {\n                                    if(!isLower(k1[0]))\n        \
    \                                return false;\n                             \
    \   }\n                                else\n                                \
    \    return false;\n                            }\n                          \
    \  else\n                                return false;\n                     \
    \   }\n                    }\n                }\n            }\n            else\n\
    \                return false;\n        }\n        else\n            return false;\n\
    \    }\n    return true;\n}", "{\n\tif(dict is null)\n\t\treturn false;\n\telse\n\
    \t{\n\t\tbool is_all_upper = true;\n\t\tforeach(k, v; dict)\n\t\t{\n\t\t\tif(!k.isUpper)\n\
    \t\t\t{\n\t\t\t\tis_all_upper = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(is_all_upper)\n\
    \t\t\treturn true;\n\t\telse\n\t\t{\n\t\t\tbool is_all_lower = true;\n\t\t\tforeach(k,\
    \ v; dict)\n\t\t\t{\n\t\t\t\tif(!k.isLower)\n\t\t\t\t{\n\t\t\t\t\tis_all_lower\
    \ = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn is_all_lower;\n\
    \t\t}\n\t}\n}", "{\n    if(dict is null)\n        return false;\n    if(dict.empty)\n\
    \        return false;\n    bool found_lower = false;\n    bool found_upper =\
    \ false;\n    foreach(k; dict.keys)\n    {\n        if(lower(k) == k)\n      \
    \      found_lower = true;\n        else if(upper(k) == k)\n            found_upper\
    \ = true;\n        else\n            return false;\n    }\n    return found_lower\
    \ ? !found_upper : found_upper;\n}", "{\n    if(dict.isNull) return false;\n \
    \   bool upper = true;\n    foreach(ref const key, value; dict)\n    {\n     \
    \   if(!isUpper(key[0]))\n        {\n            upper = false;\n            break;\n\
    \        }\n    }\n    if(upper) return true;\n    bool lower = true;\n    foreach(ref\
    \ const key, value; dict)\n    {\n        if(!isLower(key[0]))\n        {\n  \
    \          lower = false;\n            break;\n        }\n    }\n    return lower;\n\
    }", "{\n    if(dict is null)\n        return false;\n    else\n    {\n       \
    \ size_t check = dict.length;\n        // writeln(check);\n        foreach(key,\
    \ val; dict)\n        {\n            // writeln(key);\n            // writeln(val);\n\
    \            if(key.toUpperCase() == key || key.toLowerCase() == key)\n      \
    \          check--;\n        }\n        // writeln(check);\n        if(check ==\
    \ 0)\n            return true;\n        else\n            return false;\n    }\n\
    }", "{\n    return false;\n}\n/*", "{\n    if(dict.isNull)\n        return false;\n\
    \    string[] keys = dict.get.keys;\n    bool in_lower_case = true;\n    bool\
    \ in_upper_case = true;\n    foreach(key; keys)\n    {\n        in_lower_case\
    \ = in_lower_case && (toLower(key) == key);\n        in_upper_case = in_upper_case\
    \ && (toUpper(key) == key);\n    }\n    return in_lower_case || in_upper_case;\n\
    }", "{\n    if (dict.isNull)\n        return false;\n    \n    foreach (k, v;\
    \ dict)\n    {\n        auto s = dict[k];\n        // int i = s[0];\n        //\
    \ if (i == s[0].toUpper)\n        //     return false;\n        // if (i == s[0].toLower)\n\
    \        //     return false;\n        if (s[0].toUpper != s[0] && s[0].toLower\
    \ != s[0])\n            return false;\n    }\n    return true;\n}", "{\n    //\
    \ type error, array[Nullable!] cannot convert to array[T]\n    // \n    // \n\
    \    // cannot implicitly convert expression (*dict.get) of type inout(Nullable!(dchar))\
    \ \n    // to inout(dchar)\n    if (dict.isNull)\n        return false;\n    //\
    \ auto k = dict.get.keys.front;\n    // auto v = dict.get.values.front;\n    //\
    \ auto [k, v] = dict.get.assocs.front;\n    import std.algorithm;\n    auto r\
    \ = dict.get.assocs.find!(kvp => (kvp.key[0] ^ ('a'.front)) && (kvp.key[0] ^ ('A'.front)));\n\
    \    if (r.empty)\n        return true;\n    else \n        return false;\n  \
    \  \n}", "{\n    if (dict is null)\n        return false;\n    bool wasUpper =\
    \ true;\n    int countUpper = 0;\n    foreach (key; dict.keys) \n    {\n     \
    \   if (isUpper(key[0])) \n        {\n            wasUpper = true;\n         \
    \   countUpper++;\n        }\n        else \n        {\n            wasUpper =\
    \ false;\n        }\n    }\n    if (countUpper == dict.length)\n        return\
    \ true;\n    else if (!wasUpper)\n        return true;\n    else\n        return\
    \ false;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
