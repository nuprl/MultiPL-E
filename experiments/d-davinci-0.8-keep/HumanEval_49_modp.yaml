name: HumanEval_49_modp
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
  \ of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n   \
  \ >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n\
  \    1\n    \n*/\nlong modp(long n, long p) \n"
tests: "unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
  \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
  \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
  \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
  \ == 3L);\n}\nvoid main(){}"
completions: ["{\n    long res = 1;\n    while (n > 0) \n    {\n        res = (res\
    \ * 2) % p;\n        n--;\n    }\n    return res;\n}\n \n/*\nReturn all primes\
    \ p < n.\n    >>> getPrimes(50)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47]\n    >>> getPrimes(5)\n    [2, 3]\n*/\nlong[] getPrimes(long\
    \ n) \n{\n    long[] primes = {2};\n    long start = 3;\n    while (start < n)\
    \ \n    {\n        bool is_prime = true;\n        foreach (p; primes) \n     \
    \   {\n            if (p * p > start) \n            {\n                break;\n\
    \            }\n            if (start % p == 0) \n            {\n            \
    \    is_prime = false;\n                break;\n            }\n        }\n   \
    \     if (is_prime) \n        {\n            primes ~= start;\n        }\n   \
    \     start += 2;\n    }\n    return primes;\n}", "{\n    long res = 1;\n    long\
    \ x = n % p;\n    while (n > 0) {\n        if (n & 1)\n            res = (res\
    \ * x) % p;\n        x = (x * x) % p;\n        n >>= 1;\n    }\n    return res;\n\
    }", "{\n    if (n == 0) \n    {\n        return 1;\n    } \n    else if (n % 2\
    \ == 0) \n    {\n        return modp(n / 2, p) * modp(n / 2, p) % p;\n    } \n\
    \    else \n    {\n        return modp(n - 1, p) * modp(n, p) % p;\n    }\n}",
  "{\n  if (n == 0) \n    return 1;\n  else if (n == 1) \n    return n % p;\n  else\
    \ if (n % 2 == 0) \n    return (modp(n/2, p) * modp(n/2, p)) % p;\n  else \n \
    \   return (modp(n/2, p) * modp(n/2, p) * n) % p;\n}", "{\n    if (n == 0) \n\
    \        return 1;\n    long r;\n    if (n % 2 == 0) \n    {\n        r = modp(n\
    \ / 2, p);\n        r = r * r % p;\n    } \n    else \n    {\n        r = n %\
    \ p;\n        r = r * modp(n - 1, p) % p;\n    }\n    if (r < 0) \n        r +=\
    \ p;\n    return r;\n}", "{\n    long result;\n    result = 1;\n    if (n == 0)\
    \ {\n        return 1;\n    }\n    while (n) {\n        if (n & 1) {\n       \
    \     result = (result * n) % p;\n        }\n        n >>= 1;\n        n %= p;\n\
    \    }\n    return result;\n}", "{\n    if (n == 0)\n    {\n        return 1;\n\
    \    }\n    long c = modp(n >> 1, p);\n    c = (c * c) % p;\n    if (n & 1)\n\
    \    {\n        c = (c * 2) % p;\n    }\n    return c;\n}", "{ \n  assert(p >\
    \ 0);\n  int res = 1;\n  assert(n >= 0);\n  while (n > 0) \n  {\n    if (n & 1)\
    \ \n      res = (res * 2) % p;\n    n >>= 1;\n  }\n  return res;\n}", "{\n\tlong\
    \ result = 1;\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tresult = (result * 2)\
    \ % p;\n\t}\n\treturn result;\n}", "{\n    long result = 1;\n    while (n > 0)\
    \ \n    {\n        // If the rightmost bit is 1, add 2^i mod p to the result.\n\
    \        if ((n & 1) == 1) \n        {\n            result = (result * n) % p;\n\
    \        }\n        // Double i and n, removing the rightmost bit from n.\n  \
    \      n = n >> 1;\n        n = (n * n) % p;\n    }\n    return result;\n}\n/*\n\
    Compute the Jacobi symbol (a/b)\n    The Jacobi symbol is a generalization of\
    \ the Legendre symbol. It is\n    defined for all integers a and b, with b odd.",
  "{\n    uint mask = 1;\n    long result = 1;\n    while (mask != 0) {\n        if\
    \ ((n & mask) != 0)\n            result = (result * mask) % p;\n        mask <<=\
    \ 1;\n    }\n    return result;\n}", "{\n\tif (n == 0) return 1;\n\telse if (n\
    \ % 2 == 0) \n\t{\n\t\tlong z = modp(n / 2, p);\n\t\treturn z * z % p;\n\t}\n\t\
    else return (2 * modp(n - 1, p)) % p;\n}\n//int[] divisors(int x) \n//{\n//\t\
    int[] v = [];\n//\tfor (int i = 1; i <= x; i++) if (x % i == 0) v ~= i;\n//\t\
    return v;\n//}", "{\n\tif (p == 1) return 0;\n\tlong res = 1;\n\twhile (n) {\n\
    \t\tif (n & 1) {\n\t\t\tres = (res * n) % p;\n\t\t}\n\t\tn = n >> 1;\n\t\tn =\
    \ (n * n) % p;\n\t}\n\treturn res;\n}", "{\n    long[2] u = [1,0];\n    long[2]\
    \ v = [0,1];\n    auto a = (long[2])[p,n];\n    auto b = (long[2])[0,0];\n   \
    \ long q;\n    while (a[1] != 0) \n    {\n        q = a[0] / a[1];\n        b\
    \ = [a[0] - q * a[1], a[1]];\n        u = [u[0] - q * v[0], u[1] - q * v[1]];\n\
    \        a = b;\n    }\n    if (u[0] < 0)\n        u[0] += p;\n    return u[0];\n\
    }", "{\n    if (n == 0) \n        return 1;\n    long tmp = modp(n/2, p);\n  \
    \  if (n % 2 == 0)\n        return (tmp * tmp) % p;\n    else\n        return\
    \ (tmp * tmp * n) % p;\n}", "{\n    long c = 1;\n    for (int i = 0; i < n; i++)\n\
    \    {\n        c = (c * 2) % p;\n    }\n    return c;\n}", "{\n    if (n == 0)\
    \ return 1;\n    long x = modp(n >> 1, p);\n    x = (x * x) % p;\n    if (n &\
    \ 1)\n        x = (x * 2) % p;\n    return x;\n}\n/*\nGet the matrix of powers.\n\
    \    >>> modm(3, 5)\n    [[0, 1, 2, 3, 4],\n     [1, 1, 2, 3, 4],\n     [1, 2,\
    \ 4, 3, 1],\n     [1, 3, 1, 4, 2],\n     [1, 4, 3, 1, 3]]\n*/\nlong[][] modm(long\
    \ n, long p) \n{\n    auto s = cast(long) max(p, n);\n    long[][] a = new long[][](s,\
    \ s);\n    for (int i = 0; i < s; i++) \n    {\n        for (int j = 0; j < s;\
    \ j++) \n        {\n            a[i][j] = modp(i * j, p);\n        }\n    }\n\
    \    return a;\n}\n/*\nSolve the matrix equation a_0x_0 + a_1x_1 + ... + a_{n-1}x_{n-1}\
    \ = b mod p.\n    >>> solve((0, 1, 2, 3, 4), 3, 5)\n    [0, 1, 2, 3, 4]\n    >>>\
    \ solve((0, 0, 1, 2, 3), 3, 5)\n    [0, 0, 1, 2, 3]\n    >>> solve((1, 2, 3, 4,\
    \ 5), 100, 101)\n    [1, 2, 3, 4, 5]\n    >>> solve((1, 2, 3, 4, 5), 28, 101)\n\
    \    [1, 2, 3, 4, 5]\n    >>> solve((1, 2, 3, 4, 5), 30, 101)\n    [1, 2, 3, 4,\
    \ 5]\n    >>> solve((1, 2, 3, 4, 5), 43, 101)\n    [1, 2, 3, 4, 5]\n    >>> solve((1,\
    \ 2,", "{\n\tlong res = 1;\n\tif (n == 0) return 1;\n\twhile (n > 0) {\n\t\tif\
    \ (n & 1) res = (res * n) % p;\n\t\tn = n >> 1;\n\t\tn = (n * n) % p;\n\t}\n\t\
    return res;\n}\n/*\nFind the smallest integer that is a power of 2 and greater\
    \ than the given number.\n    >>> findnext(10)\n    16\n    >>> findnext(32)\n\
    \    32\n    >>> findnext(256)\n    256\n    >>> findnext(10000)\n    16384\n\
    \    >>> findnext(20000)\n    32768\n    >>> findnext(4)\n    4\n    >>> findnext(2)\n\
    \    2\n    >>> findnext(1)\n    2\n    >>> findnext(0)\n    1\n    >>> findnext(-1)\n\
    \    1\n    >>> findnext(-2)\n    1\n*/\nlong findnext(long n) {\n\tlong m = n;\n\
    \twhile (true) {\n\t\tif (m % 2 != 0) m++;\n\t\telse if (m % 4 == 0) m = m / 2;\n\
    \t\telse break;\n\t}\n\treturn m;\n}\n/*\nCheck if an integer is a power of 2.\n\
    \    >>> ispow2(1)\n    True\n    >>> ispow2(2)\n    True\n    >>> ispow2(4)\n\
    \    True\n    >>> ispow2(8)\n    True\n    >>> ispow2(16)\n    True\n    >>>\
    \ ispow2(0)\n    False\n    >>> ispow2(3)\n    False\n    >>> ispow2(5)\n    False\n\
    \    >>> ispow2(7)\n    False\n    >>> ispow2(9)\n    False\n    >>> ispow2(15)\n\
    \    False\n    >>> ispow2(17)\n    False\n    >>> ispow2(31)\n    False\n   \
    \ >>> ispow2(33)\n    False\n    >>> ispow2(255)\n    False\n    >>> ispow2(",
  "{\n   if (n <= 0) \n   {\n       if (n == 0) \n       {\n           return 1;\n\
    \       }\n       else\n       {\n           return n+p;\n       }\n   }\n   else\n\
    \   {\n       long w = n;\n       long z = 1;\n       while (w) \n       {\n \
    \          if (w & 1) \n           {\n               z = (z * 2) % p;\n      \
    \     }\n           w >>= 1;\n           if (w) \n           {\n             \
    \  z = (z * z) % p;\n           }\n       }\n       return z;\n   }\n}", "{ \n\
    \tlong r = 1; \n\tlong a = 2; \n\twhile (n) { \n\t\tif (n&1) \n\t\t\tr = (r*a)\
    \ % p; \n\t\ta = (a*a) % p; \n\t\tn >>= 1; \n\t} \n\treturn r; \n} \n/*\nEuclidean\
    \ algorithm for integers a and b.\n    >>> gcd(10, 15)\n    5\n    >>> gcd(3,\
    \ 7)\n    1\n*/\nlong gcd(long a, long b) \n{ \n\twhile (b) { \n\t\tlong t = b;\
    \ \n\t\tb = a % b; \n\t\ta = t; \n\t} \n\treturn a; \n} \n/*\nLinear congruential\
    \ generator.\n    >>> lcg(0, 1, 4, 8)\n    2\n    >>> lcg(4, 1, 4, 8)\n    0\n\
    \    >>> lcg(0, 2, 4, 8)\n    2\n    >>> lcg(0, 3, 4, 8)\n    3\n    >>> lcg(0,\
    \ 4, 4, 8)\n    0\n    >>> lcg(0, 5, 4, 8)\n    4\n    >>> lcg(0, 6, 4, 8)\n \
    \   6\n    >>> lcg(0, 7, 4, 8)\n    1\n*/\nlong lcg(long seed, long a, long c,\
    \ long m) \n{ \n\treturn (a*seed + c) % m; \n} \n/*\nLinear congruential generator,\
    \ floating point version.\n    >>> lcgf(1.0, 2.0, 3.0, 4.0)\n    3.0\n    >>>\
    \ lcgf(3.0, 2.0, 3.0, 4.0)\n    1.0\n    >>> lcgf(1.0, 4.0, 3.0, 4.0)\n    3.0\n\
    \    >>> lcgf(1.0, 3.0, 3.0, 4.0"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
