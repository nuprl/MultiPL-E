name: HumanEval_0_has_close_elements
language: d
results:
- program: "import std.typecons;\nimport std.math;\n/*\n Check if in given list of\
    \ numbers, are any two numbers closer to each other than\n    given threshold.\n\
    \    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0,\
    \ 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \n*/\nbool has_close_elements(float[]\
    \ numbers, float threshold) \n{\n    bool result = false;\n    foreach(number;\
    \ numbers)\n    {\n        if(number < threshold)\n        {\n            result\
    \ = true;\n            break;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = has_close_elements;\n\n    assert(candidate([1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3) == true);\n    assert(candidate([1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05) == false);\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.95) == true);\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == false);\n\
    \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == true);\n    assert(candidate([1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 1.0) == true);\n    assert(candidate([1.1, 2.2, 3.1, 4.1,\
    \ 5.1], 0.5) == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpd3406ln_.d(29): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4284ad]\\n??:? void tmpd3406ln_.__unittest_L25_C1()\
    \ [0x427ef5]\\n??:? void tmpd3406ln_.__modtest() [0x428230]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c463]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b2f6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430489]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430938]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430415]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b2cd]\\n??:? runModuleUnitTests [0x42c239]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4288fc]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428883]\\n??:? _d_run_main [0x4287ee]\\n??:? main [0x428243]\\\
    n??:? __libc_start_main [0x1f8f7554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n Check if in given list of\
    \ numbers, are any two numbers closer to each other than\n    given threshold.\n\
    \    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0,\
    \ 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \n*/\nbool has_close_elements(float[]\
    \ numbers, float threshold) \n{\n    float min_diff = 1000000.0;\n    float diff;\n\
    \    foreach(v; numbers)\n    {\n        diff = v - numbers[0];\n        if(diff\
    \ < min_diff)\n        {\n            min_diff = diff;\n        }\n    }\n   \
    \ return min_diff < threshold;\n}\nunittest\n{\n    alias candidate = has_close_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == true);\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == false);\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95) == true);\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8) == false);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) ==\
    \ true);\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == true);\n   \
    \ assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpu2o9i17d.d(31): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428505]\\n??:? void tmpu2o9i17d.__unittest_L26_C1()\
    \ [0x427fdd]\\n??:? void tmpu2o9i17d.__modtest() [0x428288]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c52f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b3c2]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430555]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430a04]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4304e1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b399]\\n??:? runModuleUnitTests [0x42c305]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4289c8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42894f]\\n??:? _d_run_main [0x4288ba]\\n??:? main [0x42829b]\\\
    n??:? __libc_start_main [0xd28f4554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n Check if in given list of\
    \ numbers, are any two numbers closer to each other than\n    given threshold.\n\
    \    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0,\
    \ 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \n*/\nbool has_close_elements(float[]\
    \ numbers, float threshold) \n    pure nothrow nogc {\n    foreach (i, number;\
    \ numbers) {\n        foreach (j, other; numbers[i + 1 .. $]) {\n            if\
    \ (abs(number - other) < threshold)\n                return true;\n        }\n\
    \    }\n    return false;\n}\n/*\n  Calculate the length of the longest increasing\
    \ sublist in a given list of numbers.\n    >>> length_of_longest_increasing_sublist([1.0,\
    \ 2.0, 3.0])\n    3\n    >>> length_of_longest_increasing_sublist([1.0, 3.0, 2.0,\
    \ 4.0, 5.0, 0.0])\n    3\n    >>> length_of_longest_increasing_sublist([])\n \
    \   0\n*/\nsize_t length_of_longest_increasing_sublist(float[] numbers)\n    pure\
    \ nothrow nogc {\n    if (numbers.length == 0)\n        return 0;\n    size_t\
    \ longest_length = 1;\n    foreach (i, number; numbers) {\n        size_t current_length\
    \ = 1;\n        foreach (j, other; numbers[i + 1 .. $]) {\n            if (other\
    \ > number) {\n                current_length++;\n                number = other;\n\
    \            }\n        }\n        if (current_length > longest_length)\n    \
    \        longest_length = current_length;\n    }\n    return longest_length;\n\
    }\n/*\n  Representation of a 2D interval defined by a start and end point.\n*/\n\
    struct Interval {\n    float start;\n    float end;\n}\n/*\n  Check if given interval\
    \ is inside (the start and end points are both larger than)\n  given other interval.\n\
    \    >>> (1.0 .. 3.0).is_inside(0.0 .. 2.0)\n    False\n    >>> (1.0 .. 3.0).is_inside(2.0\
    \ .. 4.0)\n    True\n    >>> (1.0 .. 3.0).is_inside(1.0 .. 3.0)\n    True\n*/\n\
    unittest\n{\n    alias candidate = has_close_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == true);\n    assert(candidate([1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05) == false);\n    assert(candidate([1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95) == true);\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8)\
    \ == false);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == true);\n\
    \    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == true);\n    assert(candidate([1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5) == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp89m6lw3z.d(13): Error: semicolon expected following function\
    \ declaration\\n/tmp/tmp89m6lw3z.d(13): Error: no identifier for declarator `nogc`\\\
    n/tmp/tmp89m6lw3z.d(13): Error: declaration expected, not `{`\\n/tmp/tmp89m6lw3z.d(14):\
    \ Error: no identifier for declarator `numbers`\\n/tmp/tmp89m6lw3z.d(14): Error:\
    \ declaration expected, not `)`\\n/tmp/tmp89m6lw3z.d(15): Error: no identifier\
    \ for declarator `numbers[i + 1 .. __dollar]`\\n/tmp/tmp89m6lw3z.d(15): Error:\
    \ declaration expected, not `)`\\n/tmp/tmp89m6lw3z.d(18): Error: unrecognized\
    \ declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp89m6lw3z.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Check if in given list of\
    \ numbers, are any two numbers closer to each other than\n    given threshold.\n\
    \    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0,\
    \ 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \n*/\nbool has_close_elements(float[]\
    \ numbers, float threshold) \n{\n    float min = infinity;\n    for (uint i =\
    \ 0; i < numbers.length; i++)\n    {\n        for (uint j = i+1; j < numbers.length;\
    \ j++)\n        {\n            float abs = abs(numbers[i] - numbers[j]);\n   \
    \         if (abs < min)\n            {\n                min = abs;\n        \
    \    }\n        }\n    }\n    return min < threshold;\n}\nunittest\n{\n    alias\
    \ candidate = has_close_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.3) == true);\n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05) == false);\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == true);\n\
    \    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == false);\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == true);\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0) == true);\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5)\
    \ == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmbr5y3f3.d(14): Error: undefined identifier `infinity`, did you\
    \ mean template `isInfinity(X)(X x) if (isFloatingPoint!X)`?\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmbr5y3f3.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Check if in given list of\
    \ numbers, are any two numbers closer to each other than\n    given threshold.\n\
    \    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0,\
    \ 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \n*/\nbool has_close_elements(float[]\
    \ numbers, float threshold) \n{\n    foreach(a; numbers)\n    {\n        foreach(b;\
    \ numbers)\n        {\n            if(abs(a-b) < threshold)\n            {\n \
    \               return true;\n            }\n        }\n    }\n    return false;\n\
    }\n/*\n    Sums numbers in given range.\n    >>> sum_range(0, 1)\n    1\n    >>>\
    \ sum_range(0, 9)\n    45\n    >>> sum_range(0, 99)\n    4950\n*/\nunittest\n\
    {\n    alias candidate = has_close_elements;\n\n    assert(candidate([1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3) == true);\n    assert(candidate([1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05) == false);\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.95) == true);\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == false);\n\
    \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == true);\n    assert(candidate([1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 1.0) == true);\n    assert(candidate([1.1, 2.2, 3.1, 4.1,\
    \ 5.1], 0.5) == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpgba54hfg.d(40): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42858d]\\n??:? void tmpgba54hfg.__unittest_L35_C1()\
    \ [0x428055]\\n??:? void tmpgba54hfg.__modtest() [0x42830c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c567]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b3fa]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x43058d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430a3c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430519]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b3d1]\\n??:? runModuleUnitTests [0x42c33d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4289dc]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428963]\\n??:? _d_run_main [0x4288ce]\\n??:? main [0x42831f]\\\
    n??:? __libc_start_main [0x37844554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n Check if in given list of\
    \ numbers, are any two numbers closer to each other than\n    given threshold.\n\
    \    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0,\
    \ 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \n*/\nbool has_close_elements(float[]\
    \ numbers, float threshold) \n{\n\tint n = numbers.length;\n\tforeach(int i; 0..n)\
    \ \n\t{\n\t\tforeach(int j; (i+1)..n) \n\t\t{\n\t\t\tif(abs(numbers[i] - numbers[j])\
    \ < threshold) \n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ false;\n}\nunittest\n{\n    alias candidate = has_close_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == true);\n    assert(candidate([1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05) == false);\n    assert(candidate([1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95) == true);\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8)\
    \ == false);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == true);\n\
    \    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == true);\n    assert(candidate([1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5) == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplt2y19_9.d(14): Error: cannot implicitly convert expression `numbers.length`\
    \ of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmplt2y19_9.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Check if in given list of\
    \ numbers, are any two numbers closer to each other than\n    given threshold.\n\
    \    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0,\
    \ 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \n*/\nbool has_close_elements(float[]\
    \ numbers, float threshold) \n{\n    immutable size = numbers.length;\n    if\
    \ (size < 2)\n        return false;\n    float distance = abs(numbers[0] - numbers[1]);\n\
    \    auto result = distance < threshold;\n    for (size_t i = 0; i < size - 1;\
    \ i++)\n    {\n        for (size_t j = i + 1; j < size; j++)\n        {\n    \
    \        float d = abs(numbers[i] - numbers[j]);\n            if (d < distance)\n\
    \                distance = d;\n            if (distance < threshold)\n      \
    \          return true;\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = has_close_elements;\n\n    assert(candidate([1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3) == true);\n    assert(candidate([1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05) == false);\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.95) == true);\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == false);\n\
    \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == true);\n    assert(candidate([1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 1.0) == true);\n    assert(candidate([1.1, 2.2, 3.1, 4.1,\
    \ 5.1], 0.5) == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n Check if in given list of\
    \ numbers, are any two numbers closer to each other than\n    given threshold.\n\
    \    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0,\
    \ 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \n*/\nbool has_close_elements(float[]\
    \ numbers, float threshold) \n{\n\tint j = 0;\n\tforeach(numbers; number)\n\t\
    {\n\t\tfor(int i = 0; i < j; i++)\n\t\t{\n\t\t\tif(abs(numbers[i] - number) <\
    \ threshold)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tj++;\n\t}\n\t\
    return false;\n}\n/*\n    Check if in given list of numbers, are any two numbers\
    \ closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0,\
    \ 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0,\
    \ 5.0, 2.0], 0.3)\n    True\n    \n*/\nunittest\n{\n    alias candidate = has_close_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == true);\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == false);\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95) == true);\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8) == false);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) ==\
    \ true);\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == true);\n   \
    \ assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbuktfswf.d(15): Error: undefined identifier `number`, did you\
    \ mean variable `numbers`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpbuktfswf.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Check if in given list of\
    \ numbers, are any two numbers closer to each other than\n    given threshold.\n\
    \    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0,\
    \ 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \n*/\nbool has_close_elements(float[]\
    \ numbers, float threshold) \n{\n    float[] distances;\n    foreach(i, n; numbers)\
    \ \n    {\n        distances ~= abs(numbers[i] - numbers[i+1]);\n    }\n    return\
    \ min(distances) < threshold;\n}\nunittest\n{\n    alias candidate = has_close_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == true);\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == false);\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95) == true);\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8) == false);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) ==\
    \ true);\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == true);\n   \
    \ assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbb33os5t.d(19): Error: undefined identifier `min`, did you mean\
    \ function `main`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbb33os5t.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Check if in given list of\
    \ numbers, are any two numbers closer to each other than\n    given threshold.\n\
    \    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0,\
    \ 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \n*/\nbool has_close_elements(float[]\
    \ numbers, float threshold) \n{\n    foreach(i, e1; numbers)\n    {\n        foreach(j,\
    \ e2; numbers)\n        {\n            if(j > i)\n            {\n            \
    \    if(abs(e1 - e2) < threshold)\n                {\n                    return\
    \ true;\n                }\n            }\n        }\n    }\n    return false;\n\
    }\n \n \n/*\n Check if in given list of numbers, are any two numbers closer to\
    \ each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0,\
    \ 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n    True\n    \n*/\nunittest\n{\n    alias candidate = has_close_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == true);\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == false);\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95) == true);\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8) == false);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) ==\
    \ true);\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == true);\n   \
    \ assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n Check if in given list of\
    \ numbers, are any two numbers closer to each other than\n    given threshold.\n\
    \    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0,\
    \ 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \n*/\nbool has_close_elements(float[]\
    \ numbers, float threshold) \n{\n    foreach(i, a; numbers)\n    {\n        foreach(j,\
    \ b; numbers)\n        {\n            if (i >= j)\n                continue;\n\
    \            if (abs(a - b) < threshold)\n                return true;\n     \
    \   }\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = has_close_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == true);\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == false);\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95) == true);\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8) == false);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) ==\
    \ true);\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == true);\n   \
    \ assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n Check if in given list of\
    \ numbers, are any two numbers closer to each other than\n    given threshold.\n\
    \    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0,\
    \ 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \n*/\nbool has_close_elements(float[]\
    \ numbers, float threshold) \nin\n{\n    assert(all!(elem => elem >= 0.0, numbers));\n\
    \    assert(threshold >= 0.0);\n}\nbody\n{\n    bool are_close;\n    foreach(index,\
    \ number; numbers)\n    {\n        foreach(index2, number2; numbers)\n       \
    \ {\n            if(index != index2)\n            {\n                are_close\
    \ = abs(number - number2) < threshold;\n                if(are_close)\n      \
    \          {\n                    return true;\n                }\n          \
    \  }\n        }\n    }\n    return false;\n}\nunittest\n{\n    alias candidate\
    \ = has_close_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.3) == true);\n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) ==\
    \ false);\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == true);\n \
    \   assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == false);\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == true);\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0) == true);\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5)\
    \ == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplnrc8n13.d(15): Error: template instance `all!((elem) => elem\
    \ >= 0.00000, numbers)` template `all` is not defined\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmplnrc8n13.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Check if in given list of\
    \ numbers, are any two numbers closer to each other than\n    given threshold.\n\
    \    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0,\
    \ 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \n*/\nbool has_close_elements(float[]\
    \ numbers, float threshold) \n    if (numbers.length < 2) return false;\n    for\
    \ (size_t i = 0; i < numbers.length; i++)\n    {\n        for (size_t j = i +\
    \ 1; j < numbers.length; j++)\n        {\n            if (abs(numbers[i] - numbers[j])\
    \ < threshold)\n                return true;\n        }\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = has_close_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == true);\n    assert(candidate([1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05) == false);\n    assert(candidate([1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95) == true);\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8)\
    \ == false);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == true);\n\
    \    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == true);\n    assert(candidate([1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5) == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfag7e008.d(13): Error: cannot use function constraints for non-template\
    \ functions. Use `static if` instead\\n/tmp/tmpfag7e008.d(13): Error: declaration\
    \ expected, not `if`\\n/tmp/tmpfag7e008.d(14): Error: declaration expected, not\
    \ `for`\\n/tmp/tmpfag7e008.d(14): Error: no identifier for declarator `i`\\n/tmp/tmpfag7e008.d(14):\
    \ Error: declaration expected, not `<`\\n/tmp/tmpfag7e008.d(14): Error: no identifier\
    \ for declarator `i`\\n/tmp/tmpfag7e008.d(14): Error: declaration expected, not\
    \ `++`\\n/tmp/tmpfag7e008.d(16): Error: no identifier for declarator `j`\\n/tmp/tmpfag7e008.d(16):\
    \ Error: declaration expected, not `<`\\n/tmp/tmpfag7e008.d(16): Error: no identifier\
    \ for declarator `j`\\n/tmp/tmpfag7e008.d(16): Error: declaration expected, not\
    \ `++`\\n/tmp/tmpfag7e008.d(20): Error: unrecognized declaration\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfag7e008.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Check if in given list of\
    \ numbers, are any two numbers closer to each other than\n    given threshold.\n\
    \    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0,\
    \ 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \n*/\nbool has_close_elements(float[]\
    \ numbers, float threshold) \n{\n  int n = numbers.length;\n  for (int i = 0;\
    \ i < n; i++) \n  {\n    for (int j = i + 1; j < n; j++) \n    {\n      if (abs(numbers[i]\
    \ - numbers[j]) < threshold) \n      {\n        return true;\n      }\n    }\n\
    \  }\n  return false;\n}\nunittest\n{\n    alias candidate = has_close_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == true);\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == false);\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95) == true);\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8) == false);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) ==\
    \ true);\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == true);\n   \
    \ assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpx9rs79my.d(14): Error: cannot implicitly convert expression `numbers.length`\
    \ of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpx9rs79my.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Check if in given list of\
    \ numbers, are any two numbers closer to each other than\n    given threshold.\n\
    \    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0,\
    \ 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \n*/\nbool has_close_elements(float[]\
    \ numbers, float threshold) \n{\n    /*\n     + Check if there are less than 2\
    \ elements\n     + Sort the list\n     + Iterate over elements and check if difference\
    \ of \n       element with next is less than threshold.\n    */\n    numbers.sort;\n\
    \    auto it = numbers.next;\n    while(it != numbers.length)\n    {\n       \
    \ float diff = abs(numbers[it]-numbers[it+1]);\n        if(diff < threshold)\n\
    \            return true;\n        it++;\n    }\n    return false;\n}\nunittest\n\
    {\n    alias candidate = has_close_elements;\n\n    assert(candidate([1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3) == true);\n    assert(candidate([1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05) == false);\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.95) == true);\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == false);\n\
    \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == true);\n    assert(candidate([1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 1.0) == true);\n    assert(candidate([1.1, 2.2, 3.1, 4.1,\
    \ 5.1], 0.5) == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpircfiazq.d(20): Error: no property `sort` for type `float[]`\\\
    n/tmp/tmpircfiazq.d(21): Error: no property `next` for type `float[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpircfiazq.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Check if in given list of\
    \ numbers, are any two numbers closer to each other than\n    given threshold.\n\
    \    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0,\
    \ 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \n*/\nbool has_close_elements(float[]\
    \ numbers, float threshold) \n{\n    bool has_close_elems = false;\n    foreach(i;\
    \ 0 .. numbers.length) \n    {\n        foreach(j; i+1 .. numbers.length) \n \
    \       {\n            if (abs(numbers[i] - numbers[j]) < threshold) \n      \
    \      {\n                has_close_elems = true;\n            }\n        }\n\
    \    }\n    return has_close_elems;\n}\n/*\n Check if in given list of numbers,\
    \ are any two numbers closer to each other than\n    given threshold.\n    >>>\
    \ has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0,\
    \ 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \n*/\nunittest\n{\n    alias candidate\
    \ = has_close_elements;\n\n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.3) == true);\n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) ==\
    \ false);\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == true);\n \
    \   assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == false);\n    assert(candidate([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == true);\n    assert(candidate([1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0) == true);\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5)\
    \ == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n Check if in given list of\
    \ numbers, are any two numbers closer to each other than\n    given threshold.\n\
    \    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0,\
    \ 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \n*/\nbool has_close_elements(float[]\
    \ numbers, float threshold) \n{\n    float[] sorted_numbers = sort(numbers);\n\
    unittest\n{\n    alias candidate = has_close_elements;\n\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == true);\n    assert(candidate([1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05) == false);\n    assert(candidate([1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95) == true);\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8)\
    \ == false);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == true);\n\
    \    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == true);\n    assert(candidate([1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5) == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_5bol1l5.d(15): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_5bol1l5.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Check if in given list of\
    \ numbers, are any two numbers closer to each other than\n    given threshold.\n\
    \    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0,\
    \ 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \n*/\nbool has_close_elements(float[]\
    \ numbers, float threshold) \n{\n    bool flag = false;\n    float min = 0.0;\n\
    \    float max = 0.0;\n    int min_index = 0;\n    int max_index = 0;\n    foreach(immutable\
    \ index, immutable number; numbers) \n    {\n        if(number < min) \n     \
    \   {\n            min = number;\n            min_index = index;\n        }\n\
    \        if(number > max) \n        {\n            max = number;\n           \
    \ max_index = index;\n        }\n    }\n    foreach(immutable index, immutable\
    \ number; numbers) \n    {\n        if(index == min_index || index == max_index)\
    \ \n        {\n            continue;\n        }\n        if(abs(number - min)\
    \ < threshold || abs(number - max) < threshold) \n        {\n            flag\
    \ = true;\n            break;\n        }\n    }\n    return flag;\n}\nunittest\n\
    {\n    alias candidate = has_close_elements;\n\n    assert(candidate([1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3) == true);\n    assert(candidate([1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05) == false);\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.95) == true);\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == false);\n\
    \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == true);\n    assert(candidate([1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 1.0) == true);\n    assert(candidate([1.1, 2.2, 3.1, 4.1,\
    \ 5.1], 0.5) == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpn68s314v.d(24): Error: cannot implicitly convert expression `index`\
    \ of type `immutable(ulong)` to `int`\\n/tmp/tmpn68s314v.d(29): Error: cannot\
    \ implicitly convert expression `index` of type `immutable(ulong)` to `int`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn68s314v.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Check if in given list of\
    \ numbers, are any two numbers closer to each other than\n    given threshold.\n\
    \    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0,\
    \ 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \n*/\nbool has_close_elements(float[]\
    \ numbers, float threshold) \n{\n    bool has_close_elements = false;\n    foreach(n1;\
    \ numbers)\n    {\n        foreach(n2; numbers)\n        {\n            if (n1\
    \ != n2)\n            {\n                has_close_elements = abs(n1 - n2) < threshold;\n\
    \                if (has_close_elements)\n                    break;\n       \
    \     }\n        }\n        if (has_close_elements)\n            break;\n    }\n\
    \    return has_close_elements;\n}\nunittest\n{\n    alias candidate = has_close_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == true);\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == false);\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95) == true);\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8) == false);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) ==\
    \ true);\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == true);\n   \
    \ assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpur1vsg94.d(39): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4285ad]\\n??:? void tmpur1vsg94.__unittest_L31_C1()\
    \ [0x42820b]\\n??:? void tmpur1vsg94.__modtest() [0x42832c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c587]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b41a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4305ad]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430a5c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430539]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b3f1]\\n??:? runModuleUnitTests [0x42c35d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4289fc]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428983]\\n??:? _d_run_main [0x4288ee]\\n??:? main [0x42833f]\\\
    n??:? __libc_start_main [0xa4e9c554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n Check if in given list of\
    \ numbers, are any two numbers closer to each other than\n    given threshold.\n\
    \    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0,\
    \ 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \n*/\nbool has_close_elements(float[]\
    \ numbers, float threshold) \n{\n\tfor (uint i = 0; i < numbers.length; i++)\n\
    \t{\n\t\tfor (uint j = i + 1; j < numbers.length; j++)\n\t\t{\n\t\t\tif (abs(numbers[i]\
    \ - numbers[j]) < threshold)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\
    }\n\treturn false;\n}\n/*\nYou have a list of words. Return a dictionary that\
    \ contains, for each word, \n    list of words from the given list that are anagrams\
    \ of the word.\n    Anagrams are words made by using exactly the same letters\
    \ in exactly the \n    same quantity, e.g. orchestra and carthorse.\n    >>> get_anagrams([\"\
    orchestra\", \"carthorse\", \"radishes\"])\n    {\"orchestra\": [\"carthorse\"\
    ], \"carthorse\": [\"orchestra\"], \"radishes\": []}\n*/\nMap!(string, string[])\
    \ get_anagrams(string[] words) \n{\n\tMap!(string, string[]) result = new Map!(string,\
    \ string[]);\n\tfor (uint i = 0; i < words.length; i++)\n\t{\n\t\tstring[] anagrams\
    \ = new string[];\n\t\tfor (uint j = 0; j < words.length; j++)\n\t\t{\n\t\t\t\
    if (i != j && words[i].length == words[j].length)\n\t\t\t{\n\t\t\t\tuint[] word1count\
    \ = new uint[256];\n\t\t\t\tuint[] word2count = new uint[256];\n\t\t\t\tforeach\
    \ (uint c; words[i])\n\t\t\t\t{\n\t\t\t\t\tword1count[c]++;\n\t\t\t\t}\n\t\t\t\
    \tforeach (uint c; words[j])\n\t\t\t\t{\n\t\t\t\t\tword2count[c]++;\n\t\t\t\t\
    }\n\t\t\t\tif (word1count == word2count)\n\t\t\t\t{\n\t\t\t\t\tanagrams ~= words[j];\n\
    \t\t\t\t}\n\t\t\t}\n\t\t\nunittest\n{\n    alias candidate = has_close_elements;\n\
    \n    assert(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == true);\n    assert(candidate([1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == false);\n    assert(candidate([1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95) == true);\n    assert(candidate([1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8) == false);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) ==\
    \ true);\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == true);\n   \
    \ assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptfym9dg9.d(60): Error: found `unittest` instead of statement\\\
    n/tmp/tmptfym9dg9.d(72): Error: found `End of File` when expecting `}` following\
    \ compound statement\\n/tmp/tmptfym9dg9.d(72): Error: found `End of File` when\
    \ expecting `}` following compound statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmptfym9dg9.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
