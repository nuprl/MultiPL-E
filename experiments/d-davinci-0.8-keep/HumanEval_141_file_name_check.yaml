name: HumanEval_141_file_name_check
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes\
  \ a string representing a file's name, and returns\n    'Yes' if the the file's\
  \ name is valid, and returns 'No' otherwise.\n    A file's name is considered to\
  \ be valid if and only if all the following conditions \n    are met:\n    - There\
  \ should not be more than three digits ('0'-'9') in the file's name.\n    - The\
  \ file's name contains exactly one dot '.'\n    - The substring before the dot should\
  \ not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z'\
  \ and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt',\
  \ 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\") # => 'Yes'\n\
  \    file_name_check(\"1example.dll\") # => 'No' (the name should start with a latin\
  \ alphapet letter)\n    \n*/\nstring file_name_check(string file_name) \n"
tests: "unittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"\
  example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n\
  \    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\"\
  ) == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"\
  His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n \
  \   assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\"\
  ) == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"\
  this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\"\
  ) == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n   \
  \ assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"\
  this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\")\
  \ == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"\
  Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"\
  Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"\
  I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n\
  \    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\"\
  ) == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"\
  s.\") == \"No\");\n}\nvoid main(){}"
completions: ["{\n    size_t dot_pos = file_name.find(\".\");\n    if (dot_pos ==\
    \ size_t.max) return \"No\";\n    string name = file_name[0..dot_pos];\n    string\
    \ ex = file_name[dot_pos+1..$];\n    return \"No\";\n}", "{\n    auto is_a_letter\
    \ = (c) =>\n    {\n        import std.utf;\n        // check if its a lower case\
    \ letter\n        return (c >= 'a' && c <= 'z') ||\n        // check if its an\
    \ upper case letter\n        (c >= 'A' && c <= 'Z');\n    };\n    auto is_a_digit\
    \ = (c) =>\n    {\n        import std.utf;\n        return c >= '0' && c <= '9';\n\
    \    };\n    auto is_file_extention = (ext) =>\n    {\n        return ext == \"\
    txt\" || ext == \"exe\" || ext == \"dll\";\n    };\n    auto valid_file_name =\
    \ (file_name) =>\n    {\n        auto file_extention = file_name.split(\".\").back;\n\
    \        auto file_name_without_extention = file_name.split(\".\").front;\n  \
    \      auto contains_no_more_than_three_digits = file_name_without_extention.filter!(a\
    \ => is_a_digit(a)).length <= 3;\n        auto contains_exactly_one_dot = file_name.count(\"\
    .\") == 1;\n        auto contains_valid_file_extention = is_file_extention(file_extention);\n\
    \        auto contains_valid_name = !file_name_without_extention.empty && is_a_letter(file_name_without_extention[0]);\n\
    \        return contains_no_more_than_three_digits && contains_exactly_one_dot\
    \ && contains_valid_file_extention && contains_valid_name;\n    };\n    return\
    \ valid_file_name(file_name) ? \"Yes\" : \"No\";\n}", "{\n    enum valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    auto tmp = split(file_name, \".\");\n  \
    \  if (count(file_name, \".\") != 1 || tmp.length != 2) \n        return \"No\"\
    ;\n    auto name = tmp[0];\n    auto extension = tmp[1];\n    if (name.length\
    \ == 0 || (extension.length != 3 && extension.length != 4)) \n        return \"\
    No\";\n    foreach (i,c; name)\n    {\n        if (isdigit(c)) \n            i++;\n\
    \        if (i > 3) \n            return \"No\";\n    }\n    return (isalpha(name[0])\
    \ && valid_extensions.canFind(extension)) ? \"Yes\" : \"No\";\n}\n/*\n    There\
    \ is a list of all the ASCII characters, with their numbers from 0 to 255.\n \
    \   Your function should take this list as an input, and return the sum of ASCII\n\
    \    character codes of all the characters which are of odd index in the given\
    \ list.\n    Examples:\n    ascii_sum([97, 116, 116, 114, 105, 98, 117, 116, 101])\
    \ # => 1151\n    ascii_sum([100, 100, 116, 58, 98, 98, 98, 98, 98, 98, 98, 98,\
    \ 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98,\
    \ 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98,\
    \ 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98,\
    \ 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98,\
    \ 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98,\
    \ 98, 98, 98, 98", "{\n    auto file_name_split = split(file_name, \".\");\n \
    \   return is(file_name_split[0].count!(a => a.isdigit) <= 3 \n          && file_name_split.length\
    \ == 2 \n          && file_name_split[0].length > 0 \n          && isLetter(file_name_split[0][0])\
    \ \n          && file_name_split[1] in [\"txt\", \"exe\", \"dll\"]) ? \"Yes\"\
    \ : \"No\";\n}", "{\n    auto dot = file_name.indexOf('.');\n    if (dot == -1)\
    \ return \"No\";\n    int nums = 0;\n    foreach (auto c; file_name) \n    {\n\
    \        if ('0' <= c && c <= '9') \n        {\n            ++nums;\n        \
    \    if (nums > 3) return \"No\";\n        }\n    }\n    auto s = file_name.split('.');\n\
    \    return (s[0].length != 0 && s[0][0] != '.' &&\n            (s[1] == \"txt\"\
    \ || s[1] == \"exe\" || s[1] == \"dll\")) ?\n    \"Yes\" : \"No\";\n}", "{\n \
    \   enum type_name=[\"txt\", \"exe\", \"dll\"];\n    int count = 0;\n    immutable\
    \ name = file_name.dup;\n    immutable len = name.length;\n    foreach(i;0..len)\n\
    \    {\n        if(name[i] in ['0'..'9'])\n        {\n            count++;\n \
    \       }\n    }\n    if(count>3)\n    {\n        return \"No\";\n    }\n    else\n\
    \    {\n        immutable n = name.dup;\n        immutable f = n.retro;\n    \
    \    immutable f2 = n.retro;\n        immutable n2 = name.dup;\n        immutable\
    \ temp1 = n2.retro.idup;\n        immutable temp2 = f2.idup;\n        immutable\
    \ t = temp1.split(\".\");\n        immutable t2 = temp2.split(\".\");\n      \
    \  int i = 0;\n        foreach(n2; t2)\n        {\n            if(i==0)\n    \
    \        {\n                if(!(n2 in ['A'..'Z']) && !(n2 in ['a'..'z']))\n \
    \               {\n                    return \"No\";\n                }\n   \
    \         }\n            else\n            {\n                if(!(n2 in type_name))\n\
    \                {\n                    return \"No\";\n                }\n  \
    \          }\n            i++;\n        }\n        return \"Yes\";\n    }\n}",
  "{\n    auto pos = file_name.findLastOf('.');\n    return file_name.count('.') ==\
    \ 1 && file_name[0].isLetter() &&\n            file_name[pos + 1..$].length >\
    \ 0 && \n            file_name[0..pos].count(x => x.isDigit()) <= 3 &&\n     \
    \       (file_name[pos + 1..$] == \"txt\" || file_name[pos + 1..$] == \"exe\"\
    \ || file_name[pos + 1..$] == \"dll\") ? \"Yes\" : \"No\";\n}", "{\n    string\
    \ left = \"\", right = \"\";\n    bool point_found = false;\n    for (uint i =\
    \ 0; i < file_name.length; i++)\n    {\n        if (file_name[i] == '.')\n   \
    \     {\n            point_found = true;\n            continue;\n        }\n \
    \       if (point_found)\n            right ~= file_name[i];\n        else\n \
    \           left ~= file_name[i];\n    }\n    if (!point_found)\n        return\
    \ \"No\";\n    if (right != \"txt\" && right != \"exe\" && right != \"dll\")\n\
    \        return \"No\";\n    int digits = 0;\n    foreach (c; left)\n    {\n \
    \       if ('0' <= c && c <= '9')\n            digits++;\n    }\n    if (digits\
    \ > 3)\n        return \"No\";\n    return \"Yes\";\n}", "{\n    // check for\
    \ more than 3 digits...\n    string[] nums = [\"0\", \"1\", \"2\", \"3\", \"4\"\
    , \"5\", \"6\", \"7\", \"8\", \"9\"];\n    string[] digits = filter!( a => nums.find(a)\
    \ != -1)(file_name.dup);\n    if (digits.length > 3)\n        return \"No\";\n\
    \    // check for 1 dot\n    string[] dots = filter!( a => a == \".\")(file_name.dup);\n\
    \    if (dots.length != 1)\n        return \"No\";\n    // check that there is\
    \ text before the dot\n    string[] parts = file_name.split(\".\");\n    if (parts[0].length\
    \ == 0)\n        return \"No\";\n    // check that the first character of the\
    \ text before the dot is a letter.\n    char[] letters = ['a', 'b', 'c', 'd',\
    \ 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\
    \ 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',\
    \ 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\
    \    char[] chars = parts[0].dup;\n    if (letters.find(chars[0]) == -1)\n   \
    \     return \"No\";\n    // check that there is a valid extension\n    string[]\
    \ exts = [\"txt\", \"exe\", \"dll\"];\n    if (exts.find(parts[1]) == -1)\n  \
    \      return \"No\";\n    return \"Yes\";\n}", "{\n    enum bool isValid = true;\n\
    \    bool number_test;\n    bool dot_count;\n    bool file_name_test;\n    bool\
    \ dll_test;\n    int file_name_len = file_name.length;\n    string[] dll_list\
    \ = [\"txt\", \"exe\", \"dll\"];\n    int dot_location = file_name.indexOf('.');\n\
    \    string front_substring = file_name[0..dot_location];\n    string back_substring\
    \ = file_name[dot_location+1..$];\n    int dot_number_test = front_substring.count('.');\n\
    \    int number_test_count = 0;\n    char[] front_substring_list = front_substring.dup;\n\
    \    if(back_substring in dll_list)\n    {\n        dll_test = true;\n    }\n\
    \    else\n    {\n        dll_test = false;\n    }\n    if(dot_number_test > 1)\n\
    \    {\n        dot_count = false;\n    }\n    else\n    {\n        dot_count\
    \ = true;\n    }\n    for(int i = 0; i < front_substring_list.length; i++)\n \
    \   {\n        if(front_substring_list[i] in \"0123456789\")\n        {\n    \
    \        number_test_count++;\n        }\n    }\n    if(number_test_count > 3)\n\
    \    {\n        number_test = false;\n    }\n    else\n    {\n        number_test\
    \ = true;\n    }\n    if(dot_location == 0)\n    {\n        file_name_test = false;\n\
    \    }\n    else\n    {\n        file_name_test = true;\n    }\n    isValid =\
    \ number_test && dot_count && file_name_test && dll_test;\n    if(isValid)\n \
    \   {\n        return \"Yes\";\n    }\n    else\n    {\n        return \"No\"\
    ;\n    }\n}", "{\n    int dot = file_name.indexOf('.');\n    string prefix = file_name[0..dot];\n\
    \    string suffix = file_name[dot + 1..$];\n    return file_name.filter!(c =>\
    \ c.isDigit).length > 3 ? \"No\" :\n           file_name.count('.') != 1 ? \"\
    No\" :\n           prefix.length == 0 || !prefix[0].isLetter ? \"No\" :\n    \
    \       !suffix.in(\"txt\", \"exe\", \"dll\") ? \"No\" : \"Yes\";\n}", "{\n  \
    \  /* For example, if the file_name is 'example.txt', the below three\n     *\
    \ variables will be set to respectively:\n     * example, ., txt\n     */\n  \
    \  auto [file_name_root, dot, file_name_extension] = file_name.split(\".\");\n\
    \    if (file_name_root.filter!(x => '0' <= x && x <= '9').length > 3)\n     \
    \   return \"No\";\n    if (dot != \".\")\n        return \"No\";\n    if (!(('a'\
    \ <= file_name_root[0] && file_name_root[0] <= 'z') ||\n            ('A' <= file_name_root[0]\
    \ && file_name_root[0] <= 'Z')))\n        return \"No\";\n    if (file_name_extension\
    \ !in [\"txt\", \"exe\", \"dll\"])\n        return \"No\";\n    return \"Yes\"\
    ;\n}", "{\n    enum extension = [\"txt\", \"exe\", \"dll\"];\n    bool ext_valid\
    \ = false;\n    int dot_pos = file_name.find(\".\");\n    bool dot_valid = dot_pos\
    \ != -1;\n    for (int i = 0; i < extension.length; i++)\n    {\n        if (extension[i]\
    \ == file_name[dot_pos + 1 .. $])\n        {\n            ext_valid = true;\n\
    \            break;\n        }\n    }\n    bool valid_before_dot = true;\n   \
    \ if (file_name[0 .. dot_pos].length == 0)\n    {\n        valid_before_dot =\
    \ false;\n    }\n    else\n    {\n        if (file_name[0 .. dot_pos][0] >= '0'\
    \ && file_name[0 .. dot_pos][0] <= '9')\n        {\n            valid_before_dot\
    \ = false;\n        }\n    }\n    int num_count = 0;\n    for (int i = 0; i <\
    \ file_name.length; i++)\n    {\n        if (file_name[i] >= '0' && file_name[i]\
    \ <= '9')\n        {\n            num_count++;\n        }\n    }\n    if (num_count\
    \ > 3)\n    {\n        return \"No\";\n    }\n    else\n    {\n        if (dot_valid\
    \ && ext_valid && valid_before_dot)\n        {\n            return \"Yes\";\n\
    \        }\n        else\n        {\n            return \"No\";\n        }\n \
    \   }\n}", "{\n    auto parts = split(file_name, \".\");\n    import std.string;\n\
    \    if (parts.length != 2) return \"No\";\n    if (parts[0].length == 0) return\
    \ \"No\";\n    if (parts[0].any!(c => c.isDigit)) return \"No\";\n    if (parts[0].count!(c\
    \ => c.isDigit) > 3) return \"No\";\n    if (parts[1] == \"txt\" || parts[1] ==\
    \ \"exe\" || parts[1] == \"dll\") return \"Yes\";\n    return \"No\";\n}", "{\n\
    \    string res = \"No\";\n    int n = file_name.length;\n    int cnt = 0;\n \
    \   if (n == 0) return res;\n    bool not_letter = false;\n    bool dot_found\
    \ = false;\n    int dot_pos = -1;\n    for (int i = 0; i < n; i++) {\n       \
    \ if (isalpha(file_name[i])) not_letter = true;\n        if (isdigit(file_name[i]))\
    \ cnt++;\n        if (file_name[i] == '.') {\n            dot_found = true;\n\
    \            dot_pos = i;\n        }\n    }\n    if (cnt > 3) return res;\n  \
    \  if (!dot_found) return res;\n    if (dot_pos == 0) return res;\n    if (dot_pos\
    \ == n - 1) return res;\n    string before_dot = file_name[0..dot_pos-1];\n  \
    \  string after_dot = file_name[dot_pos+1..$];\n    if (before_dot.length == 0)\
    \ return res;\n    if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot\
    \ != \"dll\") return res;\n    if (!not_letter) return res;\n    return \"Yes\"\
    ;\n}\n/*\nA palindrome number is a number which reads the same forwards and backwards.\n\
    \    Create a function which takes a number as argument, and returns 'Yes' if\
    \ the number is\n    palindrome, and returns 'No' otherwise.\n*/\nstring palindrome_check(int\
    \ n) \n{\n    if (n < 0) return \"No\";\n    string res = \"Yes\";\n    int x\
    \ = n;\n    int y = 0;\n    while (x > 0) {\n        y = 10 * y + x % 10;\n  \
    \      x /= 10;\n    }\n    if (y != n) return \"No\";\n    return res;\n}\n/*\n\
    An integer number is a prime number if it has exactly two divisors: 1 and the\
    \ number itself.\n    Create a function which takes a number as argument, and\
    \ returns 'Yes' if the number is ", "{\n    enum file_name_check(string file_name)\n\
    \    {\n        int indexOf = find(file_name, '.');\n        if (file_name[indexOf]\
    \ == '.')\n        {\n            if (file_name[indexOf-1] == 'e' &&\n       \
    \         file_name[indexOf-2] == 'x' &&\n                file_name[indexOf-3]\
    \ == 't' &&\n                file_name[indexOf-4] == '.')\n                return\
    \ \"Yes\";\n            else if (file_name[indexOf-1] == 'd' &&\n            \
    \    file_name[indexOf-2] == 'l' &&\n                file_name[indexOf-3] == 'l'\
    \ &&\n                file_name[indexOf-4] == '.')\n                return \"\
    Yes\";\n            else if (file_name[indexOf-1] == 'x' &&\n                file_name[indexOf-2]\
    \ == 'e' &&\n                file_name[indexOf-3] == 'e' &&\n                file_name[indexOf-4]\
    \ == '.')\n                return \"Yes\";\n            else\n               \
    \ return \"No\";\n        }\n        else\n            return \"No\";\n    }\n\
    }\n/*\nCreate a function which takes a string representing a file's name, and\
    \ returns\n    a string of the file's extension name.\n    Assume that all files\
    \ have at most one dot in their names.\n    Examples:\n    get_extension_name(\"\
    example.txt\") # => 'txt'\n    get_extension_name(\"CMakeLists.txt\") # => 'txt'\n\
    \    get_extension_name(\"file.txt.exe\") # => 'exe'\n    get_extension_name(\"\
    file.txt\") # => 'txt'\n*/\nstring get_extension_name(string file_name) \n{\n\
    \    enum get_extension_name(string file_name)\n    {\n        int indexOf = find(file_name,\
    \ '.');\n        return file_name[indexOf-1..$];\n    }\n}\n/*\nCreate a function\
    \ which returns true if the given string represents a valid file name,\n    and",
  "{\n    string first_name = \"\";\n    string last_name = \"\";\n    string extension\
    \ = \"\";\n    string numbers = \"0123456789\";\n    string letters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    ;\n    string extensions = \"txtexeDLL\";\n    bool has_dot = false;\n    bool\
    \ first_name_is_valid = false;\n    bool last_name_is_valid = false;\n    int\
    \ dots = 0;\n    int digits = 0;\n    int last_name_length = 0;\n    int first_name_length\
    \ = 0;\n    int extension_length = 0;\n    //string[] valid_extensions = [\"txt\"\
    , \"exe\", \"dll\"];\n    for (int i = 0; i < file_name.length; i++)\n    {\n\
    \        if (file_name[i] == '.')\n        {\n            has_dot = true;\n  \
    \          dots++;\n        }\n        else if (file_name[i] == '.')\n       \
    \ {\n            dots++;\n        }\n        else if (extensions.contains(file_name[i]))\n\
    \        {\n            last_name_is_valid = true;\n            last_name += file_name[i];\n\
    \            last_name_length++;\n        }\n        else if (numbers.contains(file_name[i]))\n\
    \        {\n            digits++;\n        }\n        else if (letters.contains(file_name[i]))\n\
    \        {\n            first_name_is_valid = true;\n            first_name +=\
    \ file_name[i];\n            first_name_length++;\n        }\n    }\n    if (last_name_length\
    \ != 0)\n    {\n        if (digits <= 3 && dots == 1 && has_dot && first_name_is_valid\
    \ && last_name_is_valid)\n        {\n            return \"Yes\";\n        }\n\
    \        else\n        {\n            return \"No\";\n        }\n    }\n    else\n\
    \    {\n        return \"No\";\n    }\n    //return \"No\";\n}\n/*\n", "{\n\t\
    string fname = file_name;\n\tint dot_pos = find(fname,\".\");\n\tstring sub_fname\
    \ = fname[0..dot_pos];\n\tstring sub_fname_1 = fname[dot_pos..$];\n\tsub_fname_1[0]\
    \ = ' ';\n\tsub_fname_1 = sub_fname_1.stripLeft();\n\tif(sub_fname[0].isLetter\
    \ && !sub_fname[1..$].isAlpha)\n\t{\n\t\tif(sub_fname_1 == \"txt\" || sub_fname_1\
    \ == \"exe\" || sub_fname_1 == \"dll\")\n\t\t{\n\t\t\treturn \"Yes\";\n\t\t}\n\
    \t\telse\n\t\t{\n\t\t\treturn \"No\";\n\t\t}\n\t}\n\telse\n\t{\n\t\treturn \"\
    No\";\n\t}\n\t\n}", "{\n    int digit = 0;\n    string sub1 = \"\";\n    string\
    \ sub2 = \"\";\n    bool flag1 = false;\n    bool flag2 = false;\n    bool flag3\
    \ = false;\n    bool flag4 = false;\n    bool flag5 = false;\n    bool flag6 =\
    \ false;\n    for(int i = 0; i < file_name.length; i++)\n    {\n        if(!flag1\
    \ && (file_name[i] < '0' || file_name[i] > '9'))\n        {\n            flag1\
    \ = true;\n            if(i != 0)\n            {\n                sub1 = file_name[0..i];\n\
    \                if(file_name[i] == '.')\n                {\n                \
    \    flag2 = true;\n                    flag3 = true;\n                }\n   \
    \         }\n        }\n        else if(flag1 && !flag2 && file_name[i] == '.')\n\
    \        {\n            flag2 = true;\n            sub2 = file_name[i+1..$];\n\
    \        }\n        else if(!flag2 && file_name[i] >= '0' && file_name[i] <= '9')\n\
    \        {\n            digit++;\n        }\n        else if(flag2 && !flag3 &&\
    \ (file_name[i] < '0' || file_name[i] > '9'))\n        {\n            flag3 =\
    \ true;\n            sub2 = file_name[i..$];\n        }\n        else if(flag3\
    \ && !flag4 && file_name[i] < 'a' && file_name[i] > 'z')\n        {\n        \
    \    return \"No\";\n        }\n        else if(flag3 && !flag4 && file_name[i]\
    \ >= 'a' && file_name[i] <= 'z')\n        {\n            flag4 = true;\n     \
    \   }\n        else if(flag3 && !flag5 && file_name[i] < 'A' && file_name[i] >\
    \ 'Z')\n        {\n            return \"No\";\n        }\n        else if(flag3\
    \ && !flag5 && file_name[i] >= 'A' && file_", "{\n    string[] sub_strings = file_name.split(\"\
    .\");\n    if (sub_strings.length == 2) \n    {\n        string[] numbers = sub_strings[0].split(\"\
    [0-9]\");\n        if ((sub_strings[1] == \"txt\" || sub_strings[1] == \"exe\"\
    \ || sub_strings[1] == \"dll\") && (sub_strings[0].length > 0) && (numbers.length\
    \ == 1))\n        {\n            return \"Yes\";\n        }\n    }\n    return\
    \ \"No\";\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
