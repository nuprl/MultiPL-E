name: HumanEval_110_exchange
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will implement\
  \ a function that takes two lists of numbers,\n    and determines whether it is\
  \ possible to perform an exchange of elements\n    between them to make lst1 a list\
  \ of only even numbers.\n    There is no limit on the number of exchanged elements\
  \ between lst1 and lst2.\n    If it is possible to exchange elements between the\
  \ lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\"\
  .\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1,\
  \ 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n   \
  \ It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
  \ lst1, long[] lst2) \n"
tests: "unittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
  \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
  \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
  \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) ==\
  \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
  \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
  \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
completions: ["{\n    int count = 0;\n    foreach(n; lst1)\n    {\n        if(n %\
    \ 2 == 1)\n        {\n            count += 1;\n        }\n    }\n    if(count\
    \ == 0)\n    {\n        return \"YES\";\n    }\n    count = 0;\n    foreach(m;\
    \ lst2)\n    {\n        if(m % 2 == 1)\n        {\n            count += 1;\n \
    \       }\n    }\n    if(count == 0)\n    {\n        return \"YES\";\n    }\n\
    \    foreach(n; lst1)\n    {\n        foreach(m; lst2)\n        {\n          \
    \  if(n % 2 == 1 && m % 2 == 1)\n            {\n                count = 0;\n \
    \               return \"YES\";\n            }\n        }\n    }\n    return \"\
    NO\";\n}", "{\n    bool isEven(long lst2){\n        return (lst2%2==0)?true:false;\n\
    \    }\n    bool isOdd(long lst1){\n        return (lst1%2==0)?false:true;\n \
    \   }\n    int i = 0;\n    while(i<lst1.length){\n        if(isEven(lst1[i])){\n\
    \            i++;\n        }else{\n            bool found=false;\n           \
    \ for(int k=0;k<lst2.length;k++){\n                if(isOdd(lst2[k])){\n     \
    \               int temp = lst1[i];\n                    lst1[i] = lst2[k];\n\
    \                    lst2[k] = temp;\n                    found=true;\n      \
    \              break;\n                }\n            }\n            if(!found){\n\
    \                return \"NO\";\n            }\n        }\n    }\n    return \"\
    YES\";\n}", "{\n    int i, n1, n2;\n    n1 = lst1.length;\n    n2 = lst2.length;\n\
    \    long tmp;\n    bool found = false;\n    for (i = 0; i < n1; i++)\n    {\n\
    \        if (lst1[i] % 2 == 1)\n        {\n            int j;\n            for\
    \ (j = 0; j < n2; j++)\n            {\n                if (lst2[j] % 2 == 1)\n\
    \                {\n                    continue;\n                }\n       \
    \         else\n                {\n                    found = true;\n       \
    \             tmp = lst1[i];\n                    lst1[i] = lst2[j];\n       \
    \             lst2[j] = tmp;\n                    break;\n                }\n\
    \            }\n            if (!found)\n            {\n                return\
    \ \"NO\";\n            }\n        }\n    }\n    return \"YES\";\n}", "{\n    int\
    \ sum = 0;\n    foreach(num; lst1) \n    {\n        if(num%2==1)\n           \
    \ sum++;\n    }\n    foreach(num; lst2) \n    {\n        if(num%2==0)\n      \
    \      sum--;\n    }\n    if(sum==0)\n        return \"YES\";\n    else\n    \
    \    return \"NO\";\n}", "{\n    return lst1.all!(x => x % 2 == 0) || lst2.all!(x\
    \ => x % 2 == 0) ? \"YES\" : \"NO\";\n}", "{\n\tconst bool isEven(long x) \n\t\
    {\n\t\treturn x % 2 == 0;\n\t}\n\tbool areAllEven(T)(T[] arr) \n\t{\n\t\treturn\
    \ arr.all!isEven;\n\t}\n\tbool areAllEven1(long[] arr) \n\t{\n\t\treturn areAllEven(arr);\n\
    \t}\n\tbool areAllEven2(long[] arr) \n\t{\n\t\treturn arr.all!isEven;\n\t}\n\t\
    \n\tbool areAllEven3(long[] arr) \n\t{\n\t\treturn arr.all!(a => a % 2 == 0);\n\
    \t}\n\t\n\tbool areAllEven4(long[] arr) \n\t{\n\t\treturn arr.all!isEven;\n\t\
    }\n\t\n\tTuple!(long[], long[]) swapEven(T)(T[] arr1, T[] arr2) \n\t{\n\t\tlong\
    \ arr2EvenIndex = arr2.findIndex!isEven;\n\t\tlong arr1OddIndex = arr1.findIndex!(x\
    \ => !isEven(x));\n\t\tT[] tmp = arr1[];\n\t\t\n\t\tarr1[] = arr2[arr2EvenIndex..arr2EvenIndex];\n\
    \t\tarr2[] = tmp[arr1OddIndex..arr1OddIndex];\n\t\t\n\t\treturn tuple(arr1, arr2);\n\
    \t}\n\t\n\treturn areAllEven(lst1) ? \"YES\" : (areAllEven(lst2) ? \"YES\" : \"\
    NO\");\n}", "{\n    string ret = \"YES\";\n    int size = lst1.length;\n    foreach(int\
    \ a, lst1)\n    {\n        if(a % 2 != 0)\n        {\n            int found =\
    \ 0;\n            foreach(int b, lst2)\n            {\n                if(b %\
    \ 2 != 0)\n                {\n                    found = 1;\n               \
    \     break;\n                }\n            }\n            if(found == 0)\n \
    \           {\n                ret = \"NO\";\n                break;\n       \
    \     }\n        }\n    }\n    return ret;\n}", "{\n    auto even = (int n) {\
    \ return n % 2 == 0; };\n    bool found = false;\n    auto isEven = () {\n   \
    \   foreach(el; lst1) {\n        if (!even(el)) {\n          return false;\n \
    \       }\n      }\n      return true;\n    };\n    auto swap = (int pos) {\n\
    \      auto temp = lst1[pos];\n      lst1[pos] = lst2[pos];\n      lst2[pos] =\
    \ temp;\n    };\n    foreach(i, el; lst1) {\n      if (!even(el)) {\n        foreach(j,\
    \ el2; lst2) {\n          if (even(el2)) {\n            found = true;\n      \
    \      swap(i);\n            if (isEven()) {\n              return \"YES\";\n\
    \            }\n            swap(i);\n          }\n        }\n      }\n    }\n\
    \    if (!found) {\n      return \"YES\";\n    }\n    return \"NO\";\n}", "{\n\
    \    //We will use two ranges one for each list\n    auto rng1 = lst1.chunks(2);\n\
    \    auto rng2 = lst2.chunks(2);\n    //We will check if there is a common element\
    \ between both ranges\n    foreach(i,j; zip(rng1,rng2))\n    {\n        //We will\
    \ go through each chunk of rng1\n        foreach(n; i)\n        {\n          \
    \  //We will check if n is equal to any of the elements of the chunk j \n    \
    \        foreach(m; j)\n            {\n                if(n == m)\n          \
    \      {\n                    return \"YES\";\n                }\n           \
    \ }\n        }\n    }\n    return \"NO\";\n}", "{\n    auto odd1 = lst1.filter!(a\
    \ => a % 2 != 0);\n    auto odd2 = lst2.filter!(a => a % 2 != 0);\n    return\
    \ (odd1.length - odd2.length) % 2 == 0 ? \"YES\" : \"NO\";\n}", "{\n    string\
    \ canExchange = \"NO\";\n    long evenCount = 0;\n    foreach(n; lst1)\n    {\n\
    \        if (n % 2 == 0)\n        {\n            evenCount++;\n        }\n   \
    \ }\n    foreach(m; lst2)\n    {\n        if (m % 2 == 0)\n        {\n       \
    \     evenCount--;\n        }\n    }\n    if (evenCount == 0)\n    {\n       \
    \ canExchange = \"YES\";\n    }\n    return canExchange;\n}", "{\n    int sum1\
    \ = lst1.sum();\n    int sum2 = lst2.sum();\n    if(sum1 % 2 == 0) return \"YES\"\
    ;\n    else if(sum2 % 2 == 0) return \"YES\";\n    else return \"NO\";\n}", "{\n\
    \    auto n = lst1.length;\n    auto m = lst2.length;\n    auto hist = new int[m];\n\
    \    for (size_t i = 0; i < n; i++) \n    {\n        if (lst1[i] % 2 == 0) \n\
    \        {\n            continue;\n        }\n        for (size_t j = 0; j < m;\
    \ j++) \n        {\n            if (lst2[j] % 2 == 0 && hist[j] == 0) \n     \
    \       {\n                hist[j] = 1;\n                break;\n            }\n\
    \        }\n    }\n    foreach (i; hist) \n    {\n        if (i == 0)\n      \
    \  {\n            return \"NO\";\n        }\n    }\n    return \"YES\";\n}", "{\n\
    \    long oddInLst1 = count!((i) => i%2 == 1)(lst1);\n    long oddInLst2 = count!((i)\
    \ => i%2 == 1)(lst2);\n    return oddInLst1 == oddInLst2 ? \"YES\" : \"NO\";\n\
    }", "{\n    //bool evens = true;\n    bool odds = false;\n    bool in_lst1 = false;\n\
    \    bool in_lst2 = false;\n    string result = \"NO\";\n    foreach(x; lst1)\n\
    \    {\n        if (x%2 == 1)\n        {\n            in_lst1 = true;\n      \
    \      break;\n        }\n    }\n    foreach(x; lst2)\n    {\n        if (x%2\
    \ == 1)\n        {\n            in_lst2 = true;\n            break;\n        }\n\
    \    }\n    if (in_lst1 && in_lst2)\n    {\n        result = \"YES\";\n    }\n\
    \    return result;\n}", "{ \n    foreach(var n; lst1)\n    {\n        if(n %\
    \ 2 == 0) continue;\n        else\n        {\n            for(int i = 0; i < lst2.length;\
    \ i++)\n            {\n                if(lst2[i] % 2 == 0)\n                {\n\
    \                    lst2[i] = n;\n                    break;\n              \
    \  }\n            }\n        }\n    }\n    return isAllEven(lst1) ? \"YES\" :\
    \ \"NO\";\n}", "{ \n    foreach(i;0..lst1.length) { \n        if (lst1[i] % 2\
    \ == 0) continue; \n        foreach(j;0..lst2.length) { \n            if (lst2[j]\
    \ % 2 == 0) continue; \n            if (i == j) continue; \n            long tmp\
    \ = lst1[i]; \n            lst1[i] = lst2[j]; \n            lst2[j] = tmp; \n\
    \            if (all!((n) => n % 2 == 0)(lst1)) { \n                lst1[i] =\
    \ lst2[j]; \n                lst2[j] = tmp; \n            } else { \n        \
    \        return \"YES\"; \n            } \n        } \n    } \n    return \"NO\"\
    ; \n}", "{\n    int count = 0;\n    foreach(num; lst1)\n    {\n        if(num\
    \ % 2 != 0)\n        {\n            count++;\n        }\n    }\n    if(count ==\
    \ 0)\n    {\n        return \"YES\";\n    }\n    else if(count % 2 == 0)\n   \
    \ {\n        return \"YES\";\n    }\n    else\n    {\n        return \"NO\";\n\
    \    }\n}", "{\n    bool[] even = new bool[lst1.length];\n    bool[] odd = new\
    \ bool[lst1.length];\n    for (int i = 0; i < lst1.length; i++)\n    {\n     \
    \   if (lst1[i] % 2 == 0)\n        {\n            even[i] = true;\n        }\n\
    \        else\n        {\n            odd[i] = true;\n        }\n    }\n    for\
    \ (int i = 0; i < lst2.length; i++)\n    {\n        if (lst2[i] % 2 == 0)\n  \
    \      {\n            if (odd[i])\n            {\n                return \"YES\"\
    ;\n            }\n        }\n        else\n        {\n            if (even[i])\n\
    \            {\n                return \"YES\";\n            }\n        }\n  \
    \  }\n    return \"NO\";\n}", "{\n    bool isEven(long x) {\n        return x\
    \ % 2 == 0;\n    }\n    auto parity = zip(lst1, lst2).map!(tuple => (tuple[0]\
    \ % 2 == 0 ? 1 : 0) + (tuple[1] % 2 == 0 ? 1 : 0)).sum;\n    return parity > 0\
    \ ? \"YES\" : \"NO\";\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
