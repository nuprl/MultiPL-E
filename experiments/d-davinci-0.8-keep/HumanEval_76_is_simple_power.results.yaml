name: HumanEval_76_is_simple_power
language: d
results:
- program: "import std.typecons;\nimport std.math;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    is_simple_power(1,\
    \ 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) =>\
    \ true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n\
    \    is_simple_power(5, 3) => false\n    \n*/\nbool is_simple_power(long x, long\
    \ n) \n{\n    if (x == 1) return true;\n    if (n == 1) return false;\n    bool\
    \ is_negative = false;\n    if (x < 0)\n    {\n        is_negative = true;\n \
    \       x = -x;\n    }\n    if (n < 0)\n    {\n        n = -n;\n    }\n    while\
    \ (x % n == 0)\n    {\n        x /= n;\n    }\n    if (x != 1)\n    {\n      \
    \  return false;\n    }\n    if (is_negative)\n    {\n        n = -n;\n    }\n\
    \    return true;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n\
    \    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L) ==\
    \ false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L, 3L)\
    \ == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    is_simple_power(1,\
    \ 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) =>\
    \ true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n\
    \    is_simple_power(5, 3) => false\n    \n*/\nbool is_simple_power(long x, long\
    \ n) \n{\n    // int a = x / n;\n    // int b = n;\n    // while ( b > 1 )\n \
    \   // {\n    //     b /= n;\n    //     a /= n;\n    // }\n    // return a ==\
    \ 1;\n    return x == pow(n, round(log(x) / log(n)));\n}\nunittest\n{\n    alias\
    \ candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n  \
    \  assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp654v090m.d(40): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428b2d]\\n??:? void tmp654v090m.__unittest_L28_C1()\
    \ [0x427f5b]\\n??:? void tmp654v090m.__modtest() [0x4288ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c927]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b7ba]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x43094d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430dfc]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4308d9]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b791]\\n??:? runModuleUnitTests [0x42c6fd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428f7c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428f03]\\n??:? _d_run_main [0x428e6e]\\n??:? main [0x4288bf]\\\
    n??:? __libc_start_main [0xf3d0f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    is_simple_power(1,\
    \ 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) =>\
    \ true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n\
    \    is_simple_power(5, 3) => false\n    \n*/\nbool is_simple_power(long x, long\
    \ n) \n{\n    if (x == 1) \n    {\n        return true;\n    }\n    else if (n\
    \ == 1) \n    {\n        return false;\n    }\n    return equal(log(x) / log(n),\
    \ (long) log(x) / log(n));\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6m9as52b.d(26): Error: C style cast illegal, use `cast(long)log(x)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6m9as52b.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    is_simple_power(1,\
    \ 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) =>\
    \ true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n\
    \    is_simple_power(5, 3) => false\n    \n*/\nbool is_simple_power(long x, long\
    \ n) \n{\n    if (x < n)\n        return false;\n    else if (x == n)\n      \
    \  return true;\n    else if (x % n != 0)\n        return false;\n    else\n \
    \       return is_simple_power(x / n, n);\n}\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpypm12kt7.d(40): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e45]\\n??:? void tmpypm12kt7.__unittest_L27_C1()\
    \ [0x427bb3]\\n??:? void tmpypm12kt7.__modtest() [0x427bc8]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb6b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9fe]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb91]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430040]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fb1d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a9d5]\\n??:? runModuleUnitTests [0x42b941]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428294]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42821b]\\n??:? _d_run_main [0x428186]\\n??:? main [0x427bdb]\\\
    n??:? __libc_start_main [0x99e22554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    is_simple_power(1,\
    \ 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) =>\
    \ true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n\
    \    is_simple_power(5, 3) => false\n    \n*/\nbool is_simple_power(long x, long\
    \ n) \n{\n    auto t = tuple(n, 1);\n    if (x==n)\n        return true;\n   \
    \ else if (x<n)\n        return false;\n    else \n        return is_simple_power(x,\
    \ exponent(t));\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n  \
    \  assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L) ==\
    \ false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L, 3L)\
    \ == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv2q6wd9g.d(24): Error: undefined identifier `exponent`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv2q6wd9g.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    is_simple_power(1,\
    \ 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) =>\
    \ true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n\
    \    is_simple_power(5, 3) => false\n    \n*/\nbool is_simple_power(long x, long\
    \ n) \n{\n    bool is_int = true;\n    double result = std.math.log(x) / std.math.log(n);\n\
    \    std.string.to!(\"int\")(result);\n    return is_int;\n}\nunittest\n{\n  \
    \  alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n\
    \    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpx4yv5h3x.d(20): Error: undefined identifier `string` in package\
    \ `std`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx4yv5h3x.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    is_simple_power(1,\
    \ 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) =>\
    \ true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n\
    \    is_simple_power(5, 3) => false\n    \n*/\nbool is_simple_power(long x, long\
    \ n) \n{\n    // Your code goes here\n    // THE GIVEN SOLUTION IS NOT GOOD\n\
    \    /*\n    import std.math : ln, round;\n    int nn;\n    real nnn;\n    real\
    \ nx;\n    nx = ln(n);\n    nnn = ln(x) / nx;\n    nn = round(nnn);\n    // nnn=pow(n,\
    \ nn);\n    // nn=cast(int)log10(cast(real)x)/cast(int)log10(cast(real)n);\n \
    \   return nnn == cast(real)nn;\n    */\n    if (n == 1)\n        return false;\n\
    \    else if (x == 1)\n        return true;\n    else\n    {\n        while (x\
    \ % n == 0)\n        {\n            x /= n;\n        }\n        return x == 1;\n\
    \    }\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpw0yczwl7.d(57): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e4d]\\n??:? void tmpw0yczwl7.__unittest_L45_C1()\
    \ [0x427b97]\\n??:? void tmpw0yczwl7.__modtest() [0x427bd0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb73]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42aa06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb99]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430048]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fb25]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a9dd]\\n??:? runModuleUnitTests [0x42b949]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42829c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428223]\\n??:? _d_run_main [0x42818e]\\n??:? main [0x427be3]\\\
    n??:? __libc_start_main [0xfd8f1554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    is_simple_power(1,\
    \ 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) =>\
    \ true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n\
    \    is_simple_power(5, 3) => false\n    \n*/\nbool is_simple_power(long x, long\
    \ n) \n{\n    double val;\n    val = log(x) / log(n);\n    return (val == (int)val);\n\
    }\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc29dpse1.d(20): Error: C style cast illegal, use `cast(int)val`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc29dpse1.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    is_simple_power(1,\
    \ 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) =>\
    \ true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n\
    \    is_simple_power(5, 3) => false\n    \n*/\nbool is_simple_power(long x, long\
    \ n) \n{\n    if (x == 1) return true;\n    if (n == 1) return false;\n    long\
    \ p = 0;\n    while (x % n == 0)\n    {\n        x /= n;\n        p++;\n    }\n\
    \    if (p > 1 && x == 1) return true;\n    return false;\n}\nunittest\n{\n  \
    \  alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n\
    \    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    is_simple_power(1,\
    \ 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) =>\
    \ true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n\
    \    is_simple_power(5, 3) => false\n    \n*/\nbool is_simple_power(long x, long\
    \ n) \n{\n    if (n == 1) return x == 1;\n    return log(x) / log(n) == (int)(log(x)\
    \ / log(n));\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6xcc3ebj.d(19): Error: C style cast illegal, use `cast(int)(log(x)\
    \ / log(n))`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6xcc3ebj.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    is_simple_power(1,\
    \ 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) =>\
    \ true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n\
    \    is_simple_power(5, 3) => false\n    \n*/\nbool is_simple_power(long x, long\
    \ n) \n{\n\treturn log(x) / log(n) == floor(log(x) / log(n));\n}\nunittest\n{\n\
    \    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n\
    \    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpeskq3ynz.d(32): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428035]\\n??:? void tmpeskq3ynz.__unittest_L20_C1()\
    \ [0x427d7f]\\n??:? void tmpeskq3ynz.__modtest() [0x427db8]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bef7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ad8a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff1d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x4303cc]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fea9]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42ad61]\\n??:? runModuleUnitTests [0x42bccd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428484]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42840b]\\n??:? _d_run_main [0x428376]\\n??:? main [0x427dcb]\\\
    n??:? __libc_start_main [0xb2960554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    is_simple_power(1,\
    \ 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) =>\
    \ true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n\
    \    is_simple_power(5, 3) => false\n    \n*/\nbool is_simple_power(long x, long\
    \ n) \n{\n    if (x == 1 && n == 1) return true;\n    if (x == 1) return false;\n\
    \    if (n == 1) return false;\n    if (x < n) return false;\n    return x ==\
    \ pow(n, round(log(x) / log(n)));\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp06odibgd.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428b55]\\n??:? void tmp06odibgd.__unittest_L24_C1()\
    \ [0x427fab]\\n??:? void tmp06odibgd.__modtest() [0x4288d8]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c94f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b7e2]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430975]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430e24]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430901]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b7b9]\\n??:? runModuleUnitTests [0x42c725]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428fa4]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428f2b]\\n??:? _d_run_main [0x428e96]\\n??:? main [0x4288eb]\\\
    n??:? __libc_start_main [0x510f7554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    is_simple_power(1,\
    \ 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) =>\
    \ true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n\
    \    is_simple_power(5, 3) => false\n    \n*/\nbool is_simple_power(long x, long\
    \ n) \n{\n    // just checking if n can divide x\n    if(x % n != 0)\n       \
    \ return false;\n    \n    // if n divides x, we divide x by n and check\n   \
    \ // if dividing x by n further continues to divide x\n    // meaning that if\
    \ x is divisible by n, it is divisible by\n    // x / n, if this continues to\
    \ happen, x is an integer power of n\n    while(x % n == 0)\n    {\n        x\
    \ /= n;\n    }\n    \n    // if x has become 1, then we have divided x by n and\
    \ x / n\n    // until we got x = 1, which means that x is an integer power of\
    \ n\n    if(x == 1)\n        return true;\n    \n    // if x is not equal to 1\
    \ and x is divisible by n, then x is a composite number\n    // which means that\
    \ it is not an integer power of n\n    return false;\n}\nunittest\n{\n    alias\
    \ candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n  \
    \  assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "import std.typecons;\nimport std.math;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    is_simple_power(1,\
    \ 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) =>\
    \ true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n\
    \    is_simple_power(5, 3) => false\n    \n*/\nbool is_simple_power(long x, long\
    \ n) \n{\n    if (x==1) return true;\n    if (n==1) return false;\n    return\
    \ (x%n==0 && is_simple_power(x/n, n));\n}\n//100\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    is_simple_power(1,\
    \ 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) =>\
    \ true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n\
    \    is_simple_power(5, 3) => false\n    \n*/\nbool is_simple_power(long x, long\
    \ n) \n{\n    bool result = false;\n    if ( n == 0 )\n    {\n        if ( x ==\
    \ 1 )\n            result = true;\n    }\n    else\n    {\n        auto root =\
    \ cast(long)log(x) / log(n);\n        if ( n ** root == x )\n            result\
    \ = true;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpd8nyswco.d(27): Error: can only `*` a pointer, not a `real`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd8nyswco.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    is_simple_power(1,\
    \ 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) =>\
    \ true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n\
    \    is_simple_power(5, 3) => false\n    \n*/\nbool is_simple_power(long x, long\
    \ n) \n{\n\twhile(x % n == 0)\n\t{\n\t\tx /= n;\n\t}\n\treturn x == 1;\n}\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "import std.typecons;\nimport std.math;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    is_simple_power(1,\
    \ 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) =>\
    \ true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n\
    \    is_simple_power(5, 3) => false\n    \n*/\nbool is_simple_power(long x, long\
    \ n) \n{\n    static bool is_power(long x, long n)\n    {\n        bool result\
    \ = false;\n        if (n <= 0)\n            return false;\n        if (x == 1)\n\
    \            return true;\n        if (x % n == 0)\n            result = is_power(x\
    \ / n, n);\n        return result;\n    }\n    return is_power(x, n);\n}\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    is_simple_power(1,\
    \ 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) =>\
    \ true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n\
    \    is_simple_power(5, 3) => false\n    \n*/\nbool is_simple_power(long x, long\
    \ n) \n{\n   return pow(n, floor(log(x) / log(n))) == x;\n}\nunittest\n{\n   \
    \ alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n\
    \    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp3hpumnq1.d(32): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428b65]\\n??:? void tmp3hpumnq1.__unittest_L20_C1()\
    \ [0x427f93]\\n??:? void tmp3hpumnq1.__modtest() [0x4288e4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42ca5f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b8f2]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430a85]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430f34]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430a11]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b8c9]\\n??:? runModuleUnitTests [0x42c835]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428fb4]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428f3b]\\n??:? _d_run_main [0x428ea6]\\n??:? main [0x4288f7]\\\
    n??:? __libc_start_main [0xe6f44554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    is_simple_power(1,\
    \ 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) =>\
    \ true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n\
    \    is_simple_power(5, 3) => false\n    \n*/\nbool is_simple_power(long x, long\
    \ n) \n{\n\tif (n == 1 && x == 1)\n\t\treturn true;\n\tif (x == 1)\n\t\treturn\
    \ false;\n\tif (is(typeof(n == pow(x, int(log(x) / log(n))))))\n\t\treturn true;\n\
    \treturn false;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n  \
    \  assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L) ==\
    \ false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L, 3L)\
    \ == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp5dkwnipp.d(30): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e25]\\n??:? void tmp5dkwnipp.__unittest_L26_C1()\
    \ [0x427a4d]\\n??:? void tmp5dkwnipp.__modtest() [0x427ba4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb4b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9de]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb71]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430020]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fafd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a9b5]\\n??:? runModuleUnitTests [0x42b921]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428274]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281fb]\\n??:? _d_run_main [0x428166]\\n??:? main [0x427bb7]\\\
    n??:? __libc_start_main [0xca94c554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    is_simple_power(1,\
    \ 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) =>\
    \ true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n\
    \    is_simple_power(5, 3) => false\n    \n*/\nbool is_simple_power(long x, long\
    \ n) \n{\n  long power = pow(n, int(log(x) / log(n)));\n  return x == power;\n\
    }\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxja8y1p3.d(18): Error: cannot implicitly convert expression `log(cast(real)x)\
    \ / log(cast(real)n)` of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpxja8y1p3.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
