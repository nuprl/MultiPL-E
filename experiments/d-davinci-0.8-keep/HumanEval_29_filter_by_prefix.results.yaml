name: HumanEval_29_filter_by_prefix
language: d
results:
- program: "import std.typecons;\nimport std.math;\n/*\n Filter an input list of strings\
    \ only for ones that start with a given prefix.\n    >>> filter_by_prefix([],\
    \ 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'array']\n    \n*/\nstring[] filter_by_prefix(string[] strings, string\
    \ prefix) \n{\n    string[] result;\n    foreach(str; strings)\n    {\n      \
    \  if(str.startsWith(prefix))\n        {\n            result ~= str;\n       \
    \ }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = filter_by_prefix;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7v139myw.d(16): Error: no property `startsWith` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7v139myw.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Filter an input list of strings\
    \ only for ones that start with a given prefix.\n    >>> filter_by_prefix([],\
    \ 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'array']\n    \n*/\nstring[] filter_by_prefix(string[] strings, string\
    \ prefix) \n{\n    return filter!(a => a.startsWith(prefix))(strings);\n}\n/*\n\
    \ Find the first index at which a given element is found in a given array. \n\
    \ Returns -1 if the element is not present.\n    >>> index_of(['a', 'b', 'c'],\
    \ 'c')\n    2\n    >>> index_of(['a', 'b', 'c'], 'd')\n    -1\n*/\nunittest\n\
    {\n    alias candidate = filter_by_prefix;\n\n    assert(candidate([], \"john\"\
    ) == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\"\
    , \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmresy40g.d(13): Error: template instance `filter!((a) => a.startsWith(prefix))`\
    \ template `filter` is not defined\\nFailed: [\"dmd\", \"-unittest\", \"-v\",\
    \ \"-o-\", \"/tmp/tmpmresy40g.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Filter an input list of strings\
    \ only for ones that start with a given prefix.\n    >>> filter_by_prefix([],\
    \ 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'array']\n    \n*/\nstring[] filter_by_prefix(string[] strings, string\
    \ prefix) \n{\n    return strings.filter!(s => s.startsWith(prefix)).array;\n\
    }\n/*\nFind the top n elements from a list of strings according to their lengths.\n\
    \    >>> top_n_by_length(3, ['abc', 'def', 'gh', 'i', 'jkl'])\n    ['abc', 'def',\
    \ 'jkl']\n    >>> top_n_by_length(1, ['abc', 'def', 'gh', 'i', 'jkl'])\n    ['abc']\n\
    */\nstring[] top_n_by_length(int n, string[] strings) \n{\n    return strings.filter!(s\
    \ => s.length > 2).array;\n}\n/*\n Find the sum of all numbers between two numbers\n\
    \    >>> sum_between(1, 4)\n    10\n    >>> sum_between(0, -10)\n    -55\n*/\n\
    unittest\n{\n    alias candidate = filter_by_prefix;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgtl922fe.d(13): Error: no property `filter` for type `string[]`\\\
    n/tmp/tmpgtl922fe.d(24): Error: no property `filter` for type `string[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgtl922fe.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Filter an input list of strings\
    \ only for ones that start with a given prefix.\n    >>> filter_by_prefix([],\
    \ 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'array']\n    \n*/\nstring[] filter_by_prefix(string[] strings, string\
    \ prefix) \n{\n    string[] filtered_strings;\n    foreach(string s; strings)\n\
    \    {\n        if(s.startsWith(prefix))\n        {\n            filtered_strings\
    \ ~= s;\n        }\n    }\n    return filtered_strings;\n}\n/*\n    Construct\
    \ a list of all prefixes of a given string.\n        >>> list_of_prefixes('abc')\n\
    \        ['a', 'ab', 'abc']\n        >>> list_of_prefixes('abcd')\n        ['a',\
    \ 'ab', 'abc', 'abcd']\n*/\nstring[] list_of_prefixes(string text)\n{\n    string[]\
    \ prefixes;\n    foreach(immutable i; 0..text.length)\n    {\n        prefixes\
    \ ~= text[0..i];\n    }\n    return prefixes;\n}\n/*\n    A naiive implementation\
    \ of the autocompletion function.\n    Given a prefix and a list of strings, we\
    \ return all of the possible completions of that prefix that are actually in the\
    \ list.\n    >>> autocomplete('a', ['abc', 'bcd', 'cde', 'array'])\n    ['abc',\
    \ 'array']\n    >>> autocomplete('ab', ['abc', 'bcd', 'cde', 'array'])\n    ['abc',\
    \ 'array']\n    >>> autocomplete('abc', ['abc', 'bcd', 'cde', 'array'])\n    ['abc']\n\
    \    >>> autocomplete('x', ['abc', 'bcd', 'cde', 'array'])\n    []\n*/\nstring[]\
    \ autocomplete(string prefix, string[] strings)\n{\n    string[] matching_strings;\n\
    \    foreach(string s; strings)\n    {\n        if(s.startsWith(prefix))\n   \
    \     {\n            matching_strings ~= s;\n        }\n    }\n    return matching_strings;\n\
    }\n// autocomplete using a sorted list of strings\nstring[] autocomplete_sorted(string\
    \ prefix, string[] strings)\n{\n    // use std.algorithm.find, which uses binary\
    \ search to find prefix in strings, if it is not present, return null\n    string\
    \ start_of_completions = find(strings, prefix\nunittest\n{\n    alias candidate\
    \ = filter_by_prefix;\n\n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpx8gxt3bb.d(68): Error: found `unittest` when expecting `,`\\\
    n/tmp/tmpx8gxt3bb.d(75): Error: found `void` when expecting `,`\\n/tmp/tmpx8gxt3bb.d(75):\
    \ Error: found `{` when expecting `,`\\n/tmp/tmpx8gxt3bb.d(75): Error: expression\
    \ expected, not `}`\\n/tmp/tmpx8gxt3bb.d(75): Error: found `End of File` when\
    \ expecting `,`\\n/tmp/tmpx8gxt3bb.d(75): Error: found `End of File` when expecting\
    \ `)`\\n/tmp/tmpx8gxt3bb.d(75): Error: semicolon expected, not `End of File`\\\
    n/tmp/tmpx8gxt3bb.d(75): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx8gxt3bb.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Filter an input list of strings\
    \ only for ones that start with a given prefix.\n    >>> filter_by_prefix([],\
    \ 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'array']\n    \n*/\nstring[] filter_by_prefix(string[] strings, string\
    \ prefix) \n{\n    string[] res;\n    foreach(s; strings) \n    {\n        if(s.startsWith(prefix))\
    \ \n        {\n            res ~= s;\n        }\n    }\n    return res;\n}\n \n\
    /*\n Find the length of the longest common prefix of two strings.\n    >>> longest_common_prefix_length('abc',\
    \ 'abcdef')\n    3\n    >>> longest_common_prefix_length('abc', 'abcdef', 'abcde')\n\
    \    3\n    >>> longest_common_prefix_length('abc', 'def')\n    0\n    >>> longest_common_prefix_length('abc',\
    \ 'def', 'ghi')\n    0\n    >>> longest_common_prefix_length('abcd', 'abcd')\n\
    \    4\n    \n*/\nsize_t longest_common_prefix_length(string[] strings) \n{\n\
    \    assert(strings.length > 0);\n    size_t len = 0;\n    while(true) \n    {\n\
    \        char c = strings[0][len];\n        foreach(s; strings) \n        {\n\
    \            if(s.length <= len || s[len] != c) \n            {\n            \
    \    return len;\n            }\n        }\n        len++;\n    }\n}\n \n/*\n\
    \ Returns all possible strings that can be formed by removing 0 or more characters\
    \ from a string.\n    >>> combinations('abc')\n    ['abc', 'ab', 'ac', 'a', 'bc',\
    \ 'b', 'c', '']\n    \n*/\nstring[] combinations(string str) \n{\n    string[]\
    \ res;\n    for(size_t i = 0; i <= str.length; i++) \n    {\n        res ~= str[0..i];\n\
    \    }\n    return res;\n}\n \n/*\n Returns all possible strings that can be formed\
    \ by removing 0 or more characters from a string.\n    >>> combinations(['abc',\
    \ 'def'])\n    ['abc', 'ab', 'ac', 'a', 'def', 'de', 'd', 'ef', 'e', 'f', '']\n\
    \    \n*/\nstring[] combinations(string[] strings) \n{\n    string[] res;\n  \
    \  fore\nunittest\n{\n    alias candidate = filter_by_prefix;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgny29c6c.d(82): Error: found `unittest` when expecting `;` following\
    \ statement\\n/tmp/tmpgny29c6c.d(89): Error: found `End of File` when expecting\
    \ `}` following compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\",\
    \ \"-o-\", \"/tmp/tmpgny29c6c.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Filter an input list of strings\
    \ only for ones that start with a given prefix.\n    >>> filter_by_prefix([],\
    \ 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'array']\n    \n*/\nstring[] filter_by_prefix(string[] strings, string\
    \ prefix) \n{\n    return strings.filter!(x => x.startsWith(prefix));\n}\n/*\n\
    \ Get the last element of a list.\n    >>> last_element([])\n    \"No elements!\"\
    \n    >>> last_element([1, 2, 3])\n    3\n    \n*/\nstring last_element(int[]\
    \ nums) \n{\n    if (nums.length == 0)\n        return \"No elements!\";\n   \
    \ else\n        return nums[$ - 1].to!string;\n}\n/*\nApply a function to an input\
    \ list of numbers and return the resulting list.\n    >>> map_list(x => x * 2,\
    \ [1, 2, 3])\n    [2, 4, 6]\n    >>> map_list(x => x * x, [1, 2, 3])\n    [1,\
    \ 4, 9]\n    \n*/\nunittest\n{\n    alias candidate = filter_by_prefix;\n\n  \
    \  assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\"\
    , \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpg2dgjzwv.d(13): Error: no property `filter` for type `string[]`\\\
    n/tmp/tmpg2dgjzwv.d(28): Error: no property `to` for type `int`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg2dgjzwv.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Filter an input list of strings\
    \ only for ones that start with a given prefix.\n    >>> filter_by_prefix([],\
    \ 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'array']\n    \n*/\nstring[] filter_by_prefix(string[] strings, string\
    \ prefix) \n{\n    return strings.filter!(s => s.startsWith(prefix));\n}\nunittest\n\
    {\n    alias candidate = filter_by_prefix;\n\n    assert(candidate([], \"john\"\
    ) == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\"\
    , \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnwu56qph.d(13): Error: no property `filter` for type `string[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnwu56qph.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Filter an input list of strings\
    \ only for ones that start with a given prefix.\n    >>> filter_by_prefix([],\
    \ 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'array']\n    \n*/\nstring[] filter_by_prefix(string[] strings, string\
    \ prefix) \n{\n\treturn strings.filter!(a => a.startsWith(prefix));\n}\n/*\n Counts\
    \ the number of words in a string.\n    \n*/\nunittest\n{\n    alias candidate\
    \ = filter_by_prefix;\n\n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpthfobxre.d(13): Error: no property `filter` for type `string[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpthfobxre.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Filter an input list of strings\
    \ only for ones that start with a given prefix.\n    >>> filter_by_prefix([],\
    \ 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'array']\n    \n*/\nstring[] filter_by_prefix(string[] strings, string\
    \ prefix) \n{\n    auto result = std.algorithm.filter!( (string s) => s.startsWith(prefix)\
    \ )(strings);\n    return result.array;\n}\nunittest\n{\n    alias candidate =\
    \ filter_by_prefix;\n\n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4uxychgb.d(13): Error: undefined identifier `algorithm` in package\
    \ `std`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4uxychgb.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Filter an input list of strings\
    \ only for ones that start with a given prefix.\n    >>> filter_by_prefix([],\
    \ 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'array']\n    \n*/\nstring[] filter_by_prefix(string[] strings, string\
    \ prefix) \n    if(isInputRange!(string[])) {\n        string[] results;\n   \
    \     foreach(s; strings) {\n            if(s.startsWith(prefix)) {\n        \
    \        results ~= s;\n            }\n        }\n        return results;\n  \
    \  }\nunittest\n{\n    alias candidate = filter_by_prefix;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwu6zyz2i.d(12): Error: cannot use function constraints for non-template\
    \ functions. Use `static if` instead\\n/tmp/tmpwu6zyz2i.d(12): Error: declaration\
    \ expected, not `if`\\n/tmp/tmpwu6zyz2i.d(14): Error: declaration expected, not\
    \ `foreach`\\n/tmp/tmpwu6zyz2i.d(14): Error: no identifier for declarator `strings`\\\
    n/tmp/tmpwu6zyz2i.d(14): Error: declaration expected, not `)`\\n/tmp/tmpwu6zyz2i.d(17):\
    \ Error: unrecognized declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpwu6zyz2i.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Filter an input list of strings\
    \ only for ones that start with a given prefix.\n    >>> filter_by_prefix([],\
    \ 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'array']\n    \n*/\nstring[] filter_by_prefix(string[] strings, string\
    \ prefix) \n{\n    string[] ret;\n    foreach(str; strings) \n    {\n        if(str.startsWith(prefix))\n\
    \            ret ~= str;\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate\
    \ = filter_by_prefix;\n\n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqce41w5h.d(16): Error: no property `startsWith` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqce41w5h.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Filter an input list of strings\
    \ only for ones that start with a given prefix.\n    >>> filter_by_prefix([],\
    \ 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'array']\n    \n*/\nstring[] filter_by_prefix(string[] strings, string\
    \ prefix) \n{\n    if (strings.length == 0) \n    {\n        return [];\n    }\n\
    \    else \n    {\n        if (strings[0].startsWith(prefix)) \n        {\n  \
    \          return [strings[0]] ~ filter_by_prefix(strings[1 .. $], prefix);\n\
    \        }\n        else \n        {\n            return filter_by_prefix(strings[1\
    \ .. $], prefix);\n        }\n    }\n}\nunittest\n{\n    alias candidate = filter_by_prefix;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwhndvt9f.d(19): Error: no property `startsWith` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwhndvt9f.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Filter an input list of strings\
    \ only for ones that start with a given prefix.\n    >>> filter_by_prefix([],\
    \ 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'array']\n    \n*/\nstring[] filter_by_prefix(string[] strings, string\
    \ prefix) \n{\n    string[] filtered;\n    foreach(string s; strings) \n    {\n\
    \        if(s.startsWith(prefix))\n            filtered ~= s;\n    }\n    return\
    \ filtered;\n}\n/*\n    >>> sum_or_zero([])\n    0\n    >>> sum_or_zero([3, 4,\
    \ 7])\n    14\n*/\nunittest\n{\n    alias candidate = filter_by_prefix;\n\n  \
    \  assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\"\
    , \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpb6mcgbjy.d(16): Error: no property `startsWith` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb6mcgbjy.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Filter an input list of strings\
    \ only for ones that start with a given prefix.\n    >>> filter_by_prefix([],\
    \ 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'array']\n    \n*/\nstring[] filter_by_prefix(string[] strings, string\
    \ prefix) \n{\n    return filter!(s => s.startsWith(prefix))(strings);\n}\nunittest\n\
    {\n    alias candidate = filter_by_prefix;\n\n    assert(candidate([], \"john\"\
    ) == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\"\
    , \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpz5t72c4h.d(13): Error: template instance `filter!((s) => s.startsWith(prefix))`\
    \ template `filter` is not defined\\nFailed: [\"dmd\", \"-unittest\", \"-v\",\
    \ \"-o-\", \"/tmp/tmpz5t72c4h.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Filter an input list of strings\
    \ only for ones that start with a given prefix.\n    >>> filter_by_prefix([],\
    \ 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'array']\n    \n*/\nstring[] filter_by_prefix(string[] strings, string\
    \ prefix) \n{\n    string[] filtered;\n    foreach(s; strings)\n    {\n      \
    \  if(s.startsWith(prefix))\n        {\n            filtered ~= s;\n        }\n\
    \    }\n    return filtered;\n}\n \n/*\n Filter a dictionary by key prefix\n \
    \   >>> typeof(filter_by_prefix_dict({}, 'a'))\n    Map!(string, int)\n    >>>\
    \ filter_by_prefix_dict(['a':1, 'bb':2, 'ccc':3], 'b')\n    ['bb':2]\n*/\nMap!(string,\
    \ int) filter_by_prefix_dict(Map!(string, int) d, string prefix) \n{\n    Map!(string,\
    \ int) filtered;\n    foreach(key, val; d)\n    {\n        if(key.startsWith(prefix))\n\
    \        {\n            filtered[key] = val;\n        }\n    }\n    return filtered;\n\
    }\n \n/*\n Filter a dictionary by key prefix, returning the key and value types\n\
    \    >>> typeof(filter_by_prefix_dict2({}, 'a'))\n    Tuple!(Map!(string, int),\
    \ int)\n    >>> filter_by_prefix_dict2(['a':1, 'bb':2, 'ccc':3], 'b')\n    (['bb':2],\
    \ 2)\n*/\nTuple!(Map!(string, int), int) filter_by_prefix_dict2(Map!(string, int)\
    \ d, string prefix) \n{\n    Map!(string, int) filtered;\n    foreach(key, val;\
    \ d)\n    {\n        if(key.startsWith(prefix))\n        {\n            filtered[key]\
    \ = val;\n        }\n    }\n    return tuple(filtered, d[prefix]);\n}\n \n/*\n\
    \  Filter a dictionary by key prefix, returning the key and value types\n    \
    \ >>> typeof(filter_by_prefix_dict3({}, 'a'))\n     Map!(string, int)\n     >>>\
    \ filter_by_prefix_dict3(['a':1, 'bb':2, 'ccc':3], 'b')\n     ['bb\nunittest\n\
    {\n    alias candidate = filter_by_prefix;\n\n    assert(candidate([], \"john\"\
    ) == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\"\
    , \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8j77fxzg.d(64): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8j77fxzg.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Filter an input list of strings\
    \ only for ones that start with a given prefix.\n    >>> filter_by_prefix([],\
    \ 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'array']\n    \n*/\nstring[] filter_by_prefix(string[] strings, string\
    \ prefix) \n{\n    return strings.filter!(x => x.startsWith(prefix)).array;\n\
    }\nunittest\n{\n    alias candidate = filter_by_prefix;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjuab3d3o.d(13): Error: no property `filter` for type `string[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjuab3d3o.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Filter an input list of strings\
    \ only for ones that start with a given prefix.\n    >>> filter_by_prefix([],\
    \ 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'array']\n    \n*/\nstring[] filter_by_prefix(string[] strings, string\
    \ prefix) \n{\n    return filter!(a => a.startsWith(prefix))(strings);\n}\nunittest\n\
    {\n    alias candidate = filter_by_prefix;\n\n    assert(candidate([], \"john\"\
    ) == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\"\
    , \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprgo_r9si.d(13): Error: template instance `filter!((a) => a.startsWith(prefix))`\
    \ template `filter` is not defined\\nFailed: [\"dmd\", \"-unittest\", \"-v\",\
    \ \"-o-\", \"/tmp/tmprgo_r9si.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Filter an input list of strings\
    \ only for ones that start with a given prefix.\n    >>> filter_by_prefix([],\
    \ 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'array']\n    \n*/\nstring[] filter_by_prefix(string[] strings, string\
    \ prefix) \n{\n\tstring[] result;\n\tforeach(str; strings)\n\t{\n\t\tif(str.startsWith(prefix))\n\
    \t\t{\n\t\t\tresult ~= str;\n\t\t}\n\t}\n\treturn result;\n}\n/*\n \nUsing list\
    \ comprehensions, generate a list of tuples where the first element is the index\
    \ of the tuple and the second element is the string version of the index.\n \n\
    >>> list_comprehension(5)\n[(0, '0'), (1, '1'), (2, '2'), (3, '3'), (4, '4')]\n\
    \ \n*/\ntuple!(size_t, string)[] list_comprehension(size_t end)\n{\n\ttuple!(size_t,\
    \ string)[] result;\n\tforeach(i; 0..end)\n\t{\n\t\tresult ~= tuple(i, i.to!string);\n\
    \t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = filter_by_prefix;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2kijc87p.d(31): Error: `tuple!(ulong, string)` is used as a type\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2kijc87p.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Filter an input list of strings\
    \ only for ones that start with a given prefix.\n    >>> filter_by_prefix([],\
    \ 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'array']\n    \n*/\nstring[] filter_by_prefix(string[] strings, string\
    \ prefix) \n{\n    return strings.filter!(a => a.startsWith(prefix)).array;\n\
    }\n/*\n Write a function max_by that accepts a pair of numbers and a function:\n\
    \    f(A, B) -> int\n    and returns the number that gives the larger result when\
    \ passed to f.\n    If the results are tied, one can be returned in either order.\n\
    \    >>> max_by(1, 2, square)\n    2\n    >>> max_by(2, 1, square)\n    2\n  \
    \  >>> max_by(1, 1, square)\n    1\n    >>> max_by(1, 2, square + 1)\n    1\n\
    \    >>> max_by(1, 2, square - 1)\n    2\n*/\nT max_by(T)(T a, T b, T delegate(T,\
    \ T) f) \n{\n    return f(a, b) > 0 ? a : b;\n}\n/*\n Given a list of numbers,\
    \ return the average of all the numbers.\n Hint: .sum is a function of a list\
    \ of numbers that gives you the sum of all the numbers in the list.\n    >>> average([5,1,3,4])\n\
    \    3.25\n    >>> average([4,1,3,5])\n    3.5\n*/\nreal average(int[] nums) \n\
    {\n    return nums.sum / nums.length;\n}\n/*\n Given a list of numbers and a function\
    \ f, return only the numbers that are greater than average.\n    >>> remove_below_average([1,2,3,4,5],\
    \ (a,b) => a + b)\n    [3,4,5]\n    >>> remove_below_average([1,1,1,1,1], (a,b)\
    \ => a * b)\n    [1,1,1,1,1]\n    >>> remove_below_average([1,1,1,1,1], (a,b)\
    \ => a + b)\n    []\n*/\nunittest\n{\n    alias candidate = filter_by_prefix;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpq5a04fyw.d(13): Error: no property `filter` for type `string[]`\\\
    n/tmp/tmpq5a04fyw.d(45): Error: no property `sum` for type `int[]`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq5a04fyw.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Filter an input list of strings\
    \ only for ones that start with a given prefix.\n    >>> filter_by_prefix([],\
    \ 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'array']\n    \n*/\nstring[] filter_by_prefix(string[] strings, string\
    \ prefix) \n{\n    return filter!(s => s.startsWith(prefix))(strings);\n}\n/*\n\
    Filter an input list of points only for ones that lie within a given\nradius of\
    \ a given point.\n    >>> filter_by_radius([], 1, [0, 0])\n    []\n    >>> filter_by_radius([[1,\
    \ 1], [2, 2], [3, 3]], 2, [0, 0])\n    [[1, 1]]\n*/\nreal[][] filter_by_radius(real[][]\
    \ points, real radius, real[] center) \n{\n    return filter!(p => dist(p, center)\
    \ <= radius)(points);\n}\n/*\nCount the number of elements in a list that are\
    \ strictly greater than a\ngiven value.\n    >>> count_greater_than([], 0)\n \
    \   0\n    >>> count_greater_than([1, 2, 3, 4, 5], 4)\n    1\n*/\nsize_t count_greater_than(int[]\
    \ numbers, int limit) \n{\n    return count!(n => n > limit)(numbers);\n}\n/*\n\
    Partition a list into two lists, containing elements that are less than a\ngiven\
    \ value, and elements that are greater than or equal to a given value.\n    >>>\
    \ partition([], 0)\n    ([], [])\n    >>> partition([1, 2, 3, 4, 5], 3)\n    ([1,\
    \ 2], [3, 4, 5])\n*/\nTuple!(int[], int[]) partition(int[] numbers, int limit)\
    \ \n{\n    auto lt = filter!(n => n < limit)(numbers);\n    auto ge = filter!(n\
    \ => n >= limit)(numbers);\n    return tuple(lt, ge);\n}\nunittest\n{\n    alias\
    \ candidate = filter_by_prefix;\n\n    assert(candidate([], \"john\") == []);\n\
    \    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"\
    xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0m7ucfl9.d(13): Error: template instance `filter!((s) => s.startsWith(prefix))`\
    \ template `filter` is not defined\\n/tmp/tmp0m7ucfl9.d(25): Error: template instance\
    \ `filter!((p) => dist(p, center) <= radius)` template `filter` is not defined\\\
    n/tmp/tmp0m7ucfl9.d(37): Error: template instance `count!((n) => n > limit)` template\
    \ `count` is not defined\\n/tmp/tmp0m7ucfl9.d(49): Error: template instance `filter!((n)\
    \ => n < limit)` template `filter` is not defined\\n/tmp/tmp0m7ucfl9.d(50): Error:\
    \ template instance `filter!((n) => n >= limit)` template `filter` is not defined\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0m7ucfl9.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
