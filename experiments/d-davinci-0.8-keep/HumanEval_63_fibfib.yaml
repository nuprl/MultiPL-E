name: HumanEval_63_fibfib
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\nThe FibFib number sequence is\
  \ a sequence similar to the Fibbonacci sequnece that's defined as follows:\n   \
  \ fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1)\
  \ + fibfib(n-2) + fibfib(n-3).\n    Please write a function to efficiently compute\
  \ the n-th element of the fibfib number sequence.\n    >>> fibfib(1)\n    0\n  \
  \  >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \n*/\nlong fibfib(long n)\
  \ \n"
tests: "unittest\n{\n    alias candidate = fibfib;\n\n    assert(candidate(2L) ==\
  \ 1L);\n    assert(candidate(1L) == 0L);\n    assert(candidate(5L) == 4L);\n   \
  \ assert(candidate(8L) == 24L);\n    assert(candidate(10L) == 81L);\n    assert(candidate(12L)\
  \ == 274L);\n    assert(candidate(14L) == 927L);\n}\nvoid main(){}"
completions: ["{\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n\
    \ == 2) return 1;\n    return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n}", "{\n\
    \    if (n <= 1) return 0;\n    if (n == 2) return 1;\n    long[2] cache = [0,\
    \ 1];\n    return fibfib(n, cache);\n}\nlong fibfib(long n, ref long[2] cache)\
    \ \n{\n    if (n < 2) return cache[n];\n    long next = cache[0] + cache[1] +\
    \ fibfib(n - 3, cache);\n    cache[0] = cache[1];\n    cache[1] = next;\n    return\
    \ next;\n}", "{\n    if (n == 0)\n        return 0;\n    if (n == 1)\n       \
    \ return 0;\n    if (n == 2)\n        return 1;\n    return fibfib(n-1) + fibfib(n-2)\
    \ + fibfib(n-3);\n}", "{\n    assert(n >= 0);\n    if (n < 2)\n        return\
    \ 0;\n    if (n == 2)\n        return 1;\n    int a = 0, b = 0, c = 1;\n    for\
    \ (int i = 3; i <= n; i++) \n    {\n        int d = a + b + c;\n        a = b;\n\
    \        b = c;\n        c = d;\n    }\n    return c;\n}", "{\n    long a = 0;\n\
    \    long b = 0;\n    long c = 1;\n    long d = 0;\n    long e = 0;\n    if (n\
    \ == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 1;\n    n\
    \ -= 2;\n    while (n > 0)\n    {\n        e = d;\n        d = c;\n        c =\
    \ b + c + a;\n        a = b;\n        b = d;\n        n--;\n    }\n    return\
    \ c;\n}", "{\n    return n <= 2 ? (n == 0 ? 0 : 1) : fibfib(n - 1) + fibfib(n\
    \ - 2) + fibfib(n - 3);\n}\n/*\nIn this puzzle, you're given a series of rectangles\
    \ of different heights. Write a function that can find the largest vertical stack\
    \ of consecutive rectangles you can make from the group. For example, if we're\
    \ given rectangles like so:\n    3 1 3 2 1\n    We can make stacks of size 3,\
    \ 1, 2 and 1:\n    3 1 3 2 1\n    3 1\n    2 1\n    2 1\n    This is a vertical\
    \ stack, so no rectangles may be \"horizontally\" or \"diagonally\" touching.\
    \ \n    # \n    You can assume that the rectangle sizes are always positive integers.\n\
    */\nstruct Height\n{\n    int value;\n    int index;\n};", "{\n    return n <\
    \ 3 ? n - 1 : fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}", "{\n    import\
    \ std.conv : to;\n    long a = 0, b = 0, c = 1, t = 0;\n    if (n <= 2)\n    {\n\
    \        return n - 1;\n    }\n    long start = 2;\n    while (start < n)\n  \
    \  {\n        t = a + b + c;\n        a = b;\n        b = c;\n        c = t;\n\
    \        start += 1;\n    }\n    return t;\n}", "{\n    if (n == 0)\n        return\
    \ 0;\n    else if (n == 1)\n        return 0;\n    else if (n == 2)\n        return\
    \ 1;\n    else\n        return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n}", "{\n\
    \    return n <= 2 ? n-1 : fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n}", "{\n\
    \    if (n < 2) \n        return 0;\n    if (n == 2) \n        return 1;\n   \
    \ if (n == 3) \n        return 2;\n    long[] arr = new long[n];\n    arr[0] =\
    \ 0;\n    arr[1] = 0;\n    arr[2] = 1;\n    for (int i = 3; i < n; i++) \n   \
    \ {\n        arr[i] = arr[i - 1] + arr[i - 2] + arr[i - 3];\n    }\n    return\
    \ arr[n - 1];\n}", "{\n    // Base case\n    if (n == 0) return 0;\n    if (n\
    \ == 1) return 0;\n    if (n == 2) return 1;\n    \n    // recursion case\n  \
    \  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n}", "{\n    if (n <= 1) return\
    \ 0;\n    if (n == 2) return 1;\n    long a = 0, b = 0, c = 1;\n    foreach (i;\
    \ 2 .. n) \n    {\n        long t = c;\n        c = a + b + c;\n        a = b;\n\
    \        b = t;\n    }\n    return c;\n}", "{\n    if (n == 0) return 0;\n   \
    \ if (n == 1) return 0;\n    if (n == 2) return 1;\n    long a = 0;\n    long\
    \ b = 0;\n    long c = 1;\n    long d = 0;\n    for (int i = 3; i <= n; i++)\n\
    \    {\n        d = a + b + c;\n        a = b;\n        b = c;\n        c = d;\n\
    \    }\n    return d;\n}", "{\n    if (n < 3)\n    {\n        return cast(long)max(0,\
    \ n-1);\n    }\n    return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n}", "{\n\
    \    // Implement your solution here\n    if (n == 0) return 0;\n    if (n ==\
    \ 1) return 0;\n    if (n == 2) return 1;\n    else return fibfib(n-1) + fibfib(n-2)\
    \ + fibfib(n-3);\n}", "{\n    //Your code here.\n    if (n<=1) return 0;\n   \
    \ if (n==2) return 1;\n    return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n}",
  "{\n    //We need to store values at the n-1, n-2, and n-3 indices, so we use a\
    \ tuple\n    Tuple!(long, long, long) previous = tuple(0, 0, 1);\n    long fib\
    \ = 0;\n    for(long i = 2; i <= n; i++)\n    {\n        //We start at 2 because\
    \ the previous tuple has already been initialized. We then add\n        // the\
    \ last 3 elements of the previous tuple and get our new value and set the tuple\n\
    \        // to its new value\n        fib = previous[0] + previous[1] + previous[2];\n\
    \        previous = tuple(previous[1], previous[2], fib);\n    }\n    return fib;\n\
    }", "{\n    if (n <= 1) \n        return 0;\n    if (n == 2) \n        return\
    \ 1;\n    return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n}", "{\n    if (n <=\
    \ 1)\n        return 0;\n    if (n == 2)\n        return 1;\n    long a = 0, b\
    \ = 0, c = 1;\n    while (n-- > 2) \n    {\n        long d = a + b + c;\n    \
    \    a = b;\n        b = c;\n        c = d;\n    }\n    return c;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
