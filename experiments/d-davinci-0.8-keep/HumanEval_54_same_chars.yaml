name: HumanEval_54_same_chars
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    Check if two words have\
  \ the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n\
  \    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc',\
  \ 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>>\
  \ same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz',\
  \ 'dddzzzzzzzddddabc')\n    False\n    \n*/\nbool same_chars(string s0, string s1)\
  \ \n"
tests: "unittest\n{\n    alias candidate = same_chars;\n\n    assert(candidate(\"\
  eabcdzzzz\", \"dddzzzzzzzddeddabc\") == true);\n    assert(candidate(\"abcd\", \"\
  dddddddabc\") == true);\n    assert(candidate(\"dddddddabc\", \"abcd\") == true);\n\
  \    assert(candidate(\"eabcd\", \"dddddddabc\") == false);\n    assert(candidate(\"\
  abcd\", \"dddddddabcf\") == false);\n    assert(candidate(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"\
  ) == false);\n    assert(candidate(\"aabb\", \"aaccc\") == false);\n}\nvoid main(){}"
completions: ["{\n    if (s0.length != s1.length) return false;\n    int[char] c0_counts\
    \ = counts(s0);\n    int[char] c1_counts = counts(s1);\n    foreach (char c; s0)\
    \ \n    {\n        if (c0_counts[c] != c1_counts[c]) return false;\n    }\n  \
    \  return true;\n}", "{\n    alias counts = Counts!char;", "{ \n    int[int] C0\
    \ = [ 0 : 'a', 1 : 'b', 2 : 'c', 3 : 'd', 4 : 'e', 5 : 'f', 6 : 'g', 7 : 'h',\
    \ 8 : 'i', 9 : 'j', 10 : 'k', 11 : 'l', 12 : 'm', 13 : 'n', 14 : 'o', 15 : 'p',\
    \ 16 : 'q', 17 : 'r', 18 : 's', 19 : 't', 20 : 'u', 21 : 'v', 22 : 'w', 23 : 'x',\
    \ 24 : 'y', 25 : 'z' ];\n    int[int] C1 = [ 0 : 'a', 1 : 'b', 2 : 'c', 3 : 'd',\
    \ 4 : 'e', 5 : 'f', 6 : 'g', 7 : 'h', 8 : 'i', 9 : 'j', 10 : 'k', 11 : 'l', 12\
    \ : 'm', 13 : 'n', 14 : 'o', 15 : 'p', 16 : 'q', 17 : 'r', 18 : 's', 19 : 't',\
    \ 20 : 'u', 21 : 'v', 22 : 'w', 23 : 'x', 24 : 'y', 25 : 'z' ];\n    int[int]\
    \ C2 = [ 0 : 'a', 1 : 'b', 2 : 'c', 3 : 'd', 4 : 'e', 5 : 'f', 6 : 'g', 7 : 'h',\
    \ 8 : 'i', 9 : 'j', 10 : 'k', 11 : 'l', 12 : 'm', 13 : 'n', 14 : 'o', 15 : 'p',\
    \ 16 : 'q', 17 : 'r', 18 : 's', 19 : 't', 20 : 'u', 21 : 'v', 22 : 'w', 23 : 'x',\
    \ 24 : 'y', 25 : 'z' ];\n    bool OK = true;\n    for (int i = 0; i < s0.length;\
    \ i++) \n    {\n        // AssertionError: s0 is not only alpha chars\n      \
    \  assert(isalpha(s0[i]));\n        int S0 = s0[i] - 'a';\n        if (++C0[S0]\
    \ == 1)", "{\n    auto l0 = s0.length;\n    auto l1 = s1.length;\n    if (l0 !=\
    \ l1) return false;\n    if (l0 == 0) return true;\n    immutable u0 = s0.toUpper;\n\
    \    immutable u1 = s1.toUpper;\n    immutable s0set = u0.toHashSet;\n    immutable\
    \ s1set = u1.toHashSet;\n    foreach (c; s0set) {\n        if (s1set.count(c)\
    \ != s0set.count(c)) return false;\n    }\n    return true;\n}", "{\n    auto\
    \ counts = map!(`a => int`);\n    foreach (c; s0)\n        counts[c]++;\n    foreach\
    \ (c; s1)\n        counts[c]--;\n    foreach (c; counts.byKey)\n        if (c.value\
    \ != 0) return false;\n    return true;\n}\n/*", "{ \n    int[string] cnts = [];\
    \ \n    foreach (c; s0) \n        cnts[c] += 1; \n    foreach (c; s1) \n     \
    \   cnts[c] -= 1; \n    foreach (c, i; cnts) \n        if (i != 0) \n        \
    \    return false; \n    return true; \n} ", "{\n    int n = s0.length;\n    int\
    \ m = s1.length;\n    int[] c0 = new int[256];\n    int[] c1 = new int[256];\n\
    \    foreach (wchar c; s0) c0[c]++;\n    foreach (wchar c; s1) c1[c]++;\n    for\
    \ (int i = 0; i < 256; i++)\n        if (c0[i] != c1[i]) return false;\n    return\
    \ true;\n}\n/*", "{\n    auto c0 = s0.dup;\n    auto c1 = s1.dup;\n    c0.sort;\n\
    \    c1.sort;\n    return c0 == c1;\n}", "{\n    int[] char_counter = new int[256];\n\
    \    foreach (c; s0) {\n        ++char_counter[c];\n    }\n    foreach (c; s1)\
    \ {\n        --char_counter[c];\n    }\n    foreach (c; char_counter) {\n    \
    \    if (c) return false;\n    }\n    return true;\n}", "{\n    dchar[uint] chars0\
    \ = new dchar[uint];\n    dchar[uint] chars1 = new dchar[uint];\n    foreach (dchar\
    \ c; s0)\n        chars0[c]++;\n    foreach (dchar c; s1)\n        chars1[c]++;\n\
    \    return chars0 == chars1;\n}", "{\n    assert(s0.length > 0);\n    assert(s1.length\
    \ > 0);\n    if (s0.length != s1.length) \n    {\n        return false;\n    }\n\
    \    return s0.tupleof.sort.idup.array == s1.tupleof.sort.idup.array;\n}\n/*",
  "{ \n    return sort(s0) == sort(s1);\n}", "{\n    Map!char m0;\n    foreach(c;\
    \ s0)\n        m0[c]++;\n    Map!char m1;\n    foreach(c; s1)\n        m1[c]++;\n\
    \    return m0 == m1;\n}", "{\n    if (s0.length!=s1.length)\n        return false;\n\
    \    int[string] counter;\n    foreach (ch; s0)\n        counter[ch]++;\n    foreach\
    \ (ch; s1)\n        counter[ch]--;\n    foreach (c; counter)\n        if (c!=0)\n\
    \            return false;\n    return true;\n}\n/*\n    Return the smallest number\
    \ that has the same chars as a given number.\n    >>> smallest_same_chars(12345)\n\
    \    12334\n    >>> smallest_same_chars(12334)\n    12334\n    >>> smallest_same_chars(500000)\n\
    \    44444\n    >>> smallest_same_chars(44444)\n    44444\n    >>> smallest_same_chars(10)\n\
    \    10\n    >>> smallest_same_chars(100)\n    100\n    >>> smallest_same_chars(1000)\n\
    \    999\n*/\nlong smallest_same_chars(long n)\n{\n    long res = n;\n    for\
    \ (int i=0; i<n.digits; i++)\n    {\n        int digit = n.at(i);\n        int\
    \ min = 9;\n        foreach(d; i..n.digits)\n        {\n            if (d==i)\n\
    \                continue;\n            int ndig = n.at(d);\n            if (ndig<min\
    \ && ndig>digit)\n                min = ndig;\n        }\n        if (min<9)\n\
    \        {\n            n.set(i, min);\n            n.set(n.indexOf(min), digit);\n\
    \            if (n<res)\n                res = n;\n        }\n    }\n    return\
    \ res;\n}\n/*\n    Calculate the number of possible rectangles given the number\
    \ of squares.\n    The number of possible rectangles can be calculated by\n  \
    \  rects = (N + 1) * N * (N - 1) * (N - 2) / 24\n    where N is the number of\
    \ squares.", "{\n    ulong[] cnts0 = new ulong[256];\n    ulong[] cnts1 = new\
    \ ulong[256];\n    foreach (ref ulong e; cnts0) e = 0;\n    foreach (ref ulong\
    \ e; cnts1) e = 0;\n    foreach (c; s0) cnts0[c]++;\n    foreach (c; s1) cnts1[c]++;\n\
    \    foreach (ref ulong e; cnts0) \n    {\n        if (e != cnts1[i]) return false;\n\
    \    }\n    return true;\n}", "{\n    uint[] bins0 = [0L, 0L, 0L, 0L, 0L, 0L,\
    \ 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L,\
    \ 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L,\
    \ 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L,\
    \ 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L,\
    \ 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L,\
    \ 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L,\
    \ 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L,\
    \ 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L,\
    \ 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0", "{\n    s0 = sort(s0);\n    s1 = sort(s1);\n\
    \    return s0 == s1;\n}\n/*", "{\n    auto c0 = s0.byCodepoint;\n    auto c1\
    \ = s1.byCodepoint;\n    int count0 = 0;\n    int count1 = 0;\n    foreach(dchar\
    \ c; c0)\n    {\n        count0 += c;\n    }\n    foreach(dchar c; c1)\n    {\n\
    \        count1 += c;\n    }\n    if(count0 != count1)\n    {\n        return\
    \ false;\n    }\n    return true;\n}", "{\n    alias S0 = SortedRange!(s0, \"\
    a\", \"z\");\n    alias S1 = SortedRange!(s1, \"a\", \"z\");\n    return S0.save\
    \ == S1.save;\n}", "{\n    auto cs0 = wchar.encode(s0);\n    auto cs1 = wchar.encode(s1);\n\
    \    auto c0s = sort(cs0);\n    auto c1s = sort(cs1);\n    return c0s == c1s;\n\
    }"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
