name: HumanEval_74_total_match
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function that accepts\
  \ two lists of strings and returns the list that has \n    total number of chars\
  \ in the all strings of the list less than the other list.\n\n    if the two lists\
  \ have the same number of chars, return the first list.\n\n    Examples\n    total_match([],\
  \ []) \u279E []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n\
  \    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279E ['hi',\
  \ 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi',\
  \ 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279E ['4']\n    \n\
  */\nstring[] total_match(string[] lst1, string[] lst2) \n"
tests: "unittest\n{\n    alias candidate = total_match;\n\n    assert(candidate([],\
  \ []) == []);\n    assert(candidate([\"hi\", \"admin\"], [\"hi\", \"hi\"]) == [\"\
  hi\", \"hi\"]);\n    assert(candidate([\"hi\", \"admin\"], [\"hi\", \"hi\", \"admin\"\
  , \"project\"]) == [\"hi\", \"admin\"]);\n    assert(candidate([\"4\"], [\"1\",\
  \ \"2\", \"3\", \"4\", \"5\"]) == [\"4\"]);\n    assert(candidate([\"hi\", \"admin\"\
  ], [\"hI\", \"Hi\"]) == [\"hI\", \"Hi\"]);\n    assert(candidate([\"hi\", \"admin\"\
  ], [\"hI\", \"hi\", \"hi\"]) == [\"hI\", \"hi\", \"hi\"]);\n    assert(candidate([\"\
  hi\", \"admin\"], [\"hI\", \"hi\", \"hii\"]) == [\"hi\", \"admin\"]);\n    assert(candidate([],\
  \ [\"this\"]) == []);\n    assert(candidate([\"this\"], []) == []);\n}\nvoid main(){}"
completions: ["{\n    int lst1Chars = 0;\n    int lst2Chars = 0;\n    foreach(var\
    \ word; lst1)\n    {\n        lst1Chars += word.length;\n    }\n    foreach(var\
    \ word; lst2)\n    {\n        lst2Chars += word.length;\n    }\n    if(lst1Chars\
    \ < lst2Chars)\n    {\n        return lst1;\n    }\n    else if(lst1Chars > lst2Chars)\n\
    \    {\n        return lst2;\n    }\n    else\n    {\n        return lst1;\n \
    \   }\n}", "{\n    string[] less = lst1.length < lst2.length ? lst1 : lst2;\n\
    \    string[] more = lst1.length > lst2.length ? lst1 : lst2;\n    int total1\
    \ = lst1.reduce!((a, b) => a + b.length)();\n    int total2 = lst2.reduce!((a,\
    \ b) => a + b.length)();\n    return (total1 < total2) ? less : more;\n}", "{\n\
    \    if(lst1.length == 0 && lst2.length == 0) return lst1;\n    if(lst1.length\
    \ == 0 && lst2.length != 0) return lst2;\n    if(lst1.length != 0 && lst2.length\
    \ == 0) return lst1;\n    int total_lst1 = 0;\n    int total_lst2 = 0;\n    foreach(var\
    \ i; lst1) total_lst1 += i.length;\n    foreach(var i; lst2) total_lst2 += i.length;\n\
    \    return total_lst1 < total_lst2 ? lst1 : lst2;\n}", "{\n    // best1 = max(lst1.joined.len,\
    \ lst2.joined.len);\n    // best2 = min(lst1.joined.len, lst2.joined.len);\n \
    \   // best1 = max(lst1.joined.len, lst2.joined.len);\n    // best2 = min(lst1.joined.len,\
    \ lst2.joined.len);\n    // best2 = tuple(lst1.joined.len, lst2.joined.len).min;\n\
    \    // best1 = tuple(lst1.joined.len, lst2.joined.len).max;\n    // best2 = tuple(lst1.joined.len,\
    \ lst2.joined.len).min;\n    // best1 = tuple(lst1.joined.len, lst2.joined.len).max;\n\
    \    // return lst1.joined.len < lst2.joined.len ? lst1 : lst2;\n    // return\
    \ lst1.joined.len < lst2.joined.len ? lst1 : lst2;\n    return lst1.joined.len\
    \ < lst2.joined.len ? lst1 : lst2;\n    // return lst1.joined.len < lst2.joined.len\
    \ ? lst1 : lst2;\n    // return lst1.joined.len < lst2.joined.len ? lst1 : lst2;\n\
    \    // return lst1.joined.len < lst2.joined.len ? lst1 : lst2;\n    // return\
    \ lst1.joined.len < lst2.joined.len ? lst1 : lst2;\n    // return lst1.joined.len\
    \ < lst2.joined.len ? lst1 : lst2;\n    // return lst1.joined.len < lst2.joined.len\
    \ ? lst1 : lst2;\n    // return lst1.joined.len < lst2.joined.len ? lst1 : lst2;\n\
    \    // return lst1.joined.len < lst2.joined.len ? lst1 : lst2;\n    //", '{',
  "{\n    if(lst1.length>lst2.length)\n    {\n        return lst2;\n    }\n    else\
    \ if(lst1.length<lst2.length)\n    {\n        return lst1;\n    }\n    else\n\
    \    {\n        int a=lst1.sum!((string x)=>x.length);\n        int b=lst2.sum!((string\
    \ x)=>x.length);\n        if(a>b)\n        {\n            return lst2;\n     \
    \   }\n        else if(a<b)\n        {\n            return lst1;\n        }\n\
    \        else\n        {\n            return lst1;\n        }\n    }\n}", "{\n\
    \    int lst1_total = 0;\n    int lst2_total = 0;\n    foreach(el; lst1)\n   \
    \ {\n        lst1_total += el.length;\n    }\n    foreach(el; lst2)\n    {\n \
    \       lst2_total += el.length;\n    }\n    if(lst1_total > lst2_total)\n   \
    \ {\n        return lst2;\n    }\n    else if(lst1_total < lst2_total)\n    {\n\
    \        return lst1;\n    }\n    else\n    {\n        return lst1;\n    }\n}",
  "{\n    if(lst1.length == 0 && lst2.length == 0)\n        return lst1;\n    if(lst1.length\
    \ == 0)\n        return lst2;\n    if(lst2.length == 0)\n        return lst1;\n\
    \    int x = 0;\n    int y = 0;\n    foreach(s; lst1)\n        x += s.length;\n\
    \    foreach(s; lst2)\n        y += s.length;\n    if(x < y)\n        return lst1;\n\
    \    if(y < x)\n        return lst2;\n    return lst1;\n}", "{\n    double total_chars_lst1\
    \ = 0;\n    double total_chars_lst2 = 0;\n    foreach(element; lst1)\n    {\n\
    \        total_chars_lst1 += element.length;\n    }\n    foreach(element; lst2)\n\
    \    {\n        total_chars_lst2 += element.length;\n    }\n    if(total_chars_lst1\
    \ > total_chars_lst2)\n    {\n        return lst2;\n    }\n    else if(total_chars_lst1\
    \ < total_chars_lst2)\n    {\n        return lst1;\n    }\n    else\n    {\n \
    \       return lst1;\n    }\n}", "{\n    if(lst1.length > lst2.length)\n     \
    \   return lst2;\n    if(lst1.length < lst2.length)\n        return lst1;\n  \
    \  int lst1Chars = 0;\n    int lst2Chars = 0;\n    foreach(i; lst1)\n        lst1Chars\
    \ += i.length;\n    foreach(i; lst2)\n        lst2Chars += i.length;\n    if(lst1Chars\
    \ > lst2Chars)\n        return lst2;\n    return lst1;\n}", "{\n    int chars1\
    \ = 0;\n    int chars2 = 0;\n    foreach(string str; lst1)\n    {\n        chars1\
    \ += str.length;\n    }\n    foreach(string str; lst2)\n    {\n        chars2\
    \ += str.length;\n    }\n    if(chars1 < chars2)\n    {\n        return lst1;\n\
    \    }\n    else if(chars2 < chars1)\n    {\n        return lst2;\n    }\n   \
    \ else\n    {\n        return lst1;\n    }\n}", "{\n    int count1 = 0;\n    int\
    \ count2 = 0;\n    foreach(string c; lst1)\n    {\n        count1 += c.length;\n\
    \    }\n    foreach(string c; lst2)\n    {\n        count2 += c.length;\n    }\n\
    \    return count1 < count2 ? lst1 : count1 > count2 ? lst2 : lst1;\n}", "{\n\
    \    int total1 = 0;\n    int total2 = 0;\n    for(int i = 0; i < lst1.length;\
    \ i++)\n    {\n        total1 += lst1[i].length;\n    }\n    for(int i = 0; i\
    \ < lst2.length; i++)\n    {\n        total2 += lst2[i].length;\n    }\n    return\
    \ total1 < total2 ? lst1 : lst2;\n}", "{\n    return (lst1.length < lst2.length)\
    \ ? lst1 : lst2;\n}", "{\n    int total1 = 0;\n    int total2 = 0;\n    foreach(string\
    \ item; lst1)\n    {\n        total1 += item.length;\n    }\n    foreach(string\
    \ item; lst2)\n    {\n        total2 += item.length;\n    }\n    if(total1 ==\
    \ total2)\n    {\n        return lst1;\n    }\n    if(total1 < total2)\n    {\n\
    \        return lst1;\n    }\n    else\n    {\n        return lst2;\n    }\n}",
  "{\n    int res1 = lst1.map!(a => a.length).sum();\n    int res2 = lst2.map!(a =>\
    \ a.length).sum();\n    if(res1 < res2) return lst1;\n    if(res1 > res2) return\
    \ lst2;\n    return lst1;\n}", "{\n    int length1 = 0;\n    int length2 = 0;\n\
    \    foreach(item; lst1)\n    {\n        length1 += item.length;\n    }\n    foreach(item;\
    \ lst2)\n    {\n        length2 += item.length;\n    }\n    return length1 < length2\
    \ ? lst1 : lst2;\n}", "{\n    auto lst1_total = reduce!((a, b) => a + b.length)(0,\
    \ lst1);\n    auto lst2_total = reduce!((a, b) => a + b.length)(0, lst2);\n  \
    \  return lst1_total < lst2_total ? lst1 : lst2;\n}", "{\n    int len1 = 0;\n\
    \    int len2 = 0;\n    foreach(element; lst1) len1 += element.length;\n    foreach(element;\
    \ lst2) len2 += element.length;\n    return (len1 < len2 ? lst1 : lst2);\n}",
  "{\n    bool isLongest = false;\n    int long1 = 0;\n    int long2 = 0;\n    string[]\
    \ result;\n    foreach(str1; lst1)\n    {\n        long1 = long1 + str1.length;\n\
    \    }\n    foreach(str2; lst2)\n    {\n        long2 = long2 + str2.length;\n\
    \    }\n    if(long1 < long2)\n    {\n        isLongest = true;\n    }\n    result\
    \ = (isLongest ? lst1 : lst2);\n    return result;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
