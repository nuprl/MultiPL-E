name: HumanEval_41_car_race_collision
language: d
results:
- program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long left, right,\
    \ i, j, d, res;\n    left = n;\n    right = n;\n    res = 0;\n    i = 0;\n   \
    \ while(i < left)\n    {\n        j = 0;\n        while(j < right)\n        {\n\
    \            d = car_distance(i, j);\n            if(d == 0)\n            {\n\
    \                res = res + 1;\n            }\n            else if(d < 0)\n \
    \           {\n                left = left - 1;\n            }\n            else\n\
    \            {\n                right = right - 1;\n            }\n          \
    \  j = j + 1;\n        }\n        i = i + 1;\n    }\n    return res;\n}\nlong\
    \ car_distance(long i, long j)\n{\n    long car_speed, c0, c1, d;\n    car_speed\
    \ = 5;\n    c0 = car_speed * i;\n    c1 = car_speed * j;\n    d = c0 - c1;\n \
    \   return d;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n \
    \   assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp1tmvhhda.d(59): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e75]\\n??:? void tmp1tmvhhda.__unittest_L55_C1()\
    \ [0x427b60]\\n??:? void tmp1tmvhhda.__modtest() [0x427bf8]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb9b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42aa2e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fbc1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430070]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fb4d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aa05]\\n??:? runModuleUnitTests [0x42b971]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4282c4]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42824b]\\n??:? _d_run_main [0x4281b6]\\n??:? main [0x427c0b]\\\
    n??:? __libc_start_main [0xe428d554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    return n * (n\
    \ - 1) / 2;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n   \
    \ assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp6_swvet8.d(23): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427d5d]\\n??:? void tmp6_swvet8.__unittest_L19_C1()\
    \ [0x427a44]\\n??:? void tmp6_swvet8.__modtest() [0x427adc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42ba83]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a916]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42faa9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff58]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fa35]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a8ed]\\n??:? runModuleUnitTests [0x42b859]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4281ac]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428133]\\n??:? _d_run_main [0x42809e]\\n??:? main [0x427aef]\\\
    n??:? __libc_start_main [0x1b242554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    real[long] left_to_right;\n\
    \    real[long] right_to_left;\n    long count;\n    for (long i = 0; i < n; i++)\
    \ \n    {\n        left_to_right[i] = uniform_random() / real(n);\n        right_to_left[i]\
    \ = uniform_random() / real(n);\n    }\n    merge_sort!(\"a < b\")(left_to_right);\n\
    \    merge_sort!(\"a < b\")(right_to_left);\n    long i = 0;\n    long j = 0;\n\
    \    while (i < n && j < n) \n    {\n        if (left_to_right[i] < right_to_left[j])\
    \ \n        {\n            count += j;\n            i++;\n        } \n       \
    \ else \n        {\n            j++;\n        }\n    }\n    return count;\n}\n\
    unittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmph0fzc4n7.d(22): Error: undefined identifier `uniform_random`\\\
    n/tmp/tmph0fzc4n7.d(23): Error: undefined identifier `uniform_random`\\n/tmp/tmph0fzc4n7.d(25):\
    \ Error: template instance `merge_sort!\"a < b\"` template `merge_sort` is not\
    \ defined\\n/tmp/tmph0fzc4n7.d(26): Error: template instance `merge_sort!\"a <\
    \ b\"` template `merge_sort` is not defined\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmph0fzc4n7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    if (n <= 1)\n\
    \    {\n        return 0;\n    }\n    // Each car generates a unique key.\n  \
    \  long[] keys = new long[n];\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3n9s_vpj.d(23): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3n9s_vpj.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long a[n]; //\
    \ a[i] is the position of the ith car\n    long pos;\n    long ret = 0;\n    long\
    \ i;\n    long j;\n    iota(a, a + n, 1); // a[i] = i\n    for (i = 0; i < n;\
    \ i++) {\n        // Pick a random number for the position of the car moving left\
    \ to right\n        pos = uniform(0, n + 1);\n        // See how many collisions\
    \ that car has with the cars moving right to left\n        for (j = 0; j < n;\
    \ j++) {\n            if (a[j] > pos)\n                ret++;\n        }\n   \
    \ }\n    return ret;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpf8e01j5v.d(17): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[n] a`\\n/tmp/tmpf8e01j5v.d(17): Error: variable `n` cannot be read\
    \ at compile time\\n/tmp/tmpf8e01j5v.d(22): Error: undefined identifier `iota`\\\
    n/tmp/tmpf8e01j5v.d(25): Error: undefined identifier `uniform`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf8e01j5v.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long a[n];\n\
    \    long b[n];\n    foreach (i, n)\n    {\n        a[i] = cast(long)random()\
    \ + 10000000;\n        b[i] = cast(long)random() + 10000000;\n    }\n    long\
    \ count = 0;\n    foreach (i, n)\n    {\n        foreach (j, n)\n        {\n \
    \           if (a[i] > b[j])\n            {\n                count++;\n      \
    \      }\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate\
    \ = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n    assert(candidate(3L)\
    \ == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L) == 64L);\n\
    \    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpu9bftp3y.d(17): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[n] a`\\n/tmp/tmpu9bftp3y.d(18): Deprecation: instead of C-style\
    \ syntax, use D-style syntax `long[n] b`\\n/tmp/tmpu9bftp3y.d(19): Error: no identifier\
    \ for declarator `n`\\n/tmp/tmpu9bftp3y.d(19): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmpu9bftp3y.d(24): Error: found `long` when expecting `)`\\n/tmp/tmpu9bftp3y.d(25):\
    \ Error: no identifier for declarator `n`\\n/tmp/tmpu9bftp3y.d(25): Error: found\
    \ `)` when expecting `;`\\n/tmp/tmpu9bftp3y.d(27): Error: no identifier for declarator\
    \ `n`\\n/tmp/tmpu9bftp3y.d(27): Error: found `)` when expecting `;`\\n/tmp/tmpu9bftp3y.d(34):\
    \ Error: found `}` when expecting `)`\\n/tmp/tmpu9bftp3y.d(37): Error: found `unittest`\
    \ when expecting `)`\\n/tmp/tmpu9bftp3y.d(47): Error: found `End of File` when\
    \ expecting `}` following compound statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpu9bftp3y.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    auto line_length\
    \ = to!double(n)*3;\n    auto max_x = to!double(n)*2.9;\n    auto min_x = -max_x;\n\
    \    auto max_speed = to!double(n)*1.4;\n    auto min_speed = -max_speed;\n  \
    \  //initialize random number generator with random seed\n    RandomNumberGenerator\
    \ rng;\n    rng.seed(unpredictableSeed);\n    //initialize the cars\n    struct\
    \ Car { double x; double speed; }\n    //set x values for cars going left to right\n\
    \    for(auto ref c : moving_left) \n    {\n        c.x = rng.get!double(min_x,\
    \ max_x);\n        c.speed = rng.get!double(min_speed, max_speed);\n    }\n  \
    \  //set x values for cars going right to left\n    for(auto ref c : moving_right)\
    \ \n    {\n        c.x = rng.get!double(min_x, max_x);\n        c.speed = rng.get!double(min_speed,\
    \ max_speed);\n    }\n    //keep track of the number of collisions\n    long collision_count\
    \ = 0;\n    //let the cars move until they are all way past each other\n    while(true)\
    \ \n    {\n        bool collision_happened = false;\n        //for each car moving\
    \ left to right\n        for(size_t i = 0; i < moving_left.length; i++) \n   \
    \     {\n            auto ref c = moving_left[i];\n            //for each car\
    \ moving right to left\n            for(size_t j = 0; j < moving_right.length;\
    \ j++) \n            {\n                auto ref d = moving_right[j];\n      \
    \          //check if the cars collided\n                if((c.x - d.x)*(c.x -\
    \ d.x) < 0.01) \n                {\n                    collision_happened = true;\n\
    \                    collision_count++;\n                }\n            }\n  \
    \      }\n        //if no collision happened, break out of the loop\n        if(!collision_happened)\
    \ \nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6_wtnug9.d(28): Error: no identifier for declarator `c`\\n/tmp/tmp6_wtnug9.d(28):\
    \ Error: expression expected, not `:`\\n/tmp/tmp6_wtnug9.d(28): Error: found `moving_left`\
    \ when expecting `;` following `for` condition\\n/tmp/tmp6_wtnug9.d(34): Error:\
    \ no identifier for declarator `c`\\n/tmp/tmp6_wtnug9.d(34): Error: expression\
    \ expected, not `:`\\n/tmp/tmp6_wtnug9.d(34): Error: found `moving_right` when\
    \ expecting `;` following `for` condition\\n/tmp/tmp6_wtnug9.d(63): Error: found\
    \ `unittest` instead of statement\\n/tmp/tmp6_wtnug9.d(73): Error: found `End\
    \ of File` when expecting `}` following compound statement\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6_wtnug9.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    if (n < 1) return\
    \ 0;\n    // count of collision\n    long c = 0;\n    // car positions\n    long[]\
    \ pos = new long[2*n];\n    // car velocities\n    long[] vel = new long[2*n];\n\
    \    // generate the cars\n    for (long i = 0; i < n; i++) \n    {\n        pos[i]\
    \ = 100 * (i + 1);\n        vel[i] = 1;\n        pos[i + n] = -100 * (i + 1);\n\
    \        vel[i + n] = -1;\n    }\n    // simulate\n    for (long t = 0; t < 1000;\
    \ t++) \n    {\n        // iterate over all possible pairs of cars\n        for\
    \ (long i = 0; i < 2 * n; i++) \n        {\n            for (long j = i + 1; j\
    \ < 2 * n; j++) \n            {\n                // check if they are going in\
    \ opposite directions\n                if (vel[i] != vel[j]) \n              \
    \  {\n                    // if they are on each other,  then there's a collision\n\
    \                    if (pos[i] == pos[j]) \n                    {\n         \
    \               c++;\n                    }\n                }\n            }\n\
    \        }\n        // update cars' positions\n        for (long i = 0; i < 2\
    \ * n; i++) \n        {\n            pos[i] += vel[i];\n        }\n    }\n   \
    \ return c;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n   \
    \ assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp3kz9d502.d(63): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4282d5]\\n??:? void tmp3kz9d502.__unittest_L59_C1()\
    \ [0x427fbc]\\n??:? void tmp3kz9d502.__modtest() [0x428054]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c2d3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b166]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4303f1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x4308a0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43037d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b13d]\\n??:? runModuleUnitTests [0x42c0a9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428798]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42871f]\\n??:? _d_run_main [0x42868a]\\n??:? main [0x428067]\\\
    n??:? __libc_start_main [0xe32bb554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{ \n  auto carsL =\
    \ new int[n];\n  auto carsR = new int[n];\n  for (int i = 0; i < n; i++)\n   \
    \ carsL[i] = i + 1;\n  for (int i = 0; i < n; i++)\n    carsR[i] = n - i;\n  sort(carsL.ptr,\
    \ carsL.ptr + n);\n  sort(carsR.ptr, carsR.ptr + n);\n  int collisions = 0;\n\
    \  for (int i = 0; i < n; i++)\n    if (carsL[i] == carsR[i])\n      collisions++;\n\
    \  return collisions;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc68mhzmh.d(22): Error: cannot implicitly convert expression `n\
    \ - cast(long)i` of type `long` to `int`\\n/tmp/tmpc68mhzmh.d(23): Error: undefined\
    \ identifier `sort`, did you mean function `sqrt`?\\n/tmp/tmpc68mhzmh.d(24): Error:\
    \ undefined identifier `sort`, did you mean function `sqrt`?\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc68mhzmh.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long result;\n\
    \    long[] left_cars;\n    long[] right_cars;\n    long i, j;\n    i = 0;\n \
    \   left_cars = new long[n];\n    right_cars = new long[n];\n    while (i < n)\
    \ {\n        left_cars[i] = random();\n        right_cars[i] = random();\n   \
    \     i = i + 1;\n    }\n    result = 0;\n    i = 0;\n    while (i < n) {\n  \
    \      j = 0;\n        while (j < n) {\n            if (left_cars[i] < right_cars[j])\
    \ {\n                result = result + 1;\n            }\n            j = j +\
    \ 1;\n        }\n        i = i + 1;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n\
    \    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L)\
    \ == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8266rk74.d(25): Error: undefined identifier `random`\\n/tmp/tmp8266rk74.d(26):\
    \ Error: undefined identifier `random`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp8266rk74.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    if (n <= 1)\n\
    \    {\n        return 0;\n    }\n    else\n    {\n        long x = 0;\n     \
    \   long y = n - 1;\n        long diff = x - y;\n        return diff * (diff -\
    \ 1) / 2;\n    }\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n\
    \    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpc9qnqr1f.d(33): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427d75]\\n??:? void tmpc9qnqr1f.__unittest_L29_C1()\
    \ [0x427a5c]\\n??:? void tmpc9qnqr1f.__modtest() [0x427af4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42ba9b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a92e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fac1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff70]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fa4d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a905]\\n??:? runModuleUnitTests [0x42b871]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4281c4]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42814b]\\n??:? _d_run_main [0x4280b6]\\n??:? main [0x427b07]\\\
    n??:? __libc_start_main [0x157f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    return (n*(n-1))/2;\n\
    }\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpu2q6yco9.d(23): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427d5d]\\n??:? void tmpu2q6yco9.__unittest_L19_C1()\
    \ [0x427a44]\\n??:? void tmpu2q6yco9.__modtest() [0x427adc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42ba83]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a916]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42faa9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff58]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fa35]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a8ed]\\n??:? runModuleUnitTests [0x42b859]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4281ac]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428133]\\n??:? _d_run_main [0x42809e]\\n??:? main [0x427aef]\\\
    n??:? __libc_start_main [0x32295554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    return n * (n\
    \ - 1) / 2;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n   \
    \ assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp4egjiaug.d(23): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427d5d]\\n??:? void tmp4egjiaug.__unittest_L19_C1()\
    \ [0x427a44]\\n??:? void tmp4egjiaug.__modtest() [0x427adc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42ba83]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a916]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42faa9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff58]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fa35]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a8ed]\\n??:? runModuleUnitTests [0x42b859]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4281ac]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428133]\\n??:? _d_run_main [0x42809e]\\n??:? main [0x427aef]\\\
    n??:? __libc_start_main [0x32c65554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long collision_number\
    \ = 0;\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n;\
    \ j++)\n        {\n            if (abs(i - j) < n/2)\n            {\n        \
    \        collision_number++;\n            }\n        }\n    }\n    return collision_number;\n\
    }\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp6ri_qp96.d(34): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427dfd]\\n??:? void tmp6ri_qp96.__unittest_L30_C1()\
    \ [0x427ad4]\\n??:? void tmp6ri_qp96.__modtest() [0x427b80]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb23]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9b6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb49]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42fff8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fad5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a98d]\\n??:? runModuleUnitTests [0x42b8f9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42824c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281d3]\\n??:? _d_run_main [0x42813e]\\n??:? main [0x427b93]\\\
    n??:? __libc_start_main [0x71385554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n  long num_collisions\
    \ = 0;\n  long i, j;\n  float left_to_right[n];\n  float right_to_left[n];\n \
    \ float multiplier = 1.0 / (float)n;\n  float min, max;\n  float left_car, right_car;\n\
    \  float two_n = (float)n * 2.0;\n  float one_over_two_n = 1.0 / two_n;\n  float\
    \ n_over_two = (float)n / 2.0;\n  float n_over_two_minus_1 = n_over_two - 1.0;\n\
    \  for (i = 0; i < n; i++) {\n    left_to_right[i] = (i + 0.5) * multiplier;\n\
    \    right_to_left[i] = (1.0 - (i + 0.5) * multiplier);\n  }\n  for (i = 0; i\
    \ < n; i++) {\n    left_car = left_to_right[i];\n    right_car = right_to_left[i];\n\
    \    if (left_car > right_car) {\n      num_collisions++;\n    }\n    min = min(left_car,\
    \ right_car);\n    max = max(left_car, right_car);\n    for (j = 1; j < n_over_two;\
    \ j++) {\n      left_car = min + j * one_over_two_n;\n      right_car = max -\
    \ j * one_over_two_n;\n      if (left_car > right_car) {\n        num_collisions++;\n\
    \      }\n    }\n  }\n  return num_collisions;\n}\nunittest\n{\n    alias candidate\
    \ = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n    assert(candidate(3L)\
    \ == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L) == 64L);\n\
    \    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2nhpf4qj.d(19): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `float[n] left_to_right`\\n/tmp/tmp2nhpf4qj.d(20): Deprecation: instead\
    \ of C-style syntax, use D-style syntax `float[n] right_to_left`\\n/tmp/tmp2nhpf4qj.d(21):\
    \ Error: C style cast illegal, use `cast(float)n`\\n/tmp/tmp2nhpf4qj.d(24): Error:\
    \ C style cast illegal, use `cast(float)n`\\n/tmp/tmp2nhpf4qj.d(26): Error: C\
    \ style cast illegal, use `cast(float)n`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp2nhpf4qj.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n\tlong count=0;\n\
    \tfor(long i=0;i<n;i++)\n\t{\n\t\tfor(long j=i+1;j<n;j++)\n\t\t{\n\t\t\tif(i<n/2\
    \ && j>=n/2)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n\
    }\n\t//return 0;\nunittest\n{\n    alias candidate = car_race_collision;\n\n \
    \   assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp5n9mbu0m.d(35): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427dad]\\n??:? void tmp5n9mbu0m.__unittest_L31_C1()\
    \ [0x427a98]\\n??:? void tmp5n9mbu0m.__modtest() [0x427b30]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bad3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a966]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42faf9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ffa8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fa85]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a93d]\\n??:? runModuleUnitTests [0x42b8a9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4281fc]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428183]\\n??:? _d_run_main [0x4280ee]\\n??:? main [0x427b43]\\\
    n??:? __libc_start_main [0x71ba8554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    // Cars that\
    \ are left to right.  Each element tells us the distance between \n    // the\
    \ car and the starting line\n    auto l2r = new long[n];\n    // Cars that are\
    \ right to left.  Each element tells us the distance between \n    // the car\
    \ and the starting line\n    auto r2l = new long[n];\n    // Filling up the arrays\n\
    \    for (long i = 0; i < n; i++) {\n        l2r[i] = i;\n        r2l[i] = n -\
    \ i;\n    }\n    // Simulating the race\n    long number_of_collisions = 0;\n\
    \    // Two cars will collide only if their distances from the starting line\n\
    \    // is equal.  That is, only if l2r[i] = r2l[j].\n    // So, we only need\
    \ to loop through the arrays one time.\n    for (long i = 0; i < n; i++) {\n \
    \       // If l2r[i] = r2l[j], then |l2r[i] - r2l[j]| = 0.\n        // We look\
    \ for the number of elements in r2l where the difference between\n        // the\
    \ element and l2r[i] is zero.\n        number_of_collisions += count_if(r2l, r2l\
    \ + n, [&](long val) {return abs(val - l2r[i]) == 0;});\n    }\n    return number_of_collisions;\n\
    }\n```\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprryeke73.d(37): Error: expression expected, not `]`\\n/tmp/tmprryeke73.d(37):\
    \ Error: found `val` when expecting `.` following long\\n/tmp/tmprryeke73.d(37):\
    \ Error: found `)` when expecting identifier following `long`.\\n/tmp/tmprryeke73.d(37):\
    \ Error: found `{` when expecting `,`\\n/tmp/tmprryeke73.d(37): Error: expression\
    \ expected, not `return`\\n/tmp/tmprryeke73.d(37): Error: found `abs` when expecting\
    \ `,`\\n/tmp/tmprryeke73.d(37): Error: found `;` when expecting `,`\\n/tmp/tmprryeke73.d(37):\
    \ Error: expression expected, not `}`\\n/tmp/tmprryeke73.d(37): Error: found `;`\
    \ when expecting `,`\\n/tmp/tmprryeke73.d(38): Error: expression expected, not\
    \ `}`\\n/tmp/tmprryeke73.d(39): Error: found `return` when expecting `,`\\n/tmp/tmprryeke73.d(39):\
    \ Error: found `;` when expecting `,`\\n/tmp/tmprryeke73.d(40): Error: expression\
    \ expected, not `}`\\n/tmp/tmprryeke73.d(41): Error: found `\"\"` when expecting\
    \ `,`\\n/tmp/tmprryeke73.d(41): Error: unterminated string constant starting at\
    \ /tmp/tmprryeke73.d(41)\\n/tmp/tmprryeke73.d(52): Error: found `End of File`\
    \ when expecting `,`\\n/tmp/tmprryeke73.d(37): Error: found `End of File` when\
    \ expecting `]`\\n/tmp/tmprryeke73.d(52): Error: found `End of File` when expecting\
    \ `,`\\n/tmp/tmprryeke73.d(52): Error: found `End of File` when expecting `)`\\\
    n/tmp/tmprryeke73.d(52): Error: found `End of File` when expecting `;` following\
    \ statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprryeke73.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n\treturn n*(n-1)/2;\n\
    }\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpp9qn375o.d(23): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427d5d]\\n??:? void tmpp9qn375o.__unittest_L19_C1()\
    \ [0x427a44]\\n??:? void tmpp9qn375o.__modtest() [0x427adc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42ba83]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a916]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42faa9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff58]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fa35]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a8ed]\\n??:? runModuleUnitTests [0x42b859]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4281ac]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428133]\\n??:? _d_run_main [0x42809e]\\n??:? main [0x427aef]\\\
    n??:? __libc_start_main [0x2bbd554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long count =\
    \ 0;\n    foreach (long i; 0 .. n) {\n        foreach (long j; 0 .. n) {\n   \
    \         count += i == j;\n        }\n    }\n    return count;\n}\nunittest\n\
    {\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n\
    \    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L)\
    \ == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpnz1upgp3.d(29): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427db5]\\n??:? void tmpnz1upgp3.__unittest_L25_C1()\
    \ [0x427a9c]\\n??:? void tmpnz1upgp3.__modtest() [0x427b34]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42badb]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a96e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb01]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ffb0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fa8d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a945]\\n??:? runModuleUnitTests [0x42b8b1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428204]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42818b]\\n??:? _d_run_main [0x4280f6]\\n??:? main [0x427b47]\\\
    n??:? __libc_start_main [0xf5886554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{ \n    return n *\
    \ (n - 1) / 2;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n\
    \    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp43xqo8qh.d(23): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427d5d]\\n??:? void tmp43xqo8qh.__unittest_L19_C1()\
    \ [0x427a44]\\n??:? void tmp43xqo8qh.__modtest() [0x427adc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42ba83]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a916]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42faa9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff58]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fa35]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a8ed]\\n??:? runModuleUnitTests [0x42b859]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4281ac]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428133]\\n??:? _d_run_main [0x42809e]\\n??:? main [0x427aef]\\\
    n??:? __libc_start_main [0xf6ddb554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
