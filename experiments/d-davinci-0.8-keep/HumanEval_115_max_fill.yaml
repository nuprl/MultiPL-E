name: HumanEval_115_max_fill
language: d
prompt: "import std.math;\n/*\n\n    You are given a rectangular grid of wells. Each\
  \ row represents a single well,\n    and each 1 in a row represents a single unit\
  \ of water.\n    Each well has a corresponding bucket that can be used to extract\
  \ water from it, \n    and all buckets have the same capacity.\n    Your task is\
  \ to use the buckets to empty the wells.\n    Output the number of times you need\
  \ to lower the buckets.\n\n    Example 1:\n        Input: \n            grid : [[0,0,1,0],\
  \ [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n        Output: 6\n\n\
  \    Example 2:\n        Input: \n            grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1],\
  \ [0,1,1,1]]\n            bucket_capacity : 2\n        Output: 5\n    \n    Example\
  \ 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n            bucket_capacity\
  \ : 5\n        Output: 0\n\n    Constraints:\n        * all wells have the same\
  \ length\n        * 1 <= grid.length <= 10^2\n        * 1 <= grid[:,1].length <=\
  \ 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <= capacity <= 10\n    \n*/\n\
  long max_fill(long[][] grid, long capacity) \n"
tests: "unittest\n{\n    alias candidate = max_fill;\n\n    assert(candidate([[0L,\
  \ 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
  \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
  \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
  \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L,\
  \ 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
completions: ["{\n    long max_height = 0;\n    long total_fill = 0;\n    foreach(row;\
    \ grid) \n    {\n        max_height = max(max_height, row.length);\n        total_fill\
    \ += row.sum;\n    }\n    // if it already filled with water, we don't need to\
    \ take any actions\n    if (total_fill == max_height)\n        return 0;\n   \
    \ // how many cells do we need to reach the max height\n    long need_to_fill\
    \ = max_height - total_fill;\n    // divide the number of cells by the capacity\
    \ to get the number of rounds\n    return need_to_fill / capacity + (need_to_fill\
    \ % capacity > 0 ? 1 : 0);\n}", "{\n    long max_fill = 0;\n    foreach(row; grid)\n\
    \    {\n        long fill = 0;\n        foreach(well; row)\n        {\n      \
    \      if(well == 1)\n            {\n                fill++;\n            }\n\
    \            else\n            {\n                fill = 0;\n            }\n \
    \           max_fill = max(max_fill, fill);\n        }\n    }\n    return max_fill;\n\
    }\nlong refill_buckets(long[][] grid, long capacity)\n{\n    long refill_buckets\
    \ = 0;\n    long cnt = 0;\n    foreach(row; grid)\n    {\n        long fill =\
    \ 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n     \
    \       {\n                fill++;\n            }\n            else\n        \
    \    {\n                fill = 0;\n            }\n            if(fill > capacity)\n\
    \            {\n                fill = 0;\n                refill_buckets++;\n\
    \            }\n        }\n        cnt++;\n    }\n    return refill_buckets;\n\
    }\nlong buckets(long[][] grid, long capacity)\n{\n    long max_fill = max_fill(grid,\
    \ capacity);\n    long refill_buckets = refill_buckets(grid, capacity);\n    return\
    \ max_fill + refill_buckets;\n}", "{\n    long row_max = 0;\n    foreach(row;\
    \ grid)\n    {\n        foreach(well; row)\n        {\n            if(well > row_max)\n\
    \            {\n                row_max = well;\n            }\n        }\n  \
    \  }\n    return row_max;\n}", "{\n    long rows = grid.length;\n    long cols\
    \ = grid[0].length;\n    long total_water = 0;\n    long total_steps = 0;\n  \
    \  long row_total = 0;\n    long[] row_arr = new long[(int)rows];\n    for (long\
    \ i = 0; i < rows; i++)\n    {\n        for (long j = 0; j < cols; j++)\n    \
    \    {\n            total_water += grid[(int)i][(int)j];\n        }\n        row_arr[(int)i]\
    \ = total_water;\n        total_water = 0;\n    }\n    for (long i = 0; i < rows;\
    \ i++)\n    {\n        long remaining_water = row_arr[(int)i];\n        long steps\
    \ = 0;\n        while (remaining_water > 0)\n        {\n            if (remaining_water\
    \ > capacity)\n            {\n                remaining_water -= capacity;\n \
    \               steps++;\n            }\n            else\n            {\n   \
    \             steps++;\n                remaining_water = 0;\n            }\n\
    \        }\n        total_steps += steps;\n    }\n    return total_steps;\n}",
  "{\n    size_t rows = grid.length;\n    size_t cols = grid[0].length;\n    long\
    \ max_fill = 0;\n    long bucket_fill = 0;\n    size_t start = 0;\n    size_t\
    \ end = 0;\n    bool start_set = false;\n    long height = 0;\n    bool start_found\
    \ = false;\n    for (size_t row = 0; row < rows; row++)\n    {\n        for (size_t\
    \ col = 0; col < cols; col++)\n        {\n            if (grid[row][col] == 1)\n\
    \            {\n                bucket_fill++;\n                height++;\n  \
    \              if (!start_set)\n                {\n                    start =\
    \ col;\n                    start_set = true;\n                }\n           \
    \     end = col;\n            }\n            else\n            {\n           \
    \     bucket_fill = 0;\n                start_set = false;\n            }\n  \
    \          if (bucket_fill == capacity)\n            {\n                max_fill\
    \ += height;\n                start_found = true;\n                break;\n  \
    \          }\n        }\n        if (start_found)\n        {\n            for\
    \ (size_t i = start; i <= end; i++)\n            {\n                grid[row][i]\
    \ = 0;\n            }\n            start_found = false;\n        }\n        bucket_fill\
    \ = 0;\n        start_set = false;\n        height = 0;\n    }\n    return max_fill;\n\
    }\nlong water_wells(long[][] grid, long capacity) \n{\n    size_t rows = grid.length;\n\
    \    size_t cols = grid[0].length;\n    long total_fill = 0;\n    for (size_t\
    \ col = 0; col < cols; col++)\n    {\n        for (size_t row = 0; row < rows;\
    \ row++)\n        {\n            if (grid[row][col] == 1)\n            {\n   \
    \             total_fill += max_fill(grid, capacity);\n                break;\n\
    \            }\n        }\n    }\n    return total_fill;\n}", "{\n    long result\
    \ = 0;\n    long[] bucket = new long[grid[0].length];\n    for (int i = 0; i <\
    \ grid.length; i++)\n    {\n        for (int j = 0; j < grid[0].length; j++)\n\
    \        {\n            if (grid[i][j] == 1)\n            {\n                long\
    \ amount = min(capacity - bucket[j], grid[i][j]);\n                result += amount;\n\
    \                bucket[j] += amount;\n            }\n        }\n    }\n    return\
    \ result;\n}", "{\n    int num_rows = grid.length;\n    int num_cols = grid[0].length;\n\
    \    int total_fill = 0;\n    long fill_delta = 0;\n    // we start filling the\
    \ grids in the first row\n    for (int row = 0; row < num_rows; row++) \n    {\n\
    \        fill_delta = 0;\n        for (int col = 0; col < num_cols; col++) \n\
    \        {\n            // if the cell has water, we fill the bucket\n       \
    \     if (grid[row][col] == 1) \n            {\n                // we add the\
    \ water in the current row\n                fill_delta += 1;\n               \
    \ // we lower the water in the current row (of the next row)\n               \
    \ if (row + 1 < num_rows)\n                    grid[row + 1][col] = max(grid[row\
    \ + 1][col] - 1, 0);\n            }\n        }\n        // we update the total\
    \ fill for the current row\n        total_fill += fill_delta;\n    }\n    return\
    \ total_fill;\n}", "{\n    long i, j, k, max, row, col;\n    long n = grid.length;\n\
    \    long m = grid[0].length;\n    row = col = max = 0;\n    for (i = 0; i < n;\
    \ i++) \n    {\n        for (j = 0; j < m; j++) \n        {\n            if (grid[i][j]\
    \ == 1) \n            {\n                max = max(max, (i+1)*(j+1));\n      \
    \      }\n        }\n    }\n    if (max > capacity) \n    {\n        return -1;\n\
    \    }\n    long[][] dp = new long[n][m];\n    for (i = 0; i < n; i++) \n    {\n\
    \        for (j = 0; j < m; j++) \n        {\n            if (grid[i][j] == 1)\
    \ \n            {\n                if (i == 0 && j == 0) \n                {\n\
    \                    dp[i][j] = grid[i][j];\n                } \n            \
    \    else if (i == 0) \n                {\n                    dp[i][j] = dp[i][j-1]\
    \ + grid[i][j];\n                } \n                else if (j == 0) \n     \
    \           {\n                    dp[i][j] = dp[i-1][j] + grid[i][j];\n     \
    \           } \n                else \n                {\n                   \
    \ dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j];\n                }\n  \
    \          }\n        }\n    }\n    for (i = n-1; i >= 0; i--) \n    {\n     \
    \   for (j = m-1; j >= 0; j--) \n        {\n            if (dp[i][j] == capacity)\
    \ \n            {\n                row = i;\n                col = j;\n      \
    \          break;\n            }\n        }\n    }\n    long count = 0;\n    while\
    \ (row > 0 || col > 0) \n    {\n        if (row == 0) \n       ", "{\n    long\
    \ N = grid.length;\n    long M = grid[0].length;\n    long total = 0;\n    long\
    \ min_in_col;\n    for (int col = 0; col < M; col++) {\n        // col-th column\
    \ contains the most water in it\n        // we need to empty it using the bucket\n\
    \        min_in_col = capacity;\n        for (int row = 0; row < N; row++) {\n\
    \            if (grid[row][col] != 0) {\n                min_in_col = min(min_in_col,\
    \ grid[row][col]);\n            }\n        }\n        if (min_in_col != 0) {\n\
    \            total += min_in_col;\n            for (int row = 0; row < N; row++)\
    \ {\n                grid[row][col] -= min_in_col;\n            }\n        }\n\
    \    }\n    return total;\n}\nlong max_fill(long[][] grid, long capacity) \n{\n\
    \    long N = grid.length;\n    long M = grid[0].length;\n    long total = 0;\n\
    \    for (int col = 0; col < M; col++) {\n        // col-th column contains the\
    \ most water in it\n        // we need to empty it using the bucket\n        for\
    \ (int row = 0; row < N; row++) {\n            if (grid[row][col] != 0) {\n  \
    \              total += min(capacity, grid[row][col]);\n                grid[row][col]\
    \ -= min(capacity, grid[row][col]);\n            }\n        }\n    }\n    return\
    \ total;\n}\n/*\n    `max_fill` represents the maximum water we can empty\n  \
    \  in a single cycle of lowering the bucket to each row.\n*/\nlong solution(long[][]\
    \ grid, long capacity) \n{\n    long N = grid.length;\n    long M = grid[0].length;\n\
    \    long total = 0;\n    while (true) {\n        long cycle_total = max_fill(grid,\
    \ capacity);\n        if (cycle_total == 0) {\n            break;\n        }\n\
    \        total += cycle_total;\n    }\n    return total;\n", "{\n    long row\
    \ = grid.length;\n    long col = grid[0].length;\n    long result = 0;\n    long\
    \ level = 0;\n    long lowered = 0;\n    while (true)\n    {\n        int row_index\
    \ = 0;\n        int col_index = 0;\n        bool found = false;\n        for (int\
    \ i = 0; i < row; i++)\n        {\n            for (int j = 0; j < col; j++)\n\
    \            {\n                if (grid[i][j] > level)\n                {\n \
    \                   row_index = i;\n                    col_index = j;\n     \
    \               found = true;\n                    break;\n                }\n\
    \            }\n            if (found)\n            {\n                break;\n\
    \            }\n        }\n        if (!found)\n        {\n            break;\n\
    \        }\n        if (col_index == 0 || col_index == col - 1)\n        {\n \
    \           result += (row - 1) * capacity;\n            lowered = max(lowered,\
    \ level + (row - 1) * capacity);\n        }\n        else\n        {\n       \
    \     result += 2 * (row - 1) * capacity;\n            lowered = max(lowered,\
    \ level + 2 * (row - 1) * capacity);\n        }\n        level++;\n    }\n   \
    \ return result - lowered;\n}", "{\n    long ans = 0;\n    int N = cast(int)grid.length;\n\
    \    int M = cast(int)grid[0].length;\n    long max_cap = cast(long)N * capacity;\n\
    \    // iterate through all wells, then iterate through all \n    // cells in\
    \ a well, so the buckets will filled simultaneously\n    foreach(int i; 0 .. N)\
    \ {\n        foreach(int j; 0 .. M) {\n            if(grid[i][j] == 1) {\n   \
    \             ans++;\n                // fill buckets for all wells simultaneously\n\
    \                foreach(int k; 0 .. N) {\n                    if(grid[k][j] ==\
    \ 1) {\n                        grid[k][j] = 0;\n                        capacity--;\n\
    \                        if(capacity == 0) {\n                            // check\
    \ if some wells are not empty, \n                            // if yes then we\
    \ need to refill buckets\n                            foreach(int _i; 0 .. N)\
    \ {\n                                if(grid[_i][j] == 1) {\n                \
    \                    ans++;\n                                    break;\n    \
    \                            }\n                            }\n              \
    \              capacity = cast(long)N;\n                        }\n          \
    \          }\n                }\n            }\n        }\n    }\n    return ans;\n\
    }", "{\n    long max_height = 0;\n    foreach(index, row; grid) \n    {\n    \
    \    max_height = max(max_height, row.length);\n    }\n    long ans = 0;\n   \
    \ for (long i = 0; i < max_height; i++) \n    {\n        long used = 0;\n    \
    \    foreach(row; grid) \n        {\n            if (row.length > i) \n      \
    \      {\n                if (row[i] == 1) \n                {\n             \
    \       if (used < capacity) \n                    {\n                       \
    \ used += 1;\n                    }\n                    else \n             \
    \       {\n                        ans += 1;\n                        used = 1;\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return ans;\n}", "{\n    long total = 0;\n    foreach(ref line; grid)\n  \
    \  {\n        long tank = 0;\n        foreach(ref element; line)\n        {\n\
    \            if(element == 1)\n            {\n                if(tank + element\
    \ > capacity)\n                {\n                    total += tank + element\
    \ - capacity;\n                    tank = capacity;\n                }\n     \
    \           else\n                {\n                    tank += element;\n  \
    \              }\n            }\n            else\n            {\n           \
    \     tank = 0;\n            }\n        }\n    }\n    return total;\n}", "{\n\
    \    long rows = grid.length;\n    long cols = grid[0].length;\n    long max_fill\
    \ = 0;\n    for (long i = 0; i < rows; i++)\n    {\n        for (long j = 0; j\
    \ < cols; j++)\n        {\n            max_fill = max(max_fill, grid[i][j]);\n\
    \        }\n    }\n    return max_fill * capacity;\n}", "{\n    long n_rows =\
    \ grid.length;\n    long n_cols = grid[0].length;\n    long[][] visited = new\
    \ long[n_rows][n_cols];\n    bool all_zero = true;\n    for (long i = 0; i < n_rows;\
    \ i++) {\n        for (long j = 0; j < n_cols; j++) {\n            if (grid[i][j]\
    \ == 1) {\n                all_zero = false;\n                break;\n       \
    \     }\n        }\n    }\n    if (all_zero) {\n        return 0;\n    }\n   \
    \ long row = 0;\n    long col = 0;\n    long next_row = 0;\n    long next_col\
    \ = 0;\n    long count = 0;\n    while (row < n_rows) {\n        count += 1;\n\
    \        next_row = row + 1;\n        next_col = 0;\n        visited[row][col]\
    \ = count;\n        if (next_row < n_rows) {\n            for (long j = 0; j <\
    \ n_cols; j++) {\n                visited[next_row][j] = count;\n            }\n\
    \        }\n        if (capacity > 0) {\n            capacity -= 1;\n        \
    \    next_col = col + 1;\n            if (next_col < n_cols) {\n             \
    \   visited[row][next_col] = count;\n            }\n        }\n        if (capacity\
    \ == 0) {\n            capacity = n_cols - 1;\n            row += 1;\n       \
    \     col = 0;\n        } else {\n            col += 1;\n        }\n    }\n  \
    \  return count;\n}", "{\n    long wells = 0;\n    foreach(i; grid)\n        wells\
    \ += i.count!(x => x == 1);\n    return wells / capacity + (wells % capacity ?\
    \ 1 : 0);\n}", "{\n    int n = grid.length;\n    int m = grid[0].length;\n   \
    \ for (int i = 0; i < n; i++) \n    {\n        for (int j = 0; j < m; j++) \n\
    \        {\n            if (grid[i][j] == 1) \n            {\n               \
    \ for (int k = i - 1; k >= 0; k--) \n                {\n                    if\
    \ (grid[k][j] == 0) \n                    {\n                        grid[k][j]\
    \ = 1;\n                        break;\n                    }\n              \
    \  }\n            }\n        }\n    }\n    long result = 0;\n    for (int i =\
    \ 0; i < n; i++) \n    {\n        for (int j = 0; j < m; j++) \n        {\n  \
    \          if (grid[i][j] == 1) \n            {\n                int rows = (n\
    \ - i) % capacity;\n                if (rows == 0) \n                {\n     \
    \               rows = capacity;\n                }\n                result +=\
    \ rows;\n            }\n        }\n    }\n    return result;\n}", "{\n    long\
    \ rows = grid.length;\n    long cols = grid[0].length;\n    long max_fill = 0;\n\
    \    for (long i = 0; i < rows; i++)\n    {\n        long row_fill = 0;\n    \
    \    for (long j = 0; j < cols; j++)\n        {\n            if (grid[i][j] ==\
    \ 1)\n            {\n                row_fill++;\n            }\n        }\n \
    \       max_fill = max(max_fill, row_fill);\n    }\n    return max_fill;\n}",
  "{\n    long fill = 0;\n    long max_fill = 0;\n    long row = 0;\n    while (row\
    \ < grid.length) {\n        long[] current_row = grid[row];\n        long col\
    \ = 0;\n        while (col < current_row.length) {\n            long current_cell\
    \ = current_row[col];\n            if (current_cell == 1) {\n                fill\
    \ += 1;\n            }\n            if (fill > max_fill) {\n                max_fill\
    \ = fill;\n            }\n            col += 1;\n        }\n        fill = 0;\n\
    \        row += 1;\n    }\n    return max_fill / capacity;\n}", "{\n    long bucket_fill_count\
    \ = 0;\n    foreach(row; grid)\n    {\n        long bucket_fill = 0;\n       \
    \ foreach(well; row)\n        {\n            bucket_fill += well;\n          \
    \  if(bucket_fill > capacity)\n            {\n                bucket_fill_count\
    \ += bucket_fill / capacity;\n                bucket_fill %= capacity;\n     \
    \       }\n        }\n        bucket_fill_count += bucket_fill > 0 ? 1 : 0;\n\
    \    }\n    return bucket_fill_count;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
