name: HumanEval_158_find_max
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
  \ a list of strings.\n    The list contains different words. Return the word with\
  \ maximum number\n    of unique characters. If multiple strings have maximum number\
  \ of unique\n    characters, return the one which comes first in lexicographical\
  \ order.\n\n    find_max([\"name\", \"of\", \"string\"]) == \"string\"\n    find_max([\"\
  name\", \"enam\", \"game\"]) == \"enam\"\n    find_max([\"aaaaaaa\", \"bb\" ,\"\
  cc\"]) == \"\"aaaaaaa\"\n    \n*/\nstring find_max(string[] words) \n"
tests: "unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
  , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
  , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"])\
  \ == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
  play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
  we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\"\
  , \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
  this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) ==\
  \ \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n\
  }\nvoid main(){}"
completions: ["{\n\treturn \"\";\n}", "{\n    string maxStr;\n    foreach(i, word;\
    \ words) \n    {\n        if(!maxStr.length || word.length > maxStr.length)\n\
    \            maxStr = word;\n    }\n    return maxStr;\n}\n/*\nGiven a string\
    \ str, determine if it is a palindrome (reads the same from left\nto right and\
    \ from right to left).\n*/", "{\n    int[] freq = new int[words.length];\n   \
    \ for (int i = 0; i < words.length; i++) \n    {\n        freq[i] = uniquies(words[i]);\n\
    \    }\n    // freq.length is the length of the freq array. \n    int max = freq[0];\n\
    \    int pos = 0;\n    for (int i = 1; i < freq.length; i++) \n    {\n       \
    \ if (freq[i] > max) \n        {\n            max = freq[i];\n            pos\
    \ = i;\n        }\n    }\n    return words[pos];\n}", "{\n    int max = 0;\n \
    \   string res = \"\";\n    foreach(string word; words)\n    {\n        int[]\
    \ cnt = new int[128];\n        foreach(char c; word)\n        {\n            cnt[c]++;\n\
    \        }\n        foreach(int count; cnt)\n        {\n            if(count >\
    \ 0)\n                max = max + 1;\n        }\n        if(max == word.length)\n\
    \        {\n            if(res.length == 0)\n                res = word;\n   \
    \         else if(res > word)\n                res = word;\n        }\n      \
    \  max = 0;\n    }\n    return res;\n}", "{\n    immutable string result = \"\"\
    ;\n    immutable uint max = 0;\n    foreach(word; words)\n    {\n        uint\
    \ a = word.length;\n        uint c = 0;\n        foreach(letter; word)\n     \
    \   {\n            if(word.count(letter) == 1)\n            {\n              \
    \  c += 1;\n            }\n        }\n        if(c >= max)\n        {\n      \
    \      max = c;\n            result = word;\n        }\n    }\n    return result;\n\
    }", "{\n    return reduce!(d => d.length > a.length ? d : a)(words);\n}", "{\n\
    \    immutable result = words[0];\n    foreach(immutable word; words)\n    {\n\
    \        auto length = word.length;\n        bool is_lexicographically_first =\
    \ true;\n        foreach(immutable other; words)\n        {\n            if(other\
    \ == word) continue;\n            is_lexicographically_first &= (word < other)\
    \ || (other.length < length);\n        }\n        if(is_lexicographically_first)\n\
    \        {\n            result = word;\n        }\n    }\n    return result;\n\
    }", "{\n    string max = \"\";\n    foreach(string word; words) \n    {\n    \
    \    if(word.length > max.length) \n        {\n            max = word;\n     \
    \   }\n        else if(word.length == max.length) \n        {\n            if(word\
    \ < max) \n            {\n                max = word;\n            }\n       \
    \ }\n    }\n    return max;\n}", "{\n    string str = \"\";\n    int i = 0;\n\
    \    foreach(string s; words) \n    {\n        int count = length(unique(s));\n\
    \        if(count > i) \n        {\n            i = count;\n            str =\
    \ s;\n        }\n    }\n    return str;\n}", "{\n    // write your code here\n\
    \    string ret = \"\";\n    string candidate = \"\";\n    int max_count = 0;\n\
    \    foreach(string item; words)\n    {\n        if(ret.empty)\n        {\n  \
    \          ret = item;\n            max_count = item.length;\n        }\n    \
    \    else\n        {\n            if(max_count <= item.length)\n            {\n\
    \                max_count = item.length;\n                foreach(string sub_item;\
    \ item)\n                {\n                    if(!std.algorithm.any!(ch => ch\
    \ == sub_item)(candidate))\n                    {\n                        candidate\
    \ ~= sub_item;\n                    }\n                }\n            }\n    \
    \        if(max_count == candidate.length)\n            {\n                if(ret\
    \ > item)\n                {\n                    ret = item;\n              \
    \  }\n            }\n        }\n    }\n    return ret;\n}", "{\n    string ret\
    \ = \"\";\n    foreach(ref word; words)\n    {\n        if(word.length > ret.length)\n\
    \        {\n            if(ret.length == 0)\n            {\n                ret\
    \ = word;\n            }\n            else\n            {\n                foreach(i;\
    \ 0 .. ret.length)\n                {\n                    if(ret[i] != word[i])\n\
    \                    {\n                        ret = word;\n                \
    \        break;\n                    }\n                }\n            }\n   \
    \     }\n    }\n    return ret;\n}", "{\n    \n    string top_word = \"\";\n \
    \   int top_length = 0;\n    foreach(string word; words)\n    {\n        int word_length\
    \ = count_unique_chars(word);\n        if(word_length > top_length)\n        {\n\
    \            top_length = word_length;\n            top_word = word;\n       \
    \ }\n        else if(word_length == top_length)\n        {\n            top_word\
    \ = min(top_word, word);\n        }\n    }\n    return top_word;\n}", "{\n\tstring\
    \ max = words[0];\n\tforeach(string word; words) \n\t{\n\t\tif(word.length ==\
    \ max.length)\n\t\t{\n\t\t\tsize_t maxUniq = 0;\n\t\t\tsize_t uniq = 0;\n\t\t\t\
    foreach(char c; word) \n\t\t\t{\n\t\t\t\tif(word.indexOf(c) == word.lastIndexOf(c))\n\
    \t\t\t\t{\n\t\t\t\t\tuniq++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tforeach(char c; max) \n\
    \t\t\t{\n\t\t\t\tif(max.indexOf(c) == max.lastIndexOf(c))\n\t\t\t\t{\n\t\t\t\t\
    \tmaxUniq++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(uniq > maxUniq)\n\t\t\t{\n\t\t\t\t\
    max = word;\n\t\t\t}\n\t\t}\n\t\telse if(word.length > max.length)\n\t\t{\n\t\t\
    \tmax = word;\n\t\t}\n\t}\n\treturn max;\n}", "{\n    char[][] chars = map!(w\
    \ => w.dup, words);\n    string[] dupes = filter!(c => c.length != uniq(c).length)(chars);\n\
    \    if (dupes.length == 0)\n        return \"\";\n    else\n        return dupes[0];\n\
    }", "{\n    // Use 'enumerate' to loop over index and value\n    return words\n\
    \        .enumerate()\n        .reduce!(max)(\"\")._1;\n}", "{\n    string s =\
    \ \"\";\n    foreach(i; words)\n    {\n        if(unique(i).length == max(unique(i).length,\
    \ unique(s).length))\n        {\n            s = i;\n        }\n    }\n    return\
    \ s;\n}", "{\n    string ret;\n    int maxUnique = 0;\n    foreach(word; words)\n\
    \    {\n        int unique = 0;\n        dchar[] set = [];\n        foreach(c;\
    \ word)\n        {\n            if(unique == 0)\n            {\n             \
    \   set ~= c;\n                unique = 1;\n            }\n            else\n\
    \            {\n                if(!set.canFind(c))\n                {\n     \
    \               set ~= c;\n                    unique++;\n                }\n\
    \            }\n        }\n        if(unique > maxUnique)\n        {\n       \
    \     maxUnique = unique;\n            ret = word;\n        }\n    }\n    return\
    \ ret;\n}", "{\n    immutable d = -1;\n    immutable cur = \"\";\n    foreach(string\
    \ s; words) \n    {\n        immutable dict = 0;\n        foreach(immutable c;\
    \ s)\n        {\n            dict |= (1 << (c - 'a'));\n        }\n        if(popCnt(dict)\
    \ > d) \n        {\n            d = popCnt(dict);\n            cur = s;\n    \
    \    } \n        else if(popCnt(dict) == d) \n        {\n            if(cur >\
    \ s)\n            {\n                cur = s;\n            }\n        }\n    }\n\
    \    return cur;\n}\n//\nimport std.stdio;", "{\n    string result = words[0];\n\
    \    int size = words.length;\n    for (int i = 1; i < size; i++)\n    {\n   \
    \     auto s = find_max_string(result, words[i]);\n        result = s;\n    }\n\
    \    return result;\n}", "{\n    assert(words.length > 0);\n    string str1 =\
    \ words[0];\n    for (uint i = 1; i < words.length; i++)\n    {\n        if (words[i].length\
    \ > str1.length)\n        {\n            str1 = words[i];\n        }\n    }\n\
    \    if (str1.length == 1)\n    {\n        return str1;\n    }\n    string str2\
    \ = \"\";\n    int count = 0;\n    foreach (element; words)\n    {\n        bool\
    \ result = true;\n        foreach (d; element)\n        {\n            if (count(element,\
    \ d) > 1)\n            {\n                result = false;\n                break;\n\
    \            }\n        }\n        if (result == true)\n        {\n          \
    \  if (element.length > str2.length)\n            {\n                str2 = element;\n\
    \            }\n        }\n    }\n    if (str2 == \"\")\n    {\n        return\
    \ str1;\n    }\n    return str2;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
