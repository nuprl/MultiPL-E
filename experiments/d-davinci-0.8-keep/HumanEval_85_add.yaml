name: HumanEval_85_add
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\nGiven a non-empty list of integers\
  \ lst. add the even elements that are at odd indices..\n\n\n    Examples:\n    \
  \    add([4, 2, 6, 7]) ==> 2 \n    \n*/\nlong add(long[] lst) \n"
tests: "unittest\n{\n    alias candidate = add;\n\n    assert(candidate([4L, 88L])\
  \ == 88L);\n    assert(candidate([4L, 5L, 6L, 7L, 2L, 122L]) == 122L);\n    assert(candidate([4L,\
  \ 0L, 6L, 7L]) == 0L);\n    assert(candidate([4L, 4L, 6L, 8L]) == 12L);\n}\nvoid\
  \ main(){}"
completions: ["{\n    return (reduce!(a => b => a + b)(filter!(a => isEven(a) && (cast(long)dg(a).index\
    \ % 2) == 1)(lst)))(0);\n}", "{\n    int count = 0;\n    foreach(long i; lst)\n\
    \    {\n        if(i % 2 == 0 && count % 2 != 0)\n        {\n            count\
    \ += i;\n        }\n        count++;\n    }\n    return count;\n}", "{\n    long\
    \ sum = 0;\n    foreach(i,v; lst)\n    {\n        if(i%2!=0)\n        {\n    \
    \        if(v%2==0)\n            {\n                sum+=v;\n            }\n \
    \       }\n    }\n    return sum;\n}", "{\n    return reduce!q{a + b}(lst.indices.filter!(a\
    \ => a % 2 == 1).map!(i => lst[i]).filter!(a => a % 2 == 0).array());\n}", "{\n\
    \  long sum = 0;\n  for(int i = 0; i < lst.length; i++)\n  {\n    if( i % 2 ==\
    \ 1 && lst[i] % 2 == 0)\n    {\n      sum += lst[i];\n    }\n  }\n  return sum;\n\
    }", "{\n    long result = 0;\n    for(int i = 0; i < lst.length; i += 2)\n   \
    \ {\n        if(lst[i] % 2 == 0)\n        {\n            result += lst[i];\n \
    \       }\n    }\n    return result;\n}\nlong add(long[] lst)\n{\n    long result\
    \ = 0;\n    foreach(n; lst)\n    {\n        if(n % 2 == 0)\n        {\n      \
    \      result += n;\n        }\n    }\n    return result;\n}", "{\n    return\
    \ lst.retro.filter!(x => x % 2 == 0 && lst.indexOf(x) % 2 != 0).sum;\n}", "{\n\
    \    long sum = 0;\n    int n = lst.length;\n    foreach(i;0..n)\n    {\n    \
    \    if(i%2 == 0 && lst[i]%2 == 0)\n        {\n            sum += lst[i];\n  \
    \      }\n    }\n    return sum;\n}", "{\n    long sum = 0;\n    for(long i =\
    \ 0; i < lst.length; i++)\n    {\n        if(lst[i] % 2 == 0 && (i + 1) % 2 !=\
    \ 0)\n        {\n            sum += lst[i];\n        }\n    }\n    return sum;\n\
    }", "{\n    long sum = 0;\n    for(int i = 0; i < lst.length; i++)\n    {\n  \
    \      if(i % 2 == 1 && lst[i] % 2 == 0)\n        {\n            sum += lst[i];\n\
    \        }\n    }\n    return sum;\n}", "{\n    long sum = 0;\n    foreach(int\
    \ i, int value; lst)\n    {\n        if(i % 2 != 0 && value % 2 == 0)\n      \
    \  {\n            sum += value;\n        }\n    }\n    return sum;\n}\n// This\
    \ method uses std.math.isOdd and std.typecons.tuple to accumulate the sum.\nlong\
    \ add1(long[] lst) \n{\n    long sum = 0;\n    foreach(tuple(int, long) i; zip(iota(lst.length),\
    \ lst))\n    {\n        if(isOdd(i[0]) && i[1] % 2 == 0)\n        {\n        \
    \    sum += i[1];\n        }\n    }\n    return sum;\n}\n/*\n    Examples:\n \
    \       add2([4, 2, 6, 7]) ==> 2 \n*/\nlong add2(long[] lst) \n{\n    long sum\
    \ = 0;\n    foreach(int i, int value; lst)\n    {\n        if(isOdd(i) && value\
    \ % 2 == 0)\n        {\n            sum += value;\n        }\n    }\n    return\
    \ sum;\n}\n/*\n    Examples:\n        add3([4, 2, 6, 7]) ==> 2 \n*/\nlong add3(long[]\
    \ lst) \n{\n    long sum = 0;\n    foreach(tuple(int, long) i; zip(iota(lst.length),\
    \ lst))\n    {\n        if(isOdd(i[0]) && i[1] % 2 == 0)\n        {\n        \
    \    sum += i[1];\n        }\n    }\n    return sum;\n}\n/*\n    Examples:\n \
    \       add4([4, 2, 6, 7]) ==> 2 \n*/\nlong add4(long[] lst) \n{\n    long sum\
    \ = 0;\n    foreach(int i, int value; lst)\n    {\n        if(isOdd(i) && value\
    \ % 2 == 0)\n        {\n            sum += value;\n        }\n    }\n    return\
    \ sum;\n}\n/*\n   ", "{\n    long sum = 0;\n    foreach(i, v; lst)\n    {\n  \
    \      if(i%2 != 0 && v%2 == 0)\n        {\n            sum += v;\n        }\n\
    \    }\n    return sum;\n}", "{\n    long sum = 0;\n    for(long i = 0; i < lst.length;\
    \ i++)\n    {\n        if(i % 2 == 1 && lst[i] % 2 == 0)\n        {\n        \
    \    sum += lst[i];\n        }\n    }\n    return sum;\n}", "{\n    long sum=0;\n\
    \    foreach(elem;lst)\n    {\n        if(elem%2==0 && elem!=lst[0])\n       \
    \ {\n            sum+=elem;\n        }\n    }\n    return sum;\n}", "{\n    long[]\
    \ arr = lst[1..$];\n    if(arr.length == 1)\n    {\n        return arr[0];\n \
    \   }\n    int cnt = 0;\n    long sum = 0;\n    for(cnt = 0; cnt < arr.length;\
    \ cnt += 2)\n    {\n        sum += arr[cnt];\n    }\n    return sum;\n}\n//Test\
    \ Cases", "{\n    return lst\n        .filter!(e => e % 2 == 0)\n        .filter!((e,\
    \ i) => i % 2 == 1)\n        .sum;\n}", "{\n  return 0;\n}\n```", "{\n    int\
    \ sum = 0;\n    foreach(index, item; lst)\n    {\n        if(index % 2 != 0 &&\
    \ item % 2 == 0)\n        {\n            sum += item;\n        }\n    }\n    return\
    \ sum;\n}", "{\n    return zip(filter!((a,i) => (a%2==0 && i%2!=0))(lst), iota(lst.length)).map!(a\
    \ => a[0]).reduce!((a,b) => a+b)(0);\n}", "{\n  long total = 0;\n  long[] temp\
    \ = [];\n  for(int i = 0; i < lst.length; i++)\n  {\n    if(i % 2 == 1 && lst[i]\
    \ % 2 == 0)\n    {\n      temp ~= lst[i];\n    }\n  }\n  foreach(element; temp)\n\
    \  {\n    total += element;\n  }\n  return total;\n}\n*/"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
