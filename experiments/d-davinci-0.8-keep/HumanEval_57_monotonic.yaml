name: HumanEval_57_monotonic
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\nReturn True is list elements\
  \ are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n\
  \    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1,\
  \ 0, -10])\n    True\n    \n*/\nbool monotonic(long[] l) \n"
tests: "unittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
  \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n \
  \   assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L,\
  \ 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L,\
  \ 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
  \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
completions: ["{\n  bool dec = false;\n  if (l.length <= 1) return true;\n  auto old\
    \ = l[0];\n  foreach (i; 1..l.length) {\n    if (l[i] == old) continue;\n    if\
    \ (l[i] < old) {\n      if (dec) continue;\n      dec = true;\n    } else {\n\
    \      if (!dec) continue;\n      return false;\n    }\n    old = l[i];\n  }\n\
    \  return true;\n}\n/*\nGenerate list of prime numbers.\n    >>> primes(20)\n\
    \    [2, 3, 5, 7, 11, 13, 17, 19]\n*/\nlong[] primes(long n)\n{\n    if (n < 2)\
    \ return new long[](0);\n    if (n == 2) return [2];\n    long[] result = [2];\n\
    \    foreach (i; 3..n+1) {\n        bool add = true;\n        foreach (p; result)\
    \ if (i % p == 0) { add = false; break; }\n        if (add) result ~= i;\n   \
    \ }\n    return result;\n}\n/*\nReturn the list of prime factors of a number.\n\
    \    >>> prime_factors(6)\n    [2, 3]\n    >>> prime_factors(15)\n    [3, 5]\n\
    \    >>> prime_factors(127)\n    [127]\n    >>> prime_factors(128)\n    [2, 2,\
    \ 2, 2, 2, 2, 2]\n*/\nlong[] prime_factors(long n)\n{\n    if (n < 1) return [];\n\
    \    long[] factors = [];\n    foreach (p; primes(n)) {\n        while (n % p\
    \ == 0) {\n            factors ~= p;\n            n /= p;\n        }\n    }\n\
    \    return factors;\n}\n/*", "in {\n\tassert(l.length > 0);\n}\nout (bool result)\
    \ {\n\tassert(result == (((l[0] <= l[1]) && (l[1] <= l[2]) && (l[2] <= l[3]))\
    \ || ((l[0] >= l[1]) && (l[1] >= l[2]) && (l[2] >= l[3]))));\n}\n{\n\tauto sorted\
    \ = l.dup;\n\tsorted.sort;\n\tif (sorted.length == l.length) {\n\t\treturn true;\n\
    \t}\n\treturn false;\n}\n/*\nReturns True is a list is strictly ascending order.\n\
    \    >>> strictly_increasing([1, 20, 4, 10])\n    False\n    >>> strictly_increasing([1,\
    \ 2, 4, 20])\n    True\n    >>> strictly_increasing([4, 1, 0, -10])\n    False\n\
    */", "{\n    if (l.length == 0) return true;\n    long sign = sign(l[1] - l[0]);\n\
    \    foreach (i, x; l)\n    {\n        if (sign != sign(l[i] - l[i-1])) return\
    \ false;\n    }\n    return true;\n}\n/*\nWith a type of ascending or descending,\
    \ determine if a list is monotonic.\n    >>> monotonic([1, 2, 4, 20], Tuple!(long,\
    \ \"increasing\"))\n    True\n    >>> monotonic([1, 20, 4, 10], Tuple!(long, \"\
    increasing\"))\n    False\n    >>> monotonic([4, 1, 0, -10], Tuple!(long, \"descending\"\
    ))\n    True\n    \n*/", "{\n    int sign = signbit(l[1] - l[0]);\n    if (sign\
    \ == 0)\n        return false;\n    foreach (i; 1..l.length)\n    {\n        int\
    \ nextsign = signbit(l[i] - l[i-1]);\n        if (nextsign == 0)\n           \
    \ return false;\n        if (nextsign != sign)\n            return false;\n  \
    \  }\n    return true;\n}", "{\n    if (l.length < 2)\n        return true;\n\
    \    bool ascending = l[0] < l[1];\n    foreach (a, b; zip(l[0..$-1], l[1..$]))\n\
    \    {\n        if (ascending && b < a)\n            return false;\n        if\
    \ (!ascending && b > a)\n            return false;\n    }\n    return true;\n\
    }\n/*\ncheck if a list is a permutation of another.\n    >>> is_permutation([1,\
    \ 2, 3], [3, 2, 1])\n    True\n    >>> is_permutation([1, 2, 3], [3, 2, 5])\n\
    \    False\n    >>> is_permutation([1, 2, 3], [3, 2, 5, 1])\n    False\n*/", "{\
    \ \n\tenum constant = l.length;\n\tif (constant <= 2)\n\t\treturn true;\n\tbool\
    \ is_increasing = l[0] < l[1];\n\tfor (size_t i = 1; i < constant - 1; i++) \n\
    \t{\n\t\tif (l[i] <= l[i - 1] && is_increasing)\n\t\t\treturn false;\n\t\tif (l[i]\
    \ >= l[i - 1] && !is_increasing)\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
  "{\n    auto diffs = l.map!(x => x - x.previous);\n    auto cmp = diffs[0];\n  \
    \  return diffs.all!(x => x * cmp >= 0);\n}", "{ \n  return equal(all(zip(l, l[1\
    \ .. $]).map!(a => a[0] < a[1])), true) || equal(all(zip(l, l[1 .. $]).map!(a\
    \ => a[0] > a[1])), true);\n}", "{\n\tif (l.length<=1) return true;\n\tint check\
    \ = sign(l[1]-l[0]);\n\tif (check == 0) return monotonic(l[1..$]);\n\tforeach\
    \ (v; l[1..$])\n\t{\n\t\tif (sign(v-l[$-1]) != check) return false;\n\t}\n\treturn\
    \ true;\n}", "{\n    bool isIncreasing = true;\n    bool isDecreasing = true;\n\
    \    for (ulong i = 1; i < l.length; i++) \n    {\n        isIncreasing &= l[i]\
    \ >= l[i - 1];\n        isDecreasing &= l[i] <= l[i - 1];\n    }\n    return isIncreasing\
    \ || isDecreasing;\n}", "{\n\treturn (l.length > 0) ?\n\t\t\tl.reduce!((a,b) =>\
    \ {return (a < b) ? 1 : (a > b) ? -1 : 0;})(0) <= 0 :\n\t\t\ttrue;\n}", "{\n \
    \   long[] new_l = l[1..$-1];\n    return all!(i => i[0] >= i[1])(new_l.zip(new_l[1..$]));\n\
    }", "{\n    bool m = true;\n    long[] lp = l[0..$-1];\n    long[] ln = l[1..$];\n\
    \    foreach(int i, long x; lp)\n    {\n        if (x <= ln[i])\n        {\n \
    \           m = false;\n            break;\n        }\n    }\n    return m;\n}",
  "{\n    auto s = l.sort(); \n    return (s == l) || (s == l.reverse());\n}\n \n\
    /*\nReturn True if all elements of `l` are unique.\n    >>> all_unique([1, 2,\
    \ 4, 20])\n    True\n    >>> all_unique([1, 2, 4, 1])\n    False\n*/", "{\n  \
    \  bool incr = true;\n    bool decr = true;\n    foreach(x; l) \n    {\n     \
    \   //tuple t = tuple(l[i], l[i+1]);\n        bool temp1 = l[x] <= l[x+1];\n \
    \       bool temp2 = l[x] >= l[x+1];\n        incr &= temp1;\n        decr &=\
    \ temp2;\n    }\n    return incr || decr;\n}\n/*\nGiven a list l and a natural\
    \ number n, return a list where all elements have been removed that occur more\
    \ than n times.\n    >>> limited_occurrence([1, 2, 2, 2, 2, 3, 4, 5, 6, 1, 2,\
    \ 2, 2, 2, 2, 4, 2, 2, 2, 3, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2", "{\n\tif (l.length < 2)\n\t\treturn\
    \ true;\n\t//l.sort();\n\tl.sort(lteq);\n\treturn l[0] <= l[$-1];\n}", "{ \n\t\
    long[] l1 = new long[l.length]; \n\tl1 = l.dup;\n\tl1.sort;\n\treturn l == l1\
    \ || l == l1.reverse;\n} ", "{\n\tlong[] l2 = l[].dup;\n\treturn l.sort.equal(l2)\
    \ || l.sort.equal(l2.reverse);\n}", "{\n    bool increasing = true;\n    bool\
    \ decreasing = true;\n    for (int i = 0; i < l.length - 1; i++)\n    {\n    \
    \    if (l[i] > l[i + 1])\n        {\n            increasing = false;\n      \
    \  }\n        if (l[i] < l[i + 1])\n        {\n            decreasing = false;\n\
    \        }\n    }\n    return increasing || decreasing;\n}\n/*\nReturns the second\
    \ largest number in a list.\n    >>> second_largest([1, 2, 3, 4, 5])\n    4\n\
    \    >>> second_largest([1, 2, 5, 4, 3])\n    4\n    >>> second_largest([9, 2,\
    \ 3, 2, 5])\n    5\n    >>> second_largest([2, 2, 5, 9, 9])\n    5\n*/\nlong second_largest(long[]\
    \ l)\n{\n    long largest = l[0];\n    long second_largest = l[0];\n    for (int\
    \ i = 0; i < l.length; i++)\n    {\n        if (l[i] > largest)\n        {\n \
    \           second_largest = largest;\n            largest = l[i];\n        }\n\
    \        else if (l[i] > second_largest && l[i] != largest)\n        {\n     \
    \       second_largest = l[i];\n        }\n    }\n    return second_largest;\n\
    }\n/*\nReturns the number of unique strings in a list.\n    >>> num_unique([\"\
    a\", \"b\", \"a\", \"b\", \"c\"])\n    3\n    >>> num_unique([\"a\", \"a\", \"\
    a\", \"a\", \"a\"])\n    1\n    >>> num_unique([\"a\", \"b\", \"c\", \"d\", \"\
    d\"])\n    4\n*/\nlong num_unique(string[] strings)\n{\n    unordered_set!string\
    \ unique = new unordered_set!string();\n    foreach (string s; strings)\n    {\n\
    \        unique.insert(s);\n    }\n    return unique.length;\n}\n/*\nGiven a list\
    \ of numbers, return the number of values that are smaller than\nthe previous\
    \ value.\n", "{\n    bool res;\n    int i;\n    long[] current;\n    long[] last;\n\
    \    auto d = length(l);\n    int max_diff;\n    auto n = length(l);\n    int[]\
    \ diff = new int[](n);\n    if(n < 2)\n        return true;\n    \n    foreach(i,\
    \ current; l)\n    {\n        last = current;\n        foreach(i, current; l)\n\
    \        {\n            if(i > 0)\n            {\n                diff[i] = current\
    \ - last;\n                d = max(d, diff[i]);\n            }\n            i++;\n\
    \        }\n        i++;\n    }\n    max_diff = to!int(d);\n    foreach(i, current;\
    \ l)\n    {\n        if(i > 0)\n        {\n            if(abs(diff[i]) > max_diff)\n\
    \                return false;\n        }\n        i++;\n    }\n    return true;\n\
    }"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
