name: HumanEval_16_count_distinct_characters
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n Given a string, find out how\
  \ many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n\
  \    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \n*/\nlong count_distinct_characters(string\
  \ string) \n"
tests: "unittest\n{\n    alias candidate = count_distinct_characters;\n\n    assert(candidate(\"\
  \") == 0L);\n    assert(candidate(\"abcde\") == 5L);\n    assert(candidate(\"abcdecadeCADE\"\
  ) == 5L);\n    assert(candidate(\"aaaaAAAAaaaa\") == 1L);\n    assert(candidate(\"\
  Jerry jERRY JeRRRY\") == 5L);\n}\nvoid main(){}"
completions: ["{\n    return string.iota.map!(ch => ch.toLower).distinct.length;\n\
    }", "{\n    return std.range.sort(string.toLower().unique).length;\n}", "{\n \
    \   return string.toLower.uniq.length;\n}", "{\n    long result = 0;\n    char[string.length]\
    \ found = void;\n    foreach(c; string) \n    {\n        if(!found[c]) \n    \
    \    {\n            found[c] = true;\n            result++;\n        }\n    }\n\
    \    return result;\n}\n ", "{\n    auto lower_string = map!(toLower)(string);\n\
    \    return lower_string.sort().uniq.length;\n}", "{\n\tlong count = 0;\n\tstring\
    \ compare = toLower(string);\n\tforeach(unique_char; uniq(compare))\n\t{\n\t\t\
    count++;\n\t}\n\treturn count;\n}\n/*\nGiven a string, find out how many distinct\
    \ characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n\
    \    3\n    >>> count_distinct_characters('Jerry')\n    4\n*/\nlong count_distinct_characters(string\
    \ string) \n{\n\tlong count = 0;\n\tforeach(unique_char; uniq(toLower(string)))\n\
    \t{\n\t\tcount++;\n\t}\n\treturn count;\n}", "{\n    auto result = countUntil!((a,b)\
    \ => a != b)(string.toLower);\n    return result.front;\n}", "{\n    return set(uniq(tolower(string))).length;\n\
    }", "{\n    /*\n    long count = 0;\n    foreach(char; string)\n    {\n      \
    \  if (string.count(char)==1)\n        {\n            count++;\n        }\n  \
    \  }\n    return count;\n    */\n    /*\n    string chars = \"\";\n    foreach(char;\
    \ string)\n    {\n        if (chars.indexOf(char)==-1)\n        {\n          \
    \  chars ~= char;\n        }\n    }\n    return chars.length;\n    */\n    /*\n\
    \    string set = \"\";\n    foreach(char; string)\n    {\n        if (set.count(char)==0)\n\
    \        {\n            set ~= char;\n        }\n    }\n    return set.length;\n\
    \    */\n    string unique_chars = \"\";\n    foreach(char; string)\n    {\n \
    \       if (unique_chars.count(char)==0)\n        {\n            unique_chars\
    \ ~= char;\n        }\n    }\n    return unique_chars.length;\n}\n/*\n Given a\
    \ string, find out the word with the most repeated letters in it.\n    >>> find_most_repeated_word(\"\
    My friend is so cool and she is so cool.\")\n    \"cool\"\n    >>> find_most_repeated_word(\"\
    Python is a very easy programming language and I love python\")\n    \"python\"\
    \n    >>> find_most_repeated_word(\"I love how we can just do almost anything\
    \ with programming\")\n    \"programming\"\n*/\nstring find_most_repeated_word(string\
    \ string) \n{\n    string[] words = string.split(\" \");\n    string most_repeated_word\
    \ = \"\";\n    int max_dup_count = 0;\n    foreach(word; words)\n    {\n     \
    \   int dup_count = 0;\n        foreach(char; word)\n        {\n            if\
    \ (word.count(char)>1)\n            {\n                dup_count++;\n        \
    \    }\n        }\n        if (dup_count>max_dup_count)\n        {\n         \
    \   max_dup_count = dup_count;\n            most_repeated", "{\n    return set(string.toLower()).length;\n\
    }", "{\n\tauto adict = new int[cast(int)string.length];\n\tint count = 0;\n\t\
    int j = 0;\n\tauto ln = cast(int)string.length;\n\tfor (int i = 0; i < ln; i++)\n\
    \t{\n\t\tint number = tolower(string[i]);\n\t\tint found = 0;\n\t\tforeach (j;\
    \ adict)\n\t\t{\n\t\t\tif (number == adict[j])\n\t\t\t{\n\t\t\t\tfound = 1;\n\t\
    \t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (found == 0)\n\t\t{\n\t\t\tadict[count] =\
    \ number;\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}", "{\n    return to!(long[])(distinct(map!(char.toLower)(string))).length;\n\
    }\n/*\n Given a string of words, find out how many distinct words does it contain\n\
    \    >>> count_distinct_words('I like to ride my bike. I ride my bike on a mountain')\n\
    \    8\n*/\nlong count_distinct_words(string sentence) \n{\n    return to!(long[])(distinct(split(sentence))).length;\n\
    }\n/*\n Given a string, find out how many distinct characters (regardless of case)\
    \ does it consist of, in percent\n to the total number of characters in the string\n\
    \    >>> percent_distinct_characters('xyzXYZ')\n    1.0\n    >>> percent_distinct_characters('Jerry')\n\
    \    0.6666666666666666\n*/\nfloat percent_distinct_characters(string string)\
    \ \n{\n    return cast(float) count_distinct_characters(string) / cast(float)\
    \ string.length;\n}\n/*\n Given a string of words, find out how many distinct\
    \ words does it contain, in percent to the total number of words in the string\n\
    \    >>> percent_distinct_words('I like to ride my bike. I ride my bike on a mountain')\n\
    \    0.5\n*/\nfloat percent_distinct_words(string sentence) \n{\n    return cast(float)\
    \ count_distinct_words(sentence) / cast(float) split(sentence).length;\n}\n/*\n\
    \ Given a string, return the number of upper case letters in the string\n    >>>\
    \ count_upper_case_letters('XYZ')\n    3\n    >>> count_upper_case_letters('JERRY')\n\
    \    5\n*/\nlong count_upper_case_letters(string string) \n{\n    return to!(long[])(filter!(char.isUpper)(string)).length;\n\
    }\n/*\n Given a string, return the number of upper case letters in the string,\
    \ in percent to the total number of characters in the string\n    >>> percent_upper_case_letters('XYZ')\n\
    \    1.0\n    >>> percent_upper_case_letters('Jerry')\n    0.5\n*/\nfloat percent_upper_",
  "{\n\treturn zip(string, string.toUpper())\n\t\t.mismatch\n\t\t.map!((a, b) => a.length)\n\
    \t\t.sum;\n}", "{\n\tHashSet!char characters = new HashSet!char();\n\tforeach(c;\
    \ string)\n\t{\n\t\tif(c.isLetter)\n\t\t{\n\t\t\tcharacters.insert(c.toLower);\n\
    \t\t}\n\t}\n\treturn characters.length;\n}", "{\n    import std.algorithm.comparison\
    \ : equal;\n    import std.array : array;\n    import std.traits : isSomeString;\n\
    \    import std.algorithm.searching : canFind;\n    import std.typecons : tuple;\n\
    \    alias char[] chars;\n    import std.algorithm.iteration : uniq;\n    import\
    \ std.algorithm.mutation : map;\n    static assert(isSomeString!string);\n   \
    \ static if (is(typeof(string[0].tolower))){\n        return string.uniq.map!(x\
    \ => x.tolower).length;\n    }\n    else {\n        auto result = string.uniq.map!(x\
    \ => toLower(x));\n        return result.length;\n    }\n}\n/*\n Given a string\
    \ and a character, find out if that character occurs in that string\n    >>> find_character('abc',\
    \ 'a')\n    true\n    >>> find_character('abc', 'd')\n    false\n*/", "{\n   \
    \ ulong result = 0;\n    foreach(char i; string)\n    {\n        result += mixin(\"\
    '\");\n        result += i;\n        result += mixin(\"'\");\n        result +=\
    \ mixin(\" in set\");\n    }\n    return result;\n}", "{\n\tlong count = 0;\n\t\
    foreach(char i; distinct(string.tolower()))\n\t{\n\t\tcount++;\n\t}\n\treturn\
    \ count;\n}", "{\n  ulong res = new ulong[1];\n  res[0] = 0;\n  auto cmp = (a,\
    \ b) {\n    if (a.ptr == b.ptr)\n      return 0;\n    else\n      return 1;\n\
    \  };\n  auto cmp1 = (a, b) {\n    int res = 0;\n    if (a.ptr < b.ptr)\n    \
    \  res = -1;\n    else if (a.ptr > b.ptr)\n      res = 1;\n    return res;\n \
    \ };\n  auto check = (c, data) {\n    if (data[0] == 0)\n      data[0] = 1;\n\
    \    else {\n      auto it = new std.typecons.map.TreeMap!(char*, void*)();\n\
    \      it.put(c, null);\n      if (it.ptr != data[0])\n        ++data[0];\n  \
    \  }\n  };\n  string.foreach(check, res);\n  return res[0];\n}\n/*\nGiven a string,\
    \ find the largest word in the string. A word is defined as a sequence of characters\
    \ that don't contain any\nof the following characters: \" (double quote), ' (single\
    \ quote), ` (backtick). Two words are separated by a space.\n>>> get_longest_word('I\
    \ love dogs')\n'love'\n>>> get_longest_word('Hey fellow warriors')\n'fellow'\n\
    >>> get_longest_word('This is a \"thing\"')\n'thing'\n*/\nstring get_longest_word(string\
    \ string) \n{\n  auto cmp = (a, b) {\n    int res = 0;\n    if (a.length < b.length)\n\
    \      res = -1;\n    else if (a.length > b.length)\n      res = 1;\n    return\
    \ res;\n  };\n  return string.split.map!(c => c.strip).filter!(c => c.length >\
    \ 0).sort!(cmp).reverse.front;\n}\n/*\nGiven a string, find out how many pairs\
    \ of adjacent characters there are that are different case.\n    >>> count_adjacent_pairs('aabBc",
  "{\n    return reduce!( (a, b) => a + b )\n    (\n        map!(toLower)(array(string)).tupleof.sort()\n\
    \            .chunks(2)\n            .map!(c => to!bool(c[0] != c[1]))\n    );\n\
    }", "{\n    long n = 0;\n    string chars = \"\";\n    foreach(char c; string)\
    \ \n    {\n        if(!chars.contains(c))\n        {\n            chars ~= c;\n\
    \            n += 1;\n        }\n    }\n    return n;\n}\n/*\n  Given 2 strings,\
    \ return true if they are equal when ignoring the case.\n    >>> ignore_case_compare('Apple',\
    \ 'apple')\n    True\n    >>> ignore_case_compare('Hello', 'hELLo')\n    True\n\
    \    >>> ignore_case_compare('hello', 'hEllO')\n    False\n*/"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
