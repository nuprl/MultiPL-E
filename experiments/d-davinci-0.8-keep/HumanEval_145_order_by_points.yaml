name: HumanEval_145_order_by_points
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which\
  \ sorts the given list of integers\n    in ascending order according to the sum\
  \ of their digits.\n    Note: if there are several items with similar sum of their\
  \ digits,\n    order them based on their index in original list.\n\n    For example:\n\
  \    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>>\
  \ order_by_points([]) == []\n    \n*/\nlong[] order_by_points(long[] nums) \n"
tests: "unittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
  \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
  \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
  \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
  \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L,\
  \ -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
  \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L,\
  \ 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
  \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
completions: ["{\n    /*\n        Solved with a selection sort\n    */\n    for (int\
    \ i = 0; i < nums.length - 1; i++) \n    {\n        int min = i;\n        for\
    \ (int j = i + 1; j < nums.length; j++) \n        {\n            if (nums[j].digits.sum()\
    \ < nums[min].digits.sum()) \n            {\n                min = j;\n      \
    \      } \n            else if (nums[j].digits.sum() == nums[min].digits.sum())\
    \ \n            {\n                min = nums[j] < nums[min] ? j : min;\n    \
    \        }\n        }\n        if (min != i) \n        {\n            long tmp\
    \ = nums[i];\n            nums[i] = nums[min];\n            nums[min] = tmp;\n\
    \        }\n    }\n    return nums;\n}", "{\n    return nums.sorted((a, b) =>\
    \ (sum_of_digits(a) == sum_of_digits(b)) ? a < b : sum_of_digits(a) < sum_of_digits(b));\n\
    }", "{\n    bool[] ar = new bool[nums.length];\n    int[] sums = new int[nums.length];\n\
    \    for (int i = 0; i < nums.length; i++) {\n        sums[i] = std.sum_digits(nums[i]);\n\
    \    }\n    long[] output = new long[nums.length];\n    for (int i = 0; i < nums.length;\
    \ i++) {\n        int minSum = sums[0];\n        int minSumIndex = 0;\n      \
    \  for (int j = 0; j < sums.length; j++) {\n            if (sums[j] < minSum &&\
    \ !ar[j]) {\n                minSum = sums[j];\n                minSumIndex =\
    \ j;\n            }\n        }\n        output[i] = nums[minSumIndex];\n     \
    \   ar[minSumIndex] = true;\n    }\n    return output;\n}", "{\n    immutable(long)\
    \ _nums = nums;", "{\n    auto res = nums.dup;\n    auto nums_with_index = zip(nums,iota(nums.length)).sort!((a,b)=>a[0].digitSum>b[0].digitSum);\n\
    \    foreach(i,n;nums_with_index)\n    {\n        res[i] = n[0];\n    }\n    return\
    \ res;\n}", "{\n \n long i = 0,s=0,it = 0;\n  foreach(num;nums)\n  {\n      i\
    \ = num;\n      s = 0;\n      while(i)\n      {\n          s += i%10;\n      \
    \    i /= 10;\n      }\n      nums[it] = s * 100000000 + it;\n      it++;\n  }\n\
    \  sort(nums);\n  it = 0;\n  foreach(num;nums)\n  {\n      nums[it] = num % 100000000;\n\
    \      it++;\n  }\n    return nums;\n}", "{\n    return nums.sort!((x, y) => {\n\
    \        return x.sumDigits().cmp(y.sumDigits());\n    });\n}", "{ \n    if (nums.length\
    \ == 0) \n        return nums;\n    \n    auto to_longs =  (nums.map!(a => a.to!string).map!(to\
    \ => to.to!ulong).map!(parse => parse.sum)).dup;\n    auto to_ints = to_longs.map!(a\
    \ => a.to!int).dup;", "{\n    long[] result = new long[nums.length];\n    auto\
    \ comparator = (n1, n2) => (sumDigits(n1) == sumDigits(n2)) ? n1 - n2 : sumDigits(n1)\
    \ - sumDigits(n2);\n    nums.sort(comparator);\n    foreach(i, e; nums)\n    \
    \    result[i] = e;\n    return result;\n}", "{\n    return nums.sort!((a, b)\
    \ => {\n            long sumA = 0, sumB = 0;\n            foreach(ch; a.to!string)\n\
    \                sumA += ch.to!long;\n            foreach(ch; b.to!string)\n \
    \               sumB += ch.to!long;\n            return sumA == sumB ? a.compare(b)\
    \ : sumA.compare(sumB);\n        });\n}", "{\n    long[long] points;\n    foreach(n;\
    \ nums)\n    {\n        long p = 0;\n        long t = n;\n        while(t != 0)\n\
    \        {\n            p += t % 10;\n            t /= 10;\n        }\n      \
    \  points[p] ~= n;\n    }\n    long[] sorted = [];\n    foreach(k; keys(points))\n\
    \    {\n        long[] p = points[k];\n        std.algorithm.sort!(a => a)(p);\n\
    \        foreach(n; p)\n        {\n            sorted ~= n;\n        }\n    }\n\
    \    return sorted;\n}", "{\n    /* The idea is to use associative arrays, a.k.a.\
    \ maps. */\n    auto m = new int[long][long]();", "{\n    auto digs = nums.map!(x\
    \ => tuple(x,x.toString().fold!((a,b) => a + b.to!long() - '0'.to!long())));\n\
    \    return digs.sort!((a,b) => b[1] < a[1] || (b[1] == a[1] && b[0] < a[0])).map!(x\
    \ => x[0]).array;\n}", "{\n    return nums.sort!((a, b) => to!(int)(a).sumOfDigits\
    \ < to!(int)(b).sumOfDigits);\n}", "{\n    // Assume there are no repeated numbers\n\
    \    return nums.sort!((a, b) { return sum(a) < sum(b); });\n}", "{\n    bool[]\
    \ ordered = false;\n    int i = 0;\n    long[] newArr = nums;\n    while(ordered\
    \ == false)\n    {\n        if(i == nums.length)\n        {\n            ordered\
    \ = true;\n        }\n        else\n        {\n            if(newArr[i].digits().sum()\
    \ > newArr[i+1].digits().sum())\n            {\n                long temp = newArr[i];\n\
    \                newArr[i] = newArr[i+1];\n                newArr[i+1] = temp;\n\
    \                i = 0;\n            }\n            else\n            {\n    \
    \            i++;\n            }\n        }\n    }\n    return newArr;\n}", "{\n\
    \    immutable bool cmp(long a, long b) \n    {\n        return to!string(a).sum\
    \ &lt; to!string(b).sum;\n    }\n    return nums.sort!cmp;\n}\n</code>\nAnd \n\
    <code>import std.stdio;\nimport std.algorithm;\nimport std.math;\nimport std.range;\n\
    import std.array;\n/*", "{\n    return nums.sort!((a, b) {\n        auto c = a.digits().sum,\
    \ d = b.digits().sum;\n        return c < d || (c == d && a < b);\n    });\n}\n\
    /*\n    Write a function which finds the count of non-unique\n    elements in\
    \ a given list.", "{\n    return nums.sort!((a, b) =>\n        sumOfDigits(a)\
    \ == sumOfDigits(b)\n            ? a > b\n            : sumOfDigits(a) > sumOfDigits(b));\n\
    }\n \nlong sumOfDigits(long n) \n{\n    return n\n        .to!string\n       \
    \ .split(\"\")\n        .map!(a => a.to!long)\n        .sum;\n}\n \n \nlong[]\
    \ testData = [1, 11, -1, -11, -12];\nlong[] expected = [-1, -11, 1, -12, 11];\n\
    assert(order_by_points(testData) == expected);", "{\n    return nums.sort!q{a.sumDigits\
    \ < b.sumDigits || (a.sumDigits == b.sumDigits && a.idx < b.idx)};\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
