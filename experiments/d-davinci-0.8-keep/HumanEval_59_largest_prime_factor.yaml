name: HumanEval_59_largest_prime_factor
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\nReturn the largest prime factor\
  \ of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n\
  \    29\n    >>> largest_prime_factor(2048)\n    2\n    \n*/\nlong largest_prime_factor(long\
  \ n) \n"
tests: "unittest\n{\n    alias candidate = largest_prime_factor;\n\n    assert(candidate(15L)\
  \ == 5L);\n    assert(candidate(27L) == 3L);\n    assert(candidate(63L) == 7L);\n\
  \    assert(candidate(330L) == 11L);\n    assert(candidate(13195L) == 29L);\n}\n\
  void main(){}"
completions: ["{\n    long largest = 0;\n    while (n % 2 == 0) \n    {\n        largest\
    \ = 2;\n        n /= 2;\n    }\n    for (long i = 3; i <= sqrt(n); i += 2) \n\
    \    {\n        while (n % i == 0) \n        {\n            largest = i;\n   \
    \         n /= i;\n        }\n    }\n    if (n > 2)\n        largest = n;\n  \
    \  return largest;\n}", "{\n    typeof(n) i;\n    typeof(n) max = n;\n    if (n\
    \ % 2 == 0) \n    {\n        max = n/2;\n        while (n % 2 == 0)\n        \
    \    n /= 2;\n    }\n    i = 3;\n    while (i <= n/i) \n    {\n        if (n %\
    \ i == 0) \n        {\n            max = n/i;\n            while (n % i == 0)\n\
    \                n /= i;\n        }\n        i += 2;\n    }\n    if (n > 1) \n\
    \        max = n;\n    return max;\n}", "{\n    // works with n > 1 and n not\
    \ prime.\n    import std.algorithm;\n    import std.math;\n    //if (n<=1) return\
    \ 0;\n    static int[] primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\
    \ 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127,\
    \ 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211,\
    \ 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307,\
    \ 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401,\
    \ 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499,\
    \ 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607,\
    \ 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709,\
    \ 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823,\
    \ 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937,\
    \ 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033,\
    \ 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093,", "{\n    auto prime_factorization\
    \ = primeFactors(n);\n    long max = 0;\n    foreach(i; prime_factorization)\n\
    \    {\n        if(i > max)\n            max = i;\n    }\n    return max;\n}",
  "{\n    long largest_prime_factor = 2;\n    for (long i = 3; i <= n; i += 2) \n\
    \    {\n        if (n % i == 0) \n        {\n            // find prime factors\
    \ and update largest prime factor\n            largest_prime_factor = max(largest_prime_factor,\
    \ max(largest_prime_factor, i));\n            while (n % i == 0) \n          \
    \  {\n                n /= i;\n            }\n        }\n    }\n    return largest_prime_factor;\n\
    }", "{\n    if (n == 1)\n        return 1;\n    else if (n % 2 == 0)\n       \
    \ return max(2, largest_prime_factor(n / 2));\n    else \n    {\n        // Odd\
    \ numbers.\n        long root = cast(long)ceil(sqrt(n));\n        long factor\
    \ = 3;\n        while (factor <= root) \n        {\n            if (n % factor\
    \ == 0)\n                return max(factor, largest_prime_factor(n / factor));\n\
    \            factor += 2;\n        }\n        return n;\n    }\n}", "{\n    alias\
    \ Factor = Tuple!(long, long);\n    auto factors = Factor[](1L, n);\n    while\
    \ (true) {\n        auto d = factor(n);\n        if (d)\n            factors ~=\
    \ Factor(d, 0);\n        else\n            break;\n        n /= d;\n    }\n  \
    \  foreach (f; factors) {\n        auto count = 0L;\n        auto x = f[1];\n\
    \        while (x % f[0] == 0) {\n            count++;\n            x /= f[0];\n\
    \        }\n        f[1] = count;\n    }\n    long largest = 2L;\n    long max_count\
    \ = 0L;\n    foreach (f; factors) {\n        if (f[1] > max_count) {\n       \
    \     max_count = f[1];\n            largest = f[0];\n        }\n    }\n    return\
    \ largest;\n}", "{\n    long max_prime_factor = 2;\n    while (n > 1) {\n    \
    \    long factor = 2;\n        while (n % factor) { // while n is not divisible\
    \ by factor...\n            factor++;\n        }\n        if (factor > max_prime_factor)\
    \ {\n            max_prime_factor = factor;\n        }\n        n /= factor;\n\
    \    }\n    return max_prime_factor;\n}", "{\n    long largest_prime = 2;\n  \
    \  while (n > 1) \n    {\n        if (n % largest_prime == 0)\n            n /=\
    \ largest_prime;\n        else\n            largest_prime += 1;\n    }\n    return\
    \ largest_prime;\n}\n// Return the number of trailing zeros of n!", "{\n    long\
    \ max = 0;\n    long d = 0;\n    foreach(i; 2..(n/2))\n    {\n        if (n %\
    \ i == 0)\n        {\n            d = i;\n            if (isPrime(d))\n      \
    \      {\n                max = max(max, d);\n            }\n        }\n    }\n\
    \    return max;\n}", "{\n    if (n < 2)\n        return 0;\n    \n    while (n\
    \ & 1 == 0)\n        n /= 2;\n    \n    long p = 3;\n    while (n > 1) \n    {\n\
    \        if (n % p == 0) \n        {\n            n /= p;\n            while (n\
    \ % p == 0)\n                n /= p;\n        }\n        p += 2;\n    }\n    return\
    \ p - 2;\n}", "{\n\tauto i = 1L;\n\t\n\twhile(i <= n)\n\t{\n\t\tif (n % i == 0)\n\
    \t\t{\n\t\t\tif (isPrime(i))\n\t\t\t{\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\t\
    i++;\n\t}\n\treturn 0;\n}", "{\n    long x;\n    for (x = 2; x < n/2; x++)\n \
    \   {\n        if (n % x == 0)\n        {\n            if (is_prime(n/x))\n  \
    \          {\n                return n/x;\n            }\n        }\n    }\n \
    \   return 0;\n}", "{ \n  assert(n > 1);\n  // Assume n is odd.\n  if (n % 2 ==\
    \ 0) \n  {\n    n /= 2;\n    while (n % 2 == 0) n /= 2;\n  }\n  long d = 3;\n\
    \  while (d * d <= n) \n  {\n    if (n % d == 0) \n    {\n      n /= d;\n    \
    \  while (n % d == 0) n /= d;\n    }\n    d += 2;\n  }\n  return n;\n}", "{\n\
    \    long largest_prime = 0;\n    // loop through all numbers\n    for (long i\
    \ = 2; i < n; i++)\n    {\n        // check if i is a factor of n \n        if\
    \ (n % i == 0)\n        {\n            // check if i is a prime number\n     \
    \       bool prime = true;\n            for (long j = 2; j < i; j++)\n       \
    \     {\n                if (i % j == 0)\n                {\n                \
    \    prime = false;\n                    break;\n                }\n         \
    \   }\n            if (prime) \n            {\n                largest_prime =\
    \ i;\n            }\n        }\n    }\n    return largest_prime;\n}\n/*\n    >>>\
    \ largest_prime_factor_faster(13195)\n    29\n    >>> largest_prime_factor_faster(2048)\n\
    \    2\n*/\nlong largest_prime_factor_faster(long n) \n{\n    long largest_prime\
    \ = 0;\n    // go through all numbers up to the sqrt of n\n    for (long i = 2;\
    \ i < sqrt(n); i++)\n    {\n        // check if i is a factor of n \n        if\
    \ (n % i == 0)\n        {\n            // check if i is a prime number\n     \
    \       bool prime = true;\n            for (long j = 2; j < i; j++)\n       \
    \     {\n                if (i % j == 0)\n                {\n                \
    \    prime = false;\n                    break;\n                }\n         \
    \   }\n            if (prime) \n            {\n                largest_prime =\
    \ i;\n            }\n        }\n    }\n    return largest_prime;\n}\n/*\nReturn\
    \ the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor_fastest(13195)\n\
    \    29\n    >>> largest_prime_factor_fastest(2048)\n    2\n*/\nlong largest_prime_factor_fastest(long\
    \ n) \n{\n    long largest_prime = 0;\n    // go through all numbers up to the\
    \ sqrt of n\n    for (long i = 2; i < sqrt(n); i++)\n    {\n        // check",
  "{\n    ulong maxp = 1;\n    while(n % 2 == 0) \n    {\n        maxp = 2;\n    \
    \    n /= 2;\n    }\n    ulong p = 3;\n    while(p <= sqrt(n)) \n    {\n     \
    \   if(n % p == 0) \n        {\n            maxp = p;\n            n /= p;\n \
    \       }\n        else \n        {\n            p += 2;\n        }\n    }\n \
    \   if(n > 2) maxp = n;\n    return maxp;\n}", "{\n    long ret;\n    int is_prime;\n\
    \    for (ret = n/2; ret > 0; ret--) {\n        is_prime = 1;\n        foreach\
    \ (int i; 2..ret) {\n            if (ret % i == 0) {\n                is_prime\
    \ = 0;\n                break;\n            }\n        }\n        if (is_prime)\
    \ {\n            break;\n        }\n    }\n    return ret;\n}\n/*\nReturn true\
    \ if n is a palindrome, false otherwise.\n    >>> is_palindrome(123210)\n    False\n\
    \    >>> is_palindrome(12321)\n    True\n*/", "{\n    long largest = 2;\n    long\
    \ limit = cast(long)sqrt(n);\n    foreach(prime; primes(limit))\n    {\n     \
    \   if (n % prime == 0)\n            largest = prime;\n    }\n    return largest;\n\
    }", "{\n    import std.math;\n    long i = 2;\n    long largest = 0;\n    foreach(i;\
    \ 2..isqrt(n) + 1)\n    {\n        while (n % i == 0) \n        {\n          \
    \  n /= i;\n            largest = i;\n        }\n    }\n    return largest;\n}",
  "{\n    Tuple!(long, long[]) result = factor_rec(n, n / 2);\n    return result[1][result[1].length\
    \ - 1];\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
