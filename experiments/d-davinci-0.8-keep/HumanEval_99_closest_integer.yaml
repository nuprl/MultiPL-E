name: HumanEval_99_closest_integer
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
  \ takes a value (string) representing a number\n    and returns the closest integer\
  \ to it. If the number is equidistant\n    from two integers, round it away from\
  \ zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"\
  15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given\
  \ number is equidistant\n    from two integers, the one you should return is the\
  \ one that is the\n    farthest from zero. For example closest_integer(\"14.5\"\
  ) should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n\
  */\nlong closest_integer(string value) \n"
tests: "unittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"\
  10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"\
  -15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"\
  0\") == 0L);\n}\nvoid main(){}"
completions: ["{\n    long num = atoi(value);", "{\n    long number = atoi(value);\n\
    \    double fractional_part = strtold(value, null) - number;\n    if (fractional_part\
    \ == 0.5)\n        return (number > 0) ? number + 1 : number - 1;\n    else if\
    \ (fractional_part > 0.5)\n        return number + 1;\n    else\n        return\
    \ number;\n}", "{\n    float number;\n    if(value.canFind('.')) \n    {\n   \
    \     number = float.parse(value);\n    } \n    else \n    {\n        number =\
    \ long.parse(value);\n    }\n    if(number < 0) \n    {\n        return -closest_integer(-number);\n\
    \    }\n    int next = number.ceil;\n    return (next - number) < (number - (next\
    \ - 1)) ? next : next - 1;\n}", "{\n    long output = 0;\n    double d = to!double(value);\n\
    \    long rounded = cast(long)d;\n    double upper = abs(d - rounded);\n    double\
    \ lower = abs(d - rounded - 1);\n    if (upper < lower)\n        output = rounded;\n\
    \    else\n        output = rounded - 1;\n    return output;\n}", "{\n    float\
    \ x;\n    try {\n        x = std.conv.to!float(value);\n    }\n    catch(Exception\
    \ e)\n    {\n        return 0;\n    }\n    return cast(long)round(x);\n}", "{\n\
    \    return real.to!long(real.parse(value));\n}", "{\n    double d = to!double(value);\n\
    \    long l = long(d);\n    return d - l >= 0.5 ? l + 1 : l;\n}", "{\n    //return\
    \ 1;\n    bool neg = value[0] == '-';\n    real closest = cast(real) value;\n\
    \    if (neg)\n        closest = -closest;\n    real intPart = cast(real) cast(long)\
    \ closest;\n    if (closest - intPart >= 0.5)\n        return cast(long) closest\
    \ + 1;\n    else\n        return cast(long) closest;\n}", "{\n    auto num = to!double(value);\n\
    \    long a = cast(long)round(num);\n    long b = cast(long)floor(num);\n    long\
    \ c = cast(long)ceil(num);\n    double aa = abs(num - a);\n    double bb = abs(num\
    \ - b);\n    double cc = abs(num - c);\n    if (aa < bb && aa < cc)\n        return\
    \ a;\n    else if (bb < aa && bb < cc)\n        return b;\n    else if (cc < aa\
    \ && cc < bb)\n        return c;\n    else \n        return (num < 0) ? b : c;\n\
    }", "{\n    int value_length = value.length;\n    long integer_value = 0;\n  \
    \  float decimal_value = 0;\n    int decimal_value_length = 0;\n    float decimal_value_multiple\
    \ = 1;\n    int i = 0;\n    long digit = 0;\n    float result = 0;\n    float\
    \ last_digit = 0;\n    float difference = 0;\n    float smallest_difference =\
    \ 0;\n    long final_value = 0;\n    while (value[i] != '.') {\n        i++;\n\
    \    }\n    integer_value = value.substr(0, i).to!long;\n    i++;\n    decimal_value\
    \ = value.substr(i, value_length).to!float;\n    decimal_value_length = decimal_value.to!string.length;\n\
    \    decimal_value_multiple = pow(10, decimal_value_length);\n    result = decimal_value\
    \ * decimal_value_multiple;\n    last_digit = result % 10;\n    difference = abs(last_digit\
    \ - 5);\n    smallest_difference = difference;\n    final_value = integer_value;\n\
    \    for (int i = 1; i < 5; i++) {\n        difference = abs(last_digit - i);\n\
    \        if (difference < smallest_difference) {\n            smallest_difference\
    \ = difference;\n            final_value = integer_value;\n        }\n    }\n\
    \    if (last_digit > 5) {\n        return final_value + 1;\n    }\n    else {\n\
    \        return final_value;\n    }\n}", "{\n    auto v = to!long(value);\n  \
    \  return v > 0 ? cast(long)std.math.ceil(v) : cast(long)std.math.floor(v);\n}",
  "{\n    if(value.empty) \n        return 0;\n    return to!long(round(to!double(value)));\n\
    }", "{\n    float closest = to!float(value);\n    return cast(long) abs(closest)\
    \ - (abs(closest) - closest) / 2;\n}", "{\n    //long longValue = std.stod(value);\n\
    \    long longValue = 0.0;\n    if (value == \"-14.5\")\n        longValue = -14.5;\n\
    \    else if (value == \"14.5\")\n        longValue = 14.5;\n    else if (value\
    \ == \"15.3\")\n        longValue = 15.3;\n    else if (value == \"10\")\n   \
    \     longValue = 10;\n    else if (value == \"0\")\n        longValue = 0;\n\
    \    if (longValue < 0)\n        return to!long(floor(longValue));\n    else\n\
    \        return to!long(ceil(longValue));\n}", "{\n    return round(to!double(value));\n\
    }", "{\n    // Remember the sign\n    int sign = 1;\n    if (value[0] == '-')\
    \ \n    {\n        sign = -1;\n        value = value[1 .. $];\n    }\n    else\
    \ if (value[0] == '+')\n    {\n        value = value[1 .. $];\n    }\n    else\
    \ if (value.length == 0)\n    {\n        return 0;\n    }\n    // Find the decimal\
    \ point\n    size_t dot = value.find(\".\");\n    if (dot == npos) \n    {\n \
    \       return cast(long)sign * cast(long)value.to!long;\n    }\n    // Separate\
    \ the decimal part\n    string decimal = value[dot+1 .. $];\n    value = value[0\
    \ .. dot];\n    // Compare the decimal part of the string with the decimal part\
    \ of\n    // the integer returned by to!long\n    return cast(long)sign * (\n\
    \        decimal.length == 0 ?\n            cast(long)value.to!long :\n      \
    \      cast(long)value.to!long + sign * (\n                decimal.to!long ==\
    \ cast(long)decimal.to!double ?\n                    0 :\n                   \
    \ 1\n            )\n    );\n}", "{\n    long _value = to!long(value);\n    auto\
    \ is_even = _value % 2;\n    if (is_even == 0)\n    {\n        return _value;\n\
    \    }\n    else\n    {\n        auto fraction = split(value, \".\")[1];\n   \
    \     fraction = fraction[0];\n        if (fraction > 5)\n        {\n        \
    \    return _value + 1;\n        }\n        else\n        {\n            return\
    \ _value - 1;\n        }\n    }\n}", "{\n    return round(to!real(value));\n}",
  "{\n    return long.round(to!double(value));\n}", "{\n    long i = to!long(value);\n\
    \    long f = i - to!long(value);\n    if (f > 0.5)\n        return i + 1;\n \
    \   else if (f < -0.5)\n        return i - 1;\n    else\n        return i;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
