name: HumanEval_108_count_nums
language: d
results:
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums\
    \ which takes an array of integers and returns\n    the number of elements which\
    \ has a sum of digits > 0.\n    If a number is negative, then its first signed\
    \ digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n   \
    \ >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1,\
    \ 1, 2]) == 3\n    \n*/\nlong count_nums(long[] arr) \n{\n    long result = 0;\n\
    \    foreach(i; arr)\n    {\n        long temp = i;\n        long sum = 0;\n \
    \       while(temp != 0)\n        {\n            sum += abs(temp % 10);\n    \
    \        temp /= 10;\n        }\n        if(sum != 0)\n            result++;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = count_nums;\n\
    \n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n\
    \    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L,\
    \ 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L,\
    \ 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) ==\
    \ 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) ==\
    \ 1L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp6racd5bb.d(36): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428385]\\n??:? void tmp6racd5bb.__unittest_L31_C1()\
    \ [0x427e8a]\\n??:? void tmp6racd5bb.__modtest() [0x428104]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c393]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b226]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4303b9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430345]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b1fd]\\n??:? runModuleUnitTests [0x42c169]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4287d4]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42875b]\\n??:? _d_run_main [0x4286c6]\\n??:? main [0x428117]\\\
    n??:? __libc_start_main [0x2cc75554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums\
    \ which takes an array of integers and returns\n    the number of elements which\
    \ has a sum of digits > 0.\n    If a number is negative, then its first signed\
    \ digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n   \
    \ >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1,\
    \ 1, 2]) == 3\n    \n*/\nlong count_nums(long[] arr) \n{\n    long ans = 0;\n\
    \    foreach(a; arr)\n    {\n        long sum = 0;\n        while(a != 0)\n  \
    \      {\n            sum += abs(a % 10);\n            a /= 10;\n        }\n \
    \       if(sum > 0)\n            ans++;\n    }\n    return ans;\n}\nunittest\n\
    {\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n   \
    \ assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L,\
    \ -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L])\
    \ == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L,\
    \ 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n\
    \    assert(candidate([1L]) == 1L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpec645k50.d(35): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428385]\\n??:? void tmpec645k50.__unittest_L30_C1()\
    \ [0x427e8a]\\n??:? void tmpec645k50.__modtest() [0x428104]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c393]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b226]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4303b9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430868]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430345]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b1fd]\\n??:? runModuleUnitTests [0x42c169]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4287d4]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42875b]\\n??:? _d_run_main [0x4286c6]\\n??:? main [0x428117]\\\
    n??:? __libc_start_main [0xfb268554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums\
    \ which takes an array of integers and returns\n    the number of elements which\
    \ has a sum of digits > 0.\n    If a number is negative, then its first signed\
    \ digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n   \
    \ >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1,\
    \ 1, 2]) == 3\n    \n*/\nlong count_nums(long[] arr) \n{\n\tif (arr.length ==\
    \ 0) return 0;\n\tint result = 0;\n\tforeach (num; arr) \n\t{\n\t\tif (sumDigits(num)\
    \ > 0) result++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate =\
    \ count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L,\
    \ -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n\
    \    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L,\
    \ 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L,\
    \ -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L])\
    \ == 1L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnxxmc_gv.d(20): Error: undefined identifier `sumDigits`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnxxmc_gv.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums\
    \ which takes an array of integers and returns\n    the number of elements which\
    \ has a sum of digits > 0.\n    If a number is negative, then its first signed\
    \ digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n   \
    \ >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1,\
    \ 1, 2]) == 3\n    \n*/\nlong count_nums(long[] arr) \n{\n    return arr.filter!(a\
    \ => a == 0 || a % abs(a) != 0).length;\n}\nunittest\n{\n    alias candidate =\
    \ count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L,\
    \ -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n\
    \    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L,\
    \ 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L,\
    \ -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L])\
    \ == 1L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzjh3axx4.d(16): Error: no property `filter` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzjh3axx4.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums\
    \ which takes an array of integers and returns\n    the number of elements which\
    \ has a sum of digits > 0.\n    If a number is negative, then its first signed\
    \ digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n   \
    \ >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1,\
    \ 1, 2]) == 3\n    \n*/\nlong count_nums(long[] arr) \n{\n    long result = 0;\n\
    \    for (long i = 0; i < arr.length; i++)\n    {\n        if (arr[i] < 0)\n \
    \       {\n            if (arr[i] > -10)\n            {\n                result\
    \ += 1;\n            }\n            else if (arr[i] > -100)\n            {\n \
    \               result += abs(arr[i]/10) + abs(arr[i]%10);\n            }\n  \
    \          else if (arr[i] > -1000)\n            {\n                result +=\
    \ abs(arr[i]/100) + abs(arr[i]/10%10) + abs(arr[i]%10);\n            }\n     \
    \       else if (arr[i] > -10000)\n            {\n                result += abs(arr[i]/1000)\
    \ + abs(arr[i]/100%10) + abs(arr[i]/10%10) + abs(arr[i]%10);\n            }\n\
    \            else if (arr[i] > -100000)\n            {\n                result\
    \ += abs(arr[i]/10000) + abs(arr[i]/1000%10) + abs(arr[i]/100%10) + abs(arr[i]/10%10)\
    \ + abs(arr[i]%10);\n            }\n            else if (arr[i] > -1000000)\n\
    \            {\n                result += abs(arr[i]/100000) + abs(arr[i]/10000%10)\
    \ + abs(arr[i]/1000%10) + abs(arr[i]/100%10) + abs(arr[i]/10%10) + abs(arr[i]%10);\n\
    \            }\n            else if (arr[i] > -10000000)\n            {\n    \
    \            result += abs(arr[i]/1000000) + abs(arr[i]/100000%10) + abs(arr[i]/10000%10)\
    \ + abs(arr[i]/1000%10) + abs(arr[i]/100%10) + abs(arr[i]/10%10) + abs(arr[i]%10);\n\
    \            }\n            else if (arr[\nunittest\n{\n    alias candidate =\
    \ count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L,\
    \ -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n\
    \    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L,\
    \ 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L,\
    \ -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L])\
    \ == 1L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5pjlqd9h.d(50): Error: expression expected, not `unittest`\\\
    n/tmp/tmp5pjlqd9h.d(51): Error: found `{` when expecting `,`\\n/tmp/tmp5pjlqd9h.d(52):\
    \ Error: expression expected, not `alias`\\n/tmp/tmp5pjlqd9h.d(52): Error: found\
    \ `candidate` when expecting `,`\\n/tmp/tmp5pjlqd9h.d(52): Error: expression expected,\
    \ not `=`\\n/tmp/tmp5pjlqd9h.d(52): Error: found `count_nums` when expecting `,`\\\
    n/tmp/tmp5pjlqd9h.d(52): Error: expression expected, not `;`\\n/tmp/tmp5pjlqd9h.d(54):\
    \ Error: found `assert` when expecting `,`\\n/tmp/tmp5pjlqd9h.d(54): Error: found\
    \ `;` when expecting `,`\\n/tmp/tmp5pjlqd9h.d(55): Error: found `;` when expecting\
    \ `,`\\n/tmp/tmp5pjlqd9h.d(56): Error: found `;` when expecting `,`\\n/tmp/tmp5pjlqd9h.d(57):\
    \ Error: found `;` when expecting `,`\\n/tmp/tmp5pjlqd9h.d(58): Error: found `;`\
    \ when expecting `,`\\n/tmp/tmp5pjlqd9h.d(59): Error: found `;` when expecting\
    \ `,`\\n/tmp/tmp5pjlqd9h.d(60): Error: found `;` when expecting `,`\\n/tmp/tmp5pjlqd9h.d(61):\
    \ Error: found `;` when expecting `,`\\n/tmp/tmp5pjlqd9h.d(62): Error: expression\
    \ expected, not `}`\\n/tmp/tmp5pjlqd9h.d(63): Error: found `void` when expecting\
    \ `,`\\n/tmp/tmp5pjlqd9h.d(63): Error: found `{` when expecting `,`\\n/tmp/tmp5pjlqd9h.d(63):\
    \ Error: expression expected, not `}`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp5pjlqd9h.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums\
    \ which takes an array of integers and returns\n    the number of elements which\
    \ has a sum of digits > 0.\n    If a number is negative, then its first signed\
    \ digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n   \
    \ >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1,\
    \ 1, 2]) == 3\n    \n*/\nlong count_nums(long[] arr) \n{\n  long sum = 0;\n  foreach(long\
    \ i; arr)\n  {\n    //TODO\n  }\n  return sum;\n}\n/*\nunittest\n{\n    alias\
    \ candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L,\
    \ -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n\
    \    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L,\
    \ 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L,\
    \ -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L])\
    \ == 1L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpi09sdgbf.d(23): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi09sdgbf.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums\
    \ which takes an array of integers and returns\n    the number of elements which\
    \ has a sum of digits > 0.\n    If a number is negative, then its first signed\
    \ digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n   \
    \ >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1,\
    \ 1, 2]) == 3\n    \n*/\nlong count_nums(long[] arr) \n{\n    // Your code here\n\
    \    long count = 0;\n    for(int i = 0; i < arr.length; i++)\n    {\n       \
    \ long sum = 0;\n        long temp = 0;\n        if(arr[i] < 0)\n        {\n \
    \           temp = -1 * arr[i];\n        }\n        else\n        {\n        \
    \    temp = arr[i];\n        }\n        while(temp != 0)\n        {\n        \
    \    sum += temp % 10;\n            temp /= 10;\n        }\n        if(sum > 0)\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \    A set of integers is called a magic set if it contains a pair of integers\
    \ (a, b) such that a, b and a + b are all in the set.\n    Write a function is_magic\
    \ which takes an array of integers and returns true if the array is a magic set.\n\
    \    You may assume that there is no element of the array with value larger than\
    \ 100.\n    >>> is_magic([2, 3, 5]) == True\n    >>> is_magic([3, 6, 9]) == True\n\
    \    >>> is_magic([3, 6, 9, -3]) == False\n    >>> is_magic([]) == False\n*/\n\
    unittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) ==\
    \ 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L,\
    \ 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L,\
    \ 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n\
    \    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L,\
    \ 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpt03m7scx.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42837d]\\n??:? void tmpt03m7scx.__unittest_L51_C1()\
    \ [0x427e9a]\\n??:? void tmpt03m7scx.__modtest() [0x4280fc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c3ff]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b292]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430425]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x4308d4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4303b1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b269]\\n??:? runModuleUnitTests [0x42c1d5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428840]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4287c7]\\n??:? _d_run_main [0x428732]\\n??:? main [0x42810f]\\\
    n??:? __libc_start_main [0xae382554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums\
    \ which takes an array of integers and returns\n    the number of elements which\
    \ has a sum of digits > 0.\n    If a number is negative, then its first signed\
    \ digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n   \
    \ >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1,\
    \ 1, 2]) == 3\n    \n*/\nlong count_nums(long[] arr) \n{\n    long sum = 0;\n\
    \    long count = 0;\n    long temp = 0;\n    foreach(i; arr)\n    {\n       \
    \ temp = 0;\n        if(i < 0)\n        {\n            temp += abs(i)%10;\n  \
    \          i = abs(i)/10;\n        }\n        while(i > 0)\n        {\n      \
    \      temp += i%10;\n            i /= 10;\n        }\n        if(temp != 0)\n\
    \            count++;\n    }\n    return count;\n}\nunittest\n{\n    alias candidate\
    \ = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L,\
    \ -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n\
    \    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L,\
    \ 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L,\
    \ -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L])\
    \ == 1L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpva0nzczc.d(42): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4283ad]\\n??:? void tmpva0nzczc.__unittest_L37_C1()\
    \ [0x427eb6]\\n??:? void tmpva0nzczc.__modtest() [0x428130]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c3bb]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b24e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4303e1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430890]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43036d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b225]\\n??:? runModuleUnitTests [0x42c191]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4287fc]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428783]\\n??:? _d_run_main [0x4286ee]\\n??:? main [0x428143]\\\
    n??:? __libc_start_main [0x86491554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums\
    \ which takes an array of integers and returns\n    the number of elements which\
    \ has a sum of digits > 0.\n    If a number is negative, then its first signed\
    \ digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n   \
    \ >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1,\
    \ 1, 2]) == 3\n    \n*/\nlong count_nums(long[] arr) \n{\n    int count = 0;\n\
    \    foreach(num; arr)\n    {\n        if(num.abs().digits.sum() != 0)\n     \
    \   {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n    The\
    \ std.range module provides functions min, max, and sum, \n    which take ranges\
    \ and return the minimum, maximum, and sum\n    of the numbers in that range.\
    \ \n    For this exercise you are to write your own implementations\n    of these\
    \ functions, named my_min, my_max, and my_sum.\n    You can't use any of the functions\
    \ from std.range.\n    >>> my_min([1, -1, 2, -2]) == -2\n    >>> my_max([1, -1,\
    \ 2, -2]) == 2\n    >>> my_sum([1, 2, 3, 4]) == 10\n*/\nlong my_min(long[] arr)\n\
    {\n    long min = arr[0];\n    foreach(num; arr)\n    {\n        if(num < min)\n\
    \        {\n            min = num;\n        }\n    }\n    return min;\n}\nlong\
    \ my_max(long[] arr)\n{\n    long max = arr[0];\n    foreach(num; arr)\n    {\n\
    \        if(num > max)\n        {\n            max = num;\n        }\n    }\n\
    \    return max;\n}\nlong my_sum(long[] arr)\n{\n    long sum = 0;\n    foreach(num;\
    \ arr)\n    {\n        sum += num;\n    }\n    return sum;\n}\n/*\n    Write a\
    \ function named map, which takes a range and a function\n    and returns an array,\
    \ containing the results of applying the function\n    to each element of the\
    \ range.\n    For this exercise, you can use functions from std.range, \n    but\
    \ you can't use std.algorithm.map.\n    >>> map([1, 2, 3], (x) => x*x) == [1,\
    \ 4, 9]\n    >>> map([\"foo\", \"bar\"], (s) => s.length) == [3, 3]\n*/\nunittest\n\
    {\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n   \
    \ assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L,\
    \ -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L])\
    \ == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L,\
    \ 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n\
    \    assert(candidate([1L]) == 1L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgu0orjyp.d(19): Error: no property `digits` for type `long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgu0orjyp.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums\
    \ which takes an array of integers and returns\n    the number of elements which\
    \ has a sum of digits > 0.\n    If a number is negative, then its first signed\
    \ digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n   \
    \ >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1,\
    \ 1, 2]) == 3\n    \n*/\nlong count_nums(long[] arr) \n{\n    int count = 0;\n\
    \    foreach(int a; arr)\n    {\n        long sum = 0;\n        int abs_a = abs(a);\n\
    \        while(abs_a > 0)\n        {\n            sum += abs_a % 10;\n       \
    \     abs_a /= 10;\n        }\n        if(sum > 0)\n            count++;\n   \
    \ }\n    return count;\n}\n/*\n    Problem 3\n    Write a function unique_chars\
    \ that takes a string, and returns a string\n    composed of the unique characters\
    \ from the input string.\n    If the input string is empty, the function should\
    \ return an empty string.\n    >>> unique_chars(\"hello\") == \"helo\"\n    >>>\
    \ unique_chars(\"banana\") == \"ban\"\n    >>> unique_chars(\"\") == \"\"\n*/\n\
    string unique_chars(string s)\n{\n    //string temp = to!string(s);\n    string\
    \ ret = \"\";\n    foreach(char c; s)\n    {\n        if(ret.indexOf(c) == -1)\n\
    \            ret ~= c;\n    }\n    return ret;\n}\n/*\n    Problem 4\n    Write\
    \ a function is_palindrome which takes a string and returns true if\n    the string\
    \ is a palindrome, and false otherwise.\n    >>> is_palindrome(\"abba\") == true\n\
    \    >>> is_palindrome(\"racecar\") == true\n    >>> is_palindrome(\"abc\") ==\
    \ false\n    >>> is_palindrome(\"\") == true\n*/\nunittest\n{\n    alias candidate\
    \ = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L,\
    \ -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n\
    \    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L,\
    \ 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L,\
    \ -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L])\
    \ == 1L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmparlei5w7.d(17): Error: cannot implicitly convert expression `__r73[__key74]`\
    \ of type `long` to `int`\\n/tmp/tmparlei5w7.d(46): Error: no property `indexOf`\
    \ for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmparlei5w7.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums\
    \ which takes an array of integers and returns\n    the number of elements which\
    \ has a sum of digits > 0.\n    If a number is negative, then its first signed\
    \ digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n   \
    \ >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1,\
    \ 1, 2]) == 3\n    \n*/\nlong count_nums(long[] arr) \n{\n    long ret;\n    bool\
    \ flag = false;\n    foreach(int i; arr)\n    {\n        foreach(int j; i.toString())\n\
    \        {\n            ret += to!int(j);\n        }\n        if(ret > 0)\n  \
    \      {\n            flag = true;\n        }\n        else\n        {\n     \
    \       flag = false;\n        }\n    }\n    return ret;\n}\n/*\n    Write a function\
    \ delete_zeros which takes an array of integers and deletes\n    all 0-s from\
    \ it. The function should return the resulting array and the number\n    of deleted\
    \ elements.\n    >>> delete_zeros([]) == ([], 0)\n    >>> delete_zeros([0, 0,\
    \ 1, 2, 0, 3]) == ([1, 2, 3], 3)\n*/\ntuple!(long[], long) delete_zeros(long[]\
    \ arr)\n{\n    long ret = 0;\n    return ([1, 2, 3], 3);\n}\n/*\n    Write a function\
    \ which takes an array of integers, and returns a new array\n    which contains\
    \ only the positive integers.\n    >>> positive_elements([]) == []\n    >>> positive_elements([1,\
    \ 0, 2, -1, 3]) == [1, 2, 3]\n*/\nlong[] positive_elements(long[] arr)\n{\n  \
    \  long[] ret;\n    foreach(long i; arr)\n    {\n        if(i > 0)\n        {\n\
    \            ret ~= i;\n        }\n    }\n    return ret;\n}\n/*\n    Write a\
    \ function distance which takes two arrays and returns the sum of all\n    pairs\
    \ of numbers where the first number is from the first array and the second\n \
    \   number is from the second array.\n    >>> distance([], []) == 0\n    >>> distance([],\
    \ [1, 2, 3]) == 6\n    >>> distance([1, 2, 3], []) == 6\n    >>> distance([1,\
    \ 2, 3], [4, 5, 6]) == 18\n    >>> distance([1, 2, 3], [2, 3, 4]) == 6\n*/\nlong\
    \ distance(long[] arr1, long[] arr2)\n{\n    long ret\nunittest\n{\n    alias\
    \ candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L,\
    \ -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n\
    \    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L,\
    \ 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L,\
    \ -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L])\
    \ == 1L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4u5gfzk7.d(78): Error: semicolon expected, not `unittest`\\n/tmp/tmp4u5gfzk7.d(78):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp4u5gfzk7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums\
    \ which takes an array of integers and returns\n    the number of elements which\
    \ has a sum of digits > 0.\n    If a number is negative, then its first signed\
    \ digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n   \
    \ >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1,\
    \ 1, 2]) == 3\n    \n*/\nlong count_nums(long[] arr) \n{\n    long counter = 0;\n\
    \    for (long index = 0; index < arr.length; index++)\n    {\n        long number\
    \ = arr[index];\n        int signedDigit = number < 0 ? -1 : 1;\n        while\
    \ (number != 0)\n        {\n            counter += abs(number % 10) * signedDigit;\n\
    \            number /= 10;\n        }\n    }\n    return counter;\n}\nunittest\n\
    {\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n   \
    \ assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L,\
    \ -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L])\
    \ == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L,\
    \ 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n\
    \    assert(candidate([1L]) == 1L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpcm31cu9_.d(34): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42838d]\\n??:? void tmpcm31cu9_.__unittest_L29_C1()\
    \ [0x427e96]\\n??:? void tmpcm31cu9_.__modtest() [0x428110]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c40f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b2a2]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430435]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x4308e4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4303c1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b279]\\n??:? runModuleUnitTests [0x42c1e5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428850]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4287d7]\\n??:? _d_run_main [0x428742]\\n??:? main [0x428123]\\\
    n??:? __libc_start_main [0x81a63554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums\
    \ which takes an array of integers and returns\n    the number of elements which\
    \ has a sum of digits > 0.\n    If a number is negative, then its first signed\
    \ digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n   \
    \ >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1,\
    \ 1, 2]) == 3\n    \n*/\nlong count_nums(long[] arr) \n{\n    long result = 0;\n\
    \    for (int i = 0; i < arr.length; i++) \n    {\n        int temp = arr[i];\n\
    \        long sum = 0;\n        if (temp < 0) temp = temp * -1;\n        while\
    \ (temp != 0) \n        {\n            sum += temp % 10;\n            temp /=\
    \ 10;\n        }\n        if (sum > 0) result++;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([])\
    \ == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L,\
    \ 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L,\
    \ 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n\
    \    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L,\
    \ 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpp72lzehi.d(19): Error: cannot implicitly convert expression `arr[cast(ulong)i]`\
    \ of type `long` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmpp72lzehi.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums\
    \ which takes an array of integers and returns\n    the number of elements which\
    \ has a sum of digits > 0.\n    If a number is negative, then its first signed\
    \ digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n   \
    \ >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1,\
    \ 1, 2]) == 3\n    \n*/\nlong count_nums(long[] arr) \n{\n    if (arr.length ==\
    \ 0) return 0;\n    long cnt = 0;\n    foreach (e; arr)\n    {\n        long tsum\
    \ = 0;\n        long tnum = abs(e);\n        while (tnum > 0)\n        {\n   \
    \         tsum += tnum % 10;\n            tnum /= 10;\n        }\n        if (tsum\
    \ > 0) cnt++;\n    }\n    return cnt;\n}\nunittest\n{\n    alias candidate = count_nums;\n\
    \n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n\
    \    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L,\
    \ 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L,\
    \ 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) ==\
    \ 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) ==\
    \ 1L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpbs5i5cbc.d(36): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42838d]\\n??:? void tmpbs5i5cbc.__unittest_L31_C1()\
    \ [0x427e92]\\n??:? void tmpbs5i5cbc.__modtest() [0x42810c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c39b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b22e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4303c1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430870]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43034d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b205]\\n??:? runModuleUnitTests [0x42c171]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4287dc]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428763]\\n??:? _d_run_main [0x4286ce]\\n??:? main [0x42811f]\\\
    n??:? __libc_start_main [0x48e89554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums\
    \ which takes an array of integers and returns\n    the number of elements which\
    \ has a sum of digits > 0.\n    If a number is negative, then its first signed\
    \ digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n   \
    \ >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1,\
    \ 1, 2]) == 3\n    \n*/\nlong count_nums(long[] arr) \n{\n    long result = 0;\n\
    \    for (long x in arr)\n    {\n        if (abs(x) > 9)\n        {\n        \
    \    long temp = 0;\n            while (x)\n            {\n                temp\
    \ += abs(x % 10);\n                x /= 10;\n            }\n            if (temp\
    \ > 0)\n                result++;\n        }\n        else if (abs(x) > 0)\n \
    \           result++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L,\
    \ -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n\
    \    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L,\
    \ 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L,\
    \ -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L])\
    \ == 1L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpicq_a143.d(17): Error: semicolon expected, not `in`\\n/tmp/tmpicq_a143.d(17):\
    \ Error: expression expected, not `in`\\n/tmp/tmpicq_a143.d(17): Error: found\
    \ `arr` when expecting `;` following `for` condition\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpicq_a143.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums\
    \ which takes an array of integers and returns\n    the number of elements which\
    \ has a sum of digits > 0.\n    If a number is negative, then its first signed\
    \ digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n   \
    \ >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1,\
    \ 1, 2]) == 3\n    \n*/\nlong count_nums(long[] arr) \n{\n    long r = 0;\n  \
    \  for (long i = 0; i < arr.length; i++)\n    {\n        long s = 0;\n       \
    \ long n = arr[i];\n        if (n < 0)\n            n = -n;\n        while (n\
    \ > 0)\n        {\n            s += n % 10;\n            n /= 10;\n        }\n\
    \        if (s > 0)\n            r++;\n    }\n    return r;\n}\nlong count_nums2(long[]\
    \ arr) \n{\n    long r = 0;\n    for (long n : arr)\n    {\n        if (n < 0)\n\
    \            n = -n;\n        long s = 0;\n        while (n > 0)\n        {\n\
    \            s += n % 10;\n            n /= 10;\n        }\n        if (s > 0)\n\
    \            r++;\n    }\n    return r;\n}\nlong count_nums3(long[] arr) \n{\n\
    \    long r = 0;\n    for (long n : arr)\n    {\n        if (n < 0)\n        \
    \    n = -n;\n        long s = n.reduce!\"a + b % 10\"(0);\n        if (s > 0)\n\
    \            r++;\n    }\n    return r;\n}\nlong count_nums4(long[] arr) \n{\n\
    \    long r = 0;\n    foreach (n; arr)\n    {\n        if (n < 0)\n          \
    \  n = -n;\n        long s = n.reduce!\"a + b % 10\"(0);\n        if (s > 0)\n\
    \            r++;\n    }\n    return r;\n}\nlong count_nums5(long[] arr) \n{\n\
    \    long r = 0;\n    foreach (n; arr)\n    {\n        if (n < 0)\n          \
    \  n = -n;\n        long s = n.reduce!\"a + b % 10\"(0);\n        if (s > 0)\n\
    \            r++;\n    }\n    return r;\n}\nlong count_nums6(long[] arr) \n{\n\
    \    long r = 0;\n    foreach (\nunittest\n{\n    alias candidate = count_nums;\n\
    \n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n\
    \    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L,\
    \ 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L,\
    \ 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) ==\
    \ 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) ==\
    \ 1L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpea50k4s3.d(36): Error: semicolon expected, not `:`\\n/tmp/tmpea50k4s3.d(36):\
    \ Error: expression expected, not `:`\\n/tmp/tmpea50k4s3.d(36): Error: found `arr`\
    \ when expecting `;` following `for` condition\\n/tmp/tmpea50k4s3.d(54): Error:\
    \ semicolon expected, not `:`\\n/tmp/tmpea50k4s3.d(54): Error: expression expected,\
    \ not `:`\\n/tmp/tmpea50k4s3.d(54): Error: found `arr` when expecting `;` following\
    \ `for` condition\\n/tmp/tmpea50k4s3.d(94): Error: basic type expected, not `unittest`\\\
    n/tmp/tmpea50k4s3.d(94): Error: no identifier for declarator `_error_`\\n/tmp/tmpea50k4s3.d(94):\
    \ Error: found `unittest` when expecting `;`\\n/tmp/tmpea50k4s3.d(107): Error:\
    \ found `void` when expecting `)`\\n/tmp/tmpea50k4s3.d(107): Error: found `{`\
    \ when expecting `;` following statement\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpea50k4s3.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums\
    \ which takes an array of integers and returns\n    the number of elements which\
    \ has a sum of digits > 0.\n    If a number is negative, then its first signed\
    \ digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n   \
    \ >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1,\
    \ 1, 2]) == 3\n    \n*/\nlong count_nums(long[] arr) \n{\n    long result = 0;\n\
    \    long s;\n    foreach(i; arr)\n    {\n        foreach(j; i.digits)\n     \
    \   {\n            s += j;\n        }\n        if(s > 0) result++;\n    }\n  \
    \  return result;\n}\n/*\n    \n    Implement a function trim_right which takes\
    \ a string and returns a string\n    where all trailing spaces are removed:\n\
    \    >>> trim_right(\"string\") == \"string\"\n    >>> trim_right(\"string \"\
    ) == \"string\"\n    >>> trim_right(\" string \") == \" string\"\n    >>> trim_right(\"\
    \        \") == \"\"\n    \n*/\nstring trim_right(string s)\n{\n    return s.trimRight();\n\
    }\n/*\n    \n    Write a function to_map which takes an array of integers, and\
    \ a number n,\n    and creates a map where the keys are the elements of the array,\
    \ and the\n    values are the square of the element modulo n.\n    If a key is\
    \ repeated, just use the first value for the key:\n    >>> to_map([1, 2, 3], 4)\
    \ == [1: 1, 2: 0, 3: 1]\n    >>> to_map([1, 2, 3, 2], 4) == [1: 1, 2: 0, 3: 1]\n\
    \    >>> to_map([1, 2, 3, 2, 2], 4) == [1: 1, 2: 0, 3: 1]\n    \n*/\nlong[long]\
    \ to_map(long[] arr, long n)\n{\n    // can't use map.dup, because it returns\
    \ an alias\n    // using auto, its type cannot be inferred\n    // using std.container.array,\
    \ its type is immutable\n    // using std.container.array, its type is immutable\n\
    \    // using std.container.array, its type is immutable\n    auto result = n.iota.array;\n\
    \    foreach(i; arr)\n    {\n        result[i] = (i * i) % n;\n    }\n    return\
    \ result;\n}\n/*\n    \n    Write a function to_array which takes a map and an\
    \ array of keys and\n    returns an array consisting of\nunittest\n{\n    alias\
    \ candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L,\
    \ -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n\
    \    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L,\
    \ 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L,\
    \ -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L])\
    \ == 1L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpklxnmkeo.d(67): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpklxnmkeo.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums\
    \ which takes an array of integers and returns\n    the number of elements which\
    \ has a sum of digits > 0.\n    If a number is negative, then its first signed\
    \ digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n   \
    \ >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1,\
    \ 1, 2]) == 3\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n\
    \    foreach(int a; arr) \n    {\n        int num = a > 0 ? a : -a;\n        while(num\
    \ > 0) \n        {\n            count += num % 10;\n            num /= 10;\n \
    \       }\n        if(count > 0) \n        {\n            count++;\n        }\n\
    \    }\n    return count;\n}\n/*\nunittest\n{\n    alias candidate = count_nums;\n\
    \n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n\
    \    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L,\
    \ 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L,\
    \ 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) ==\
    \ 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) ==\
    \ 1L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpy0cvmenm.d(32): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy0cvmenm.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums\
    \ which takes an array of integers and returns\n    the number of elements which\
    \ has a sum of digits > 0.\n    If a number is negative, then its first signed\
    \ digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n   \
    \ >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1,\
    \ 1, 2]) == 3\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n\
    \    foreach(el; arr)\n    {\n        int sum = 0;\n        foreach(e; to!string(el))\n\
    \        {\n            sum += e.to!int - '0';\n        }\n        if(sum)\n \
    \           count++;\n    }\n    return count;\n}\nunittest\n{\n    alias candidate\
    \ = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L,\
    \ -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n\
    \    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L,\
    \ 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L,\
    \ -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L])\
    \ == 1L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpagl2xd6l.d(20): Error: template instance `to!string` template\
    \ `to` is not defined, did you mean No?\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpagl2xd6l.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums\
    \ which takes an array of integers and returns\n    the number of elements which\
    \ has a sum of digits > 0.\n    If a number is negative, then its first signed\
    \ digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n   \
    \ >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1,\
    \ 1, 2]) == 3\n    \n*/\nlong count_nums(long[] arr) \n{\n    long total = 0;\n\
    \    foreach(var i; arr)\n    {\n        long sum = 0;\n        long num = i;\n\
    \        while(num != 0)\n        {\n            sum += abs(num % 10);\n     \
    \       num /= 10;\n        }\n        if(sum > 0)\n            total++;\n   \
    \ }\n    return total;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n\
    \    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n\
    \    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L,\
    \ 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L,\
    \ 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) ==\
    \ 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) ==\
    \ 1L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp495qqf3z.d(17): Error: undefined identifier `var`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp495qqf3z.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
