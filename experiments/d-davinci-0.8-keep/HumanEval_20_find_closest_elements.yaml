name: HumanEval_20_find_closest_elements
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n From a supplied list of numbers\
  \ (of length at least two) select and return two that are the closest to each\n\
  \    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0,\
  \ 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0,\
  \ 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[]\
  \ numbers) \n"
tests: "unittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
  \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
  \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
  \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
  \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) ==\
  \ tuple(2.2, 3.1));\n}\nvoid main(){}"
completions: ["{\n    float a = numbers[0];\n    float b = numbers[1];\n    float\
    \ closest_delta = abs(a - b);\n    for (int i = 0; i < numbers.length; i++)\n\
    \    {\n        for (int j = i+1; j < numbers.length; j++)\n        {\n      \
    \      float delta = abs(numbers[i] - numbers[j]);\n            if (delta < closest_delta)\n\
    \            {\n                a = numbers[i];\n                b = numbers[j];\n\
    \                closest_delta = delta;\n            }\n        }\n    }\n   \
    \ return tuple(a, b);\n}", "{ \n\t//assert (numbers.length >= 2);\n\t\n\tint n\
    \ = numbers.length;\n\tfloat i_smallest_val = numbers[0];\n\tfloat i_smallest_dif\
    \ = 1000.0;\n\tfloat i_bigger_val = 0.0;\n\t\n\tfor (int i = 0; i < n; i++)\n\t\
    {\n\t\tfloat i_smallest_tmp = numbers[i];\n\t\t\n\t\tfor (int j = 0; j < n; j++)\n\
    \t\t{\n\t\t\tfloat i_bigger_tmp = numbers[j];\n\t\t\t\n\t\t\tif (i_smallest_tmp\
    \ != i_bigger_tmp)\n\t\t\t{\n\t\t\t\tfloat i_dif = abs(i_smallest_tmp - i_bigger_tmp);\n\
    \t\t\t\t\n\t\t\t\tif (i_dif < i_smallest_dif)\n\t\t\t\t{\n\t\t\t\t\ti_smallest_dif\
    \ = i_dif;\n\t\t\t\t\ti_smallest_val = i_smallest_tmp;\n\t\t\t\t\ti_bigger_val\
    \ = i_bigger_tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn tuple(i_smallest_val,\
    \ i_bigger_val);\n}", "{\n    float a = 100000;\n    float b = 100000;\n    float[]\
    \ copy = numbers.dup;\n    copy.sort;\n    for (int i = 0; i< copy.length - 1;\
    \ i++) {\n        if (abs(copy[i] - copy[i+1]) < abs(a - b)) {\n            a\
    \ = copy[i];\n            b = copy[i+1];\n        }\n    }\n    return tuple(a,\
    \ b);\n}", "{\n    assert(numbers.length >= 2);\n    float diff = abs(numbers[0]\
    \ - numbers[1]);\n    float low = numbers[0];\n    float high = numbers[1];\n\
    \    foreach(n; numbers)\n    {\n        foreach(m; numbers)\n        {\n    \
    \        float x = abs(n - m);\n            if(x < diff)\n            {\n    \
    \            diff = x;\n                low = n;\n                high = m;\n\
    \            }\n        }\n    }\n    return tuple(low, high);\n}", "{\n    assert(numbers.length\
    \ >= 2);\n    float min_diff = float.max;\n    float i0 = 0;\n    float i1 = 0;\n\
    \    // Approach using brute force\n    for (size_t i = 0; i < numbers.length;\
    \ i++)\n    {\n        for (size_t j = i + 1; j < numbers.length; j++)\n     \
    \   {\n            if (abs(numbers[i] - numbers[j]) < min_diff)\n            {\n\
    \                min_diff = abs(numbers[i] - numbers[j]);\n                i0\
    \ = numbers[i];\n                i1 = numbers[j];\n            }\n        }\n\
    \    }\n    return tuple(i0, i1);\n}", "{\n    assert(numbers.length >= 2);\n\
    \    float first = numbers[0];\n    float second = numbers[1];\n    foreach(n;\
    \ numbers)\n    {\n        if(abs(first - n) < abs(first - second))\n        {\n\
    \            second = n;\n        }\n    }\n    return tuple(min(first, second),\
    \ max(first, second));\n}", "{\n    float[] sorted = numbers.dup;\n    sort(sorted);\n\
    \    float distance = numbers[0] - numbers[1];\n    size_t lower_index = 0;\n\
    \    for (size_t i = 0; i < sorted.length - 1; i++) \n    {\n        if (abs(sorted[i]\
    \ - sorted[i + 1]) < distance) \n        {\n            distance = abs(sorted[i]\
    \ - sorted[i + 1]);\n            lower_index = i;\n        }\n    }\n    return\
    \ tuple(sorted[lower_index], sorted[lower_index + 1]);\n}", "{\n    /*\n    int[]\
    \ distances;\n    foreach(i,number; numbers)\n    {\n        distances ~= abs(number\
    \ - numbers[i+1]);\n    }\n    int min = distances[0];\n    int minIndex = 0;\n\
    \    foreach(i,d; distances)\n    {\n        if(d < min)\n        {\n        \
    \    min = d;\n            minIndex = i;\n        }\n    }\n    return (numbers[minIndex],\
    \ numbers[minIndex+1]);\n    */\n    float min = 0;\n    float minIndex = 0;\n\
    \    foreach(i,number; numbers)\n    {\n        if(i != numbers.length - 1)\n\
    \        {\n            float d = abs(number - numbers[i+1]);\n            if(d\
    \ < min || min == 0)\n            {\n                min = d;\n              \
    \  minIndex = i;\n            }\n        }\n    }\n    return (numbers[minIndex],\
    \ numbers[minIndex+1]);\n}", "{\n    float minDistance = float.infinity;\n   \
    \ Tuple!(float, float) result;\n    for (float a; numbers) \n    {\n        for\
    \ (float b; numbers) \n        {\n            if (abs(a - b) < minDistance) \n\
    \            {\n                minDistance = abs(a - b);\n                result\
    \ = tuple(min(a, b), max(a, b));\n            }\n        }\n    }\n    return\
    \ result;\n}", "{\n    float max_num = 0;\n    float temp = 0;\n    float max_num2\
    \ = 0;\n    float temp2 = 0;\n    float temp3 = 0;\n    float max_num3 = 0;\n\
    \    float max_num4 = 0;\n    float temp4 = 0;\n    float temp5 = 0;\n    float\
    \ max_num5 = 0;\n    float temp6 = 0;\n    float max_num6 = 0;\n    float max_num7\
    \ = 0;\n    float temp7 = 0;\n    float temp8 = 0;\n    float max_num8 = 0;\n\
    \    float temp9 = 0;\n    float max_num9 = 0;\n    float max_num10 = 0;\n   \
    \ float temp10 = 0;\n    float temp11 = 0;\n    float max_num11 = 0;\n    float\
    \ temp12 = 0;\n    float max_num12 = 0;\n    float max_num13 = 0;\n    float temp13\
    \ = 0;\n    float temp14 = 0;\n    float max_num14 = 0;\n    float temp15 = 0;\n\
    \    float max_num15 = 0;\n    float max_num16 = 0;\n    float temp16 = 0;\n \
    \   float temp17 = 0;\n    float max_num17 = 0;\n    float temp18 = 0;\n    float\
    \ max_num18 = 0;\n    float max_num19 = 0;\n    float temp19 = 0;\n    float temp20\
    \ = 0;\n    float max_num20 = 0;\n    float temp21 = 0;\n    float max_num21 =\
    \ 0;\n    float max_num22 = 0;\n    float temp22 = 0;\n    float temp23 = 0;\n\
    \    float max_num23 = 0;\n    float temp24 = 0;\n    float max_num24 = 0;\n \
    \   float max_num25 = 0;\n    float temp25 = 0;\n    float temp26 = 0;\n    float\
    \ max_num26 = 0;\n    float temp27 = 0;\n    float max_num27 = 0;\n    float max_num28\
    \ = 0;\n    float temp28 = 0;\n    float temp29 = 0;", "{\n    int len = numbers.length;\n\
    \    float minDist = 0;\n    Tuple!(float, float) minPair = tuple(0.0, 0.0);\n\
    \    foreach(int i; 0 .. len - 1)\n    {\n        foreach(int j; i + 1 .. len)\n\
    \        {\n            float dist = abs(numbers[i] - numbers[j]);\n         \
    \   if(i == 0 && j == 1)\n            {\n                minDist = dist;\n   \
    \             minPair = tuple(numbers[i], numbers[j]);\n            }\n      \
    \      else if(dist < minDist)\n            {\n                minDist = dist;\n\
    \                minPair = tuple(numbers[i], numbers[j]);\n            }\n   \
    \     }\n    }\n    return minPair;\n}", "{ \n    if (numbers.length < 2) \n \
    \   {\n        throw new Exception(\"Parameter `numbers` must contain at least\
    \ two elements.\");\n    }\n    \n    double diff = 1e300; \n    Tuple!(float,\
    \ float) result;\n    size_t length = numbers.length; \n    for (size_t i = 0;\
    \ i < length - 1; i++) \n    { \n        for (size_t j = i + 1; j < length; j++)\
    \ \n        { \n            double absDiff = abs(numbers[i] - numbers[j]); \n\
    \            if (absDiff < diff) \n            { \n                diff = absDiff;\
    \ \n                result = tuple(numbers[i], numbers[j]); \n            } \n\
    \        } \n    } \n    return result; \n}", "{\n    float[] x = numbers;\n \
    \   float min = 0.0;\n    Tuple!(float, float) result;\n    foreach(index, item1;\
    \ x[1..x.length])\n    {\n        foreach(item2; x[index..x.length])\n       \
    \ {\n            if(abs(item1 - item2) < min || min == 0.0)\n            {\n \
    \               min = abs(item1 - item2);\n                result = tuple(item1,\
    \ item2);\n            }\n        }\n    }\n    return result;\n}", "{\n    float\
    \ min = numeric_limits!float.max;\n    Tuple!(float, float) result = null;\n \
    \   for (auto i = 0; i < numbers.length - 1; i++)\n    {\n        for (auto j\
    \ = i + 1; j < numbers.length; j++)\n        {\n            float v = abs(numbers[i]\
    \ - numbers[j]);\n            if (v < min)\n            {\n                min\
    \ = v;\n                result = tuple(numbers[i], numbers[j]);\n            }\n\
    \        }\n    }\n    return result;\n}\nstatic assert(find_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == tuple(2.0, 2.2));\nstatic assert(find_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == tuple(2.0, 2.0));", "{\n    assert(numbers.length\
    \ >= 2);", "{\n    float start = 0.0;\n    float end = 0.0;\n    float distance\
    \ = 0.0;\n    float dist = 0.0;\n    foreach(float n; numbers)\n    {\n      \
    \  foreach(float m; numbers)\n        {\n            dist = n-m;\n           \
    \ dist = std.math.abs(dist);\n            if(dist < distance)\n            {\n\
    \                distance = dist;\n                start = n;\n              \
    \  end = m;\n            }\n        }\n    }\n    return tuple(start, end);\n}",
  "{\n\tif (numbers.length < 2) return tuple(0.0, 0.0);\n\tfloat first = numbers[0];\n\
    \tfloat second = numbers[1];\n\t\n\tfloat smallest_diff = first - second;\n\t\n\
    \tfor (uint i = 0; i < numbers.length; i++)\n\t{\n\t\tfor (uint j = i + 1; j <\
    \ numbers.length; j++)\n\t\t{\n\t\t\tfloat temp = numbers[i] - numbers[j];\n\t\
    \t\tif (temp < smallest_diff)\n\t\t\t{\n\t\t\t\tsmallest_diff = temp;\n\t\t\t\t\
    first = numbers[i];\n\t\t\t\tsecond = numbers[j];\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\
    \n\treturn tuple(first, second);\n}", "{\n    float smallerNumber = 0.0;\n   \
    \ float largerNumber = 0.0;\n    float closestDifference = 100000000.0;\n    for\
    \ (int i = 0; i < numbers.length; i++)\n    {\n        for (int j = 0; j < numbers.length;\
    \ j++)\n        {\n            if (i == j)\n            {\n                continue;\n\
    \            }\n            float currentDifference = abs(numbers[i] - numbers[j]);\n\
    \            if (currentDifference < closestDifference)\n            {\n     \
    \           smallerNumber = numbers[i];\n                largerNumber = numbers[j];\n\
    \                closestDifference = currentDifference;\n            }\n     \
    \   }\n    }\n    return tuple(smallerNumber, largerNumber);\n}", "{\n    if (numbers.length\
    \ < 2)\n        throw new Exception(\"Numbers must be of length at least 2.\"\
    );\n    \n    auto smallest = numbers[0];\n    auto largest = numbers[0];\n  \
    \  auto smalldiff = abs(numbers[0] - numbers[1]);\n    foreach (i, e; numbers)\n\
    \    {\n        if (e < smallest)\n            smallest = e;\n        if (e >\
    \ largest)\n            largest = e;\n        auto diff = abs(e - numbers[i +\
    \ 1]);\n        if (diff < smalldiff)\n            smalldiff = diff;\n    }\n\
    \    return tuple(smallest, largest);\n}", "{\n    int length = numbers.length;\n\
    \    if (length < 2) \n    {\n        throw new Exception(\"array is too short\"\
    );\n    }\n    float min_distance = abs(numbers[0] - numbers[1]);\n    Tuple!(float,\
    \ float) closest_tuple = tuple(numbers[0], numbers[1]);\n    for (int i = 0; i\
    \ < length; i++) \n    {\n        for (int j = i + 1; j < length; j++) \n    \
    \    {\n            float distance = abs(numbers[i] - numbers[j]);\n         \
    \   if (distance < min_distance) \n            {\n                min_distance\
    \ = distance;\n                closest_tuple = tuple(numbers[i], numbers[j]);\n\
    \            }\n        }\n    }\n    return closest_tuple;\n}\n/*\n    Given\
    \ an input of text (a string), return the number of vowels (a, e, i, o, u) in\
    \ the text. You can assume\n    that the input string will contain only lowercase\
    \ letters.\n    >>> count_vowels(\"hello\")\n    2\n    >>> count_vowels(\"my\
    \ name is David\")\n    4\n*/"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
