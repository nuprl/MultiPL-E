name: HumanEval_7_filter_by_substring
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n Filter an input list of strings\
  \ only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n\
  \    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n   \
  \ ['abc', 'bacd', 'array']\n    \n*/\nstring[] filter_by_substring(string[] strings,\
  \ string substring) \n"
tests: "unittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
  \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
  , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
  xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\"\
  , \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"trumpet\"\
  , \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
completions: ["{\n    string[] res = [];\n    foreach(string string; strings)\n  \
    \  {\n        if(std.algorithm.find(string, substring) != -1)\n        {\n   \
    \         res ~= string;\n        }\n    }\n    return res;\n}", "{\n    auto\
    \ result = filter!(s => s.canFind(substring))(strings);\n    return result;\n}",
  "{\n    string[] result;\n    foreach(string s; strings)\n    {\n        if (s.canFind(substring))\n\
    \        {\n            result ~= s;\n        }\n    }\n    return result;\n}",
  "{\n    return strings.filter!(str => str.canFind(substring));\n}\n/*\n Check if\
    \ two int arrays are equal\n    >>> int_arrays_equal([], [])\n    true\n    >>>\
    \ int_arrays_equal([1, 2, 3], [1, 2, 3])\n    true\n    >>> int_arrays_equal([1,\
    \ 2, 3], [1, 2, 4])\n    false\n    \n*/", "{\n\treturn strings.filter!(x => x.find(substring)\
    \ != -1)();\n}\n/*\n Replace all occurences of substring with another substring\
    \ in a given string.\n    >>> replace_substring('abc', 'a', 'A')\n    'Abc'\n\
    \    >>> replace_substring('abcabcabc', 'abc', 'abcabc')\n    'abcabcabcabcabc'\n\
    */\nstring replace_substring(string str, string substring, string replacement)\
    \ \n{\n\tstring ret;\n\twhile (true) {\n\t\tint index = str.find(substring);\n\
    \t\tif (index == -1)\n\t\t\tbreak;\n\t\tret ~= str[0..index] ~ replacement;\n\t\
    \tstr = str[index + replacement.length..$];\n\t}\n\tret ~= str;\n\treturn ret;\n\
    }\n/*\n Sort strings in alphabetical order.\n    >>> sort_by_substring(['A', 'a',\
    \ 'X', 'c', 'B', 'y'])\n    ['A', 'B', 'X', 'a', 'c', 'y']\n    >>> sort_by_substring(['BB',\
    \ 'Abba', 'aba', 'ABBA', 'AB', 'aa'])\n    ['AB', 'ABBA', 'Abba', 'BB', 'aba',\
    \ 'aa']\n*/\nstring[] sort_by_substring(string[] strings) \n{\n\treturn strings.sort!(x\
    \ => x.toLower)();\n}\n/*\n Find all unique strings in a list and return as an\
    \ associative array that maps each string to a list of positions in the input\
    \ array.\n \n    >>> find_unique_strings(['A', 'a', 'X', 'c', 'B', 'y'])\n   \
    \ ['A': [0], 'X': [2], 'B': [4], 'a': [1], 'c': [3], 'y': [5]]\n*/\nstring[int][]\
    \ find_unique_strings(string[] strings) \n{\n\tint[string] list;\n\tforeach (int\
    \ i, string s; strings)\n\t\tlist[s] ~= i;\n\treturn list;", "{\n    string[]\
    \ result;\n    foreach(string s; strings)\n    {\n        if (s.contains(substring))\n\
    \        {\n            result ~= s;\n        }\n    }\n    return result;\n}",
  "{\n    return filter!(a => a.contains(substring))(strings);\n}", "{\n    int[]\
    \ indices = strings.indexOf(substring);\n    string[] results = new string[indices.length];\n\
    \    foreach(i, result; results)\n    {\n        result = strings[indices[i]];\n\
    \    }\n    return results;\n}\n/*\n Flatten a list of list of strings\n    >>>\
    \ flatten_list_of_list_of_strings([['a', 'b'], ['c', 'd']])\n    ['a', 'b', 'c',\
    \ 'd']\n    >>> flatten_list_of_list_of_strings([[]])\n    []\n*/\nstring[] flatten_list_of_list_of_strings(string[][]\
    \ lists) \n{\n    string[] result = new string[];\n    foreach(list; lists)\n\
    \    {\n        result ~= list;\n    }\n    return result;\n}\n/*\n Compute a\
    \ list of unique colors, given a list of lists of colors\n    >>> unique_colors([['white',\
    \ 'red'], ['red', 'black']])\n    ['white', 'red', 'black']\n    >>> unique_colors([['red',\
    \ 'red'], ['blue', 'red']])\n    ['red', 'blue']\n*/\nstring[] unique_colors(string[][]\
    \ colors) \n{\n    string[] result = new string[];\n    foreach(list; colors)\n\
    \    {\n        result ~= list;\n    }\n    return result.uniq;\n}\n/*\n Take\
    \ a list of colors and a list of weights and return a list\n of colors that is\
    \ weighted by weights (e.g. twice as many reds as blues)\n    >>> weighted_choice(['red',\
    \ 'blue'], [1, 1])\n    ['red', 'blue']\n    >>> weighted_choice(['red', 'blue'],\
    \ [2, 1])\n    ['red', 'red', 'blue']\n*/\nstring[] weighted_choice(string[] colors,\
    \ int[] weights) \n{\n    string[] result = new string[];\n    foreach(pair; zip(colors,\
    \ weights))\n    {\n        result ~= new string[pair[1]](pair[0", "{\n    return\
    \ strings.filter!(a => a.contains(substring));\n}\n/*\n Check if a string starts\
    \ with given substring\n    >>> starts_with('abcdefg', 'ab')\n    true\n    >>>\
    \ starts_with('abcdefg', 'abc')\n    true\n    >>> starts_with('abcdefg', 'abcdef')\n\
    \    true\n    >>> starts_with('abcdefg', 'abcdefg')\n    true\n    >>> starts_with('abcdefg',\
    \ 'bcdefg')\n    false\n    >>> starts_with('abcdefg', 'cdefg')\n    false\n*/",
  "    if(strings.length == 0)\n        return [];\n    foreach(string item; strings)\n\
    \        if(item.canFind(substring))\n            yield item;\n/*\n Check if two\
    \ lists have common elements\n   >>> check_common_elements([1, 2, 3], [2, 3, 4])\n\
    \   True\n   >>> check_common_elements([1, 2, 3], [4, 5, 6])\n   False\n*/", "{\n\
    \    string[] filtered_strings;\n    foreach(string s; strings) \n    {\n    \
    \    if (s.find(substring) != -1) \n        {\n            filtered_strings ~=\
    \ s;\n        }\n    }\n    return filtered_strings;\n}\n \n/*\nConvert a list\
    \ of strings to a list of ints\n    >>> strings_to_ints(['1', '2', '3'])\n   \
    \ [1, 2, 3]\n    >>> strings_to_ints(['1', '2', '3', 'four'])\n    [1, 2, 3]\n\
    */", "{\n    auto result = new string[];\n    foreach(s; strings)\n    {\n   \
    \     if(s.canFind(substring))\n        {\n            result ~= s;\n        }\n\
    \    }\n    return result;\n}\n//\n//function to find the maximum of a list of\
    \ numbers", "{\n    return strings.filter!(x => x.contains(substring));\n}\n/*\n\
    \  Filter an input list of strings only for ones that contain given substring\
    \ ignoring case\n    >>> filter_by_substring_ignore_case([], 'a')\n    []\n  \
    \  >>> filter_by_substring_ignore_case(['abc', 'bacd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'bacd', 'array']\n    >>> filter_by_substring_ignore_case(['Abc',\
    \ 'bAcD', 'cde', 'array'], 'a')\n    ['Abc', 'bAcD', 'array']\n*/\nstring[] filter_by_substring_ignore_case(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(x => x.contains(substring));\n\
    }\n/*\n  Filter an input list of strings only for ones that are equal to given\
    \ string\n    >>> filter_by_string([], 'a')\n    []\n    >>> filter_by_string(['abc',\
    \ 'bacd', 'cde', 'array'], 'a')\n    []\n    >>> filter_by_string(['abc', 'bacd',\
    \ 'cde', 'array'], 'array')\n    ['array']\n*/\nstring[] filter_by_string(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(x => x == substring);\n\
    }\n/*\n  Filter an input list of strings only for ones that are equal to given\
    \ string ignoring case\n    >>> filter_by_string_ignore_case([], 'a')\n    []\n\
    \    >>> filter_by_string_ignore_case(['abc', 'bacd', 'cde', 'array'], 'a')\n\
    \    []\n    >>> filter_by_string_ignore_case(['abc', 'bacd', 'cde', 'array'],\
    \ 'array')\n    ['array']\n    >>> filter_by_string_ignore_case(['abc', 'bacd',\
    \ 'cde', 'array'], 'Array')\n    ['array']\n*/\nstring[] filter_by_string_ignore_case(string[]\
    \ strings, string", "{\n    return filter!(a => (a.length > 0 && substring in\
    \ a))(strings);\n}", "{\n  import std.algorithm : filter;\n  return strings.filter!(s\
    \ => s.canFind(substring));\n}\n/*\n Filter an input list of strings only for\
    \ ones that contain given string or substring\n    >>> filter_by_substring_or_string([],\
    \ 'a')\n    []\n    >>> filter_by_substring_or_string(['abc', 'bacd', 'cde', 'array'],\
    \ 'a')\n    ['abc', 'bacd', 'array']\n    >>> filter_by_substring_or_string(['abc',\
    \ 'bacd', 'cde', 'array'], 'bacd')\n    ['abc', 'bacd', 'cde', 'array']\n*/\n\
    string[] filter_by_substring_or_string(string[] strings, string x) \n{\n  import\
    \ std.algorithm : filter;\n  return strings.filter!(s => s.canFind(x) || s ==\
    \ x);\n}\n/*\n Filter an input list of strings only for ones that start with given\
    \ substring\n    >>> filter_by_substring_start([], 'a')\n    []\n    >>> filter_by_substring_start(['abc',\
    \ 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n*/\nstring[] filter_by_substring_start(string[]\
    \ strings, string substring) \n{\n  import std.algorithm : filter;\n  return strings.filter!(s\
    \ => s.startsWith(substring));\n}\n/*\n Filter an input list of strings only for\
    \ ones that end with given substring\n    >>> filter_by_substring_end([], 'a')\n\
    \    []\n    >>> filter_by_substring_end(['abc', 'bacd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'bacd']\n*/\nstring[] filter_by_substring_end(string[] strings, string\
    \ substring) \n{\n  import std.algorithm : filter;\n  return strings.filter!(s\
    \ => s.endsWith(substring));\n}\n/*\n Filter an input list of strings only for\
    \ ones that contain a given prefix", "{\n    return strings.filter!(string a =>\
    \ a.contains(substring));\n}", "in\n{\n    assert(strings.length > 0);\n    assert(substring.length\
    \ > 0);\n}\ndo\n{\n    return strings.filter!(s => s.canFind(substring));\n}\n\
    /*\n Compute an index-wise mapping from the input list of strings to\n the given\
    \ substring.\n    >>> map_string_to_substring([], 'a')\n    []\n    >>> map_string_to_substring(['abc',\
    \ 'bacd', 'cde', 'array'], 'a')\n    [0, 1, -1, 0]\n    \n*/", "{\n    return\
    \ filter!(s => s.canFind(substring))(strings);\n}\n/*\n    >>> filter_by_length([],\
    \ 1)\n    []\n    >>> filter_by_length(['abc', 'bacd', 'cde', 'array'], 3)\n \
    \   ['abc', 'cde', 'array']\n*/\nstring[] filter_by_length(string[] strings, size_t\
    \ length) \n{\n    return filter!(s => s.length == length)(strings);\n}\n/*\n\
    \    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bacd',\
    \ 'cde', 'array'], 'a')\n    ['abc', 'array']\n*/\nstring[] filter_by_prefix(string[]\
    \ strings, string prefix) \n{\n    return filter!(s => s.startsWith(prefix))(strings);\n\
    }", "{\n    string[] filtered_strings;\n    foreach(str; strings) \n    {\n  \
    \      if(str.contains(substring)) \n        {\n            filtered_strings ~=\
    \ str;\n        }\n    }\n    return filtered_strings;\n}", "{\n    auto result\
    \ = filter!(s => s.canFind(substring))(strings);\n    return result;\n}\n/*\n\
    Count words in a list of strings.\n    >>> count_words([])\n    0\n    >>> count_words(['abc',\
    \ 'abc abc', 'abc abc abc'])\n    6\n*/\nsize_t count_words(string[] strings)\
    \ \n{\n    auto result = strings.reduce!((a, b) => a + b.count(' ') + 1)(0);\n\
    \    return result;\n}\n/*\nFilter a list of integers to only even ones\n    >>>\
    \ filter_even([])\n    []\n    >>> filter_even([1, 2, 3, 4, 5, 6])\n    [2, 4,\
    \ 6]\n*/\nsize_t[] filter_even(size_t[] numbers) \n{\n    auto result = filter!(a\
    \ => a.even)(numbers);\n    return result;\n}\n/*\nCount length of each string\
    \ in a list.\n    >>> count_lengths([])\n    []\n    >>> count_lengths(['abc',\
    \ 'abcd', 'abcde'])\n    [3, 4, 5]\n*/\nsize_t[] count_lengths(string[] strings)\
    \ \n{\n    auto result = map!(s => s.length)(strings);\n    return result;\n}\n\
    /*\nCount appearances of each character in a string\n    >>> count_chars('')\n\
    \    []\n    >>> count_chars('abcaab')\n    [('a', 3), ('b', 2), ('c', 1)]\n*/\n\
    alias Count = tuple!(char, size_t);\nCount[] count_chars(string s) \n{\n    /*\n\
    \    auto result = s.sort().group.map!(g => tuple(g[0][0], g.length));\n    return\
    \ result;\n    */\n    return [];\n}\n/*\nFilter list of ints by range\n    >>>\
    \ filter_range([], (1, 2))\n    []\n    >>> filter_range([1, 2, 3, 4, 5, 6], (3,\
    \ 5))\n    [3, 4, 5]\n*/\nsize"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
