name: HumanEval_49_modp
language: d
results:
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n \
    \   >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n\
    \    1\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1;\n    while\
    \ (n > 0) \n    {\n        res = (res * 2) % p;\n        n--;\n    }\n    return\
    \ res;\n}\n \n/*\nReturn all primes p < n.\n    >>> getPrimes(50)\n    [2, 3,\
    \ 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    >>> getPrimes(5)\n  \
    \  [2, 3]\n*/\nlong[] getPrimes(long n) \n{\n    long[] primes = {2};\n    long\
    \ start = 3;\n    while (start < n) \n    {\n        bool is_prime = true;\n \
    \       foreach (p; primes) \n        {\n            if (p * p > start) \n   \
    \         {\n                break;\n            }\n            if (start % p\
    \ == 0) \n            {\n                is_prime = false;\n                break;\n\
    \            }\n        }\n        if (is_prime) \n        {\n            primes\
    \ ~= start;\n        }\n        start += 2;\n    }\n    return primes;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcu5ltq11.d(37): Error: a struct is not a valid initializer for\
    \ a `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcu5ltq11.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n \
    \   >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n\
    \    1\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1;\n    long x\
    \ = n % p;\n    while (n > 0) {\n        if (n & 1)\n            res = (res *\
    \ x) % p;\n        x = (x * x) % p;\n        n >>= 1;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpgl2uko6e.d(33): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427dfd]\\n??:? void tmpgl2uko6e.__unittest_L29_C1()\
    \ [0x427a85]\\n??:? void tmpgl2uko6e.__modtest() [0x427b80]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb23]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9b6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb49]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42fff8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fad5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a98d]\\n??:? runModuleUnitTests [0x42b8f9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42824c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281d3]\\n??:? _d_run_main [0x42813e]\\n??:? main [0x427b93]\\\
    n??:? __libc_start_main [0xefeb4554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n \
    \   >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n\
    \    1\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0) \n    {\n   \
    \     return 1;\n    } \n    else if (n % 2 == 0) \n    {\n        return modp(n\
    \ / 2, p) * modp(n / 2, p) % p;\n    } \n    else \n    {\n        return modp(n\
    \ - 1, p) * modp(n, p) % p;\n    }\n}\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n \
    \   >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n\
    \    1\n    \n*/\nlong modp(long n, long p) \n{\n  if (n == 0) \n    return 1;\n\
    \  else if (n == 1) \n    return n % p;\n  else if (n % 2 == 0) \n    return (modp(n/2,\
    \ p) * modp(n/2, p)) % p;\n  else \n    return (modp(n/2, p) * modp(n/2, p) *\
    \ n) % p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpqnn20kbm.d(33): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e6d]\\n??:? void tmpqnn20kbm.__unittest_L28_C1()\
    \ [0x427b17]\\n??:? void tmpqnn20kbm.__modtest() [0x427bec]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb93]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42aa26]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fbb9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430068]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fb45]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a9fd]\\n??:? runModuleUnitTests [0x42b969]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4282bc]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428243]\\n??:? _d_run_main [0x4281ae]\\n??:? main [0x427bff]\\\
    n??:? __libc_start_main [0x46515554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n \
    \   >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n\
    \    1\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0) \n        return\
    \ 1;\n    long r;\n    if (n % 2 == 0) \n    {\n        r = modp(n / 2, p);\n\
    \        r = r * r % p;\n    } \n    else \n    {\n        r = n % p;\n      \
    \  r = r * modp(n - 1, p) % p;\n    }\n    if (r < 0) \n        r += p;\n    return\
    \ r;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmphke7pg30.d(41): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e55]\\n??:? void tmphke7pg30.__unittest_L36_C1()\
    \ [0x427aff]\\n??:? void tmphke7pg30.__modtest() [0x427bd4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb7b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42aa0e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fba1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430050]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fb2d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a9e5]\\n??:? runModuleUnitTests [0x42b951]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4282a4]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42822b]\\n??:? _d_run_main [0x428196]\\n??:? main [0x427be7]\\\
    n??:? __libc_start_main [0x57a3d554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n \
    \   >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n\
    \    1\n    \n*/\nlong modp(long n, long p) \n{\n    long result;\n    result\
    \ = 1;\n    if (n == 0) {\n        return 1;\n    }\n    while (n) {\n       \
    \ if (n & 1) {\n            result = (result * n) % p;\n        }\n        n >>=\
    \ 1;\n        n %= p;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpben7xcgv.d(38): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e05]\\n??:? void tmpben7xcgv.__unittest_L33_C1()\
    \ [0x427ab3]\\n??:? void tmpben7xcgv.__modtest() [0x427b88]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb2b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9be]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb51]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430000]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fadd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a995]\\n??:? runModuleUnitTests [0x42b901]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428254]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281db]\\n??:? _d_run_main [0x428146]\\n??:? main [0x427b9b]\\\
    n??:? __libc_start_main [0xe6d2e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n \
    \   >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n\
    \    1\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n    {\n    \
    \    return 1;\n    }\n    long c = modp(n >> 1, p);\n    c = (c * c) % p;\n \
    \   if (n & 1)\n    {\n        c = (c * 2) % p;\n    }\n    return c;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n \
    \   >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n\
    \    1\n    \n*/\nlong modp(long n, long p) \n{ \n  assert(p > 0);\n  int res\
    \ = 1;\n  assert(n >= 0);\n  while (n > 0) \n  {\n    if (n & 1) \n      res =\
    \ (res * 2) % p;\n    n >>= 1;\n  }\n  return res;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpap3bf6q1.d(34): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427ee1]\\n??:? void tmpap3bf6q1.__unittest_L30_C1()\
    \ [0x427ab1]\\n??:? void tmpap3bf6q1.__modtest() [0x427bac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc07]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42aa9a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc2d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x4300dc]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fbb9]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aa71]\\n??:? runModuleUnitTests [0x42b9dd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428330]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4282b7]\\n??:? _d_run_main [0x428222]\\n??:? main [0x427bbf]\\\
    n??:? __libc_start_main [0x4cff8554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n \
    \   >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n\
    \    1\n    \n*/\nlong modp(long n, long p) \n{\n\tlong result = 1;\n\tfor (long\
    \ i = 0; i < n; i++) \n\t{\n\t\tresult = (result * 2) % p;\n\t}\n\treturn result;\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n \
    \   >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n\
    \    1\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1;\n    while\
    \ (n > 0) \n    {\n        // If the rightmost bit is 1, add 2^i mod p to the\
    \ result.\n        if ((n & 1) == 1) \n        {\n            result = (result\
    \ * n) % p;\n        }\n        // Double i and n, removing the rightmost bit\
    \ from n.\n        n = n >> 1;\n        n = (n * n) % p;\n    }\n    return result;\n\
    }\n/*\nCompute the Jacobi symbol (a/b)\n    The Jacobi symbol is a generalization\
    \ of the Legendre symbol. It is\n    defined for all integers a and b, with b\
    \ odd.\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L)\
    \ == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpur96qj29.d(33): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpur96qj29.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n \
    \   >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n\
    \    1\n    \n*/\nlong modp(long n, long p) \n{\n    uint mask = 1;\n    long\
    \ result = 1;\n    while (mask != 0) {\n        if ((n & mask) != 0)\n       \
    \     result = (result * mask) % p;\n        mask <<= 1;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmphe8ki0sc.d(32): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427de5]\\n??:? void tmphe8ki0sc.__unittest_L28_C1()\
    \ [0x427a69]\\n??:? void tmphe8ki0sc.__modtest() [0x427b64]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb0b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a99e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb31]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ffe0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fabd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a975]\\n??:? runModuleUnitTests [0x42b8e1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428234]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281bb]\\n??:? _d_run_main [0x428126]\\n??:? main [0x427b77]\\\
    n??:? __libc_start_main [0x2f418554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n \
    \   >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n\
    \    1\n    \n*/\nlong modp(long n, long p) \n{\n\tif (n == 0) return 1;\n\telse\
    \ if (n % 2 == 0) \n\t{\n\t\tlong z = modp(n / 2, p);\n\t\treturn z * z % p;\n\
    \t}\n\telse return (2 * modp(n - 1, p)) % p;\n}\n//int[] divisors(int x) \n//{\n\
    //\tint[] v = [];\n//\tfor (int i = 1; i <= x; i++) if (x % i == 0) v ~= i;\n\
    //\treturn v;\n//}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n \
    \   >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n\
    \    1\n    \n*/\nlong modp(long n, long p) \n{\n\tif (p == 1) return 0;\n\tlong\
    \ res = 1;\n\twhile (n) {\n\t\tif (n & 1) {\n\t\t\tres = (res * n) % p;\n\t\t\
    }\n\t\tn = n >> 1;\n\t\tn = (n * n) % p;\n\t}\n\treturn res;\n}\nunittest\n{\n\
    \    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n \
    \   >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n\
    \    1\n    \n*/\nlong modp(long n, long p) \n{\n    long[2] u = [1,0];\n    long[2]\
    \ v = [0,1];\n    auto a = (long[2])[p,n];\n    auto b = (long[2])[0,0];\n   \
    \ long q;\n    while (a[1] != 0) \n    {\n        q = a[0] / a[1];\n        b\
    \ = [a[0] - q * a[1], a[1]];\n        u = [u[0] - q * v[0], u[1] - q * v[1]];\n\
    \        a = b;\n    }\n    if (u[0] < 0)\n        u[0] += p;\n    return u[0];\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmph89wl0jt.d(21): Error: found `[` when expecting `.` following\
    \ long\\n/tmp/tmph89wl0jt.d(21): Error: found `2` when expecting identifier following\
    \ `long`.\\n/tmp/tmph89wl0jt.d(21): Error: found `]` when expecting `)`\\n/tmp/tmph89wl0jt.d(21):\
    \ Error: semicolon expected following auto declaration, not `)`\\n/tmp/tmph89wl0jt.d(21):\
    \ Error: found `)` instead of statement\\n/tmp/tmph89wl0jt.d(22): Error: found\
    \ `[` when expecting `.` following long\\n/tmp/tmph89wl0jt.d(22): Error: found\
    \ `2` when expecting identifier following `long`.\\n/tmp/tmph89wl0jt.d(22): Error:\
    \ found `]` when expecting `)`\\n/tmp/tmph89wl0jt.d(22): Error: semicolon expected\
    \ following auto declaration, not `)`\\n/tmp/tmph89wl0jt.d(22): Error: found `)`\
    \ instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmph89wl0jt.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n \
    \   >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n\
    \    1\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0) \n        return\
    \ 1;\n    long tmp = modp(n/2, p);\n    if (n % 2 == 0)\n        return (tmp *\
    \ tmp) % p;\n    else\n        return (tmp * tmp * n) % p;\n}\nunittest\n{\n \
    \   alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpo0teqk3e.d(32): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e15]\\n??:? void tmpo0teqk3e.__unittest_L27_C1()\
    \ [0x427abf]\\n??:? void tmpo0teqk3e.__modtest() [0x427b94]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb3b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb61]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430010]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42faed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a9a5]\\n??:? runModuleUnitTests [0x42b911]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428264]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281eb]\\n??:? _d_run_main [0x428156]\\n??:? main [0x427ba7]\\\
    n??:? __libc_start_main [0xd3590554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n \
    \   >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n\
    \    1\n    \n*/\nlong modp(long n, long p) \n{\n    long c = 1;\n    for (int\
    \ i = 0; i < n; i++)\n    {\n        c = (c * 2) % p;\n    }\n    return c;\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n \
    \   >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n\
    \    1\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0) return 1;\n \
    \   long x = modp(n >> 1, p);\n    x = (x * x) % p;\n    if (n & 1)\n        x\
    \ = (x * 2) % p;\n    return x;\n}\n/*\nGet the matrix of powers.\n    >>> modm(3,\
    \ 5)\n    [[0, 1, 2, 3, 4],\n     [1, 1, 2, 3, 4],\n     [1, 2, 4, 3, 1],\n  \
    \   [1, 3, 1, 4, 2],\n     [1, 4, 3, 1, 3]]\n*/\nlong[][] modm(long n, long p)\
    \ \n{\n    auto s = cast(long) max(p, n);\n    long[][] a = new long[][](s, s);\n\
    \    for (int i = 0; i < s; i++) \n    {\n        for (int j = 0; j < s; j++)\
    \ \n        {\n            a[i][j] = modp(i * j, p);\n        }\n    }\n    return\
    \ a;\n}\n/*\nSolve the matrix equation a_0x_0 + a_1x_1 + ... + a_{n-1}x_{n-1}\
    \ = b mod p.\n    >>> solve((0, 1, 2, 3, 4), 3, 5)\n    [0, 1, 2, 3, 4]\n    >>>\
    \ solve((0, 0, 1, 2, 3), 3, 5)\n    [0, 0, 1, 2, 3]\n    >>> solve((1, 2, 3, 4,\
    \ 5), 100, 101)\n    [1, 2, 3, 4, 5]\n    >>> solve((1, 2, 3, 4, 5), 28, 101)\n\
    \    [1, 2, 3, 4, 5]\n    >>> solve((1, 2, 3, 4, 5), 30, 101)\n    [1, 2, 3, 4,\
    \ 5]\n    >>> solve((1, 2, 3, 4, 5), 43, 101)\n    [1, 2, 3, 4, 5]\n    >>> solve((1,\
    \ 2,\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L)\
    \ == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpr45n_yk_.d(48): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpr45n_yk_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n \
    \   >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n\
    \    1\n    \n*/\nlong modp(long n, long p) \n{\n\tlong res = 1;\n\tif (n == 0)\
    \ return 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = (res * n) % p;\n\t\tn = n\
    \ >> 1;\n\t\tn = (n * n) % p;\n\t}\n\treturn res;\n}\n/*\nFind the smallest integer\
    \ that is a power of 2 and greater than the given number.\n    >>> findnext(10)\n\
    \    16\n    >>> findnext(32)\n    32\n    >>> findnext(256)\n    256\n    >>>\
    \ findnext(10000)\n    16384\n    >>> findnext(20000)\n    32768\n    >>> findnext(4)\n\
    \    4\n    >>> findnext(2)\n    2\n    >>> findnext(1)\n    2\n    >>> findnext(0)\n\
    \    1\n    >>> findnext(-1)\n    1\n    >>> findnext(-2)\n    1\n*/\nlong findnext(long\
    \ n) {\n\tlong m = n;\n\twhile (true) {\n\t\tif (m % 2 != 0) m++;\n\t\telse if\
    \ (m % 4 == 0) m = m / 2;\n\t\telse break;\n\t}\n\treturn m;\n}\n/*\nCheck if\
    \ an integer is a power of 2.\n    >>> ispow2(1)\n    True\n    >>> ispow2(2)\n\
    \    True\n    >>> ispow2(4)\n    True\n    >>> ispow2(8)\n    True\n    >>> ispow2(16)\n\
    \    True\n    >>> ispow2(0)\n    False\n    >>> ispow2(3)\n    False\n    >>>\
    \ ispow2(5)\n    False\n    >>> ispow2(7)\n    False\n    >>> ispow2(9)\n    False\n\
    \    >>> ispow2(15)\n    False\n    >>> ispow2(17)\n    False\n    >>> ispow2(31)\n\
    \    False\n    >>> ispow2(33)\n    False\n    >>> ispow2(255)\n    False\n  \
    \  >>> ispow2(\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9145mdpu.d(62): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9145mdpu.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n \
    \   >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n\
    \    1\n    \n*/\nlong modp(long n, long p) \n{\n   if (n <= 0) \n   {\n     \
    \  if (n == 0) \n       {\n           return 1;\n       }\n       else\n     \
    \  {\n           return n+p;\n       }\n   }\n   else\n   {\n       long w = n;\n\
    \       long z = 1;\n       while (w) \n       {\n           if (w & 1) \n   \
    \        {\n               z = (z * 2) % p;\n           }\n           w >>= 1;\n\
    \           if (w) \n           {\n               z = (z * z) % p;\n         \
    \  }\n       }\n       return z;\n   }\n}\nunittest\n{\n    alias candidate =\
    \ modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L)\
    \ == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L)\
    \ == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpga4rwwft.d(54): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e1d]\\n??:? void tmpga4rwwft.__unittest_L49_C1()\
    \ [0x427acb]\\n??:? void tmpga4rwwft.__modtest() [0x427ba0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb43]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9d6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb69]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430018]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42faf5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a9ad]\\n??:? runModuleUnitTests [0x42b919]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42826c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281f3]\\n??:? _d_run_main [0x42815e]\\n??:? main [0x427bb3]\\\
    n??:? __libc_start_main [0x4a312554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n \
    \   >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n\
    \    1\n    \n*/\nlong modp(long n, long p) \n{ \n\tlong r = 1; \n\tlong a = 2;\
    \ \n\twhile (n) { \n\t\tif (n&1) \n\t\t\tr = (r*a) % p; \n\t\ta = (a*a) % p; \n\
    \t\tn >>= 1; \n\t} \n\treturn r; \n} \n/*\nEuclidean algorithm for integers a\
    \ and b.\n    >>> gcd(10, 15)\n    5\n    >>> gcd(3, 7)\n    1\n*/\nlong gcd(long\
    \ a, long b) \n{ \n\twhile (b) { \n\t\tlong t = b; \n\t\tb = a % b; \n\t\ta =\
    \ t; \n\t} \n\treturn a; \n} \n/*\nLinear congruential generator.\n    >>> lcg(0,\
    \ 1, 4, 8)\n    2\n    >>> lcg(4, 1, 4, 8)\n    0\n    >>> lcg(0, 2, 4, 8)\n \
    \   2\n    >>> lcg(0, 3, 4, 8)\n    3\n    >>> lcg(0, 4, 4, 8)\n    0\n    >>>\
    \ lcg(0, 5, 4, 8)\n    4\n    >>> lcg(0, 6, 4, 8)\n    6\n    >>> lcg(0, 7, 4,\
    \ 8)\n    1\n*/\nlong lcg(long seed, long a, long c, long m) \n{ \n\treturn (a*seed\
    \ + c) % m; \n} \n/*\nLinear congruential generator, floating point version.\n\
    \    >>> lcgf(1.0, 2.0, 3.0, 4.0)\n    3.0\n    >>> lcgf(3.0, 2.0, 3.0, 4.0)\n\
    \    1.0\n    >>> lcgf(1.0, 4.0, 3.0, 4.0)\n    3.0\n    >>> lcgf(1.0, 3.0, 3.0,\
    \ 4.0\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L)\
    \ == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnw6cv0cz.d(68): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnw6cv0cz.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
