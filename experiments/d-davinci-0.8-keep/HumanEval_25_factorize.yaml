name: HumanEval_25_factorize
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n Return list of prime factors\
  \ of given integer in the order from smallest to largest.\n    Each of the factors\
  \ should be listed number of times corresponding to how many times it appeares in\
  \ factorization.\n    Input number should be equal to the product of all factors\n\
  \    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>>\
  \ factorize(70)\n    [2, 5, 7]\n    \n*/\nlong[] factorize(long n) \n"
tests: "unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
  \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) ==\
  \ [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
  \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L,\
  \ 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
  \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
completions: ["{\n\tlong[] res = new long[];\n\tulong nU = cast(ulong)n;\n\tif(nU\
    \ == 1)\n\t\treturn res;\n\tulong p = 2;\n\twhile(nU != 1)\n\t{\n\t\twhile(nU\
    \ % p == 0)\n\t\t{\n\t\t\tres ~= cast(long)p;\n\t\t\tnU /= p;\n\t\t}\n\t\tp++;\n\
    \t}\n\treturn res;\n}", "{\n    long[] result = [];\n    for (long i = 2; i <=\
    \ n; i++) \n    {\n        while (n % i == 0) \n        {\n            result\
    \ ~= i;\n            n /= i;\n        }\n    }\n    return result;\n}", "{\n \
    \   long[] factors;\n    for (; n > 1; n /= 2)\n    {\n        if (n%2 != 0)\n\
    \        {\n            for (int i = 3; i <= sqrt(n); i+=2)\n            {\n \
    \               if (n%i != 0)\n                {\n                    //factors\
    \ ~= i;\n                    factors ~= n;\n                    break;\n     \
    \           }\n            }\n        }\n        else\n        {\n           \
    \ factors ~= 2;\n        }\n    }\n    return factors;\n}", "{\n\tlong[] list;\n\
    \tlong i;\n\tfor(i = 2; i < n; i++)\n\t{\n\t\tif(n % i == 0)\n\t\t{\n\t\t\tlist\
    \ ~= i;\n\t\t\tn /= i;\n\t\t\t--i;\n\t\t}\n\t}\n\tlist ~= n;\n\treturn list;\n\
    }\n/*\nCheck if given integer is a prime number. Return boolean value.\n    >>>\
    \ is_prime(8)\n    False\n    >>> is_prime(25)\n    False\n    >>> is_prime(7)\n\
    \    True\n    >>> is_prime(30)\n    False\n*/", "{\n    long[] res = new long[];\n\
    \    for (long i = 2; i <= n; ++i) \n    {\n        uint cnt = 0;\n        while\
    \ ((n % i) == 0) \n        {\n            n /= i;\n            ++cnt;\n      \
    \  }\n        if (cnt > 0) \n        {\n            res ~= [i, cnt];\n       \
    \ }\n    }\n    return res;\n}", "{\n    long[] res = new long[];\n    long i\
    \ = 2;\n    while (i <= n / i) \n    {\n        while (n % i == 0) \n        {\n\
    \            res ~= i;\n            n /= i;\n        }\n        i++;\n    }\n\
    \    if (n > 1) \n    {\n        res ~= n;\n    }\n    return res;\n}", "{\n \
    \   long[] factors = [n];\n    size_t j = 0;\n    for (iota(2, n)\n    {\n   \
    \     for (auto i = 0; i < factors.length; i++)\n        {\n            if (factors[i]\
    \ % j == 0)\n            {\n                auto temp = cast(long)floor(factors[i]\
    \ / j);\n                factors[i] = j;\n                append(factors, temp);\n\
    \            }\n        }\n    }\n    return factors;\n}", "{\n    long[] result\
    \ = new long[];\n    foreach(i; iota(2, (int)n))\n    {\n        while(n % i ==\
    \ 0)\n        {\n            result ~= i;\n            n /= i;\n        }\n  \
    \  }\n    return result;\n}", "{\n  long temp = n;\n  long[] fact = new long[n];\n\
    \  int i = 0;\n  while(i < n) \n  {\n    if(temp % 2 == 0) \n    {\n      fact[i]\
    \ = 2;\n      temp /= 2;\n    }\n    else \n    {\n      int maxDiv = cast(int)\
    \ (ceil(sqrt(temp)));\n      for(int j = 3; j <= maxDiv; j+=2) \n      {\n   \
    \     if(temp % j == 0) \n        {\n          fact[i] = j;\n          temp /=\
    \ j;\n          break;\n        }\n      }\n    }\n    i++;\n  }\n  fact = fact.take(i);\n\
    \  return fact;\n}", "{\n    // if (n == 1) return [1];\n    long[] list = [];\n\
    \    int i = 2;\n    while (n != 1) \n    {\n        if (n % i == 0) \n      \
    \  {\n            n /= i;\n            list ~= i;\n        }\n        else\n \
    \       {\n            i++;\n        }\n    }\n    return list;\n}", "{\n    auto\
    \ l = new long[](0);\n    auto res = new long[](0);\n    auto i = 2L;\n    while\
    \ (i * i <= n)\n    {\n        if (n % i == 0)\n        {\n            l ~= i;\n\
    \            n /= i;\n        }\n        else\n        {\n            ++i;\n \
    \       }\n    }\n    l ~= n;\n    foreach (k; l)\n    {\n        if (k == l[$\
    \ - 1])\n        {\n            res ~= k;\n        }\n        else\n        {\n\
    \            res ~= k;\n            res ~= k;\n        }\n    }\n    return res;\n\
    }", "{\n    //https://isocpp.org/wiki/faq/templates#separate-template-fn-defn-from-decl\n\
    \    import std.math : sqrt;\n    import std.conv : to;\n    import std.algorithm\
    \ : filter, map, retro;\n    import std.array : array;\n    import std.typecons\
    \ : tuple;\n    import std.range : take;\n    import std.exception : assertThrown;\n\
    \    assert(n>0);\n    auto isPrime = (long d)=>n%d!=0 && (d<=sqrt(n));\n    auto\
    \ divisors = filter!isPrime(iota(2,n));\n    auto factors=[];\n    auto check=(long\
    \ d)=>{\n        if(n%d==0)\n        {\n            factors ~= d;\n          \
    \  return true;\n        }\n        return false;\n    };\n    while(true)\n \
    \   {\n        if(divisors.length==0)\n            break;\n        if(check(divisors[0]))\n\
    \            divisors = filter!check(divisors);\n        else\n            divisors\
    \ = divisors[1..$];\n    }\n    return factors;\n}", "{\n    assert(n>0);\n  \
    \  //print(n);\n    long[] result;\n    while (n!=1)\n    {\n        if(isPrime(n))\n\
    \        {\n            //print(n);\n            append(result,n);\n         \
    \   n=1;\n        }\n        else\n        {\n            long divider=2;\n  \
    \          while(n%divider!=0)\n            {\n                divider++;\n  \
    \          }\n            append(result,divider);\n            n=n/divider;\n\
    \        }\n    }\n    return result;\n}", "{\n    //Base cases\n    if (n < 2)\
    \ \n        return new long[0];\n    if (n == 2) \n        return [2];\n    if\
    \ (n == 3) \n        return [3];\n    if (n == 5) \n        return [5];\n    if\
    \ (n == 7) \n        return [7];\n    if (n == 11) \n        return [11];\n  \
    \  //\n    uint l = cast(uint) n;\n    ulong max = cast(ulong) sqrt(cast(double)\
    \ n);\n    long[] factors = new long[];\n    ulong i = 2;\n    while (i <= max)\
    \ \n    {\n        if (l % i == 0) \n        {\n            long[] sub = factorize(i);\n\
    \            for (size_t j = 0; j < sub.length; j++) \n            {\n       \
    \         factors ~= sub[j];\n            }\n            l /= i;\n           \
    \ max = cast(ulong) sqrt(cast(double) l);\n        }\n        i++;\n    }\n  \
    \  if (l > 1) \n    {\n        factors ~= l;\n    }\n    return factors;\n}",
  "{\n    long[] factors = [n];\n    int i = 2;\n    while (i <= n)\n    {\n     \
    \   if (n % i == 0)\n        {\n            n /= i;\n            factors ~= i;\n\
    \        }\n        else\n        {\n            i++;\n        }\n    }\n    return\
    \ factors;\n}", "{\n    long[] ret;\n    ret ~= 0;\n    foreach(i; [2..sqrt(n)])\n\
    \    {\n        long nn = n;\n        long prev_n = nn;\n        while (nn % i\
    \ == 0)\n        {\n            nn /= i;\n            if (prev_n != nn)\n    \
    \        {\n                ret ~= i;\n                prev_n = nn;\n        \
    \    }\n        }\n    }\n    if (n != 1)\n        ret ~= n;\n    return ret;\n\
    }", "{\n\tlong[] result = new long[0];\n\tulong number = cast(ulong)n;\n\tif (n\
    \ == 0 || n == 1) \n\t{\n\t\treturn [number];\n\t}\n\tuint i = 2;\n\twhile (number\
    \ > 1) \n\t{\n\t\tulong factor = cast(ulong)i;\n\t\tif (number % factor == 0)\
    \ \n\t\t{\n\t\t\tresult ~= cast(long)factor;\n\t\t\tnumber /= factor;\n\t\t} \n\
    \t\telse \n\t\t{\n\t\t\ti++;\n\t\t}\n\t}\n\treturn result;\n}", "{\n     auto\
    \ result = [];\n     long[] primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109,\
    \ 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197,\
    \ 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283,\
    \ 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389,\
    \ 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487,\
    \ 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599,\
    \ 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691,\
    \ 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811,\
    \ 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919,\
    \ 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021,\
    \ 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103,\
    \ 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187,", "{ \n    long[]\
    \ res = []; \n    // Print the number of 2s that divide n \n    while (n % 2 ==\
    \ 0) \n    { \n        res ~= 2; \n        n = n / 2; \n    } \n  \n    // n must\
    \ be odd at this point.  So we can skip  \n    // one element (Note i = i +2)\
    \ \n    for (long i = 3; i <= n; i = i + 2) \n    { \n        // While i divides\
    \ n, print i and divide n \n        while (n % i == 0) \n        { \n        \
    \    res ~= i; \n            n = n / i; \n        } \n    } \n  \n    // This\
    \ condition is to handle the case when n  \n    // is a prime number greater than\
    \ 2 \n    if (n > 2) \n        res ~= n; \n  \n    return res; \n} ", "{\n   \
    \ /*\n    Algorithm:\n    1. Find the smallest prime factor of N with help of\
    \ sieve of Eratosthenes,\n       other small primes could be found by trial division.\n\
    \    2. Repeat step 1 while the factor divides N.\n    3. Replace N with N / factor.\n\
    \    4. Repeat steps 1-3 until N becomes 1.\n    */\n    // Algorithm taken from\
    \ http://www.geeksforgeeks.org/print-all-prime-factors-of-a-given-number/\n  \
    \  // The primes less than or equal to N can be found in O(NloglogN) operations.\n\
    \    // The total complexity of the algorithm is O(NloglogN).\n    long[] fact\
    \ = [];\n    while (n % 2 == 0) \n    {\n        fact ~= 2;\n        n = n / 2;\n\
    \    }\n    long i = 3;\n    while (i * i <= n) \n    {\n        while (n % i\
    \ == 0) \n        {\n            fact ~= i;\n            n = n / i;\n        }\n\
    \        i = i + 2;\n    }\n    if (n > 2) \n    {\n        fact ~= n;\n    }\n\
    \    return fact;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
