name: HumanEval_162_string_to_md5
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    Given a string 'text',\
  \ return its md5 hash equivalent string.\n    If 'text' is an empty string, return\
  \ None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n\
  \    \n*/\nNullable!(string) string_to_md5(string text) \n"
tests: "unittest\n{\n    alias candidate = string_to_md5;\n\n{\n        auto result\
  \ = candidate(\"Hello world\");\n        assert(!result.isNull && result.get ==\
  \ \"3e25960a79dbc69b674cd4ec67a72c62\");\n}\n\n{\n        auto result = candidate(\"\
  \");\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate(\"\
  A B C\");\n        assert(!result.isNull && result.get == \"0ef78513b0cb8cef12743f5aeb35f888\"\
  );\n}\n\n{\n        auto result = candidate(\"password\");\n        assert(!result.isNull\
  \ && result.get == \"5f4dcc3b5aa765d61d8327deb882cf99\");\n}\n\n}\nvoid main(){}"
completions: ["{\n    \n    if (text.length == 0)\n        return Nullable!(string)();\n\
    \    \n    size_t[4] initial = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476];\n\
    \    size_t[4] working = initial;\n    size_t[2] buffer = [0, 0];\n    immutable\
    \ char[] s = cast(immutable char[]) text;\n    immutable size_t len = text.length;\n\
    \    const size_t blockSize = 64;\n    const size_t shift = [7, 12, 17, 22, 5,\
    \ 9, 14, 20, 4, 11, 16, 23, 6, 10, 15, 21];\n    const size_t[16] sinTable = [0xd76aa478,\
    \ 0xe8c7b756, 0x242070db, 0xc1bdceee,\n        0xf57c0faf, 0x4787c62a, 0xa8304613,\
    \ 0xfd469501,\n        0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,\n     \
    \   0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821];\n    const size_t[64] k =\
    \ [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n        1, 6, 11, 0,\
    \ 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12,\n        5, 8, 11, 14, 1, 4, 7, 10,\
    \ 13, 0, 3, 6, 9, 12, 15, 2,\n        0, 7, 14, 5, 12, 3, 10, 1, 8, 15, 6, 13,\
    \ 4, 11, 2, 9];\n    \n    for (size_t i = 0; i < len / blockSize; i++)\n    {\n\
    \        size_t[16] w = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0", "{\n\tif (text.length\
    \ == 0)\n\t\treturn null;\n\t\n\tubyte[] hash = text.md5;\n\treturn typeof(null).init.stringof(hash);\n\
    }", "{\n    import std.digest.md;\n    Nullable!(string) ret = null;\n    if (text.length)\
    \ \n    {\n        auto hasher = MD5.create;\n        hasher.put(text);\n    \
    \    ret = hasher.finishString;\n    }\n    return ret;\n}", "{ \n\tif (text.length)\
    \ { \n\t\timport std.md5 : digest;\n\t\treturn digest(text);\n\t}\n\telse {\n\t\
    \treturn null;\n\t}\n}", "{\n    if (text.length < 1) \n    {\n        return\
    \ null;\n    }", "{\n    return text.md5;\n}\n/*", "{\n    if(text.length > 0)\
    \ \n    {\n        import core.stdc.string : strlen;\n        import openssl.md5\
    \ : MD5_DIGEST_LENGTH, MD5, MD5_Init, MD5_Update, MD5_Final;\n        \n     \
    \   // Initialize variables\n        auto buf = new ubyte[MD5_DIGEST_LENGTH];\n\
    \        auto ctx = new MD5;\n        MD5_Init(ctx);\n        MD5_Update(ctx,\
    \ text.ptr, strlen(text.ptr));\n        MD5_Final(buf, ctx);\n        \n     \
    \   // Convert to hex string\n        return to!string(buf);\n    }\n    return\
    \ null;\n}", "{\n    import std.algorithm;\n    import std.bigint;\n    import\
    \ std.conv;\n    import std.digest.md;\n    import std.digest.sha;\n    import\
    \ std.range;\n    import std.typecons;\n    import std.math;\n    Nullable!(string)\
    \ result = Nullable!(string).init;\n    if (text.length > 0)\n    {\n        result\
    \ = md.md5(text).to!string;\n    }\n    return result;\n}\n/*", "{\n    if (text.length\
    \ == 0) return null;\n    return text.md5;\n}", "{\n    if (text.length == 0)\n\
    \        return Nullable!(string)();\n    import std.digest.md;\n    import std.conv;\n\
    \    return text.md5.to!string;\n}", "{\n    string result = null;\n    import\
    \ std.digest;\n    import std.digest.md;\n    auto digest = MD5(text);\n    result\
    \ = digest.toHexString;\n    return result;\n}\n/*", "{\n    Nullable!(string)\
    \ rv;\n    if (text.length == 0) \n    {\n        return Nullable!(string).init;\n\
    \    }\n    import std.digest.md;\n    import std.digest.md5;\n    auto hash =\
    \ MD5(text);\n    import std.conv;\n    rv = to!(string)(hash);\n    return rv;\n\
    }\n/*", "{\n    import std.digest.md;\n    if (text.length == 0) return null;\n\
    \    // For dmd and ldc, use\n    // auto result = md5(text);\n    // for gdc,\
    \ use\n    auto result = digest(MD_5, text);\n    return result.toString();\n\
    }\n/*", "{\n    auto md5_provider = std.crypto.md5();\n    md5_provider.put(text);\n\
    \    return to!string(md5_provider.finish());\n}", "{\n    auto len = text.length;\n\
    \    auto buf = text.ptr;\n    if (len == 0)\n        return Nullable!(string)();\n\
    \    \n    import std.digest.md;\n    auto md5 = MD5(buf, len);\n    md5.finish();\n\
    \    return Nullable!(string)(md5.hexdigest());\n}", "{\n    if (text.length ==\
    \ 0) return None;\n    import std.digest.md;\n    auto res = md5(text);\n    return\
    \ res.toHexString();\n}", "{\n    /* \n        based on Dr John D. Cook's code\
    \ \n        http://www.johndcook.com/blog/2009/10/20/md5-in-d/ \n    */\n    import\
    \ core.bitop; // for rotation operations\n   \n    if (text.length == 0) \n  \
    \      return Nullable!(string).init; // None\n   \n    /*\n        constants\
    \ for md5\n    */\n    enum uint32[64] T = [\n        0xd76aa478, 0xe8c7b756,\
    \ 0x242070db, 0xc1bdceee,\n        0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,\n\
    \        0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,\n        0x6b901122,\
    \ 0xfd987193, 0xa679438e, 0x49b40821,\n        0xf61e2562, 0xc040b340, 0x265e5a51,\
    \ 0xe9b6c7aa,\n        0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,\n     \
    \   0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,\n        0xa9e3e905, 0xfcefa3f8,\
    \ 0x676f02d9, 0x8d2a4c8a,\n        0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,\n\
    \        0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,\n        0x289b7ec6,\
    \ 0xeaa127fa, 0xd4ef3085, 0x04881d05,\n        0xd9d4d039, 0xe6db99e5, 0x1fa27cf8,\
    \ 0xc4ac5665,\n        0xf4292244, 0x432aff97,", "{\n    if(text.length == 0)\
    \ \n    {\n        return null;\n    }\n    import std.digest.md;\n    ubyte[]\
    \ hash = MD5(text);\n    string hash_string = hash.to!string;\n    return hash_string;\n\
    }", "{\n    if (text.length == 0)\n        return Nullable!(string)();\n    \n\
    \    import std.digest.md;\n    return Nullable!(string)(md5(text).toString);\n\
    }", "{\n    if (text.length == 0) return null;\n    auto md5 = MD5();\n    md5.put(text.array);\n\
    \    return md5.get();\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
