name: HumanEval_61_correct_bracketing
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n brackets is a string of \"(\"\
  \ and \")\".\n    return True if every opening bracket has a corresponding closing\
  \ bracket.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"\
  ()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\"\
  )(()\")\n    False\n    \n*/\nbool correct_bracketing(string brackets) \n"
tests: "unittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
  ()\") == true);\n    assert(candidate(\"(()())\") == true);\n    assert(candidate(\"\
  ()()(()())()\") == true);\n    assert(candidate(\"()()((()()())())(()()(()))\")\
  \ == true);\n    assert(candidate(\"((()())))\") == false);\n    assert(candidate(\"\
  )(()\") == false);\n    assert(candidate(\"(\") == false);\n    assert(candidate(\"\
  ((((\") == false);\n    assert(candidate(\")\") == false);\n    assert(candidate(\"\
  (()\") == false);\n    assert(candidate(\"()()(()())())(()\") == false);\n    assert(candidate(\"\
  ()()(()())()))()\") == false);\n}\nvoid main(){}"
completions: ["{\n    int len = brackets.length;\n    if (len == 0) return true;\n\
    \    // in case that some brackets are not paired, then there should be at least\
    \ one open bracket left\n    if (brackets[len-1] == ')') return false;\n    while\
    \ (brackets.length > 0) {\n        size_t pos = brackets.find(\")\");\n      \
    \  if (pos == string.npos) return false;\n        brackets = brackets[0..pos-1];\n\
    \        if (brackets.length == 0) return false;\n        pos = brackets.rfind(\"\
    (\");\n        if (pos == string.npos) return false;\n        brackets = brackets[pos+1..brackets.length];\n\
    \    }\n    return true;\n}", "{\n    bool r = true;\n    uint cnt = 0;\n    foreach(c;\
    \ brackets)\n    {\n        if(c == '(')\n            cnt++;\n        else if(c\
    \ == ')')\n            cnt--;\n        if(cnt < 0)\n        {\n            r =\
    \ false;\n            break;\n        }\n    }\n    return r && cnt == 0;\n}",
  "    {\n    static struct parenthesis_match\n        {\n        char open,close;\n\
    \        }\n    matches[] = \n        {\n        {'(',')'},\n        {'[',']'},\n\
    \        {'{','}'},\n        };\n    long num_matches = sizeof(matches)/sizeof(matches[0]);\n\
    \    int result = 0;\n    foreach(char c;brackets)\n        {\n        int match_num;\n\
    \        for(match_num = 0;match_num < num_matches;match_num++)\n            {\n\
    \            if(c == matches[match_num].open)\n                result++;\n   \
    \         else if(c == matches[match_num].close)\n                result--;\n\
    \            }\n        }\n    return result == 0;\n    }", "{\n    int n = 0;\n\
    \    for (char c : brackets)\n    {\n        n += (c == '(' ? 1 : -1);\n     \
    \   if (n < 0) \n            return false;\n    }\n    return n == 0;\n}", "{\n\
    \    ulong balance = 0;", "{\n    auto stack = new Stack!(int)();\n    for (int\
    \ i = 0; i < brackets.length; i++) \n    {\n        switch (brackets[i]) \n  \
    \      {\n            case '(':\n                stack.push(0);\n            \
    \    break;\n            case ')':\n                if (stack.empty)\n       \
    \             return false;\n                stack.pop();\n                break;\n\
    \        }\n    }\n    return stack.empty;\n}\n/*\n    You are given a string.\n\
    \    You need to remove at most one pair of adjacent characters.\n    The goal\
    \ is to remove as many pairs as possible.", "{\n    long depth = 0;\n    foreach(bracket;\
    \ brackets) {\n        if (bracket == '(') {\n            depth++;\n        }\
    \ else if (bracket == ')') {\n            depth--;\n        }\n        if (depth\
    \ < 0) {\n            return false;\n        }\n    }\n    return depth == 0;\n\
    }\n/*\n combine_dicts is a dictionary of dictionarys.\n    return a dictionary\
    \ that combines all the key/value pairs from the sub-dictionaries.", "    in\n\
    \    {\n        assert(all!(e => e == \"(\" || e == \")\", brackets));\n    }\n\
    \    body\n    {\n        size_t depth = 0;\n        foreach(ch; brackets)\n \
    \       {\n            if(ch == \"(\")\n                depth += 1;\n        \
    \    else if(ch == \")\")\n                depth -= 1;\n            else\n   \
    \             assert(false);\n            \n            if(depth < 0)\n      \
    \          return false;\n        }\n        return depth == 0;\n    }", "{\n\
    \    int p = 0;\n    int i = 0;\n    foreach(ch;brackets)\n    {\n        if(ch\
    \ == '(')\n        {\n            p++;\n        }\n        else if(ch == ')')\n\
    \        {\n            p--;\n        }\n        i++;\n        if(p < 0)\n   \
    \     {\n            return false;\n        }\n    }\n    if(p == 0)\n    {\n\
    \        return true;\n    }\n    else\n    {\n        return false;\n    }\n\
    }\n/*\n * return true if str is a palindrome, a string that reads the same\n *\
    \ forward and backward.\n *\n * >>> is_palindrome(\"abba\")\n * True\n * >>> is_palindrome(\"\
    abcba\")\n * True\n * >>> is_palindrome(\"\")\n * True\n * >>> is_palindrome(\"\
    abcd\")\n * False\n */", "{\n    bool is_correct = true;\n    int bracket_count\
    \ = 0;\n    foreach(ch; brackets)\n    {\n\tbracket_count += ch == '(' ? 1 : -1;\n\
    \tif(bracket_count < 0)\n\t{\n\t    is_correct = false;\n\t    break;\n\t}\n \
    \   }\n    return is_correct && (bracket_count == 0);\n}", "{\n    if (empty(brackets))\
    \ return true;\n    int n = length(brackets);\n    if (brackets[0] == ')') return\
    \ false;\n    // brackets[0] == '('\n    if (n % 2 == 1) return false;", "{\n\
    \    int bracket_count = 0;\n    int i;\n    foreach(ch; brackets)\n    {\n  \
    \      if(ch == '(')\n        {\n            bracket_count++;\n        }\n   \
    \     else if(ch == ')')\n        {\n            bracket_count--;\n        }\n\
    \        else\n        {\n            assert(false);\n        }\n        if(bracket_count\
    \ < 0)\n        {\n            return false;\n        }\n    }\n    return (bracket_count\
    \ == 0);\n}\n/*\n    returns the maximum of list1, list2 and list3\n    >>> max_list([1,2,3,4,5])\n\
    \    5\n    >>> max_list([-1,1,10])\n    10\n    >>> max_list([1])\n    1\n*/",
  "{\n  //std.file.write(\"debug.txt\", brackets);\n  int count = 0;\n  foreach(i,\
    \ ch; brackets) {\n    if (ch == '(') {\n      count++;\n    }\n    else if (ch\
    \ == ')') {\n      count--;\n    }\n  }\n  if (count == 0) {\n    return true;\n\
    \  }\n  else {\n    return false;\n  }\n}", "{\n    //variables\n    int bracket_counter\
    \ = 0;\n    //iterate through every character in brackets\n    foreach(char c;\
    \ brackets)\n    {\n        //if current character is ( increase counter\n   \
    \     if(c == '(')\n        {\n            bracket_counter += 1;\n        }\n\
    \        //if current character is ) decrease counter\n        else if(c == ')')\n\
    \        {\n            bracket_counter -= 1;\n        }\n        //if counter\
    \ goes below 0 return false\n        if(bracket_counter < 0)\n        {\n    \
    \        return false;\n        }\n    }\n    //if counter is 0 return true otherwise\
    \ return false\n    return bracket_counter == 0;\n}\n/*\n   returns length of\
    \ longest prefix of s that has correct bracketing.\n   returns length of longest\
    \ suffix of s that has correct bracketing.\n*/", "{\n    uint counter = 0;\n \
    \   for (int i = 0; i < brackets.length; i++)\n    {\n        if (brackets[i]\
    \ == '(')\n        {\n            counter++;\n        }\n        else if (brackets[i]\
    \ == ')')\n        {\n            counter--;\n        }\n    }\n    return counter\
    \ == 0;\n}\n/*\n short_circuit_eval is a string containing boolean operators (&,\
    \ |, !) and\n    boolean values (true, false).\n    return True if the expression\
    \ evaluates to true.", "{\n  return count(brackets, \"(\") == count(brackets,\
    \ \")\");\n}\n/*\n    brackets is a string of \"(\" and \")\".\n    return the\
    \ longest substring of brackets starting at the beginning of brackets\n    that\
    \ has the property that any prefix has at least as many \"(\" as \")\".", "{\n\
    \  int count = 0;\n  foreach(c;brackets)\n  {\n    count += (c == '(' ? 1 : -1);\n\
    \    if(count < 0)\n      return false;\n  }\n  return count == 0;\n}\n/*\n  \
    \  return True if every opening bracket has a corresponding closing bracket.",
  "{\n    int count = 0;\n    foreach(c; brackets) \n    {\n        count += c ==\
    \ '(' ? 1 : -1;\n        if (count < 0) \n        {\n            return false;\n\
    \        }\n    }\n    return count == 0;\n}", "{\n    int bracket_counter = 0;\n\
    \    foreach(char c; brackets) \n    {\n        if (c == '(') \n        {\n  \
    \          bracket_counter += 1;\n        } \n        else if (c == ')') \n  \
    \      {\n            bracket_counter -= 1;\n        }\n        if (bracket_counter\
    \ < 0) \n        {\n            return false;\n        }\n    }\n    return bracket_counter\
    \ == 0;\n}", "{\n\tint temp = 0;\n\tforeach(c; brackets)\n\t{\n\t\tif(c == '(')\n\
    \t\t\ttemp++;\n\t\telse if(c == ')')\n\t\t\ttemp--;\n\t\tif(temp < 0)\n\t\t\t\
    return false;\n\t}\n\treturn temp == 0;\n}\n/*\n  Returns true if a string is\
    \ a palindrome (a string which reads the same\n  forwards and backwards)."]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
