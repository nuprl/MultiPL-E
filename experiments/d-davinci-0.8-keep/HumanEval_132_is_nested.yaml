name: HumanEval_132_is_nested
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
  \ takes a string as input which contains only square brackets.\n    The function\
  \ should return True if and only if there is a valid subsequence of brackets \n\
  \    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]')\
  \ \u279E True\n    is_nested('[]]]]]]][[[[[]') \u279E False\n    is_nested('[][]')\
  \ \u279E False\n    is_nested('[]') \u279E False\n    is_nested('[[][]]') \u279E\
  \ True\n    is_nested('[[]][[') \u279E True\n    \n*/\nbool is_nested(string string)\
  \ \n"
tests: "unittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
  ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
  [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
  [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
  [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
  []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
  [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
  [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}"
completions: ["{\n    // Create a deque to store\n    // brackets in.\n    Deque!char\
    \ bracket;\n    // Create an int to store\n    // the number of brackets.\n  \
    \  int bracket_count = 0;\n    // Create an int to store\n    // the number of\
    \ nested brackets.\n    int nested_bracket_count = 0;\n    // Iterate over each\
    \ char\n    // in the string.\n    foreach(char c; string)\n    {\n        //\
    \ Increase bracket_count\n        // every time we encounter a bracket.\n    \
    \    if(c == '[' || c == ']')\n        {\n            // If we have an open bracket,\n\
    \            // push to the front of the deque.\n            if(c == '[')\n  \
    \          {\n                bracket.pushFront(c);\n            }\n         \
    \   // If we have a closed bracket,\n            // push to the back of the deque.\n\
    \            else\n            {\n                bracket.pushBack(c);\n     \
    \       }\n            bracket_count++;\n        }\n    }\n    // If the bracket_count\
    \ is odd,\n    // it will never be possible\n    // to have nested brackets.\n\
    \    if(bracket_count % 2 != 0)\n    {\n        return false;\n    }\n    // Iterate\
    \ over each char\n    // in the deque.\n    foreach(char c; bracket)\n    {\n\
    \        // Check if the current char\n        // is a closed bracket.\n     \
    \   if(c == ']')\n        {\n            // If it is, loop until\n           \
    \ // we find an open bracket.\n            while(bracket.front != '[')\n     \
    \       {\n                // If we reach the back\n                // of the\
    \ deque, there is\n                // no nested bracket.\n                if(bracket.back\
    \ == '[')\n                {\n                    return false;\n            \
    \    }\n                // Pop from the front.\n                bracket.popFront();\n\
    \            }\n            // Pop the open bracket.\n            bracket.popFront();\n\
    \            // Increase nested_bracket_count.\n            nested_bracket_count++;\n\
    \        }\n    }\n    // If the nested_bracket_count\n    // is less than 2,\
    \ there is no\n    // nested bracket.", "{\n    auto stack = typeof(return)();\n\
    \    for(char c : string)\n    {\n        if(c == '[')\n            stack.pushBack(c);\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \       return false;\n            stack.popBack();\n        }\n    }\n    return\
    \ stack.empty;\n}", "{\n    int i = 0;\n    while(i < string.length)\n    {\n\
    \        if(string[i] == '[')\n        {\n            if(string[i+1] == ']' ||\
    \ string[i+1] == '[')\n            {\n                return true;\n         \
    \   }\n        }\n        i++;\n    }\n    return false;\n}", "{\n    // if zero\
    \ brackets, can't nest\n    if (string.empty) \n        return false;\n    //\
    \ if all pairs, can't nest\n    if (string.filter!(a => a == '[').empty)\n   \
    \     return false;\n    // if length is odd, can't nest\n    if (string.length\
    \ % 2 == 1)\n        return false;\n    // if any nested, return true\n    return\
    \ string.filter!(a => a == '[').zip(string.filter!(a => a == ']')).map!(tuple\
    \ => tuple[0] == '[' && tuple[1] == ']').any;\n}\n/*", "{\n    // first solution\n\
    \    /*\n    char[] input = to!char[](string);\n    // remove all characters exept\
    \ [ and ]\n    input = input.filter!(c => c == '[' || c == ']');\n    // check\
    \ if length is even\n    if (input.length % 2 == 1)\n        return false;\n \
    \   // check for invalid sequences\n    if (input.indexOf(\"][\") != -1 || input.indexOf(\"\
    ][\") != -1)\n        return false;\n    // split the brackets\n    char[][] splitted\
    \ = input.split(\"\\\\[\\\\]\");\n    // remove empty strings\n    splitted =\
    \ splitted.filter!(c => c.length != 0);\n    // there should be only one string\
    \ left\n    return splitted.length == 1;\n    */\n    // better solution\n   \
    \ char[] input = to!char[](string);\n    // remove all characters exept [ and\
    \ ]\n    input = input.filter!(c => c == '[' || c == ']');\n    // check if length\
    \ is even\n    if (input.length % 2 == 1)\n        return false;\n    // check\
    \ for invalid sequences\n    if (input.indexOf(\"][\") != -1 || input.indexOf(\"\
    ][\") != -1)\n        return false;\n    // check for invalid strings\n    for\
    \ (int i = 0; i < input.length; i += 2)\n    {\n        if (input[i] != '[' ||\
    \ input[i + 1] != ']')\n            return false;\n    }\n    return true;\n}\n\
    /*\n    Write a function that takes a string of braces, and determines if the\
    \ order of the braces is valid.\n    It should return true if the string is valid,\
    \ and false if it's invalid.", "{\n\tif(string.length == 0)\n\t\treturn false;\n\
    \t\t\n\tuint[] stack;\n\tfor(uint i = 0; i < string.length; i++)\n\t{\n\t\tif(string[i]\
    \ == '[')\n\t\t\tstack ~= 0;\n\t\telse if(string[i] == ']')\n\t\t{\n\t\t\tif(stack.length\
    \ == 0)\n\t\t\t\treturn false;\n\t\t\telse\n\t\t\t\tstack.popBack();\n\t\t}\n\t\
    }\n\treturn stack.length == 0;\n}", "{\n    int openBrackets = 0;\n    int closedBrackets\
    \ = 0;\n    foreach(char c; string)\n    {\n        if(c == '[')\n        {\n\
    \            ++openBrackets;\n        }\n        else if(c == ']')\n        {\n\
    \            ++closedBrackets;\n        }\n        if(closedBrackets > openBrackets)\n\
    \        {\n            return false;\n        }\n    }\n    return openBrackets\
    \ != closedBrackets ? false : true;\n}", "{\n    auto bracket_count = 0;\n   \
    \ foreach(c; string)\n    {\n        if(c == '[') bracket_count++;\n        else\
    \ if(c == ']') bracket_count--;\n        if(bracket_count < 0) break;\n    }\n\
    \    return bracket_count == 0;\n}", "{\n    bool result = false;\n    bool inside\
    \ = false;\n    uint index = 0;\n    while(!result && index < string.length)\n\
    \    {\n        if(string[index] == '[')\n        {\n            index++;\n  \
    \          inside = true;\n            while(inside && index < string.length)\n\
    \            {\n                if(string[index] == ']')\n                {\n\
    \                    result = true;\n                    inside = false;\n   \
    \             }\n                else if(string[index] == '[')\n             \
    \   {\n                    result = false;\n                    inside = false;\n\
    \                }\n                index++;\n            }\n        }\n     \
    \   else index++;\n    }\n    return result;\n}", "{\n    int counter = 0;\n \
    \   int nesting = 0;\n    foreach(char c; string)\n    {\n        if(c == '[')\n\
    \        {\n            ++counter;\n            ++nesting;\n        }\n      \
    \  else if(c == ']')\n        {\n            --counter;\n            --nesting;\n\
    \        }\n        if(nesting < 0)\n        {\n            return false;\n  \
    \      }\n    }\n    return counter == 0 && nesting >= 0;\n}\n/*\n    function\
    \ is_nested(string) {\n    let nest = 0;\n    for (let i = 0; i < string.length;\
    \ i++) {\n      if (string[i] === '[') {\n        nest++;\n      } else if (string[i]\
    \ === ']') {\n        nest--;\n      }\n      if (nest < 0) {\n        return\
    \ false;\n      }\n    }\n    return nest === 0;\n  }\n  function is_nested(string)\
    \ {\n    var count = 0;\n    for (var i = 0; i < string.length; i++) {\n     \
    \ if (string[i] == '[') count++;\n      if (string[i] == ']') count--;\n     \
    \ if (count < 0) return false;\n    }\n    return count == 0;\n  }\n  function\
    \ is_nested(string) {\n    return !string.split(\"\").reduce((x,y)=>{\n      if(y===\"\
    [\"){\n        x++\n      }else if(y===\"]\"){\n        x--\n      }\n      if(x<0){\n\
    \        return false\n      }\n      return x\n    },0)\n  }\n*/", "{\n    bool\
    \ rval = false;\n    bool lval = false;\n    bool val = false;\n    int cnt =\
    \ 0;\n    foreach(char c; string)\n    {\n        if(c == '[')\n        {\n  \
    \          cnt++;\n            if(lval)\n            {\n                val =\
    \ true;\n            }\n            else\n            {\n                lval\
    \ = true;\n            }\n        }\n        else if(c == ']')\n        {\n  \
    \          cnt--;\n            if(rval)\n            {\n                val =\
    \ true;\n            }\n            else\n            {\n                rval\
    \ = true;\n            }\n        }\n    }\n    if(cnt == 0 && val)\n    {\n \
    \       return true;\n    }\n    return false;\n}", "{\n    Tuple!(bool,bool)\
    \ counts = tuple(false,false);\n    int i = 0;\n    for(i=0;i<string.length;i++)\n\
    \    {\n        if(string[i] == '[')\n        {\n            counts[0] = true;\n\
    \        }\n        else if(string[i] == ']')\n        {\n            counts[1]\
    \ = true;\n        }\n    }\n    if(counts[0] && counts[1])\n    {\n        return\
    \ true;\n    }\n    else\n    {\n        return false;\n    }\n}", "{\n    struct\
    \ Brackets\n    {\n        int opened;\n        int closed;\n    };\n    Brackets\
    \ bs = {};\n    bool is_nested = false;\n    foreach(c; string)\n    {\n     \
    \   if(c == '[')\n        {\n            bs.opened++;\n        }\n        else\
    \ if(c == ']')\n        {\n            bs.closed++;\n        }\n    }\n    is_nested\
    \ = bs.opened > bs.closed;\n    return is_nested;\n}", "{\n    int bracket_count\
    \ = 0;\n    int last_char = 0;\n    for(int i = 0; i < string.length; i++) {\n\
    \        if(string[i] == '[') {\n            bracket_count++;\n        }\n   \
    \     else if(string[i] == ']') {\n            bracket_count--;\n        }\n \
    \       if(bracket_count == 0) last_char = i;\n    }\n    return bracket_count\
    \ == 0 && last_char != 0;\n}", "{\n    bool res = false;\n    int left = 0;\n\
    \    int right = 0;\n    for(int i = 0; i < string.length; i++)\n    {\n     \
    \   if(string[i] == '[') left++;\n        if(string[i] == ']') right++;\n    \
    \    if(left < right) return false;\n    }\n    if(left == right) return true;\n\
    \    return res;\n}", "{\n    // create stack\n    Stack!int stack = new Stack!int;\n\
    \    // put value's in the stack\n    foreach(char; string)\n    {\n        stack.push(char);\n\
    \    }\n    // create the closing bracket\n    int close;\n    // if the stack\
    \ is not empty\n    if(!stack.empty)\n    {\n        // Pop last value from the\
    \ stack\n        close = stack.pop;\n    }\n    // check if the input string is\
    \ valid\n    bool isValid = false;\n    // for every character in the string\n\
    \    foreach(i; 0 .. string.length)\n    {\n        // if the character is [\n\
    \        if(string[i] == '[')\n        {\n            // check if a closing bracket\
    \ exists\n            if(close == ']')\n            {\n                // if so\
    \ set isValid to true\n                isValid = true;\n            }\n      \
    \  }\n    }\n    // return isValid\n    return isValid;\n}\n// Tests\nunittest\
    \ \n{\n    assert(is_nested(\"[[]]\"));\n    assert(!is_nested(\"[]]]]]]][[[[[]\"\
    ));\n    assert(!is_nested(\"[][]\"));\n    assert(!is_nested(\"[]\"));\n    assert(is_nested(\"\
    [[][]]\"));\n    assert(is_nested(\"[[]][[\"));\n}", "{\n    int prev_len = 0;\n\
    \    for(int i = 0; i < string.length; i++) {\n        string.replace(\"[]\",\
    \ \"\");\n        if(prev_len == string.length) {\n            return false;\n\
    \        }\n        prev_len = string.length;\n    }\n    return true;\n}", "{\n\
    \    /*\n        This function should return true if and only if there is a valid\
    \ subsequence of brackets \n        where at least one bracket in the subsequence\
    \ is nested.\n    */\n    // Because we're only given strings with square brackets\
    \ and not actual square brackets, we're going to have to find a way to change\
    \ them.\n    // Lets take care of the square brackets that are nested first.\n\
    \    // Examples of this would be:\n    // '[[]]'\n    // '[][]'\n    // '[[][]]'\n\
    \    // One way to do this would be to just loop through the string and remove\
    \ all of the square brackets until there are no more.\n    // If we have a string\
    \ that is nested, then we will have an empty string.\n    // If we have a string\
    \ that is not nested, then we will have a string with brackets left.\n    // This\
    \ is how we will determine if a bracket is nested.\n    // So lets make a while\
    \ loop that will check the lenght of the string.\n    // If the length of the\
    \ string is 0, then we will return true, because it is a nested string.\n    //\
    \ If the length of the string is not 0, then we will return false, because it\
    \ is not a nested string.\n    // Now we need to determine if the string is nested.\n\
    \    // If we have a string like '[][]', then those brackets aren't nested.\n\
    \    // We could loop through the string, and if we see that the bracket is a\
    \ ']', then we can try to find the index of the closest '[' before that index.\n\
    \    // If we are able to find an index that is less than the current index, then\
    \ we can replace that with a '|' sign.\n    // '|' is just to make the string\
    \ look nice, so that we know that that bracket was removed.\n    // After we are\
    \ done looping through the string, we will make a while loop that will check if\
    \ there are any brackets in the string.\n    // If there is, then we will replace\
    \ it with '|' and if there isn't, then we will return false.\n    // Remember,\
    \ if we are able to get an empty string, then we will return true.\n    // Lets\
    \ start with the for loop.\n    for(int i = 0; i < string.length; i", "{\n   \
    \ int count = 0;\n    for(char a : string)\n    {\n        if(a == '[') count++;\n\
    \        else if(a == ']') count--;\n        if(count == -1) return false;\n \
    \   }\n    return count == 0;\n}", "{\n    bool result = false;\n    for(int i\
    \ = 0; i < string.length; i++)\n    {\n        if(string[i] == '[')\n        {\n\
    \            for(int j = i + 1; j < string.length; j++)\n            {\n     \
    \           if(string[j] == ']')\n                {\n                    result\
    \ = true;\n                    break;\n                }\n            }\n    \
    \    }\n    }\n    return result;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
