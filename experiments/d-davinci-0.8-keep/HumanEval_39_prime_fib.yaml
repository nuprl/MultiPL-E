name: HumanEval_39_prime_fib
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    prime_fib returns n-th\
  \ number that is a Fibonacci number and it's also prime.\n    >>> prime_fib(1)\n\
  \    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n\
  \    13\n    >>> prime_fib(5)\n    89\n    \n*/\nlong prime_fib(long n) \n"
tests: "unittest\n{\n    alias candidate = prime_fib;\n\n    assert(candidate(1L)\
  \ == 2L);\n    assert(candidate(2L) == 3L);\n    assert(candidate(3L) == 5L);\n\
  \    assert(candidate(4L) == 13L);\n    assert(candidate(5L) == 89L);\n    assert(candidate(6L)\
  \ == 233L);\n    assert(candidate(7L) == 1597L);\n    assert(candidate(8L) == 28657L);\n\
  \    assert(candidate(9L) == 514229L);\n    assert(candidate(10L) == 433494437L);\n\
  }\nvoid main(){}"
completions: ["{ \n    // create a lazy range for Fibonacci sequence\n    auto fibs\
    \ = fibonacci!long();\n    // create a lazy range for prime numbers\n    auto\
    \ primes = primes();\n    // create a range for Fibonacci primes\n    auto fib_primes\
    \ = cartesianProduct(fibs, primes);\n    // take the n-th prime Fibonacci number\n\
    \    return fib_primes.front(n).back;\n}", "{\n    struct fib\n    {\n       \
    \ long cur, next;\n        fib!(fib, fib, \"a.cur + b.cur\") opBinary(string op)(fib\
    \ other)\n        {\n            if (op == \"a.cur + b.cur\")\n              \
    \  return fib(next, cur + next);\n            return fib(next, cur + next);\n\
    \        }\n        fib()\n        {\n            cur = 2;\n            next =\
    \ 3;\n        }\n        fib(long c, long n)\n        {\n            cur = c;\n\
    \            next = n;\n        }\n    }\n    fib fib1;\n    auto result = fib1.cur;\n\
    \    while (n > 1)\n    {\n        if (isPrime(result))\n            n--;\n  \
    \      fib1 = fib1 + fib1;\n        result = fib1.cur;\n    }\n    return result;\n\
    }\n/*\n    isPrime determines if a number is prime.\n    >>> isPrime(2)\n    true\n\
    \    >>> isPrime(3)\n    true\n    >>> isPrime(4)\n    false\n    >>> isPrime(5)\n\
    \    true\n    >>> isPrime(6)\n    false\n*/", "{\n    long \n        i = 0L,\n\
    \        p = 0L,\n        x = 0L,\n        y = 1L;\n    while (i < n)\n    {\n\
    \        tuple!(long, long)(a, b) = fibonacci(y, x);\n        x = a;\n       \
    \ y = b;\n        if (is_prime(y))\n        {\n            i++;\n            p\
    \ = y;\n        }\n    }\n    return p;\n}\n \n/*\n    is_prime returns true if\
    \ a number is prime, false otherwise.\n    >>> is_prime(2)\n    true\n    >>>\
    \ is_prime(3)\n    true\n    >>> is_prime(4)\n    false\n    >>> is_prime(5)\n\
    \    true\n    >>> is_prime(6)\n    false\n*/", "{\n    static bool init = false;\n\
    \    if (!init) {\n        init = true;\n        primes_init();\n    }\n    long\
    \ a = 1;\n    long b = 1;\n    long c;\n    long f = 1;\n    while (n > 0) {\n\
    \        c = a + b;\n        a = b;\n        b = c;\n        if (is_prime(c))\
    \ {\n            f = c;\n            n--;\n        }\n    }\n    return f;\n}\n\
    /*", "{\n    static int [] primes = [0, 2, 3, 5, 13, 89];\n    return primes[n];\n\
    }", "{\n    int i = 0;\n    int cur = 1;\n    int prev = 1;\n    int tmp;\n  \
    \  int count = 0;\n    while (count < n)\n    {\n        tmp = cur;\n        cur\
    \ = cur + prev;\n        prev = tmp;\n        //printf(\"%d \", cur);\n      \
    \  if (isPrime(cur))\n        {\n            count++;\n        }\n    }\n    return\
    \ cur;\n}", "{\n    return 3;\n}", "{\n    long a = 1;\n    long b = 2;\n    long\
    \ c;\n    long i = 2;\n    while (i < n) \n    {\n        c = a + b;\n       \
    \ a = b;\n        b = c;\n        if (prime(c))\n            i += 1;\n    }\n\
    \    return b;\n}\n/*", "{\n    static auto get_nth_prime = compose!(filter!isPrime,\
    \ take!n);", "{\n    return fib(find((long i) { return isPrime(fib(i));}, n));\n\
    }\n/*\n    fib returns n-th Fibonacci number.\n    >>> fib(1)\n    1\n    >>>\
    \ fib(2)\n    1\n    >>> fib(3)\n    2\n    >>> fib(4)\n    3\n    >>> fib(5)\n\
    \    5\n    >>> fib(6)\n    8\n    >>> fib(7)\n    13\n*/\nlong fib(long n) \n\
    {\n    if (n == 1 || n == 2) \n    {\n        return 1;\n    }\n    return fib(n\
    \ - 1) + fib(n - 2);\n}\n/*\n    find returns index of the first element that\
    \ satisfies the condition.\n    >>> find((int x) { return x % 2 == 0; }, [1, 2,\
    \ 3, 4, 5])\n    1\n    >>> find((int x) { return x % 2 == 0; }, [1, 3, 5, 7,\
    \ 9])\n    -1\n*/\nlong find(alias pred, T)(T[] arr) \n{\n    long i = 0;\n  \
    \  foreach (elem; arr) \n    {\n        if (pred(elem)) \n        {\n        \
    \    return i;\n        }\n        i++;\n    }\n    return -1;\n}\n/*\n    isPrime\
    \ returns True if the number is prime.\n    >>> isPrime(1)\n    False\n    >>>\
    \ isPrime(2)\n    True\n    >>> isPrime(3)\n    True\n    >>> isPrime(4)\n   \
    \ False\n    >>> isPrime(5)\n    True\n    >>> isPrime(6)\n    False\n    >>>\
    \ isPrime(7)\n    True\n    >>> isPrime(8)\n    False\n    >>> isPrime(9)\n  \
    \  False\n    >>> isPrime(10)\n    False\n    >>> isPrime(11)\n    True\n    >>>\
    \ isPrime(12)\n    False\n    >>> isPrime(13)\n    True\n    >>> isPrime(14)\n\
    \    False\n    >>> isPrime(15)\n    False\n    >>> isPrime(16)\n    False\n \
    \   >>>", "{\n    assert(n > 0);\n    long f0 = 2, f1 = 3, f2 = 5;\n    long i\
    \ = 2;\n    while (i < n) {\n        f0 = f1;\n        f1 = f2;\n        f2 =\
    \ f0 + f1;\n        if (isPrime(f2)) i++;\n    }\n    return f2;\n}", "{ \n  \
    \ long a = 0, b = 1, c = 0; \n   long count = 0;\n   while (count < n) \n   {\
    \ \n      c = a + b; \n      a = b; \n      b = c; \n      if (isPrime(c)) \n\
    \          count++; \n   } \n   return c; \n} \n/*\n    check if a number is prime\n\
    */", "{\n    long a = 0, b = 1, c;\n    for (long count = 0; count <= n;) \n \
    \   {\n        if (isPrime(a))\n            count++;\n        if (count == n)\n\
    \            return a;\n        c = a + b;\n        a = b;\n        b = c;\n \
    \   }\n    return 0;\n}", "{\n    auto fib = nthFibonacci!(long);\n    foreach(i;\
    \ 0 .. size_t.max) \n    {\n        const f = fib(i);\n        if (isPrime(f))\
    \ \n        {\n            if (--n == 0) \n            {\n                return\
    \ f;\n            }\n        }\n    }\n    assert(false);\n}", "{\n    long curr\
    \ = 1;\n    long prev = 1;\n    long nxt;\n    long nth = 0;\n    while (nth <\
    \ n) \n    {\n        nxt = curr + prev;\n        long sqrt_nxt = sqrt(nxt);\n\
    \        bool is_prime = true;\n        for (long i = 2; i <= sqrt_nxt; i++) \n\
    \        {\n            if (nxt % i == 0) \n            {\n                is_prime\
    \ = false;\n                break;\n            }\n        }\n        if (is_prime)\
    \ \n        {\n            nth++;\n        }\n        prev = curr;\n        curr\
    \ = nxt;\n    }\n    return curr;\n}\n/*", "{\n    long fib_n = 1;\n    long fib_n_1\
    \ = 1;\n    long fib_n_2 = 0;\n    long counter = 0;\n    while (counter < n)\n\
    \    {\n        fib_n = fib_n_1 + fib_n_2;\n        fib_n_2 = fib_n_1;\n     \
    \   fib_n_1 = fib_n;\n        if ( isPrime(fib_n) )\n        {\n            counter++;\n\
    \        }\n    }\n    return fib_n;\n}\n/*", "{\n    long a = 0, b = 1, c;\n\
    \    long i = 0;\n    while (i != n)\n    {\n        c = a + b;\n        if (isPrime(c))\n\
    \        {\n            if (i == n - 1)\n                return c;\n         \
    \   i++;\n        }\n        a = b;\n        b = c;\n    }\n    return 0;\n}\n\
    /*", "{\n    static long[] cache;\n    static long counter = 0;\n    static long\
    \ fibo = 0;\n    static long fibo1 = 1;\n    static long fibo2 = 1;\n    if (cache[n]\
    \ != 0) \n    {\n        return cache[n];\n    }\n    while (counter != n) \n\
    \    {\n        fibo = fibo1 + fibo2;\n        fibo1 = fibo2;\n        fibo2 =\
    \ fibo;\n        if (fibo1.isPrime) \n        {\n            counter++;\n    \
    \        cache[counter] = fibo1;\n        }\n    }\n    return fibo1;\n}", "{\n\
    \    long c = 0;\n    long fib = 1;\n    long fib1 = 1;\n    long fib2 = 2;\n\
    \    while (c != n)\n    {\n        if (isPrime(fib2))\n        {\n          \
    \  c++;\n        }\n        fib = fib1 + fib2;\n        fib1 = fib2;\n       \
    \ fib2 = fib;\n    }\n    return fib1;\n}", "{\n    long x = 2; \n    long a =\
    \ 2; \n    long b = 3; \n    while (x <= n) \n    {\n        auto c = a + b; \n\
    \        if (isPrime(c)) \n        {\n            ++x; \n            a = b; \n\
    \            b = c; \n        } \n        else \n        {\n            a = b;\
    \ \n            b = c; \n        }\n    }\n    return a; \n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
