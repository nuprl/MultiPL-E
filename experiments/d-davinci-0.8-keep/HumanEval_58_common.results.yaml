name: HumanEval_58_common
language: d
results:
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n\tauto l1 = list(3,\
    \ 2, 5, 9, 1, 34, 5, 653, 1, 5);\n\tauto l2 = list(4, 7, 12, 3, 5, 9, 1, 5, 653,\
    \ 121);\n\tsort(l1);\n\tsort(l2);\n\tint lengthl1 = l1.length;\n\tint lengthl2\
    \ = l2.length;\n\tint i = 0;\n\tint j = 0;\n\twhile (i < lengthl1 && j < lengthl2)\
    \ \n\t{\n\t\tif (l1[i] < l2[j])\n\t\t{\n\t\t\ti++;\n\t\t}\n\t\telse if (l1[i]\
    \ > l2[j])\n\t\t{\n\t\t\tj++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\twriteln(l1[i]);\n\
    \t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t}\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptprb7vhd.d(14): Error: undefined identifier `list`\\n/tmp/tmptprb7vhd.d(14):\
    \ Error: variable `l1` is shadowing variable `tmptprb7vhd.common.l1`\\n/tmp/tmptprb7vhd.d(15):\
    \ Error: undefined identifier `list`\\n/tmp/tmptprb7vhd.d(15): Error: variable\
    \ `l2` is shadowing variable `tmptprb7vhd.common.l2`\\n/tmp/tmptprb7vhd.d(16):\
    \ Error: undefined identifier `sort`, did you mean function `sqrt`?\\n/tmp/tmptprb7vhd.d(17):\
    \ Error: undefined identifier `sort`, did you mean function `sqrt`?\\n/tmp/tmptprb7vhd.d(34):\
    \ Error: `writeln` is not defined, perhaps `import std.stdio;` is needed?\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptprb7vhd.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] l3\
    \ = set(l1);\n    long[] l4 = set(l2);\n    long[] l5 = set(l3);\n    long[] l6\
    \ = set(l4);\n    long[] l7 = set(l5);\n    long[] l8 = set(l6);\n    long[] l9\
    \ = set(l7);\n    long[] l10 = set(l8);\n    long[] l11 = set(l9);\n    long[]\
    \ l12 = set(l10);\n    long[] l13 = set(l11);\n    long[] l14 = set(l12);\n  \
    \  long[] l15 = set(l13);\n    long[] l16 = set(l14);\n    long[] l17 = set(l15);\n\
    \    long[] l18 = set(l16);\n    long[] l19 = set(l17);\n    long[] l20 = set(l18);\n\
    \    long[] l21 = set(l19);\n    long[] l22 = set(l20);\n    long[] l23 = set(l21);\n\
    \    long[] l24 = set(l22);\n    long[] l25 = set(l23);\n    long[] l26 = set(l24);\n\
    \    long[] l27 = set(l25);\n    long[] l28 = set(l26);\n    long[] l29 = set(l27);\n\
    \    long[] l30 = set(l28);\n    long[] l31 = set(l29);\n    long[] l32 = set(l30);\n\
    \    long[] l33 = set(l31);\n    long[] l34 = set(l32);\n    long[] l35 = set(l33);\n\
    \    long[] l36 = set(l34);\n    long[] l37 = set(l35);\n    long[] l38 = set(l36);\n\
    \    long[] l39 = set(l37);\n    long[] l40 = set(l38);\n    long[] l41 = set(l39);\n\
    \    long[] l42 = set(l40);\n    long[] l43 = set(l41);\n    long[] l44 = set(l42);\n\
    \    long[] l45\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8x3fc9aw.d(57): Error: semicolon expected, not `unittest`\\n/tmp/tmp8x3fc9aw.d(57):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp8x3fc9aw.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    if (l1.length\
    \ < l2.length)\n    {\n        long[] swap = l1;\n        l1 = l2;\n        l2\
    \ = swap;\n    }\n    auto set1 = l1.sort.uniq;\n    auto set2 = l2.sort.uniq;\n\
    \    long[] common = new long[];\n    foreach (item; set1)\n    {\n        if\
    \ (item in set2)\n        {\n            common ~= item;\n        }\n    }\n \
    \   return common;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4kifa1j2.d(20): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp4kifa1j2.d(21): Error: no property `sort` for type `long[]`\\n/tmp/tmp4kifa1j2.d(22):\
    \ Error: new can only create structs, dynamic arrays or class objects, not `long[]`\\\
    's\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4kifa1j2.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n\t// determine\
    \ which is larger, l1 or l2\n\t// sort the larger array\n\t// sort the smaller\
    \ array\n\t// start indexing the smaller array by 0\n\t// if the current index\
    \ matches the first value of the larger array, then all the others will be in\
    \ order\n\t// if the current index does not match the first value of the larger\
    \ array, then all the other index values should be less than the first value of\
    \ the larger array\n\t//\n\t\t\n\t\n\t\n\t\n\t// determine which is larger, l1\
    \ or l2\n\tlong[] smaller = l1;\n\tlong[] larger = l2;\n\t\n\tif (l1.length <\
    \ l2.length)\n\t{\n\t\tsmaller = l1;\n\t\tlarger = l2;\n\t}\n\t\n\t// sort the\
    \ larger array\n\t//sort(larger);\n\t\n\t// sort the smaller array\n\t//sort(smaller);\n\
    \t\n\t\n\t// start indexing the smaller array by 0\n\t\n\tint smaller_index =\
    \ 0;\n\t\n\t\n\t//if the current index matches the first value of the larger array,\
    \ then all the others will be in order\n\tif (smaller[smaller_index] == larger[0])\n\
    \t{\n\t\t// all values of smaller array will match in order to the larger array\n\
    \t\tsmaller_index++;\n\t}\n\t\n\t// if the current index does not match the first\
    \ value of the larger array, then all the other index values should be less than\
    \ the first value of the larger array\n\t\n\t\n\t\n\treturn larger;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmph15j8wyb.d(64): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428565]\\n??:? void tmph15j8wyb.__unittest_L60_C1()\
    \ [0x427fee]\\n??:? void tmph15j8wyb.__modtest() [0x4282e8]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c5c3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b456]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4305e9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430a98]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430575]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b42d]\\n??:? runModuleUnitTests [0x42c399]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428a28]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4289af]\\n??:? _d_run_main [0x42891a]\\n??:? main [0x4282fb]\\\
    n??:? __libc_start_main [0x9aae7554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] ret\
    \ = [];\n    foreach(element; sort(set(l1)))\n    {\n        if(element in set(l2))\n\
    \        {\n            ret ~= element;\n        }\n    }\n    return ret;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc_ua8ijk.d(15): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc_ua8ijk.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = [];\n    long[] tmp = [];\n    foreach(long i; l1)\n    {\n        if (l2.length\
    \ > 1)\n        {\n            tmp = common(l2[1..$], l1);\n            if (tmp.length\
    \ > 0)\n            {\n                result ~= tmp;\n            }\n       \
    \ }\n        if (l2[0] == l1[0])\n        {\n            result ~= l1[0];\n  \
    \      }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp12fy1cij.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42865d]\\n??:? void tmp12fy1cij.__unittest_L33_C1()\
    \ [0x4280e2]\\n??:? void tmp12fy1cij.__modtest() [0x4283dc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d157]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42bfea]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x43098d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430e3c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430919]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42bfc1]\\n??:? runModuleUnitTests [0x42cf2d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428b20]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428aa7]\\n??:? _d_run_main [0x428a12]\\n??:? main [0x4283ef]\\\
    n??:? __libc_start_main [0xe3359554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    /*\n    The\
    \ following algorithm uses a binary search to find the common elements in two\
    \ sorted lists.\n    Time complexity is O(mlogn) where m is the number of elements\
    \ in the smaller list.\n    Space complexity is O(1).\n    */\n    long[] result\
    \ = new long[0];\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpscwrso0p.d(20): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpscwrso0p.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{ \n    long[] result\
    \ = [];\n    HashSet!long set = new HashSet!long(); \n    foreach(e1; l1) \n \
    \   { \n        foreach(e2; l2) \n        { \n            if(e1 == e2) \n    \
    \        { \n                if(!set.contains(e1)) \n                { \n    \
    \                set.insert(e1); \n                    result ~= e1; \n      \
    \          } \n            } \n        } \n    } \n    return result; \n}\n \n\
    /*\nReturn sorted unique elements for two lists.\n    >>> union([1, 4, 3, 34,\
    \ 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 2, 3, 4, 5, 7, 9, 34, 121, 653]\n\
    \    >>> union([5, 3, 2, 8], [3, 2])\n    [2, 3, 5, 8]\n*/\nlong[] union(long[]\
    \ l1, long[] l2) \n{ \n    long[] result = [];\n    HashSet!long set = new HashSet!long();\
    \ \n    foreach(e1; l1) \n    { \n        if(!set.contains(e1)) \n        { \n\
    \            set.insert(e1); \n            result ~= e1; \n        } \n    } \n\
    \    foreach(e2; l2) \n    { \n        if(!set.contains(e2)) \n        { \n  \
    \          set.insert(e2); \n            result ~= e2; \n        } \n    } \n\
    \    return result; \n}\n \n/*\nReturn sorted unique elements for all lists.\n\
    \    >>> unionAll([[1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]])\n   \
    \ [1, 2, 3, 4, 5, 7, 9, 34, 121, 653]\n    >>> unionAll([[5, 3, 2, 8], [3, 2]])\n\
    \    [2, 3,\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnototkre.d(40): Error: no identifier for declarator `long[]`\\\
    n/tmp/tmpnototkre.d(40): Error: { } expected following `union` declaration\\n/tmp/tmpnototkre.d(40):\
    \ Error: declaration expected, not `(`\\n/tmp/tmpnototkre.d(44): Error: declaration\
    \ expected, not `foreach`\\n/tmp/tmpnototkre.d(44): Error: no identifier for declarator\
    \ `l1`\\n/tmp/tmpnototkre.d(44): Error: declaration expected, not `)`\\n/tmp/tmpnototkre.d(49):\
    \ Error: no identifier for declarator `result`\\n/tmp/tmpnototkre.d(49): Error:\
    \ declaration expected, not `~=`\\n/tmp/tmpnototkre.d(50): Error: unrecognized\
    \ declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnototkre.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long max1\
    \ = std.max(l1);\n    long max2 = std.max(l2);\n    auto max = std.max(max1, max2);\n\
    \    int[] arr = new int[max + 1];\n    foreach (i; l1) \n    {\n        arr[i]\
    \ += 1;\n    }\n    foreach (i; l2) \n    {\n        arr[i] += 1;\n    }\n   \
    \ return arr.byKey.keys.filter!(a => a != 0);\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyktt8y_7.d(14): Error: undefined identifier `max` in package\
    \ `std`\\n/tmp/tmpyktt8y_7.d(15): Error: undefined identifier `max` in package\
    \ `std`\\n/tmp/tmpyktt8y_7.d(16): Error: undefined identifier `max` in package\
    \ `std`\\n/tmp/tmpyktt8y_7.d(26): Error: template `object.byKey` cannot deduce\
    \ function from argument types `!()(int[])`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/druntime/import/object.d(2941):\
    \        `object.byKey(T : V[K], K, V)(T aa)`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/druntime/import/object.d(2963):\
    \        `object.byKey(T : V[K], K, V)(T* aa)`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpyktt8y_7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{ \n\tlong[long]\
    \ l;\n\t\n\tforeach(idx, i; l1) {\n\t\tforeach(idx, j; l2) {\n\t\t\tif(i == j)\
    \ {\n\t\t\t\tl[i] = i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn cast(long[]) l.values;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnipwx2w1.d(17): Error: variable `idx` is shadowing variable `tmpnipwx2w1.common.idx`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnipwx2w1.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    l1.sort();\n\
    \    l2.sort();\n    long[] t1 = l1.dup;\n    t1.uniq;\n    long[] t2 = l2.dup;\n\
    \    t2.uniq;\n    return t1.intersect(t2);\n}\nstatic assert(common([1, 4, 3,\
    \ 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]);\nstatic assert(common([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3]);\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5m3ma3ga.d(14): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp5m3ma3ga.d(15): Error: no property `sort` for type `long[]`\\n/tmp/tmp5m3ma3ga.d(17):\
    \ Error: no property `uniq` for type `long[]`\\n/tmp/tmp5m3ma3ga.d(19): Error:\
    \ no property `uniq` for type `long[]`\\n/tmp/tmp5m3ma3ga.d(20): Error: no property\
    \ `intersect` for type `long[]`\\n/tmp/tmp5m3ma3ga.d(22):        called from here:\
    \ `common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])`\\\
    n/tmp/tmp5m3ma3ga.d(22):        called from here: `__equals(common([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]), [1, 5, 653])`\\n/tmp/tmp5m3ma3ga.d(22):\
    \        while evaluating: `static assert(common([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1, 5, 653])`\\n/tmp/tmp5m3ma3ga.d(23):\
    \ Error: CTFE failed because of previous errors in `common`\\n/tmp/tmp5m3ma3ga.d(23):\
    \        called from here: `__equals(common([5L, 3L, 2L, 8L], [3L, 2L]), [2, 3])`\\\
    n/tmp/tmp5m3ma3ga.d(23):        while evaluating: `static assert(common([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2, 3])`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp5m3ma3ga.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    assert(l1);\n\
    \    assert(l2);\n    // sort(l1);\n    // sort(l2);\n    long[] ret;\n    long[]\
    \ t = array(long);\n    // trace(l1);\n    // trace(l2);\n    foreach(x,y; zip(l1,l2))\n\
    \    {\n        if(x == y)\n        {\n            t ~= x;\n        }\n    }\n\
    \    // trace(t);\n    ret = sort(t)[];\n    // trace(ret);\n    return ret;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfk8uwqcc.d(19): Error: found `)` when expecting `.` following\
    \ long\\n/tmp/tmpfk8uwqcc.d(19): Error: found `;` when expecting identifier following\
    \ `long`.\\n/tmp/tmpfk8uwqcc.d(22): Error: found `foreach` when expecting `,`\\\
    n/tmp/tmpfk8uwqcc.d(22): Error: found `;` when expecting `)`\\n/tmp/tmpfk8uwqcc.d(22):\
    \ Error: found `zip` when expecting `,`\\n/tmp/tmpfk8uwqcc.d(23): Error: semicolon\
    \ expected, not `{`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfk8uwqcc.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] ll1;\n\
    \    long[] ll2;\n    // common items are added to uniques and then returned sorted\n\
    \    long[] uniques;\n    long[] l;\n    auto n;\n    int i;\n    int j;\n   \
    \ int k;\n    //std.sort.sort(l1);\n    //std.sort.sort(l2);\n    // get size\
    \ of the lists\n    n = l1.length;\n    m = l2.length;\n    // determine if l1\
    \ or l2 is smaller list\n    if (n<m)\n    {\n        ll1 = l1;\n        ll2 =\
    \ l2;\n    }\n    else\n    {\n        ll1 = l2;\n        ll2 = l1;\n    }\n \
    \   // allocate enough space in uniques\n    uniques = new long[ll1.length];\n\
    \    // start looping through small list\n    for (i=0; i<ll1.length; i++)\n \
    \   {\n        // check list 2 to see if it contains the number\n        if (ll2.find(ll1[i])!=-1)\n\
    \        {\n            // if it does, check the array of unique numbers\n   \
    \         // to make sure it has not already been added\n            if (uniques.find(ll1[i])==-1)\n\
    \            {\n                // if it is not in uniques, add it\n         \
    \       uniques.length++;\n                uniques[uniques.length-1] = ll1[i];\n\
    \            }\n        }\n    }\n    return uniques;\n}\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpy18lzgux.d(19): Error: no identifier for declarator `n`\\n/tmp/tmpy18lzgux.d(19):\
    \ Deprecation: use `{ }` for an empty statement, not `;`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmpy18lzgux.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    auto s1 =\
    \ l1.sort();\n    auto s2 = l2.sort();\n    long[][] t = [ s1, s2 ];\n    t =\
    \ t.sort!((a, b) => a.length < b.length);\n    long[] common = [ ];\n    long[]\
    \ f = t[0];\n    long[] s = t[1];\n    long len = f.length;\n    auto iter = s.opSlice().byChunk(len).sort().opSlice();\n\
    \    foreach(i; 0..5)\n    {\n        if(i > 3) return common;\n        auto newS\
    \ = iter.popFront();\n        if(f == newS) return f;\n        if(! newS.length)\
    \ continue;\n        auto fiter = f.opSlice().byChunk(newS.length).sort().opSlice();\n\
    \        foreach(j; 0..5)\n        {\n            if(j > 3) return common;\n \
    \           auto newF = fiter.popFront();\n            if(newF == newS) \n   \
    \         {\n                common ~= newF;\n                break;\n       \
    \     }\n        }\n    }\n    return common;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp799_m7sz.d(14): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp799_m7sz.d(15): Error: no property `sort` for type `long[]`\\n/tmp/tmp799_m7sz.d(17):\
    \ Error: no property `sort` for type `long[][]`\\n/tmp/tmp799_m7sz.d(22): Error:\
    \ no property `opSlice` for type `long[]`\\n/tmp/tmp799_m7sz.d(29): Error: no\
    \ property `opSlice` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp799_m7sz.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    //return l1.filter!(e\
    \ => l2.count(e)).sort().uniq();\n    long[] ret = new long[](0);\n    long[]\
    \ l,s;\n    if(l1.length < l2.length) {\n        l = l2;\n        s = l1;\n  \
    \  }\n    else {\n        l = l1;\n        s = l2;\n    }\n    foreach(i; l) {\n\
    \        if(s.count(i) > 0) {\n            ret ~= i;\n        }\n    }\n    ret\
    \ = ret.sort().uniq();\n    return ret;\n}\nunittest\n{\n    alias candidate =\
    \ common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L,\
    \ 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L,\
    \ 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L,\
    \ 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpiyte__a_.d(26): Error: no property `count` for type `long[]`\\\
    n/tmp/tmpiyte__a_.d(30): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiyte__a_.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    auto n = l1.length;\n\
    \    auto l1s = l1[0..n];\n    auto l2s = l2[0..n];\n    auto l1sUnique = l1s.sort().unique;\n\
    \    auto l2sUnique = l2s.sort().unique;\n    auto l = [] {};\n    auto i = 0;\n\
    \    foreach(e; l1sUnique)\n    {\n        if(l2sUnique.canFind(e))\n        {\n\
    \            l ~= e;\n        }\n    }\n    return l;\n}\n/*\nReturn sorted unique\
    \ common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5,\
    \ 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n\
    \    [2, 3]\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6zx470hj.d(19): Error: semicolon expected following auto declaration,\
    \ not `{`\\n/tmp/tmp6zx470hj.d(19): Deprecation: use `{ }` for an empty statement,\
    \ not `;`\\n/tmp/tmp6zx470hj.d(30): Error: unterminated /* */ comment\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6zx470hj.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    return l1.sort()\n\
    \    .zip(l2.sort())\n    .filter!(a => a[0] == a[1])\n    .map!(a => a[0])\n\
    \    .front;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8rs2vuw9.d(14): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8rs2vuw9.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    assert(l1.length\
    \ > 0 && l2.length > 0);\n    // TODO: Sort l1 and l2\n    auto s1 = l1.sort();\n\
    \    auto s2 = l2.sort();\n    long[] res = new long[];\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_8kc8nru.d(19): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_8kc8nru.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{ \n    long[] a1\
    \ = nts(l1); \n    long[] a2 = nts(l2); \n    return setintersection(a1, a2);\
    \ \n} \nlong[] nts(long[] arr) \n{ \n    return arr.dup.sort(); \n} \nlong[] setintersection(long[]\
    \ l1, long[] l2) \n{ \n    long[] l3 = new long[1]; \n    foreach (i; l1) \n \
    \   { \n        if (l2.contains(i)) \n        { \n            l3 ~= i; \n    \
    \    } \n    } \n    return l3; \n} \nlong[] setunion(long[] l1, long[] l2) \n\
    { \n    long[] l3 = l1.dup; \n    foreach (i; l2) \n    { \n        if (!l3.contains(i))\
    \ \n        { \n            l3 ~= i; \n        } \n    } \n    return l3; \n}\
    \ \nlong[] setdifference(long[] l1, long[] l2) \n{ \n    long[] l3 = new long[1];\
    \ \n    foreach (i; l1) \n    { \n        if (!l2.contains(i)) \n        { \n\
    \            l3 ~= i; \n        } \n    } \n    return l3; \n} \nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc0awxwqa.d(20): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpc0awxwqa.d(27): Error: no property `contains` for type `long[]`\\n/tmp/tmpc0awxwqa.d(39):\
    \ Error: no property `contains` for type `long[]`\\n/tmp/tmpc0awxwqa.d(51): Error:\
    \ no property `contains` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\",\
    \ \"-v\", \"-o-\", \"/tmp/tmpc0awxwqa.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    // In the\
    \ first step we create a dictionary, where the keys are unique \n    // elements\
    \ of the second list, and values are equal to the keys.\n    long[] l2_unique\
    \ = l2.sort.uniq;\n    auto d1 = new long[long][long](l2_unique.length);\n   \
    \ for (int i = 0; i < l2_unique.length; i++)\n    {\n        d1[l2_unique[i]]\
    \ = l2_unique[i];\n    }\n    // Now we iterate through the first list, and check\
    \ if\n    // the element is in the first dictionary.\n    // If it is, we move\
    \ it to the second dictionary.\n    // In the result we have sorted unique elements\n\
    \    // that are in both lists.\n    auto d2 = new long[long][long](l1.length);\n\
    \    foreach (a; l1)\n    {\n        if (a in d1)\n        {\n            d2[a]\
    \ = a;\n        }\n    }\n    // Sorting and uniquing at the last step\n    return\
    \ d2.values.sort.uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpavjv4k3n.d(17): Error: need size of rightmost array, not type\
    \ `long`\\n/tmp/tmpavjv4k3n.d(27): Error: need size of rightmost array, not type\
    \ `long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpavjv4k3n.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
