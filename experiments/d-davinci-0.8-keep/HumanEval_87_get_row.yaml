name: HumanEval_87_get_row
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
  \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
  \    each row may contain a different number of columns.\n    Given lst, and integer\
  \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
  \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
  \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
  \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
  \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
  \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n\
  \    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long, long)[]\
  \ get_row(long[][] lst, long x) \n"
tests: "unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
  \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
  \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
  \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
  \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
  \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
  \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
  \ 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L,\
  \ 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L,\
  \ 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L,\
  \ 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L),\
  \ tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]],\
  \ 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L,\
  \ 2L)]);\n}\nvoid main(){}"
completions: ["{\n\tbool[long, long] hash = new bool[long, long];\n\tTuple!(long,\
    \ long)[] result = new Tuple!(long, long)[];\n\tfor (long i = 0; i < lst.length;\
    \ i++)\n\t{\n\t\tfor (long j = 0; j < lst[i].length; j++)\n\t\t{\n\t\t\tif (lst[i][j]\
    \ == x)\n\t\t\t{\n\t\t\t\thash[i, j] = true;\n\t\t\t}\n\t\t}\n\t}\n\tforeach (i;\
    \ keys(hash))\n\t{\n\t\tforeach (j; keys(hash[i]))\n\t\t{\n\t\t\tresult ~= tuple(i,\
    \ j);\n\t\t}\n\t}\n\tstd.algorithm.sort!(\"a.length < b.length || a[0] < b[0]\
    \ || a[1] > b[1]\")(result);\n\treturn result;\n}", "{\n    Tuple!(long, long)[]\
    \ coordinates;\n    foreach(row; 0 .. lst.length)\n    {\n        foreach(col;\
    \ 0 .. lst[row].length)\n        {\n            if(lst[row][col] == x)\n     \
    \       {\n                coordinates ~= tuple(row, col);\n            }\n  \
    \      }\n    }\n    coordinates.sort!(a, b => a[0] < b[0] || (a[0] == b[0] &&\
    \ a[1] > b[1]));\n    return coordinates;\n}", "{\n    Tuple!(long, long)[] res;\n\
    \    foreach(i, row; lst) \n    {\n        foreach(j, col; row) \n        {\n\
    \            if(col == x) \n            {\n                res ~= tuple(i, j);\n\
    \            }\n        }\n    }\n    res.sort!((a, b) => a[0] == b[0] ? b[1]\
    \ < a[1] : a[0] < b[0]);\n    return res;\n}", "{\n    auto op__(in long[] a,\
    \ in long[] b) {\n        if (a.length < b.length) {\n            return true;\n\
    \        } else if (a.length > b.length) {\n            return false;\n      \
    \  } else {\n            for (size_t i = 0; i < a.length; i++) {\n           \
    \     if (a[i] < b[i]) {\n                    return true;\n                }\
    \ else if (a[i] > b[i]) {\n                    return false;\n               \
    \ }\n            }\n            return false;\n        }\n    }\n    Tuple!(long,\
    \ long)[] res;\n    int x_count = 0;\n    lst.sort!op__();\n    foreach (row;\
    \ lst) {\n        foreach (col; row) {\n            if (col == x) {\n        \
    \        Tuple!(long, long) tuple = tuple(cast(long)x_count, cast(long)row.indexOf(col));\n\
    \                res ~= tuple;\n            }\n        }\n        x_count++;\n\
    \    }\n    return res;\n}\n// sort!((a, b) => a.length < b.length || a.length\
    \ == b.length && a.sum > b.sum)\n// (a, b) => a.length < b.length || a.length\
    \ == b.length && a.sum > b.sum\n//(a, b) => a.length < b.length || a.length ==\
    \ b.length && a.sum > b.sum", "{\n    if (lst.length == 0)\n        return [];\n\
    \    long[][] ret;\n    foreach (r, i; lst)\n    {\n        foreach (c, j; r)\n\
    \        {\n            if (c == x)\n                ret ~= [i, j];\n        }\n\
    \    }\n    return ret.sort!((a, b) => a[0] < b[0] || a[0] == b[0] && a[1] > b[1]).map!(s\
    \ => Tuple!(long, long)(s[0], s[1]));\n}", "{\n    Tuple!(long, long)[] tuples;\n\
    \    foreach(i, row; lst) \n    {\n        if(i in tuples)\n            continue;\n\
    \        foreach(j, e; row) \n        {\n            if(e == x)\n            \
    \    tuples ~= tuple(i, j);\n        }\n    }\n    tuples.sort!((t1, t2) {\n \
    \       return t1[0] < t2[0]\n            || (t1[0] == t2[0] && t1[1] > t2[1]);\n\
    \    });\n    return tuples;\n}", "{\n    // init variables\n    immutable size_t\
    \ length = lst.length;\n    Tuple!(long, long)[] answer;\n    // searching\n \
    \   for (size_t i = 0; i < length; i++) \n    {\n        // init indexes\n   \
    \     immutable size_t size = lst[i].length;\n        size_t index = 0;\n    \
    \    // searching\n        for (; index < size; index++) \n        {\n       \
    \     if (lst[i][index] == x) \n            {\n                answer ~= tuple(i,\
    \ index);\n            }\n        }\n    }\n    return sort(answer, (a, b) =>\
    \ a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]));\n}", "{\n    auto ret = new Tuple!(long,\
    \ long)[](0);\n    size_t row_index = 0;\n    foreach(row; lst) {\n        long\
    \ column_index = row.length;\n        foreach(cell; row) {\n            if(cell\
    \ == x) {\n                ret ~= tuple(row_index, column_index);\n          \
    \  }\n            column_index--;\n        }\n        row_index++;\n    }\n  \
    \  return ret;\n}", "{\n    import std.algorithm : filter, sort, map;\n    import\
    \ std.range : enumerate;\n    Tuple!(long, long)[] result;\n    foreach(i, row;\
    \ lst.enumerate)\n    {\n        immutable res = row.filter!(a => a == x).map!(a\
    \ => Tuple!(long, long)(i, a)).array;\n        if(res.length != 0)\n         \
    \   result ~= res;\n    }\n    result.sort!((a, b) => a[0] == b[0] ? b[1] < a[1]\
    \ : a[0] < b[0]);\n    return result;\n}", "{\n    import std.algorithm : sort;\n\
    \    import std.algorithm : filter;\n    import std.range : zip;\n    import std.range\
    \ : enumerate;\n    import std.array : array;\n    import std.conv : to;\n   \
    \ if (lst.length == 0) return [];\n    auto tmp = lst.enumerate().map!(a => a.index.to!long).zip(lst);\n\
    \    auto res = tmp.filter!(a => a[1].filter!(i => i == x).length != 0)\n    \
    \    .map!(a => a[1].enumerate().map!(c => c.index.to!long).zip(a[1])\n      \
    \      .filter!(c => c[1] == x)\n            .map!(a => tuple(a[0], a[1]))).array();\n\
    \    foreach (i; res) \n    {\n        sort!((a, b) => a[0] > b[0])(i);\n    }\n\
    \    sort!((a, b) => a[0] < b[0])(res);\n    return res.map!(a => a[0]).array;\n\
    }", "{\n    // get list of indexes of given element\n    auto indices = zip(enumerate(lst))\n\
    \        .filter!(t => t[1].canFind(x))\n        .map!(t => tuple(t[0], t[1].indexOf(x)));\n\
    \    return indices\n        .sort!(t => t[0]) // sort indices in ascending order\n\
    \        .map!(t => tuple(t[0], t[1])) // reorder elements\n        .sort!(t =>\
    \ t[1]) // sort indices in descending order\n        .map!(t => tuple(t[0], t[1]));\
    \ // reorder elements\n}", "{\n    return lst.byRow!((a, b) =>\n    {\n      \
    \  if (a[].length < b[].length)\n            return -1;\n        else if (a[].length\
    \ > b[].length)\n            return 1;\n        else\n            return 0;\n\
    \    }).map!(row => row.indexOf(x)).zip(seq(lst.length));\n}", "{\n    long[Tuple!(long,\
    \ long)[]] data = [];\n    long[Tuple!(long, long)[]] row = [];\n    long[long[]]\
    \ tmp = [];\n    for (long i = 0; i < lst.length; i++) \n    {\n        for (long\
    \ j = 0; j < lst[i].length; j++) \n        {\n            if (lst[i][j] == x)\
    \ \n            {\n                row ~= tuple(i, j);\n            }\n      \
    \  }\n        if (row.length != 0) \n        {\n            data ~= row;\n   \
    \         row = [];\n        }\n    }\n    row = [];\n    foreach (r; data) \n\
    \    {\n        row = sort(r);\n        row.reverse;\n        tmp ~= row;\n  \
    \  }\n    row = [];\n    foreach (t; tmp) \n    {\n        foreach (r; t) \n \
    \       {\n            row ~= r;\n        }\n    }\n    return row;\n}", "{\n\
    \    if (lst.length == 0)\n        return [];\n    auto t = zip(iota(lst.length),\
    \ lst);\n    t = filter!(y => y[1].canFind(x))(t);\n    t = map!(y => zip(repeat(y[0]),y[1].findAll(x)))(t);\n\
    \    t = t.join;\n    t = sort!((x, y) => x[0] < y[0] || x[0] == y[0] && x[1]\
    \ > y[1])(t);\n    return t;\n}", "{\n    Tuple!(long, long)[] result;\n    foreach(i,\
    \ row; lst) \n    {\n        foreach(j, val; row) \n        {\n            if(val\
    \ == x)\n                result ~= tuple(i, j);\n        }\n    }\n    if(result.length\
    \ > 0)\n    {\n        result.sort!((a, b) => \n        {\n            if(a[0]\
    \ < b[0]) return -1;\n            if(a[0] > b[0]) return 1;\n            return\
    \ b[1] - a[1];\n        });\n    }\n    return result;\n}", "{\n    int num =\
    \ lst.length;\n    int count = 0;\n    long[] xIndex = new long[num];\n    long[]\
    \ yIndex = new long[num];\n    for (int i = 0; i < num; i++) \n    {\n       \
    \ auto length = lst[i].length;\n        for (int j = 0; j < length; j++) \n  \
    \      {\n            if (lst[i][j] == x) \n            {\n                xIndex[count]\
    \ = i;\n                yIndex[count] = j;\n                count++;\n       \
    \     }\n        }\n    }\n    xIndex = xIndex[0..count];\n    yIndex = yIndex[0..count];\n\
    \    sort(xIndex);\n    Tuple!(long, long)[] result = new Tuple!(long, long)[count];\n\
    \    for (int i = 0; i < count; i++) \n    {\n        result[i] = tuple(xIndex[i],\
    \ yIndex[i]);\n    }\n    return result;\n}", "{\n    Tuple!(long, long)[] result;\n\
    \    foreach(long i, const(long)[] row; lst)\n    {\n        foreach(long j, long\
    \ val; row)\n        {\n            if(val == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    sort!((a, b)\
    \ =>\n        a[0] > b[0] || (a[0] == b[0] && a[1] < b[1])\n    )(result);\n \
    \   return result;\n}\n/*\n    \n    Your task is to make a calculator which evaluates\
    \ expressions in Reverse Polish notation.\n    Empty expression should evaluate\
    \ to 0. \n    Valid operations are +, -, *, /.\n    Calculate((2, 3, '+')) ==\
    \ 5\n    Calculate((2, 3, '*')) == 6\n    Calculate((50, 23, '-')) == 27\n   \
    \ Calculate((50, 23, '/')) == 2\n    Calculate((2, 3, '+', 5, '*')) == 25\n  \
    \  Calculate((2, 3, '+', 5, '/')) == 1\n    Calculate((50, 23, '-', 10, '/'))\
    \ == 3\n    Calculate((100, 10, '/', 2, '+')) == 55\n    Calculate((2, 3, 4, '+',\
    \ '*')) == 14\n*/\nlong calculate(in long[] ops) \n{\n    long[] stack;\n    long\
    \ res = 0;\n    foreach(long i, long op; ops)\n    {\n        if(op == '+')\n\
    \        {\n            stack ~= stack.pop() + stack.pop();\n        }\n     \
    \   else if(op == '-')\n        {\n            long val1 = stack.pop();\n    \
    \        long val2 = stack.pop();\n            stack ~= val2 - val1;\n       \
    \ }\n        else if(op == '*')\n        {\n            stack ~= stack.pop() *\
    \ stack.pop();\n        }\n        else if(op == '/')\n        {\n           \
    \ long val1 = stack.pop();\n            long val", "{\n    int[] x_list = [];\n\
    \    int[] y_list = [];\n    for (int i = 0; i < lst.length; i++)\n    {\n   \
    \     for (int j = 0; j < lst[i].length; j++)\n        {\n            if (lst[i][j]\
    \ == x)\n            {\n                x_list ~= j;\n                y_list ~=\
    \ i;\n            }\n        }\n    }\n    if (x_list.length == 0)\n    {\n  \
    \      return [];\n    }\n    else\n    {\n        auto zipped = zip(y_list, x_list);\n\
    \        zipped.sort!(\"a[0] < b[0]\");\n        foreach (z; zipped)\n       \
    \ {\n            z.sort!(\"a[1] > b[1]\");\n        }\n        return zipped;\n\
    \    }\n}", "{\n    // TODO: Implement me.\n    return [].sor", "{\n    auto coordinates\
    \ = [];\n    for (size_t i = 0; i < lst.length; i++) \n    {\n        for (size_t\
    \ j = 0; j < lst[i].length; j++) \n        {\n            if (lst[i][j] == x)\n\
    \                coordinates ~= tuple(i, j);\n        }\n    }\n    return coordinates.sort!((a,\
    \ b) => a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]));\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
