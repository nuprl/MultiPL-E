name: HumanEval_27_flip_case
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n For a given string, flip lowercase\
  \ characters to uppercase and uppercase to lowercase.\n    >>> flip_case('Hello')\n\
  \    'hELLO'\n    \n*/\nstring flip_case(string string) \n"
tests: "unittest\n{\n    alias candidate = flip_case;\n\n    assert(candidate(\"\"\
  ) == \"\");\n    assert(candidate(\"Hello!\") == \"hELLO!\");\n    assert(candidate(\"\
  These violent delights have violent ends\") == \"tHESE VIOLENT DELIGHTS HAVE VIOLENT\
  \ ENDS\");\n}\nvoid main(){}"
completions: ["{\n    string result;\n    foreach(i, c; string) \n    {\n        if\
    \ (i % 2 == 0) \n        {\n            result ~= toUpper(c);\n        } \n  \
    \      else \n        {\n            result ~= toLower(c);\n        }\n    }\n\
    \    return result;\n}", "{\n    string ret;\n    foreach(ch; string) \n    {\n\
    \        ret ~= isUpper(ch) ? toLower(ch) : toUpper(ch);\n    }\n    return ret;\n\
    }\n/*\n For a given string, return the summed ASCII values of the string.\n  \
    \  >>> summed_ascii('abc')\n    291\n    >>> summed_ascii('Hello')\n    532\n\
    \    \n*/\nsize_t summed_ascii(string string) \n{\n    size_t ret = 0;\n    foreach(ch;\
    \ string) \n    {\n        ret += ord(ch);\n    }\n    return ret;\n}\n/*\n Returns\
    \ the reverse of a given string.\n    >>> reverse('Hello')\n    'olleH'\n    >>>\
    \ reverse('abc')\n    'cba'\n    \n*/\nstring reverse(string string) \n{\n   \
    \ return string.dup.reverse;\n}\n/*\n Returns the middle character of a given\
    \ string.\n If there are an even number of characters, return the right-most.\n\
    \    >>> middle('Hello')\n    'l'\n    >>> middle('abcdefg')\n    'e'\n    \n\
    */\nchar middle(string string) \n{\n    size_t half = string.length / 2;\n   \
    \ return string[half];\n}\n/*\n For a given string, return true if the string\
    \ is a palindrome, and false otherwise.\n    >>> is_palindrome('racecar')\n  \
    \  True\n    >>> is_palindrome('hello')\n    False\n    \n*/", "{\n    return\
    \ string.map!(ch => (ch.isUpper() ? ch.toLower() : ch.toUpper()));\n}\n/*\nTake\
    \ the first n alphabetically sorted elements from a list.\nIf n is greater than\
    \ or equal to the length of list, return the list.\nIf n is less than zero, return\
    \ an empty list.", "{\n    string ret;\n    foreach(c; string) \n    {\n     \
    \   if(c.isUpper)\n            ret ~= c.toLower;\n        else if(c.isLower)\n\
    \            ret ~= c.toUpper;\n        else\n            ret ~= c;\n    }\n \
    \   return ret;\n}", "{\n\tforeach(c; string)\n\t{\n\t\tif(isAlpha(c))\n\t\t{\n\
    \t\t\tif(isUpper(c))\n\t\t\t{\n\t\t\t\tc = toLower(c);\n\t\t\t}\n\t\t\telse\n\t\
    \t\t{\n\t\t\t\tc = toUpper(c);\n\t\t\t}\n\t\t}\n\t}\n\treturn string;\n}", "{\n\
    \tforeach(immutable char c; string)\n\t{\n\t\tif(isUpper(c))\n\t\t\tstring ~=\
    \ toLower(c);\n\t\telse if(isLower(c))\n\t\t\tstring ~= toUpper(c);\n\t\telse\n\
    \t\t\tstring ~= c;\n\t}\n\treturn string;\n}", "{\n    string flipped = \"\";\n\
    \    for (auto c : string) \n    {\n        if (c.isUpper()) \n        {\n   \
    \         flipped ~= c.toLower();\n        } \n        else \n        {\n    \
    \        flipped ~= c.toUpper();\n        }\n    }\n    return flipped;\n}", "{\n\
    \  return (string.map!(ch => ch.isUpper ? ch.toLower : ch.toUpper)).retro;\n}",
  "{\n    char[] result = new char[string.length];\n    for (int i = 0; i < string.length;\
    \ i++) \n    {\n        result[i] = isLower(string[i]) ? toupper(string[i]) :\
    \ tolower(string[i]);\n    }\n    return result.toStringz();\n}\nstring s = \"\
    Hello\";\nwriteln(flip_case(s));", "{\n    string new_string;\n    for (int i\
    \ = 0; i < string.length; i++) \n    {\n        auto c = string[i];\n        if(isUpper(c))\
    \ \n        {\n            new_string ~= toLower(c);\n        } \n        else\
    \ \n        {\n            new_string ~= toUpper(c);\n        }\n    }\n    return\
    \ new_string;\n}", "{\n    import std.string;\n    return string.map!(\"to!(char)(to!int(a)\
    \ ^ 32)\")(\"a\");\n}", "{\n    auto new_string = string.dup;\n    for (size_t\
    \ i = 0; i < new_string.length; i++)\n    {\n        new_string[i] = isalpha(new_string[i])\
    \ ? toggle(new_string[i]) : new_string[i];\n    }\n    return new_string;\n}",
  "{\n    foreach(immutable ref c; string) {\n        if(isAlpha(c))\n           \
    \ c = toLower(c);\n        else\n            c = toUpper(c);\n    }\n    return\
    \ string;\n}", "{\n    string result = \"\";\n    foreach(char letter; string)\n\
    \    {\n        result ~= islower(letter) ? toupper(letter) : tolower(letter);\n\
    \    }\n    return result;\n}", "{\n    char[] s2 = new char[string.length];\n\
    \    foreach(size_t i, c; string) {\n        if(isLower(c))\n            s2[i]\
    \ = toUpper(c);\n        else if(isUpper(c))\n            s2[i] = toLower(c);\n\
    \        else\n            s2[i] = c;\n    }\n    return to!string(s2);\n}", "{\n\
    \    string new_string = \"\";\n    foreach(character; string)\n    {\n      \
    \  if(isUpper(character))\n        {\n            new_string ~= lower(character);\n\
    \        }\n        else\n        {\n            new_string ~= upper(character);\n\
    \        }\n    }\n    return new_string;\n}", "{\n\tstring result;\n\tforeach(chr;\
    \ string) \n\t{\n\t\tresult ~= cast(char) (((chr >= 'a' && chr <= 'z') ? chr -\
    \ 32 : chr)\n\t\t\t\t\t\t\t\t\t\t+ ((chr >= 'A' && chr <= 'Z') ? chr + 32 : chr));\n\
    \t}\n\treturn result;\n}", "{\n    string result = \"\";\n    foreach(c; string)\
    \ \n    {\n        if(c.isUpper) \n        {\n            result ~= c.toLower;\n\
    \        } \n        else \n        {\n            result ~= c.toUpper;\n    \
    \    }\n    }\n    return result;\n}", "{\n  string result = \"\";\n  foreach(ch;\
    \ string) \n  {\n    result ~= isUpper(ch) ? toLower(ch) : toUpper(ch);\n  }\n\
    \  return result;\n}", "{ \n    immutable result = \"\"; \n    immutable stringLength\
    \ = string.length; \n    foreach(immutable i; 0..stringLength) \n    { \n    \
    \    immutable c = string[i]; \n        immutable s = c.toString(); \n       \
    \ immutable isupper = c.isUpper; \n        immutable islower = c.isLower; \n \
    \       if(isupper) \n        { \n            result ~= c.toLower; \n        }\
    \ \n        else if(islower) \n        { \n            result ~= c.toUpper; \n\
    \        } \n        else \n        { \n            result ~= c; \n        } \n\
    \    } \n    return result; \n} "]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
