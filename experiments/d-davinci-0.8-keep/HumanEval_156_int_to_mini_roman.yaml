name: HumanEval_156_int_to_mini_roman
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
  \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
  \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
  \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
  \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n"
tests: "unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
  \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
  \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
  \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
  iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) == \"\
  xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L) == \"\
  dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L) ==\
  \ \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
completions: ["{ \n    long[] values = [ \n                    1000, 900, 500, 400,\n\
    \                    100, 90, 50, 40,\n                    10, 9, 5, 4,\n    \
    \                1\n                    ];\n    \n    string[] numerals = [\n\
    \                        \"m\", \"cm\", \"d\", \"cd\",\n                     \
    \   \"c\", \"xc\", \"l\", \"xl\",\n                        \"x\", \"ix\", \"v\"\
    , \"iv\",\n                        \"i\"\n                        ];\n    \n \
    \   string result = \"\";\n    foreach(idx, number_of_symbols; zip(values, numerals))\
    \ \n    {\n        while(number >= number_of_symbols[0]) \n        {\n       \
    \     result ~= number_of_symbols[1];\n            number -= number_of_symbols[0];\n\
    \        }\n    }\n    return result;\n}", "{\n    auto result = \"\";\n    auto\
    \ arabic = [\n        (1, 'i'), (4, 'iv'), (5, 'v'), (9, 'ix'),\n        (10,\
    \ 'x'), (40, 'xl'), (50, 'l'), (90, 'xc'),\n        (100, 'c'), (400, 'cd'), (500,\
    \ 'd'), (900, 'cm'),\n        (1000, 'm')\n    ];\n    foreach(index, value; arabic.sorted)\n\
    \    {\n        while(value[0] <= number)\n        {\n            result ~= value[1];\n\
    \            number -= value[0];\n        }\n    }\n    return result;\n}", "{\n\
    \    static char[][7] digits = [\n        [\"i\", \"x\", \"c\", \"m\"],\n    \
    \    [\"v\", \"l\", \"d\"]\n    ];\n    static int[] values = [\n        [1, 10,\
    \ 100, 1000],\n        [5, 50, 500]\n    ];\n    static string template = `+\\\
    *-.`;\n    static string templates[] = split(template);\n    static int[] factors\
    \ = [0, 0, -1, 1, -1, 1, -1, 1, 0, 1];\n    static char[] operations = \"+-*.\"\
    ;\n    static int[] zeros = repeat(0, 4);\n    static int[] ones = repeat(1, 4);\n\
    \    static int[] fives = repeat(5, 4);\n    static int[] tens = repeat(10, 4);\n\
    \    static int[] hundreds = repeat(100, 4);\n    static string[] templates_for_ones\
    \ = repeat(\"\", 4);\n    static string[] templates_for_fives = repeat(\"\", 4);\n\
    \    static string[] templates_for_tens = repeat(\"\", 4);\n    static string[]\
    \ templates_for_hundreds = repeat(\"\", 4);\n    static int[] units = repeat(1,\
    \ 4);\n    static int[] scores = repeat(1, 4);\n    static int[] scores_for_ones\
    \ = repeat(0, 4);\n    static int[] scores_for_fives = repeat(0, 4);\n    static\
    \ int[] scores_for_tens = repeat(0, 4);\n    static int[] scores_for_hundreds\
    \ = repeat(0, 4);\n    static string[] templates_for_ones_ = repeat(\"\", 4);\n\
    \    static string[] templates_for_fives_ = repeat(\"\", 4);\n    static string[]\
    \ templates_for_tens_ = repeat(\"\", 4);\n    static string[] templates_for_hundreds_\
    \ = repeat(\"\", 4);\n    static int[] scores_for_ones_ = repeat(0, 4);\n    static\
    \ int[] scores_for_fives_ = repeat(0, 4);\n    static int[] scores_for_tens_ =\
    \ repeat(0, 4);\n    static int[] scores_for_hundreds_ = repeat(", "{\n    string\
    \ result;\n    string symbols = \"ixcm\";\n    int   decimals = [1, 10, 100, 1000];\n\
    \    int   max_power = symbols.length;\n    int   power, symbol_value, symbol;\n\
    \    char  symbol_char;\n    while (number > 0) {\n        power = max_power -\
    \ 1;\n        while (power >= 0) {\n            symbol_value = decimals[power];\n\
    \            if (number >= symbol_value) {\n                symbol = number /\
    \ symbol_value;\n                number = number % symbol_value;\n           \
    \     symbol_char = symbols[power];\n                for (int j = 0; j < symbol;\
    \ j++) {\n                    result ~= symbol_char;\n                }\n    \
    \            break;\n            }\n            power -= 1;\n        }\n    }\n\
    \    return result;\n}", "{ \n    if (number <= 0 || number > 1000) return \"\"\
    ;\n    string romans = \"ivxlcdm\";\n    int digits = (int)floor(log10(number));\n\
    \    string result = \"\";\n    for (int digit = digits; digit >= 0; digit--)\n\
    \    {\n        int power = (int)pow(10, digit);\n        int digit_value = number\
    \ / power;\n        number -= digit_value * power;\n        if (digit_value ==\
    \ 0) continue;\n        result ~= get_roman_for_digit(digit_value, romans[digit\
    \ * 2]);\n    }\n    return result;\n}", "{\n    static string roman_chars = \"\
    ixcm\";\n    string result = \"\";\n    int j = 0;\n    while (number > 0)\n \
    \   {\n        auto repeat = min(number, 9);\n        number -= repeat;\n    \
    \    while (repeat > 0)\n        {\n            result += roman_chars[j];\n  \
    \          --repeat;\n        }\n        if (number > 0)\n        {\n        \
    \    auto roman_char = roman_chars[j];\n            auto ch = roman_char;\n  \
    \          if (number >= 5)\n            {\n                ch = toUpper(roman_char);\n\
    \                number -= 5;\n            }\n            else if (number >= 4)\n\
    \            {\n                ch = toUpper(roman_char);\n                --number;\n\
    \            }\n            else\n            {\n                ch = roman_char;\n\
    \                --number;\n            }\n            result += ch;\n       \
    \ }\n        ++j;\n    }\n    return result;\n}\n//Preferably use the following\
    \ version:\nstring int_to_mini_roman(long number) \n{\n    static string roman_chars\
    \ = \"ixcm\";\n    string result = \"\";\n    int j = 0;\n    while (number >\
    \ 0)\n    {\n        auto repeat = min(number, 9);\n        number -= repeat;\n\
    \        result ~= repeat.roman;\n        if (number > 0)\n        {\n       \
    \     auto roman_char = roman_chars[j];\n            auto ch = roman_char;\n \
    \           if (number >= 5)\n            {\n                ch = toUpper(roman_char);\n\
    \                number -= 5;\n            }\n            else if (number >= 4)\n\
    \            {\n                ch = toUpper(roman_char);\n                --number;\n\
    \            }\n            else\n            {\n                ch = roman_char;\n\
    \                --number;\n            }\n            result ~= ch;\n       \
    \ }\n        ++j;\n    }\n    return result;\n}", "{\n    import std.typecons\
    \ : tuple;\n    import std.math : ceil;\n    import std.conv : to;\n    import\
    \ std.range : iota;\n    import std.algorithm : join;\n    import std.array :\
    \ array;\n    import std.array : split;\n    import std.algorithm : fill;\n  \
    \  import std.range : retro;\n    import std.array : each;\n    import std.string\
    \ : toLower, toUpper;\n    import std.traits : isSomeString;\n    import std.typecons\
    \ : tuple;\n    import std.conv : to;\n    import std.math : round;\n    import\
    \ std.algorithm : map;\n    import std.algorithm : find;\n    import std.regex\
    \ : matches;\n    import std.meta : AliasSeq;\n    import std.meta : AliasSeq;\n\
    \    import std.meta : AliasSeq;\n    import std.meta : AliasSeq;\n    import\
    \ std.meta : AliasSeq;\n    import std.meta : AliasSeq;\n    import std.meta :\
    \ AliasSeq;\n    import std.meta : AliasSeq;\n    import std.meta : AliasSeq;\n\
    \    import std.meta : AliasSeq;\n    import std.meta : AliasSeq;\n    import\
    \ std.meta : AliasSeq;\n    import std.meta : AliasSeq;\n    import std.meta :\
    \ AliasSeq;\n    import std.meta : AliasSeq;\n    import std.meta : AliasSeq;\n\
    \    import std.meta : AliasSeq;\n    import std.meta : AliasSeq;\n    import\
    \ std.meta : AliasSeq;\n    import std.meta : AliasSeq;\n    import std.meta :\
    \ AliasSeq;\n    import std.meta : AliasSeq;\n    import std.meta : AliasSeq;\n\
    \    import std.meta : AliasSeq;\n    import std.meta : AliasSeq;\n    import\
    \ std.meta : AliasSeq;\n    import std.meta : AliasSeq;\n    import std.meta :",
  "{\n    const int[] romans = [1, 5, 10, 50, 100, 500, 1000];\n    const char[] roman_chars\
    \ = [\n        'i', 'v', 'x', 'l', 'c', 'd', 'm'\n    ];\n    enum RomanType {\n\
    \        I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n    }\n    alias RomanTypeTuple\
    \ = Tuple!(RomanType, char, int);\n    static RomanTypeTuple[] romanTypes = [\n\
    \        tuple(RomanType.I, 'i', 1),\n        tuple(RomanType.IV, 'i', 4),\n \
    \       tuple(RomanType.V, 'v', 5),\n        tuple(RomanType.IX, 'i', 9),\n  \
    \      tuple(RomanType.X, 'x', 10),\n        tuple(RomanType.XL, 'x', 40),\n \
    \       tuple(RomanType.L, 'l', 50),\n        tuple(RomanType.XC, 'x', 90),\n\
    \        tuple(RomanType.C, 'c', 100),\n        tuple(RomanType.CD, 'c', 400),\n\
    \        tuple(RomanType.D, 'd', 500),\n        tuple(RomanType.CM, 'c', 900),\n\
    \        tuple(RomanType.M, 'm', 1000)\n    ];\n    enum RomanType[] romans =\
    \ [\n        RomanType.I, RomanType.IV, RomanType.V,\n        RomanType.IX, RomanType.X,\
    \ RomanType.XL,\n        RomanType.L, RomanType.XC, RomanType.C,\n        RomanType.CD,\
    \ RomanType.D, RomanType.CM,\n        RomanType.M\n    ];\n    int[] roman_values\
    \ = [\n        1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000\n    ];\n\
    \    string roman_chars = \"i,v,x,l,c,d,m\";\n    static int getRomanTypeIndex(char\
    \ romanChar) {\n        return roman_chars.indexOf(romanChar);\n    }\n    //static\
    \ RomanTypeTuple get", "{\n    static char[4] roman = ['i', 'v', 'x', 'l'];\n\
    \    assert(number > 0 && number <= 1000);\n    if (number < 10)\n        return\
    \ roman[0 .. number];\n    else if (number < 100)\n        return roman[2 .. number\
    \ / 10] ~\n               roman[0 .. number % 10];\n    else if (number < 1000)\n\
    \        return roman[4 .. number / 100] ~\n               roman[2 .. number %\
    \ 100 / 10] ~\n               roman[0 .. number % 10];\n    else\n        return\
    \ \"m\" ~\n               roman[4 .. number % 1000 / 100] ~\n               roman[2\
    \ .. number % 100 / 10] ~\n               roman[0 .. number % 10];\n}\n/*", "{\n\
    \    enum symbols = \"ixcm\";\n    string result;\n    for (size_t i = 0; i <\
    \ 4; i++) {\n        auto digit = number % 10;\n        auto symbol = symbols[3\
    \ - i];\n        if (digit == 9) {\n            result = symbol ~ \"v\" ~ result;\n\
    \        } else if (digit >= 5) {\n            result = \"v\" ~ (symbol * (digit\
    \ - 5)) ~ result;\n        } else if (digit == 4) {\n            result = symbol\
    \ ~ \"v\" ~ result;\n        } else {\n            result = symbol * digit ~ result;\n\
    \        }\n        number /= 10;\n    }\n    return result;\n}", "{\n    static\
    \ char [][] digit_to_mini_roman = [\n        ['i', 'v'],\n        ['x', 'l'],\n\
    \        ['c', 'd'],\n        ['m']\n    ];\n    static int [] bases = [1, 10,\
    \ 100, 1000];\n    string ret;\n    foreach(digit; 0 .. 4) {\n        int base\
    \ = bases[$-1];\n        if (number >= base) {\n            int digit_value =\
    \ cast(int)(number / base);\n            number %= base;\n            if (digit_value\
    \ < 4) {\n                ret ~= repeat(digit_to_mini_roman[digit][0], digit_value);\n\
    \            } else if (digit_value == 4) {\n                ret ~= format(\"\
    %s%s\", digit_to_mini_roman[digit][0], digit_to_mini_roman[digit][1]);\n     \
    \       } else if (digit_value == 5) {\n                ret ~= digit_to_mini_roman[digit][1];\n\
    \            } else if (digit_value < 9) {\n                ret ~= format(\"%s%s\"\
    , digit_to_mini_roman[digit][1], repeat(digit_to_mini_roman[digit][0], digit_value\
    \ - 5));\n            } else {\n                ret ~= format(\"%s%s\", digit_to_mini_roman[digit][0],\
    \ digit_to_mini_roman[digit + 1][0]);\n            }\n        }\n    }\n    return\
    \ ret;\n}\n \nstring int_to_mini_roman_2(long num)\n{\n    static char [][] digit_to_mini_roman\
    \ = [\n        ['i', 'v'],\n        ['x', 'l'],\n        ['c', 'd'],\n       \
    \ ['m']\n    ];\n    string str;\n    for (int i = 0; i < 4; i++) {\n        long\
    \ power = cast(long)(pow(10, i));\n        long digit = num / power;\n       \
    \ if (digit >= 1 && digit <= 9) {\n            if (digit == 9) {\n           \
    \     str ~= format(\"%s%s\", digit_to_mini", "{\n    return roman(number).to!string.toLower();\n\
    }", "{\n    if(number == 0)\n    {\n        return \"\";\n    }\n    int[] numeral\
    \ = [1, 5, 10, 50, 100, 500, 1000];\n    string[] symbol = [\"i\", \"v\", \"x\"\
    , \"l\", \"c\", \"d\", \"m\"];\n    int[] div = [1, 10, 100, 1000];\n    int limit\
    \ = numeral.length - 1;\n    string result = \"\";\n    int i = 0;\n    while(number\
    \ > 0)\n    {\n        if(number >= numeral[limit])\n        {\n            int\
    \ max = numeral[limit];\n            int digit = number / max;\n            int\
    \ j = digit;\n            if(j == 9)\n            {\n                result ~=\
    \ symbol[limit - 2];\n                result ~= symbol[limit];\n             \
    \   number -= 9 * max;\n            }\n            else if(j == 4)\n         \
    \   {\n                result ~= symbol[limit - 2];\n                result ~=\
    \ symbol[limit - 1];\n                number -= 4 * max;\n            }\n    \
    \        else\n            {\n                while(j > 0)\n                {\n\
    \                    result ~= symbol[limit - 2];\n                    j--;\n\
    \                }\n                number -= digit * max;\n            }\n  \
    \      }\n        else\n        {\n            limit -= 2;\n        }\n    }\n\
    \    return result;\n}", "{\n    static string numbers[] = [\"\", \"i\", \"ii\"\
    , \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static string\
    \ tens[] = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\"];\n    static string hundreds[] = [\"\", \"c\", \"cc\", \"ccc\", \"cd\"\
    , \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string thousands[] =\
    \ [\"\", \"m\", \"mm\", \"mmm\"];\n    return thousands[div(number, 1000)] ~\n\
    \    hundreds[div(number, 100) % 10] ~\n    tens[div(number, 10) % 10] ~\n   \
    \ numbers[number % 10];\n}", "{\n    import std.conv : to;\n    import std.array\
    \ : replicate;\n    import std.algorithm : each;\n    import std.range : iota;\n\
    \    import std.range : cycle;\n    import std.range : lockstep;\n    import std.range\
    \ : retro;\n    import std.range : drop;\n    import std.range : take;\n    import\
    \ std.range : transform;\n    import std.string : format;\n    import std.math\
    \ : logBase;\n    import std.math : clamp;\n    import std.typecons : tuple;\n\
    \    import std.traits : isIntegral;\n    import std.meta : AliasSeq;\n    import\
    \ std.meta : AliasSeqOf;\n    enum roman = tuple(\n        tuple(\"\", \"i\",\
    \ \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"),\n      \
    \  tuple(\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\"),\n        tuple(\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\"\
    , \"dcc\", \"dccc\", \"cm\"),\n        tuple(\"\", \"m\", \"mm\", \"mmm\")\n \
    \   );\n    enum StringSeq = AliasSeq!(tuple(roman));\n    enum StringElement\
    \ = AliasSeqOf!(StringSeq);\n    static assert(isIntegral!number);\n    static\
    \ assert(1 <= number <= 1000);\n    return format(\"%s\",\n        take(3,\n \
    \           iota(\n                logBase(10, (clamp(number, 1, 3999)))\n   \
    \         )\n        )\n        .map!((a) => number / cast(long)(10_pow(a)) %\
    \ 10)\n        .cycle\n        .lockstep!((a, b) => roman[b][a])\n        .drop(3)\n\
    \        .reverse\n        .join\n    );\n}", "{\n    const lookup = [\"m\", \"\
    cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\"\
    , \"i\"];\n    const values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5,\
    \ 4, 1];\n    auto result = \"\";\n    foreach(var i, var l; zip(values, lookup))\n\
    \    {\n        auto count = number / i;\n        result ~= repeat(l, count);\n\
    \        number -= count * i;\n    }\n    return result;\n}", "{\n    // TODO:\
    \ Implement me.\n    return null;\n}", "{\n    static string[8] const units =\
    \ \n        [\"i\", \"x\", \"c\", \"m\", \"ix\", \"xl\", \"xc\", \"cd\"];\n  \
    \  static int[8] const values = \n        [1, 10, 100, 1000, 9, 40, 90, 400];\n\
    \    long[] digits = (number /& values).map!(to!long).array;\n    string roman\
    \ = reduce!(\"a+b\")(zip(digits, units))\n        .filter!(a => a[0] != 0)\n \
    \       .map!(a => a[0] * a[1])\n        .array;\n    return roman;\n}", "{\n\
    \    // Create a container that will have a key for every possible roman numeral\n\
    \    string[long] romans = [\n        // If num is 0, return empty string\n  \
    \      0:'',\n        // Create a key for every possible roman numeral\n     \
    \   // This way, we can just loop over romans[num]\n        1:'i',\n        2:'ii',\n\
    \        3:'iii',\n        4:'iv',\n        5:'v',\n        6:'vi',\n        7:'vii',\n\
    \        8:'viii',\n        9:'ix',\n        10:'x',\n        20:'xx',\n     \
    \   30:'xxx',\n        40:'xl',\n        50:'l',\n        60:'lx',\n        70:'lxx',\n\
    \        80:'lxxx',\n        90:'xc',\n        100:'c',\n        200:'cc',\n \
    \       300:'ccc',\n        400:'cd',\n        500:'d',\n        600:'dc',\n \
    \       700:'dcc',\n        800:'dccc',\n        900:'cm',\n        1000:'m',\n\
    \        2000:'mm',\n        3000:'mmm',\n        4000:'mv',\n        5000:'v',\n\
    \        6000:'vm',\n        7000:'vmm',\n        8000:'vmmm',\n        9000:'mx',\n\
    \        10000:'x',\n        20000:'xx',\n        30000:'xxx',\n        40000:'xl',\n\
    \        50000:'l',\n        60000:'lx',\n        70000:'lxx',\n        80000:'lxxx',\n\
    \        90000:'xc',\n        100000:'c',\n        200000:'cc',\n        300000:'ccc',\n\
    \        400000:'cd',\n        500000:'d',\n        600000:'dc',\n        700000:'dcc',\n\
    \        800000:'dccc',\n        900000:'cm',\n        1000000:'m',\n        2000000:'mm',\n\
    \        3000000:'mmm',\n        4000000:'mv',\n        5000000:'v',\n       \
    \ 6000000:'vm',\n        7000000:'vmm',\n        8000000:'vmmm',\n        9000000:'mx',\n\
    \        10000000:'x',\n       ", "{\n    if (number <= 0)\n        return \"\"\
    ;\n    \n    int digit = (int)log10(number) + 1;\n    int first = number / ((int)pow(10,\
    \ digit - 1));\n    int other = number % ((int)pow(10, digit - 1));\n    \n  \
    \  string result = int_to_mini_roman(other);\n    \n    switch (digit) {\n   \
    \     case 1:\n            if (first < 4)\n                result = \"i\" * first\
    \ + result;\n            else if (first == 4)\n                result = \"iv\"\
    \ + result;\n            else if (first == 5)\n                result = \"v\"\
    \ + result;\n            else if (first < 9)\n                result = \"v\" +\
    \ (\"i\" * (first - 5)) + result;\n            else\n                result =\
    \ \"ix\" + result;\n            break;\n        case 2:\n            if (first\
    \ < 4)\n                result = \"x\" * first + result;\n            else if\
    \ (first == 4)\n                result = \"xl\" + result;\n            else if\
    \ (first == 5)\n                result = \"l\" + result;\n            else if\
    \ (first < 9)\n                result = \"l\" + (\"x\" * (first - 5)) + result;\n\
    \            else\n                result = \"xc\" + result;\n            break;\n\
    \        case 3:\n            if (first < 4)\n                result = \"c\" *\
    \ first + result;\n            else if (first == 4)\n                result =\
    \ \"cd\" + result;\n            else if (first == 5)\n                result =\
    \ \"d\" + result;\n            else if (first < 9)\n                result = \"\
    d\" + (\"c\" * (first - 5)) + result;\n            else\n                result\
    \ = \"cm\" + result;\n            break;\n        case 4:\n            result\
    \ = \"m\" * first + result;\n            break;\n    }\n    \n    return result;\n\
    }"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
