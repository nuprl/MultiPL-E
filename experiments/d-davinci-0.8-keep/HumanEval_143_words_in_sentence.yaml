name: HumanEval_143_words_in_sentence
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a string\
  \ representing a sentence,\n    the sentence contains some words separated by a\
  \ space,\n    and you have to return a string that contains the words from the original\
  \ sentence,\n    whose lengths are prime numbers,\n    the order of the words in\
  \ the new string should be the same as the original one.\n\n    Example 1:\n   \
  \     Input: sentence = \"This is a test\"\n        Output: \"is\"\n\n    Example\
  \ 2:\n        Input: sentence = \"lets go for swimming\"\n        Output: \"go for\"\
  \n\n    Constraints:\n        * 1 <= len(sentence) <= 100\n        * sentence contains\
  \ only letters\n    \n*/\nstring words_in_sentence(string sentence) \n"
tests: "unittest\n{\n    alias candidate = words_in_sentence;\n\n    assert(candidate(\"\
  This is a test\") == \"is\");\n    assert(candidate(\"lets go for swimming\") ==\
  \ \"go for\");\n    assert(candidate(\"there is no place available here\") == \"\
  there is no place\");\n    assert(candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\
  );\n    assert(candidate(\"go for it\") == \"go for it\");\n    assert(candidate(\"\
  here\") == \"\");\n    assert(candidate(\"here is\") == \"is\");\n}\nvoid main(){}"
completions: ["{\n    import std.algorithm : filter,map;\n    import std.math : isPrime;\n\
    \    auto words = split(sentence);\n    return to!string(words.filter!(w => w.length.isPrime).map!(w\
    \ => w ~ \" \"));\n}", "{\n    string res;\n    string[] words = split(sentence);\n\
    \    foreach(string word; words)\n    {\n        if(isPrime(word.length))\n  \
    \      {\n            res ~= word ~ \" \";\n        }\n    }\n    return res.trimRight();\n\
    }", "{\n    import std.range;\n    import std.algorithm;\n    import std.conv;\n\
    \    import std.array;\n    import std.stdio;\n    import std.range;\n    import\
    \ std.algorithm;\n    import std.string;\n    return sentence.split(\" \").filter!(a\
    \ => isPrime(a.length)).joiner(\" \");\n}", "{\n    immutable \n    all_primes\
    \ =\n    [\n        2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97,\n        101, 103, 107, 109, 113, 127, 131,\
    \ 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199,\n    \
    \    211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283,\
    \ 293,\n        307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379,\
    \ 383, 389, 397,\n        401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461,\
    \ 463, 467, 479, 487, 491, 499,\n        503, 509, 521, 523, 541, 547, 557, 563,\
    \ 569, 571, 577, 587, 593, 599,\n        601, 607, 613, 617, 619, 631, 641, 643,\
    \ 647, 653, 659, 661, 673, 677, 683, 691,\n        701, 709, 719, 727, 733, 739,\
    \ 743, 751, 757, 761, 769, 773, 787, 797,\n        809, 811, 821, 823, 827, 829,\
    \ 839, 853, 857, 859, 863, 877, 881, 883, 887,\n        907, 911, 919, 929, 937,\
    \ 941, 947, 953, 967, 971, 977, 983, 991, 997\n    ];\n    \n    return joiner!(\"\
    \ \")(\n        sentence.split(\" \")\n            .filter!(a => all_primes.canFind(a.length))\n\
    \            .map!(a => a)\n    );\n}", "{\n    string[] words = sentence.split(\"\
    \ \");\n    string result = \"\";\n    foreach(word; words) {\n        if(word.length.isPrime)\
    \ {\n            result ~= word ~ \" \";\n        }\n    }\n    return result.stripRight;\n\
    }", "{\n    import std.algorithm : filter, map;\n    import std.range : take,\
    \ takeWhile;\n    import std.math : isPrime;\n    static auto primes = takeWhile!(isPrime)(iota(2));\n\
    \    return sentence.split\n    (\n        ' '\n    )\n    .filter!(x => x.length.isPrime)\n\
    \    .join(\" \");\n}", "{\n    string[] words = sentence.split(\" \");\n    auto\
    \ is_prime = [](size_t x) {\n        for (size_t d = 2; d <= sqrt(x); d++) {\n\
    \            if (x % d == 0) {\n                return false;\n            }\n\
    \        }\n        return true;\n    };\n    string res = \"\";\n    foreach\
    \ (i, word; words) {\n        if (is_prime(word.length)) {\n            res ~=\
    \ word ~ \" \";\n        }\n    }\n    return res.rstrip();\n}", "{\n    string[]\
    \ words = sentence.split;\n    string result = \"\";\n    for (int i = 0; i <\
    \ words.length; i++)\n    {\n        if (isPrime(words[i].length))\n        {\n\
    \            result ~= words[i] ~= \" \";\n        }\n    }\n    return result.stripRight;\n\
    }", "{\n    auto words = split(sentence);\n    auto is_prime = (int val) => {\n\
    \        if (val <= 1) return false;\n        else if (val == 2) return true;\n\
    \        else if (val % 2 == 0) return false;\n        else\n        {\n     \
    \       for (int i = 3; i <= val/2; i+=2)\n            {\n                if (val\
    \ % i == 0) return false;\n            }\n            return true;\n        }\n\
    \    };\n    auto new_words = words.filter!(word => is_prime(word.length));\n\
    \    return join(new_words);\n}", "{\n    immutable char[] delimiters = [ ' ',\
    \ '\\n', '\\t' ];\n    immutable words = split(sentence, delimiters);\n    immutable\
    \ primes = [ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61,\
    \ 67, 71, 73, 79, 83, 89, 97 ];\n    // map from char to index of primes array\n\
    \    immutable asciiToPrimeIdx = [ asciiToPrimeIdx[char.min .. char.max]\n   \
    \     .assign(iota(char.min, char.max).map!(c => \n            primes.canFind(p\
    \ => p == c.to!int) ? primes.indexOf(c.to!int) : -1\n        )\n    ) ];\n   \
    \ immutable primeLengths = words.map!(w => \n        w.sum!(c => \n          \
    \  asciiToPrimeIdx[c] >= 0 ? 1 : 0\n        )\n    );\n    string result = \"\"\
    ;\n    foreach(index, word; words)\n    {\n        if(primeLengths[index] > 0)\n\
    \        {\n            result ~= \" \" ~ word;\n        }\n    }\n    return\
    \ result.trim;\n}", "{\n    auto res = split(sentence);\n    string result = \"\
    \";\n    foreach(i,n; res)\n    {\n        if(isPrime(n.length))\n        {\n\
    \            result ~= n ~ \" \";\n        }\n    }\n    return result;\n}", "{\n\
    \    enum isPrime(int n) pure nothrow \n    {\n        if (n < 2) \n         \
    \   return false;\n        if (n == 2) \n            return true;\n        if\
    \ (n % 2 == 0) \n            return false;\n        for (int d = 3; d <= sqrt(n);\
    \ d += 2) \n            if (n % d == 0) \n                return false;\n    \
    \    return true;\n    }\n    import std.algorithm : map, filter, joiner;\n  \
    \  auto words = sentence.split(\" \");\n    string res = words.filter!(a => isPrime(a.length)).map!(a\
    \ => a ~ \" \").joiner.to!string;\n    return res[0 .. $ - 1];\n}", "{\n    string\
    \ [] words = sentence.split(\" \");\n    string result = \"\";\n    foreach(w;\
    \ words)\n    {\n        if(isPrime(w.length))\n        {\n            result\
    \ ~= w ~ \" \";\n        }\n    }\n    return result.stripRight;\n}", "{\n   \
    \ import std.string;\n    import std.algorithm;\n    import std.math;\n    import\
    \ std.array;\n    auto words = sentence.split(\" \");\n    return words.filter!(x\
    \ => isPrime(x.length)).join(\" \");\n}", "{\n    string[] words = split(sentence);\n\
    \    string newSentence = \"\";\n    foreach(string word; words)\n    {\n    \
    \    if(isPrime(word.length))\n        {\n            newSentence ~= word ~ \"\
    \ \";\n        }\n    }\n    return newSentence.trim();\n}", "{\n    string[]\
    \ words = sentence.split(\" \");\n    string result = \"\";\n    foreach(word;\
    \ words)\n    {\n        if(isPrime(word.length))\n        {\n            result\
    \ ~= word ~ \" \";\n        }\n    }\n    return result.stripRight;\n}", "{\n\
    \    string result = \"\";\n    string[] words = sentence.split();\n    foreach(word;\
    \ words)\n    {\n        if(isPrime(word.length))\n        {\n            result\
    \ ~= \" \" ~ word;\n        }\n    }\n    return result.stripLeft;\n}", "{\n \
    \   bool [] primes = new bool[100];\n    bool [] sieve = new bool[100];\n    bool\
    \ [] visited = new bool[100];\n    for (int i = 0; i < 100; i++)\n    {\n    \
    \    primes[i] = true;\n        sieve[i] = true;\n        visited[i] = false;\n\
    \    }\n    for (int i = 2; i < 100; i++)\n    {\n        if (sieve[i])\n    \
    \    {\n            for (int j = i*i; j < 100; j += i)\n            {\n      \
    \          sieve[j] = false;\n            }\n        }\n    }\n    foreach (string\
    \ word; sentence.split(\" \"))\n    {\n        int len = word.length;\n      \
    \  if (len > 1)\n        {\n            primes[len] = false;\n        }\n    }\n\
    \    string result = \"\";\n    foreach (string word; sentence.split(\" \"))\n\
    \    {\n        int len = word.length;\n        if (primes[len] && !visited[len])\n\
    \        {\n            result += word + \" \";\n            visited[len] = true;\n\
    \        }\n    }\n    return result.trim();\n}", "{\n    string result = \"\"\
    ;\n    immutable is_prime = [true,true,false] ~ [true,false,false];\n    immutable\
    \ len = sentence.length;\n    foreach(i,substr;enumerate(split(sentence)))\n \
    \   {\n        immutable space = (i < len - 1 ? \" \" : \"\");\n        auto len\
    \ = substr.length;\n        if(len <= 3)\n        {\n            if(is_prime[len])\n\
    \            {\n                result ~= substr ~ space;\n            }\n   \
    \     }\n        else\n        {\n            foreach(j;2..(len/2 + 1))\n    \
    \        {\n                if(len % j == 0)\n                {\n            \
    \        goto next;\n                }\n            }\n            result ~= substr\
    \ ~ space;\n        }\n        next:\n        continue;\n    }\n    return result;\n\
    }", "{\n    string[] parts = split(sentence);\n    string result = \"\";\n   \
    \ foreach(w; parts)\n    {\n        if(isPrime(w.length))\n        {\n       \
    \     result ~= w ~ \" \";\n        }\n    }\n    return result.length ? result[0..$-1]\
    \ : result;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
