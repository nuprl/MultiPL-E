name: HumanEval_70_strange_sort_list
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
  \ return list in strange order.\n    Strange sorting, is when you start with the\
  \ minimum value,\n    then maximum of the remaining integers, then minimum and so\
  \ on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n  \
  \  strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) ==\
  \ []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n"
tests: "unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
  \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
  \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
  \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
  \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
  \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
  \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
  \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
  \ == [111111L]);\n}\nvoid main(){}"
completions: ["{\n    if (lst.length == 0) return [];\n    int result_size = 2 * lst.length;\n\
    \    long[] result = new long[result_size];\n    result[0] = std.algorithm.min(lst);\n\
    \    lst -= result[0];\n    result[1] = std.algorithm.max(lst);\n    lst -= result[1];\n\
    \    int index = 1;\n    while (lst.length > 0)\n    {\n        result[++index]\
    \ = std.algorithm.min(lst);\n        lst -= result[index];\n        result[++index]\
    \ = std.algorithm.max(lst);\n        lst -= result[index];\n    }\n    return\
    \ result;\n}\n/*\n    Your task is to create a function that does four basic mathematical\
    \ operations.", "{\n    auto min = min(lst);\n    auto max = max(lst);\n    auto\
    \ step = lst.length % 2 ? 1 : -1;\n    auto result = appender!(long[])();\n  \
    \  foreach(i; 0 .. lst.length)\n    {\n        if(step > 0)\n        {\n     \
    \       result.put(min);\n            min = min(lst[min .. $]);\n        }\n \
    \       else\n        {\n            result.put(max);\n            max = max(lst[max\
    \ .. $]);\n        }\n        step *= -1;\n    }\n    return result.data;\n}",
  "{\n    if (lst.length == 0)\n        return new long[0];\n    \n    auto nlst =\
    \ lst.dup;\n    auto res = new long[lst.length];\n    size_t cnt = nlst.length;\n\
    \    size_t restr = 0;\n    size_t restl = nlst.length - 1;\n    int inc = 1;\n\
    \    while (cnt > 0)\n    {\n        auto m = nlst[restr..restl].min;\n      \
    \  res[restr] = m;\n        nlst = nlst.filter!(a => a != m);\n        if (inc\
    \ > 0)\n        {\n            restr++;\n            inc = -1;\n        }\n  \
    \      else\n        {\n            restl--;\n            inc = 1;\n        }\n\
    \        cnt--;\n    }\n    return res;\n}\n ", "{\n    auto sorted_lst = sort(lst);\n\
    \    auto odd = sorted_lst[0 .. $/2 + 1];\n    auto even = sorted_lst[$/2 + 1\
    \ .. $];\n    long[] result;\n    foreach(i, n; enumerate(odd)) {\n        if\
    \ (i % 2 == 0) {\n            result ~= n;\n        } else {\n            result\
    \ ~= even.popBack();\n        }\n    }\n    return result;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    bool isMax = false;\n    alias L = lst.dup;\n\
    \    lst = [];\n    auto cmp = isMax ? (a, b) => a >= b : (a, b) => a <= b;\n\
    \    while (L.length > 0)\n    {\n        bool isFirst = true;\n        long minMax\
    \ = L[0];\n        long minMaxIndex = 0;\n        foreach (i, e; L)\n        {\n\
    \            if (isFirst)\n            {\n                isFirst = false;\n \
    \               minMax = e;\n                minMaxIndex = i;\n            }\n\
    \            else if (cmp(e, minMax))\n            {\n                minMax =\
    \ e;\n                minMaxIndex = i;\n            }\n        }\n        lst\
    \ ~= minMax;\n        L = L[0..minMaxIndex] ~ L[minMaxIndex + 1..$];\n       \
    \ isMax = !isMax;\n    }\n    return lst;\n}", "{\n    lst = lst.dup;\n    immutable\
    \ int len = lst.length;\n    if (len < 1) \n        return lst;\n    else if (len\
    \ < 2) \n        return lst[0 .. 1];\n    else if (len == 2) \n        return\
    \ lst[0] < lst[1] ? lst : lst[1, 0];\n    else \n    {\n        int newlen = 2;\n\
    \        for (long i = 2; i < len; i += 2) \n            newlen += 2;\n      \
    \  long[] res = new long[newlen];\n        long[] tmp = lst[0 .. 2];\n       \
    \ tmp.sort;\n        res[0] = tmp[0];\n        res[1] = tmp[2];\n        immutable\
    \ tuple!(long, long) minmax = minmax(lst[2 .. $]);\n        bool ascend = true;\n\
    \        res[2] = minmax[ascend ? 0 : 1];\n        bool ascend = !ascend;\n  \
    \      int idx = 3;\n        for (long i = 3; i < len; i += 2) \n        {\n \
    \           immutable tuple!(long, long) minmax = minmax(lst[i .. $]);\n     \
    \       res[idx] = minmax[ascend ? 0 : 1];\n            idx++;\n            bool\
    \ ascend = !ascend;\n            res[idx] = minmax[ascend ? 0 : 1];\n        \
    \    idx++;\n        }\n        return res;\n    }\n}", "{\n    if (lst.length\
    \ == 0) return [];\n    lst.sort();\n    auto lst2 = lst.dup;\n    lst2.reverse;\n\
    \    return lst[].zip(lst2[]).expand;\n}", "{\n    if (lst.length == 0) \n   \
    \     return lst;\n    long max = lst[0];\n    long min = lst[0];\n    long[]\
    \ res = new long[lst.length];\n    foreach (x; lst)\n    {\n        if (x > max)\n\
    \            max = x;\n        if (x < min)\n            min = x;\n    }\n   \
    \ lst = lst.retro();\n    res[0] = min;\n    res[1] = max;\n    bool is_min =\
    \ false;\n    for (int i = 2; i < lst.length; i++)\n    {\n        if (is_min)\n\
    \        {\n            min = lst[0];\n            foreach (x; lst)\n        \
    \    {\n                if (x < min)\n                    min = x;\n         \
    \   }\n            res[i] = min;\n            lst = lst.retro();\n           \
    \ is_min = false;\n        }\n        else\n        {\n            max = lst[0];\n\
    \            foreach (x; lst)\n            {\n                if (x > max)\n \
    \                   max = x;\n            }\n            res[i] = max;\n     \
    \       lst = lst.retro();\n            is_min = true;\n        }\n    }\n   \
    \ return res;\n}", "{\n    if (lst.length == 0) return [];\n    lst.sort!((a,\
    \ b) => a - b);\n    auto ret = new long[lst.length];\n    auto up = true;\n \
    \   for (uint i = 0; i < lst.length; i++)\n    {\n        ret[i] = up ? lst[i]\
    \ : lst[lst.length - i - 1];\n        up = !up;\n    }\n    return ret;\n}", "{\n\
    \    if (lst.length == 0) \n        return lst;\n    auto min = lst[0];\n    foreach\
    \ (i; lst)\n        min = min(min, i);\n    lst = lst.filter!(a => a != min);\n\
    \    long[] ret;\n    ret ~= min;\n    while (lst.length != 0)\n    {\n      \
    \  auto max = lst[0];\n        foreach (i; lst)\n            max = max(max, i);\n\
    \        lst = lst.filter!(a => a != max);\n        ret ~= max;\n        auto\
    \ min = lst[0];\n        foreach (i; lst)\n            min = min(min, i);\n  \
    \      lst = lst.filter!(a => a != min);\n        ret ~= min;\n    }\n    return\
    \ ret;\n}", "{\n    if (lst.length == 0) return lst;\n    long max = lst[0];\n\
    \    long min = lst[0];\n    long[] lst_max = new long[];\n    long[] lst_min\
    \ = new long[];\n    lst_max.length = lst.length;\n    lst_min.length = lst.length;\n\
    \    for (size_t i = 0; i < lst.length; i++)\n    {\n        if (lst[i] > max)\
    \ max = lst[i];\n        if (lst[i] < min) min = lst[i];\n    }\n    long delta\
    \ = max - min;\n    size_t i = 0;\n    while (delta != 0)\n    {\n        lst_max[i]\
    \ = max;\n        lst_min[i] = min;\n        delta--;\n        i++;\n    }\n \
    \   lst_max[i] = max;\n    lst_min[i] = min;\n    size_t n = lst.length / 2;\n\
    \    size_t l = 0;\n    size_t r = lst.length - 1;\n    lst.length = lst.length\
    \ + 1;\n    for (size_t i = 0; i < n; i++)\n    {\n        lst[l] = lst_min[i];\n\
    \        lst[r] = lst_max[i];\n        l += 2;\n        r -= 2;\n    }\n    lst[l]\
    \ = lst_min[n];\n    return lst;\n}", "{\n    long[] new_list = lst[];\n    bool\
    \ odd = true;\n    for (int i = 0; i < lst.length; i++)\n    {\n        long min\
    \ = new_list[0];\n        int min_index = 0;\n        long max = new_list[0];\n\
    \        int max_index = 0;\n        for (int j = 0; j < new_list.length; j++)\n\
    \        {\n            if (min > new_list[j])\n            {\n              \
    \  min = new_list[j];\n                min_index = j;\n            }\n       \
    \     if (max < new_list[j])\n            {\n                max = new_list[j];\n\
    \                max_index = j;\n            }\n        }\n        if (odd)\n\
    \        {\n            new_list[min_index] = -1;\n            lst[i] = min;\n\
    \        }\n        else\n        {\n            new_list[max_index] = -1;\n \
    \           lst[i] = max;\n        }\n        odd = !odd;\n    }\n    return lst;\n\
    }", "{\n    long[] res = new long[lst.length];\n    bool asc = true;\n    long\
    \ i = 0;\n    while(lst.length > 0)\n    {\n        if(asc)\n        {\n     \
    \       res[i] = lst.front;\n            lst.remove(lst.front);\n        }\n \
    \       else\n        {\n            res[i] = lst.back;\n            lst.remove(lst.back);\n\
    \        }\n        i++;\n        asc = !asc;\n    }\n    return res;\n}", "{\n\
    \    if (lst.length == 0)\n        return lst;\n    alias Ind = long;\n    alias\
    \ Val = long;\n    auto minVal = min(lst);\n    auto maxVal = max(lst);\n    auto\
    \ minValInd = lst.indexOf(minVal);\n    auto maxValInd = lst.indexOf(maxVal);\n\
    \    long[Val][Ind] inds = lst.indexed;\n    immutable Ind[Val] sortedInds = inds.values;\n\
    \    immutable Ind[Val] minInds = sortedInds.takeExactly(minValInd + 1);\n   \
    \ immutable Ind[Val] maxInds = sortedInds.dropExactly(minValInd + 1);\n    immutable\
    \ Ind[] minToMax;\n    immutable Ind[] maxToMin;\n    foreach (Ind i; minInds)\n\
    \        minToMax ~= i;\n    foreach (Ind i; maxInds)\n        maxToMin ~= i;\n\
    \    maxToMin.reverse;\n    immutable Ind[] res;\n    long i = 0;\n    while (true)\n\
    \    {\n        if (i < minToMax.length)\n            res ~= minToMax[i];\n  \
    \      else\n            break;\n        if (i < maxToMin.length)\n          \
    \  res ~= maxToMin[i];\n        else\n            break;\n        i++;\n    }\n\
    \    return lst[res];\n}", "{\n    alias Pair = Tuple!(long, long);\n    alias\
    \ IndexedValue = Tuple!(size_t, long);\n    alias Comparator = int delegate(IndexedValue,\
    \ IndexedValue);\n    alias MaxComparator = Comparator function(Comparator);\n\
    \    alias MinComparator = Comparator function(Comparator);\n    auto compare_indexed_value\
    \ = (Comparator)(IndexedValue a, IndexedValue b) => a[1] < b[1] ? -1 : 1;\n  \
    \  auto max_indexed_value = (MaxComparator)(Comparator cmp) => (IndexedValue a,\
    \ IndexedValue b) => cmp(a, b) >= 0 ? a : b;\n    auto min_indexed_value = (MinComparator)(Comparator\
    \ cmp) => (IndexedValue a, IndexedValue b) => cmp(a, b) <= 0 ? a : b;\n    auto\
    \ index_values = lst.map!(t => IndexedValue(t.tupleof)).retro;\n    auto min_value\
    \ = min_indexed_value(compare_indexed_value)(index_values);\n    auto max_value\
    \ = max_indexed_value(compare_indexed_value)(index_values);\n    auto result =\
    \ new long[](lst.length);\n    long[] rest;\n    for (int i = 0; i < lst.length;\
    \ i += 2) {\n        if (i == 0) {\n            rest = lst[min_value[0] + 1 ..\
    \ $];\n            result[i] = min_value[1];\n        } else {\n            rest\
    \ = lst[0 .. max_value[0]] ~ lst[max_value[0] + 1 .. $];\n            result[i]\
    \ = max_value[1];\n        }\n        if (i + 1 == lst.length) {\n           \
    \ break;\n        }\n        min_value = min_indexed_value(compare_indexed_value)(rest.map!(t\
    \ => IndexedValue(t.tupleof)).retro);\n        max_value = max_indexed_value(compare_indexed_value)(rest.map!(t",
  "{\n    if (lst.length == 0)\n        return lst;\n    \n    long[] sorted = new\
    \ long[lst.length];\n    auto minmax = minmaxElement(lst);\n    auto minmax_iter\
    \ = minmax.max;\n    sorted[0] = *minmax.min;\n    sorted[sorted.length - 1] =\
    \ *minmax.max;\n    foreach (i; 1 .. lst.length - 1)\n    {\n        if (i % 2\
    \ == 0)\n        {\n            sorted[i] = *minmax_iter;\n            minmax_iter.popFront();\n\
    \        }\n        else\n        {\n            sorted[i] = *minmax_iter;\n \
    \           minmax_iter.popBack();\n        }\n    }\n    return sorted;\n}",
  "{\n    // TODO\n    if (lst.length == 0) {\n        return lst;\n    }\n    long\
    \ min = lst[0];\n    int index = 0;\n    foreach (long i; lst) {\n        if (i\
    \ < min) {\n            min = i;\n            index = lst.indexOf(i);\n      \
    \  }\n    }\n    lst.remove(index);\n    lst = lst.sort(std.functional.greater);\n\
    \    long max = lst[0];\n    lst.remove(0);\n    lst = lst.sort();\n    long min2\
    \ = lst[0];\n    lst.remove(0);\n    lst = lst.sort(std.functional.greater);\n\
    \    long max2 = lst[0];\n    return [min, max, min2, max2];\n}", "{\n    if (lst.length\
    \ == 0) \n        return [];\n    else if (lst.length == 1) \n        return lst;\n\
    \    else \n    {\n        long min = min(lst);\n        auto a = lst.filter!(x\
    \ => x != min).sort!((a, b) => a > b);\n        return concat([min], a);\n   \
    \ }\n}", "{\n    if (lst.length == 0)\n        return lst;\n    import std.algorithm\
    \ : sort;\n    auto l = lst.sort();\n    auto b = l.front;\n    auto e = l.back;\n\
    \    long[] new_lst;\n    new_lst ~= b;\n    while (b + 1 != e)\n    {\n     \
    \   new_lst ~= e;\n        b++;\n        new_lst ~= b;\n        e--;\n    }\n\
    \    if (b == e)\n        new_lst ~= b;\n    return new_lst;\n}", "{\n    if (lst.length\
    \ == 0) return [];\n    lst.sort();\n    bool swap = true;\n    long[] lst2 =\
    \ lst.dup;\n    long[] lst3 = [];\n    foreach(v; lst) {\n        if (swap) {\n\
    \            lst3 ~= lst2.front;\n            lst2 = lst2[1..$];\n        } else\
    \ {\n            lst3 ~= lst2.back;\n            lst2 = lst2[0..$-1];\n      \
    \  }\n        swap = !swap;\n    }\n    return lst3;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
