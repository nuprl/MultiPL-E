name: HumanEval_159_eat
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
  \ and you already have eaten a certain number of carrots,\n    but now you need\
  \ to eat more carrots to complete the day's meals.\n    you should return an array\
  \ of [ total number of eaten carrots after your meals,\n                       \
  \             the number of carrots left after your meals ]\n    if there are not\
  \ enough remaining carrots, you will eat all remaining carrots, but will still be\
  \ hungry.\n    \n    Example:\n    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9)\
  \ -> [12, 1]\n    * eat(1, 10, 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n \
  \   \n    Variables:\n    @number : integer\n        the number of carrots that\
  \ you have eaten.\n    @need : integer\n        the number of carrots that you need\
  \ to eat.\n    @remaining : integer\n        the number of remaining carrots thet\
  \ exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need\
  \ <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long\
  \ number, long need, long remaining) \n"
tests: "unittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L)\
  \ == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L,\
  \ 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n  \
  \  assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L)\
  \ == [5L, 0L]);\n}\nvoid main(){}"
completions: ["{\n    long x = min(remaining, need);\n    return [ number + x, remaining\
    \ - x ];\n}", "{\n    auto result = new long[2];\n    remaining += number;\n \
    \   result[0] = remaining;\n    result[1] = remaining >= need ? remaining - need\
    \ : 0;\n    return result;\n}", "{\n    if(remaining == 0) return new long[]{need,\
    \ 0};\n    else if(remaining >= need) return new long[]{need+number, remaining-need};\n\
    \    else return new long[]{need+number, 0};\n}", "{\n    if (number > 1000 ||\
    \ need > 1000 || remaining > 1000)\n        throw new RuntimeException(\"Constrains\
    \ are broken\");\n    return new long[]{number + need, remaining - need};\n}",
  "{\n    long left = remaining - (number + need);\n    long eaten = number + need;\n\
    \    if (left < 0)\n    {\n        eaten = eaten + left;\n        left = 0;\n\
    \    }\n    return [eaten, left];\n}", "{\n    return new long[] {min(number +\
    \ need, remaining), max(remaining - need, 0)};\n}", "{\n    // your code goes\
    \ here\n    return [ need + number, max(0, remaining - need) ];\n}", "{\n    //\
    \ Write your code here\n    return [min(need, remaining) + number, max(remaining\
    \ - need, 0)];\n}", "{\n    long result;\n    long left;\n    left = 0;\n    if\
    \ (number < need) {\n        if (need < remaining) {\n            result = number\
    \ + need;\n            left = remaining - need;\n        } else {\n          \
    \  result = number + remaining;\n            left = 0;\n        }\n    } else\
    \ {\n        left = remaining;\n        result = number;\n    }\n    return [result,\
    \ left];\n}", "{\n    if(need > remaining) return new long[]{number + remaining,\
    \ 0};\n    else return new long[]{number + need, remaining - need};\n}", "{\n\
    \    long[] r = [ 0, 0 ];\n    long res = (number + need);\n    if (res <= remaining)\n\
    \    {\n        r[0] = res;\n        r[1] = remaining - res;\n    }\n    else\n\
    \    {\n        r[0] = remaining;\n        r[1] = 0;\n    }\n    return r;\n}",
  "{\n    if (need > remaining)\n        return [remaining + number, 0];\n    else\n\
    \        return [number + need, remaining - need];\n}", "{\n    return [remaining\
    \ >= need ? number + need : number + remaining, remaining >= need ? remaining\
    \ - need : 0];\n}\n```", "{\n    long[] total = [number + min(need, remaining),\
    \ max(0, remaining - need)];\n    return total;\n}", "{\n    long[] result;\n\
    \    if (number >= 1000 || need >= 1000 || remaining >= 1000) {\n        throw\
    \ new IllegalArgumentException(\"Out of range\");\n    }\n    if (need == 0 ||\
    \ number == 0) {\n        throw new IllegalArgumentException(\"You're not hungry\"\
    );\n    }\n    if (remaining > 1000) {\n        throw new IllegalArgumentException(\"\
    Out of range\");\n    }\n    if (remaining < need) {\n        result = new long[2];\n\
    \        result[0] = number + remaining;\n        result[1] = 0;\n        return\
    \ result;\n    }\n    if (remaining >= need) {\n        result = new long[2];\n\
    \        result[0] = number + need;\n        result[1] = remaining - need;\n \
    \       return result;\n    }\n}", "{\n    return [min(number + remaining, need),\
    \ max(number + remaining - need, 0)];\n}", "{\n    long[] eaten = new long[2];\n\
    \    eaten[0] = number;\n    eaten[1] = 0;\n    if (number >= need) {\n      \
    \  eaten[0] = need;\n        eaten[1] = number - need;\n    } else {\n       \
    \ if (remaining + number >= need) {\n            eaten[0] = need;\n          \
    \  eaten[1] = remaining + number - need;\n        } else {\n            eaten[0]\
    \ = remaining + number;\n            eaten[1] = 0;\n        }\n    }\n    return\
    \ eaten;\n}", "{\n    return [ min(number + remaining, need), remaining - min(need\
    \ - number, remaining) ];\n}", "{\n    if (need == 0)\n        return [0, remaining];\n\
    \    if (need <= remaining)\n        return [number + need, remaining - need];\n\
    \    return [number + remaining, 0];\n}", "{\n    long[] rez = new long[2];\n\
    \    if(remaining < need) \n    {\n        rez[0] = number + remaining;\n    \
    \    rez[1] = 0;\n    }\n    else\n    {\n        rez[0] = number + need;\n  \
    \      rez[1] = remaining - need;\n    }\n    return rez;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
