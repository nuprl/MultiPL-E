name: HumanEval_79_decimal_to_binary
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\nYou will be given a number in\
  \ decimal form and your task is to convert it to\n    binary format. The function\
  \ should return a string, with each character representing a binary\n    number.\
  \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
  \ couple of characters 'db' at the beginning and at the end of the string.\n   \
  \ The extra characters are there to help with the format.\n\n    Examples:\n   \
  \ decimal_to_binary(15)   # returns \"db1111db\"\n    decimal_to_binary(32)   #\
  \ returns \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n"
tests: "unittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
  \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
  \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
completions: ["{\n    string ret;\n    foreach(i; 0 .. 8)\n    {\n        ret ~= decimal\
    \ % 2;\n        decimal /= 2;\n    }\n    ret = \"db\" ~ ret ~ \"db\";\n    return\
    \ ret;\n}", "{\n\timmutable int bs=8; // bitsize - 4\n\tlong tmp = 0;\n\tint neg=0;\n\
    \tchar[bs] str=0;\n\tif(decimal<0) {\n\t\tneg=1;\n\t\tdecimal*=-1;\n\t}\n\twhile(decimal)\
    \ {\n\t\ttmp=decimal%2;\n\t\tdecimal/=2;\n\t\tstr[bs-1]=(char)(tmp+'0');\n\t\t\
    bs--;\n\t}\n\tif(neg) {\n\t\tstr=str~'0';\n\t}\n\treturn \"db\"~str~\"db\";\n}",
  "{\n    auto is_negative = decimal < 0;\n    auto output = \"db\";\n    auto temp\
    \ = is_negative ? -decimal : decimal;\n    for (int i = 31; i >= 0; i--)\n   \
    \ {\n        if (temp & (1 << i))\n            output ~= \"1\";\n        else\n\
    \            output ~= \"0\";\n    }\n    return output ~ \"db\";\n}\n/*\nReturn\
    \ the number of occurences of each letter in the given string. The result will\
    \ be\n    returned as a dictionary.", "{\n    return \"db\" ~ integral_to_binary_string(decimal,\
    \ Unsigned) ~ \"db\";\n}", "{\n    auto bits = immutable([](){\n        long i\
    \ = 0;\n        auto bits = new string[0];\n        foreach(m;2..64)\n       \
    \ {\n            auto t = (2 ^ m) - 1;\n            if(t >= i)\n            {\n\
    \                //writeln(i, \" \", t);\n                append(bits, t);\n \
    \               i = t;\n            }\n        }\n        return bits;\n    })();\n\
    \    //writeln(bits);\n    int n = 0;\n    string result = \"db\";\n    while(decimal\
    \ != 0)\n    {\n        if(decimal >= bits[n])\n        {\n            result\
    \ ~= \"1\";\n            decimal -= bits[n];\n        }\n        else\n      \
    \  {\n            result ~= \"0\";\n        }\n        ++n;\n    }\n    while(result.length\
    \ < n + 2)\n    {\n        result ~= \"0\";\n    }\n    result ~= \"db\";\n  \
    \  return result;\n}", "{\n    string result = \"db\";\n    int remainder = 0;\n\
    \    while(decimal > 0)\n    {\n        remainder = decimal % 2;\n        if(remainder\
    \ == 0)\n        {\n            result = \"0\" ~ result;\n        }\n        else\n\
    \        {\n            result = \"1\" ~ result;\n        }\n        decimal =\
    \ decimal / 2;\n    }\n    result = result ~ \"db\";\n    return result;\n}\n\
    string decimal_to_binary2(long decimal) \n{\n    string result = \"db\";\n   \
    \ if(decimal == 0)\n    {\n        result = \"0\";\n    }\n    for(; decimal >\
    \ 0; decimal /= 2)\n    {\n        result = (decimal % 2) ~ result;\n    }\n \
    \   result = result ~ \"db\";\n    return result;\n}", "{\n  string result = \"\
    db\";\n  long remainder = decimal;\n  while(remainder > 0) {\n    if (remainder\
    \ % 2)\n      result = \"1\" ~ result;\n    else\n      result = \"0\" ~ result;\n\
    \    remainder /= 2;\n  }\n  return result ~ \"db\";\n}", "{\n    string binary=\
    \ \"db\";\n    while(decimal!=0)\n    {\n        binary~=cast(char)(decimal%2+'0');\n\
    \        decimal/=2;\n    }\n    return binary~\"db\";\n}\n/*\nWrite a function,\
    \ generate_doubles, that returns a sequence of values from a sequence in which\
    \ every\n    value is doubled. For example:", "{\n    string b = \"db\";\n   \
    \ for(; decimal > 0; decimal /= 2) \n    {\n        //binary.insert(binary.begin(),\
    \ ((decimal % 2) ? '1' : '0'));\n        b ~= (decimal % 2) ? '1' : '0';\n   \
    \ }\n    b ~= \"db\";\n    return b;\n}", "{\n    long n = decimal;\n    string\
    \ txt = \"db\";\n    long m = 2;\n    long i = 0;\n    while(n > 0)\n    {\n \
    \       if(n % m == 1)\n        {\n            txt = \"1\" ~ txt;\n        }\n\
    \        else\n        {\n            txt = \"0\" ~ txt;\n        }\n        n\
    \ = n / m;\n    }\n    txt = txt ~ \"db\";\n    return txt;\n}\n/*\n    Given\
    \ an integer n, calculate and return the n'th term of the binary sequence.\n \
    \   This sequence consists of elements of the form 2^(i+1) - 1, where i is an\
    \ integer.\n    The first few elements of the sequence are (n starts at 1):\n\
    \    3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535,\
    \ 131071, 262143\n    If the nth term of the sequence exceeds the maximum value\
    \ of a long, return the sequence value\n    at that point.", "{\n    long remainder;\n\
    \    string binary = \"db\";\n    while(decimal != 0)\n    {\n        remainder\
    \ = decimal % 2;\n        decimal /= 2;\n        if(remainder == 0)\n        \
    \    binary = \"0\" ~ binary;\n        else\n            binary = \"1\" ~ binary;\n\
    \    }\n    binary ~= \"db\";\n    return binary;\n}", "{\n    enum char db =\
    \ \"db\";\n    string binary = \"\";\n    string tmp;\n    long quotient = decimal;\n\
    \    long remainder = 0;\n    while( quotient != 0 )\n    {\n        remainder\
    \ = quotient % 2;\n        quotient = quotient / 2;\n        tmp = to!string(remainder);\n\
    \        binary = tmp ~ binary;\n    }\n    binary = db ~ binary ~ db;\n    return\
    \ binary;\n}", "{\n    return \"db\" ~ to!string(decimal, 2) ~ \"db\";\n}", "{\n\
    \    string result;\n    while(decimal > 0) {\n        result ~= (decimal % 2).to!string;\n\
    \        decimal /= 2;\n    }\n    return \"db\" ~ std.algorithm.reverse(result)\
    \ ~ \"db\";\n}", "{\n    enum result =\"db\";\n    enum num = decimal;\n    long\
    \ i = 0;\n    long quot = 0;\n    long remainder = 0;\n    long temp = 0;\n  \
    \  long length = num.length;\n    for(;i < num.length;i++)\n    {\n        temp\
    \ = num[i]-'0';\n        if(temp >= 10)\n        {\n            continue;\n  \
    \      }\n        quot = temp / 2;\n        remainder = temp % 2;\n        result\
    \ ~= remainder;\n        num[i] = quot + '0';\n    }\n    result ~= \"db\";\n\
    \    return result;\n}", "{\n    string result = \"db\";\n    int i = 0;\n   \
    \ for(; decimal > 0; i++)\n    {\n        result += decimal % 2;\n        decimal\
    \ /= 2;\n    }\n    if(i == 0)\n        result += \"0\";\n    result += \"db\"\
    ;\n    reverse(result);\n    return result;\n}", "{\n    // Your code here...\n\
    \    string input_bin = \"db\";\n    bool done = false;\n    long decimal_copy\
    \ = decimal;\n    while(decimal_copy != 0 && !done)\n    {\n        input_bin\
    \ += (char)(48 + decimal_copy % 2);\n        decimal_copy /= 2;\n        if(decimal_copy\
    \ == 0)\n        {\n            done = true;\n        }\n    }\n    input_bin\
    \ += \"db\";\n    string bin_str;\n    foreach(elem; input_bin.length)\n    {\n\
    \        bin_str += input_bin[input_bin.length - elem - 1];\n    }\n    return\
    \ bin_str;\n}", "{\n    string s = \"db\";\n    long  i = 0;\n    while(decimal\
    \ > 0)\n    {\n        s ~= (cast(char)((decimal % 2) + 48));\n        decimal\
    \ /= 2;\n    }\n    reverse(s);\n    s ~= \"db\";\n    return s;\n}", "{\n   \
    \ string result;\n    if (decimal == 0)\n        return \"db0db\";\n    while\
    \ (decimal > 0) {\n        result ~= decimal % 2;\n        decimal /= 2;\n   \
    \ }\n    return \"db\" ~ result.reverse ~ \"db\";\n}", "{\n    auto binary = \"\
    \";\n    if (decimal == 0) \n    {\n        binary = \"db0db\";\n    }\n    else\
    \ \n    {\n        binary = \"db\";\n        for (long i = 0; i < 32; i++) \n\
    \        {\n            binary ~= (decimal % 2).to!string;\n            decimal\
    \ /= 2;\n        }\n        binary ~= \"db\";\n    }\n    return binary;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
