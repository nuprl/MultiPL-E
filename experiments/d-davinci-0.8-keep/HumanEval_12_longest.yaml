name: HumanEval_12_longest
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n Out of list of strings, return\
  \ the longest one. Return the first one in case of multiple\n    strings of the\
  \ same length. Return None in case the input list is empty.\n    >>> longest([])\n\
  \n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n\
  \    'ccc'\n    \n*/\nNullable!(string) longest(string[] strings) \n"
tests: "unittest\n{\n    alias candidate = longest;\n\n{\n        auto result = candidate([]);\n\
  \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([\"x\"\
  , \"y\", \"z\"]);\n        assert(!result.isNull && result.get == \"x\");\n}\n\n\
  {\n        auto result = candidate([\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\"\
  , \"abc\"]);\n        assert(!result.isNull && result.get == \"zzzz\");\n}\n\n}\n\
  void main(){}"
completions: ["{\n    int max_length = -1;\n    Nullable!(string) longest = null;\n\
    \    foreach(string s; strings) \n    {\n        if (s.length > max_length) \n\
    \        {\n            max_length = s.length;\n            longest = s;\n   \
    \     }\n    }\n    return longest;\n}", "{\n    Nullable!(string) longest_string;\n\
    \    size_t longest_length = 0;\n    foreach(string s; strings) \n    {\n    \
    \    if (s.length > longest_length) \n        {\n            longest_string =\
    \ s;\n            longest_length = s.length;\n        }\n    }\n    return longest_string;\n\
    }", "{\n    import std.algorithm : max, iterator;\n    import std.typecons : Nullable;\n\
    \    static struct SizeT(T) {\n        T t;\n        size_t size() {\n       \
    \     return (t.sizeof > 0) ? t.sizeof : 0;\n        }\n    }\n    return (strings.empty)\n\
    \        ? null\n        : strings.max!(SizeT).t;\n}\n/*\n Return the sum of the\
    \ squares of the numbers in the input list. Return 0 in case the input list is\
    \ empty.\n    >>> sum_of_squares([])\n    0\n    >>> sum_of_squares([2, 3, 4])\n\
    \    29\n    >>> sum_of_squares([1, 0, -1])\n    2\n*/", "{\n    if (strings.length\
    \ == 0)\n        return null;\n    \n    Nullable!(string) r = null;\n    foreach\
    \ (str; strings)\n    {\n        if (r is null || str.length > r.length)\n   \
    \         r = str;\n    }\n    return r;\n}\n/*\n Take a list of integers, return\
    \ the sum of squares of all the integers except \n     negative numbers.\n   \
    \ >>> sum_of_squares([2, -1, 3])\n    13\n    >>> sum_of_squares([-2, 1, 3])\n\
    \    10\n*/", "{\n    if (strings.length > 0) \n    {\n        auto res = strings[0];\n\
    \        for (size_t i = 1; i < strings.length; i++) \n        {\n           \
    \ if (strings[i].length > res.length) \n            {\n                res = strings[i];\n\
    \            }\n        }\n        return res;\n    }\n    return null;\n}", "{\n\
    \    if (strings.length == 0)\n        return null;\n    else\n    {\n       \
    \ string s = strings[0];\n        foreach (string i; strings)\n        {\n   \
    \         if (i.length > s.length)\n                s = i;\n        }\n      \
    \  return Nullable!(string)(s);\n    }\n}", "{\n    Nullable!(string) longest;\n\
    \    if (strings.length == 0) return longest;\n    foreach (string s; strings)\
    \ \n    {\n        if (s.length > longest.length) \n        {\n            longest\
    \ = s;\n        }\n    }\n    return longest;\n}\n/*\n Return the first element\
    \ of an array which satisfies a predicate. Return null \n in case the input list\
    \ is empty. Return null in case there is no element \n satisfying the predicate.\n\
    \ \n    >>> first([])", "{\n    if (strings.length == 0)\n        return Nullable!(string)();\n\
    \    else\n    {\n        auto res = strings[0];\n        foreach (i, e; strings)\n\
    \        {\n            if (e.length > res.length)\n                res = e;\n\
    \        }\n        return Nullable!(string)(res);\n    }\n}", "{\n    import\
    \ std.algorithm : max;\n    import std.algorithm : map;\n    if (strings.empty)\n\
    \        return null;\n    else\n        return strings.map!(a => a.length).max!((a,\
    \ b) => a > b);\n}", "{\n    if (strings.length == 0) \n    {\n        return\
    \ null;\n    }\n    string longest = strings[0];\n    foreach (string str; strings)\
    \ \n    {\n        if (str.length > longest.length) \n        {\n            longest\
    \ = str;\n        }\n    }\n    return longest;\n}\n/*\n Make a dictionary that\
    \ maps digits to the corresponding Roman numeral.\n    >>> romans()\n    {'M':\
    \ 1000, 'CM': 900, 'D': 500, 'CD': 400, 'C': 100, 'XC': 90, 'L': 50, 'XL': 40,\
    \ 'X': 10, 'IX': 9, 'V': 5, 'IV': 4, 'I': 1}\n*/\nmap!(string, int) romans() \n\
    {\n    map!(string, int) romans;\n    romans[\"M\"] = 1000;\n    romans[\"CM\"\
    ] = 900;\n    romans[\"D\"] = 500;\n    romans[\"CD\"] = 400;\n    romans[\"C\"\
    ] = 100;\n    romans[\"XC\"] = 90;\n    romans[\"L\"] = 50;\n    romans[\"XL\"\
    ] = 40;\n    romans[\"X\"] = 10;\n    romans[\"IX\"] = 9;\n    romans[\"V\"] =\
    \ 5;\n    romans[\"IV\"] = 4;\n    romans[\"I\"] = 1;\n    return romans;\n}\n\
    /*\n Convert an integer to a roman numeral.\n    >>> to_roman(1666)\n    'MDCLXVI'\n\
    \    >>> to_roman(1999)\n    'MCMXCIX'\n    >>> to_roman(3)\n    'III'\n    >>>\
    \ to_roman(4)\n    'IV'\n    >>> to_roman(5)\n    'V'\n    >>> to_roman(9)\n \
    \   'IX'\n    >>> to_roman(10)\n    'X'\n    >>> to_roman(40)\n    'XL'\n    >>>\
    \ to_roman(50)\n    'L'\n    >>> to_roman(90)\n    'XC'\n    >>> to_roman(100)\n\
    \   ", "{\n    Nullable!(string) max=null;\n    foreach(string s; strings)\n \
    \   {\n        if(!max.isNull)\n        {\n            if(s.length>max.get.length)\n\
    \            {\n                max=makeNullable(s);\n            }\n        }\n\
    \        else\n        {\n            max=makeNullable(s);\n        }\n    }\n\
    \    return max;\n}", "{\n    //auto length = map!((s) => s.length)(strings);\n\
    \    //auto zipped = zip(length, strings);\n    //auto longest = max(length);\n\
    \    //return find!((pair) => longest == pair[0])(zipped)[1];\n    return None;\n\
    }", "{\n    Nullable!(string) result;\n    foreach(str; strings)\n    {\n    \
    \    if (result.isNull || str.length > result.get.length)\n        {\n       \
    \     result = str;\n        }\n    }\n    return result;\n}\n/*\n Return the\
    \ top N most frequently occurring items in the input sequence.", "{\n    Nullable!(string)\
    \ result;\n    foreach(str; strings)\n    {\n        if (str.length >= result.get)\n\
    \        {\n            result = to!Nullable(str);\n        }\n    }\n    return\
    \ result;\n}", "{\n    Nullable!(string) longest = null;", "{\n    Nullable!(string)\
    \ n;\n    foreach(string s; strings)\n    {\n        auto l = s.length;\n    \
    \    if(l > n.value?.length)\n            n = s;\n    }\n    return n;\n}\n/*\n\
    \    Cleanup a phone number:\n        ignore symbols, spaces\n        return in\
    \ international format, i.e. with a leading '+' and country code\n        if the\
    \ phone number is not a valid Irish number, return None\n        >>> clean('086\
    \ 6666667')\n        '+35386 6666667'\n        >>> clean('086+66 6666667')\n \
    \       '+35386 6666667'\n        >>> clean('+35386 6666667')\n        '+35386\
    \ 6666667'\n        >>> clean('a086 6666667')\n        >>> clean('086 6666667\
    \   ')\n        '+35386 6666667'\n        >>> clean('086 666666')\n        >>>\
    \ clean('086 6666669')\n        >>> clean('08 6666667')\n        >>> clean('086+66\
    \ 6666669')\n*/\nNullable!(string) clean(string phone) \n{\n    Nullable!(string)\
    \ n;\n    phone = phone.strip;\n    phone = phone.filter!(a => a.isDigit).joiner;\n\
    \    auto length = phone.length;\n    if(length == 11)\n    {\n        if(phone[0]\
    \ == '0' && phone[1] == '8' && (phone[2] == '6' || phone[2] == '7'))\n       \
    \     n = \"+35\" ~ phone;\n    }\n    else if(length == 10)\n    {\n        if(phone[0]\
    \ == '8' && (phone[1] == '6' || phone[1] == '7'))\n            n = \"+35\" ~ phone;\n\
    \    }\n    return n;\n}\n/*\n    >>> sum_pairs([1, 2, 3], 4)\n    [1, 3]\n  \
    \  >>> sum_pairs([1, 2, 3], 5)\n    [2, 3]\n    >>> sum_pairs([1, 2", "{\n   \
    \ if (strings.length == 0) \n    {\n        return Nullable!(string).init;\n \
    \   }\n    else \n    {\n        string result = strings[0];\n        foreach\
    \ (str; strings) \n        {\n            if (str.length > result.length) \n \
    \           {\n                result = str;\n            }\n        }\n     \
    \   return Nullable!(string)(result);\n    }\n}", "{\n    Nullable!(string) ret;\n\
    \    if (strings.length == 0)\n        return null;\n    if (strings.length ==\
    \ 1)\n        return strings[0];\n    ret = strings[0];\n    int maxLen = strings[0].length;\n\
    \    foreach (str; strings) {\n        if (str.length > maxLen) {\n          \
    \  maxLen = str.length;\n            ret = str;\n        }\n    }\n    return\
    \ ret;\n}", "{\n\t//TODO: implement\n\treturn null;\n}", "{\n    if (strings.length\
    \ == 0) return null;\n    // convert strings to (string, index) pairs\n    auto\
    \ pairs = strings.map!((string s) => tuple(s, s.length));\n    // return max according\
    \ to 2nd tuple element\n    return pairs.max!((tuple!(string, int) a, tuple!(string,\
    \ int) b) => a[1] < b[1])[0];\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
