name: HumanEval_153_Strongest_Extension
language: d
results:
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    double max_strength = -DBL_MAX;\n    string max_strength_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        double extension_strength\
    \ = calc_extension_strength(extension);\n        if(extension_strength > max_strength)\n\
    \        {\n            max_strength = extension_strength;\n            max_strength_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ max_strength_extension;\n\
    }\ndouble calc_extension_strength(string extension)\n{\n    double cap_strength\
    \ = (double)extension.countUpper;\n    double sm_strength = (double)extension.countLower;\n\
    \    return cap_strength - sm_strength;\n}\nunittest\n{\n    alias candidate =\
    \ Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1ahi7oqy.d(38): Error: C style cast illegal, use `cast(double)extension.countUpper`\\\
    n/tmp/tmp1ahi7oqy.d(39): Error: C style cast illegal, use `cast(double)extension.countLower`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1ahi7oqy.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    double strength;\n    double maxStrength = 0;\n    int indexOfMax =\
    \ 0;\n    foreach(int i, string ext; extensions)\n    {\n        strength = std.algorithm.count!(x\
    \ => x.isUpper)(ext) - \n            std.algorithm.count!(x => x.isLower)(ext);\n\
    \        if(strength > maxStrength)\n        {\n            maxStrength = strength;\n\
    \            indexOfMax = i;\n        }\n    }\n    return class_name ~ \".\"\
    \ ~ extensions[indexOfMax];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1agvp__6.d(28): Error: undefined identifier `algorithm` in package\
    \ `std`\\n/tmp/tmp1agvp__6.d(29): Error: undefined identifier `algorithm` in package\
    \ `std`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1agvp__6.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strongest_extension = \"\";\n    int strongest_extension_strength\
    \ = 0;\n    foreach(string extension; extensions)\n    {\n        int this_extension_strength\
    \ = 0;\n        foreach(char character; extension)\n        {\n            if(isupper(character))\
    \ this_extension_strength++;\n            else if(islower(character)) this_extension_strength--;\n\
    \        }\n        if(this_extension_strength > strongest_extension_strength)\n\
    \        {\n            strongest_extension_strength = this_extension_strength;\n\
    \            strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptqq70ez7.d(30): Error: undefined identifier `isupper`\\n/tmp/tmptqq70ez7.d(31):\
    \ Error: undefined identifier `islower`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmptqq70ez7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    import std.string;\n    int cap;\n    int sm;\n    int[] strengths;\n\
    \    int index;\n    string result;\n    import std.algorithm;\n    import std.array;\n\
    \    strengths = extensions.map!(a => {\n        cap = 0;\n        sm = 0;\n \
    \       foreach(i; a)\n        {\n            if(isUpper(i))\n               \
    \ cap++;\n            else if(isLower(i))\n                sm++;\n        }\n\
    \        return cap - sm;\n    }).array;\n    import std.algorithm;\n    index\
    \ = maxElement(strengths).idx;\n    result = class_name ~ \".\" ~ extensions[index];\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpi83t1vu6.d(36): Error: undefined identifier `isUpper`, did you\
    \ mean alias `toUpper`?\\n/tmp/tmpi83t1vu6.d(38): Error: undefined identifier\
    \ `isLower`, did you mean alias `toLower`?\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/algorithm/iteration.d(499):\
    \        instantiated from here: `MapResult!(__lambda3, string[])`\\n/tmp/tmpi83t1vu6.d(31):\
    \        instantiated from here: `map!(string[])`\\n/tmp/tmpi83t1vu6.d(44): Error:\
    \ no property `idx` for type `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\",\
    \ \"-o-\", \"/tmp/tmpi83t1vu6.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max(int a, int b)\n    {\n        return a > b ? a : b;\n    }\n\
    \    //int max2 = max(3,4);\n    string res = class_name;\n    int strength =\
    \ -1;\n    int res_strength = -1;\n    foreach(string ext; extensions)\n    {\n\
    \        foreach(inout char c; ext)\n        {\n            if(isUpper(c)) strength++;\n\
    \            else strength--;\n        }\n        if(abs(strength) > abs(res_strength))\n\
    \        {\n            res_strength = strength;\n            res = class_name\
    \ ~ \".\" ~ ext;\n        }\n        strength = -1;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5gmco05b.d(33): Error: variable `tmp5gmco05b.Strongest_Extension.c`\
    \ `inout` variables can only be declared inside `inout` functions\\n/tmp/tmp5gmco05b.d(35):\
    \ Error: undefined identifier `isUpper`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp5gmco05b.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    double best_extension_strength = -100;\n    int best_extension_index\
    \ = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        double\
    \ current_extension_strength = uppercase_count(extensions[i]) - lowercase_count(extensions[i]);\n\
    \        if (current_extension_strength > best_extension_strength)\n        {\n\
    \            best_extension_strength = current_extension_strength;\n         \
    \   best_extension_index = i;\n        }\n    }\n    return class_name ~ \".\"\
    \ ~ extensions[best_extension_index];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5c97m_25.d(27): Error: undefined identifier `uppercase_count`\\\
    n/tmp/tmp5c97m_25.d(27): Error: undefined identifier `lowercase_count`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5c97m_25.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    double max = 0;\n    string return_string = \"\";\n    foreach(extension;\
    \ extensions)\n    {\n        int upper = countUntil!(a => a.isUpper)(extension.front);\n\
    \        int lower = countUntil!(a => a.isLower)(extension.front);\n        double\
    \ strength = ((double)upper - (double)lower) / (double)extension.length;\n   \
    \     if(strength > max)\n        {\n            max = strength;\n           \
    \ return_string = class_name ~ \".\" ~ extension;\n        }\n    }\n    return\
    \ return_string;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpa0qwwhlk.d(29): Error: C style cast illegal, use `cast(double)upper`\\\
    n/tmp/tmpa0qwwhlk.d(29): Error: C style cast illegal, use `cast(double)lower`\\\
    n/tmp/tmpa0qwwhlk.d(29): Error: C style cast illegal, use `cast(double)extension.length`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa0qwwhlk.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    double[] strengths = extensions.map!(ext => ext.filter!(a => a >= 'A'\
    \ && a <= 'Z').length - ext.filter!(a => a >= 'a' && a <= 'z').length).array;\n\
    \    return class_name ~ \".\" ~ extensions[indexOf(strengths, max(strengths))];\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwkbc0ht5.d(23): Error: no property `map` for type `string[]`\\\
    n/tmp/tmpwkbc0ht5.d(24): Error: undefined identifier `indexOf`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwkbc0ht5.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    auto num_upper = (char c) { return c >= 'A' && c <= 'Z'; };\n    auto\
    \ num_lower = (char c) { return c >= 'a' && c <= 'z'; };\n    int i = 0;\n   \
    \ float max = -1;\n    string selected = \"\";\n    while (i < extensions.length)\n\
    \    {\n        float upper = filter!num_upper(extensions[i]).length;\n      \
    \  float lower = filter!num_lower(extensions[i]).length;\n        float strength\
    \ = upper - lower;\n        if (strength > max)\n        {\n            max =\
    \ strength;\n            selected = extensions[i];\n        }\n        i++;\n\
    \    }\n    return class_name ~ \".\" ~ selected;\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptwuphk8r.d(30): Error: template instance `filter!num_upper` template\
    \ `filter` is not defined\\n/tmp/tmptwuphk8r.d(31): Error: template instance `filter!num_lower`\
    \ template `filter` is not defined\\nFailed: [\"dmd\", \"-unittest\", \"-v\",\
    \ \"-o-\", \"/tmp/tmptwuphk8r.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int capCount = 0;\n    int smCount = 0;\n    int capSum = 0;\n    int\
    \ smSum = 0;\n    int compare = 0;\n    int compareSum = 0;\n    int x = 0;\n\
    \    string extension = \"\";\n    string result = \"\";\n    foreach(string ext;\
    \ extensions)\n    {\n        capCount = 0;\n        smCount = 0;\n        foreach(char\
    \ ch; ext)\n        {\n            if(isupper(ch))\n            {\n          \
    \      capCount++;\n            }\n            else\n            {\n         \
    \       smCount++;\n            }\n        }\n        capSum = capCount - smCount;\n\
    \        if(capSum == compare)\n        {\n            if(extensions[x] < extension)\n\
    \            {\n                extension = extensions[x];\n            }\n  \
    \      }\n        else if(capSum > compare)\n        {\n            compare =\
    \ capSum;\n            extension = extensions[x];\n        }\n        x++;\n \
    \   }\n    result = format(\"%s.%s\", class_name, extension);\n    return result;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1zo8pr8z.d(38): Error: undefined identifier `isupper`\\n/tmp/tmp1zo8pr8z.d(62):\
    \ Error: undefined identifier `format`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp1zo8pr8z.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    struct  Ext{\n        string name;\n        int strength;\n    }\n\
    \    Ext[] exts = new Ext[extensions.length];\n    foreach(i, elem; extensions)\n\
    \    {\n        Ext e;\n        e.name = elem;\n        e.strength = elem.count!(a\
    \ => a.isUpper) - elem.count!(a => a.isLower);\n        exts[i] = e;\n    }\n\
    \    size_t max_strength = exts.map!(x => x.strength).max;\n    foreach(i, elem;\
    \ exts)\n    {\n        if(elem.strength == max_strength)\n            return\
    \ class_name ~ \".\" ~ elem.name;\n    }\n    return \"\";\n}\nunittest\n{\n \
    \   alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp___umuuh.d(32): Error: no property `count` for type `string`\\\
    n/tmp/tmp___umuuh.d(32): Error: no property `count` for type `string`\\n/tmp/tmp___umuuh.d(35):\
    \ Error: no property `map` for type `Ext[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp___umuuh.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    // \u041F\u0440\u0438\u0432\u0435\u0442, \u043A\u043E\u043B\u043B\u0435\
    \u0433\u0430! \u0412\u044B \u043C\u043E\u0436\u0435\u0442\u0435 \u043E\u0442\u0440\
    \u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u044D\
    \u0442\u043E\u0442 \u043A\u043E\u0434 \u0438 \u0437\u0430\u043F\u0443\u0441\u0442\
    \u0438\u0442\u044C \u0435\u0433\u043E.\n    int max_strength = 0;\n    string\
    \ strongest_extension = \"\";\n    foreach(extension; extensions)\n    {\n   \
    \     int cap = 0;\n        int sm = 0;\n        foreach(letter; extension)\n\
    \        {\n            if (isUpper(letter))\n                cap++;\n       \
    \     else\n                sm++;\n        }\n        int strength = cap - sm;\n\
    \        if (max_strength < strength)\n        {\n            max_strength = strength;\n\
    \            strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplkm1iuzy.d(32): Error: undefined identifier `isUpper`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplkm1iuzy.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    struct Str\n    {\n        string @this;\n        int CAP;\n      \
    \  int SM;\n    }\n    int max = -100000;\n    Str best = Str(class_name, 0, 0);\n\
    \    Str[] bests = new Str[0];\n    foreach(i, s; extensions)\n    {\n       \
    \ Str str = Str(s, 0, 0);\n        foreach(c; str.@this)\n        {\n        \
    \    if(isUpper(c))\n                str.CAP++;\n            else\n          \
    \      str.SM++;\n        }\n        if(str.CAP - str.SM > max)\n        {\n \
    \           max = str.CAP - str.SM;\n            best = str;\n            bests\
    \ = new Str[0];\n            bests ~= best;\n        }\n        else if(str.CAP\
    \ - str.SM == max)\n        {\n            bests ~= str;\n        }\n    }\n \
    \   return class_name ~ \".\" ~ bests[0].@this;\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_fuooyvx.d(25): Error: no identifier for declarator `string`\\\
    n/tmp/tmp_fuooyvx.d(25): Error: @identifier or @(ArgumentList) expected, not `@this`\\\
    n/tmp/tmp_fuooyvx.d(25): Error: valid attributes are `@property`, `@safe`, `@trusted`,\
    \ `@system`, `@disable`, `@nogc`\\n/tmp/tmp_fuooyvx.d(25): Error: found `;` when\
    \ expecting `(`\\n/tmp/tmp_fuooyvx.d(26): Error: found `;` when expecting `)`\\\
    n/tmp/tmp_fuooyvx.d(27): Error: semicolon expected following function declaration\\\
    n/tmp/tmp_fuooyvx.d(35): Error: identifier expected following `.`, not `@`\\n/tmp/tmp_fuooyvx.d(35):\
    \ Error: found `this` when expecting `)`\\n/tmp/tmp_fuooyvx.d(35): Error: found\
    \ `)` instead of statement\\n/tmp/tmp_fuooyvx.d(39): Error: found `else` without\
    \ a corresponding `if`, `version` or `debug` statement\\n/tmp/tmp_fuooyvx.d(54):\
    \ Error: declaration expected, not `return`\\n/tmp/tmp_fuooyvx.d(55): Error: unrecognized\
    \ declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_fuooyvx.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    double strength = -1.0;\n    string strongestExt = \"\";\n    string\
    \ class_name_lower = class_name.toLower();\n    foreach(string extension, int\
    \ i; extensions)\n    {\n        string extension_lower = extension.toLower();\n\
    \        double ext_strength = cast(double)extension.countUpper() - extension_lower.countLower();\n\
    \        if(ext_strength > strength && class_name_lower.indexOf(extension_lower)\
    \ != -1)\n        {\n            strength = ext_strength;\n            strongestExt\
    \ = extension;\n        }\n    }\n    return (class_name + \".\" + strongestExt);\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpd24_bxuq.d(25): Error: no property `toLower` for type `string`\\\
    n/tmp/tmpd24_bxuq.d(26): Error: integral constant must be scalar type, not `string`\\\
    n/tmp/tmpd24_bxuq.d(26): Error: integral constant must be scalar type, not `string`\\\
    n/tmp/tmpd24_bxuq.d(26): Error: incompatible types for `(__key73) < (__r74.length)`:\
    \ `string` and `ulong`\\n/tmp/tmpd24_bxuq.d(26): Error: cannot implicitly convert\
    \ expression `__key73` of type `string` to `ulong`\\n/tmp/tmpd24_bxuq.d(28): Error:\
    \ no property `toLower` for type `string`\\n/tmp/tmpd24_bxuq.d(29): Error: no\
    \ property `countUpper` for type `string`\\n/tmp/tmpd24_bxuq.d(29): Error: no\
    \ property `countLower` for type `string`\\n/tmp/tmpd24_bxuq.d(30): Error: no\
    \ property `indexOf` for type `string`\\n/tmp/tmpd24_bxuq.d(36): Error: invalid\
    \ array operation `class_name + \".\"` (possible missing [])\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd24_bxuq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string ret = \"\";\n    double min = double.max;\n    foreach(string\
    \ s; extensions)\n    {\n        int capital_cnt = 0;\n        int small_cnt =\
    \ 0;\n        foreach(char c; s)\n        {\n            if(isupper(c)) capital_cnt++;\n\
    \            else if(islower(c)) small_cnt++;\n        }\n        if(small_cnt\
    \ - capital_cnt <= min)\n        {\n            ret = s;\n            min = small_cnt\
    \ - capital_cnt;\n        }\n    }\n    return format(\"%s.%s\", class_name, ret);\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqbaaz_q9.d(31): Error: undefined identifier `isupper`\\n/tmp/tmpqbaaz_q9.d(32):\
    \ Error: undefined identifier `islower`\\n/tmp/tmpqbaaz_q9.d(40): Error: undefined\
    \ identifier `format`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqbaaz_q9.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int caps;\n    int sm;\n    int counter;\n    int max_value = -1;\n\
    \    int max_count = 0;\n    string[] str_arr;\n    string result;\n    foreach(i;\
    \ extensions)\n    {\n        caps = 0;\n        sm = 0;\n        foreach(ch;\
    \ i)\n        {\n            if(ch.isUpper)\n                caps++;\n       \
    \     else\n                sm++;\n        }\n        //writeln(i, \": \", caps\
    \ - sm);\n        counter = caps - sm;\n        if(counter > max_value)\n    \
    \    {\n            max_value = counter;\n            max_count = 0;\n       \
    \     str_arr = [i];\n        }\n        else if(counter == max_value)\n     \
    \   {\n            str_arr ~= i;\n        }\n    }\n    result = class_name ~\
    \ \".\" ~ str_arr[0];\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppiv0mcg1.d(36): Error: no property `isUpper` for type `immutable(char)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppiv0mcg1.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    int max_strength = -1;\n    string max_extension = \"\";\n    foreach(extension;\
    \ extensions)\n    {\n        int strength = 0;\n        foreach(c; extension)\n\
    \        {\n            if(std.ctype.isupper(c))\n                strength++;\n\
    \            else\n                strength--;\n        }\n        if(strength\
    \ > max_strength)\n        {\n            max_strength = strength;\n         \
    \   max_extension = extension;\n        }\n    }\n    return class_name ~ \".\"\
    \ ~ max_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1fat6z3a.d(30): Error: undefined identifier `ctype` in package\
    \ `std`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1fat6z3a.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    double strength = 0;\n    string result = \"\";\n    foreach(string\
    \ str; extensions)\n    {\n        int CAP = 0;\n        int SM = 0;\n       \
    \ foreach(char c; str)\n        {\n            if(c.isUpper)\n               \
    \ CAP++;\n            else if(c.isLower)\n                SM++;\n        }\n \
    \       if(abs(CAP - SM) > strength)\n        {\n            strength = abs(CAP\
    \ - SM);\n            result = \".\" ~ str;\n        }\n    }\n    return class_name\
    \ ~ result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n  \
    \  assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    );\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\"\
    , [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) ==\
    \ \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\"\
    , [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    );\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    ]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"])\
    \ == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptimgdxgj.d(31): Error: no property `isUpper` for type `char`\\\
    n/tmp/tmptimgdxgj.d(33): Error: no property `isLower` for type `char`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptimgdxgj.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string result = \"\";\n    double f = 0;\n    foreach(string ext, int\
    \ i; extensions)\n    {\n        string temp;\n        double s = 0;\n       \
    \ foreach(char c; ext)\n        {\n            if(c >= 'A' && c <= 'Z')\n    \
    \            s++;\n            else if(c >= 'a' && c <= 'z')\n               \
    \ s--;\n        }\n        if(s > f)\n        {\n            f = s;\n        \
    \    temp = ext;\n        }\n        result = format(\"%s.%s\", class_name, temp);\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5pyqjrpg.d(25): Error: integral constant must be scalar type,\
    \ not `string`\\n/tmp/tmp5pyqjrpg.d(25): Error: integral constant must be scalar\
    \ type, not `string`\\n/tmp/tmp5pyqjrpg.d(25): Error: incompatible types for `(__key73)\
    \ < (__r74.length)`: `string` and `ulong`\\n/tmp/tmp5pyqjrpg.d(25): Error: cannot\
    \ implicitly convert expression `__key73` of type `string` to `ulong`\\n/tmp/tmp5pyqjrpg.d(41):\
    \ Error: undefined identifier `format`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp5pyqjrpg.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
    \    \n*/\nstring Strongest_Extension(string class_name, string[] extensions)\
    \ \n{\n    string strong_extension = extensions[0];\n    int strong_strength =\
    \ 0;\n    foreach(string extension; extensions)\n    {\n        int cap = extension.count!(a\
    \ => a.isUpper)();\n        int sm = extension.count!(a => a.isLower)();\n   \
    \     int strength = cap - sm;\n        if(strong_strength < strength)\n     \
    \   {\n            strong_strength = strength;\n            strong_extension =\
    \ extension;\n        }\n    }\n    return format(\"%s.%s\", class_name, strong_extension);\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnx32yh2x.d(27): Error: no property `count` for type `string`\\\
    n/tmp/tmpnx32yh2x.d(28): Error: no property `count` for type `string`\\n/tmp/tmpnx32yh2x.d(36):\
    \ Error: undefined identifier `format`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpnx32yh2x.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
