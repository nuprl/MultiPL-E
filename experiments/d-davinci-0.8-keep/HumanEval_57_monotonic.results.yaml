name: HumanEval_57_monotonic
language: d
results:
- program: "import std.typecons;\nimport std.math;\n/*\nReturn True is list elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n\
    \    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4,\
    \ 1, 0, -10])\n    True\n    \n*/\nbool monotonic(long[] l) \n{\n  bool dec =\
    \ false;\n  if (l.length <= 1) return true;\n  auto old = l[0];\n  foreach (i;\
    \ 1..l.length) {\n    if (l[i] == old) continue;\n    if (l[i] < old) {\n    \
    \  if (dec) continue;\n      dec = true;\n    } else {\n      if (!dec) continue;\n\
    \      return false;\n    }\n    old = l[i];\n  }\n  return true;\n}\n/*\nGenerate\
    \ list of prime numbers.\n    >>> primes(20)\n    [2, 3, 5, 7, 11, 13, 17, 19]\n\
    */\nlong[] primes(long n)\n{\n    if (n < 2) return new long[](0);\n    if (n\
    \ == 2) return [2];\n    long[] result = [2];\n    foreach (i; 3..n+1) {\n   \
    \     bool add = true;\n        foreach (p; result) if (i % p == 0) { add = false;\
    \ break; }\n        if (add) result ~= i;\n    }\n    return result;\n}\n/*\n\
    Return the list of prime factors of a number.\n    >>> prime_factors(6)\n    [2,\
    \ 3]\n    >>> prime_factors(15)\n    [3, 5]\n    >>> prime_factors(127)\n    [127]\n\
    \    >>> prime_factors(128)\n    [2, 2, 2, 2, 2, 2, 2]\n*/\nlong[] prime_factors(long\
    \ n)\n{\n    if (n < 1) return [];\n    long[] factors = [];\n    foreach (p;\
    \ primes(n)) {\n        while (n % p == 0) {\n            factors ~= p;\n    \
    \        n /= p;\n        }\n    }\n    return factors;\n}\n/*\nunittest\n{\n\
    \    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) ==\
    \ true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbg9e1fuv.d(71): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbg9e1fuv.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn True is list elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n\
    \    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4,\
    \ 1, 0, -10])\n    True\n    \n*/\nbool monotonic(long[] l) \nin {\n\tassert(l.length\
    \ > 0);\n}\nout (bool result) {\n\tassert(result == (((l[0] <= l[1]) && (l[1]\
    \ <= l[2]) && (l[2] <= l[3])) || ((l[0] >= l[1]) && (l[1] >= l[2]) && (l[2] >=\
    \ l[3]))));\n}\n{\n\tauto sorted = l.dup;\n\tsorted.sort;\n\tif (sorted.length\
    \ == l.length) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n/*\nReturns True\
    \ is a list is strictly ascending order.\n    >>> strictly_increasing([1, 20,\
    \ 4, 10])\n    False\n    >>> strictly_increasing([1, 2, 4, 20])\n    True\n \
    \   >>> strictly_increasing([4, 1, 0, -10])\n    False\n*/\nunittest\n{\n    alias\
    \ candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n\
    \    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpt2kqnffi.d(17): Error: `(identifier) { ... }` or `(identifier;\
    \ expression)` following `out` expected, not `bool`\\n/tmp/tmpt2kqnffi.d(17):\
    \ Error: found `result` when expecting `)`\\n/tmp/tmpt2kqnffi.d(17): Error: statement\
    \ expected to be `{ }`, not `)`\\n/tmp/tmpt2kqnffi.d(17): Error: found `)` instead\
    \ of statement\\n/tmp/tmpt2kqnffi.d(19): Error: unrecognized declaration\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt2kqnffi.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn True is list elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n\
    \    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4,\
    \ 1, 0, -10])\n    True\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ == 0) return true;\n    long sign = sign(l[1] - l[0]);\n    foreach (i, x; l)\n\
    \    {\n        if (sign != sign(l[i] - l[i-1])) return false;\n    }\n    return\
    \ true;\n}\n/*\nWith a type of ascending or descending, determine if a list is\
    \ monotonic.\n    >>> monotonic([1, 2, 4, 20], Tuple!(long, \"increasing\"))\n\
    \    True\n    >>> monotonic([1, 20, 4, 10], Tuple!(long, \"increasing\"))\n \
    \   False\n    >>> monotonic([4, 1, 0, -10], Tuple!(long, \"descending\"))\n \
    \   True\n    \n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsfycl5w1.d(16): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpsfycl5w1.d(19): Error: function expected before\
    \ `()`, not `sign` of type `long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpsfycl5w1.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn True is list elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n\
    \    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4,\
    \ 1, 0, -10])\n    True\n    \n*/\nbool monotonic(long[] l) \n{\n    int sign\
    \ = signbit(l[1] - l[0]);\n    if (sign == 0)\n        return false;\n    foreach\
    \ (i; 1..l.length)\n    {\n        int nextsign = signbit(l[i] - l[i-1]);\n  \
    \      if (nextsign == 0)\n            return false;\n        if (nextsign !=\
    \ sign)\n            return false;\n    }\n    return true;\n}\nunittest\n{\n\
    \    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) ==\
    \ true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(271):\
    \ Error: no property `epsilon` for type `long`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(272):\
    \ Error: no property `mant_dig` for type `long`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(292):\
    \ Error: no property `mant_dig` for type `long`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(335):\
    \ Error: no property `mant_dig` for type `long`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(353):\
    \ Error: no property `mant_dig` for type `long`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(371):\
    \ Error: no property `mant_dig` for type `long`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(6254):\
    \ Error: template instance `std.math.floatTraits!long` error instantiating\\n/tmp/tmp0c6h2d9x.d(15):\
    \        instantiated from here: `signbit!long`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp0c6h2d9x.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn True is list elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n\
    \    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4,\
    \ 1, 0, -10])\n    True\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ < 2)\n        return true;\n    bool ascending = l[0] < l[1];\n    foreach (a,\
    \ b; zip(l[0..$-1], l[1..$]))\n    {\n        if (ascending && b < a)\n      \
    \      return false;\n        if (!ascending && b > a)\n            return false;\n\
    \    }\n    return true;\n}\n/*\ncheck if a list is a permutation of another.\n\
    \    >>> is_permutation([1, 2, 3], [3, 2, 1])\n    True\n    >>> is_permutation([1,\
    \ 2, 3], [3, 2, 5])\n    False\n    >>> is_permutation([1, 2, 3], [3, 2, 5, 1])\n\
    \    False\n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdy07j1ds.d(18): Error: undefined identifier `zip`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdy07j1ds.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn True is list elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n\
    \    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4,\
    \ 1, 0, -10])\n    True\n    \n*/\nbool monotonic(long[] l) \n{ \n\tenum constant\
    \ = l.length;\n\tif (constant <= 2)\n\t\treturn true;\n\tbool is_increasing =\
    \ l[0] < l[1];\n\tfor (size_t i = 1; i < constant - 1; i++) \n\t{\n\t\tif (l[i]\
    \ <= l[i - 1] && is_increasing)\n\t\t\treturn false;\n\t\tif (l[i] >= l[i - 1]\
    \ && !is_increasing)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvvalzzoo.d(15): Error: variable `l` cannot be read at compile\
    \ time\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvvalzzoo.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn True is list elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n\
    \    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4,\
    \ 1, 0, -10])\n    True\n    \n*/\nbool monotonic(long[] l) \n{\n    auto diffs\
    \ = l.map!(x => x - x.previous);\n    auto cmp = diffs[0];\n    return diffs.all!(x\
    \ => x * cmp >= 0);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfpievokp.d(15): Error: no property `map` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfpievokp.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn True is list elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n\
    \    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4,\
    \ 1, 0, -10])\n    True\n    \n*/\nbool monotonic(long[] l) \n{ \n  return equal(all(zip(l,\
    \ l[1 .. $]).map!(a => a[0] < a[1])), true) || equal(all(zip(l, l[1 .. $]).map!(a\
    \ => a[0] > a[1])), true);\n}\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphkpwzif2.d(15): Error: undefined identifier `equal`\\n/tmp/tmphkpwzif2.d(15):\
    \ Error: undefined identifier `equal`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmphkpwzif2.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn True is list elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n\
    \    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4,\
    \ 1, 0, -10])\n    True\n    \n*/\nbool monotonic(long[] l) \n{\n\tif (l.length<=1)\
    \ return true;\n\tint check = sign(l[1]-l[0]);\n\tif (check == 0) return monotonic(l[1..$]);\n\
    \tforeach (v; l[1..$])\n\t{\n\t\tif (sign(v-l[$-1]) != check) return false;\n\t\
    }\n\treturn true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5neo3cfo.d(16): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmp5neo3cfo.d(20): Error: undefined identifier\
    \ `sign`, did you mean template `sgn(F)(F x)`?\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp5neo3cfo.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn True is list elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n\
    \    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4,\
    \ 1, 0, -10])\n    True\n    \n*/\nbool monotonic(long[] l) \n{\n    bool isIncreasing\
    \ = true;\n    bool isDecreasing = true;\n    for (ulong i = 1; i < l.length;\
    \ i++) \n    {\n        isIncreasing &= l[i] >= l[i - 1];\n        isDecreasing\
    \ &= l[i] <= l[i - 1];\n    }\n    return isIncreasing || isDecreasing;\n}\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\nReturn True is list elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n\
    \    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4,\
    \ 1, 0, -10])\n    True\n    \n*/\nbool monotonic(long[] l) \n{\n\treturn (l.length\
    \ > 0) ?\n\t\t\tl.reduce!((a,b) => {return (a < b) ? 1 : (a > b) ? -1 : 0;})(0)\
    \ <= 0 :\n\t\t\ttrue;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n  \
    \  assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L,\
    \ 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n \
    \   assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfg5wed8j.d(16): Error: no property `reduce` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfg5wed8j.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn True is list elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n\
    \    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4,\
    \ 1, 0, -10])\n    True\n    \n*/\nbool monotonic(long[] l) \n{\n    long[] new_l\
    \ = l[1..$-1];\n    return all!(i => i[0] >= i[1])(new_l.zip(new_l[1..$]));\n\
    }\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8khb1rc7.d(16): Error: template instance `all!((i) => i[0] >=\
    \ i[1])` template `all` is not defined\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp8khb1rc7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn True is list elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n\
    \    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4,\
    \ 1, 0, -10])\n    True\n    \n*/\nbool monotonic(long[] l) \n{\n    bool m =\
    \ true;\n    long[] lp = l[0..$-1];\n    long[] ln = l[1..$];\n    foreach(int\
    \ i, long x; lp)\n    {\n        if (x <= ln[i])\n        {\n            m = false;\n\
    \            break;\n        }\n    }\n    return m;\n}\nunittest\n{\n    alias\
    \ candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n\
    \    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp2r700ofu.d(32): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42832d]\\n??:? void tmp2r700ofu.__unittest_L28_C1()\
    \ [0x427e44]\\n??:? void tmp2r700ofu.__modtest() [0x4280b0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c3af]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b242]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4303d5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430884]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430361]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b219]\\n??:? runModuleUnitTests [0x42c185]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4287f0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428777]\\n??:? _d_run_main [0x4286e2]\\n??:? main [0x4280c3]\\\
    n??:? __libc_start_main [0x66325554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn True is list elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n\
    \    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4,\
    \ 1, 0, -10])\n    True\n    \n*/\nbool monotonic(long[] l) \n{\n    auto s =\
    \ l.sort(); \n    return (s == l) || (s == l.reverse());\n}\n \n/*\nReturn True\
    \ if all elements of `l` are unique.\n    >>> all_unique([1, 2, 4, 20])\n    True\n\
    \    >>> all_unique([1, 2, 4, 1])\n    False\n*/\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpr3q8pnqr.d(15): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpr3q8pnqr.d(16): Error: template `std.typecons.reverse` cannot deduce\
    \ function from argument types `!()(long[])`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmpr3q8pnqr.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn True is list elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n\
    \    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4,\
    \ 1, 0, -10])\n    True\n    \n*/\nbool monotonic(long[] l) \n{\n    bool incr\
    \ = true;\n    bool decr = true;\n    foreach(x; l) \n    {\n        //tuple t\
    \ = tuple(l[i], l[i+1]);\n        bool temp1 = l[x] <= l[x+1];\n        bool temp2\
    \ = l[x] >= l[x+1];\n        incr &= temp1;\n        decr &= temp2;\n    }\n \
    \   return incr || decr;\n}\n/*\nGiven a list l and a natural number n, return\
    \ a list where all elements have been removed that occur more than n times.\n\
    \    >>> limited_occurrence([1, 2, 2, 2, 2, 3, 4, 5, 6, 1, 2, 2, 2, 2, 2, 4, 2,\
    \ 2, 2, 3, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2o9vea_3.d(27): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2o9vea_3.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn True is list elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n\
    \    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4,\
    \ 1, 0, -10])\n    True\n    \n*/\nbool monotonic(long[] l) \n{\n\tif (l.length\
    \ < 2)\n\t\treturn true;\n\t//l.sort();\n\tl.sort(lteq);\n\treturn l[0] <= l[$-1];\n\
    }\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpah8ay3ns.d(18): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpah8ay3ns.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn True is list elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n\
    \    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4,\
    \ 1, 0, -10])\n    True\n    \n*/\nbool monotonic(long[] l) \n{ \n\tlong[] l1\
    \ = new long[l.length]; \n\tl1 = l.dup;\n\tl1.sort;\n\treturn l == l1 || l ==\
    \ l1.reverse;\n} \nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7vjrkrxw.d(17): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp7vjrkrxw.d(18): Error: template `std.typecons.reverse` cannot deduce\
    \ function from argument types `!()(long[])`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmp7vjrkrxw.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn True is list elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n\
    \    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4,\
    \ 1, 0, -10])\n    True\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong[] l2 =\
    \ l[].dup;\n\treturn l.sort.equal(l2) || l.sort.equal(l2.reverse);\n}\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbvn2cpl0.d(16): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpbvn2cpl0.d(16): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbvn2cpl0.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn True is list elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n\
    \    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4,\
    \ 1, 0, -10])\n    True\n    \n*/\nbool monotonic(long[] l) \n{\n    bool increasing\
    \ = true;\n    bool decreasing = true;\n    for (int i = 0; i < l.length - 1;\
    \ i++)\n    {\n        if (l[i] > l[i + 1])\n        {\n            increasing\
    \ = false;\n        }\n        if (l[i] < l[i + 1])\n        {\n            decreasing\
    \ = false;\n        }\n    }\n    return increasing || decreasing;\n}\n/*\nReturns\
    \ the second largest number in a list.\n    >>> second_largest([1, 2, 3, 4, 5])\n\
    \    4\n    >>> second_largest([1, 2, 5, 4, 3])\n    4\n    >>> second_largest([9,\
    \ 2, 3, 2, 5])\n    5\n    >>> second_largest([2, 2, 5, 9, 9])\n    5\n*/\nlong\
    \ second_largest(long[] l)\n{\n    long largest = l[0];\n    long second_largest\
    \ = l[0];\n    for (int i = 0; i < l.length; i++)\n    {\n        if (l[i] > largest)\n\
    \        {\n            second_largest = largest;\n            largest = l[i];\n\
    \        }\n        else if (l[i] > second_largest && l[i] != largest)\n     \
    \   {\n            second_largest = l[i];\n        }\n    }\n    return second_largest;\n\
    }\n/*\nReturns the number of unique strings in a list.\n    >>> num_unique([\"\
    a\", \"b\", \"a\", \"b\", \"c\"])\n    3\n    >>> num_unique([\"a\", \"a\", \"\
    a\", \"a\", \"a\"])\n    1\n    >>> num_unique([\"a\", \"b\", \"c\", \"d\", \"\
    d\"])\n    4\n*/\nlong num_unique(string[] strings)\n{\n    unordered_set!string\
    \ unique = new unordered_set!string();\n    foreach (string s; strings)\n    {\n\
    \        unique.insert(s);\n    }\n    return unique.length;\n}\n/*\nGiven a list\
    \ of numbers, return the number of values that are smaller than\nthe previous\
    \ value.\n\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpf5uys_jf.d(77): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf5uys_jf.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn True is list elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n\
    \    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4,\
    \ 1, 0, -10])\n    True\n    \n*/\nbool monotonic(long[] l) \n{\n    bool res;\n\
    \    int i;\n    long[] current;\n    long[] last;\n    auto d = length(l);\n\
    \    int max_diff;\n    auto n = length(l);\n    int[] diff = new int[](n);\n\
    \    if(n < 2)\n        return true;\n    \n    foreach(i, current; l)\n    {\n\
    \        last = current;\n        foreach(i, current; l)\n        {\n        \
    \    if(i > 0)\n            {\n                diff[i] = current - last;\n   \
    \             d = max(d, diff[i]);\n            }\n            i++;\n        }\n\
    \        i++;\n    }\n    max_diff = to!int(d);\n    foreach(i, current; l)\n\
    \    {\n        if(i > 0)\n        {\n            if(abs(diff[i]) > max_diff)\n\
    \                return false;\n        }\n        i++;\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqgtievsy.d(19): Error: undefined identifier `length`\\n/tmp/tmpqgtievsy.d(21):\
    \ Error: undefined identifier `length`\\n/tmp/tmpqgtievsy.d(26): Error: variable\
    \ `current` is shadowing variable `tmpqgtievsy.monotonic.current`\\n/tmp/tmpqgtievsy.d(26):\
    \ Error: variable `i` is shadowing variable `tmpqgtievsy.monotonic.i`\\n/tmp/tmpqgtievsy.d(28):\
    \ Error: cannot implicitly convert expression `current` of type `long` to `long[]`\\\
    n/tmp/tmpqgtievsy.d(29): Error: variable `current` is shadowing variable `tmpqgtievsy.monotonic.current`\\\
    n/tmp/tmpqgtievsy.d(29): Error: variable `i` is shadowing variable `tmpqgtievsy.monotonic.i`\\\
    n/tmp/tmpqgtievsy.d(33): Error: incompatible types for `(current) - (last)`: `long`\
    \ and `long[]`\\n/tmp/tmpqgtievsy.d(40): Error: template instance `to!int` template\
    \ `to` is not defined, did you mean No?\\n/tmp/tmpqgtievsy.d(41): Error: variable\
    \ `current` is shadowing variable `tmpqgtievsy.monotonic.current`\\n/tmp/tmpqgtievsy.d(41):\
    \ Error: variable `i` is shadowing variable `tmpqgtievsy.monotonic.i`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqgtievsy.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
