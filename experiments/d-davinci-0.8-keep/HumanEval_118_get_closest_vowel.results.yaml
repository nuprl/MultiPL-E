name: HumanEval_118_get_closest_vowel
language: d
results:
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n\tauto vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n\tint min_dist\
    \ = int.max;\n\tstring min_vowel = \"\";\n\tstring last_consonant = \"\";\n\t\
    string prev_letter = \"\";\n\tforeach(i, ch; word.byReverse)\n\t{\n\t\tif(vowels.canFind(ch))\n\
    \t\t{\n\t\t\tif(last_consonant != \"\")\n\t\t\t{\n\t\t\t\tint dist = word.length\
    \ - i - word.byReverse.canFind(last_consonant);\n\t\t\t\tif(dist < min_dist)\n\
    \t\t\t\t{\n\t\t\t\t\tmin_dist = dist;\n\t\t\t\t\tmin_vowel = ch;\n\t\t\t\t}\n\t\
    \t\t}\n\t\t\tlast_consonant = prev_letter;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprev_letter\
    \ = ch;\n\t\t}\n\t}\n\treturn min_vowel;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpg301dr_t.d(26): Error: no property `byReverse` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg301dr_t.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{ \n    string vowels = \"AEIOUaeiou\";\n    string consonants = \"\
    BCDFGHJKLMNPQRSTVWXYZbcdfghjklmnpqrstvwxyz\";\n    string result = \"\";\n   \
    \ int index;\n    //convert string to dchar[],\n    auto word_dchars = word.to!dchar[];\n\
    \    //iterate through it, starting from the end\n    for(int i = word_dchars.length-1;\
    \ i > 0; i--)\n    {\n        //if our letter is a consonant and the letter before\
    \ it is a vowel,\n        //return the vowel\n        if(consonants.canFind(word_dchars[i])\
    \ && vowels.canFind(word_dchars[i-1]))\n        {\n            index = i-1;\n\
    \            result = word_dchars[index].to!string;\n            return result;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1a_ept18.d(26): Error: no property `to` for type `string`\\n/tmp/tmp1a_ept18.d(32):\
    \ Error: no property `canFind` for type `string`\\n/tmp/tmp1a_ept18.d(32): Error:\
    \ no property `canFind` for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp1a_ept18.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    auto arr=new char[](['A','E','I','O','U']);\n    int p=0;\n \
    \   foreach(e;arr)\n    {\n        if(word.rfind(e)!=-1)\n        {\n        \
    \    if(p==0) p=word.rfind(e);\n            else p=min(p,word.rfind(e));\n   \
    \     }\n    }\n    if(p==0) return \"\";\n    else return word[p..$];\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpx_9bfa6g.d(21): Error: cannot implicitly convert expression `[\\\
    'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']` of type `char[]` to `ulong`\\n/tmp/tmpx_9bfa6g.d(25):\
    \ Error: no property `rfind` for type `string`\\n/tmp/tmpx_9bfa6g.d(27): Error:\
    \ no property `rfind` for type `string`\\n/tmp/tmpx_9bfa6g.d(28): Error: undefined\
    \ identifier `min`, did you mean function `main`?\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpx_9bfa6g.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    if (word.length == 0) return \"\";\n    string vowels = \"aeiou\"\
    ;\n    string s = \"\";\n    foreach ( i, c; word )\n    {\n        if (i == 0\
    \ || i == word.length - 1) continue;\n        if (vowels.find(word[i]) == -1)\
    \ continue;\n        if (vowels.find(word[i-1]) != -1 || vowels.find(word[i+1])\
    \ != -1) continue;\n        if (s.length == 0)\n        {\n            s = word[i..$];\n\
    \        }\n        else\n        {\n            if (abs(s.length - i) < abs(s.length\
    \ - word.length))\n            {\n                s = word[i..$];\n          \
    \  }\n        }\n    }\n    return s.length == 0 ? \"\" : s[0..0];\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpn1whxnp2.d(27): Error: no property `find` for type `string`\\\
    n/tmp/tmpn1whxnp2.d(28): Error: no property `find` for type `string`\\n/tmp/tmpn1whxnp2.d(28):\
    \ Error: no property `find` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpn1whxnp2.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n\tenum Vowels : char[]\n\t{\n\t\t'a','e','i','o','u','A','E','I','O','U'\n\
    \t}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8g5fz491.d(23): Error: basic type expected, not `97U`\\n/tmp/tmp8g5fz491.d(23):\
    \ Error: no identifier for declarator `_error_`\\n/tmp/tmp8g5fz491.d(23): Error:\
    \ type only allowed if anonymous enum and no enum type\\n/tmp/tmp8g5fz491.d(23):\
    \ Error: if type, there must be an initializer\\n/tmp/tmp8g5fz491.d(23): Error:\
    \ found `97U` when expecting `,`\\n/tmp/tmp8g5fz491.d(23): Error: basic type expected,\
    \ not `,`\\n/tmp/tmp8g5fz491.d(23): Error: no identifier for declarator `_error_`\\\
    n/tmp/tmp8g5fz491.d(23): Error: type only allowed if anonymous enum and no enum\
    \ type\\n/tmp/tmp8g5fz491.d(23): Error: if type, there must be an initializer\\\
    n/tmp/tmp8g5fz491.d(23): Error: basic type expected, not `101U`\\n/tmp/tmp8g5fz491.d(23):\
    \ Error: no identifier for declarator `_error_`\\n/tmp/tmp8g5fz491.d(23): Error:\
    \ type only allowed if anonymous enum and no enum type\\n/tmp/tmp8g5fz491.d(23):\
    \ Error: if type, there must be an initializer\\n/tmp/tmp8g5fz491.d(23): Error:\
    \ found `101U` when expecting `,`\\n/tmp/tmp8g5fz491.d(23): Error: basic type\
    \ expected, not `,`\\n/tmp/tmp8g5fz491.d(23): Error: no identifier for declarator\
    \ `_error_`\\n/tmp/tmp8g5fz491.d(23): Error: type only allowed if anonymous enum\
    \ and no enum type\\n/tmp/tmp8g5fz491.d(23): Error: if type, there must be an\
    \ initializer\\n/tmp/tmp8g5fz491.d(23): Error: basic type expected, not `105U`\\\
    n/tmp/tmp8g5fz491.d(23): Error: no identifier for declarator `_error_`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8g5fz491.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    char closest = '\\0';\n\
    \    bool lastCharWasVowel = false;\n    bool firstVowel = true;\n    for (int\
    \ i = word.length - 1; i >= 0; i--)\n    {\n        if (vowels.canFind(word[i]))\n\
    \        {\n            closest = word[i];\n            firstVowel = false;\n\
    \            if (lastCharWasVowel)\n                break;\n        }\n      \
    \  else if (!firstVowel)\n            lastCharWasVowel = true;\n    }\n    return\
    \ closest ? \"\" ~ closest : \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2_mvtswl.d(25): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmp2_mvtswl.d(27): Error: no property\
    \ `canFind` for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp2_mvtswl.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    int found = word.rfind(\"a\");\n    if (found != -1) return \"\
    a\";\n    found = word.rfind(\"e\");\n    if (found != -1) return \"e\";\n   \
    \ found = word.rfind(\"i\");\n    if (found != -1) return \"i\";\n    found =\
    \ word.rfind(\"o\");\n    if (found != -1) return \"o\";\n    found = word.rfind(\"\
    u\");\n    if (found != -1) return \"u\";\n    found = word.rfind(\"A\");\n  \
    \  if (found != -1) return \"A\";\n    found = word.rfind(\"E\");\n    if (found\
    \ != -1) return \"E\";\n    found = word.rfind(\"I\");\n    if (found != -1) return\
    \ \"I\";\n    found = word.rfind(\"O\");\n    if (found != -1) return \"O\";\n\
    \    found = word.rfind(\"U\");\n    if (found != -1) return \"U\";\n    return\
    \ \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpznzp0sn6.d(21): Error: no property `rfind` for type `string`\\\
    n/tmp/tmpznzp0sn6.d(23): Error: no property `rfind` for type `string`\\n/tmp/tmpznzp0sn6.d(25):\
    \ Error: no property `rfind` for type `string`\\n/tmp/tmpznzp0sn6.d(27): Error:\
    \ no property `rfind` for type `string`\\n/tmp/tmpznzp0sn6.d(29): Error: no property\
    \ `rfind` for type `string`\\n/tmp/tmpznzp0sn6.d(31): Error: no property `rfind`\
    \ for type `string`\\n/tmp/tmpznzp0sn6.d(33): Error: no property `rfind` for type\
    \ `string`\\n/tmp/tmpznzp0sn6.d(35): Error: no property `rfind` for type `string`\\\
    n/tmp/tmpznzp0sn6.d(37): Error: no property `rfind` for type `string`\\n/tmp/tmpznzp0sn6.d(39):\
    \ Error: no property `rfind` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpznzp0sn6.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    int pos = 0;\n    for (int i\
    \ = word.length - 1; i >= 0; i--)\n    {\n        if (vowels.findFirstOf(word[i])\
    \ != -1)\n        {\n            if (i != 0 && i != word.length - 1)\n       \
    \     {\n                if (vowels.findFirstOf(word[i-1]) == -1 && vowels.findFirstOf(word[i+1])\
    \ == -1)\n                {\n                    pos = i;\n                  \
    \  break;\n                }\n            }\n        }\n    }\n    return pos\
    \ == 0 ? \"\" : word[pos..$];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpz8qhdg96.d(23): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmpz8qhdg96.d(25): Error: no property\
    \ `findFirstOf` for type `string`\\n/tmp/tmpz8qhdg96.d(29): Error: no property\
    \ `findFirstOf` for type `string`\\n/tmp/tmpz8qhdg96.d(29): Error: no property\
    \ `findFirstOf` for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpz8qhdg96.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    auto vowels = \"aeiou\";\n    immutable n = word.length;\n  \
    \  immutable m = vowels.length;\n    if (n <= 2)\n        return \"\";\n    else\
    \ \n    {\n        auto prev_vowel = \"\";\n        immutable best_idx = n;\n\
    \        for (immutable i = n - 1; i >= 0; --i)\n        {\n            auto ch\
    \ = word[i];\n            immutable idx = find(vowels, ch);\n            if (idx\
    \ != -1)\n            {\n                if (i < best_idx)\n                {\n\
    \                    best_idx = i;\n                    prev_vowel = ch;\n   \
    \             }\n            }\n            else \n            {\n           \
    \     if (best_idx != n)\n                    return prev_vowel;\n           \
    \ }\n        }\n        return \"\";\n    }\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9zk4qira.d(30): Error: cannot modify `immutable` expression `i`\\\
    n/tmp/tmp9zk4qira.d(33): Error: undefined identifier `find`, did you mean template\
    \ `Bind(alias Template, args1...)`?\\n/tmp/tmp9zk4qira.d(38): Error: cannot modify\
    \ `immutable` expression `best_idx`\\n/tmp/tmp9zk4qira.d(39): Error: cannot implicitly\
    \ convert expression `ch` of type `immutable(char)` to `string`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9zk4qira.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiouAEIOU\";\n    string closestVowel = \"\
    \";\n    double distance = double.infinity;\n    foreach(ch; word)\n    {\n  \
    \      if(vowels.find(ch) == -1)\n        {\n            continue;\n        }\n\
    \        size_t startPos = word.find(ch);\n        if(startPos == 0)\n       \
    \ {\n            continue;\n        }\n        size_t lastVowelPos = word.rfind(ch);\n\
    \        if(lastVowelPos == word.length - 1)\n        {\n            continue;\n\
    \        }\n        size_t endPos = word.rfindNot(ch);\n        if(endPos == startPos\
    \ - 1)\n        {\n            continue;\n        }\n        double currentDistance\
    \ = abs(double(endPos - startPos));\n        if(currentDistance == 0)\n      \
    \  {\n            return ch;\n        }\n        if(currentDistance < distance)\n\
    \        {\n            distance = currentDistance;\n            closestVowel\
    \ = ch;\n        }\n    }\n    return closestVowel;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplljkzmud.d(26): Error: no property `find` for type `string`\\\
    n/tmp/tmplljkzmud.d(30): Error: no property `find` for type `string`\\n/tmp/tmplljkzmud.d(35):\
    \ Error: no property `rfind` for type `string`\\n/tmp/tmplljkzmud.d(40): Error:\
    \ no property `rfindNot` for type `string`\\n/tmp/tmplljkzmud.d(53): Error: cannot\
    \ implicitly convert expression `ch` of type `immutable(char)` to `string`\\n/tmp/tmplljkzmud.d(48):\
    \ Error: cannot implicitly convert expression `ch` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplljkzmud.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    auto vowels = \"AEIOUaeiou\";\n    string result = \"\";\n  \
    \  int min_dist = INFINITY;\n    for (int i = 0; i < word.length; i++)\n    {\n\
    \        if (vowels.canFind(word[i]))\n        {\n            int consBefore =\
    \ -1;\n            int consAfter = -1;\n            foreach (j; 0 .. i)\n    \
    \        {\n                if (!vowels.canFind(word[j]))\n                {\n\
    \                    consBefore = j;\n                    break;\n           \
    \     }\n            }\n            foreach (j; i + 1 .. word.length)\n      \
    \      {\n                if (!vowels.canFind(word[j]))\n                {\n \
    \                   consAfter = j;\n                    break;\n             \
    \   }\n            }\n            if (consBefore != -1 && consAfter != -1)\n \
    \           {\n                if (min_dist > consAfter - consBefore)\n      \
    \          {\n                    min_dist = consAfter - consBefore;\n       \
    \             result = word[i .. i + 1];\n                }\n            }\n \
    \       }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpp4vhrsj1.d(23): Error: undefined identifier `INFINITY`\\n/tmp/tmpp4vhrsj1.d(26):\
    \ Error: no property `canFind` for type `string`\\n/tmp/tmpp4vhrsj1.d(32): Error:\
    \ no property `canFind` for type `string`\\n/tmp/tmpp4vhrsj1.d(40): Error: no\
    \ property `canFind` for type `string`\\n/tmp/tmpp4vhrsj1.d(42): Error: cannot\
    \ implicitly convert expression `j` of type `ulong` to `int`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp4vhrsj1.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    int vowel_ind = -1;\n    foreach(i, ch; word.reversed())\n  \
    \  {\n        if (isVowel(ch))\n        {\n            vowel_ind = i;\n      \
    \      break;\n        }\n    }\n    if (vowel_ind == -1) return \"\";\n    if\
    \ (isVowel(word[0]) || isVowel(word[$-1])) return \"\";\n    int con_ind = 0;\n\
    \    foreach(i, ch; word.reversed())\n    {\n        if (!isVowel(ch))\n     \
    \   {\n            con_ind = i;\n            break;\n        }\n    }\n    if\
    \ (vowel_ind < con_ind)\n    {\n        return word[$-vowel_ind-1..$-vowel_ind];\n\
    \    }\n    else\n    {\n        return \"\";\n    }\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc8oqh12p.d(22): Error: no property `reversed` for type `string`\\\
    n/tmp/tmpc8oqh12p.d(31): Error: undefined identifier `isVowel`\\n/tmp/tmpc8oqh12p.d(31):\
    \ Error: undefined identifier `isVowel`\\n/tmp/tmpc8oqh12p.d(33): Error: no property\
    \ `reversed` for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpc8oqh12p.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string letters = \"aeiouAEIOU\";\n    string consonants = \"\
    bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string closest_vowel = \"\"\
    ;\n    size_t closest_vowel_offset = word.length;\n    foreach(offset, char c;\
    \ word)\n    {\n        if(letters.count(c))\n        {\n            size_t left_consonant_offset\
    \ = word[0..offset].rfind(consonants);\n            size_t right_consonant_offset\
    \ = word[offset..$].find(consonants);\n            if(left_consonant_offset !=\
    \ -1 && right_consonant_offset != -1)\n            {\n                if(right_consonant_offset\
    \ < closest_vowel_offset)\n                {\n                    closest_vowel\
    \ = c;\n                    closest_vowel_offset = right_consonant_offset;\n \
    \               }\n            }\n        }\n    }\n    return closest_vowel;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2kxpmurc.d(27): Error: no property `count` for type `string`\\\
    n/tmp/tmp2kxpmurc.d(29): Error: no property `rfind` for type `string`\\n/tmp/tmp2kxpmurc.d(30):\
    \ Error: no property `find` for type `string`\\n/tmp/tmp2kxpmurc.d(35): Error:\
    \ cannot implicitly convert expression `c` of type `char` to `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2kxpmurc.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    int index = 0;\n    int index_res = 0;\n    int current_distance\
    \ = 0;\n    int min_distance = (int) word.length();\n    int distance_from_end\
    \ = 0;\n    //cout << word.length() << endl;\n    for (int i = word.length() -\
    \ 1; i >= 0; i--)\n    {\n        //cout << i << endl;\n        if (word[i] ==\
    \ 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U')\n\
    \        {\n            index = i;\n            //cout << index << endl;\n   \
    \         if (index < min_distance)\n            {\n                min_distance\
    \ = index;\n                index_res = i;\n            }\n        }\n    }\n\
    \    if (index_res == 0)\n    {\n        return \"\";\n    }\n    return word[index_res];\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3uybduk3.d(24): Error: C style cast illegal, use `cast(int)word.length()`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3uybduk3.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n  /*\n  // A solution with the STL\n  auto const vowels = \"aeiou\"\
    ;\n  auto const consonants = \"bcdfghjklmnpqrstvwxyz\";\n  auto const position\
    \ = find(word.rbegin(), word.rend(), findFirstOf(consonants, *--word.rend()));\n\
    \  if (position != word.rend())\n    return findFirstOf(vowels, *find(find(position,\
    \ word.rend(), findFirstOf(consonants, *position)) + 1, word.rend(), findFirstOf(vowels)));\n\
    \  return \"\";\n  */\n  \n  // A solution with ranges.\n  import std.range.primitives;\n\
    \  import std.range.iteration;\n  import std.array;\n  import std.algorithm.searching;\n\
    \  auto const vowels = ['a', 'e', 'i', 'o', 'u'];\n  auto const consonants = ['b',\
    \ 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v',\
    \ 'w', 'x', 'y', 'z'];\n  auto const wordRight = word.retro;\n  auto const wordRightWithoutVowels\
    \ = filter!(a => a.canFindOneOf(consonants))(wordRight);\n  if (wordRightWithoutVowels.empty)\n\
    \    return \"\";\n  auto const firstConsonant = wordRightWithoutVowels.front;\n\
    \  auto const restWithoutVowels = wordRightWithoutVowels.dropOne;\n  if (restWithoutVowels.empty)\n\
    \    return \"\";\n  auto const secondConsonant = restWithoutVowels.front;\n \
    \ auto const middle = restWithoutVowels.dropOne;\n  if (middle.empty)\n    return\
    \ \"\";\n  auto const firstVowel = middle.canFindOneOf(vowels);\n  if (firstVowel.empty)\n\
    \    return \"\";\n  auto const firstVowelDistance = firstVowel.front - secondConsonant;\n\
    \  auto const\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_aj4eqgs.d(55): Error: basic type expected, not `unittest`\\\
    n/tmp/tmp_aj4eqgs.d(55): Error: no identifier for declarator `_error_`\\n/tmp/tmp_aj4eqgs.d(55):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp_aj4eqgs.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n  string s = lowerCase(word);\n  int len = s.length;\n  int i = len\
    \ - 1;\n  while (i > 0) {\n    if (isVowel(s[i]) && !isVowel(s[i - 1])) {\n  \
    \    return word[i .. i];\n    }\n    i--;\n  }\n  return \"\";\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpacexc7qq.d(21): Error: undefined identifier `lowerCase`\\n/tmp/tmpacexc7qq.d(22):\
    \ Error: cannot implicitly convert expression `s.length` of type `ulong` to `int`\\\
    n/tmp/tmpacexc7qq.d(25): Error: undefined identifier `isVowel`\\n/tmp/tmpacexc7qq.d(25):\
    \ Error: undefined identifier `isVowel`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpacexc7qq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    //if(word.length < 3) return \"\";\n    string vowels = \"aeiou\"\
    ;\n    string cons = \"bcdfghjklmnpqrstvwxyz\";\n    string result = \"\";\n \
    \   int vidx = 0;\n    int cidx = 0;\n    int diff = 0;\n    int length = word.length;\n\
    \    int max = length;\n    for(int i = length - 1; i > 0; i--)\n    {\n     \
    \   if(vowels.findFirstOf(word[i]) == -1)\n        {\n            continue;\n\
    \        }\n        else\n        {\n            vidx = i;\n            break;\n\
    \        }\n    }\n    for(int i = vidx - 1; i > 0; i--)\n    {\n        if(cons.findFirstOf(word[i])\
    \ == -1)\n        {\n            continue;\n        }\n        else\n        {\n\
    \            cidx = i;\n            break;\n        }\n    }\n    if(vidx == 0\
    \ || cidx == 0)\n    {\n        return \"\";\n    }\n    else\n    {\n       \
    \ diff = abs(vidx - cidx);\n        for(int i = vidx - 1; i > 0; i--)\n      \
    \  {\n            if(vowels.findFirstOf(word[i]) == -1)\n            {\n     \
    \           continue;\n            }\n            else\n            {\n      \
    \          if(abs(i - cidx) < diff)\n                {\n                    vidx\
    \ = i;\n                    diff = abs(i - cidx);\n                }\n       \
    \     }\n        }\n        if(diff > max)\n        {\n            return \"\"\
    ;\n        }\n        else\n        {\n            result = word[vidx];\n    \
    \        return result;\n        }\n    }\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9t1bk80m.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp9t1bk80m.d(32): Error: no property `findFirstOf`\
    \ for type `string`\\n/tmp/tmp9t1bk80m.d(44): Error: no property `findFirstOf`\
    \ for type `string`\\n/tmp/tmp9t1bk80m.d(63): Error: no property `findFirstOf`\
    \ for type `string`\\n/tmp/tmp9t1bk80m.d(82): Error: cannot implicitly convert\
    \ expression `word[cast(ulong)vidx]` of type `immutable(char)` to `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9t1bk80m.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string[char] vowels = ['a':'a', 'e':'e', 'i':'i', 'o':'o', 'u':'u'];\n\
    \    immutable(char[]) consonants = \"bcdfghjklmnpqrstvwxyz\".dup;\n    auto reverse_word\
    \ = word.dup.reverse;\n    auto consonant_index = -1;\n    for(immutable(size_t)\
    \ i = 0; i < reverse_word.length; i++)\n    {\n        if(consonants.find(reverse_word[i])\
    \ != -1)\n        {\n            consonant_index = i;\n            break;\n  \
    \      }\n    }\n    if(consonant_index < 0)\n        return \"\";\n    auto start_vowel_index\
    \ = -1;\n    for(immutable(size_t) i = consonant_index + 1; i < reverse_word.length;\
    \ i++)\n    {\n        if(vowels.find(reverse_word[i]) != null)\n        {\n \
    \           start_vowel_index = i;\n            break;\n        }\n    }\n   \
    \ if(start_vowel_index < 0)\n        return \"\";\n    auto end_vowel_index =\
    \ -1;\n    for(immutable(size_t) i = consonant_index - 1; i >= 0; i--)\n    {\n\
    \        if(vowels.find(reverse_word[i]) != null)\n        {\n            end_vowel_index\
    \ = i;\n            break;\n        }\n    }\n    return (end_vowel_index == -1)\
    \ ? reverse_word[start_vowel_index] \n        : ((consonant_index - start_vowel_index)\
    \ < (end_vowel_index - consonant_index)) \n        ? reverse_word[start_vowel_index]\
    \ : reverse_word[end_vowel_index];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpz2ifbu6z.d(21): Error: cannot implicitly convert expression `[\\\
    'a\\':\\'a\\', \\'e\\':\\'e\\', \\'i\\':\\'i\\', \\'o\\':\\'o\\', \\'u\\':\\'u\\\
    ']` of type `char[char]` to `string[char]`\\n/tmp/tmpz2ifbu6z.d(23): Error: template\
    \ `std.typecons.reverse` cannot deduce function from argument types `!()(char[])`,\
    \ candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\n/tmp/tmpz2ifbu6z.d(25):\
    \ Error: cannot modify `immutable` expression `0LU`\\n/tmp/tmpz2ifbu6z.d(27):\
    \ Error: no property `find` for type `immutable(string)`\\n/tmp/tmpz2ifbu6z.d(36):\
    \ Error: cannot modify `immutable` expression `i`\\n/tmp/tmpz2ifbu6z.d(38): Error:\
    \ no property `find` for type `string[char]`\\n/tmp/tmpz2ifbu6z.d(40): Error:\
    \ cannot implicitly convert expression `i` of type `immutable(ulong)` to `int`\\\
    n/tmp/tmpz2ifbu6z.d(47): Error: cannot modify `immutable` expression `i`\\n/tmp/tmpz2ifbu6z.d(49):\
    \ Error: no property `find` for type `string[char]`\\n/tmp/tmpz2ifbu6z.d(51):\
    \ Error: cannot implicitly convert expression `i` of type `immutable(ulong)` to\
    \ `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz2ifbu6z.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    int wordLen = word.length;\n    string wordRev = word[$].dup.reversed;\n\
    \    string result = \"\";\n    for (int i = 0; i < wordLen; i++)\n    {\n   \
    \     if (wordRev[i] == 'a' || wordRev[i] == 'e' || wordRev[i] == 'i' ||\n   \
    \         wordRev[i] == 'o' || wordRev[i] == 'u' || wordRev[i] == 'A' ||\n   \
    \         wordRev[i] == 'E' || wordRev[i] == 'I' || wordRev[i] == 'O' ||\n   \
    \         wordRev[i] == 'U')\n        {\n            if (i - 1 >= 0 && i + 1 <\
    \ wordLen)\n            {\n                if (wordRev[i - 1] != 'a' && wordRev[i\
    \ - 1] != 'e' && wordRev[i - 1] != 'i' &&\n                    wordRev[i - 1]\
    \ != 'o' && wordRev[i - 1] != 'u' && wordRev[i - 1] != 'A' &&\n              \
    \      wordRev[i - 1] != 'E' && wordRev[i - 1] != 'I' && wordRev[i - 1] != 'O'\
    \ &&\n                    wordRev[i - 1] != 'U' && wordRev[i + 1] != 'a' && wordRev[i\
    \ + 1] != 'e' &&\n                    wordRev[i + 1] != 'i' && wordRev[i + 1]\
    \ != 'o' && wordRev[i + 1] != 'u' &&\n                    wordRev[i + 1] != 'A'\
    \ && wordRev[i + 1] != 'E' && wordRev[i + 1] != 'I' &&\n                    wordRev[i\
    \ + 1] != 'O' && wordRev[i + 1] != 'U')\n                {\n                 \
    \   result = wordRev[i .. i+1];\n                    break;\n                }\n\
    \            }\n        }\n    }\n    return result.reversed;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpe8dotg7l.d(21): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpe8dotg7l.d(22): Error: template `object.dup`\
    \ cannot deduce function from argument types `!()(immutable(char))`, candidates\
    \ are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/druntime/import/object.d(2889):\
    \        `object.dup(T : V[K], K, V)(T aa)`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/druntime/import/object.d(2925):\
    \        `object.dup(T : V[K], K, V)(T* aa)`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/druntime/import/object.d(4280):\
    \        `object.dup(T)(T[] a) if (!is(const(T) : T))`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/druntime/import/object.d(4296):\
    \        `object.dup(T)(const(T)[] a) if (is(const(T) : T))`\\n/tmp/tmpe8dotg7l.d(47):\
    \ Error: no property `reversed` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpe8dotg7l.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==>\
    \ \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\"\
    ) ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string ret;\n    size_t i = 0;\n\
    \    if (word.length == 0) return ret;\n    i = word.length - 1;\n    while (i--)\n\
    \    {\n        if (vowels.find(word[i]) != -1)\n        {\n            if (vowels.find(word[i-1])\
    \ == -1 && vowels.find(word[i+1]) == -1)\n            {\n                ret =\
    \ word[i..$];\n                break;\n            }\n        }\n    }\n    return\
    \ ret;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc1f58jt6.d(28): Error: no property `find` for type `string`\\\
    n/tmp/tmpc1f58jt6.d(30): Error: no property `find` for type `string`\\n/tmp/tmpc1f58jt6.d(30):\
    \ Error: no property `find` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpc1f58jt6.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
