name: HumanEval_68_pluck
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
  \ a branch of a tree that has non-negative integer nodes\n    your task is to pluck\
  \ one of the nodes and return it.\n    The plucked node should be the node with\
  \ the smallest even value.\n    If multiple nodes with the same smallest even value\
  \ are found return the node that has smallest index.\n\n    The plucked node should\
  \ be returned in a list, [ smalest_value, its index ],\n    If there are no even\
  \ values or the given array is empty, return [].\n\n    Example 1:\n        Input:\
  \ [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even\
  \ value, and 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n\
  \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
  \ 2 has the smallest index. \n\n    Example 3:\n        Input: []\n        Output:\
  \ []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
  \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
  \                     so we will choose the first zero, which has the smallest index.\n\
  \n    Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n\
  \    \n*/\nlong[] pluck(long[] arr) \n"
tests: "unittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
  \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
  \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
  \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
  \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
  \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
completions: ["{\n    // First find the smallest even number\n    auto res = arr.filter!(a\
    \ => a % 2 == 0).min;\n    // If the smallest number is not even return an empty\
    \ array\n    if (res % 2 != 0) \n        return [];\n    // \n    auto pos = arr.indexOf(res);\n\
    \    return [res, pos];\n}", "{\n    if (arr.length == 0)\n        return [];\n\
    \    const long min = arr[0];\n    size_t index = 0;\n    for (auto i = 1; i <\
    \ arr.length; ++i)\n    {\n        if (arr[i] < min)\n        {\n            index\
    \ = i;\n            break;\n        }\n    }\n    return [arr[index], index];\n\
    }", "{\n\tauto min = findMin(arr);\n\treturn [min, 1];\n}\nlong findMin(long[]\
    \ arr)\n{\n\tauto min = long.max;\n\tlong ret;\n\tforeach(n; arr)\n\t{\n\t\tif(n\
    \ < min && n % 2 == 0)\n\t\t{\n\t\t\tmin = n;\n\t\t\tret = n;\n\t\t}\n\t}\n\t\
    return ret;\n}", "{\n    // Your code here\n    if(arr.length == 0)\n        return\
    \ [];\n    long min = arr[0];\n    long minIndex = 0;\n    foreach(ref value;\
    \ arr)\n    {\n        if(value > 0 && value % 2 == 0)\n        {\n          \
    \  if(value < min)\n            {\n                min = value;\n            \
    \    minIndex = indexOf(arr, value);\n            }\n        }\n    }\n    if(min\
    \ == arr[0])\n        return [];\n    else\n        return [min, minIndex];\n}",
  "{\n  import std.algorithm : sort, filter, find;\n  import std.array : array;\n\
    \  import std.range : min, minElement;\n  // Sort array so we can find minElement\n\
    \  arr.sort();\n  // Filter out all values less than 2, then find minElement,\
    \ if empty return [].\n  auto evens = arr.filter!(a => a > 1).minElement!(a =>\
    \ a % 2);\n  return !evens ? [].array() : [evens[0], arr.find(evens[0])];\n}",
  "{\n    import std.conv : to;\n    long[] result = new long[2];\n    if (arr.length\
    \ == 0) return [].dup;\n    if (arr.length == 1) return arr.dup;\n    if (arr.length\
    \ == 2)\n    {\n        if (arr[0] < arr[1])\n        {\n            result[0]\
    \ = arr[0];\n            result[1] = 0;\n        }\n        else\n        {\n\
    \            result[0] = arr[1];\n            result[1] = 1;\n        }\n    \
    \    return result;\n    }\n    else\n    {\n        long[] new_arr = [0];\n \
    \       for (int i = 0; i < arr.length; i++)\n        {\n            if (i ==\
    \ 0)\n            {\n                if (arr[i] == 0)\n                {\n   \
    \                 new_arr[0] = arr[i];\n                    new_arr ~= i;\n  \
    \              }\n                else if (arr[i] % 2 == 0)\n                {\n\
    \                    new_arr[0] = arr[i];\n                    new_arr ~= i;\n\
    \                }\n            }\n            else\n            {\n         \
    \       if (arr[i] < new_arr[0])\n                {\n                    if (arr[i]\
    \ == 0)\n                    {\n                        new_arr[0] = arr[i];\n\
    \                        new_arr[1] = i;\n                    }\n            \
    \        else if (arr[i] % 2 == 0)\n                    {\n                  \
    \      new_arr[0] = arr[i];\n                        new_arr[1] = i;\n       \
    \             }\n                }\n            }\n        }\n        return new_arr;\n\
    \    }\n}", "{\n    long[] ret = new long[2];", "{\n    int arr_len = arr.length;\n\
    \    if (arr_len == 0)\n        return [];\n    long[] res = [long.max, 0];\n\
    \    for (int i = 0; i < arr_len; i++)\n    {\n        if (arr[i] % 2 == 0 &&\
    \ arr[i] < res[0])\n        {\n            res[0] = arr[i];\n            res[1]\
    \ = i;\n        }\n    }\n    if (res[0] == long.max)\n        return [];\n  \
    \  return res;\n}\n/*\n    Find all possible combinations of k numbers that add\
    \ up to a number n,\n    given that only numbers from 1 to 9 can be used and each\
    \ combination should be a unique set of numbers.", "{\n    if (arr.length == 0)\
    \ return new long[0];\n    long ret = 10001;\n    long min = 0;\n    long t;\n\
    \    for (long i = 0; i < arr.length; i++)\n    {\n        t = arr[i];\n     \
    \   if (t % 2 == 0 && t < ret)\n        {\n            ret = t;\n            min\
    \ = i;\n        }\n    }\n    if (ret == 10001) return new long[0];\n    return\
    \ new long[]{ret, min};\n}", "{\n    auto ret = [1234123123123123123, 1234123123123123123];\n\
    \    if (arr.length == 0) return ret;\n    auto any = false;\n    for (uint i\
    \ = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0)\n        {\n\
    \            any = true;\n            if (arr[i] < ret[0])\n            {\n  \
    \              ret[0] = arr[i];\n                ret[1] = i;\n            }\n\
    \        }\n    }\n    if (!any) ret[0] = ret[1] = 1234123123123123123;\n    return\
    \ ret;\n}", "{\n\tif (arr.length == 0)\n\t\treturn new long[0];\n\t\n\tlong minEven\
    \ = long.max;\n\tlong idx = long.max;\n\t\n\tfor (long i = 0; i < arr.length;\
    \ i++)\n\t{\n\t\tif (arr[i] % 2 == 0 && arr[i] < minEven)\n\t\t{\n\t\t\tminEven\
    \ = arr[i];\n\t\t\tidx = i;\n\t\t}\n\t}\n\t\n\treturn new long[] {minEven, idx};\n\
    }", "{\n    if (arr.length == 0)\n        return [];\n    long[] ret = [min(arr.filter!(a\
    \ => a % 2 == 0)), arr.indexOf(min(arr.filter!(a => a % 2 == 0)))];\n    return\
    \ ret;\n}", "{\n    import std.algorithm;\n    import std.range;\n    import std.numeric;\n\
    \    import std.stdio;\n    import std.conv;\n    import std.typecons;\n    import\
    \ std.math;\n    long[] result;\n    if (arr.length == 0)\n    {\n        return\
    \ result;\n    }\n    else\n    {\n        int[] even = arr.filter!(a => a % 2\
    \ == 0).sort.array;\n        int smallest = even[0];\n        writefln(\"smallest:\
    \ %s\", smallest);\n        if (even.length == 0)\n        {\n            return\
    \ result;\n        }\n        else\n        {\n            import std.algorithm;\n\
    \            import std.range;\n            import std.numeric;\n            import\
    \ std.stdio;\n            import std.conv;\n            import std.typecons;\n\
    \            import std.math;\n            auto index = arr.indexOf(smallest);\n\
    \            result ~= smallest;\n            result ~= index;\n            return\
    \ result;\n        }\n    }\n}\nimport std.algorithm;\nimport std.range;\nimport\
    \ std.numeric;\nimport std.stdio;\nimport std.conv;\nimport std.typecons;\nimport\
    \ std.math;", "{\n    // keep the smallest even value and its corresponding index\n\
    \    long smallestEven = long.max;\n    long index = -1;\n    long[] result =\
    \ [0, 0];", "{\n    if (arr.length == 0) return [];\n    auto minEven = (minval(arr.filter!(x\
    \ => x % 2 == 0)));\n    auto index = arr.find(minEven);\n    if (index is size_t.max)\
    \ return [];\n    return [minEven, index];\n}", "{\n\tif (arr.length == 0) return\
    \ new long[0];\n\tlong[] newArr = arr.filter!(i => i % 2 == 0).array;\n\treturn\
    \ newArr.length == 0 ? new long[0] : [newArr[0], newArr.indexOf(newArr[0])];\n\
    }", "{\n    if ( arr.length == 0 ) return [0,0];\n    long[] result = [arr[0],0];\n\
    \    foreach(i,item; arr)\n    {\n        if ( item%2 == 0 && item < result[0]\
    \ ) \n        {\n            result[0] = item;\n            result[1] = i;\n \
    \       }\n    }\n    if ( result[0] == arr[0] ) return [0,0];\n    return result;\n\
    }", "{\n    if (arr.length == 0) \n        return [];\n    long min = int.max;\n\
    \    long minIndex = int.max;\n    foreach (index, value; arr)\n    {\n      \
    \  if (value % 2 == 0 && value < min)\n        {\n            min = value;\n \
    \           minIndex = index;\n        }\n    }\n    if (min == int.max)\n   \
    \     return [];\n    return [min, minIndex];\n}", "{\n    if (arr.length == 0)\
    \ return new long[0];\n    if (arr.length == 1) return arr[0] % 2 == 0 ? new long[]\
    \ { arr[0], 0 } : new long[0];\n    long min = arr[0] % 2 == 0 ? arr[0] : std.numeric.INT_MAX;\n\
    \    long idx = -1;\n    foreach (i, e; arr)\n    {\n        if (e % 2 == 0 &&\
    \ e < min)\n        {\n            min = e;\n            idx = i;\n        }\n\
    \    }\n    return idx == -1 ? new long[0] : new long[] { min, idx };\n}", "{\n\
    \    if (arr.length == 0) return [];"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
