name: HumanEval_14_all_prefixes
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n Return list of all prefixes\
  \ from shortest to longest of the input string\n    >>> all_prefixes('abc')\n  \
  \  ['a', 'ab', 'abc']\n    \n*/\nstring[] all_prefixes(string string) \n"
tests: "unittest\n{\n    alias candidate = all_prefixes;\n\n    assert(candidate(\"\
  \") == []);\n    assert(candidate(\"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\"\
  , \"asdfg\", \"asdfgh\"]);\n    assert(candidate(\"WWW\") == [\"W\", \"WW\", \"\
  WWW\"]);\n}\nvoid main(){}"
completions: ["{\n    return sequence(0, string.length).map!(i => string[0..i])();\n\
    }", "{\n    import std.algorithm;\n    return string.byChunk(1).takeWhile!(x =>\
    \ x.length == 1).scan!((ref a, b) => a~b).to!string[];\n}", "{\n    import std.algorithm;\n\
    \    return iota(string.length + 1).map!((i) => string[0 .. i]).array;\n}", "{\n\
    \    auto ret = new string[];\n    foreach(i; 0 .. string.length)\n    {\n   \
    \     ret ~= string[0 .. i];\n    }\n    return ret;\n}", "{\n    //return map!(x\
    \ => string[0..x],iota(0,string.length));\n    auto result = new string[];\n \
    \   foreach(x;iota(0,string.length))\n    {\n        result ~= string[0..x];\n\
    \    }\n    return result;\n}", "{\n    int start = 0;\n    int stop = string.length;\n\
    \    string[] result;\n    foreach(i; 0..stop)\n    {\n        result ~= string[start..i];\n\
    \    }\n    return result;\n}", "{\n\tstring[] ret = new string[$];\n\tforeach(0,string.length,(int\
    \ i)\n\t{\n\t\tret ~= string[0..i];\n\t})\n\treturn ret;\n}\n/*\n Return list\
    \ of all suffixes from shortest to longest of the input string\n    >>> all_suffixes('abc')\n\
    \    ['c', 'bc', 'abc']\n*/\nstring[] all_suffixes(string string) \n{\n\tstring[]\
    \ ret = new string[$];\n\tforeach(0,string.length,(int i)\n\t{\n\t\tret ~= string[i..string.length];\n\
    \t})\n\treturn ret;\n}\n/*\n Return list of all substrings from shortest to longest\
    \ of the input string\n    >>> all_substrings('abc')\n    ['a', 'ab', 'abc', 'b',\
    \ 'bc', 'c']\n*/\nstring[] all_substrings(string string) \n{\n\tstring[] ret =\
    \ new string[$];\n\tforeach(0,string.length,(int i)\n\t{\n\t\tforeach(i,string.length,(int\
    \ j)\n\t\t{\n\t\t\tret ~= string[i..j];\n\t\t})\n\t})\n\treturn ret;\n}\n/*\n\
    \ Return list of all prefixes from shortest to longest of the input string\n \
    \   >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n*/\nstring[] all_prefixes(string\
    \ string) \n{\n\tstring[] ret = new string[$];\n\tforeach(0,string.length,(int\
    \ i)\n\t{\n\t\tret ~= string[0..i];\n\t})\n\treturn ret;\n}", "{\n\timport std.typecons;\n\
    \timport std.math;\n\tsize_t longest_prefix = string.length;\n\talias typeof(this)\
    \ result;\n\t\n\treturn iota(1, longest_prefix + 1).map!(size_t i => string[0\
    \ .. i]).array;\n}", "{\n    auto result = [];\n    foreach (prefix; 0 .. string.length\
    \ + 1) \n    {\n        result ~= string[0 .. prefix];\n    }\n    return result;\n\
    }\n/*\n Return list of all suffixes from shortest to longest of the input string\n\
    \    >>> all_suffixes('abc')\n    ['c', 'bc', 'abc']\n*/\nstring[] all_suffixes(string\
    \ string) \n{\n    auto result = [];\n    foreach (suffix; 0 .. string.length\
    \ + 1) \n    {\n        result ~= string[string.length - suffix .. string.length];\n\
    \    }\n    return result;\n}\n/*\n Return longest common prefix of two strings,\
    \ e.g.\n    >>> lcp('abc', 'abd')\n    'ab'\n*/\nstring lcp(string stringA, string\
    \ stringB) \n{\n    auto prefixesA = all_prefixes(stringA);\n    auto prefixesB\
    \ = all_prefixes(stringB);\n    foreach (prefixA; prefixesA) \n    {\n       \
    \ foreach (prefixB; prefixesB) \n        {\n            if (prefixA == prefixB)\
    \ \n            {\n                return prefixA;\n            }\n        }\n\
    \    }\n    return \"\";\n}", "    if (string.length)\n    {\n        return map!((x){return\
    \ string[0..x];})(iota(string.length));\n    }\n    else\n    {\n        return\
    \ [];\n    }\n/*\n    Return tuple of the longest common prefix and the strings\
    \ with prefix removed\n    >>> longest_common_prefix(['abcd', 'ab', 'abde'])\n\
    \    ('ab', ['cd', '', 'de'])\n*/\ntuple!(string, string[]) longest_common_prefix(string[]\
    \ strings)\n{\n    return fold!((a, x){\n        if (a.length == 0)\n        {\n\
    \            return a;\n        }\n        else\n        {\n            auto prefixes\
    \ = all_prefixes(x);\n            return list_zip(prefixes, zip(iota(prefixes.length),\
    \ a))\n                .filter!((x){return x[0] == x[1][1];})\n              \
    \  .front\n                .map!((x){return x[0];})\n                .map!((x){return\
    \ (x, a.map!((y){return y[0].length < x.length ? y[0] : y[0][x.length..];}));})\n\
    \                .orElse(a)\n                .get;\n        }\n    })((\"\", map!((x){return\
    \ (x,x);})(strings)))(strings);\n}\n/*\n    Generate suffixes of a string\n  \
    \  >>> suffixes('abcd')\n    ['abcd', 'bcd', 'cd', 'd']\n*/\nstring[] suffixes(string\
    \ s)\n{\n    if (s.length)\n    {\n        return map!((x){return s[x..];})(iota(s.length));\n\
    \    }\n    else\n    {\n        return [];\n    }\n}\n/*\n    Remove common prefix\
    \ from the front of a string\n    >>> remove_prefix('abc', 'ab')\n    'c'\n*/\n\
    string remove_prefix(string string, string prefix)\n{\n    if (string.startsWith(prefix))\n\
    \    {\n        return string[prefix.length..];\n    }\n    else\n    {\n    \
    \    return string", "{\n    string[] result;\n    foreach(immutable index, immutable\
    \ char c; string)\n    {\n        result ~= string[0..index];\n    }\n    return\
    \ result;\n}", "{\n    import std.stdio;\n    immutable min_prefix_length = 1;\n\
    \    immutable max_prefix_length = string.length;\n    immutable expected_length_of_result\
    \ = max_prefix_length - min_prefix_length + 1;\n    string[] result;\n    result.length\
    \ = expected_length_of_result;\n    assert(result.length == expected_length_of_result);\n\
    \    uint index = 0;\n    foreach(prefix_length; min_prefix_length .. max_prefix_length\
    \ + 1)\n    {\n        assert(index < result.length);\n        result[index] =\
    \ string[0 .. prefix_length];\n        index++;\n    }\n    assert(index == result.length);\n\
    \    return result;\n}", "{\n    string[] ret;\n    foreach(i; 0 .. string.length)\n\
    \    {\n        ret ~= string[0 .. i];\n    }\n    return ret;\n}\n// https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior\n\
    // Recursively expand out all the arguments", "{\n    int len = string.length;\n\
    \    string[] buffer = new string[len];\n    foreach (immutable i; 0 .. len)\n\
    \    {\n        buffer[i] = string[0 .. i];\n    }\n    return buffer;\n}", "{\n\
    \    size_t length = string.length;\n    size_t number_of_substrings = length+1;\n\
    \    string[] string_array;\n    string_array.length = number_of_substrings;\n\
    \    size_t i = 0;\n    foreach(substring; 0..length) \n    {\n        string_array[i]\
    \ = string[0..substring];\n        i++;\n    }\n    return string_array;\n}\n\
    /*\n Return list of all substrings from shortest to longest of the input string\n\
    \    >>> all_substrings('abc')\n    ['a', 'ab', 'abc', 'b', 'bc', 'c']\n    \n\
    */\nstring[] all_substrings(string string) \n{\n    size_t length = string.length;\n\
    \    size_t number_of_substrings = pow(2, length) - 1;\n    string[] string_array;\n\
    \    string_array.length = number_of_substrings;\n    size_t i = 0;\n    foreach(start;\
    \ 0..length) \n    {\n        foreach(end; start..length) \n        {\n      \
    \      string_array[i] = string[start..end];\n            i++;\n        }\n  \
    \  }\n    return string_array;\n}\n/*\n Return list of all substrings from shortest\
    \ to longest of the input string\n    >>> all_substrings('abc')\n    ['a', 'ab',\
    \ 'abc', 'b', 'bc', 'c']\n    \n*/\nstring[] all_substrings_v2(string string)\
    \ \n{\n    size_t length = string.length;\n    size_t number_of_substrings = pow(2,\
    \ length) - 1;\n    string[] string_array;\n    string_array.length = number_of_substrings;\n\
    \    size_t i = 0;\n    foreach(element; string) \n    {\n        foreach(end;\
    \ 0..length) \n        {\n            string_array[i] = string[element..end];\n\
    \            i++;\n        }\n    }\n    return string_array;\n}\n// -----------------------------------------------------------\n\
    import std.stdio;", "{\n    string[] result;\n    foreach(immutable i; 0 .. string.length)\n\
    \    {\n        result ~= string[0 .. i];\n    }\n    return result;\n}\n/*\n\
    \ Return list of all suffixes from shortest to longest of the input string\n \
    \   >>> all_suffixes('abc')\n    ['c', 'bc', 'abc']\n    \n*/\nstring[] all_suffixes(string\
    \ string) \n{\n    string[] result;\n    foreach(immutable i; 0 .. string.length)\n\
    \    {\n        result ~= string[i .. $];\n    }\n    return result;\n}\n/*\n\
    \ Return the longest common prefix of two strings\n    >>> lcp('abb', 'ab')\n\
    \    'ab'\n    \n*/\nstring lcp(string a, string b) \n{\n    string[] prefixes_a\
    \ = all_prefixes(a);\n    string[] prefixes_b = all_prefixes(b);\n    foreach(immutable\
    \ prefix; prefixes_a)\n    {\n        if(prefix in prefixes_b)\n        {\n  \
    \          return prefix;\n        }\n    }\n    return \"\";\n}\n/*\n Return\
    \ the longest common suffix of two strings\n    >>> lcs('abb', 'ab')\n    'b'\n\
    \    \n*/\nstring lcs(string a, string b) \n{\n    string[] suffixes_a = all_suffixes(a);\n\
    \    string[] suffixes_b = all_suffixes(b);\n    foreach(immutable suffix; suffixes_a)\n\
    \    {\n        if(suffix in suffixes_b)\n        {\n            return suffix;\n\
    \        }\n    }\n    return \"\";\n}\n/*\n Return the longest common substring\
    \ of two strings\n    >>> lcss('abb', 'ab')\n    'ab'\n    \n*/\nstring lcss(string\
    \ a, string b) \n{\n    auto prefix = lcp(a, b);\n    auto suffix = lcs(a, b);\n\
    \    if(prefix.length == a.length && suffix.length == b.length)\n    {\n     \
    \   return a;\n    }\n    if(prefix.", "{\n    string[] ret;\n    int len = string.length;\n\
    \    for (int i = 0; i < len; i++)\n    {\n        ret ~= string[0..i];\n    }\n\
    \    return ret;\n}", "{\n    auto res = [];\n    while(string.length > 0) \n\
    \    {\n        res ~= string;\n        string = string[0..$-1];\n    }\n    return\
    \ res;\n}", "{\n  string[] res;\n  foreach(immutable i; 0 .. string.length)\n\
    \    res ~= string[0 .. i];\n  return res;\n}", "{\n    string[] result;\n   \
    \ foreach(size_t i; 0 .. string.length)\n    {\n        result ~= string[0 ..\
    \ i];\n    }\n    return result;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
