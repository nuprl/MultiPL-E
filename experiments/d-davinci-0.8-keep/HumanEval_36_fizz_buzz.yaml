name: HumanEval_36_fizz_buzz
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\nReturn the number of times the\
  \ digit 7 appears in integers less than n which are divisible by 11 or 13.\n   \
  \ >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n\
  \    3\n    \n*/\nlong fizz_buzz(long n) \n"
tests: "unittest\n{\n    alias candidate = fizz_buzz;\n\n    assert(candidate(50L)\
  \ == 0L);\n    assert(candidate(78L) == 2L);\n    assert(candidate(79L) == 3L);\n\
  \    assert(candidate(100L) == 3L);\n    assert(candidate(200L) == 6L);\n    assert(candidate(4000L)\
  \ == 192L);\n    assert(candidate(10000L) == 639L);\n    assert(candidate(100000L)\
  \ == 8026L);\n}\nvoid main(){}"
completions: ["{\n  import std.stdio;\n  long result = 0;\n  for (int i = 0; i <=\
    \ n; i++)\n  {\n    if (i % 11 == 0 || i % 13 == 0)\n    {\n      immutable total\
    \ = i.to!string;\n      for (long j = 0; j < total.length; j++)\n      {\n   \
    \     if (total[j] == '7')\n        {\n          result++;\n        }\n      }\n\
    \    }\n  }\n  return result;\n}", "{\n    long result = 0;\n    foreach(i; 1..n)\
    \ \n    {\n        if (i % 11 == 0 || i % 13 == 0) \n        {\n            result\
    \ += count(to!string(i), '7');\n        }\n    }\n    return result;\n}", "{\n\
    \    int i = 0;\n    int count = 0;\n    string s = \"\";\n    for (i = 11; i\
    \ < n; i = i + 11)\n    {\n        s = to!string(i);\n        if (s.count('7')\
    \ > 0)\n        {\n            count = count + 1;\n        }\n    }\n    for (i\
    \ = 13; i < n; i = i + 13)\n    {\n        s = to!string(i);\n        if (s.count('7')\
    \ > 0)\n        {\n            count = count + 1;\n        }\n    }\n    return\
    \ count;\n}", "{\n  long fizzes = 0;", "{\n    int numTimes = 0;\n    for (long\
    \ x = 7; x < n; x+=7)\n    {\n        if ((x % 11 == 0) || (x % 13 == 0))\n  \
    \      {\n            numTimes++;\n        }\n    }\n    return numTimes;\n}",
  "{\n\tint counter = 0;\n\tint digits[] = new int[6];\n\tfor (int i = 11; i < n;\
    \ i++) \n\t{\n\t\tif (i % 11 == 0 || i % 13 == 0) \n\t\t{\n\t\t\tdigits = i.toString().toArray.map!(a\
    \ => a.toInt).array;\n\t\t\tfor (int j = 0; j < digits.length; j++) \n\t\t\t{\n\
    \t\t\t\tif (digits[j] == 7) \n\t\t\t\t{\n\t\t\t\t\tcounter += 1;\n\t\t\t\t}\n\t\
    \t\t}\n\t\t}\n\t}\n\treturn counter;\n}", "{\n  long count = 0;\n  foreach(int\
    \ i; 0..n)\n  {\n    if(i%11 == 0 || i%13 == 0)\n    {\n      count += countDigits(i,7);\n\
    \    }\n  }\n  return count;\n}", "{\n\tlong res = 0;\n\tfor (long i = 7; i <\
    \ n; i++)\n\t{\n\t\tif ((i % 11 == 0) || (i % 13 == 0))\n\t\t{\n\t\t\tstring si\
    \ = i.to!string;\n\t\t\tforeach (c; si)\n\t\t\t{\n\t\t\t\tif (c == '7')\n\t\t\t\
    \t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}", "{\n    long count = 0;\n\
    \    long i = 0;\n    while (i < n) \n    {\n        if (i % 11 == 0 || i % 13\
    \ == 0) \n        {\n            ulong x = i;\n            while (x != 0) \n \
    \           {\n                if (x % 10 == 7) \n                {\n        \
    \            count++;\n                }\n                x /= 10;\n         \
    \   }\n        }\n        i++;\n    }\n    return count;\n}\n/*\n    Find the\
    \ sum of all the positive integers which cannot be written as the sum of two abundant\
    \ numbers.\n    >>> a(1)\n    0\n    >>> a(100)\n    0\n    >>> a(200)\n    0\n\
    \    >>> a(300)\n    0\n    >>> a(400)\n    1\n    >>> a(2000)\n    1\n    >>>\
    \ a(4000)\n    5\n    >>> a(8000)\n    9\n    >>> a(16000)\n    31\n*/\nlong a(long\
    \ n) \n{\n    long g_sum = 0;\n    int abundant_numbers = [12];\n    int i = 0;\n\
    \    while (i < n) \n    {\n        if (is_abundant(i)) \n        {\n        \
    \    abundant_numbers ~= i;\n        }\n        i++;\n    }\n    i = 0;\n    while\
    \ (i < n) \n    {\n        int j = 0;\n        long sum = 0;\n        while (j\
    \ < abundant_numbers.length) \n        {\n            sum += abundant_numbers[j];\n\
    \            if (sum == i) \n            {\n                break;\n         \
    \   }\n            j++;\n        }\n        if (sum != i) \n        {\n      \
    \      g_sum += i;\n        }\n        i++;\n    }\n    return g_sum;\n}\n/*\n\
    \    Given the three smallest primes: a = 2, b = 3, c = 5, we can construct a\
    \ sequence of successive primes by inserting 3 between 2 and 3, 5 between 3 and\
    \ 5, 7 between 5 and 7, and so on. The resulting sequence is:", "{\n    long count=0;\n\
    \    long i=1;\n    while(i<n)\n    {\n        if(i%11==0 || i%13==0)\n      \
    \  {\n            count += to!(string)(i).count(\"7\");\n        }\n        i++;\n\
    \    }\n    return count;\n}", "{\n\tassert(n >=0);\n\tlong sum = 0;\n\tfor (size_t\
    \ i =0; i < n; ++i) {\n\t\tif (((i % 11) == 0) || ((i % 13) == 0)) {\n\t\t\tint\
    \ x = i;\n\t\t\twhile (x > 0) {\n\t\t\t\tif (x % 10 == 7) {\n\t\t\t\t\t++sum;\n\
    \t\t\t\t}\n\t\t\t\tx /= 10;\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}", "{\n    enum\
    \ { step = 11 * 13, mul = step / 7 };\n    auto s = iota(step).array;\n    auto\
    \ m = iota(mul).array;\n    foreach (immutable i; s)\n        foreach (immutable\
    \ j; m)\n            if (i * j >= n) return i * j;\n}", "{\n    long i;\n    long\
    \ x;\n    long count = 0;\n    for (i = 0; i < n; i++) \n    {\n        if ((i\
    \ % 11 == 0) || (i % 13 == 0)) \n        {\n            x = i;\n            while\
    \ (x > 0) \n            {\n                if (x % 10 == 7) \n               \
    \ {\n                    count += 1;\n                }\n                x /=\
    \ 10;\n            }\n        }\n    }\n    return count;\n}\n/*\nReturn a function\
    \ which takes the power of a base number.\n    >>> square = power(2)\n    >>>\
    \ square(3)\n    9\n    >>> cube = power(3)\n    >>> cube(2)\n    8\n*/", "{\n\
    \    long sum_fizz = n / 11;\n    long sum_buzz = n / 13;\n    long sum_fizz_buzz\
    \ = n / ((11 * 13) );\n    long sum_no_fizz_buzz = n - sum_fizz - sum_buzz + sum_fizz_buzz;\n\
    \    long sum_7_fizz = sum_fizz * countDigit(7, 11);\n    long sum_7_buzz = sum_buzz\
    \ * countDigit(7, 13);\n    long sum_7_fizz_buzz = sum_fizz_buzz * countDigit(7,\
    \ 11 * 13);\n    long sum_7_no_fizz_buzz = sum_no_fizz_buzz * countDigit(7, 1);\n\
    \    return sum_7_fizz + sum_7_buzz + sum_7_fizz_buzz + sum_7_no_fizz_buzz;\n}",
  "{\n    return sum(map!(c => c == '7' ? 1 : 0)(iota(n)).filter!(n => n % 11 == 0\
    \ || n % 13 == 0));\n}", "{\n\tlong b=1;\n\tlong a=0;\n\tforeach(i;0..n)\n\t{\n\
    \t\tlong k=i;\n\t\twhile(k!=0)\n\t\t{\n\t\t\tif((k%10)==7 && ((k%11)==0 || (k%13)==0))\n\
    \t\t\t{\n\t\t\t\ta++;\n\t\t\t}\n\t\t\tk/=10;\n\t\t}\n\t}\n\treturn a;\n}\n/*\n\
    Given two integers, return a new integer composed of the first integer repeated\
    \ some number of times.", "{\n    long count = 0;\n    for (int i = 1; i < n;\
    \ i++)\n    {\n        if ((i % 11 == 0) || (i % 13 == 0))\n        {\n      \
    \      long num = i;\n            while (num > 0)\n            {\n           \
    \     if (num % 10 == 7)\n                {\n                    count++;\n  \
    \              }\n                num /= 10;\n            }\n        }\n    }\n\
    \    return count;\n}\n/*\n    The Euler totient function phi(m) is defined as\
    \ the number of positive integers r (1 <= r < m) that are coprime to m.\n    >>>\
    \ euler_totient(7)\n    6\n    >>> euler_totient(17)\n    16\n*/\nlong euler_totient(long\
    \ m) \n{\n    long count = 0;\n    for (int i = 1; i < m; i++)\n    {\n      \
    \  if (gcd(i, m) == 1)\n        {\n            count++;\n        }\n    }\n  \
    \  return count;\n}\n/*\n    Given a number of digits in a string. Add digits\
    \ up and return the value as a string.\n    >>> digital_root(132189)\n    \"6\"\
    \n    >>> digital_root(493193)\n    \"2\"\n*/\nstring digital_root(long n) \n\
    {\n    long sum = 0;\n    while (n > 0)\n    {\n        sum += n % 10;\n     \
    \   n /= 10;\n    }\n    string sum_str = to!string(sum);\n    if (sum_str.length\
    \ == 1)\n    {\n        return sum_str;\n    }\n    else\n    {\n        return\
    \ digital_root(to!long(sum_str));\n    }\n}\n/*\n    Given a string of characters\
    \ and a single character, replace all the occurrences of the character in the\
    \ string with the single character.\n    >>> replace(\"But as he spake he drew\
    \ the good sword from its scabbard, and smote a heathen knight, Jusssstin of thee\
    \ Iron Valley.\", 'e', 'o')\n    \"But as ho spako ho drew th good sword from\
    \ its sc", "{\n    if (n < 0)\n        return -1;\n    if (n == 0)\n        return\
    \ 0;\n    auto t = tuple!(int, \"\", \"fizz\", \"buzz\", \"fizzbuzz\")(1, \"\"\
    , \"fizz\", \"buzz\", \"fizzbuzz\");\n    long ret = 0;\n    for (long i = 1;\
    \ i < n; i++)\n    {\n        if (i % 11 == 0 || i % 13 == 0)\n        {\n   \
    \         auto s = (i % 15 == 0) ? t[4] : (i % 3 == 0) ? t[2] : (i % 5 == 0) ?\
    \ t[3] : t[1];\n            ret += count(s, '7');\n        }\n    }\n    return\
    \ ret;\n}", "{\n\tlong count;\n\t\n\tstatic immutable long numbers[3] = [11, 13,\
    \ -1];\n\tauto i = 0;\n\tfor (auto n_ : numbers)\n\t{\n\t\tauto n_copy = n_;\n\
    \t\tif (n_ == -1)\n\t\t\tbreak;\n\t\twhile (n_copy <= n)\n\t\t{\n\t\t\tif (n_copy\
    \ % 11 == 0 || n_copy % 13 == 0)\n\t\t\t{\n\t\t\t\twhile (n_copy)\n\t\t\t\t{\n\
    \t\t\t\t\tauto d = n_copy % 10;\n\t\t\t\t\tif (d == 7)\n\t\t\t\t\t\tcount++;\n\
    \t\t\t\t\tn_copy /= 10;\n\t\t\t\t}\n\t\t\t}\n\t\t\tn_copy += n_;\n\t\t}\n\t}\n\
    \treturn count;\n}", "{\n  int count = 0;\n  foreach(i; 0 .. n)\n    if(i % 11\
    \ == 0 || i % 13 == 0)\n    {\n      if( i % 10 == 7 ||  i / 10 == 7)\n      \
    \  count++;\n    }\n    return count;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
