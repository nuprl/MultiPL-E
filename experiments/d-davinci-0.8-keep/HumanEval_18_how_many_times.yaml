name: HumanEval_18_how_many_times
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
  \ substring can be found in the original string. Count overlaping cases.\n    >>>\
  \ how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n  \
  \  >>> how_many_times('aaaa', 'aa')\n    3\n    \n*/\nlong how_many_times(string\
  \ string, string substring) \n"
tests: "unittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
  \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
  cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n\
  }\nvoid main(){}"
completions: ["{\n    long counter = 0;\n    long substring_length = substring.length;\n\
    \    long string_length = string.length;\n    long i = 0;\n    while (i < string_length)\
    \ \n    {\n        long start = i;\n        long end = i + substring_length;\n\
    \        if (string[start..end] == substring) \n        {\n            counter++;\n\
    \            i = end;\n        } \n        else \n        {\n            i = start\
    \ + 1;\n        }\n    }\n    return counter;\n}\n \n \n/*\nFind the first non-repeating\
    \ character in the given string.\n    >>> first_non_repeating_character('')\n\
    \    -1\n    >>> first_non_repeating_character('aaaaa')\n    -1\n    >>> first_non_repeating_character('abacddbec')\n\
    \    3\n    >>> first_non_repeating_character('abcabc')\n    -1\n    >>> first_non_repeating_character('aabbcc')\n\
    \    -1\n    >>> first_non_repeating_character('abcdefghijklmnopqrstuvwxyz')\n\
    \    0\n    >>> first_non_repeating_character('abacddbec')\n    3", "{\n    if\
    \ (string.length == 0 || substring.length == 0) return 0;\n    const long sl =\
    \ string.length;\n    const long subl = substring.length;\n    long count = 0;\n\
    \    long it = 0;\n    while (it < sl) \n    {\n        // Check if it's a match\n\
    \        auto found = string.find(substring, it);\n        if (found < 0) break;\n\
    \        // if found, add 1 and move the search pointer forward by 'subl'\n  \
    \      it = found + subl;\n        count++;\n    }\n    return count;\n}", "{\n\
    \    long count = 0;\n    if(substring.length == 0) return 0;\n    for(long i\
    \ = 0; i < string.length - substring.length + 1; i++) \n    {\n        if(string[i..i+substring.length]\
    \ == substring) \n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Reverse the string.\n    >>> reverse('c')\n    'c'\n    >>>\
    \ reverse('ab')\n    'ba'\n    >>> reverse('abcd')\n    'dcba'\n*/\nstring reverse(string\
    \ string) \n{\n    // version 1\n    return string.idup.reverse;\n    // version\
    \ 2\n    // return string.reverse;\n}\n/*\n Check if it is a palindrome.\n   \
    \ >>> is_palindrome('c')\n    True\n    >>> is_palindrome('ab')\n    False\n \
    \   >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('abba')\n    True\n\
    */", "{\n    long count = 0;\n    long pos = 0;\n    while(true)\n    {\n    \
    \    long found_pos = string.find(substring, pos);\n        if(found_pos == -1)\n\
    \            break;\n        count++;\n        pos = found_pos + 1;\n    }\n \
    \   return count;\n}", "{\n    long counter = 0;\n    long tmp = 0;\n    for (int\
    \ i = 0; i < string.length; i++)\n    {\n        for (int j = 0; j < substring.length;\
    \ j++)\n        {\n            if (string[i+j] == substring[j])\n            {\n\
    \                tmp++;\n            }\n            else\n            {\n    \
    \            tmp = 0;\n                break;\n            }\n        }\n    \
    \    if (tmp == substring.length)\n        {\n            counter++;\n       \
    \     tmp = 0;\n        }\n    }\n    return counter;\n}", "    if (string.length\
    \ >= substring.length)\n{\n    long ans = 0;\n    foreach (int i; 0 .. string.length\
    \ - substring.length + 1) \n        if (string[i .. i + substring.length - 1]\
    \ == substring) \n        {\n            ans += 1;\n        }\n    return ans;\n\
    }", "{\n    long count = 0;\n    size_t pos = 0;\n    long len = substrlen(substring);\n\
    \    size_t len_of_string = strings.length(string);\n    while (pos + len <= len_of_string)\
    \ \n    {\n        auto part = substr(string, pos, len);\n        if (part ==\
    \ substring) \n        {\n            count += 1;\n            pos += len;\n \
    \       }\n        else \n        {\n            pos += 1;\n        }\n    }\n\
    \    return count;\n}\nlong how_many_times2(string string, string substring) \n\
    {\n    long count = 0;\n    size_t len = substrlen(substring);\n    size_t len_of_string\
    \ = strings.length(string);\n    foreach (i; 0 .. len_of_string - len + 1) \n\
    \    {\n        auto part = substr(string, i, len);\n        if (part == substring)\
    \ \n        {\n            count += 1;\n        }\n    }\n    return count;\n}",
  "{\n    long counter = 0;\n    long from = 0;\n    do\n    {\n        from = string.find(substring,\
    \ from);\n        if (from != string.npos)\n        {\n            counter++;\n\
    \            from++;\n        }\n    }\n    while (from != string.npos);\n   \
    \ return counter;\n}\nlong[] how_many_times2(string string, string substring)\
    \ \n{\n    long counter = 0;\n    long from = 0;\n    do\n    {\n        from\
    \ = string.find(substring, from);\n        if (from != string.npos)\n        {\n\
    \            counter++;\n            from++;\n        }\n    }\n    while (from\
    \ != string.npos);\n    return [counter, from];\n}", "{\n    if(substring.length\
    \ == 0) \n    {\n        return 0;\n    }\n    long result = 0;\n    size_t len\
    \ = string.length;\n    size_t len_sub = substring.length;\n    foreach(size_t\
    \ i; 0 .. len) \n    {\n        if(len - i < len_sub) \n        {\n          \
    \  break;\n        }\n        if(string[i .. i + len_sub] == substring) \n   \
    \     {\n            result += 1;\n        }\n    }\n    return result;\n}\n/*",
  "{\n    long count = 0;\n    foreach(int i; 0 .. string.length - substring.length\
    \ + 1)\n    {\n        if(string[i .. i + substring.length - 1] == substring)\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}", "{\n\
    \    long count = 0;\n    string text;\n    foreach(i;0..string.length)\n    {\n\
    \        text = string[i..$];\n        foreach(j;0..text.length)\n        {\n\
    \            if(text[j..j+substring.length-1] == substring)\n            {\n \
    \               count++;\n            }\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> find_longest_common_substring('', 'a')\n  \
    \  0\n    >>> find_longest_common_substring('aaa', 'a')\n    1\n    >>> find_longest_common_substring('abcd',\
    \ 'ab')\n    2\n    >>> find_longest_common_substring('abcdfaaaabcabc', 'abc')\n\
    \    3\n*/\nlong find_longest_common_substring(string string, string substring)\
    \ \n{\n    long max_length = 0;\n    long count = 0;\n    string text;\n    foreach(i;0..string.length)\n\
    \    {\n        text = string[i..$];\n        foreach(j;0..text.length)\n    \
    \    {\n            if(text[j..j+substring.length-1] == substring)\n         \
    \   {\n                count++;\n            }\n            else\n           \
    \ {\n                if(count > max_length)\n                {\n             \
    \       max_length = count;\n                }\n                count = 0;\n \
    \           }\n        }\n    }\n    return max_length;\n}\n/*\n Find the longest\
    \ palindrome in the original string.\n    >>> find_longest_palindrome('')\n  \
    \  0\n    >>> find_longest_palindrome('a')\n    1\n    >>> find_longest_palindrome('aab')\n\
    \    2\n    >>> find_longest_palindrome('abcdefg')\n    1\n    >>> find_longest_palindrome('abcddcba')\n\
    \    8\n    >>> find_longest_palindrome('abcdfaaaabcabc')\n    5\n   ", "{\n \
    \   long n = 0;\n    long pos = 0;\n    while ((pos = string.find(substring, pos))\
    \ != -1) \n    {\n        n++;\n        pos += substring.length;\n    }\n    return\
    \ n;\n}\n/*\n Return a tuple where the first element is the longest prefix of\
    \ a given string, \n consisting only of the characters from a specified alphabet.\
    \ \n The second element is the remaining part of the string.\n    >>> longest_prefix(\"\
    abacadaba\", \"aba\")\n    (\"aba\", \"cadaba\")\n*/\ntuple!(string, string) longest_prefix(string\
    \ string, string alphabet)\n{\n    string prefix = \"\";\n    string suffix =\
    \ \"\";\n    foreach (index, c; string) \n    {\n        if (alphabet.find(c)\
    \ != -1)\n            prefix ~= c;\n        else\n            break;\n    }\n\
    \    suffix = string[prefix.length .. $];\n    return tuple(prefix, suffix);\n\
    }\n/*\n Return a tuple with the elements from a given tuple reversed.\n \n   \
    \ >>> reverse_tuple(tuple(\"a\", \"b\", \"c\"))\n    tuple(\"c\", \"b\", \"a\"\
    )\n*/\nstring[] reverse_tuple(string[] tuple)\n{\n    return tuple[$ .. 0];\n}",
  "{\n    long count = 0;\n    long substring_length = substring.length;\n    long\
    \ string_length = string.length;\n    long found_offset = 0;\n    while (found_offset\
    \ != string.npos)\n    {\n        count++;\n        found_offset = string.find(substring,\
    \ found_offset+1);\n    }\n    return count;\n}\n/*\n Given a list of integers,\
    \ return True if the sequence of numbers 1, 2, 3\n appears in the list somewhere.\n\
    \    >>> array([]).has123()\n    False\n    >>> array([1, 1, 2, 3, 1]).has123()\n\
    \    True\n    >>> array([1, 1, 2, 4, 1]).has123()\n    False\n    >>> array([1,\
    \ 1, 2, 1, 2, 3]).has123()\n    True\n*/", "{\n    long count = 0;\n    size_t\
    \ offset = 0;\n    while ((offset = string.find(substring, offset)) != string.npos)\
    \ \n    {\n        count++;\n        offset += substring.length();\n    }\n  \
    \  return count;\n}", "{\n\tlong count = 0;\n\tlong length = string.length;\n\t\
    long sublength = substring.length;\n\tlong offset = 0;\n\twhile (offset < length)\
    \ \n\t{\n\t\tlong pos = string.find(substring, offset);\n\t\tif (pos < 0) \n\t\
    \t{\n\t\t\tbreak;\n\t\t}\n\t\telse \n\t\t{\n\t\t\toffset = pos + sublength;\n\t\
    \t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n//\nclass SortBySuffixLength \n\
    {\n\tprivate:\n\t\tbool _compare_suffix(const string a, const string b) \n\t\t\
    {\n\t\t\tif (a.length == b.length) \n\t\t\t{\n\t\t\t\treturn a <= b;\n\t\t\t}\n\
    \t\t\telse \n\t\t\t{\n\t\t\t\treturn a.length < b.length;\n\t\t\t}\n\t\t}\n\t\t\
    /*\n\t\t\t\n\t\t>>> a = ['aba', 'aba', 'xzxb', 'ab', 'abc']\n\t\t>>> b = ['aba',\
    \ 'xzxb', 'ab', 'abc', 'aba']\n\t\t>>> SortBySuffixLength(a)\n\t\t>>> a\n\t\t\
    ['aba', 'aba', 'xzxb', 'ab', 'abc']\n\t\t>>> SortBySuffixLength(b)\n\t\t>>> b\n\
    \t\t['aba', 'ab', 'xzxb', 'abc', 'aba']\n\t\t*/\n\tpublic:\n\t\tvoid sort(string[]\
    \ strings) \n\t\t{\n\t\t\tstrings.sort(_compare_suffix);\n\t\t}\n}\nclass SuffixArray\
    \ \n{\n\tprivate:\n\t\tstring _text;\n\t\tlong[] _suffix_array;\n\t\t//\n\t\t\
    long _compare_suffix(const long index_a, const long index_b) \n\t\t{\n\t\t\tlong\
    \ length = _text.length;\n\t\t\tfor (long i = 0; i < length; i++) \n\t\t\t{\n\t\
    \t\t\t", "{\n    long r = 0;\n    foreach(int i, char c; string) \n    {\n   \
    \     if(c == substring[0]) \n        {\n            if(substring.length > 1)\
    \ \n            {\n                if(i + substring.length - 1 < string.length)\
    \ \n                {\n                    if(string[i + 1 .. i + substring.length\
    \ - 1] == substring[1 .. $ - 1]) \n                    {\n                   \
    \     r += 1;\n                    }\n                }\n            } \n    \
    \        else \n            {\n                r += 1;\n            }\n      \
    \  }\n    }\n    return r;\n}\n//\n//", "{\n    long count = 0;\n    long index\
    \ = 0;\n    while ((index = string.find(substring, index)) != -1)\n    {\n   \
    \     index += substring.length;\n        count++;\n    }\n    return count;\n\
    }", "{\n    long r = 0;\n    while (string.length >= substring.length) \n    {\n\
    \        size_t p = string.find(substring);\n        if (p == string.npos) break;\n\
    \        r++;\n        string = string[p + substring.length .. $];\n    }\n  \
    \  return r;\n}", "{\n\tlong result = 0;\n\tlong i = 0;\n\twhile (true) \n\t{\n\
    \t\ti = string.find(substring, i);\n\t\tif (i == -1) \n\t\t{\n\t\t\tbreak;\n\t\
    \t}\n\t\t++result;\n\t\t++i;\n\t}\n\treturn result;\n}\n/*\n Convert the given\
    \ list of string to a single string by joining them with a given separator.\n\
    \    >>> list_to_string(['a', 'b', 'c'], '.')\n    'a.b.c'\n*/\nstring list_to_string(string[]\
    \ list, string separator) \n{\n\tstring result = \"\";\n\tforeach (i, item; list)\
    \ \n\t{\n\t\tif (i != 0) \n\t\t{\n\t\t\tresult ~= separator;\n\t\t}\n\t\tresult\
    \ ~= item;\n\t}\n\treturn result;\n}\n/*\n Given a positive integer n and a string\
    \ s, find the first occurrence of the substring \"abc\" in the string\n and return\
    \ the index of the beginning of the substring. Return -1 if the substring is not\
    \ found.\n    >>> first_abc_index(1, 'abc')\n    0\n    >>> first_abc_index(10,\
    \ 'abc')\n    -1\n    >>> first_abc_index(1, 'babc')\n    -1\n    >>> first_abc_index(2,\
    \ 'ababc')\n    0\n    >>> first_abc_index(3, 'ababc')\n    -1\n    >>> first_abc_index(1,\
    \ 'cababc')\n    -1\n    >>> first_abc_index(2, 'cababc')\n    0\n    >>> first_abc_index(3,\
    \ 'cababc')\n    0\n    >>> first_abc_index(2, 'bcababc')\n    -1\n    >>> first_abc_index(3,\
    \ 'bcababc')\n    -1\n    >>> first_abc_index(4, 'bcababc')\n    0\n    >>> first_abc_index(3,\
    \ 'ababcababc')\n    0\n    >>> first", "{\n    long count = 0;\n    foreach(i;\
    \ 0 .. string.length - substring.length + 1) \n    {\n        if(string[i .. i\
    \ + substring.length - 1] == substring)\n            count++;\n    }\n    return\
    \ count;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
