name: HumanEval_69_search
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a non-empty\
  \ list of positive integers. Return the greatest integer that is greater than \n\
  \    zero, and has a frequency greater than or equal to the value of the integer\
  \ itself. \n    The frequency of an integer is the number of times it appears in\
  \ the list.\n    If no such a value exist, return -1.\n    Examples:\n        search([4,\
  \ 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n     \
  \   search([5, 5, 4, 4, 4]) == -1\n    \n*/\nlong search(long[] lst) \n"
tests: "unittest\n{\n    alias candidate = search;\n\n    assert(candidate([5L, 5L,\
  \ 5L, 5L, 1L]) == 1L);\n    assert(candidate([4L, 1L, 4L, 1L, 4L, 4L]) == 4L);\n\
  \    assert(candidate([3L, 3L]) == -1L);\n    assert(candidate([8L, 8L, 8L, 8L,\
  \ 8L, 8L, 8L, 8L]) == 8L);\n    assert(candidate([2L, 3L, 3L, 2L, 2L]) == 2L);\n\
  \    assert(candidate([2L, 7L, 8L, 8L, 4L, 8L, 7L, 3L, 9L, 6L, 5L, 10L, 4L, 3L,\
  \ 6L, 7L, 1L, 7L, 4L, 10L, 8L, 1L]) == 1L);\n    assert(candidate([3L, 2L, 8L, 2L])\
  \ == 2L);\n    assert(candidate([6L, 7L, 1L, 8L, 8L, 10L, 5L, 8L, 5L, 3L, 10L])\
  \ == 1L);\n    assert(candidate([8L, 8L, 3L, 6L, 5L, 6L, 4L]) == -1L);\n    assert(candidate([6L,\
  \ 9L, 6L, 7L, 1L, 4L, 7L, 1L, 8L, 8L, 9L, 8L, 10L, 10L, 8L, 4L, 10L, 4L, 10L, 1L,\
  \ 2L, 9L, 5L, 7L, 9L]) == 1L);\n    assert(candidate([1L, 9L, 10L, 1L, 3L]) == 1L);\n\
  \    assert(candidate([6L, 9L, 7L, 5L, 8L, 7L, 5L, 3L, 7L, 5L, 10L, 10L, 3L, 6L,\
  \ 10L, 2L, 8L, 6L, 5L, 4L, 9L, 5L, 3L, 10L]) == 5L);\n    assert(candidate([1L])\
  \ == 1L);\n    assert(candidate([8L, 8L, 10L, 6L, 4L, 3L, 5L, 8L, 2L, 4L, 2L, 8L,\
  \ 4L, 6L, 10L, 4L, 2L, 1L, 10L, 2L, 1L, 1L, 5L]) == 4L);\n    assert(candidate([2L,\
  \ 10L, 4L, 8L, 2L, 10L, 5L, 1L, 2L, 9L, 5L, 5L, 6L, 3L, 8L, 6L, 4L, 10L]) == 2L);\n\
  \    assert(candidate([1L, 6L, 10L, 1L, 6L, 9L, 10L, 8L, 6L, 8L, 7L, 3L]) == 1L);\n\
  \    assert(candidate([9L, 2L, 4L, 1L, 5L, 1L, 5L, 2L, 5L, 7L, 7L, 7L, 3L, 10L,\
  \ 1L, 5L, 4L, 2L, 8L, 4L, 1L, 9L, 10L, 7L, 10L, 2L, 8L, 10L, 9L, 4L]) == 4L);\n\
  \    assert(candidate([2L, 6L, 4L, 2L, 8L, 7L, 5L, 6L, 4L, 10L, 4L, 6L, 3L, 7L,\
  \ 8L, 8L, 3L, 1L, 4L, 2L, 2L, 10L, 7L]) == 4L);\n    assert(candidate([9L, 8L, 6L,\
  \ 10L, 2L, 6L, 10L, 2L, 7L, 8L, 10L, 3L, 8L, 2L, 6L, 2L, 3L, 1L]) == 2L);\n    assert(candidate([5L,\
  \ 5L, 3L, 9L, 5L, 6L, 3L, 2L, 8L, 5L, 6L, 10L, 10L, 6L, 8L, 4L, 10L, 7L, 7L, 10L,\
  \ 8L]) == -1L);\n    assert(candidate([10L]) == -1L);\n    assert(candidate([9L,\
  \ 7L, 7L, 2L, 4L, 7L, 2L, 10L, 9L, 7L, 5L, 7L, 2L]) == 2L);\n    assert(candidate([5L,\
  \ 4L, 10L, 2L, 1L, 1L, 10L, 3L, 6L, 1L, 8L]) == 1L);\n    assert(candidate([7L,\
  \ 9L, 9L, 9L, 3L, 4L, 1L, 5L, 9L, 1L, 2L, 1L, 1L, 10L, 7L, 5L, 6L, 7L, 6L, 7L, 7L,\
  \ 6L]) == 1L);\n    assert(candidate([3L, 10L, 10L, 9L, 2L]) == -1L);\n}\nvoid main(){}"
completions: ["{\n    long[] sumLst = new long[10001];\n    for(long l : lst)\n  \
    \  {\n        sumLst[l]++;\n    }\n    for(long l : lst)\n    {\n        if(sumLst[l]\
    \ >= l)\n        {\n            return l;\n        }\n    }\n    return -1;\n\
    }\n// TEST CASES:\nunittest\n{\n    Assert.Equal(search([4, 1, 2, 2, 3, 1]), 2);\n\
    \    Assert.Equal(search([1, 2, 2, 3, 3, 3, 4, 4, 4]), 3);\n    Assert.Equal(search([5,\
    \ 5, 4, 4, 4]), -1);\n    Assert.Equal(search([4, 1, 2, 2, 3, 1, 1, 1, 5, 6, 7,\
    \ 8, 5, 4, 3, 3, 5, 7, 6, 5, 5, 4, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 6, 4, 5,\
    \ 6, 6, 6, 5, 5, 4, 4, 5, 6, 7, 8, 5, 4, 3, 3, 5, 7, 6, 5, 5, 4, 3, 3, 3, 3, 3,\
    \ 3, 4, 4, 4, 4, 5, 5, 6, 4, 5, 6, 6, 6, 5, 5, 4, 4, 5, 6, 7, 8, 5, 4, 3, 3, 5,\
    \ 7, 6, 5, 5, 4, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 6, 4, 5, 6, 6, 6, 5, 5, 4,\
    \ 4, 5, 6, 7, 8, 5, 4, 3, 3, 5, 7, 6, 5, 5, 4, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 5,\
    \ 5, 6, 4, 5, 6, 6, 6, 5, 5, 4, 4, 5, 6, 7, 8, 5, 4, 3, 3, 5, 7,", "{\n    auto\
    \ list = lst.idup;\n    list.sort();\n    auto frequencies = list.frequency;\n\
    \    long largest = -1;\n    foreach(key, value; frequencies)\n    {\n       \
    \ if(value >= key && key > largest)\n            largest = key;\n    }\n    return\
    \ largest;\n}", "{\n    long candidate = -1;\n    long current = -1;\n    long\
    \ frequency = 0;\n    foreach(elem; lst)\n    {\n        if(elem > current)\n\
    \        {\n            if(frequency >= current)\n            {\n            \
    \    candidate = current;\n            }\n            current = elem;\n      \
    \      frequency = 1;\n        }\n        else if(elem == current)\n        {\n\
    \            frequency++;\n        }\n    }\n    if(frequency >= current)\n  \
    \  {\n        candidate = current;\n    }\n    return candidate;\n}", "{\n   \
    \ static assert(lst.length > 0);\n    static assert(lst.filter!(i => i <= 0).length\
    \ == 0);\n    long[] sortedLst = lst.dup.sort();\n    long[] dups = [1];\n   \
    \ long count = 1;\n    for (long i = 1; i < sortedLst.length; i++)\n    {\n  \
    \      if (sortedLst[i] == sortedLst[i - 1])\n        {\n            count++;\n\
    \        }\n        else\n        {\n            dups ~= count;\n            count\
    \ = 1;\n        }\n    }\n    dups ~= count;\n    dups.sort;\n    foreach (value;\
    \ dups)\n    {\n        if (value >= lst.max)\n        {\n            if (lst.filter!(i\
    \ => i == value).length >= value)\n            {\n                return value;\n\
    \            }\n        }\n    }\n    return -1;\n}", "{\n    import std.algorithm.sorting\
    \ : sort;\n    lst.sort;", "{\n    long max = 0;\n    bool found = false;\n  \
    \  foreach(k; lst)\n    {\n        if(k>max) max = k;\n    }\n    for(long i =\
    \ max; i>0; i--)\n    {\n        long count = 0;\n        foreach(k; lst)\n  \
    \      {\n            if(k==i) count++;\n        }\n        if(count>=i)\n   \
    \     {\n            found = true;\n            return i;\n        }\n    }\n\
    \    if(!found) return -1;\n}", "{\n    long result = -1;\n    long freq = 0;\n\
    \    long maxFreq = 0;\n    long val = 0;\n    long maxVal = 0;\n    long index\
    \ = 0;\n    for(;index < lst.length;)\n    {\n        if(maxFreq == 0)\n     \
    \   {\n            maxFreq = 1;\n            maxVal = lst[index];\n        }\n\
    \        val = lst[index];\n        freq = 0;\n        while(index < lst.length\
    \ && val == lst[index])\n        {\n            freq++;\n            index++;\n\
    \        }\n        if(freq >= val && val >= maxVal)\n        {\n            maxFreq\
    \ = freq;\n            maxVal = val;\n        }\n    }\n    if(maxFreq > 0)\n\
    \    {\n        if(maxFreq >= maxVal)\n        {\n            result = maxVal;\n\
    \        }\n    }\n    return result;\n}\nlong search1(long[] lst) \n{\n    long[]\
    \  sortedLst = sort(lst);\n    long result = -1;\n    long freq = 0;\n    long\
    \ maxFreq = 0;\n    long val = 0;\n    long maxVal = 0;\n    long index = 0;\n\
    \    for(;index < sortedLst.length;)\n    {\n        if(maxFreq == 0)\n      \
    \  {\n            maxFreq = 1;\n            maxVal = sortedLst[index];\n     \
    \   }\n        val = sortedLst[index];\n        freq = 0;\n        while(index\
    \ < sortedLst.length && val == sortedLst[index])\n        {\n            freq++;\n\
    \            index++;\n        }\n        if(freq >= val && val >= maxVal)\n \
    \       {\n            maxFreq = freq;\n            maxVal = val;\n        }\n\
    \    }\n    if(maxFreq > 0)\n    {\n        if(maxFreq >= maxVal)\n        {\n\
    \            result = maxVal;\n        }\n    }\n    return result;\n}\nlong search2(long[]\
    \ lst) \n{\n", "{\n    import std.algorithm;\n    import std.conv;\n    import\
    \ std.range;\n    import std.functional;\n    import std.array;\n    import std.stdio;\n\
    \    import std.math;\n    import std.algorithm.comparison;\n    import std.container.array;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.type", "{\n    long[] arr = new long[lst.length];\n    foreach(i;\
    \ 0 .. lst.length) arr[i] = -1;\n    foreach(i; 0 .. lst.length)\n    {\n    \
    \    long counter = 0;\n        foreach(j; 0 .. lst.length)\n        {\n     \
    \       if(lst[i] == lst[j])\n            {\n                counter++;\n    \
    \        }\n        }\n        if(counter >= lst[i])\n        {\n            arr[i]\
    \ = lst[i];\n        }\n    }\n    long count = 0;\n    foreach(i; 0 .. arr.length)\n\
    \    {\n        if(arr[i] != -1)\n        {\n            count++;\n        }\n\
    \    }\n    if(count == 0)\n    {\n        return -1;\n    }\n    long mx = 0;\n\
    \    foreach(i; 0 .. arr.length)\n    {\n        if(arr[i] > mx)\n        {\n\
    \            mx = arr[i];\n        }\n    }\n    return mx;\n}", "{\n    immutable\
    \ map = lst.sort().group.array;\n    immutable ints = map.map!(e => e[0]).sort;\n\
    \    foreach(immutable int num; ints)\n    {\n        immutable value = map.binaryFind!((e)\
    \ => e[0] == num).value[1].length;\n        if(value >= num)\n            return\
    \ num;\n    }\n    return -1;\n}", "{\n    if(lst.length < 1) return -1;\n   \
    \ long max = lst[0];\n    for(long x : lst)\n    {\n        if(x > max) max =\
    \ x;\n    }\n    long[] freq = new long[(int)max+1];\n    foreach(i; lst)\n  \
    \  {\n        freq[(int)i]++;\n    }\n    foreach(i; (iota(0,max)).array)\n  \
    \  {\n        if(freq[(int)i] >= i) return i;\n    }\n    return -1;\n}", "{\n\
    \    long[] arrFrequencies = new long[0];\n    long greatestInt = -1;\n    int\
    \ intCurrentFrequency = 0;\n    int intPreviousFrequency = 0;\n    int indexPrevious\
    \ = 0;\n    for(int i = 0; i < lst.length; i++)\n    {\n        int index = arrFrequencies.find(x\
    \ => x == lst[i]);\n        if(index == -1)\n        {\n            arrFrequencies\
    \ ~= lst[i];\n            arrFrequencies ~= 1;\n        }\n        else\n    \
    \    {\n            arrFrequencies[index + 1]++;\n        }\n    }\n    for(int\
    \ i = 0; i < arrFrequencies.length; i += 2)\n    {\n        intCurrentFrequency\
    \ = arrFrequencies[i + 1];\n        if(intCurrentFrequency >= intPreviousFrequency)\n\
    \        {\n            greatestInt = arrFrequencies[i];\n            intPreviousFrequency\
    \ = intCurrentFrequency;\n            indexPrevious = i;\n        }\n    }\n \
    \   if(greatestInt > intPreviousFrequency)\n    {\n        return -1;\n    }\n\
    \    else\n    {\n        return greatestInt;\n    }\n}", "{\n    const auto m\
    \ = max(lst);\n    return m > frequency(lst, m) ? -1 : m;\n}", "{\n    long[]\
    \ freq = new long[lst.max + 1];\n    foreach(e; lst)\n        freq[e]++;\n   \
    \ foreach(e; freq[1..$].retro)\n        if(e >= freq.indexOf(e))\n           \
    \ return e;\n    return -1;\n}", "{\n    // Define frequency\n    long[] freq\
    \ = new long[lst.length];\n    long counter = 0;\n    foreach(long i; lst) {\n\
    \        foreach(long v; lst) {\n            if(i == v) {\n                counter++;\n\
    \            }\n        }\n        freq[i] = counter;\n        counter = 0;\n\
    \    }\n    // Deducing the result\n    long result = -1;\n    for(long i = 1;\
    \ i < lst.length; i++) {\n        if(freq[i] >= i) {\n            result = i;\n\
    \        }\n    }\n    return result;\n}", "{\n    import std.algorithm.sorting\
    \ : sort;\n    immutable maxNum = lst.max();\n    immutable maxFrequency = lst.frequency.max;\n\
    \    writeln(maxNum);\n    writeln(maxFrequency);\n    lst.sort;\n    writeln(lst);\n\
    \    foreach(elem; lst)\n    {\n        if (elem >= maxFrequency)\n        {\n\
    \            return -1;\n        }\n        if (lst.countUntil(elem) == elem)\n\
    \        {\n            return elem;\n        }\n    }\n    return -1;\n}", "{\n\
    \    enum num = -1;\n    enum freq = 0;\n    auto counts = std.algorithm.countingSort(lst);\n\
    \    foreach(n; counts)\n    {\n        if(n.key > n.value && n.value >= freq)\n\
    \        {\n            num = n.key;\n            freq = n.value;\n        }\n\
    \    }\n    return num;\n}", "{\n    int[] count = new int[lst.length];\n    foreach(i;\
    \ lst)\n    {\n        if(i < lst.length)\n            count[i] += 1;\n    }\n\
    \    foreach(i; 0..lst.length)\n    {\n        if(count[i] == i)\n           \
    \ return i;\n    }\n    return -1;\n}", "{\n    long[] freq = new long[lst.length\
    \ + 1];\n    long result = -1;\n    int idx = 0;\n    for (long elem : lst)\n\
    \    {\n        ++freq[idx];\n        idx = elem;\n    }\n    for (idx = 1; idx\
    \ < freq.length; ++idx)\n    {\n        if (freq[idx] >= idx)\n        {\n   \
    \         result = max(result, idx);\n        }\n    }\n    return result;\n}",
  "{\n    long maxNumber = 0;\n    int[] numbers = lst.dup;\n    numbers.sort;\n \
    \   int maxFrequency = 0;\n    for (int i = 0; i < numbers.length; i++) {\n  \
    \      int frequency = 0;\n        foreach (long number; numbers) {\n        \
    \    if (number == numbers[i]) {\n                frequency++;\n            }\n\
    \        }\n        if (frequency >= numbers[i] && frequency > maxFrequency) {\n\
    \            maxFrequency = frequency;\n            maxNumber = numbers[i];\n\
    \        }\n    }\n    return maxNumber;\n}\n/* \n    You are given a string representing\
    \ an attendance record for a student. \n    The record only contains the following\
    \ three characters:\n        'A' : Absent.\n        'L' : Late.\n        'P' :\
    \ Present.\n    A student could be rewarded if his attendance record doesn't contain\
    \ more than one 'A' (absent) \n    or more than two continuous 'L' (late).\n \
    \   You need to return whether the student could be rewarded according to his\
    \ attendance record.\n    Example 1:\n        Input: \"PPALLP\"\n        Output:\
    \ True\n    Example 2:\n        Input: \"PPALLL\"\n        Output: False\n*/"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
