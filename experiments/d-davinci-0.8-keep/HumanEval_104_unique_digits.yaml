name: HumanEval_104_unique_digits
language: d
prompt: "import std.math;\n/*\nGiven a list of positive integers x. return a sorted\
  \ list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list\
  \ should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
  \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
  \    []\n    \n*/\nlong[] unique_digits(long[] x) \n"
tests: "unittest\n{\n    alias candidate = unique_digits;\n\n    assert(candidate([15L,\
  \ 33L, 1422L, 1L]) == [1L, 15L, 33L]);\n    assert(candidate([152L, 323L, 1422L,\
  \ 10L]) == []);\n    assert(candidate([12345L, 2033L, 111L, 151L]) == [111L, 151L]);\n\
  \    assert(candidate([135L, 103L, 31L]) == [31L, 135L]);\n}\nvoid main(){}"
completions: ["{\n    /*auto has_even_digit = [] (long n)\n    {\n        while (n\
    \ > 0)\n        {\n            if (n % 2 == 0)\n                return true;\n\
    \            n /= 10;\n        }\n        return false;\n    };*/\n    //return\
    \ x.filter!(has_even_digit).sort;\n    return x.filter!(a => a.digits.filter!(c\
    \ => (c % 2) == 0).empty).sort;\n}", "{\n    long[] result = [], temp = [];\n\
    \    int n = x.length;\n    for (int i = 0; i < n; i++)\n    {\n        int num\
    \ = x[i];\n        bool flag = true;\n        int j = 0;\n        temp = [];\n\
    \        while (num > 0)\n        {\n            temp ~= num % 10;\n         \
    \   num /= 10;\n        }\n        for (j = 0; j < temp.length; j++)\n       \
    \ {\n            if (temp[j] % 2 == 0)\n            {\n                flag =\
    \ false;\n                break;\n            }\n        }\n        if (flag)\n\
    \        {\n            result ~= x[i];\n        }\n    }\n    sort(result);\n\
    \    return result;\n}", "{\n    // I'm too stupid to figure this out on my own\
    \ so I'll have to\n    // try and walk through this manually and figure out where\
    \ my\n    // reasoning was flawed.\n    // I was apparently trying to make this\
    \ much more complicated\n    // than it needed to be. I should have just done\
    \ something like:\n    // for(in long i : x) {\n    //    if(i % 2 == 0) {\n \
    \   //        continue;\n    //    }\n    //    if(!(i is even)) {\n    //   \
    \     vec.push_back(i);\n    //    }\n    //    push.back(i);\n    // }\n    //\
    \ return vec;\n    // Or something to that effect.\n    int i = 0;\n    auto vec\
    \ = appender!(long[])();\n    while(i < x.length) {\n        if(x[i] % 2 == 0)\
    \ {\n            // First let's check if the current index is even\n         \
    \   i++;\n            continue;\n        }\n        int j = x[i];\n        while(j\
    \ > 0) {\n            if(j % 2 == 0) {\n                // Now we check if the\
    \ number is even\n                break;\n            }\n            j /= 10;\n\
    \        }\n        if(j == 0) {\n            // If j is 0 then we know that we\
    \ went through the whole\n            // number without hitting an even number.\n\
    \            vec.put(x[i]);\n        }\n        i++;\n    }\n    return vec.data;\n\
    }", "{\n    // Write your code here\n    return x.filter!(a => a < 10).dup;\n}",
  "{\n    long[] ret = new long[];\n    for (long i = 0; i < x.length; i++)\n    {\n\
    \        bool found = false;\n        long num = x[i];\n        while (num > 0)\n\
    \        {\n            long dig = num % 10;\n            if (dig % 2 == 0)\n\
    \            {\n                found = true;\n                break;\n      \
    \      }\n            num /= 10;\n        }\n        if (!found)\n           \
    \ ret ~= x[i];\n    }\n    ret.sort;\n    return ret;\n}", "{\n\treturn x.filter!(a\
    \ => a.toString().chars.all!(char.isOdd)).array;\n}", "{\n    long[] result;\n\
    \    foreach(e; x)\n    {\n        if (abs(e) % 2 == 1)\n        {\n         \
    \   result ~= e;\n        }\n    }\n    return result;\n}", "{\n    long[] res\
    \ = [];\n    for (i in x)\n    {\n        string str = format(\"%s\", i);\n  \
    \      bool even = false;\n        foreach (z; str)\n        {\n            if\
    \ (z == '2' || z == '4' || z == '6' || z == '8' || z == '0')\n            {\n\
    \                even = true;\n                break;\n            }\n       \
    \ }\n        if (!even)\n            res ~= i;\n    }\n    res.sort;\n    return\
    \ res;\n}", "{\n    long[] unique = new long[0];\n    foreach(long j; x) {\n \
    \       auto hasEven = false;\n        auto digit = 0;\n        auto sj = to!string(j);\n\
    \        foreach(char k; sj) {\n            digit = k - '0';\n            if(digit\
    \ % 2 == 0) {\n                hasEven = true;\n                break;\n     \
    \       }\n        }\n        if(!hasEven)\n            unique ~= j;\n    }\n\
    \    sort(unique);\n    return unique;\n}", "{\n    int digits = 0;\n    long[]\
    \ a = new long[x.length];\n    int pos = 0;\n    for (int i = 0; i < x.length;\
    \ i++)\n    {\n        digits = 0;\n        int num = cast(int)x[i];\n       \
    \ while (num > 0)\n        {\n            digits++;\n            num /= 10;\n\
    \        }\n        num = cast(int)x[i];\n        int temp = 0;\n        bool\
    \ found = false;\n        while (num > 0)\n        {\n            temp = num %\
    \ 10;\n            if (temp % 2 == 0)\n            {\n                found =\
    \ true;\n                break;\n            }\n            num /= 10;\n     \
    \   }\n        if (!found)\n        {\n            a[pos] = x[i];\n          \
    \  pos++;\n        }\n    }\n    long[] b = new long[pos];\n    for (int i = 0;\
    \ i < pos; i++)\n    {\n        b[i] = a[i];\n    }\n    return b;\n}", "{\n \
    \   return x.filter!(a => a.tostring.all!(b => b % 2 != 0)).sort;\n}", "{ \n \
    \   // Your code goes here.\n    // Write you solution with the require functional\
    \ and \n    // test cases for the function.\n    return long[0];\n}", "{\n   \
    \ long[] sorted = x.sort;\n    long[] res = new long[0];\n    for (int i = 0;\
    \ i < sorted.length; i++) {\n        long n = sorted[i];\n        bool has_even\
    \ = false;\n        while (n > 0) {\n            if (n % 2 == 0) {\n         \
    \       has_even = true;\n                break;\n            }\n            n\
    \ /= 10;\n        }\n        if (!has_even) res ~= sorted[i];\n    }\n    return\
    \ res;\n}", "{\n    //This is the length of the array\n    int arrayLength = x.length;\n\
    \    //This is the length of the array I will return\n    int count = 0;\n   \
    \ long[] y = new long[arrayLength];\n    long[] y2 = new long[arrayLength];\n\
    \    //This finds the number of elemnts in the array that have no even digits\n\
    \    for(int i = 0; i < arrayLength; i++)\n    {\n        long z = x[i];\n   \
    \     if(z == 0)\n        {\n            continue;\n        }\n        while(z\
    \ > 0)\n        {\n            if(z % 2 == 0)\n            {\n               \
    \ break;\n            }\n            if(z % 10 == 1 || z % 10 == 3 || z % 10 ==\
    \ 5 || z % 10 == 7 || z % 10 == 9)\n            {\n                count++;\n\
    \            }\n            z = z / 10;\n        }\n    }\n    //This finds the\
    \ elements of the array that have no even digits\n    //Then adds them to a new\
    \ array\n    //Then sorts the new array in increasing order\n    int count2 =\
    \ 0;\n    for(int i = 0; i < arrayLength; i++)\n    {\n        long z = x[i];\n\
    \        if(z == 0)\n        {\n            continue;\n        }\n        while(z\
    \ > 0)\n        {\n            if(z % 2 == 0)\n            {\n               \
    \ break;\n            }\n            if(z % 10 == 1 || z % 10 == 3 || z % 10 ==\
    \ 5 || z % 10 == 7 || z % 10 == 9)\n            {\n                y[count2] =\
    \ x[i];\n                count2++;\n            }\n            z = z / 10;\n \
    \       }\n    }\n    sort(y, 0, count2);\n    //This takes the new sorted array\
    \ and adds it to a new array that I return\n    for(int i = 0; i < count2; i++)\n\
    \    {\n        y2[i] = y[i];\n    }\n    return y2;\n}", "{\n    long[] y = new\
    \ long[1];\n    long j = 0;\n    foreach(long z; x)\n    {\n        if(z % 2 ==\
    \ 1)\n        {\n            y ~= z;\n            j++;\n        }\n    }\n   \
    \ if(j == 0)\n    {\n        long[] y = [];\n        return y;\n    }\n    sort(y);\n\
    \    return y;\n}", "{\n    long n;\n    long i;\n    long count = 0;\n    long[]\
    \ y;\n    foreach(element; x)\n    {\n        n = element;\n        for(i = 1;\
    \ n != 0; i *= 10)\n        {\n            if(mod(n % 10, 2) == 0)\n         \
    \   {\n                count++;\n                break;\n            }\n     \
    \       n /= 10;\n        }\n    }\n    y = new long[x.length - count];\n    long\
    \ j = 0;\n    foreach(element; x)\n    {\n        n = element;\n        for(i\
    \ = 1; n != 0; i *= 10)\n        {\n            if(mod(n % 10, 2) == 0)\n    \
    \        {\n                break;\n            }\n            n /= 10;\n    \
    \    }\n        if(n == 0)\n        {\n            y[j] = element;\n         \
    \   j++;\n        }\n    }\n    return y;\n}", "{\n    /*Write your code here*/\n\
    \    long[] r;\n    r = new long[0];\n    for(int i = 0; i < x.length; i++)\n\
    \    {\n        bool f = true;\n        long xx = x[i];\n        while(xx > 0)\n\
    \        {\n            if(xx % 2 == 0)\n            {\n                f = false;\n\
    \                break;\n            }\n            xx /= 10;\n        }\n   \
    \     if(f)\n        {\n            long[] r1 = new long[r.length + 1];\n    \
    \        foreach(idx, elem; r)\n            {\n                r1[idx] = elem;\n\
    \            }\n            r1[r1.length - 1] = x[i];\n            r = r1;\n \
    \       }\n    }\n    sort(r);\n    return r;\n}", "{\n    long[] result = [];\n\
    \    foreach(i; x)\n    {\n        if(i < 10)\n        {\n            result ~=\
    \ i;\n        }\n        else if(mod(i, 2) == 1)\n        {\n            result\
    \ ~= i;\n        }\n        else\n        {\n            if(mod(i, 10) == 0)\n\
    \            {\n                continue;\n            }\n            else\n \
    \           {\n                int j = i;\n                for(;;)\n         \
    \       {\n                    if(mod(j, 10) == 1)\n                    {\n  \
    \                      result ~= i;\n                        break;\n        \
    \            }\n                    else if(mod(j, 10) == 0)\n               \
    \     {\n                        break;\n                    }\n             \
    \       else\n                    {\n                        j = j / 10;\n   \
    \                 }\n                }\n            }\n        }\n    }\n    std.algorithm.sort(result);\n\
    \    return result;\n}\n//This is a solution for this problem: https://www.codewars.com/kata/sum-of-intervals/train/d\n\
    struct Interval\n{\n    int start;\n    int end;\n}\nlong sum_of_intervals(Interval[]\
    \ intervals)\n{\n    int[] temp = [];\n    foreach(i; intervals)\n    {\n    \
    \    for(int j = i.start; j < i.end; j++)\n        {\n            temp ~= j;\n\
    \        }\n    }\n    std.algorithm.sort(temp);\n    long count = 1;\n    for(int\
    \ i = 1; i < temp.length; i++)\n    {\n        if(temp[i] == temp[i - 1])\n  \
    \      {\n            continue;\n        }\n        else\n        {\n        \
    \    count++;\n        }\n    }\n    return count;\n}\n//This is a solution for\
    \ this problem: https://www.codewars.com/kata/vowel-count/train/d", "{\n    long[]\
    \ result = new long[0];\n    long[] temp;\n    foreach(item; x)\n    {\n     \
    \   temp = item.toString.split.retro.to!long;\n        if(temp.all!(a => a%2!=0))\n\
    \        {\n            result ~= item;\n        }\n    }\n    return result.sort;\n\
    }", "{\n    int sz = x.length;\n    int[] even = new int[sz];\n    int counter\
    \ = 0;\n    for (int i = 0; i < sz; i++)\n    {\n        int num = x[i];\n   \
    \     int div = 10;\n        while (num != 0)\n        {\n            if ( (num\
    \ % div) % 2 == 0)\n            {\n                even[i] = 1;\n            \
    \    break;\n            }\n            num = num / 10;\n        }\n        if\
    \ (even[i] == 0)\n            counter++;\n    }\n    if (counter == 0)\n     \
    \   return new long[0];\n    else\n    {\n        long[] ans = new long[counter];\n\
    \        int k = 0;\n        for (int i = 0; i < sz; i++)\n        {\n       \
    \     if (even[i] == 0)\n            {\n                ans[k] = x[i];\n     \
    \           k++;\n            }\n        }\n        insertionSort(ans);\n    \
    \    return ans;\n    }\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
