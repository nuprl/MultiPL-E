name: HumanEval_158_find_max
language: d
results:
- program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ a list of strings.\n    The list contains different words. Return the word with\
    \ maximum number\n    of unique characters. If multiple strings have maximum number\
    \ of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    find_max([\"name\", \"of\", \"string\"]) == \"string\"\n    find_max([\"\
    name\", \"enam\", \"game\"]) == \"enam\"\n    find_max([\"aaaaaaa\", \"bb\" ,\"\
    cc\"]) == \"\"aaaaaaa\"\n    \n*/\nstring find_max(string[] words) \n{\n\treturn\
    \ \"\";\n}\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpciu0981n.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428fdd]\\n??:? void tmpciu0981n.__unittest_L18_C1()\
    \ [0x427b99]\\n??:? void tmpciu0981n.__modtest() [0x428244]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8b7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d36]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a765]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a7f4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a6f1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d0d]\\n??:? runModuleUnitTests [0x42d68d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42942c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293b3]\\n??:? _d_run_main [0x42931e]\\n??:? main [0x428257]\\\
    n??:? __libc_start_main [0xcfc77554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ a list of strings.\n    The list contains different words. Return the word with\
    \ maximum number\n    of unique characters. If multiple strings have maximum number\
    \ of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    find_max([\"name\", \"of\", \"string\"]) == \"string\"\n    find_max([\"\
    name\", \"enam\", \"game\"]) == \"enam\"\n    find_max([\"aaaaaaa\", \"bb\" ,\"\
    cc\"]) == \"\"aaaaaaa\"\n    \n*/\nstring find_max(string[] words) \n{\n    string\
    \ maxStr;\n    foreach(i, word; words) \n    {\n        if(!maxStr.length || word.length\
    \ > maxStr.length)\n            maxStr = word;\n    }\n    return maxStr;\n}\n\
    /*\nGiven a string str, determine if it is a palindrome (reads the same from left\n\
    to right and from right to left).\n*/\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp51owu8nl.d(33): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42906d]\\n??:? void tmp51owu8nl.__unittest_L28_C1()\
    \ [0x427cca]\\n??:? void tmp51owu8nl.__modtest() [0x4282d4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d947]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dc6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a7f5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a884]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a781]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d9d]\\n??:? runModuleUnitTests [0x42d71d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294bc]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429443]\\n??:? _d_run_main [0x4293ae]\\n??:? main [0x4282e7]\\\
    n??:? __libc_start_main [0x39924554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ a list of strings.\n    The list contains different words. Return the word with\
    \ maximum number\n    of unique characters. If multiple strings have maximum number\
    \ of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    find_max([\"name\", \"of\", \"string\"]) == \"string\"\n    find_max([\"\
    name\", \"enam\", \"game\"]) == \"enam\"\n    find_max([\"aaaaaaa\", \"bb\" ,\"\
    cc\"]) == \"\"aaaaaaa\"\n    \n*/\nstring find_max(string[] words) \n{\n    int[]\
    \ freq = new int[words.length];\n    for (int i = 0; i < words.length; i++) \n\
    \    {\n        freq[i] = uniquies(words[i]);\n    }\n    // freq.length is the\
    \ length of the freq array. \n    int max = freq[0];\n    int pos = 0;\n    for\
    \ (int i = 1; i < freq.length; i++) \n    {\n        if (freq[i] > max) \n   \
    \     {\n            max = freq[i];\n            pos = i;\n        }\n    }\n\
    \    return words[pos];\n}\nunittest\n{\n    alias candidate = find_max;\n\n \
    \   assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4jgf80g5.d(19): Error: undefined identifier `uniquies`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4jgf80g5.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ a list of strings.\n    The list contains different words. Return the word with\
    \ maximum number\n    of unique characters. If multiple strings have maximum number\
    \ of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    find_max([\"name\", \"of\", \"string\"]) == \"string\"\n    find_max([\"\
    name\", \"enam\", \"game\"]) == \"enam\"\n    find_max([\"aaaaaaa\", \"bb\" ,\"\
    cc\"]) == \"\"aaaaaaa\"\n    \n*/\nstring find_max(string[] words) \n{\n    int\
    \ max = 0;\n    string res = \"\";\n    foreach(string word; words)\n    {\n \
    \       int[] cnt = new int[128];\n        foreach(char c; word)\n        {\n\
    \            cnt[c]++;\n        }\n        foreach(int count; cnt)\n        {\n\
    \            if(count > 0)\n                max = max + 1;\n        }\n      \
    \  if(max == word.length)\n        {\n            if(res.length == 0)\n      \
    \          res = word;\n            else if(res > word)\n                res =\
    \ word;\n        }\n        max = 0;\n    }\n    return res;\n}\nunittest\n{\n\
    \    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"\
    string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp2axcljmb.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4294f5]\\n??:? void tmp2axcljmb.__unittest_L41_C1()\
    \ [0x428071]\\n??:? void tmp2axcljmb.__modtest() [0x42875c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42e0d7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42924e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ada1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ae30]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ad2d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x429225]\\n??:? runModuleUnitTests [0x42dead]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429a0c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429993]\\n??:? _d_run_main [0x4298fe]\\n??:? main [0x42876f]\\\
    n??:? __libc_start_main [0xed3d1554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ a list of strings.\n    The list contains different words. Return the word with\
    \ maximum number\n    of unique characters. If multiple strings have maximum number\
    \ of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    find_max([\"name\", \"of\", \"string\"]) == \"string\"\n    find_max([\"\
    name\", \"enam\", \"game\"]) == \"enam\"\n    find_max([\"aaaaaaa\", \"bb\" ,\"\
    cc\"]) == \"\"aaaaaaa\"\n    \n*/\nstring find_max(string[] words) \n{\n    immutable\
    \ string result = \"\";\n    immutable uint max = 0;\n    foreach(word; words)\n\
    \    {\n        uint a = word.length;\n        uint c = 0;\n        foreach(letter;\
    \ word)\n        {\n            if(word.count(letter) == 1)\n            {\n \
    \               c += 1;\n            }\n        }\n        if(c >= max)\n    \
    \    {\n            max = c;\n            result = word;\n        }\n    }\n \
    \   return result;\n}\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjanuy90u.d(20): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `uint`\\n/tmp/tmpjanuy90u.d(24): Error: no property `count`\
    \ for type `string`\\n/tmp/tmpjanuy90u.d(31): Error: cannot modify `immutable`\
    \ expression `max`\\n/tmp/tmpjanuy90u.d(32): Error: cannot modify `immutable`\
    \ expression `result`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjanuy90u.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ a list of strings.\n    The list contains different words. Return the word with\
    \ maximum number\n    of unique characters. If multiple strings have maximum number\
    \ of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    find_max([\"name\", \"of\", \"string\"]) == \"string\"\n    find_max([\"\
    name\", \"enam\", \"game\"]) == \"enam\"\n    find_max([\"aaaaaaa\", \"bb\" ,\"\
    cc\"]) == \"\"aaaaaaa\"\n    \n*/\nstring find_max(string[] words) \n{\n    return\
    \ reduce!(d => d.length > a.length ? d : a)(words);\n}\nunittest\n{\n    alias\
    \ candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0ahmp0jd.d(16): Error: template instance `reduce!((d) => d.length\
    \ > a.length ? d : a)` template `reduce` is not defined\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmp0ahmp0jd.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ a list of strings.\n    The list contains different words. Return the word with\
    \ maximum number\n    of unique characters. If multiple strings have maximum number\
    \ of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    find_max([\"name\", \"of\", \"string\"]) == \"string\"\n    find_max([\"\
    name\", \"enam\", \"game\"]) == \"enam\"\n    find_max([\"aaaaaaa\", \"bb\" ,\"\
    cc\"]) == \"\"aaaaaaa\"\n    \n*/\nstring find_max(string[] words) \n{\n    immutable\
    \ result = words[0];\n    foreach(immutable word; words)\n    {\n        auto\
    \ length = word.length;\n        bool is_lexicographically_first = true;\n   \
    \     foreach(immutable other; words)\n        {\n            if(other == word)\
    \ continue;\n            is_lexicographically_first &= (word < other) || (other.length\
    \ < length);\n        }\n        if(is_lexicographically_first)\n        {\n \
    \           result = word;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgc501lym.d(28): Error: cannot modify `immutable` expression `result`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgc501lym.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ a list of strings.\n    The list contains different words. Return the word with\
    \ maximum number\n    of unique characters. If multiple strings have maximum number\
    \ of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    find_max([\"name\", \"of\", \"string\"]) == \"string\"\n    find_max([\"\
    name\", \"enam\", \"game\"]) == \"enam\"\n    find_max([\"aaaaaaa\", \"bb\" ,\"\
    cc\"]) == \"\"aaaaaaa\"\n    \n*/\nstring find_max(string[] words) \n{\n    string\
    \ max = \"\";\n    foreach(string word; words) \n    {\n        if(word.length\
    \ > max.length) \n        {\n            max = word;\n        }\n        else\
    \ if(word.length == max.length) \n        {\n            if(word < max) \n   \
    \         {\n                max = word;\n            }\n        }\n    }\n  \
    \  return max;\n}\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpaomm6053.d(44): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42913d]\\n??:? void tmpaomm6053.__unittest_L33_C1()\
    \ [0x4281a9]\\n??:? void tmpaomm6053.__modtest() [0x4283a4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42da6b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428e96]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a919]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a9a8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a8a5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428e6d]\\n??:? runModuleUnitTests [0x42d841]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4295e0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429567]\\n??:? _d_run_main [0x4294d2]\\n??:? main [0x4283b7]\\\
    n??:? __libc_start_main [0xa480a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ a list of strings.\n    The list contains different words. Return the word with\
    \ maximum number\n    of unique characters. If multiple strings have maximum number\
    \ of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    find_max([\"name\", \"of\", \"string\"]) == \"string\"\n    find_max([\"\
    name\", \"enam\", \"game\"]) == \"enam\"\n    find_max([\"aaaaaaa\", \"bb\" ,\"\
    cc\"]) == \"\"aaaaaaa\"\n    \n*/\nstring find_max(string[] words) \n{\n    string\
    \ str = \"\";\n    int i = 0;\n    foreach(string s; words) \n    {\n        int\
    \ count = length(unique(s));\n        if(count > i) \n        {\n            i\
    \ = count;\n            str = s;\n        }\n    }\n    return str;\n}\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvu9k_5qn.d(20): Error: undefined identifier `length`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvu9k_5qn.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ a list of strings.\n    The list contains different words. Return the word with\
    \ maximum number\n    of unique characters. If multiple strings have maximum number\
    \ of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    find_max([\"name\", \"of\", \"string\"]) == \"string\"\n    find_max([\"\
    name\", \"enam\", \"game\"]) == \"enam\"\n    find_max([\"aaaaaaa\", \"bb\" ,\"\
    cc\"]) == \"\"aaaaaaa\"\n    \n*/\nstring find_max(string[] words) \n{\n    //\
    \ write your code here\n    string ret = \"\";\n    string candidate = \"\";\n\
    \    int max_count = 0;\n    foreach(string item; words)\n    {\n        if(ret.empty)\n\
    \        {\n            ret = item;\n            max_count = item.length;\n  \
    \      }\n        else\n        {\n            if(max_count <= item.length)\n\
    \            {\n                max_count = item.length;\n                foreach(string\
    \ sub_item; item)\n                {\n                    if(!std.algorithm.any!(ch\
    \ => ch == sub_item)(candidate))\n                    {\n                    \
    \    candidate ~= sub_item;\n                    }\n                }\n      \
    \      }\n            if(max_count == candidate.length)\n            {\n     \
    \           if(ret > item)\n                {\n                    ret = item;\n\
    \                }\n            }\n        }\n    }\n    return ret;\n}\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfqoehoxa.d(22): Error: no property `empty` for type `string`\\\
    n/tmp/tmpfqoehoxa.d(25): Error: cannot implicitly convert expression `item.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpfqoehoxa.d(31): Error: cannot implicitly\
    \ convert expression `item.length` of type `ulong` to `int`\\n/tmp/tmpfqoehoxa.d(32):\
    \ Error: cannot implicitly convert expression `__r76[__key77]` of type `immutable(char)`\
    \ to `string`\\n/tmp/tmpfqoehoxa.d(34): Error: undefined identifier `algorithm`\
    \ in package `std`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfqoehoxa.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ a list of strings.\n    The list contains different words. Return the word with\
    \ maximum number\n    of unique characters. If multiple strings have maximum number\
    \ of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    find_max([\"name\", \"of\", \"string\"]) == \"string\"\n    find_max([\"\
    name\", \"enam\", \"game\"]) == \"enam\"\n    find_max([\"aaaaaaa\", \"bb\" ,\"\
    cc\"]) == \"\"aaaaaaa\"\n    \n*/\nstring find_max(string[] words) \n{\n    string\
    \ ret = \"\";\n    foreach(ref word; words)\n    {\n        if(word.length > ret.length)\n\
    \        {\n            if(ret.length == 0)\n            {\n                ret\
    \ = word;\n            }\n            else\n            {\n                foreach(i;\
    \ 0 .. ret.length)\n                {\n                    if(ret[i] != word[i])\n\
    \                    {\n                        ret = word;\n                \
    \        break;\n                    }\n                }\n            }\n   \
    \     }\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpsnc8yl3q.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4290fd]\\n??:? void tmpsnc8yl3q.__unittest_L40_C1()\
    \ [0x427d5e]\\n??:? void tmpsnc8yl3q.__modtest() [0x428368]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42da4b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428e56]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a8f9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a988]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a885]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428e2d]\\n??:? runModuleUnitTests [0x42d821]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4295c0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429547]\\n??:? _d_run_main [0x4294b2]\\n??:? main [0x42837b]\\\
    n??:? __libc_start_main [0x68eb4554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ a list of strings.\n    The list contains different words. Return the word with\
    \ maximum number\n    of unique characters. If multiple strings have maximum number\
    \ of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    find_max([\"name\", \"of\", \"string\"]) == \"string\"\n    find_max([\"\
    name\", \"enam\", \"game\"]) == \"enam\"\n    find_max([\"aaaaaaa\", \"bb\" ,\"\
    cc\"]) == \"\"aaaaaaa\"\n    \n*/\nstring find_max(string[] words) \n{\n    \n\
    \    string top_word = \"\";\n    int top_length = 0;\n    foreach(string word;\
    \ words)\n    {\n        int word_length = count_unique_chars(word);\n       \
    \ if(word_length > top_length)\n        {\n            top_length = word_length;\n\
    \            top_word = word;\n        }\n        else if(word_length == top_length)\n\
    \        {\n            top_word = min(top_word, word);\n        }\n    }\n  \
    \  return top_word;\n}\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmje_4mrf.d(21): Error: undefined identifier `count_unique_chars`\\\
    n/tmp/tmpmje_4mrf.d(29): Error: undefined identifier `min`, did you mean function\
    \ `main`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmje_4mrf.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ a list of strings.\n    The list contains different words. Return the word with\
    \ maximum number\n    of unique characters. If multiple strings have maximum number\
    \ of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    find_max([\"name\", \"of\", \"string\"]) == \"string\"\n    find_max([\"\
    name\", \"enam\", \"game\"]) == \"enam\"\n    find_max([\"aaaaaaa\", \"bb\" ,\"\
    cc\"]) == \"\"aaaaaaa\"\n    \n*/\nstring find_max(string[] words) \n{\n\tstring\
    \ max = words[0];\n\tforeach(string word; words) \n\t{\n\t\tif(word.length ==\
    \ max.length)\n\t\t{\n\t\t\tsize_t maxUniq = 0;\n\t\t\tsize_t uniq = 0;\n\t\t\t\
    foreach(char c; word) \n\t\t\t{\n\t\t\t\tif(word.indexOf(c) == word.lastIndexOf(c))\n\
    \t\t\t\t{\n\t\t\t\t\tuniq++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tforeach(char c; max) \n\
    \t\t\t{\n\t\t\t\tif(max.indexOf(c) == max.lastIndexOf(c))\n\t\t\t\t{\n\t\t\t\t\
    \tmaxUniq++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(uniq > maxUniq)\n\t\t\t{\n\t\t\t\t\
    max = word;\n\t\t\t}\n\t\t}\n\t\telse if(word.length > max.length)\n\t\t{\n\t\t\
    \tmax = word;\n\t\t}\n\t}\n\treturn max;\n}\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3jxursjy.d(25): Error: no property `indexOf` for type `string`\\\
    n/tmp/tmp3jxursjy.d(25): Error: no property `lastIndexOf` for type `string`\\\
    n/tmp/tmp3jxursjy.d(32): Error: no property `indexOf` for type `string`\\n/tmp/tmp3jxursjy.d(32):\
    \ Error: no property `lastIndexOf` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp3jxursjy.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ a list of strings.\n    The list contains different words. Return the word with\
    \ maximum number\n    of unique characters. If multiple strings have maximum number\
    \ of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    find_max([\"name\", \"of\", \"string\"]) == \"string\"\n    find_max([\"\
    name\", \"enam\", \"game\"]) == \"enam\"\n    find_max([\"aaaaaaa\", \"bb\" ,\"\
    cc\"]) == \"\"aaaaaaa\"\n    \n*/\nstring find_max(string[] words) \n{\n    char[][]\
    \ chars = map!(w => w.dup, words);\n    string[] dupes = filter!(c => c.length\
    \ != uniq(c).length)(chars);\n    if (dupes.length == 0)\n        return \"\"\
    ;\n    else\n        return dupes[0];\n}\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2cjer3qc.d(16): Error: template instance `map!((w) => w.dup,\
    \ words)` template `map` is not defined\\n/tmp/tmp2cjer3qc.d(17): Error: template\
    \ instance `filter!((c) => c.length != uniq(c).length)` template `filter` is not\
    \ defined\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2cjer3qc.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ a list of strings.\n    The list contains different words. Return the word with\
    \ maximum number\n    of unique characters. If multiple strings have maximum number\
    \ of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    find_max([\"name\", \"of\", \"string\"]) == \"string\"\n    find_max([\"\
    name\", \"enam\", \"game\"]) == \"enam\"\n    find_max([\"aaaaaaa\", \"bb\" ,\"\
    cc\"]) == \"\"aaaaaaa\"\n    \n*/\nstring find_max(string[] words) \n{\n    //\
    \ Use 'enumerate' to loop over index and value\n    return words\n        .enumerate()\n\
    \        .reduce!(max)(\"\")._1;\n}\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4ciyva3j.d(18): Error: no property `enumerate` for type `string[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4ciyva3j.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ a list of strings.\n    The list contains different words. Return the word with\
    \ maximum number\n    of unique characters. If multiple strings have maximum number\
    \ of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    find_max([\"name\", \"of\", \"string\"]) == \"string\"\n    find_max([\"\
    name\", \"enam\", \"game\"]) == \"enam\"\n    find_max([\"aaaaaaa\", \"bb\" ,\"\
    cc\"]) == \"\"aaaaaaa\"\n    \n*/\nstring find_max(string[] words) \n{\n    string\
    \ s = \"\";\n    foreach(i; words)\n    {\n        if(unique(i).length == max(unique(i).length,\
    \ unique(s).length))\n        {\n            s = i;\n        }\n    }\n    return\
    \ s;\n}\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2jk_v_l4.d(19): Error: undefined identifier `unique`, did you\
    \ mean struct `Unique(T)`?\\n/tmp/tmp2jk_v_l4.d(19): Error: undefined identifier\
    \ `max`, did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp2jk_v_l4.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ a list of strings.\n    The list contains different words. Return the word with\
    \ maximum number\n    of unique characters. If multiple strings have maximum number\
    \ of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    find_max([\"name\", \"of\", \"string\"]) == \"string\"\n    find_max([\"\
    name\", \"enam\", \"game\"]) == \"enam\"\n    find_max([\"aaaaaaa\", \"bb\" ,\"\
    cc\"]) == \"\"aaaaaaa\"\n    \n*/\nstring find_max(string[] words) \n{\n    string\
    \ ret;\n    int maxUnique = 0;\n    foreach(word; words)\n    {\n        int unique\
    \ = 0;\n        dchar[] set = [];\n        foreach(c; word)\n        {\n     \
    \       if(unique == 0)\n            {\n                set ~= c;\n          \
    \      unique = 1;\n            }\n            else\n            {\n         \
    \       if(!set.canFind(c))\n                {\n                    set ~= c;\n\
    \                    unique++;\n                }\n            }\n        }\n\
    \        if(unique > maxUnique)\n        {\n            maxUnique = unique;\n\
    \            ret = word;\n        }\n    }\n    return ret;\n}\nunittest\n{\n\
    \    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"\
    string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7n7gephw.d(31): Error: no property `canFind` for type `dchar[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7n7gephw.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ a list of strings.\n    The list contains different words. Return the word with\
    \ maximum number\n    of unique characters. If multiple strings have maximum number\
    \ of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    find_max([\"name\", \"of\", \"string\"]) == \"string\"\n    find_max([\"\
    name\", \"enam\", \"game\"]) == \"enam\"\n    find_max([\"aaaaaaa\", \"bb\" ,\"\
    cc\"]) == \"\"aaaaaaa\"\n    \n*/\nstring find_max(string[] words) \n{\n    immutable\
    \ d = -1;\n    immutable cur = \"\";\n    foreach(string s; words) \n    {\n \
    \       immutable dict = 0;\n        foreach(immutable c; s)\n        {\n    \
    \        dict |= (1 << (c - 'a'));\n        }\n        if(popCnt(dict) > d) \n\
    \        {\n            d = popCnt(dict);\n            cur = s;\n        } \n\
    \        else if(popCnt(dict) == d) \n        {\n            if(cur > s)\n   \
    \         {\n                cur = s;\n            }\n        }\n    }\n    return\
    \ cur;\n}\n//\nimport std.stdio;\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6yky08ky.d(23): Error: cannot modify `immutable` expression `0`\\\
    n/tmp/tmp6yky08ky.d(25): Error: undefined identifier `popCnt`\\n/tmp/tmp6yky08ky.d(27):\
    \ Error: undefined identifier `popCnt`\\n/tmp/tmp6yky08ky.d(28): Error: cannot\
    \ modify `immutable` expression `cur`\\n/tmp/tmp6yky08ky.d(30): Error: undefined\
    \ identifier `popCnt`\\n/tmp/tmp6yky08ky.d(34): Error: cannot modify `immutable`\
    \ expression `cur`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6yky08ky.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ a list of strings.\n    The list contains different words. Return the word with\
    \ maximum number\n    of unique characters. If multiple strings have maximum number\
    \ of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    find_max([\"name\", \"of\", \"string\"]) == \"string\"\n    find_max([\"\
    name\", \"enam\", \"game\"]) == \"enam\"\n    find_max([\"aaaaaaa\", \"bb\" ,\"\
    cc\"]) == \"\"aaaaaaa\"\n    \n*/\nstring find_max(string[] words) \n{\n    string\
    \ result = words[0];\n    int size = words.length;\n    for (int i = 1; i < size;\
    \ i++)\n    {\n        auto s = find_max_string(result, words[i]);\n        result\
    \ = s;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpukjjhmcc.d(17): Error: cannot implicitly convert expression `words.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpukjjhmcc.d(20): Error: undefined identifier\
    \ `find_max_string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpukjjhmcc.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ a list of strings.\n    The list contains different words. Return the word with\
    \ maximum number\n    of unique characters. If multiple strings have maximum number\
    \ of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    find_max([\"name\", \"of\", \"string\"]) == \"string\"\n    find_max([\"\
    name\", \"enam\", \"game\"]) == \"enam\"\n    find_max([\"aaaaaaa\", \"bb\" ,\"\
    cc\"]) == \"\"aaaaaaa\"\n    \n*/\nstring find_max(string[] words) \n{\n    assert(words.length\
    \ > 0);\n    string str1 = words[0];\n    for (uint i = 1; i < words.length; i++)\n\
    \    {\n        if (words[i].length > str1.length)\n        {\n            str1\
    \ = words[i];\n        }\n    }\n    if (str1.length == 1)\n    {\n        return\
    \ str1;\n    }\n    string str2 = \"\";\n    int count = 0;\n    foreach (element;\
    \ words)\n    {\n        bool result = true;\n        foreach (d; element)\n \
    \       {\n            if (count(element, d) > 1)\n            {\n           \
    \     result = false;\n                break;\n            }\n        }\n    \
    \    if (result == true)\n        {\n            if (element.length > str2.length)\n\
    \            {\n                str2 = element;\n            }\n        }\n  \
    \  }\n    if (str2 == \"\")\n    {\n        return str1;\n    }\n    return str2;\n\
    }\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpl3j_0_db.d(36): Error: function expected before `()`, not `count`\
    \ of type `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl3j_0_db.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
