name: HumanEval_128_prod_signs
language: d
results:
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    long s = 1,\
    \ t = 0;\n    foreach(n; arr) \n    {\n        s *= sign(n);\n        t += abs(n);\n\
    \    }\n    return s ? s * t : null;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\
    \n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpze__u6o1.d(21): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpze__u6o1.d(24): Error: incompatible types\
    \ for `(s * t) : (null)`: `long` and `typeof(null)`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpze__u6o1.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return Nullable!(long)();\n    auto s = new long[](arr.length);\n    foreach\
    \ (i, e; arr) \n    {\n        if (e > 0) s[i] = 1;\n        else if (e < 0) s[i]\
    \ = -1;\n        else s[i] = 0;\n    }\n    return reduce!(\"a * b\")(abs(e) for\
    \ e in arr) * reduce!(\"a * b\")(s);\n}\nunittest\n{\n    alias candidate = prod_signs;\n\
    \n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpguh1am6h.d(26): Error: found `for` when expecting `,`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpguh1am6h.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    long[] signs;\n\
    \    foreach (n; arr)\n    {\n        // Store signs of each number\n        signs\
    \ ~= sign(n);\n    }\n    if (signs.length == 0) \n    {\n        return null;\n\
    \    }\n    long prodSigns = 1;\n    foreach (sign; signs)\n    {\n        prodSigns\
    \ *= sign;\n    }\n    long sumMagnitudes = 0;\n    foreach (n; arr)\n    {\n\
    \        // Sum magnitudes\n        sumMagnitudes += abs(n);\n    }\n    return\
    \ sumMagnitudes * prodSigns;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\
    \n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprdnq_jey.d(22): Error: undefined identifier `sign`, did you mean\
    \ variable `signs`?\\n/tmp/tmprdnq_jey.d(26): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmprdnq_jey.d(39):\
    \ Error: cannot implicitly convert expression `sumMagnitudes * prodSigns` of type\
    \ `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmprdnq_jey.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n  if (arr.length\
    \ == 0)\n    return null;\n  long product = 1;\n  foreach (num; arr)\n  {\n  \
    \  product *= sign(num);\n  }\n  long sum = 0;\n  foreach (num; arr)\n  {\n  \
    \  sum += abs(num);\n  }\n  return product * sum;\n}\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpx9leddct.d(23): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpx9leddct.d(19): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpx9leddct.d(30):\
    \ Error: cannot implicitly convert expression `product * sum` of type `long` to\
    \ `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx9leddct.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return null;\n    }\n    long sum_magn = 0;\n    long\
    \ prod_sign = 1;\n    foreach (n; arr) \n    {\n        if (n != 0) \n       \
    \ {\n            sum_magn += abs(n);\n            prod_sign *= sign(n);\n    \
    \    }\n    }\n    return sum_magn * prod_sign;\n}\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgp18v61y.d(29): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpgp18v61y.d(20): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpgp18v61y.d(32):\
    \ Error: cannot implicitly convert expression `sum_magn * prod_sign` of type `long`\
    \ to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgp18v61y.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return Nullable!(long)();\n    \n    auto signs = arr.map!(a\
    \ => (long)round(a/abs(a)));\n    auto vals = arr.map!(a => abs(a));\n    return\
    \ signs.reduce!((a,b) => a*b) * vals.reduce!((a,b) => a+b);\n}\nunittest\n{\n\
    \    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppin77xs8.d(21): Error: C style cast illegal, use `cast(long)round(a\
    \ / abs(a))`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppin77xs8.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    long res = 1L;\n\
    \    foreach(n; arr) {\n        res *= signbit(n);\n    }\n    return res == 0\
    \ ? res : res * sum(arr.map!abs.array);\n}\nunittest\n{\n    alias candidate =\
    \ prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n    \
    \    assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(271):\
    \ Error: no property `epsilon` for type `long`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(272):\
    \ Error: no property `mant_dig` for type `long`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(292):\
    \ Error: no property `mant_dig` for type `long`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(335):\
    \ Error: no property `mant_dig` for type `long`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(353):\
    \ Error: no property `mant_dig` for type `long`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(371):\
    \ Error: no property `mant_dig` for type `long`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(6254):\
    \ Error: template instance `std.math.floatTraits!long` error instantiating\\n/tmp/tmp0xgpnzvi.d(20):\
    \        instantiated from here: `signbit!long`\\n/tmp/tmp0xgpnzvi.d(22): Error:\
    \ undefined identifier `sum`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp0xgpnzvi.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return Nullable!(long)();\n    long prod = 1;\n    long sum =\
    \ 0;\n    foreach (i; arr)\n    {\n        prod *= sign(i);\n        sum += i.abs;\n\
    \    }\n    return Nullable!(long)(sum * prod);\n}\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp02xbq54f.d(24): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmp02xbq54f.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return Nullable!(long)();\n    }\n    long prodSigns\
    \ = 1;\n    long sumMagnitudes = 0;\n    foreach (i; arr) \n    {\n        if\
    \ (i < 0) \n        {\n            prodSigns *= -1;\n        }\n        if (i\
    \ == 0) \n        {\n            prodSigns = 0;\n        }\n        if (i != 0)\
    \ \n        {\n            sumMagnitudes += abs(i);\n        }\n    }\n    return\
    \ Nullable!(long)(sumMagnitudes * prodSigns);\n}\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return Nullable!(long)();\n    \n    long p = 1;\n    long s\
    \ = 0;\n    foreach (a; arr) \n    {\n        if (a < 0)\n            p *= -1;\n\
    \        else if (a > 0)\n            p *= 1;\n        else\n            p *=\
    \ 0;\n        s += a.abs;\n    }\n    return Nullable!(long)(p * s);\n}\n \nunittest\n\
    {\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    long sum = 0;\n\
    \    long prod = 1;\n    foreach(num; arr) \n    {\n        if (num == 0)\n  \
    \          return null;\n        prod *= sign(num);\n        sum += abs(num);\n\
    \    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\
    \n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpoh7undj9.d(24): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpoh7undj9.d(23): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpoh7undj9.d(27):\
    \ Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoh7undj9.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    long ret = 1;\n\
    \    foreach(e; arr)\n    {\n        if(e == 0)\n            ret = 0;\n      \
    \  else\n            ret *= e / abs(e);\n    }\n    foreach(e; arr)\n    {\n \
    \       if(e == 0)\n            ret = 0;\n        else\n            ret *= abs(e);\n\
    \    }\n    return ret;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5_bd5tdr.d(33): Error: cannot implicitly convert expression `ret`\
    \ of type `long` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp5_bd5tdr.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return null;\n    long res = 1;\n    long total = 0;\n    foreach (num;\
    \ arr)\n    {\n        if (num == 0) continue;\n        res *= sign(num);\n  \
    \      total += abs(num);\n    }\n    return res * total;\n}\nunittest\n{\n  \
    \  alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L,\
    \ 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n \
    \       auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n\
    \        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc13noumb.d(24): Error: undefined identifier `sign`, did you mean\
    \ template `sgn(F)(F x)`?\\n/tmp/tmpc13noumb.d(18): Error: cannot implicitly convert\
    \ expression `null` of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpc13noumb.d(27):\
    \ Error: cannot implicitly convert expression `res * total` of type `long` to\
    \ `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc13noumb.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    auto signs =\
    \ arr.map!(i => sign(i));\n    auto product = reduce!((a, b) => a * b)(signs);\n\
    \    if (product == 0) return null;\n    return product * reduce!((a, b) => a\
    \ + b)(arr.map!(abs));\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnpg2m25i.d(18): Error: no property `map` for type `long[]`\\\
    n/tmp/tmpnpg2m25i.d(19): Error: template instance `reduce!((a, b) => a * b)` template\
    \ `reduce` is not defined\\n/tmp/tmpnpg2m25i.d(21): Error: template instance `reduce!((a,\
    \ b) => a + b)` template `reduce` is not defined\\n/tmp/tmpnpg2m25i.d(20): Error:\
    \ cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnpg2m25i.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return null;\n    }\n    long sum_mag = 0;\n    int prod_sign\
    \ = 1;\n    foreach (i; arr) \n    {\n        sum_mag += abs(i);\n        prod_sign\
    \ *= abs(i) / i;\n    }\n    return sum_mag * prod_sign;\n}\nunittest\n{\n   \
    \ alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L,\
    \ 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n \
    \       auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n\
    \        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0jgq73gu.d(20): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmp0jgq73gu.d(29): Error: cannot\
    \ implicitly convert expression `sum_mag * cast(long)prod_sign` of type `long`\
    \ to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0jgq73gu.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return null;\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n  \
    \      auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpuct066z0.d(19): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuct066z0.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    /*\n    *\n\
    \    * Logic:\n    * Each product of signs is equal to the product of all signs.\n\
    \    * So we just need to keep track of the sign of each value.\n    *\n    */\n\
    \    Nullable!(long) answer = Nullable!(long)(0);\n    long prodSigns = 1;\n \
    \   foreach(element; arr)\n    {\n        if(element == 0)\n        {\n      \
    \      answer = Nullable!(long)(-1);\n            break;\n        }\n        else\n\
    \        {\n            element > 0 ? answer.get!(long) += abs(element) : answer.get!(long)\
    \ -= abs(element);\n            prodSigns *= signbit(element) ? -1 : 1;\n    \
    \    }\n    }\n    if(answer.isSome == true)\n    {\n        answer.get!(long)\
    \ *= prodSigns;\n    }\n    return answer;\n}\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqucti33z.d(36): Error: `inout` method `std.typecons.Nullable!long.Nullable.get!long.get`\
    \ is not callable using a mutable object\\n/tmp/tmpqucti33z.d(36): Error: `inout`\
    \ method `std.typecons.Nullable!long.Nullable.get!long.get` is not callable using\
    \ a mutable object\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(271):\
    \ Error: no property `epsilon` for type `long`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(272):\
    \ Error: no property `mant_dig` for type `long`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(292):\
    \ Error: no property `mant_dig` for type `long`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(335):\
    \ Error: no property `mant_dig` for type `long`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(353):\
    \ Error: no property `mant_dig` for type `long`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(371):\
    \ Error: no property `mant_dig` for type `long`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(6254):\
    \ Error: template instance `std.math.floatTraits!long` error instantiating\\n/tmp/tmpqucti33z.d(37):\
    \        instantiated from here: `signbit!long`\\n/tmp/tmpqucti33z.d(40): Error:\
    \ no property `isSome` for type `Nullable!long`\\n/tmp/tmpqucti33z.d(42): Error:\
    \ `inout` method `std.typecons.Nullable!long.Nullable.get!long.get` is not callable\
    \ using a mutable object\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmpqucti33z.d\", \"-I/tmp\"]"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n\tif (arr.length\
    \ == 0)\n\t\treturn Nullable!(long)();\n\t\n\treturn reduce!((a, b) => a * abs(b))(arr)\
    \ * reduce!((a, b) => a * (b > 0 ? 1 : b < 0 ? -1 : 0))(arr);\n}\nunittest\n{\n\
    \    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpib5wnyhb.d(21): Error: template instance `reduce!((a, b) => a\
    \ * abs(b))` template `reduce` is not defined\\n/tmp/tmpib5wnyhb.d(21): Error:\
    \ template instance `reduce!((a, b) => a * (b > 0 ? 1 : b < 0 ? -1 : 0))` template\
    \ `reduce` is not defined\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmpib5wnyhb.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return null;\n    long res = 1, sum = 0;\n    foreach (i; arr) \n    {\n\
    \        if (i > 0) \n        {\n            res *= 1;\n            sum += i;\n\
    \        }\n        else if (i < 0) \n        {\n            res *= -1;\n    \
    \        sum += abs(i);\n        }\n        else \n        {\n            res\
    \ *= 0;\n        }\n    }\n    if (res == 0) return 0;\n    return res * sum;\n\
    }\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result =\
    \ candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get ==\
    \ -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjl9aps8c.d(18): Error: cannot implicitly convert expression `null`\
    \ of type `typeof(null)` to `Nullable!long`\\n/tmp/tmpjl9aps8c.d(37): Error: cannot\
    \ implicitly convert expression `0` of type `int` to `Nullable!long`\\n/tmp/tmpjl9aps8c.d(38):\
    \ Error: cannot implicitly convert expression `res * sum` of type `long` to `Nullable!long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjl9aps8c.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) ==\
    \ None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return null;\n    }\n    long result = 1;\n    foreach\
    \ (i; arr) \n    {\n        result *= i > 0 ? 1 : (i < 0 ? -1 : 0);\n    }\n \
    \   return result * arr.map!(abs).sum;\n}\nunittest\n{\n    alias candidate =\
    \ prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n    \
    \    assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnpt1pmwj.d(27): Error: no property `map` for type `long[]`\\\
    n/tmp/tmpnpt1pmwj.d(20): Error: cannot implicitly convert expression `null` of\
    \ type `typeof(null)` to `Nullable!long`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpnpt1pmwj.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
