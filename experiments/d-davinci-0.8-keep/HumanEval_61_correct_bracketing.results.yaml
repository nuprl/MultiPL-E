name: HumanEval_61_correct_bracketing
language: d
results:
- program: "import std.typecons;\nimport std.math;\n/*\n brackets is a string of \"\
    (\" and \")\".\n    return True if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"\
    ()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\"\
    )(()\")\n    False\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int len = brackets.length;\n    if (len == 0) return true;\n    // in case\
    \ that some brackets are not paired, then there should be at least one open bracket\
    \ left\n    if (brackets[len-1] == ')') return false;\n    while (brackets.length\
    \ > 0) {\n        size_t pos = brackets.find(\")\");\n        if (pos == string.npos)\
    \ return false;\n        brackets = brackets[0..pos-1];\n        if (brackets.length\
    \ == 0) return false;\n        pos = brackets.rfind(\"(\");\n        if (pos ==\
    \ string.npos) return false;\n        brackets = brackets[pos+1..brackets.length];\n\
    \    }\n    return true;\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"()\") == true);\n    assert(candidate(\"(()())\") ==\
    \ true);\n    assert(candidate(\"()()(()())()\") == true);\n    assert(candidate(\"\
    ()()((()()())())(()()(()))\") == true);\n    assert(candidate(\"((()())))\") ==\
    \ false);\n    assert(candidate(\")(()\") == false);\n    assert(candidate(\"\
    (\") == false);\n    assert(candidate(\"((((\") == false);\n    assert(candidate(\"\
    )\") == false);\n    assert(candidate(\"(()\") == false);\n    assert(candidate(\"\
    ()()(()())())(()\") == false);\n    assert(candidate(\"()()(()())()))()\") ==\
    \ false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9vt7p95_.d(19): Error: cannot implicitly convert expression `brackets.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp9vt7p95_.d(24): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp9vt7p95_.d(25): Error: no property `npos` for type\
    \ `string`\\n/tmp/tmp9vt7p95_.d(28): Error: no property `rfind` for type `string`\\\
    n/tmp/tmp9vt7p95_.d(29): Error: no property `npos` for type `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9vt7p95_.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n brackets is a string of \"\
    (\" and \")\".\n    return True if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"\
    ()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\"\
    )(()\")\n    False\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   bool r = true;\n    uint cnt = 0;\n    foreach(c; brackets)\n    {\n     \
    \   if(c == '(')\n            cnt++;\n        else if(c == ')')\n            cnt--;\n\
    \        if(cnt < 0)\n        {\n            r = false;\n            break;\n\
    \        }\n    }\n    return r && cnt == 0;\n}\nunittest\n{\n    alias candidate\
    \ = correct_bracketing;\n\n    assert(candidate(\"()\") == true);\n    assert(candidate(\"\
    (()())\") == true);\n    assert(candidate(\"()()(()())()\") == true);\n    assert(candidate(\"\
    ()()((()()())())(()()(()))\") == true);\n    assert(candidate(\"((()())))\") ==\
    \ false);\n    assert(candidate(\")(()\") == false);\n    assert(candidate(\"\
    (\") == false);\n    assert(candidate(\"((((\") == false);\n    assert(candidate(\"\
    )\") == false);\n    assert(candidate(\"(()\") == false);\n    assert(candidate(\"\
    ()()(()())())(()\") == false);\n    assert(candidate(\"()()(()())()))()\") ==\
    \ false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpugfpiizm.d(44): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f0d]\\n??:? void tmpugfpiizm.__unittest_L35_C1()\
    \ [0x427b87]\\n??:? void tmpugfpiizm.__modtest() [0x427c90]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc33]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42aac6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc59]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430108]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fbe5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aa9d]\\n??:? runModuleUnitTests [0x42ba09]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42835c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4282e3]\\n??:? _d_run_main [0x42824e]\\n??:? main [0x427ca3]\\\
    n??:? __libc_start_main [0x75902554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n brackets is a string of \"\
    (\" and \")\".\n    return True if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"\
    ()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\"\
    )(()\")\n    False\n    \n*/\nbool correct_bracketing(string brackets) \n    {\n\
    \    static struct parenthesis_match\n        {\n        char open,close;\n  \
    \      }\n    matches[] = \n        {\n        {'(',')'},\n        {'[',']'},\n\
    \        {'{','}'},\n        };\n    long num_matches = sizeof(matches)/sizeof(matches[0]);\n\
    \    int result = 0;\n    foreach(char c;brackets)\n        {\n        int match_num;\n\
    \        for(match_num = 0;match_num < num_matches;match_num++)\n            {\n\
    \            if(c == matches[match_num].open)\n                result++;\n   \
    \         else if(c == matches[match_num].close)\n                result--;\n\
    \            }\n        }\n    return result == 0;\n    }\nunittest\n{\n    alias\
    \ candidate = correct_bracketing;\n\n    assert(candidate(\"()\") == true);\n\
    \    assert(candidate(\"(()())\") == true);\n    assert(candidate(\"()()(()())()\"\
    ) == true);\n    assert(candidate(\"()()((()()())())(()()(()))\") == true);\n\
    \    assert(candidate(\"((()())))\") == false);\n    assert(candidate(\")(()\"\
    ) == false);\n    assert(candidate(\"(\") == false);\n    assert(candidate(\"\
    ((((\") == false);\n    assert(candidate(\")\") == false);\n    assert(candidate(\"\
    (()\") == false);\n    assert(candidate(\"()()(()())())(()\") == false);\n   \
    \ assert(candidate(\"()()(()())()))()\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpo40lgr2n.d(25): Error: found `}` when expecting `;` following\
    \ statement\\n/tmp/tmpo40lgr2n.d(25): Error: found `,` instead of statement\\\
    n/tmp/tmpo40lgr2n.d(26): Error: found `,` instead of statement\\n/tmp/tmpo40lgr2n.d(28):\
    \ Error: expression expected, not `}`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpo40lgr2n.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n brackets is a string of \"\
    (\" and \")\".\n    return True if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"\
    ()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\"\
    )(()\")\n    False\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int n = 0;\n    for (char c : brackets)\n    {\n        n += (c == '(' ? 1\
    \ : -1);\n        if (n < 0) \n            return false;\n    }\n    return n\
    \ == 0;\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    ()\") == true);\n    assert(candidate(\"(()())\") == true);\n    assert(candidate(\"\
    ()()(()())()\") == true);\n    assert(candidate(\"()()((()()())())(()()(()))\"\
    ) == true);\n    assert(candidate(\"((()())))\") == false);\n    assert(candidate(\"\
    )(()\") == false);\n    assert(candidate(\"(\") == false);\n    assert(candidate(\"\
    ((((\") == false);\n    assert(candidate(\")\") == false);\n    assert(candidate(\"\
    (()\") == false);\n    assert(candidate(\"()()(()())())(()\") == false);\n   \
    \ assert(candidate(\"()()(()())()))()\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2mco_ccb.d(20): Error: semicolon expected, not `:`\\n/tmp/tmp2mco_ccb.d(20):\
    \ Error: expression expected, not `:`\\n/tmp/tmp2mco_ccb.d(20): Error: found `brackets`\
    \ when expecting `;` following `for` condition\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp2mco_ccb.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n brackets is a string of \"\
    (\" and \")\".\n    return True if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"\
    ()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\"\
    )(()\")\n    False\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   ulong balance = 0;\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"()\") == true);\n    assert(candidate(\"(()())\") ==\
    \ true);\n    assert(candidate(\"()()(()())()\") == true);\n    assert(candidate(\"\
    ()()((()()())())(()()(()))\") == true);\n    assert(candidate(\"((()())))\") ==\
    \ false);\n    assert(candidate(\")(()\") == false);\n    assert(candidate(\"\
    (\") == false);\n    assert(candidate(\"((((\") == false);\n    assert(candidate(\"\
    )\") == false);\n    assert(candidate(\"(()\") == false);\n    assert(candidate(\"\
    ()()(()())())(()\") == false);\n    assert(candidate(\"()()(()())()))()\") ==\
    \ false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpao_5cprn.d(20): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpao_5cprn.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n brackets is a string of \"\
    (\" and \")\".\n    return True if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"\
    ()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\"\
    )(()\")\n    False\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   auto stack = new Stack!(int)();\n    for (int i = 0; i < brackets.length;\
    \ i++) \n    {\n        switch (brackets[i]) \n        {\n            case '(':\n\
    \                stack.push(0);\n                break;\n            case ')':\n\
    \                if (stack.empty)\n                    return false;\n       \
    \         stack.pop();\n                break;\n        }\n    }\n    return stack.empty;\n\
    }\n/*\n    You are given a string.\n    You need to remove at most one pair of\
    \ adjacent characters.\n    The goal is to remove as many pairs as possible.\n\
    unittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    ()\") == true);\n    assert(candidate(\"(()())\") == true);\n    assert(candidate(\"\
    ()()(()())()\") == true);\n    assert(candidate(\"()()((()()())())(()()(()))\"\
    ) == true);\n    assert(candidate(\"((()())))\") == false);\n    assert(candidate(\"\
    )(()\") == false);\n    assert(candidate(\"(\") == false);\n    assert(candidate(\"\
    ((((\") == false);\n    assert(candidate(\")\") == false);\n    assert(candidate(\"\
    (()\") == false);\n    assert(candidate(\"()()(()())())(()\") == false);\n   \
    \ assert(candidate(\"()()(()())()))()\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpultag4mc.d(36): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpultag4mc.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n brackets is a string of \"\
    (\" and \")\".\n    return True if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"\
    ()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\"\
    )(()\")\n    False\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   long depth = 0;\n    foreach(bracket; brackets) {\n        if (bracket ==\
    \ '(') {\n            depth++;\n        } else if (bracket == ')') {\n       \
    \     depth--;\n        }\n        if (depth < 0) {\n            return false;\n\
    \        }\n    }\n    return depth == 0;\n}\n/*\n combine_dicts is a dictionary\
    \ of dictionarys.\n    return a dictionary that combines all the key/value pairs\
    \ from the sub-dictionaries.\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"()\") == true);\n    assert(candidate(\"(()())\") ==\
    \ true);\n    assert(candidate(\"()()(()())()\") == true);\n    assert(candidate(\"\
    ()()((()()())())(()()(()))\") == true);\n    assert(candidate(\"((()())))\") ==\
    \ false);\n    assert(candidate(\")(()\") == false);\n    assert(candidate(\"\
    (\") == false);\n    assert(candidate(\"((((\") == false);\n    assert(candidate(\"\
    )\") == false);\n    assert(candidate(\"(()\") == false);\n    assert(candidate(\"\
    ()()(()())())(()\") == false);\n    assert(candidate(\"()()(()())()))()\") ==\
    \ false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjwn_rrip.d(32): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjwn_rrip.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n brackets is a string of \"\
    (\" and \")\".\n    return True if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"\
    ()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\"\
    )(()\")\n    False\n    \n*/\nbool correct_bracketing(string brackets) \n    in\n\
    \    {\n        assert(all!(e => e == \"(\" || e == \")\", brackets));\n    }\n\
    \    body\n    {\n        size_t depth = 0;\n        foreach(ch; brackets)\n \
    \       {\n            if(ch == \"(\")\n                depth += 1;\n        \
    \    else if(ch == \")\")\n                depth -= 1;\n            else\n   \
    \             assert(false);\n            \n            if(depth < 0)\n      \
    \          return false;\n        }\n        return depth == 0;\n    }\nunittest\n\
    {\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"()\") ==\
    \ true);\n    assert(candidate(\"(()())\") == true);\n    assert(candidate(\"\
    ()()(()())()\") == true);\n    assert(candidate(\"()()((()()())())(()()(()))\"\
    ) == true);\n    assert(candidate(\"((()())))\") == false);\n    assert(candidate(\"\
    )(()\") == false);\n    assert(candidate(\"(\") == false);\n    assert(candidate(\"\
    ((((\") == false);\n    assert(candidate(\")\") == false);\n    assert(candidate(\"\
    (()\") == false);\n    assert(candidate(\"()()(()())())(()\") == false);\n   \
    \ assert(candidate(\"()()(()())()))()\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpi5idaf4n.d(27): Error: incompatible types for `(ch) == (\"(\"\
    )`: `immutable(char)` and `string`\\n/tmp/tmpi5idaf4n.d(29): Error: incompatible\
    \ types for `(ch) == (\")\")`: `immutable(char)` and `string`\\n/tmp/tmpi5idaf4n.d(20):\
    \ Error: template instance `all!((e) => e == \"(\" || e == \")\", brackets)` template\
    \ `all` is not defined\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmpi5idaf4n.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n brackets is a string of \"\
    (\" and \")\".\n    return True if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"\
    ()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\"\
    )(()\")\n    False\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int p = 0;\n    int i = 0;\n    foreach(ch;brackets)\n    {\n        if(ch\
    \ == '(')\n        {\n            p++;\n        }\n        else if(ch == ')')\n\
    \        {\n            p--;\n        }\n        i++;\n        if(p < 0)\n   \
    \     {\n            return false;\n        }\n    }\n    if(p == 0)\n    {\n\
    \        return true;\n    }\n    else\n    {\n        return false;\n    }\n\
    }\n/*\n * return true if str is a palindrome, a string that reads the same\n *\
    \ forward and backward.\n *\n * >>> is_palindrome(\"abba\")\n * True\n * >>> is_palindrome(\"\
    abcba\")\n * True\n * >>> is_palindrome(\"\")\n * True\n * >>> is_palindrome(\"\
    abcd\")\n * False\n */\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"()\") == true);\n    assert(candidate(\"(()())\") ==\
    \ true);\n    assert(candidate(\"()()(()())()\") == true);\n    assert(candidate(\"\
    ()()((()()())())(()()(()))\") == true);\n    assert(candidate(\"((()())))\") ==\
    \ false);\n    assert(candidate(\")(()\") == false);\n    assert(candidate(\"\
    (\") == false);\n    assert(candidate(\"((((\") == false);\n    assert(candidate(\"\
    )\") == false);\n    assert(candidate(\"(()\") == false);\n    assert(candidate(\"\
    ()()(()())())(()\") == false);\n    assert(candidate(\"()()(()())()))()\") ==\
    \ false);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n brackets is a string of \"\
    (\" and \")\".\n    return True if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"\
    ()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\"\
    )(()\")\n    False\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   bool is_correct = true;\n    int bracket_count = 0;\n    foreach(ch; brackets)\n\
    \    {\n\tbracket_count += ch == '(' ? 1 : -1;\n\tif(bracket_count < 0)\n\t{\n\
    \t    is_correct = false;\n\t    break;\n\t}\n    }\n    return is_correct &&\
    \ (bracket_count == 0);\n}\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"()\") == true);\n    assert(candidate(\"(()())\") ==\
    \ true);\n    assert(candidate(\"()()(()())()\") == true);\n    assert(candidate(\"\
    ()()((()()())())(()()(()))\") == true);\n    assert(candidate(\"((()())))\") ==\
    \ false);\n    assert(candidate(\")(()\") == false);\n    assert(candidate(\"\
    (\") == false);\n    assert(candidate(\"((((\") == false);\n    assert(candidate(\"\
    )\") == false);\n    assert(candidate(\"(()\") == false);\n    assert(candidate(\"\
    ()()(()())())(()\") == false);\n    assert(candidate(\"()()(()())()))()\") ==\
    \ false);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n brackets is a string of \"\
    (\" and \")\".\n    return True if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"\
    ()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\"\
    )(()\")\n    False\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   if (empty(brackets)) return true;\n    int n = length(brackets);\n    if (brackets[0]\
    \ == ')') return false;\n    // brackets[0] == '('\n    if (n % 2 == 1) return\
    \ false;\nunittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    ()\") == true);\n    assert(candidate(\"(()())\") == true);\n    assert(candidate(\"\
    ()()(()())()\") == true);\n    assert(candidate(\"()()((()()())())(()()(()))\"\
    ) == true);\n    assert(candidate(\"((()())))\") == false);\n    assert(candidate(\"\
    )(()\") == false);\n    assert(candidate(\"(\") == false);\n    assert(candidate(\"\
    ((((\") == false);\n    assert(candidate(\")\") == false);\n    assert(candidate(\"\
    (()\") == false);\n    assert(candidate(\"()()(()())())(()\") == false);\n   \
    \ assert(candidate(\"()()(()())()))()\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpq5qlfi5h.d(24): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq5qlfi5h.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n brackets is a string of \"\
    (\" and \")\".\n    return True if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"\
    ()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\"\
    )(()\")\n    False\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int bracket_count = 0;\n    int i;\n    foreach(ch; brackets)\n    {\n   \
    \     if(ch == '(')\n        {\n            bracket_count++;\n        }\n    \
    \    else if(ch == ')')\n        {\n            bracket_count--;\n        }\n\
    \        else\n        {\n            assert(false);\n        }\n        if(bracket_count\
    \ < 0)\n        {\n            return false;\n        }\n    }\n    return (bracket_count\
    \ == 0);\n}\n/*\n    returns the maximum of list1, list2 and list3\n    >>> max_list([1,2,3,4,5])\n\
    \    5\n    >>> max_list([-1,1,10])\n    10\n    >>> max_list([1])\n    1\n*/\n\
    unittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    ()\") == true);\n    assert(candidate(\"(()())\") == true);\n    assert(candidate(\"\
    ()()(()())()\") == true);\n    assert(candidate(\"()()((()()())())(()()(()))\"\
    ) == true);\n    assert(candidate(\"((()())))\") == false);\n    assert(candidate(\"\
    )(()\") == false);\n    assert(candidate(\"(\") == false);\n    assert(candidate(\"\
    ((((\") == false);\n    assert(candidate(\")\") == false);\n    assert(candidate(\"\
    (()\") == false);\n    assert(candidate(\"()()(()())())(()\") == false);\n   \
    \ assert(candidate(\"()()(()())()))()\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n brackets is a string of \"\
    (\" and \")\".\n    return True if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"\
    ()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\"\
    )(()\")\n    False\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \ //std.file.write(\"debug.txt\", brackets);\n  int count = 0;\n  foreach(i, ch;\
    \ brackets) {\n    if (ch == '(') {\n      count++;\n    }\n    else if (ch ==\
    \ ')') {\n      count--;\n    }\n  }\n  if (count == 0) {\n    return true;\n\
    \  }\n  else {\n    return false;\n  }\n}\nunittest\n{\n    alias candidate =\
    \ correct_bracketing;\n\n    assert(candidate(\"()\") == true);\n    assert(candidate(\"\
    (()())\") == true);\n    assert(candidate(\"()()(()())()\") == true);\n    assert(candidate(\"\
    ()()((()()())())(()()(()))\") == true);\n    assert(candidate(\"((()())))\") ==\
    \ false);\n    assert(candidate(\")(()\") == false);\n    assert(candidate(\"\
    (\") == false);\n    assert(candidate(\"((((\") == false);\n    assert(candidate(\"\
    )\") == false);\n    assert(candidate(\"(()\") == false);\n    assert(candidate(\"\
    ()()(()())())(()\") == false);\n    assert(candidate(\"()()(()())()))()\") ==\
    \ false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp99kwcrv8.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f05]\\n??:? void tmp99kwcrv8.__unittest_L36_C1()\
    \ [0x427b7f]\\n??:? void tmp99kwcrv8.__modtest() [0x427c88]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc2b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42aabe]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc51]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430100]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fbdd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aa95]\\n??:? runModuleUnitTests [0x42ba01]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428354]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4282db]\\n??:? _d_run_main [0x428246]\\n??:? main [0x427c9b]\\\
    n??:? __libc_start_main [0xc81f2554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n brackets is a string of \"\
    (\" and \")\".\n    return True if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"\
    ()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\"\
    )(()\")\n    False\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   //variables\n    int bracket_counter = 0;\n    //iterate through every character\
    \ in brackets\n    foreach(char c; brackets)\n    {\n        //if current character\
    \ is ( increase counter\n        if(c == '(')\n        {\n            bracket_counter\
    \ += 1;\n        }\n        //if current character is ) decrease counter\n   \
    \     else if(c == ')')\n        {\n            bracket_counter -= 1;\n      \
    \  }\n        //if counter goes below 0 return false\n        if(bracket_counter\
    \ < 0)\n        {\n            return false;\n        }\n    }\n    //if counter\
    \ is 0 return true otherwise return false\n    return bracket_counter == 0;\n\
    }\n/*\n   returns length of longest prefix of s that has correct bracketing.\n\
    \   returns length of longest suffix of s that has correct bracketing.\n*/\nunittest\n\
    {\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"()\") ==\
    \ true);\n    assert(candidate(\"(()())\") == true);\n    assert(candidate(\"\
    ()()(()())()\") == true);\n    assert(candidate(\"()()((()()())())(()()(()))\"\
    ) == true);\n    assert(candidate(\"((()())))\") == false);\n    assert(candidate(\"\
    )(()\") == false);\n    assert(candidate(\"(\") == false);\n    assert(candidate(\"\
    ((((\") == false);\n    assert(candidate(\")\") == false);\n    assert(candidate(\"\
    (()\") == false);\n    assert(candidate(\"()()(()())())(()\") == false);\n   \
    \ assert(candidate(\"()()(()())()))()\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n brackets is a string of \"\
    (\" and \")\".\n    return True if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"\
    ()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\"\
    )(()\")\n    False\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   uint counter = 0;\n    for (int i = 0; i < brackets.length; i++)\n    {\n\
    \        if (brackets[i] == '(')\n        {\n            counter++;\n        }\n\
    \        else if (brackets[i] == ')')\n        {\n            counter--;\n   \
    \     }\n    }\n    return counter == 0;\n}\n/*\n short_circuit_eval is a string\
    \ containing boolean operators (&, |, !) and\n    boolean values (true, false).\n\
    \    return True if the expression evaluates to true.\nunittest\n{\n    alias\
    \ candidate = correct_bracketing;\n\n    assert(candidate(\"()\") == true);\n\
    \    assert(candidate(\"(()())\") == true);\n    assert(candidate(\"()()(()())()\"\
    ) == true);\n    assert(candidate(\"()()((()()())())(()()(()))\") == true);\n\
    \    assert(candidate(\"((()())))\") == false);\n    assert(candidate(\")(()\"\
    ) == false);\n    assert(candidate(\"(\") == false);\n    assert(candidate(\"\
    ((((\") == false);\n    assert(candidate(\")\") == false);\n    assert(candidate(\"\
    (()\") == false);\n    assert(candidate(\"()()(()())())(()\") == false);\n   \
    \ assert(candidate(\"()()(()())()))()\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvw34k8ii.d(33): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvw34k8ii.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n brackets is a string of \"\
    (\" and \")\".\n    return True if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"\
    ()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\"\
    )(()\")\n    False\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \ return count(brackets, \"(\") == count(brackets, \")\");\n}\n/*\n    brackets\
    \ is a string of \"(\" and \")\".\n    return the longest substring of brackets\
    \ starting at the beginning of brackets\n    that has the property that any prefix\
    \ has at least as many \"(\" as \")\".\nunittest\n{\n    alias candidate = correct_bracketing;\n\
    \n    assert(candidate(\"()\") == true);\n    assert(candidate(\"(()())\") ==\
    \ true);\n    assert(candidate(\"()()(()())()\") == true);\n    assert(candidate(\"\
    ()()((()()())())(()()(()))\") == true);\n    assert(candidate(\"((()())))\") ==\
    \ false);\n    assert(candidate(\")(()\") == false);\n    assert(candidate(\"\
    (\") == false);\n    assert(candidate(\"((((\") == false);\n    assert(candidate(\"\
    )\") == false);\n    assert(candidate(\"(()\") == false);\n    assert(candidate(\"\
    ()()(()())())(()\") == false);\n    assert(candidate(\"()()(()())()))()\") ==\
    \ false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdidhnqj6.d(21): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdidhnqj6.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n brackets is a string of \"\
    (\" and \")\".\n    return True if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"\
    ()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\"\
    )(()\")\n    False\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \ int count = 0;\n  foreach(c;brackets)\n  {\n    count += (c == '(' ? 1 : -1);\n\
    \    if(count < 0)\n      return false;\n  }\n  return count == 0;\n}\n/*\n  \
    \  return True if every opening bracket has a corresponding closing bracket.\n\
    unittest\n{\n    alias candidate = correct_bracketing;\n\n    assert(candidate(\"\
    ()\") == true);\n    assert(candidate(\"(()())\") == true);\n    assert(candidate(\"\
    ()()(()())()\") == true);\n    assert(candidate(\"()()((()()())())(()()(()))\"\
    ) == true);\n    assert(candidate(\"((()())))\") == false);\n    assert(candidate(\"\
    )(()\") == false);\n    assert(candidate(\"(\") == false);\n    assert(candidate(\"\
    ((((\") == false);\n    assert(candidate(\")\") == false);\n    assert(candidate(\"\
    (()\") == false);\n    assert(candidate(\"()()(()())())(()\") == false);\n   \
    \ assert(candidate(\"()()(()())()))()\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp57vauvin.d(28): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp57vauvin.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n brackets is a string of \"\
    (\" and \")\".\n    return True if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"\
    ()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\"\
    )(()\")\n    False\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int count = 0;\n    foreach(c; brackets) \n    {\n        count += c == '('\
    \ ? 1 : -1;\n        if (count < 0) \n        {\n            return false;\n \
    \       }\n    }\n    return count == 0;\n}\nunittest\n{\n    alias candidate\
    \ = correct_bracketing;\n\n    assert(candidate(\"()\") == true);\n    assert(candidate(\"\
    (()())\") == true);\n    assert(candidate(\"()()(()())()\") == true);\n    assert(candidate(\"\
    ()()((()()())())(()()(()))\") == true);\n    assert(candidate(\"((()())))\") ==\
    \ false);\n    assert(candidate(\")(()\") == false);\n    assert(candidate(\"\
    (\") == false);\n    assert(candidate(\"((((\") == false);\n    assert(candidate(\"\
    )\") == false);\n    assert(candidate(\"(()\") == false);\n    assert(candidate(\"\
    ()()(()())())(()\") == false);\n    assert(candidate(\"()()(()())()))()\") ==\
    \ false);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n brackets is a string of \"\
    (\" and \")\".\n    return True if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"\
    ()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\"\
    )(()\")\n    False\n    \n*/\nbool correct_bracketing(string brackets) \n{\n \
    \   int bracket_counter = 0;\n    foreach(char c; brackets) \n    {\n        if\
    \ (c == '(') \n        {\n            bracket_counter += 1;\n        } \n    \
    \    else if (c == ')') \n        {\n            bracket_counter -= 1;\n     \
    \   }\n        if (bracket_counter < 0) \n        {\n            return false;\n\
    \        }\n    }\n    return bracket_counter == 0;\n}\nunittest\n{\n    alias\
    \ candidate = correct_bracketing;\n\n    assert(candidate(\"()\") == true);\n\
    \    assert(candidate(\"(()())\") == true);\n    assert(candidate(\"()()(()())()\"\
    ) == true);\n    assert(candidate(\"()()((()()())())(()()(()))\") == true);\n\
    \    assert(candidate(\"((()())))\") == false);\n    assert(candidate(\")(()\"\
    ) == false);\n    assert(candidate(\"(\") == false);\n    assert(candidate(\"\
    ((((\") == false);\n    assert(candidate(\")\") == false);\n    assert(candidate(\"\
    (()\") == false);\n    assert(candidate(\"()()(()())())(()\") == false);\n   \
    \ assert(candidate(\"()()(()())()))()\") == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n brackets is a string of \"\
    (\" and \")\".\n    return True if every opening bracket has a corresponding closing\
    \ bracket.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"\
    ()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\"\
    )(()\")\n    False\n    \n*/\nbool correct_bracketing(string brackets) \n{\n\t\
    int temp = 0;\n\tforeach(c; brackets)\n\t{\n\t\tif(c == '(')\n\t\t\ttemp++;\n\t\
    \telse if(c == ')')\n\t\t\ttemp--;\n\t\tif(temp < 0)\n\t\t\treturn false;\n\t\
    }\n\treturn temp == 0;\n}\n/*\n  Returns true if a string is a palindrome (a string\
    \ which reads the same\n  forwards and backwards).\nunittest\n{\n    alias candidate\
    \ = correct_bracketing;\n\n    assert(candidate(\"()\") == true);\n    assert(candidate(\"\
    (()())\") == true);\n    assert(candidate(\"()()(()())()\") == true);\n    assert(candidate(\"\
    ()()((()()())())(()()(()))\") == true);\n    assert(candidate(\"((()())))\") ==\
    \ false);\n    assert(candidate(\")(()\") == false);\n    assert(candidate(\"\
    (\") == false);\n    assert(candidate(\"((((\") == false);\n    assert(candidate(\"\
    )\") == false);\n    assert(candidate(\"(()\") == false);\n    assert(candidate(\"\
    ()()(()())())(()\") == false);\n    assert(candidate(\"()()(()())()))()\") ==\
    \ false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0pqnz_9v.d(31): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0pqnz_9v.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
