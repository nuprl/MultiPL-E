name: HumanEval_6_parse_nested_parens
language: d
results:
- program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    struct ParenInfo\n\
    \    {\n        size_t parenLevel;\n        bool isOpen;\n        long parenIdx;\n\
    \    }\n    auto parenStack = ds.Stack!ParenInfo();\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxxaix4z4.d(21): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxxaix4z4.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // TODO: parse\
    \ input string and for each nested parenthesis group, output its maximum nesting\
    \ level\n    import std.algorithm;\n    import std.string;\n    return paren_string.split(\"\
    \ \").filter!(s => s.length > 0).map!(s =>\n    {\n        //stack depth from\
    \ left to right\n        int depth = 0;\n        int maxDepth = 0;\n        s.walkLength((d,\
    \ r) =>\n        {\n            if (r == '(')\n                ++depth;\n    \
    \        else if (r == ')')\n                --depth;\n            maxDepth =\
    \ max(maxDepth, depth);\n        });\n        return maxDepth;\n    }).array;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwx0vz63l.d(22): Error: no property `walkLength` for type `string`\\\
    n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/algorithm/iteration.d(499):\
    \        instantiated from here: `MapResult!(__lambda3, FilterResult!(__lambda2,\
    \ string[]))`\\n/tmp/tmpwx0vz63l.d(17):        instantiated from here: `map!(FilterResult!(__lambda2,\
    \ string[]))`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwx0vz63l.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    ulong max_nesting_level\
    \ = 0;\n    long[] opn_stack = [];\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6l74ktnq.d(16): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6l74ktnq.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    return paren_string.split(\"\
    \ \").map!(a => {\n        long[] val_stack;\n        long max_idx;\n        foreach(ch;\
    \ a)\n        {\n            if(ch == '(') \n            {\n                val_stack\
    \ ~= 1;\n                max_idx = max(max_idx, val_stack.length);\n         \
    \   }\n            else if(ch == ')') \n            {\n                val_stack.pop;\n\
    \            }\n        }\n        return max_idx;\n    }).array;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9yccjkcw.d(14): Error: no property `split` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9yccjkcw.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] res;\n\
    \    immutable long len = paren_string.length;\n    int count = 0;\n    int max\
    \ = 0;\n    long start = 0;\n    foreach(immutable long i; 0..len)\n    {\n  \
    \      if(paren_string[i] == '(')\n        {\n            count += 1;\n      \
    \      if(count > max)\n            {\n                max = count;\n        \
    \    }\n        }\n        else if(paren_string[i] == ')')\n        {\n      \
    \      count -= 1;\n        }\n        else if(paren_string[i] == ' ')\n     \
    \   {\n            if(max != 0)\n            {\n                res ~= max;\n\
    \                max = 0;\n            }\n            count = 0;\n        }\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpwyh65rw5.d(49): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4283dd]\\n??:? void tmpwyh65rw5.__unittest_L45_C1()\
    \ [0x427fcd]\\n??:? void tmpwyh65rw5.__modtest() [0x428160]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42ce27]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42bcba]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x43070d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430bbc]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430699]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42bc91]\\n??:? runModuleUnitTests [0x42cbfd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4288a0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428827]\\n??:? _d_run_main [0x428792]\\n??:? main [0x428173]\\\
    n??:? __libc_start_main [0x66ee554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // deep_nest\
    \ is the maximum depth of nested parentheses in a single group.\n    auto max_deep_nest\
    \ = (long n, long m) { return max(n, m); };\n    auto paren_groups = paren_string.split;\n\
    \    long[] ret_arr;\n    foreach (paren_group; paren_groups) \n    {\n      \
    \  ret_arr ~= paren_group.reduce!max_deep_nest(0, (long deep_nest, char c) {\n\
    \            return c == '(' ? deep_nest + 1 : deep_nest - 1;\n        });\n \
    \   }\n    return ret_arr;\n}\n \nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpabdeqx4e.d(15): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmpabdeqx4e.d(16): Error: no property `split` for type\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpabdeqx4e.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // FIXME\n\
    \    return null;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpjge2rdl3.d(21): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4282a5]\\n??:? void tmpjge2rdl3.__unittest_L17_C1()\
    \ [0x427e95]\\n??:? void tmpjge2rdl3.__modtest() [0x428028]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c28f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b122]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4302b5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430764]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430241]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b0f9]\\n??:? runModuleUnitTests [0x42c065]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4286f4]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42867b]\\n??:? _d_run_main [0x4285e6]\\n??:? main [0x42803b]\\\
    n??:? __libc_start_main [0xa38f6554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto result\
    \ = new long[](paren_string.count);\n    for (uint i = 0; i < paren_string.count;\
    \ i++)\n    {\n        int cur_depth = 0;\n        int max_depth = 0;\n      \
    \  for (uint j = 0; j < paren_string[i].count; j++)\n        {\n            if\
    \ (paren_string[i][j] == '(')\n            {\n                cur_depth++;\n \
    \               max_depth = max(max_depth, cur_depth);\n            }\n      \
    \      else if (paren_string[i][j] == ')')\n            {\n                cur_depth--;\n\
    \            }\n        }\n        result[i] = max_depth;\n    }\n    return result;\n\
    }\n/*\nInput is a sequence of parenthesis group.\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_18qovv4.d(35): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_18qovv4.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{ \n    long[] paren_levels\
    \ = new long[paren_string.length];\n    long paren_index = 0;\nunittest\n{\n \
    \   alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprd7m96e4.d(16): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprd7m96e4.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{ \n    long[] max_depth\
    \ = new long[];\n    long current_depth = 0;\n    long max_depth_in_group = 0;\n\
    \    foreach(immutable c; paren_string)\n    {\n        if(c == '(')\n       \
    \ {\n            current_depth += 1;\n            max_depth_in_group = max(max_depth_in_group,\
    \ current_depth);\n        }\n        else if(c == ')')\n        {\n         \
    \   current_depth -= 1;\n        }\n        else if(c == ' ')\n        {\n   \
    \         if(current_depth != 0)\n            {\n                assert(false,\
    \ \"Invalid paren string.\");\n            }\n            max_depth ~= max_depth_in_group;\n\
    \            max_depth_in_group = 0;\n        }\n    }\n    max_depth ~= max_depth_in_group;\n\
    \    return max_depth;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphqa0shof.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmphqa0shof.d(22): Error: undefined\
    \ identifier `max`, did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmphqa0shof.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    paren_string\
    \ = paren_string.rstrip();\n    long[] num_levels = paren_string.split().map!((string\
    \ s) {return count_nested_parens(s);}).array;\n    return num_levels;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpejoomqjj.d(14): Error: no property `rstrip` for type `string`\\\
    n/tmp/tmpejoomqjj.d(15): Error: no property `split` for type `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpejoomqjj.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\treturn paren_string.split().map!(a\
    \ => a.countUntil(')') - a.countUntil('(')).array;\n}\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdj14ghmk.d(14): Error: no property `split` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdj14ghmk.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    ulong counter\
    \ = 0;\n    long[] result = new long[];\n    foreach(c; paren_string)\n    {\n\
    \        if(c == '(')\n        {\n            counter++;\n        }\n        else\
    \ if(c == ')')\n        {\n            counter--;\n        }\n        else if(c\
    \ == ' ')\n        {\n            if(counter != 0)\n            {\n          \
    \      result ~= counter;\n            }\n            counter = 0;\n        }\n\
    \    }\n    if(counter != 0)\n    {\n        result ~= counter;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphefj0gm0.d(15): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmphefj0gm0.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    return paren_string.split(\"\
    \ \").map!(parens =>\n        parens.walkLength!((a, b) => a == '(' && b == ')').max).array;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_nexlgrq.d(14): Error: no property `split` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_nexlgrq.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto tokens\
    \ = paren_string.split;\n    long[] result;\n    int highest_nesting = 0;\n  \
    \  int nesting = 0;\n    foreach(paren_group; tokens)\n    {\n        foreach(paren;\
    \ paren_group)\n        {\n            if(paren == '(')\n            {\n     \
    \           nesting++;\n            }\n            else\n            {\n     \
    \           nesting--;\n            }\n            highest_nesting = max(nesting,\
    \ highest_nesting);\n        }\n        result ~= highest_nesting;\n        highest_nesting\
    \ = 0;\n        nesting = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps1kr2wyp.d(14): Error: no property `split` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps1kr2wyp.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    return paren_string.split(\"\
    \ \").map!((s) => paren_depth(s)).array;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpy8t_mk9p.d(14): Error: no property `split` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy8t_mk9p.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] ret\
    \ = new long[];\n    int max_count = 0;\n    int count = 0;\n    for (int i =\
    \ 0; i < paren_string.length; i++) \n    {\n        auto c = paren_string[i];\n\
    \        if (c == '(') \n        {\n            count++;\n            if (max_count\
    \ < count) \n            {\n                max_count = count;\n            }\n\
    \        }\n        else if (c == ')') \n        {\n            count--;\n   \
    \     }\n        else if (c == ' ') \n        {\n            ret ~= max_count;\n\
    \            max_count = 0;\n            count = 0;\n        }\n    }\n    return\
    \ ret;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwnvdy1b0.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpwnvdy1b0.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    import std.algorithm\
    \ : filter, map;\n    auto nested_groups = paren_string.split.filter!(a => a.length).map!(a\
    \ => [a[0], a[$-1]]);\n    auto result = nested_groups.map!(a => a[0] == '(' ?\
    \ a[1] == ')' ? 1 : paren_helper(a[$-1])+1 : 0).array;\n    return result;\n}\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpd8p35sor.d(15): Error: no property `split` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd8p35sor.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tsize_t[] open_paren_pos\
    \ = ();\n\tsize_t[] close_paren_pos = ();\n\tsize_t[] paren_counts = [];\n\tconst\
    \ size_t len = paren_string.length;\n\tsize_t i = 0;\n\twhile (i < len)\n\t{\n\
    \t\tif (paren_string[i] == '(')\n\t\t{\n\t\t\topen_paren_pos ~= i;\n\t\t}\n\t\t\
    else if (paren_string[i] == ')')\n\t\t{\n\t\t\tif (open_paren_pos.length > 0)\n\
    \t\t\t{\n\t\t\t\tconst size_t start = open_paren_pos[$-1];\n\t\t\t\topen_paren_pos\
    \ = open_paren_pos[0..$-1];\n\t\t\t\tclose_paren_pos ~= i;\n\t\t\t\tsize_t cnt\
    \ = 0;\n\t\t\t\tfor (size_t j = start + 1; j < i; j++)\n\t\t\t\t{\n\t\t\t\t\t\
    if (paren_string[j] == '(')\n\t\t\t\t\t{\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\
    \t\t}\n\t\t\t\tparen_counts ~= cnt;\n\t\t\t}\n\t\t}\n\t\telse if (paren_string[i]\
    \ == ' ')\n\t\t{\n\t\t\tif (open_paren_pos.length == 0)\n\t\t\t{\n\t\t\t\tparen_counts\
    \ ~= 0;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\treturn paren_counts;\n}\n/*\n Given\
    \ an array of integer, find out the length of the longest consecutive elements\
    \ sequence.\n \n >>> find_longest_consecutive_sequence([100, 4, 200, 1, 3, 2])\n\
    \ 4\n*/\nlong find_longest_consecutive_sequence(long[] nums)\n{\n\tsort(nums);\n\
    \tconst size_t size = nums.length;\n\tlong max_length = 1;\n\tlong current_length\
    \ =\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfoke1ph0.d(14): Error: expression expected, not `)`\\n/tmp/tmpfoke1ph0.d(14):\
    \ Error: found `;` when expecting `)`\\n/tmp/tmpfoke1ph0.d(15): Error: semicolon\
    \ expected, not `size_t`\\n/tmp/tmpfoke1ph0.d(15): Error: expression expected,\
    \ not `)`\\n/tmp/tmpfoke1ph0.d(15): Error: found `;` when expecting `)`\\n/tmp/tmpfoke1ph0.d(16):\
    \ Error: semicolon expected, not `size_t`\\n/tmp/tmpfoke1ph0.d(66): Error: expression\
    \ expected, not `unittest`\\n/tmp/tmpfoke1ph0.d(67): Error: semicolon expected,\
    \ not `{`\\n/tmp/tmpfoke1ph0.d(74): Error: found `End of File` when expecting\
    \ `}` following compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\",\
    \ \"-o-\", \"/tmp/tmpfoke1ph0.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    ulong[] stack;\n\
    \    long[] accum;\n    foreach (i, p; paren_string.splitter)\n    {\n       \
    \ stack = new ulong[];\n        foreach (c; p)\n        {\n            if (c ==\
    \ '(')\n                stack ~= 0;\n            else if (c == ')')\n        \
    \    {\n                stack.pop;\n                if (stack.length > 0)\n  \
    \                  stack[$-1]++;\n            }\n        }\n        accum ~= max(stack);\n\
    \    }\n    return accum;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp63ft9ztc.d(16): Error: no property `splitter` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp63ft9ztc.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
