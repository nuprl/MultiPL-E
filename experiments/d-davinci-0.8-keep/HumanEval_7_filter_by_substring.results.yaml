name: HumanEval_7_filter_by_substring
language: d
results:
- program: "import std.typecons;\nimport std.math;\n/*\n Filter an input list of strings\
    \ only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'bacd', 'array']\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] res = [];\n    foreach(string string;\
    \ strings)\n    {\n        if(std.algorithm.find(string, substring) != -1)\n \
    \       {\n            res ~= string;\n        }\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprpsr0rue.d(16): Error: undefined identifier `algorithm` in package\
    \ `std`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprpsr0rue.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Filter an input list of strings\
    \ only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'bacd', 'array']\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    auto result = filter!(s => s.canFind(substring))(strings);\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = filter_by_substring;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkrfpjym9.d(13): Error: template instance `filter!((s) => s.canFind(substring))`\
    \ template `filter` is not defined\\nFailed: [\"dmd\", \"-unittest\", \"-v\",\
    \ \"-o-\", \"/tmp/tmpkrfpjym9.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Filter an input list of strings\
    \ only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'bacd', 'array']\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] result;\n    foreach(string s;\
    \ strings)\n    {\n        if (s.canFind(substring))\n        {\n            result\
    \ ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = filter_by_substring;\n\n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\",\
    \ \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"\
    ], \"run\") == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptewzrlav.d(16): Error: no property `canFind` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptewzrlav.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Filter an input list of strings\
    \ only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'bacd', 'array']\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(str => str.canFind(substring));\n\
    }\n/*\n Check if two int arrays are equal\n    >>> int_arrays_equal([], [])\n\
    \    true\n    >>> int_arrays_equal([1, 2, 3], [1, 2, 3])\n    true\n    >>> int_arrays_equal([1,\
    \ 2, 3], [1, 2, 4])\n    false\n    \n*/\nunittest\n{\n    alias candidate = filter_by_substring;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmxrta2jy.d(13): Error: no property `filter` for type `string[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmxrta2jy.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Filter an input list of strings\
    \ only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'bacd', 'array']\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n\treturn strings.filter!(x => x.find(substring)\
    \ != -1)();\n}\n/*\n Replace all occurences of substring with another substring\
    \ in a given string.\n    >>> replace_substring('abc', 'a', 'A')\n    'Abc'\n\
    \    >>> replace_substring('abcabcabc', 'abc', 'abcabc')\n    'abcabcabcabcabc'\n\
    */\nstring replace_substring(string str, string substring, string replacement)\
    \ \n{\n\tstring ret;\n\twhile (true) {\n\t\tint index = str.find(substring);\n\
    \t\tif (index == -1)\n\t\t\tbreak;\n\t\tret ~= str[0..index] ~ replacement;\n\t\
    \tstr = str[index + replacement.length..$];\n\t}\n\tret ~= str;\n\treturn ret;\n\
    }\n/*\n Sort strings in alphabetical order.\n    >>> sort_by_substring(['A', 'a',\
    \ 'X', 'c', 'B', 'y'])\n    ['A', 'B', 'X', 'a', 'c', 'y']\n    >>> sort_by_substring(['BB',\
    \ 'Abba', 'aba', 'ABBA', 'AB', 'aa'])\n    ['AB', 'ABBA', 'Abba', 'BB', 'aba',\
    \ 'aa']\n*/\nstring[] sort_by_substring(string[] strings) \n{\n\treturn strings.sort!(x\
    \ => x.toLower)();\n}\n/*\n Find all unique strings in a list and return as an\
    \ associative array that maps each string to a list of positions in the input\
    \ array.\n \n    >>> find_unique_strings(['A', 'a', 'X', 'c', 'B', 'y'])\n   \
    \ ['A': [0], 'X': [2], 'B': [4], 'a': [1], 'c': [3], 'y': [5]]\n*/\nstring[int][]\
    \ find_unique_strings(string[] strings) \n{\n\tint[string] list;\n\tforeach (int\
    \ i, string s; strings)\n\t\tlist[s] ~= i;\n\treturn list;\nunittest\n{\n    alias\
    \ candidate = filter_by_substring;\n\n    assert(candidate([], \"john\") == []);\n\
    \    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"\
    xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_bvqxdbl.d(58): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_bvqxdbl.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Filter an input list of strings\
    \ only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'bacd', 'array']\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] result;\n    foreach(string s;\
    \ strings)\n    {\n        if (s.contains(substring))\n        {\n           \
    \ result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = filter_by_substring;\n\n    assert(candidate([], \"john\") == []);\n\
    \    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"\
    xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpk9d6ax81.d(16): Error: no property `contains` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk9d6ax81.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Filter an input list of strings\
    \ only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'bacd', 'array']\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return filter!(a => a.contains(substring))(strings);\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp787v3v10.d(13): Error: template instance `filter!((a) => a.contains(substring))`\
    \ template `filter` is not defined\\nFailed: [\"dmd\", \"-unittest\", \"-v\",\
    \ \"-o-\", \"/tmp/tmp787v3v10.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Filter an input list of strings\
    \ only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'bacd', 'array']\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    int[] indices = strings.indexOf(substring);\n\
    \    string[] results = new string[indices.length];\n    foreach(i, result; results)\n\
    \    {\n        result = strings[indices[i]];\n    }\n    return results;\n}\n\
    /*\n Flatten a list of list of strings\n    >>> flatten_list_of_list_of_strings([['a',\
    \ 'b'], ['c', 'd']])\n    ['a', 'b', 'c', 'd']\n    >>> flatten_list_of_list_of_strings([[]])\n\
    \    []\n*/\nstring[] flatten_list_of_list_of_strings(string[][] lists) \n{\n\
    \    string[] result = new string[];\n    foreach(list; lists)\n    {\n      \
    \  result ~= list;\n    }\n    return result;\n}\n/*\n Compute a list of unique\
    \ colors, given a list of lists of colors\n    >>> unique_colors([['white', 'red'],\
    \ ['red', 'black']])\n    ['white', 'red', 'black']\n    >>> unique_colors([['red',\
    \ 'red'], ['blue', 'red']])\n    ['red', 'blue']\n*/\nstring[] unique_colors(string[][]\
    \ colors) \n{\n    string[] result = new string[];\n    foreach(list; colors)\n\
    \    {\n        result ~= list;\n    }\n    return result.uniq;\n}\n/*\n Take\
    \ a list of colors and a list of weights and return a list\n of colors that is\
    \ weighted by weights (e.g. twice as many reds as blues)\n    >>> weighted_choice(['red',\
    \ 'blue'], [1, 1])\n    ['red', 'blue']\n    >>> weighted_choice(['red', 'blue'],\
    \ [2, 1])\n    ['red', 'red', 'blue']\n*/\nstring[] weighted_choice(string[] colors,\
    \ int[] weights) \n{\n    string[] result = new string[];\n    foreach(pair; zip(colors,\
    \ weights))\n    {\n        result ~= new string[pair[1]](pair[0\nunittest\n{\n\
    \    alias candidate = filter_by_substring;\n\n    assert(candidate([], \"john\"\
    ) == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\"\
    , \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6ko5537c.d(67): Error: found `unittest` when expecting `,`\\\
    n/tmp/tmp6ko5537c.d(76): Error: found `void` when expecting `,`\\n/tmp/tmp6ko5537c.d(76):\
    \ Error: found `{` when expecting `,`\\n/tmp/tmp6ko5537c.d(76): Error: expression\
    \ expected, not `}`\\n/tmp/tmp6ko5537c.d(76): Error: found `End of File` when\
    \ expecting `,`\\n/tmp/tmp6ko5537c.d(76): Error: found `End of File` when expecting\
    \ `]`\\n/tmp/tmp6ko5537c.d(76): Error: found `End of File` when expecting `,`\\\
    n/tmp/tmp6ko5537c.d(76): Error: found `End of File` when expecting `)`\\n/tmp/tmp6ko5537c.d(76):\
    \ Error: found `End of File` when expecting `;` following statement\\n/tmp/tmp6ko5537c.d(76):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    n/tmp/tmp6ko5537c.d(76): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6ko5537c.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Filter an input list of strings\
    \ only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'bacd', 'array']\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(a => a.contains(substring));\n\
    }\n/*\n Check if a string starts with given substring\n    >>> starts_with('abcdefg',\
    \ 'ab')\n    true\n    >>> starts_with('abcdefg', 'abc')\n    true\n    >>> starts_with('abcdefg',\
    \ 'abcdef')\n    true\n    >>> starts_with('abcdefg', 'abcdefg')\n    true\n \
    \   >>> starts_with('abcdefg', 'bcdefg')\n    false\n    >>> starts_with('abcdefg',\
    \ 'cdefg')\n    false\n*/\nunittest\n{\n    alias candidate = filter_by_substring;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpiewn5y2m.d(13): Error: no property `filter` for type `string[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiewn5y2m.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Filter an input list of strings\
    \ only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'bacd', 'array']\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n    if(strings.length == 0)\n        return [];\n\
    \    foreach(string item; strings)\n        if(item.canFind(substring))\n    \
    \        yield item;\n/*\n Check if two lists have common elements\n   >>> check_common_elements([1,\
    \ 2, 3], [2, 3, 4])\n   True\n   >>> check_common_elements([1, 2, 3], [4, 5, 6])\n\
    \   False\n*/\nunittest\n{\n    alias candidate = filter_by_substring;\n\n   \
    \ assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\"\
    , \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqqp3ovap.d(12): Error: cannot use function constraints for non-template\
    \ functions. Use `static if` instead\\n/tmp/tmpqqp3ovap.d(12): Error: declaration\
    \ expected, not `if`\\n/tmp/tmpqqp3ovap.d(14): Error: declaration expected, not\
    \ `foreach`\\n/tmp/tmpqqp3ovap.d(14): Error: no identifier for declarator `strings`\\\
    n/tmp/tmpqqp3ovap.d(14): Error: declaration expected, not `)`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqqp3ovap.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Filter an input list of strings\
    \ only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'bacd', 'array']\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] filtered_strings;\n    foreach(string\
    \ s; strings) \n    {\n        if (s.find(substring) != -1) \n        {\n    \
    \        filtered_strings ~= s;\n        }\n    }\n    return filtered_strings;\n\
    }\n \n/*\nConvert a list of strings to a list of ints\n    >>> strings_to_ints(['1',\
    \ '2', '3'])\n    [1, 2, 3]\n    >>> strings_to_ints(['1', '2', '3', 'four'])\n\
    \    [1, 2, 3]\n*/\nunittest\n{\n    alias candidate = filter_by_substring;\n\n\
    \    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc7t0rdgr.d(16): Error: no property `find` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc7t0rdgr.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Filter an input list of strings\
    \ only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'bacd', 'array']\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    auto result = new string[];\n    foreach(s;\
    \ strings)\n    {\n        if(s.canFind(substring))\n        {\n            result\
    \ ~= s;\n        }\n    }\n    return result;\n}\n//\n//function to find the maximum\
    \ of a list of numbers\nunittest\n{\n    alias candidate = filter_by_substring;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpd8ihnzd3.d(13): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `string[]`\\'s\\n/tmp/tmpd8ihnzd3.d(16): Error: no property\
    \ `canFind` for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpd8ihnzd3.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Filter an input list of strings\
    \ only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'bacd', 'array']\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(x => x.contains(substring));\n\
    }\n/*\n  Filter an input list of strings only for ones that contain given substring\
    \ ignoring case\n    >>> filter_by_substring_ignore_case([], 'a')\n    []\n  \
    \  >>> filter_by_substring_ignore_case(['abc', 'bacd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'bacd', 'array']\n    >>> filter_by_substring_ignore_case(['Abc',\
    \ 'bAcD', 'cde', 'array'], 'a')\n    ['Abc', 'bAcD', 'array']\n*/\nstring[] filter_by_substring_ignore_case(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(x => x.contains(substring));\n\
    }\n/*\n  Filter an input list of strings only for ones that are equal to given\
    \ string\n    >>> filter_by_string([], 'a')\n    []\n    >>> filter_by_string(['abc',\
    \ 'bacd', 'cde', 'array'], 'a')\n    []\n    >>> filter_by_string(['abc', 'bacd',\
    \ 'cde', 'array'], 'array')\n    ['array']\n*/\nstring[] filter_by_string(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(x => x == substring);\n\
    }\n/*\n  Filter an input list of strings only for ones that are equal to given\
    \ string ignoring case\n    >>> filter_by_string_ignore_case([], 'a')\n    []\n\
    \    >>> filter_by_string_ignore_case(['abc', 'bacd', 'cde', 'array'], 'a')\n\
    \    []\n    >>> filter_by_string_ignore_case(['abc', 'bacd', 'cde', 'array'],\
    \ 'array')\n    ['array']\n    >>> filter_by_string_ignore_case(['abc', 'bacd',\
    \ 'cde', 'array'], 'Array')\n    ['array']\n*/\nstring[] filter_by_string_ignore_case(string[]\
    \ strings, string\nunittest\n{\n    alias candidate = filter_by_substring;\n\n\
    \    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpl0raegma.d(53): Error: found `unittest` when expecting `)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl0raegma.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Filter an input list of strings\
    \ only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'bacd', 'array']\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return filter!(a => (a.length > 0 && substring\
    \ in a))(strings);\n}\nunittest\n{\n    alias candidate = filter_by_substring;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyjlfho86.d(13): Error: template instance `filter!((a) => a.length\
    \ > 0 && (substring in a))` template `filter` is not defined\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyjlfho86.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Filter an input list of strings\
    \ only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'bacd', 'array']\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n  import std.algorithm : filter;\n  return strings.filter!(s\
    \ => s.canFind(substring));\n}\n/*\n Filter an input list of strings only for\
    \ ones that contain given string or substring\n    >>> filter_by_substring_or_string([],\
    \ 'a')\n    []\n    >>> filter_by_substring_or_string(['abc', 'bacd', 'cde', 'array'],\
    \ 'a')\n    ['abc', 'bacd', 'array']\n    >>> filter_by_substring_or_string(['abc',\
    \ 'bacd', 'cde', 'array'], 'bacd')\n    ['abc', 'bacd', 'cde', 'array']\n*/\n\
    string[] filter_by_substring_or_string(string[] strings, string x) \n{\n  import\
    \ std.algorithm : filter;\n  return strings.filter!(s => s.canFind(x) || s ==\
    \ x);\n}\n/*\n Filter an input list of strings only for ones that start with given\
    \ substring\n    >>> filter_by_substring_start([], 'a')\n    []\n    >>> filter_by_substring_start(['abc',\
    \ 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n*/\nstring[] filter_by_substring_start(string[]\
    \ strings, string substring) \n{\n  import std.algorithm : filter;\n  return strings.filter!(s\
    \ => s.startsWith(substring));\n}\n/*\n Filter an input list of strings only for\
    \ ones that end with given substring\n    >>> filter_by_substring_end([], 'a')\n\
    \    []\n    >>> filter_by_substring_end(['abc', 'bacd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'bacd']\n*/\nstring[] filter_by_substring_end(string[] strings, string\
    \ substring) \n{\n  import std.algorithm : filter;\n  return strings.filter!(s\
    \ => s.endsWith(substring));\n}\n/*\n Filter an input list of strings only for\
    \ ones that contain a given prefix\nunittest\n{\n    alias candidate = filter_by_substring;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvv2pyogb.d(54): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvv2pyogb.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Filter an input list of strings\
    \ only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'bacd', 'array']\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.filter!(string a => a.contains(substring));\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppjg_mntl.d(13): Error: found `a` when expecting `)` following\
    \ template argument list\\n/tmp/tmppjg_mntl.d(13): Error: found `=>` when expecting\
    \ `;` following `return` statement\\n/tmp/tmppjg_mntl.d(13): Error: found `)`\
    \ when expecting `;` following statement\\n/tmp/tmppjg_mntl.d(13): Deprecation:\
    \ use `{ }` for an empty statement, not `;`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmppjg_mntl.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Filter an input list of strings\
    \ only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'bacd', 'array']\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \nin\n{\n    assert(strings.length > 0);\n    assert(substring.length\
    \ > 0);\n}\ndo\n{\n    return strings.filter!(s => s.canFind(substring));\n}\n\
    /*\n Compute an index-wise mapping from the input list of strings to\n the given\
    \ substring.\n    >>> map_string_to_substring([], 'a')\n    []\n    >>> map_string_to_substring(['abc',\
    \ 'bacd', 'cde', 'array'], 'a')\n    [0, 1, -1, 0]\n    \n*/\nunittest\n{\n  \
    \  alias candidate = filter_by_substring;\n\n    assert(candidate([], \"john\"\
    ) == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\"\
    , \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8j5pg5x4.d(19): Error: no property `filter` for type `string[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8j5pg5x4.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Filter an input list of strings\
    \ only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'bacd', 'array']\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return filter!(s => s.canFind(substring))(strings);\n\
    }\n/*\n    >>> filter_by_length([], 1)\n    []\n    >>> filter_by_length(['abc',\
    \ 'bacd', 'cde', 'array'], 3)\n    ['abc', 'cde', 'array']\n*/\nstring[] filter_by_length(string[]\
    \ strings, size_t length) \n{\n    return filter!(s => s.length == length)(strings);\n\
    }\n/*\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc',\
    \ 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n*/\nstring[] filter_by_prefix(string[]\
    \ strings, string prefix) \n{\n    return filter!(s => s.startsWith(prefix))(strings);\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpundso0b7.d(13): Error: template instance `filter!((s) => s.canFind(substring))`\
    \ template `filter` is not defined\\n/tmp/tmpundso0b7.d(23): Error: template instance\
    \ `filter!((s) => s.length == length)` template `filter` is not defined\\n/tmp/tmpundso0b7.d(33):\
    \ Error: template instance `filter!((s) => s.startsWith(prefix))` template `filter`\
    \ is not defined\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpundso0b7.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Filter an input list of strings\
    \ only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'bacd', 'array']\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] filtered_strings;\n    foreach(str;\
    \ strings) \n    {\n        if(str.contains(substring)) \n        {\n        \
    \    filtered_strings ~= str;\n        }\n    }\n    return filtered_strings;\n\
    }\nunittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
    \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
    xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"\
    xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"\
    trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppnh27xn1.d(16): Error: no property `contains` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppnh27xn1.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Filter an input list of strings\
    \ only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n\
    \    ['abc', 'bacd', 'array']\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    auto result = filter!(s => s.canFind(substring))(strings);\n\
    \    return result;\n}\n/*\nCount words in a list of strings.\n    >>> count_words([])\n\
    \    0\n    >>> count_words(['abc', 'abc abc', 'abc abc abc'])\n    6\n*/\nsize_t\
    \ count_words(string[] strings) \n{\n    auto result = strings.reduce!((a, b)\
    \ => a + b.count(' ') + 1)(0);\n    return result;\n}\n/*\nFilter a list of integers\
    \ to only even ones\n    >>> filter_even([])\n    []\n    >>> filter_even([1,\
    \ 2, 3, 4, 5, 6])\n    [2, 4, 6]\n*/\nsize_t[] filter_even(size_t[] numbers) \n\
    {\n    auto result = filter!(a => a.even)(numbers);\n    return result;\n}\n/*\n\
    Count length of each string in a list.\n    >>> count_lengths([])\n    []\n  \
    \  >>> count_lengths(['abc', 'abcd', 'abcde'])\n    [3, 4, 5]\n*/\nsize_t[] count_lengths(string[]\
    \ strings) \n{\n    auto result = map!(s => s.length)(strings);\n    return result;\n\
    }\n/*\nCount appearances of each character in a string\n    >>> count_chars('')\n\
    \    []\n    >>> count_chars('abcaab')\n    [('a', 3), ('b', 2), ('c', 1)]\n*/\n\
    alias Count = tuple!(char, size_t);\nCount[] count_chars(string s) \n{\n    /*\n\
    \    auto result = s.sort().group.map!(g => tuple(g[0][0], g.length));\n    return\
    \ result;\n    */\n    return [];\n}\n/*\nFilter list of ints by range\n    >>>\
    \ filter_range([], (1, 2))\n    []\n    >>> filter_range([1, 2, 3, 4, 5, 6], (3,\
    \ 5))\n    [3, 4, 5]\n*/\nsize\nunittest\n{\n    alias candidate = filter_by_substring;\n\
    \n    assert(candidate([], \"john\") == []);\n    assert(candidate([\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"]);\n    assert(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\"\
    , \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n\
    \    assert(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
    ) == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphjtzbn5o.d(76): Error: no identifier for declarator `size`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphjtzbn5o.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
