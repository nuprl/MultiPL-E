name: HumanEval_47_median
language: d
prompt: "import std.math;\n/*\nReturn median of elements in the list l.\n    >>> median([3,\
  \ 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n   \
  \ \n*/\nfloat median(long[] l) \n"
tests: "unittest\n{\n    alias candidate = median;\n\n    assert(candidate([3L, 1L,\
  \ 2L, 4L, 5L]) == 3L);\n    assert(candidate([-10L, 4L, 6L, 1000L, 10L, 20L]) ==\
  \ 8.0);\n    assert(candidate([5L]) == 5L);\n    assert(candidate([6L, 5L]) == 5.5);\n\
  \    assert(candidate([8L, 1L, 3L, 9L, 9L, 2L, 7L]) == 7L);\n}\nvoid main(){}"
completions: ["{\n    sort(l);\n    long idx = (l.length / 2);\n    if (l.length %\
    \ 2 == 0)\n    {\n        return float(l[idx] + l[idx - 1]) / 2;\n    }\n    else\n\
    \    {\n        return l[idx];\n    }\n}", "{\n    long[] sl = l.sort();\n   \
    \ long n = sl.length;\n    if (n % 2 == 1) {\n        return sl[n / 2];\n    }\
    \ else {\n        long a = sl[n / 2 - 1];\n        long b = sl[n / 2];\n     \
    \   return (a + b) / 2.0;\n    }\n}", "    pure nothrow\n{\n    immutable length\
    \ = l.length;\n    if (length == 0) return 0;\n    immutable half = length / 2;\n\
    \    if (length % 2) \n    {\n        sort(l);\n        return l[half];\n    }\n\
    \    sort(l);\n    return (l[half - 1] + l[half]) / 2;\n}", "{\n    sort(l);\n\
    \    const long len = l.length;\n    if (len % 2 == 0) \n    {\n        return\
    \ (l[len / 2] + l[len / 2 - 1]) / 2.0;\n    } \n    else \n    {\n        return\
    \ l[len / 2];\n    }\n}", "{\n    float ret;\n    l.sort();\n    if (l.length\
    \ & 1) {\n        ret = l[l.length / 2];\n    } else {\n        ret = (l[l.length\
    \ / 2] + l[l.length / 2 - 1]) / 2.0;\n    }\n    return ret;\n}", "{\n    bool\
    \ isEven = l.length % 2 == 0;\n    long sorted = max(l);\n    if (isEven)\n  \
    \  {\n        long a = l[l.length / 2];\n        long b = l[l.length / 2 - 1];\n\
    \        return (a + b) / 2;\n    }\n    else\n    {\n        long a = l[l.length\
    \ / 2];\n        return a;\n    }\n}", "{\n    long[] sl = [];\n    long n = l.length;\n\
    \    long i = 0;\n    for (i = 0; i < n; i++) \n    {\n        sl.push(l[i]);\n\
    \    }\n    sort(sl);\n    long m = sl.length;\n    if (m == 0) \n    {\n    \
    \    return null;\n    }\n    else if (m % 2 == 0) \n    {\n        return (sl[m\
    \ / 2 - 1] + sl[m / 2]) / 2.0;\n    }\n    else \n    {\n        return sl[m /\
    \ 2];\n    }\n}", "{ \n    long[] sortedl = l[0..$]; \n    sortedl.sort(); \n\
    \    int mid = sortedl.length / 2; \n    if (l.length % 2 == 0) \n        return\
    \ (float)(sortedl[mid - 1] + sortedl[mid]) / 2; \n    else \n        return sortedl[mid];\
    \ \n}", "{\n    assert(l.length > 0);\n    float[] sorted = new float[l.length];\n\
    \    foreach (i,v; l) {\n        sorted[i] = v;\n    }\n    std.algorithm.sort(sorted);\n\
    \    return sorted[l.length / 2];\n}", "{ \n    float median = 0;\n    long[]\
    \ l2 = l.dup;", "{\n\tlong i, j;\n\tlong n = l.length;\n\tlong[] tmp = new long[n];\n\
    \tfor (i = 0; i < n; i++)\n\t{\n\t\ttmp[i] = l[i];\n\t}\n\tj = 0;\n\t\n\tfor (i\
    \ = 0; i < n - 1; i++)\n\t{\n\t\tif (tmp[i] > tmp[i + 1])\n\t\t{\n\t\t\tj = 1;\n\
    \t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif (j == 1)\n\t{\n\t\tfor (i = 0; i < n - 1; i++)\n\
    \t\t{\n\t\t\tfor (j = 0; j < n - i - 1; j++)\n\t\t\t{\n\t\t\t\tif (tmp[j] > tmp[j\
    \ + 1])\n\t\t\t\t{\n\t\t\t\t\tint temp = tmp[j];\n\t\t\t\t\ttmp[j] = tmp[j + 1];\n\
    \t\t\t\t\ttmp[j + 1] = temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (n % 2\
    \ == 0)\n\t{\n\t\treturn (tmp[n / 2] + tmp[n / 2 - 1]) / 2.0;\n\t}\n\telse\n\t\
    {\n\t\treturn tmp[n / 2];\n\t}\n}", "{\n    l.sort();\n    if (l.length % 2 ==\
    \ 0)\n        return (l[l.length / 2 - 1] + l[l.length / 2]) / 2.0;\n    else\n\
    \        return l[l.length / 2];\n}", "{ \n    l.sort();\n    long n = l.length;\n\
    \    float med = 0;\n    if (n % 2 == 0)\n        med = (l[n/2] + l[n/2 - 1])\
    \ / 2.0;\n    else\n        med = l[n/2];\n    return med;\n}\n/*\nReturn the\
    \ probability of getting the sample mean samp_mean from a population\nof size\
    \ pop_size whose mean is pop_mean and standard deviation is sd.\n    >>> population_probability(5,\
    \ 15, 2, 8)\n    0.0668072012688581\n*/", "{\n    int[] s = l.sort(std.int.cmp);\n\
    \    int mid = l.length / 2;\n    if (l.length % 2 == 0)\n    {\n        return\
    \ (s[mid] + s[mid-1]) / 2.0;\n    }\n    else\n    {\n        return s[mid];\n\
    \    }\n}", "{\n    float result;\n    int len = l.length;\n    if(len % 2 ==\
    \ 0)\n    {\n        result = (l[len/2] + l[len/2-1])/2.0;\n    }\n    else\n\
    \    {\n        result = l[len/2];\n    }\n    return result;\n}", "{\n\treturn\
    \ median(cast(float[])l);\n}\nfloat median(float[] l) \n{\n\tint size = l.length;\n\
    \tstd.sort(l);\n\tif(size%2)\n\t\treturn l[size/2];\n\telse\n\t\treturn (l[size/2-1]+l[size/2])/2;\n\
    }", "{\n    size_t length = l.length;\n    if(length == 0) \n    {\n        throw\
    \ new Exception(\"Median of empty list\");\n    }\n    long[] sorted = l[0..length];\n\
    \    std.algorithm.sort(sorted);\n    size_t midpoint = length / 2;\n    if(length\
    \ % 2 == 1) \n    {\n        return sorted[midpoint];\n    }\n    else \n    {\n\
    \        return (sorted[midpoint - 1] + sorted[midpoint]) / 2.0;\n    }\n}\n/*\n\
    Return a list of the frequencies of each character in string s.\nCharacters are\
    \ ordered based on frequency, from most common to least.\nIf two characters have\
    \ the same frequency, order them based on their\nnatural sort order:\n    >>>\
    \ frequencies(\"mississippi\")\n    [('i', 4), ('s', 4), ('p', 2), ('m', 1)]\n\
    \    \n*/\nTuple!(char, ulong)[] frequencies(string s) \n{\n    size_t length\
    \ = s.length;\n    if(length == 0) \n    {\n        return [];\n    }\n    size_t[]\
    \ count = new size_t[256];\n    foreach(c; s) \n    {\n        count[c]++;\n \
    \   }\n    Tuple!(char, ulong)[] freq = new Tuple!(char, ulong)[0];\n    foreach(c;\
    \ s) \n    {\n        if(count[c] > 0) \n        {\n            freq ~= tuple(c,\
    \ count[c]);\n            count[c] = 0;\n        }\n    }\n    std.algorithm.sort!((x,\
    \ y) => x[1] > y[1] || (x[1] == y[1] && x[0] > y[0]))(freq);\n    return freq;\n\
    }\n/*\nReturn the mode of the list l.  (The mode is the most common\nelement.)\n\
    \    >>> mode([0, 1, 1, 2, 2, 2, 3])\n    2\n    \n*/\nlong mode(long[] l) \n\
    {\n    long mode", "in {\n\tforeach(long i in l) {\n\t\tassert(i >= -1000);\n\t\
    \tassert(i <= 1000);\n\t}\n}\nout(result) {\n\tassert(result >= -1000);\n\tassert(result\
    \ <= 1000);\n}\n{\n\tassert(l.length > 0);\n\t\n\tlong n = l.length;\n\tlong i;\n\
    \tlong m = n/2;\n\tl = sort(l);\n\tif (n%2 == 0)\n\t\treturn (float)(l[m-1] +\
    \ l[m])/2;\n\telse\n\t\treturn (float)l[m];\n}", "{\n    auto l2 = l.dup;\n  \
    \  l2.sort;\n    if (l2.length % 2 == 0)\n    {\n        return (l2[l2.length\
    \ / 2 - 1] + l2[l2.length / 2]) / 2.0;\n    }\n    else\n    {\n        return\
    \ l2[l2.length / 2];\n    }\n}", "{\n    int n = l.length;\n    long[] s = new\
    \ long[n];\n    foreach (i, j; l)\n    {\n        s[i] = j;\n    }\n    sort(s);\n\
    \    if (n%2 == 0)\n    {\n        return (s[n/2] + s[n/2-1])/2;\n    }\n    else\n\
    \    {\n        return s[n/2];\n    }\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
