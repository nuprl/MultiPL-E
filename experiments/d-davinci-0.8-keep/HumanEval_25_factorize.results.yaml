name: HumanEval_25_factorize
language: d
results:
- program: "import std.typecons;\nimport std.math;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>>\
    \ factorize(70)\n    [2, 5, 7]\n    \n*/\nlong[] factorize(long n) \n{\n\tlong[]\
    \ res = new long[];\n\tulong nU = cast(ulong)n;\n\tif(nU == 1)\n\t\treturn res;\n\
    \tulong p = 2;\n\twhile(nU != 1)\n\t{\n\t\twhile(nU % p == 0)\n\t\t{\n\t\t\tres\
    \ ~= cast(long)p;\n\t\t\tnU /= p;\n\t\t}\n\t\tp++;\n\t}\n\treturn res;\n}\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7xphorfx.d(17): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp7xphorfx.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>>\
    \ factorize(70)\n    [2, 5, 7]\n    \n*/\nlong[] factorize(long n) \n{\n    long[]\
    \ result = [];\n    for (long i = 2; i <= n; i++) \n    {\n        while (n %\
    \ i == 0) \n        {\n            result ~= i;\n            n /= i;\n       \
    \ }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>>\
    \ factorize(70)\n    [2, 5, 7]\n    \n*/\nlong[] factorize(long n) \n{\n    long[]\
    \ factors;\n    for (; n > 1; n /= 2)\n    {\n        if (n%2 != 0)\n        {\n\
    \            for (int i = 3; i <= sqrt(n); i+=2)\n            {\n            \
    \    if (n%i != 0)\n                {\n                    //factors ~= i;\n \
    \                   factors ~= n;\n                    break;\n              \
    \  }\n            }\n        }\n        else\n        {\n            factors ~=\
    \ 2;\n        }\n    }\n    return factors;\n}\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvrtdfhza.d(22): Error: `std.math.sqrt` called with argument types\
    \ `(long)` matches both:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(1848):\
    \     `std.math.sqrt(float x)`\\nand:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(1854):\
    \     `std.math.sqrt(real x)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpvrtdfhza.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>>\
    \ factorize(70)\n    [2, 5, 7]\n    \n*/\nlong[] factorize(long n) \n{\n\tlong[]\
    \ list;\n\tlong i;\n\tfor(i = 2; i < n; i++)\n\t{\n\t\tif(n % i == 0)\n\t\t{\n\
    \t\t\tlist ~= i;\n\t\t\tn /= i;\n\t\t\t--i;\n\t\t}\n\t}\n\tlist ~= n;\n\treturn\
    \ list;\n}\n/*\nCheck if given integer is a prime number. Return boolean value.\n\
    \    >>> is_prime(8)\n    False\n    >>> is_prime(25)\n    False\n    >>> is_prime(7)\n\
    \    True\n    >>> is_prime(30)\n    False\n*/\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>>\
    \ factorize(70)\n    [2, 5, 7]\n    \n*/\nlong[] factorize(long n) \n{\n    long[]\
    \ res = new long[];\n    for (long i = 2; i <= n; ++i) \n    {\n        uint cnt\
    \ = 0;\n        while ((n % i) == 0) \n        {\n            n /= i;\n      \
    \      ++cnt;\n        }\n        if (cnt > 0) \n        {\n            res ~=\
    \ [i, cnt];\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjnf3dh4k.d(17): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpjnf3dh4k.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>>\
    \ factorize(70)\n    [2, 5, 7]\n    \n*/\nlong[] factorize(long n) \n{\n    long[]\
    \ res = new long[];\n    long i = 2;\n    while (i <= n / i) \n    {\n       \
    \ while (n % i == 0) \n        {\n            res ~= i;\n            n /= i;\n\
    \        }\n        i++;\n    }\n    if (n > 1) \n    {\n        res ~= n;\n \
    \   }\n    return res;\n}\nunittest\n{\n    alias candidate = factorize;\n\n \
    \   assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n \
    \   assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplo5usuv6.d(17): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmplo5usuv6.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>>\
    \ factorize(70)\n    [2, 5, 7]\n    \n*/\nlong[] factorize(long n) \n{\n    long[]\
    \ factors = [n];\n    size_t j = 0;\n    for (iota(2, n)\n    {\n        for (auto\
    \ i = 0; i < factors.length; i++)\n        {\n            if (factors[i] % j ==\
    \ 0)\n            {\n                auto temp = cast(long)floor(factors[i] /\
    \ j);\n                factors[i] = j;\n                append(factors, temp);\n\
    \            }\n        }\n    }\n    return factors;\n}\nunittest\n{\n    alias\
    \ candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmo05who0.d(20): Error: found `{` when expecting `;` following\
    \ statement\\n/tmp/tmpmo05who0.d(21): Error: expression expected, not `for`\\\
    n/tmp/tmpmo05who0.d(21): Error: expression expected, not `auto`\\n/tmp/tmpmo05who0.d(21):\
    \ Error: found `i` when expecting `,`\\n/tmp/tmpmo05who0.d(21): Error: expression\
    \ expected, not `=`\\n/tmp/tmpmo05who0.d(21): Error: found `0` when expecting\
    \ `,`\\n/tmp/tmpmo05who0.d(21): Error: expression expected, not `;`\\n/tmp/tmpmo05who0.d(21):\
    \ Error: found `i` when expecting `,`\\n/tmp/tmpmo05who0.d(21): Error: expression\
    \ expected, not `<`\\n/tmp/tmpmo05who0.d(21): Error: found `factors` when expecting\
    \ `,`\\n/tmp/tmpmo05who0.d(21): Error: found `;` when expecting `,`\\n/tmp/tmpmo05who0.d(22):\
    \ Error: found `{` when expecting `;` following `for` condition\\n/tmp/tmpmo05who0.d(23):\
    \ Error: expression expected, not `if`\\n/tmp/tmpmo05who0.d(24): Error: found\
    \ `{` when expecting `)`\\n/tmp/tmpmo05who0.d(29): Error: unrecognized declaration\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmo05who0.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>>\
    \ factorize(70)\n    [2, 5, 7]\n    \n*/\nlong[] factorize(long n) \n{\n    long[]\
    \ result = new long[];\n    foreach(i; iota(2, (int)n))\n    {\n        while(n\
    \ % i == 0)\n        {\n            result ~= i;\n            n /= i;\n      \
    \  }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5rjae8x_.d(18): Error: C style cast illegal, use `cast(int)n`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5rjae8x_.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>>\
    \ factorize(70)\n    [2, 5, 7]\n    \n*/\nlong[] factorize(long n) \n{\n  long\
    \ temp = n;\n  long[] fact = new long[n];\n  int i = 0;\n  while(i < n) \n  {\n\
    \    if(temp % 2 == 0) \n    {\n      fact[i] = 2;\n      temp /= 2;\n    }\n\
    \    else \n    {\n      int maxDiv = cast(int) (ceil(sqrt(temp)));\n      for(int\
    \ j = 3; j <= maxDiv; j+=2) \n      {\n        if(temp % j == 0) \n        {\n\
    \          fact[i] = j;\n          temp /= j;\n          break;\n        }\n \
    \     }\n    }\n    i++;\n  }\n  fact = fact.take(i);\n  return fact;\n}\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0jdi_tpm.d(29): Error: `std.math.sqrt` called with argument types\
    \ `(long)` matches both:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(1848):\
    \     `std.math.sqrt(float x)`\\nand:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(1854):\
    \     `std.math.sqrt(real x)`\\n/tmp/tmp0jdi_tpm.d(42): Error: no property `take`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0jdi_tpm.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>>\
    \ factorize(70)\n    [2, 5, 7]\n    \n*/\nlong[] factorize(long n) \n{\n    //\
    \ if (n == 1) return [1];\n    long[] list = [];\n    int i = 2;\n    while (n\
    \ != 1) \n    {\n        if (n % i == 0) \n        {\n            n /= i;\n  \
    \          list ~= i;\n        }\n        else\n        {\n            i++;\n\
    \        }\n    }\n    return list;\n}\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>>\
    \ factorize(70)\n    [2, 5, 7]\n    \n*/\nlong[] factorize(long n) \n{\n    auto\
    \ l = new long[](0);\n    auto res = new long[](0);\n    auto i = 2L;\n    while\
    \ (i * i <= n)\n    {\n        if (n % i == 0)\n        {\n            l ~= i;\n\
    \            n /= i;\n        }\n        else\n        {\n            ++i;\n \
    \       }\n    }\n    l ~= n;\n    foreach (k; l)\n    {\n        if (k == l[$\
    \ - 1])\n        {\n            res ~= k;\n        }\n        else\n        {\n\
    \            res ~= k;\n            res ~= k;\n        }\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) ==\
    \ [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) ==\
    \ [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpx_l5zqgl.d(54): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42873d]\\n??:? void tmpx_l5zqgl.__unittest_L47_C1()\
    \ [0x42821d]\\n??:? void tmpx_l5zqgl.__modtest() [0x4284bc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d207]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42c09a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430be5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x431094]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430b71]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42c071]\\n??:? runModuleUnitTests [0x42cfdd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428c00]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b87]\\n??:? _d_run_main [0x428af2]\\n??:? main [0x4284cf]\\\
    n??:? __libc_start_main [0x1b8ab554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>>\
    \ factorize(70)\n    [2, 5, 7]\n    \n*/\nlong[] factorize(long n) \n{\n    //https://isocpp.org/wiki/faq/templates#separate-template-fn-defn-from-decl\n\
    \    import std.math : sqrt;\n    import std.conv : to;\n    import std.algorithm\
    \ : filter, map, retro;\n    import std.array : array;\n    import std.typecons\
    \ : tuple;\n    import std.range : take;\n    import std.exception : assertThrown;\n\
    \    assert(n>0);\n    auto isPrime = (long d)=>n%d!=0 && (d<=sqrt(n));\n    auto\
    \ divisors = filter!isPrime(iota(2,n));\n    auto factors=[];\n    auto check=(long\
    \ d)=>{\n        if(n%d==0)\n        {\n            factors ~= d;\n          \
    \  return true;\n        }\n        return false;\n    };\n    while(true)\n \
    \   {\n        if(divisors.length==0)\n            break;\n        if(check(divisors[0]))\n\
    \            divisors = filter!check(divisors);\n        else\n            divisors\
    \ = divisors[1..$];\n    }\n    return factors;\n}\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpspa5fpkm.d(20): Error: module `std.algorithm` import `retro`\
    \ not found\\n/tmp/tmpspa5fpkm.d(26): Error: `std.math.sqrt` called with argument\
    \ types `(long)` matches both:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(1848):\
    \     `std.math.sqrt(float x)`\\nand:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(1854):\
    \     `std.math.sqrt(real x)`\\n/tmp/tmpspa5fpkm.d(32): Error: cannot append type\
    \ `long` to type `void[]`\\n/tmp/tmpspa5fpkm.d(46): Error: cannot implicitly convert\
    \ expression `factors` of type `void[]` to `long[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpspa5fpkm.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>>\
    \ factorize(70)\n    [2, 5, 7]\n    \n*/\nlong[] factorize(long n) \n{\n    assert(n>0);\n\
    \    //print(n);\n    long[] result;\n    while (n!=1)\n    {\n        if(isPrime(n))\n\
    \        {\n            //print(n);\n            append(result,n);\n         \
    \   n=1;\n        }\n        else\n        {\n            long divider=2;\n  \
    \          while(n%divider!=0)\n            {\n                divider++;\n  \
    \          }\n            append(result,divider);\n            n=n/divider;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp86o90asp.d(22): Error: undefined identifier `isPrime`\\n/tmp/tmp86o90asp.d(25):\
    \ Error: undefined identifier `append`\\n/tmp/tmp86o90asp.d(35): Error: undefined\
    \ identifier `append`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp86o90asp.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>>\
    \ factorize(70)\n    [2, 5, 7]\n    \n*/\nlong[] factorize(long n) \n{\n    //Base\
    \ cases\n    if (n < 2) \n        return new long[0];\n    if (n == 2) \n    \
    \    return [2];\n    if (n == 3) \n        return [3];\n    if (n == 5) \n  \
    \      return [5];\n    if (n == 7) \n        return [7];\n    if (n == 11) \n\
    \        return [11];\n    //\n    uint l = cast(uint) n;\n    ulong max = cast(ulong)\
    \ sqrt(cast(double) n);\n    long[] factors = new long[];\n    ulong i = 2;\n\
    \    while (i <= max) \n    {\n        if (l % i == 0) \n        {\n         \
    \   long[] sub = factorize(i);\n            for (size_t j = 0; j < sub.length;\
    \ j++) \n            {\n                factors ~= sub[j];\n            }\n  \
    \          l /= i;\n            max = cast(ulong) sqrt(cast(double) l);\n    \
    \    }\n        i++;\n    }\n    if (l > 1) \n    {\n        factors ~= l;\n \
    \   }\n    return factors;\n}\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3opayae5.d(33): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp3opayae5.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>>\
    \ factorize(70)\n    [2, 5, 7]\n    \n*/\nlong[] factorize(long n) \n{\n    long[]\
    \ factors = [n];\n    int i = 2;\n    while (i <= n)\n    {\n        if (n % i\
    \ == 0)\n        {\n            n /= i;\n            factors ~= i;\n        }\n\
    \        else\n        {\n            i++;\n        }\n    }\n    return factors;\n\
    }\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) ==\
    \ [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) ==\
    \ [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpsh26ebtc.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4285bd]\\n??:? void tmpsh26ebtc.__unittest_L33_C1()\
    \ [0x427f4a]\\n??:? void tmpsh26ebtc.__modtest() [0x428340]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42cfb7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42be4a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x43089d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430829]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42be21]\\n??:? runModuleUnitTests [0x42cd8d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428a0c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428993]\\n??:? _d_run_main [0x4288fe]\\n??:? main [0x428353]\\\
    n??:? __libc_start_main [0xb80a1554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>>\
    \ factorize(70)\n    [2, 5, 7]\n    \n*/\nlong[] factorize(long n) \n{\n    long[]\
    \ ret;\n    ret ~= 0;\n    foreach(i; [2..sqrt(n)])\n    {\n        long nn =\
    \ n;\n        long prev_n = nn;\n        while (nn % i == 0)\n        {\n    \
    \        nn /= i;\n            if (prev_n != nn)\n            {\n            \
    \    ret ~= i;\n                prev_n = nn;\n            }\n        }\n    }\n\
    \    if (n != 1)\n        ret ~= n;\n    return ret;\n}\nunittest\n{\n    alias\
    \ candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4opsh1e9.d(19): Error: found `..` when expecting `,`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4opsh1e9.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>>\
    \ factorize(70)\n    [2, 5, 7]\n    \n*/\nlong[] factorize(long n) \n{\n\tlong[]\
    \ result = new long[0];\n\tulong number = cast(ulong)n;\n\tif (n == 0 || n ==\
    \ 1) \n\t{\n\t\treturn [number];\n\t}\n\tuint i = 2;\n\twhile (number > 1) \n\t\
    {\n\t\tulong factor = cast(ulong)i;\n\t\tif (number % factor == 0) \n\t\t{\n\t\
    \t\tresult ~= cast(long)factor;\n\t\t\tnumber /= factor;\n\t\t} \n\t\telse \n\t\
    \t{\n\t\t\ti++;\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>>\
    \ factorize(70)\n    [2, 5, 7]\n    \n*/\nlong[] factorize(long n) \n{\n     auto\
    \ result = [];\n     long[] primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109,\
    \ 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197,\
    \ 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283,\
    \ 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389,\
    \ 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487,\
    \ 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599,\
    \ 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691,\
    \ 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811,\
    \ 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919,\
    \ 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021,\
    \ 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103,\
    \ 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187,\nunittest\n{\n \
    \   alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpa5ssocxx.d(19): Error: expression expected, not `unittest`\\\
    n/tmp/tmpa5ssocxx.d(20): Error: comma expected separating array initializers,\
    \ not `{`\\n/tmp/tmpa5ssocxx.d(32): Error: comma expected separating array initializers,\
    \ not `void`\\n/tmp/tmpa5ssocxx.d(32): Error: semicolon expected, not `main`\\\
    n/tmp/tmpa5ssocxx.d(32): Error: found `{` when expecting `;` following statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa5ssocxx.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>>\
    \ factorize(70)\n    [2, 5, 7]\n    \n*/\nlong[] factorize(long n) \n{ \n    long[]\
    \ res = []; \n    // Print the number of 2s that divide n \n    while (n % 2 ==\
    \ 0) \n    { \n        res ~= 2; \n        n = n / 2; \n    } \n  \n    // n must\
    \ be odd at this point.  So we can skip  \n    // one element (Note i = i +2)\
    \ \n    for (long i = 3; i <= n; i = i + 2) \n    { \n        // While i divides\
    \ n, print i and divide n \n        while (n % i == 0) \n        { \n        \
    \    res ~= i; \n            n = n / i; \n        } \n    } \n  \n    // This\
    \ condition is to handle the case when n  \n    // is a prime number greater than\
    \ 2 \n    if (n > 2) \n        res ~= n; \n  \n    return res; \n} \nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>>\
    \ factorize(70)\n    [2, 5, 7]\n    \n*/\nlong[] factorize(long n) \n{\n    /*\n\
    \    Algorithm:\n    1. Find the smallest prime factor of N with help of sieve\
    \ of Eratosthenes,\n       other small primes could be found by trial division.\n\
    \    2. Repeat step 1 while the factor divides N.\n    3. Replace N with N / factor.\n\
    \    4. Repeat steps 1-3 until N becomes 1.\n    */\n    // Algorithm taken from\
    \ http://www.geeksforgeeks.org/print-all-prime-factors-of-a-given-number/\n  \
    \  // The primes less than or equal to N can be found in O(NloglogN) operations.\n\
    \    // The total complexity of the algorithm is O(NloglogN).\n    long[] fact\
    \ = [];\n    while (n % 2 == 0) \n    {\n        fact ~= 2;\n        n = n / 2;\n\
    \    }\n    long i = 3;\n    while (i * i <= n) \n    {\n        while (n % i\
    \ == 0) \n        {\n            fact ~= i;\n            n = n / i;\n        }\n\
    \        i = i + 2;\n    }\n    if (n > 2) \n    {\n        fact ~= n;\n    }\n\
    \    return fact;\n}\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
