name: HumanEval_10_make_palindrome
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n Find the shortest palindrome\
  \ that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find\
  \ the longest postfix of supplied string that is a palindrome.\n    - Append to\
  \ the end of the string reverse of a string prefix that comes before the palindromic\
  \ suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n\
  \    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \n*/\nstring make_palindrome(string\
  \ string) \n"
tests: "unittest\n{\n    alias candidate = make_palindrome;\n\n    assert(candidate(\"\
  \") == \"\");\n    assert(candidate(\"x\") == \"x\");\n    assert(candidate(\"xyz\"\
  ) == \"xyzyx\");\n    assert(candidate(\"xyx\") == \"xyx\");\n    assert(candidate(\"\
  jerry\") == \"jerryrrej\");\n}\nvoid main(){}"
completions: ["{\n    auto length = string.length;\n    auto reverse = string.dup.reverse;\n\
    \    foreach (i; 0 .. length)\n    {\n        if (reverse[i .. $] == string[0\
    \ .. length - i]) \n        {\n            return string ~ reverse[0 .. i].reverse;\n\
    \        }\n    }\n    return string;\n}\n/*\n    Finds the longest palindromic\
    \ substring of a string.\n    >>> long_palindrome('banana')\n    'anana'\n   \
    \ >>> long_palindrome('a')\n    'a'\n    >>> long_palindrome('aaaa')\n    'aaaa'\n\
    \    >>> long_palindrome('abcdefg')\n    'a'\n    >>> long_palindrome('abba')\n\
    \    'abba'\n    >>> long_palindrome('ac')\n    'a'\n    >>> long_palindrome('acd')\n\
    \    'a'\n    >>> long_palindrome('abbacd')\n    'abba'\n    >>> long_palindrome('abbacdd')\n\
    \    'abba'\n    >>> long_palindrome('abbacdde')\n    'abba'\n*/\nstring long_palindrome(string\
    \ string) \n{\n    auto length = string.length;\n    if (length <= 1) \n    {\n\
    \        return string;\n    }\n    else \n    {\n        foreach (i; 0 .. length)\n\
    \        {\n            if (string[i] == string[length - 1]) \n            {\n\
    \                auto result = long_palindrome(string[i + 1 .. length - 1]);\n\
    \                if (result.length == length - 2) \n                {\n      \
    \              return string[i .. length];\n                }\n              \
    \  else \n                {\n                    return result;\n            \
    \    }\n            }\n        }\n        return string[0 .. 1];\n    }\n}\n/*\n\
    \    Find the longest prefix that is a palindrome.\n    >>> longest_prefix_palindrome('banana')\n\
    \    'ana'\n    >>> longest_prefix_palindrome('a')\n    'a'\n    >>> longest_prefix_palindrome('aaaa')\n\
    \   ", "{\n    auto\n    r = reverse(string);\n    auto len = string.length;\n\
    \    if (r[0 .. len] == string)\n        return string;\n    else\n    {\n   \
    \     string[] prefixes = new string[];\n        for (size_t i = 0; i < len; i++)\n\
    \        {\n            auto prefix = string[0 .. i];\n            if (prefix\
    \ == r[(len - i) .. len])\n                prefixes ~= prefix;\n        }\n  \
    \      string result = string ~ reverse(max(prefixes, (a, b) => a.length < b.length));\n\
    \        return result;\n    }\n}\n ", "{\n    if (string.empty)\n    {\n    \
    \    return string;\n    }\n    string tail = string.dropOne;\n    size_t count\
    \ = 1;\n    for (size_t i = 0; i < tail.length; i++)\n    {\n        if (tail[i..$]\
    \ == tail[$-1-i..$-1])\n        {\n            count = i + 1;\n        }\n   \
    \ }\n    string head = tail[$-count..$];\n    return head ~ string ~ head.retro;\n\
    }", "{\n    auto length = string.length;\n    if (length <= 1) \n    {\n     \
    \   return string;\n    }\n    auto reverse = string.dup.reverse;\n    auto suffix\
    \ = reverse[0 .. length];\n    auto distance = mismatch(string, suffix).length;\n\
    \    return string ~ reverse[distance .. $];\n}", "{\n    int max_count = 0;\n\
    \    int index = 0;\n    int n = string.length;\n    for (int i = 0; i < n; i++)\
    \ \n    {\n        int count = 0;\n        int low = i;\n        int high = i;\n\
    \        while (low >= 0 && high < n && string[low] == string[high]) \n      \
    \  {\n            count += 1;\n            low -= 1;\n            high += 1;\n\
    \        }\n        if (count > max_count) \n        {\n            max_count\
    \ = count;\n            index = i;\n        }\n    }\n    int start = index -\
    \ max_count + 1;\n    int end = index + max_count - 1;\n    if (start == 0) \n\
    \    {\n        return string;\n    }\n    return string[start .. end] ~ string[start\
    \ - 1 .. 0].reverse;\n}", "{\n    // Take a reverse of supplied string\n    string\
    \ reverse = string.reverse;\n    // Find the longest postfix of supplied string\
    \ that is a palindrome\n    uint i = 0;\n    while(i < reverse.length && reverse[i..$]\
    \ != string[0..i])\n    {\n        i++;\n    }\n    // Append to the end of the\
    \ string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    return string ~ reverse[i..$];\n}", "{\n    enum length = string.length;\n\
    \    alias first = string[0..length / 2];\n    alias second = string[$..$][0..length\
    \ / 2];\n    int prefix = longest_palindrome_prefix(first);\n    string palindrome\
    \ = first ~ reverse(first[prefix..$]);\n    return palindrome;\n}", "{\n    auto\
    \ r  = reverse(string);\n    // Find the longest postfix of the string that is\
    \ a palindrome.\n    for (auto i = 1; i < string.length; ++i)\n    {\n       \
    \ if (string[0 .. i] == r[0 .. i])\n        {\n            //string[0 .. i] ==\
    \ r[0 .. i]\n            // Append reverse of the prefix that comes before the\
    \ palindromic suffix.\n            return string ~ r[i .. $];\n        }\n   \
    \ }\n    return string ~ r;\n}\n// Solve the suffix tree construction problem.\n\
    //\n//\n//\n//        \n//\n//\n//\n//\n//    \n//\n//   3  \n//  / \\  \n// 4\
    \   5  \n// |\n// 6\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\
    //\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\
    //\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\
    //\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\
    //\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\
    //\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\
    //\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\
    //\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\
    //\n//\n//\n//\n//\n//\n//\n//\n", "{\n\tif (string.length == 0) return string;\n\
    \tstring s = string.dup;\n\t// Find the longest postfix that is a palindrome.\n\
    \tforeach (int i; 0 .. s.length/2) {\n\t\tif (s[i] != s[s.length - i - 1]) {\n\
    \t\t\ts = s[i+1..$];\n\t\t}\n\t}\n\t// Append the reverse of a prefix to the string.\n\
    \treturn string ~ s[s.length..s.length - 1].reversed;\n}\n/*\n Find the longest\
    \ string that is a substring of both supplied strings.\n    >>> common_substring('abc',\
    \ 'abca')\n    'abc'\n    >>> common_substring('abc', 'def')\n    ''\n    >>>\
    \ common_substring('', 'def')\n    ''\n*/\nstring common_substring(string s1,\
    \ string s2) \n{\n\tif (s1.length == 0 || s2.length == 0) return \"\";\n\t// Swap\
    \ s1 and s2 if s1 is longer than s2.\n\tauto s = tuple(s1, s2);\n\tif (s[0].length\
    \ > s[1].length) {\n\t\ts = tuple(s[1], s[0]);\n\t}\n\t// Try all substrings of\
    \ the shorter string.\n\tstring result = \"\";\n\tforeach (int i; 0 .. s[0].length)\
    \ {\n\t\tforeach (int j; i .. s[0].length) {\n\t\t\tstring substring = s[0][i..j];\n\
    \t\t\tif (s[1].indexOf(substring) != -1 && substring.length > result.length) {\n\
    \t\t\t\tresult = substring;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n/*\n Find\
    \ the longest string that is a substring of both supplied strings.\n    >>> common_substring('abc',\
    \ 'abca')\n    'abc'\n    >>> common_substring('abc', 'def')\n    ''\n    >>>\
    \ common_substring('', 'def')\n    ''\n*/\nstring common_", "{ \n  auto is_palindrome\
    \ = (string string) {\n    foreach (int i, char _; string[0 .. $ - 1]) {\n   \
    \   if (string[i] != string[$ - 1 - i]) return false;\n    }\n    return true;\n\
    \  };\n  \n  auto find_palindrome_postfix = (string string) {\n    while (!is_palindrome(string))\
    \ {\n      string = string[0 .. $ - 1];\n    }\n    return string;\n  };\n  \n\
    \  if (string.length == 0) return string;\n  return string ~ reverse(string[0\
    \ .. $ - find_palindrome_postfix(reverse(string)).length]);\n}\n ", "{\n    //\
    \ length of suffix that is the longest palindrome\n    size_t length = longest_palindromic_suffix(string);\n\
    \    // Reversed string prefix\n    string prefix = string[0..$-length].idup.reverse;\n\
    \    // Append prefix to the end of supplied string.\n    return string ~ prefix;\n\
    }\n/*\n Find the longest substring that is a palindrome.\n    >>> longest_palindromic_suffix('cat')\n\
    \    0\n    >>> longest_palindromic_suffix('cata')\n    2\n*/\nsize_t longest_palindromic_suffix(string\
    \ string) \n{\n    string reverse = string.idup.reverse;\n    size_t length =\
    \ 0;\n    foreach (index, char; string) {\n        if (char == reverse[index])\
    \ {\n            length++;\n        } else {\n            break;\n        }\n\
    \    }\n    return length;\n}\n/*\n Find the longest palindromic substring in\
    \ a supplied string.\n    >>> longest_palindromic_substring('cat')\n    'c'\n\
    \    >>> longest_palindromic_substring('cata')\n    'cat'\n    >>> longest_palindromic_substring('catac')\n\
    \    'cata'\n    >>> longest_palindromic_substring('catacat')\n    'catacat'\n\
    \    >>> longest_palindromic_substring('catacata')\n    'atacat'\n    >>> longest_palindromic_substring('catacatac')\n\
    \    'atacata'\n*/\nstring longest_palindromic_substring(string string) \n{\n\
    \    // We look for palindromes up to max length/2. After that we only find\n\
    \    // mirrored substrings.\n    auto half_length = string.length / 2;\n    foreach\
    \ (length; half_length.iota.reverse) {\n        size_t max_index = string.length\
    \ - length;\n        foreach (index; 0..max_index) {\n            // We test for\
    \ palindrome by checking if its reverse matches the substring\n            if\
    \ (string[index", "{\n    int max_palindrome_size = longest_palindrome_size(string);\n\
    \    int prefix_size = string.length - max_palindrome_size;\n    string prefix\
    \ = string[0..prefix_size];\n    return string ~ reverse(prefix);\n}", "{\n  \
    \  // Find the longest postfix of supplied string that is a palindrome.\n    //\
    \ If a string is a palindrome, then reverse(prefix) is a substring of the string\
    \ itself.\n    // It's easy to find the longest suffix that is a palindrome in\
    \ linear time:\n    // compute the values of the KMP-matcher function. This algorithm\
    \ finds all prefixes of the string\n    // that are also suffixes, and in the\
    \ same time finds the length of the longest palindromic suffix.\n    // In this\
    \ case the longest palindromic suffix will be the string itself, so there is no\
    \ need to\n    // compute all values of the KMP-matcher, only the last one will\
    \ suffice.\n    auto kmp = new int[string.length];\n    kmp[0] = 0;\n    for (int\
    \ i = 1; i < string.length; i++) \n    {\n        int j = kmp[i - 1];\n      \
    \  while (j > 0 && string[i] != string[j]) \n        {\n            j = kmp[j\
    \ - 1];\n        }\n        if (string[i] == string[j]) \n        {\n        \
    \    j++;\n        }\n        kmp[i] = j;\n    }\n    // Reverse of a string prefix\
    \ that comes before the palindromic suffix.\n    // The i-th prefix ends at i-th\
    \ position and starts at kmp[i-1] position,\n    // so the reverse of the prefix\
    \ ends at i - kmp[i-1] position and starts at 0-th position.\n    // It's easy\
    \ to append a substring to the end of the string by using slicing [begin .. end]\n\
    \    return string ~ string[0 .. string.length - kmp[string.length - 1]].reverse;\n\
    }", "{ \n    // Find the longest palindromic suffix.\n    size_t i = 0; \n   \
    \ size_t j = string.length; \n    while (i < j) \n    { \n        if (string[i]\
    \ == string[j - 1]) \n        { \n            i++; \n            j--; \n     \
    \   } \n        else \n        { \n            i = 0; \n            j--; \n  \
    \      } \n    } \n  \n    return string + string[i..string.length].idup.reverse;\
    \ \n}", "{\n    if (string.empty)\n        return string;\n    auto suffix_start\
    \ = string.length;\n    for (; suffix_start; --suffix_start) \n    {\n       \
    \ if (string[0 .. suffix_start] == string[suffix_start .. $].idup.reverse)\n \
    \           break;\n    }\n    assert(suffix_start, \"The algorithm should terminate\
    \ in all cases\");\n    return string ~ string[suffix_start .. $].idup.reverse;\n\
    }", "{\n    size_t prefix_len = 0;\n    if (string.length > 1)\n    {\n      \
    \  string rev_string = string.dup.reverse;\n        auto result = rev_string.find(string[0..$-1]);\n\
    \        if (result.length)\n        {\n            prefix_len = result.at.to;\n\
    \        }\n    }\n    return string ~ string[0..$-prefix_len].reverse;\n}", "{\n\
    \    immutable max_iterations = string.length;\n    immutable half_max_iterations\
    \ = max_iterations / 2;\n    uint iter_counter = 0;\n    while (iter_counter <\
    \ half_max_iterations) {\n        immutable i = string.length - iter_counter -\
    \ 1;\n        immutable j = iter_counter;\n        if (string[i] != string[j])\
    \ {\n            break;\n        }\n        iter_counter++;\n    }\n    return\
    \ string ~ string[0..~iter_counter];\n}", "{\n    int reversed_middle = string.length\
    \ + 1;\n    int length = string.length;\n    string prefix;\n    string reversed_prefix;\n\
    \    string suffix;\n    while (length >= 0) \n    {\n        suffix = string[reversed_middle..length];\n\
    \        reversed_prefix = reverse(string[0..reversed_middle]);\n        if (suffix\
    \ == reversed_prefix) \n        {\n            prefix = string[0..reversed_middle];\n\
    \            reversed_middle = reversed_middle - 1;\n            break;\n    \
    \    }\n        length--;\n    }\n    return prefix ~ reverse(prefix);\n}", "{\n\
    \    size_t len = string.length;\n    if (len == 0)\n    {\n        return \"\"\
    ;\n    }\n    /* Find the longest palindromic postfix of a string. */\n    size_t\
    \ end_of_longest_palindrome = len;\n    size_t n = 1;\n    while (n < len)\n \
    \   {\n        size_t start_of_prefix = 0;\n        size_t end_of_prefix = len\
    \ - n;\n        while (start_of_prefix < end_of_prefix)\n        {\n         \
    \   if (string[start_of_prefix] != string[end_of_prefix])\n            {\n   \
    \             break;\n            }\n            start_of_prefix++;\n        \
    \    end_of_prefix++;\n        }\n        if (start_of_prefix >= end_of_prefix)\n\
    \        {\n            end_of_longest_palindrome = end_of_prefix;\n         \
    \   break;\n        }\n        n++;\n    }\n    /* Append the reverse of the prefix\
    \ to the end of the supplied string. */\n    string prefix = string[0..end_of_longest_palindrome];\n\
    \    return string ~ prefix.reverse;\n}", "{\n    int longest_suffix_palindrome_len\
    \ = longest_suffix_palindrome_length(string);\n    if (longest_suffix_palindrome_len\
    \ == string.length)\n        return string;\n    else\n        return string ~\
    \ string[0..$-longest_suffix_palindrome_len].reverse;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
