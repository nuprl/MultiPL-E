name: HumanEval_122_add_elements
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    Given a non-empty array\
  \ of integers arr and an integer k, return\n    the sum of the elements with at\
  \ most two digits from the first k elements of arr.\n\n    Example:\n\n        Input:\
  \ arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Output: 24 # sum of 21 + 3\n\n\
  \    Constraints:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n\
  \    \n*/\nlong add_elements(long[] arr, long k) \n"
tests: "unittest\n{\n    alias candidate = add_elements;\n\n    assert(candidate([1L,\
  \ -2L, -3L, 41L, 57L, 76L, 87L, 88L, 99L], 3L) == -4L);\n    assert(candidate([111L,\
  \ 121L, 3L, 4000L, 5L, 6L], 2L) == 0L);\n    assert(candidate([11L, 21L, 3L, 90L,\
  \ 5L, 6L, 7L, 8L, 9L], 4L) == 125L);\n    assert(candidate([111L, 21L, 3L, 4000L,\
  \ 5L, 6L, 7L, 8L, 9L], 4L) == 24L);\n    assert(candidate([1L], 1L) == 1L);\n}\n\
  void main(){}"
completions: ["{\n    long sum = 0;\n    foreach(immutable e; arr[0 .. cast(size_t)k])\n\
    \    {\n        if(e < 100)\n            sum += e;\n    }\n    return sum;\n}",
  "{\n    long count = 0;\n    long ans = 0;\n    foreach(num; arr) {\n        if(num\
    \ < 100 && count < k) {\n            ans += num;\n            count++;\n     \
    \   }\n    }\n    return ans;\n}", "{\n    long sum = 0;\n    foreach(e; arr[0..k])\n\
    \    {\n        if(e >= 10 && e < 100)\n            sum += e;\n    }\n    return\
    \ sum;\n}", "{\n    /*\n        We need to find the sum of the first k elements.\n\
    \        We will also determine the total number of two\n        digit numbers.\
    \ We will then subtract the total\n        number of two digit numbers from k\
    \ to get the\n        number of one digit numbers we will sum.\n    */\n    int\
    \ k_two_digit = 0;\n    foreach(i; arr[0..k])\n    {\n        if(i > 9 && i <\
    \ 100) k_two_digit++;\n    }\n    int k_one_digit = k - k_two_digit;\n    /* \n\
    \        We will then sum the first k_one_digit of arr.\n        We will then\
    \ sum the two digit numbers from\n        the first k_two_digit of arr.\n    */\n\
    \    long sum = 0;\n    foreach(i; arr[0..k_one_digit]) sum += i;\n    foreach(i;\
    \ arr[k_one_digit..k_two_digit]) sum += i;\n    return sum;\n}", "{\n    long\
    \ sum = 0;\n    for (long i = 0; i < k; i++)\n    {\n        if (arr[i] <= 99)\n\
    \        {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}",
  "{\n    int sum = 0;\n    int i = 0;\n    while (i < k)\n    {\n        if (arr[i]\
    \ > 100)\n        {\n            sum += 100;\n        }\n        else\n      \
    \  {\n            sum += arr[i];\n        }\n        i++;\n    }\n    return sum;\n\
    }", "{\n    long sum = 0;\n    foreach(idx, elem; arr)\n    {\n        // check\
    \ if current element is less than 99\n        if(elem < 99)\n        {\n     \
    \       sum += elem;\n        }\n        \n        // break when k elements are\
    \ added to sum\n        if(idx == k - 1)\n        {\n            break;\n    \
    \    }\n    }\n    return sum;\n}", "{\n    long result = 0;\n    foreach(i; 0\
    \ .. k)\n    {\n        long value = arr[i];\n        if(value / 100 == 0)\n \
    \       {\n            result += value;\n        }\n    }\n    return result;\n\
    }", "{\n    size_t i;\n    long result = 0;\n    foreach(e; arr[0 .. k]) {\n \
    \       if(e >= 0 && e < 10) {\n            result += e;\n        }\n        else\
    \ if(e >= 10 && e < 100) {\n            result += e;\n        }\n    }\n    return\
    \ result;\n}", "{\n    // return sum of first k elements with at most 2 digits\n\
    \    long sum = 0;\n    for (long i = 0; i < k; i++)\n    {\n        // elements\
    \ greater than 99 and upto 999\n        if (arr[i] < 1000)\n        {\n      \
    \      // elements less than 99\n            if (arr[i] < 100)\n            {\n\
    \                sum += arr[i];\n            }\n            else\n           \
    \ {\n                auto t = to!string(arr[i]);\n                // elements\
    \ greater than 99 and less than 200\n                if (to!int(t[0..1]) < 20)\n\
    \                {\n                    sum += to!int(t[0..1]);\n            \
    \    }\n                else\n                {\n                    sum += to!int(t[0..2]);\n\
    \                }\n            }\n        }\n    }\n    return sum;\n}", "{\n\
    \    long sum = 0;\n    foreach(i; 0 .. k) {\n        if (isOneDigit(arr[i]) ||\
    \ isTwoDigit(arr[i])) {\n            sum += arr[i];\n        }\n    }\n    return\
    \ sum;\n}", "{\n    // create a dynamic array\n    auto dyn_arr = arr.dup;\n \
    \   // sort the array from smallest to largest\n    dyn_arr.sort();\n    long\
    \ sum = 0;\n    for (long i = 0; i < k; i++)\n    {\n        if (arr[i] >= 10\
    \ && arr[i] <= 99)\n        {\n            sum += arr[i];\n        }\n    }\n\
    \    return sum;\n}", "{\n    long a = 0;\n    foreach(e; arr[0..k])\n    {\n\
    \        if(e > 9 && e < 100)\n            a += e;\n    }\n    return a;\n}",
  "{\n    long sum = 0;\n    long[] int_arr = arr.dup;\n    while (k > 0)\n    {\n\
    \        int[] result = int_arr[0].divmod(10);\n        if (result[0] < 1)\n \
    \       {\n            sum += int_arr[0];\n            int_arr.removeFront();\n\
    \            k--;\n        }\n        else if (result[0] < 10)\n        {\n  \
    \          sum += int_arr[0];\n            int_arr.removeFront();\n          \
    \  k--;\n        }\n        else\n        {\n            int_arr.removeFront();\n\
    \        }\n    }\n    return sum;\n}", "{\n    // find the minimum number of\
    \ digits needed to represent each element\n    long max_digits = arr.map!(s =>\
    \ log10(s) + 1).max;\n    // add the element if it's less than or equal to the\
    \ number of digits\n    return arr.take(k).filter!(s => log10(s) + 1 <= max_digits).sum;\n\
    }", "{\n    long result = 0;\n    foreach(elem; arr[0..k])\n    {\n        auto\
    \ str = format(\"%s\", elem);\n        result += elem >= 100 ? 0 : elem;\n   \
    \ }\n    return result;\n}\n// fast\nlong add_elements_fast(long[] arr, long k)\
    \ \n{\n    long result = 0;\n    foreach(elem; arr[0..k])\n    {\n        result\
    \ += elem >= 100 ? 0 : elem;\n    }\n    return result;\n}\n// faster\nlong add_elements_faster(long[]\
    \ arr, long k) \n{\n    long result = 0;\n    for(long i = 0; i < k; i++)\n  \
    \  {\n        result += arr[i] >= 100 ? 0 : arr[i];\n    }\n    return result;\n\
    }\n//", "{\n    enum n = arr.length;\n    long[] temp;\n    temp[] = new long[n];\n\
    \    long sum = 0;\n    for (long i = 0; i < n; i++) \n    {\n        temp[i]\
    \ = arr[i] % 100;\n    }\n    for (long i = 0; i < k; i++) \n    {\n        sum\
    \ += temp[i];\n    }\n    return sum;\n}", "{\n    long result = 0;\n    long\
    \ i = 0;\n    while (i < k)\n    {\n        result += arr[i];\n        ++i;\n\
    \    }\n    return result;\n}", "{\n    long ret = 0;\n    for (size_t i = 0;\
    \ i < k; i++)\n    {\n        if (arr[i] < 100)\n        {\n            ret +=\
    \ arr[i];\n        }\n    }\n    return ret;\n}", "{\n    long sum = 0;\n    foreach(idx,\
    \ val; arr)\n    {\n        if(val < 100) \n        {\n            // idx + 1\
    \ is the current element index.\n            if(idx + 1 <= k) \n            {\n\
    \                sum += val;\n            }\n        }\n    }\n    return sum;\n\
    }"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
