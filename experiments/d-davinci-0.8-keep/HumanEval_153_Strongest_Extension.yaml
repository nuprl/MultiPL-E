name: HumanEval_153_Strongest_Extension
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name of\
  \ a class (a string) and a list of extensions.\n    The extensions are to be used\
  \ to load additional classes to the class. The\n    strength of the extension is\
  \ as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
  \ name, and let SM be the number of lowercase letters \n    in the extension's name,\
  \ the strength is given by the fraction CAP - SM. \n    You should find the strongest\
  \ extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
  \    If there are two or more extensions with the same strength, you should\n  \
  \  choose the one that comes first in the list.\n    For example, if you are given\
  \ \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes', 'Cheese',\
  \ 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes'\
  \ is the strongest extension \n    (its strength is -1).\n    Example:\n    for\
  \ Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n    \n*/\n\
  string Strongest_Extension(string class_name, string[] extensions) \n"
tests: "unittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
  Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
  Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
  );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
  , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
  K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
  __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
  YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
  YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
  , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\"\
  , \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"])\
  \ == \"Sp.671235\");\n}\nvoid main(){}"
completions: ["{\n    double max_strength = -DBL_MAX;\n    string max_strength_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        double extension_strength\
    \ = calc_extension_strength(extension);\n        if(extension_strength > max_strength)\n\
    \        {\n            max_strength = extension_strength;\n            max_strength_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ max_strength_extension;\n\
    }\ndouble calc_extension_strength(string extension)\n{\n    double cap_strength\
    \ = (double)extension.countUpper;\n    double sm_strength = (double)extension.countLower;\n\
    \    return cap_strength - sm_strength;\n}", "{\n    double strength;\n    double\
    \ maxStrength = 0;\n    int indexOfMax = 0;\n    foreach(int i, string ext; extensions)\n\
    \    {\n        strength = std.algorithm.count!(x => x.isUpper)(ext) - \n    \
    \        std.algorithm.count!(x => x.isLower)(ext);\n        if(strength > maxStrength)\n\
    \        {\n            maxStrength = strength;\n            indexOfMax = i;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ extensions[indexOfMax];\n}",
  "{\n    string strongest_extension = \"\";\n    int strongest_extension_strength\
    \ = 0;\n    foreach(string extension; extensions)\n    {\n        int this_extension_strength\
    \ = 0;\n        foreach(char character; extension)\n        {\n            if(isupper(character))\
    \ this_extension_strength++;\n            else if(islower(character)) this_extension_strength--;\n\
    \        }\n        if(this_extension_strength > strongest_extension_strength)\n\
    \        {\n            strongest_extension_strength = this_extension_strength;\n\
    \            strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}", "{\n    import std.string;\n    int cap;\n\
    \    int sm;\n    int[] strengths;\n    int index;\n    string result;\n    import\
    \ std.algorithm;\n    import std.array;\n    strengths = extensions.map!(a =>\
    \ {\n        cap = 0;\n        sm = 0;\n        foreach(i; a)\n        {\n   \
    \         if(isUpper(i))\n                cap++;\n            else if(isLower(i))\n\
    \                sm++;\n        }\n        return cap - sm;\n    }).array;\n \
    \   import std.algorithm;\n    index = maxElement(strengths).idx;\n    result\
    \ = class_name ~ \".\" ~ extensions[index];\n    return result;\n}", "{\n    int\
    \ max(int a, int b)\n    {\n        return a > b ? a : b;\n    }\n    //int max2\
    \ = max(3,4);\n    string res = class_name;\n    int strength = -1;\n    int res_strength\
    \ = -1;\n    foreach(string ext; extensions)\n    {\n        foreach(inout char\
    \ c; ext)\n        {\n            if(isUpper(c)) strength++;\n            else\
    \ strength--;\n        }\n        if(abs(strength) > abs(res_strength))\n    \
    \    {\n            res_strength = strength;\n            res = class_name ~ \"\
    .\" ~ ext;\n        }\n        strength = -1;\n    }\n    return res;\n}", "{\n\
    \    double best_extension_strength = -100;\n    int best_extension_index = 0;\n\
    \    for (int i = 0; i < extensions.length; i++)\n    {\n        double current_extension_strength\
    \ = uppercase_count(extensions[i]) - lowercase_count(extensions[i]);\n       \
    \ if (current_extension_strength > best_extension_strength)\n        {\n     \
    \       best_extension_strength = current_extension_strength;\n            best_extension_index\
    \ = i;\n        }\n    }\n    return class_name ~ \".\" ~ extensions[best_extension_index];\n\
    }", "{\n    double max = 0;\n    string return_string = \"\";\n    foreach(extension;\
    \ extensions)\n    {\n        int upper = countUntil!(a => a.isUpper)(extension.front);\n\
    \        int lower = countUntil!(a => a.isLower)(extension.front);\n        double\
    \ strength = ((double)upper - (double)lower) / (double)extension.length;\n   \
    \     if(strength > max)\n        {\n            max = strength;\n           \
    \ return_string = class_name ~ \".\" ~ extension;\n        }\n    }\n    return\
    \ return_string;\n}", "{\n    double[] strengths = extensions.map!(ext => ext.filter!(a\
    \ => a >= 'A' && a <= 'Z').length - ext.filter!(a => a >= 'a' && a <= 'z').length).array;\n\
    \    return class_name ~ \".\" ~ extensions[indexOf(strengths, max(strengths))];\n\
    }", "{\n    auto num_upper = (char c) { return c >= 'A' && c <= 'Z'; };\n    auto\
    \ num_lower = (char c) { return c >= 'a' && c <= 'z'; };\n    int i = 0;\n   \
    \ float max = -1;\n    string selected = \"\";\n    while (i < extensions.length)\n\
    \    {\n        float upper = filter!num_upper(extensions[i]).length;\n      \
    \  float lower = filter!num_lower(extensions[i]).length;\n        float strength\
    \ = upper - lower;\n        if (strength > max)\n        {\n            max =\
    \ strength;\n            selected = extensions[i];\n        }\n        i++;\n\
    \    }\n    return class_name ~ \".\" ~ selected;\n}", "{\n    int capCount =\
    \ 0;\n    int smCount = 0;\n    int capSum = 0;\n    int smSum = 0;\n    int compare\
    \ = 0;\n    int compareSum = 0;\n    int x = 0;\n    string extension = \"\";\n\
    \    string result = \"\";\n    foreach(string ext; extensions)\n    {\n     \
    \   capCount = 0;\n        smCount = 0;\n        foreach(char ch; ext)\n     \
    \   {\n            if(isupper(ch))\n            {\n                capCount++;\n\
    \            }\n            else\n            {\n                smCount++;\n\
    \            }\n        }\n        capSum = capCount - smCount;\n        if(capSum\
    \ == compare)\n        {\n            if(extensions[x] < extension)\n        \
    \    {\n                extension = extensions[x];\n            }\n        }\n\
    \        else if(capSum > compare)\n        {\n            compare = capSum;\n\
    \            extension = extensions[x];\n        }\n        x++;\n    }\n    result\
    \ = format(\"%s.%s\", class_name, extension);\n    return result;\n}", "{\n  \
    \  struct  Ext{\n        string name;\n        int strength;\n    }\n    Ext[]\
    \ exts = new Ext[extensions.length];\n    foreach(i, elem; extensions)\n    {\n\
    \        Ext e;\n        e.name = elem;\n        e.strength = elem.count!(a =>\
    \ a.isUpper) - elem.count!(a => a.isLower);\n        exts[i] = e;\n    }\n   \
    \ size_t max_strength = exts.map!(x => x.strength).max;\n    foreach(i, elem;\
    \ exts)\n    {\n        if(elem.strength == max_strength)\n            return\
    \ class_name ~ \".\" ~ elem.name;\n    }\n    return \"\";\n}", "{\n    // \u041F\
    \u0440\u0438\u0432\u0435\u0442, \u043A\u043E\u043B\u043B\u0435\u0433\u0430! \u0412\
    \u044B \u043C\u043E\u0436\u0435\u0442\u0435 \u043E\u0442\u0440\u0435\u0434\u0430\
    \u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u044D\u0442\u043E\u0442\
    \ \u043A\u043E\u0434 \u0438 \u0437\u0430\u043F\u0443\u0441\u0442\u0438\u0442\u044C\
    \ \u0435\u0433\u043E.\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int cap = 0;\n \
    \       int sm = 0;\n        foreach(letter; extension)\n        {\n         \
    \   if (isUpper(letter))\n                cap++;\n            else\n         \
    \       sm++;\n        }\n        int strength = cap - sm;\n        if (max_strength\
    \ < strength)\n        {\n            max_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }", "{\n    struct Str\n    {\n        string @this;\n        int CAP;\n     \
    \   int SM;\n    }\n    int max = -100000;\n    Str best = Str(class_name, 0,\
    \ 0);\n    Str[] bests = new Str[0];\n    foreach(i, s; extensions)\n    {\n \
    \       Str str = Str(s, 0, 0);\n        foreach(c; str.@this)\n        {\n  \
    \          if(isUpper(c))\n                str.CAP++;\n            else\n    \
    \            str.SM++;\n        }\n        if(str.CAP - str.SM > max)\n      \
    \  {\n            max = str.CAP - str.SM;\n            best = str;\n         \
    \   bests = new Str[0];\n            bests ~= best;\n        }\n        else if(str.CAP\
    \ - str.SM == max)\n        {\n            bests ~= str;\n        }\n    }\n \
    \   return class_name ~ \".\" ~ bests[0].@this;\n}", "{\n    double strength =\
    \ -1.0;\n    string strongestExt = \"\";\n    string class_name_lower = class_name.toLower();\n\
    \    foreach(string extension, int i; extensions)\n    {\n        string extension_lower\
    \ = extension.toLower();\n        double ext_strength = cast(double)extension.countUpper()\
    \ - extension_lower.countLower();\n        if(ext_strength > strength && class_name_lower.indexOf(extension_lower)\
    \ != -1)\n        {\n            strength = ext_strength;\n            strongestExt\
    \ = extension;\n        }\n    }\n    return (class_name + \".\" + strongestExt);\n\
    }", "{\n    string ret = \"\";\n    double min = double.max;\n    foreach(string\
    \ s; extensions)\n    {\n        int capital_cnt = 0;\n        int small_cnt =\
    \ 0;\n        foreach(char c; s)\n        {\n            if(isupper(c)) capital_cnt++;\n\
    \            else if(islower(c)) small_cnt++;\n        }\n        if(small_cnt\
    \ - capital_cnt <= min)\n        {\n            ret = s;\n            min = small_cnt\
    \ - capital_cnt;\n        }\n    }\n    return format(\"%s.%s\", class_name, ret);\n\
    }", "{\n    int caps;\n    int sm;\n    int counter;\n    int max_value = -1;\n\
    \    int max_count = 0;\n    string[] str_arr;\n    string result;\n    foreach(i;\
    \ extensions)\n    {\n        caps = 0;\n        sm = 0;\n        foreach(ch;\
    \ i)\n        {\n            if(ch.isUpper)\n                caps++;\n       \
    \     else\n                sm++;\n        }\n        //writeln(i, \": \", caps\
    \ - sm);\n        counter = caps - sm;\n        if(counter > max_value)\n    \
    \    {\n            max_value = counter;\n            max_count = 0;\n       \
    \     str_arr = [i];\n        }\n        else if(counter == max_value)\n     \
    \   {\n            str_arr ~= i;\n        }\n    }\n    result = class_name ~\
    \ \".\" ~ str_arr[0];\n    return result;\n}", "{\n    int max_strength = -1;\n\
    \    string max_extension = \"\";\n    foreach(extension; extensions)\n    {\n\
    \        int strength = 0;\n        foreach(c; extension)\n        {\n       \
    \     if(std.ctype.isupper(c))\n                strength++;\n            else\n\
    \                strength--;\n        }\n        if(strength > max_strength)\n\
    \        {\n            max_strength = strength;\n            max_extension =\
    \ extension;\n        }\n    }\n    return class_name ~ \".\" ~ max_extension;\n\
    }", "{\n    double strength = 0;\n    string result = \"\";\n    foreach(string\
    \ str; extensions)\n    {\n        int CAP = 0;\n        int SM = 0;\n       \
    \ foreach(char c; str)\n        {\n            if(c.isUpper)\n               \
    \ CAP++;\n            else if(c.isLower)\n                SM++;\n        }\n \
    \       if(abs(CAP - SM) > strength)\n        {\n            strength = abs(CAP\
    \ - SM);\n            result = \".\" ~ str;\n        }\n    }\n    return class_name\
    \ ~ result;\n}", "{\n    string result = \"\";\n    double f = 0;\n    foreach(string\
    \ ext, int i; extensions)\n    {\n        string temp;\n        double s = 0;\n\
    \        foreach(char c; ext)\n        {\n            if(c >= 'A' && c <= 'Z')\n\
    \                s++;\n            else if(c >= 'a' && c <= 'z')\n           \
    \     s--;\n        }\n        if(s > f)\n        {\n            f = s;\n    \
    \        temp = ext;\n        }\n        result = format(\"%s.%s\", class_name,\
    \ temp);\n    }\n    return result;\n}", "{\n    string strong_extension = extensions[0];\n\
    \    int strong_strength = 0;\n    foreach(string extension; extensions)\n   \
    \ {\n        int cap = extension.count!(a => a.isUpper)();\n        int sm = extension.count!(a\
    \ => a.isLower)();\n        int strength = cap - sm;\n        if(strong_strength\
    \ < strength)\n        {\n            strong_strength = strength;\n          \
    \  strong_extension = extension;\n        }\n    }\n    return format(\"%s.%s\"\
    , class_name, strong_extension);\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
