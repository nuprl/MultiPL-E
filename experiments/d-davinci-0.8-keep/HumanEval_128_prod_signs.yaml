name: HumanEval_128_prod_signs
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
  \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
  \ by product of all signs\n    of each number in the array, represented by 1, -1\
  \ or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1,\
  \ 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n\
  \    \n*/\nNullable!(long) prod_signs(long[] arr) \n"
tests: "unittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result =\
  \ candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get ==\
  \ -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
  \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
  \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n\
  \        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n\
  \        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
  \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
  \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto\
  \ result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get\
  \ == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n      \
  \  assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
completions: ["{\n    long s = 1, t = 0;\n    foreach(n; arr) \n    {\n        s *=\
    \ sign(n);\n        t += abs(n);\n    }\n    return s ? s * t : null;\n}", "{\n\
    \    if (arr.length == 0) return Nullable!(long)();\n    auto s = new long[](arr.length);\n\
    \    foreach (i, e; arr) \n    {\n        if (e > 0) s[i] = 1;\n        else if\
    \ (e < 0) s[i] = -1;\n        else s[i] = 0;\n    }\n    return reduce!(\"a *\
    \ b\")(abs(e) for e in arr) * reduce!(\"a * b\")(s);\n}", "{\n    long[] signs;\n\
    \    foreach (n; arr)\n    {\n        // Store signs of each number\n        signs\
    \ ~= sign(n);\n    }\n    if (signs.length == 0) \n    {\n        return null;\n\
    \    }\n    long prodSigns = 1;\n    foreach (sign; signs)\n    {\n        prodSigns\
    \ *= sign;\n    }\n    long sumMagnitudes = 0;\n    foreach (n; arr)\n    {\n\
    \        // Sum magnitudes\n        sumMagnitudes += abs(n);\n    }\n    return\
    \ sumMagnitudes * prodSigns;\n}", "{\n  if (arr.length == 0)\n    return null;\n\
    \  long product = 1;\n  foreach (num; arr)\n  {\n    product *= sign(num);\n \
    \ }\n  long sum = 0;\n  foreach (num; arr)\n  {\n    sum += abs(num);\n  }\n \
    \ return product * sum;\n}", "{\n    if (arr.length == 0) \n    {\n        return\
    \ null;\n    }\n    long sum_magn = 0;\n    long prod_sign = 1;\n    foreach (n;\
    \ arr) \n    {\n        if (n != 0) \n        {\n            sum_magn += abs(n);\n\
    \            prod_sign *= sign(n);\n        }\n    }\n    return sum_magn * prod_sign;\n\
    }", "{\n    if (arr.length == 0)\n        return Nullable!(long)();\n    \n  \
    \  auto signs = arr.map!(a => (long)round(a/abs(a)));\n    auto vals = arr.map!(a\
    \ => abs(a));\n    return signs.reduce!((a,b) => a*b) * vals.reduce!((a,b) =>\
    \ a+b);\n}", "{\n    long res = 1L;\n    foreach(n; arr) {\n        res *= signbit(n);\n\
    \    }\n    return res == 0 ? res : res * sum(arr.map!abs.array);\n}", "{\n  \
    \  if (arr.length == 0)\n        return Nullable!(long)();\n    long prod = 1;\n\
    \    long sum = 0;\n    foreach (i; arr)\n    {\n        prod *= sign(i);\n  \
    \      sum += i.abs;\n    }\n    return Nullable!(long)(sum * prod);\n}", "{\n\
    \    if (arr.length == 0) \n    {\n        return Nullable!(long)();\n    }\n\
    \    long prodSigns = 1;\n    long sumMagnitudes = 0;\n    foreach (i; arr) \n\
    \    {\n        if (i < 0) \n        {\n            prodSigns *= -1;\n       \
    \ }\n        if (i == 0) \n        {\n            prodSigns = 0;\n        }\n\
    \        if (i != 0) \n        {\n            sumMagnitudes += abs(i);\n     \
    \   }\n    }\n    return Nullable!(long)(sumMagnitudes * prodSigns);\n}", "{\n\
    \    if (arr.length == 0)\n        return Nullable!(long)();\n    \n    long p\
    \ = 1;\n    long s = 0;\n    foreach (a; arr) \n    {\n        if (a < 0)\n  \
    \          p *= -1;\n        else if (a > 0)\n            p *= 1;\n        else\n\
    \            p *= 0;\n        s += a.abs;\n    }\n    return Nullable!(long)(p\
    \ * s);\n}\n ", "{\n    long sum = 0;\n    long prod = 1;\n    foreach(num; arr)\
    \ \n    {\n        if (num == 0)\n            return null;\n        prod *= sign(num);\n\
    \        sum += abs(num);\n    }\n    return sum * prod;\n}", "{\n    long ret\
    \ = 1;\n    foreach(e; arr)\n    {\n        if(e == 0)\n            ret = 0;\n\
    \        else\n            ret *= e / abs(e);\n    }\n    foreach(e; arr)\n  \
    \  {\n        if(e == 0)\n            ret = 0;\n        else\n            ret\
    \ *= abs(e);\n    }\n    return ret;\n}", "{\n    if (arr.length == 0) return\
    \ null;\n    long res = 1;\n    long total = 0;\n    foreach (num; arr)\n    {\n\
    \        if (num == 0) continue;\n        res *= sign(num);\n        total +=\
    \ abs(num);\n    }\n    return res * total;\n}", "{\n    auto signs = arr.map!(i\
    \ => sign(i));\n    auto product = reduce!((a, b) => a * b)(signs);\n    if (product\
    \ == 0) return null;\n    return product * reduce!((a, b) => a + b)(arr.map!(abs));\n\
    }", "{\n    if (arr.length == 0) \n    {\n        return null;\n    }\n    long\
    \ sum_mag = 0;\n    int prod_sign = 1;\n    foreach (i; arr) \n    {\n       \
    \ sum_mag += abs(i);\n        prod_sign *= abs(i) / i;\n    }\n    return sum_mag\
    \ * prod_sign;\n}", "{\n    if (arr.length == 0) return null;", "{\n    /*\n \
    \   *\n    * Logic:\n    * Each product of signs is equal to the product of all\
    \ signs.\n    * So we just need to keep track of the sign of each value.\n   \
    \ *\n    */\n    Nullable!(long) answer = Nullable!(long)(0);\n    long prodSigns\
    \ = 1;\n    foreach(element; arr)\n    {\n        if(element == 0)\n        {\n\
    \            answer = Nullable!(long)(-1);\n            break;\n        }\n  \
    \      else\n        {\n            element > 0 ? answer.get!(long) += abs(element)\
    \ : answer.get!(long) -= abs(element);\n            prodSigns *= signbit(element)\
    \ ? -1 : 1;\n        }\n    }\n    if(answer.isSome == true)\n    {\n        answer.get!(long)\
    \ *= prodSigns;\n    }\n    return answer;\n}", "{\n\tif (arr.length == 0)\n\t\
    \treturn Nullable!(long)();\n\t\n\treturn reduce!((a, b) => a * abs(b))(arr) *\
    \ reduce!((a, b) => a * (b > 0 ? 1 : b < 0 ? -1 : 0))(arr);\n}", "{\n    if (arr.length\
    \ == 0) return null;\n    long res = 1, sum = 0;\n    foreach (i; arr) \n    {\n\
    \        if (i > 0) \n        {\n            res *= 1;\n            sum += i;\n\
    \        }\n        else if (i < 0) \n        {\n            res *= -1;\n    \
    \        sum += abs(i);\n        }\n        else \n        {\n            res\
    \ *= 0;\n        }\n    }\n    if (res == 0) return 0;\n    return res * sum;\n\
    }", "{\n    if (arr.length == 0) \n    {\n        return null;\n    }\n    long\
    \ result = 1;\n    foreach (i; arr) \n    {\n        result *= i > 0 ? 1 : (i\
    \ < 0 ? -1 : 0);\n    }\n    return result * arr.map!(abs).sum;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
