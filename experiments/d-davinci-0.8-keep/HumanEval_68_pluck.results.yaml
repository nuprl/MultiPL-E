name: HumanEval_68_pluck
language: d
results:
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    // First find the smallest even number\n    auto res = arr.filter!(a => a\
    \ % 2 == 0).min;\n    // If the smallest number is not even return an empty array\n\
    \    if (res % 2 != 0) \n        return [];\n    // \n    auto pos = arr.indexOf(res);\n\
    \    return [res, pos];\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpt06n3jyl.d(41): Error: no property `filter` for type `long[]`\\\
    n/tmp/tmpt06n3jyl.d(46): Error: no property `indexOf` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt06n3jyl.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    const long min = arr[0];\n\
    \    size_t index = 0;\n    for (auto i = 1; i < arr.length; ++i)\n    {\n   \
    \     if (arr[i] < min)\n        {\n            index = i;\n            break;\n\
    \        }\n    }\n    return [arr[index], index];\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp17yevpwj.d(59): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286bd]\\n??:? void tmp17yevpwj.__unittest_L54_C1()\
    \ [0x428029]\\n??:? void tmp17yevpwj.__modtest() [0x42843c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c71b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430741]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430bf0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306cd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b585]\\n??:? runModuleUnitTests [0x42c4f1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428b80]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b07]\\n??:? _d_run_main [0x428a72]\\n??:? main [0x42844f]\\\
    n??:? __libc_start_main [0x42a5e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \tauto min = findMin(arr);\n\treturn [min, 1];\n}\nlong findMin(long[] arr)\n\
    {\n\tauto min = long.max;\n\tlong ret;\n\tforeach(n; arr)\n\t{\n\t\tif(n < min\
    \ && n % 2 == 0)\n\t\t{\n\t\t\tmin = n;\n\t\t\tret = n;\n\t\t}\n\t}\n\treturn\
    \ ret;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmputzjngvf.d(63): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286dd]\\n??:? void tmputzjngvf.__unittest_L57_C1()\
    \ [0x4280aa]\\n??:? void tmputzjngvf.__modtest() [0x42845c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c6c7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b55a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4306ed]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430b9c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430679]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b531]\\n??:? runModuleUnitTests [0x42c49d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428b2c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428ab3]\\n??:? _d_run_main [0x428a1e]\\n??:? main [0x42846f]\\\
    n??:? __libc_start_main [0xbe6bb554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    // Your code here\n    if(arr.length == 0)\n        return [];\n    long\
    \ min = arr[0];\n    long minIndex = 0;\n    foreach(ref value; arr)\n    {\n\
    \        if(value > 0 && value % 2 == 0)\n        {\n            if(value < min)\n\
    \            {\n                min = value;\n                minIndex = indexOf(arr,\
    \ value);\n            }\n        }\n    }\n    if(min == arr[0])\n        return\
    \ [];\n    else\n        return [min, minIndex];\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8k7o3csv.d(52): Error: undefined identifier `indexOf`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8k7o3csv.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \  import std.algorithm : sort, filter, find;\n  import std.array : array;\n \
    \ import std.range : min, minElement;\n  // Sort array so we can find minElement\n\
    \  arr.sort();\n  // Filter out all values less than 2, then find minElement,\
    \ if empty return [].\n  auto evens = arr.filter!(a => a > 1).minElement!(a =>\
    \ a % 2);\n  return !evens ? [].array() : [evens[0], arr.find(evens[0])];\n}\n\
    unittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L])\
    \ == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5phpoire.d(42): Error: module `std.range` import `min` not found\\\
    n/tmp/tmp5phpoire.d(42): Error: module `std.range` import `minElement` not found\\\
    n/tmp/tmp5phpoire.d(47): Error: template `std.array.array` cannot deduce function\
    \ from argument types `!()(void[])`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/array.d(98):\
    \        `std.array.array(Range)(Range r) if (isIterable!Range && !isNarrowString!Range\
    \ && !isInfinite!Range)`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/array.d(143):\
    \        `std.array.array(Range)(Range r) if (isPointer!Range && isIterable!(PointerTarget!Range)\
    \ && !isNarrowString!Range && !isInfinite!Range)`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/array.d(232):\
    \        `std.array.array(String)(scope String str) if (isNarrowString!String)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5phpoire.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    import std.conv : to;\n    long[] result = new long[2];\n    if (arr.length\
    \ == 0) return [].dup;\n    if (arr.length == 1) return arr.dup;\n    if (arr.length\
    \ == 2)\n    {\n        if (arr[0] < arr[1])\n        {\n            result[0]\
    \ = arr[0];\n            result[1] = 0;\n        }\n        else\n        {\n\
    \            result[0] = arr[1];\n            result[1] = 1;\n        }\n    \
    \    return result;\n    }\n    else\n    {\n        long[] new_arr = [0];\n \
    \       for (int i = 0; i < arr.length; i++)\n        {\n            if (i ==\
    \ 0)\n            {\n                if (arr[i] == 0)\n                {\n   \
    \                 new_arr[0] = arr[i];\n                    new_arr ~= i;\n  \
    \              }\n                else if (arr[i] % 2 == 0)\n                {\n\
    \                    new_arr[0] = arr[i];\n                    new_arr ~= i;\n\
    \                }\n            }\n            else\n            {\n         \
    \       if (arr[i] < new_arr[0])\n                {\n                    if (arr[i]\
    \ == 0)\n                    {\n                        new_arr[0] = arr[i];\n\
    \                        new_arr[1] = i;\n                    }\n            \
    \        else if (arr[i] % 2 == 0)\n                    {\n                  \
    \      new_arr[0] = arr[i];\n                        new_arr[1] = i;\n       \
    \             }\n                }\n            }\n        }\n        return new_arr;\n\
    \    }\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgecggzs3.d(42): Error: cannot implicitly convert expression `dup([])`\
    \ of type `void[]` to `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpgecggzs3.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    long[] ret = new long[2];\nunittest\n{\n    alias candidate = pluck;\n\n\
    \    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3v4acpii.d(41): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3v4acpii.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    int arr_len = arr.length;\n    if (arr_len == 0)\n        return [];\n  \
    \  long[] res = [long.max, 0];\n    for (int i = 0; i < arr_len; i++)\n    {\n\
    \        if (arr[i] % 2 == 0 && arr[i] < res[0])\n        {\n            res[0]\
    \ = arr[i];\n            res[1] = i;\n        }\n    }\n    if (res[0] == long.max)\n\
    \        return [];\n    return res;\n}\n/*\n    Find all possible combinations\
    \ of k numbers that add up to a number n,\n    given that only numbers from 1\
    \ to 9 can be used and each combination should be a unique set of numbers.\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0hfe6j9m.d(56): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0hfe6j9m.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0) return new long[0];\n    long ret = 10001;\n    long\
    \ min = 0;\n    long t;\n    for (long i = 0; i < arr.length; i++)\n    {\n  \
    \      t = arr[i];\n        if (t % 2 == 0 && t < ret)\n        {\n          \
    \  ret = t;\n            min = i;\n        }\n    }\n    if (ret == 10001) return\
    \ new long[0];\n    return new long[]{ret, min};\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjiodfudw.d(54): Error: found `{` when expecting `;` following\
    \ `return` statement\\n/tmp/tmpjiodfudw.d(54): Error: found `}` when expecting\
    \ `;` following statement\\n/tmp/tmpjiodfudw.d(54): Deprecation: use `{ }` for\
    \ an empty statement, not `;`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpjiodfudw.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    auto ret = [1234123123123123123, 1234123123123123123];\n    if (arr.length\
    \ == 0) return ret;\n    auto any = false;\n    for (uint i = 0; i < arr.length;\
    \ i++)\n    {\n        if (arr[i] % 2 == 0)\n        {\n            any = true;\n\
    \            if (arr[i] < ret[0])\n            {\n                ret[0] = arr[i];\n\
    \                ret[1] = i;\n            }\n        }\n    }\n    if (!any) ret[0]\
    \ = ret[1] = 1234123123123123123;\n    return ret;\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp3bvflenu.d(64): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4287e5]\\n??:? void tmp3bvflenu.__unittest_L58_C1()\
    \ [0x4281b2]\\n??:? void tmp3bvflenu.__modtest() [0x428564]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c867]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b6fa]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x43088d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430d3c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430819]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b6d1]\\n??:? runModuleUnitTests [0x42c63d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ca8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428c2f]\\n??:? _d_run_main [0x428b9a]\\n??:? main [0x428577]\\\
    n??:? __libc_start_main [0x6fb4c554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \tif (arr.length == 0)\n\t\treturn new long[0];\n\t\n\tlong minEven = long.max;\n\
    \tlong idx = long.max;\n\t\n\tfor (long i = 0; i < arr.length; i++)\n\t{\n\t\t\
    if (arr[i] % 2 == 0 && arr[i] < minEven)\n\t\t{\n\t\t\tminEven = arr[i];\n\t\t\
    \tidx = i;\n\t\t}\n\t}\n\t\n\treturn new long[] {minEven, idx};\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmhtwvrkb.d(55): Error: found `{` when expecting `;` following\
    \ `return` statement\\n/tmp/tmpmhtwvrkb.d(55): Error: found `}` when expecting\
    \ `;` following statement\\n/tmp/tmpmhtwvrkb.d(55): Deprecation: use `{ }` for\
    \ an empty statement, not `;`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpmhtwvrkb.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0)\n        return [];\n    long[] ret = [min(arr.filter!(a\
    \ => a % 2 == 0)), arr.indexOf(min(arr.filter!(a => a % 2 == 0)))];\n    return\
    \ ret;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzzhsrfkp.d(42): Error: undefined identifier `min`, did you mean\
    \ function `main`?\\n/tmp/tmpzzhsrfkp.d(42): Error: no property `indexOf` for\
    \ type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzzhsrfkp.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    import std.algorithm;\n    import std.range;\n    import std.numeric;\n \
    \   import std.stdio;\n    import std.conv;\n    import std.typecons;\n    import\
    \ std.math;\n    long[] result;\n    if (arr.length == 0)\n    {\n        return\
    \ result;\n    }\n    else\n    {\n        int[] even = arr.filter!(a => a % 2\
    \ == 0).sort.array;\n        int smallest = even[0];\n        writefln(\"smallest:\
    \ %s\", smallest);\n        if (even.length == 0)\n        {\n            return\
    \ result;\n        }\n        else\n        {\n            import std.algorithm;\n\
    \            import std.range;\n            import std.numeric;\n            import\
    \ std.stdio;\n            import std.conv;\n            import std.typecons;\n\
    \            import std.math;\n            auto index = arr.indexOf(smallest);\n\
    \            result ~= smallest;\n            result ~= index;\n            return\
    \ result;\n        }\n    }\n}\nimport std.algorithm;\nimport std.range;\nimport\
    \ std.numeric;\nimport std.stdio;\nimport std.conv;\nimport std.typecons;\nimport\
    \ std.math;\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjavab2qe.d(54): Error: template `std.algorithm.sorting.sort`\
    \ cannot deduce function from argument types `!()(FilterResult!(__lambda2, long[]))`,\
    \ candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/algorithm/sorting.d(1847):\
    \        `std.algorithm.sorting.sort(alias less = \"a < b\", SwapStrategy ss =\
    \ SwapStrategy.unstable, Range)(Range r) if ((ss == SwapStrategy.unstable && (hasSwappableElements!Range\
    \ || hasAssignableElements!Range) || ss != SwapStrategy.unstable && hasAssignableElements!Range)\
    \ && isRandomAccessRange!Range && hasSlicing!Range && hasLength!Range)`\\n/tmp/tmpjavab2qe.d(70):\
    \ Error: no property `indexOf` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpjavab2qe.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    // keep the smallest even value and its corresponding index\n    long smallestEven\
    \ = long.max;\n    long index = -1;\n    long[] result = [0, 0];\nunittest\n{\n\
    \    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n\
    \    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpm4_659lp.d(44): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm4_659lp.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0) return [];\n    auto minEven = (minval(arr.filter!(x\
    \ => x % 2 == 0)));\n    auto index = arr.find(minEven);\n    if (index is size_t.max)\
    \ return [];\n    return [minEven, index];\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjoqhe3f4.d(41): Error: undefined identifier `minval`\\n/tmp/tmpjoqhe3f4.d(42):\
    \ Error: no property `find` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpjoqhe3f4.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \tif (arr.length == 0) return new long[0];\n\tlong[] newArr = arr.filter!(i =>\
    \ i % 2 == 0).array;\n\treturn newArr.length == 0 ? new long[0] : [newArr[0],\
    \ newArr.indexOf(newArr[0])];\n}\nunittest\n{\n    alias candidate = pluck;\n\n\
    \    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpn3zolyv8.d(41): Error: no property `filter` for type `long[]`\\\
    n/tmp/tmpn3zolyv8.d(42): Error: no property `indexOf` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn3zolyv8.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if ( arr.length == 0 ) return [0,0];\n    long[] result = [arr[0],0];\n \
    \   foreach(i,item; arr)\n    {\n        if ( item%2 == 0 && item < result[0]\
    \ ) \n        {\n            result[0] = item;\n            result[1] = i;\n \
    \       }\n    }\n    if ( result[0] == arr[0] ) return [0,0];\n    return result;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp3bf6ajyv.d(58): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42879d]\\n??:? void tmp3bf6ajyv.__unittest_L53_C1()\
    \ [0x428109]\\n??:? void tmp3bf6ajyv.__modtest() [0x42851c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c7fb]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b68e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430821]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430cd0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4307ad]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b665]\\n??:? runModuleUnitTests [0x42c5d1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428c60]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428be7]\\n??:? _d_run_main [0x428b52]\\n??:? main [0x42852f]\\\
    n??:? __libc_start_main [0xcc056554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0) \n        return [];\n    long min = int.max;\n    long\
    \ minIndex = int.max;\n    foreach (index, value; arr)\n    {\n        if (value\
    \ % 2 == 0 && value < min)\n        {\n            min = value;\n            minIndex\
    \ = index;\n        }\n    }\n    if (min == int.max)\n        return [];\n  \
    \  return [min, minIndex];\n}\nunittest\n{\n    alias candidate = pluck;\n\n \
    \   assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0) return new long[0];\n    if (arr.length == 1) return\
    \ arr[0] % 2 == 0 ? new long[] { arr[0], 0 } : new long[0];\n    long min = arr[0]\
    \ % 2 == 0 ? arr[0] : std.numeric.INT_MAX;\n    long idx = -1;\n    foreach (i,\
    \ e; arr)\n    {\n        if (e % 2 == 0 && e < min)\n        {\n            min\
    \ = e;\n            idx = i;\n        }\n    }\n    return idx == -1 ? new long[0]\
    \ : new long[] { min, idx };\n}\nunittest\n{\n    alias candidate = pluck;\n\n\
    \    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpub7zwsv4.d(41): Error: found `{` when expecting `:`\\n/tmp/tmpub7zwsv4.d(41):\
    \ Error: found `}` when expecting `;` following `return` statement\\n/tmp/tmpub7zwsv4.d(41):\
    \ Error: found `:` instead of statement\\n/tmp/tmpub7zwsv4.d(52): Error: found\
    \ `{` when expecting `;` following `return` statement\\n/tmp/tmpub7zwsv4.d(52):\
    \ Error: found `}` when expecting `;` following statement\\n/tmp/tmpub7zwsv4.d(52):\
    \ Deprecation: use `{ }` for an empty statement, not `;`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmpub7zwsv4.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\n\n    The plucked\
    \ node should be returned in a list, [ smalest_value, its index ],\n    If there\
    \ are no even values or the given array is empty, return [].\n\n    Example 1:\n\
    \        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n\n    Example 2:\n     \
    \   Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \n\n    Example 3:\n        Input:\
    \ []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4,\
    \ 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n                     so we will choose the first zero,\
    \ which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[] arr) \n{\n\
    \    if (arr.length == 0) return [];\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6rkqvmz7.d(41): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6rkqvmz7.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
