name: HumanEval_11_string_xor
language: jl
prompt: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform\
  \ binary XOR on these inputs and return result also as a string.\n    >>> string_xor(\"\
  010\", \"110\")\n    \"100\"\n    \"\"\"\nfunction string_xor(a::String, b::String)::String\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"\
  111000\", \"101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\
  \t@test(candidate(\"0101\", \"0000\") == \"0101\")\nend\n"
completions: ["    if(length(a) != length(b))\n        error(\"String length does\
    \ not match\")\n    end\n    res = \"\"\n    for i in 1:length(a)\n        res\
    \ = res * xor(a[i], b[i])\n    end\n    return res\nend", "    c = \"\"\n    for\
    \ (t,s) in zip(a,b)\n        c *= xor(parse(Int,t),parse(Int,s))\n    end\n  \
    \  return c\nend", "    m, n = length(a), length(b)\n    c = Array(Char, max(m,\
    \ n))\n    for i in 1:max(m, n)\n        if i > m\n            c[i] = b[i]\n \
    \       elseif i > n\n            c[i] = a[i]\n        else\n            c[i]\
    \ = ((a[i] == '1') != (b[i] == '1')) ? '1' : '0'\n        end\n    end\n    return\
    \ string(c)\nend", "    c = \"\"\n    for i in aind(a)\n        if a[i] == b[i]\n\
    \            push!(c, \"0\")\n        else\n            push!(c, \"1\")\n    \
    \    end\n    end\n    return c\nend", "    c = \"\"\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            c = c * \"0\"\n        else\n          \
    \  c = c * \"1\"\n        end\n    end\n    return c\nend", "  return join([a[i]\
    \ ^ b[i] for i in 1:min(length(a), length(b))]...)\nend", "    result = \"\"\n\
    \    for i in 1:length(a)\n        a_bit = Int(a[i])\n        b_bit = Int(b[i])\n\
    \        result = result * string(bitxor(a_bit, b_bit))\n    end\n    return result\n\
    end", "    ans = \"\"\n    for i in 1:length(a)\n        if a[i] == b[i]\n   \
    \         ans = ans * \"0\"\n        else\n            ans = ans * \"1\"\n   \
    \     end\n    end\n    return ans\nend", "    c = String(length(a))\n    @inbounds\
    \ for i in 1:length(a)\n        c[i] = xor(a[i], b[i])\n    end\n    return c\n\
    end", "    result = \"\"\n    for (ai, bi) in zip(a, b)\n        if ai == bi\n\
    \            result *= \"0\"\n        else\n            result *= \"1\"\n    \
    \    end\n    end\n    return result\nend", "    n = length(a)\n    xor_output\
    \ = \"\"\n    for i in 1:n\n        if a[i] != b[i]\n            xor_output =\
    \ string(xor_output, \"1\")\n        else\n            xor_output = string(xor_output,\
    \ \"0\")\n        end\n    end\n    return xor_output\nend", "    if length(a)\
    \ != length(b)\n        throw(ArgumentError(\"a and b must be of equal length\"\
    ))\n    end\n    xor_result = \"\"\n    for i = 1:length(a)\n        if a[i] ==\
    \ b[i]\n            xor_result *= \"0\"\n        else\n            xor_result\
    \ *= \"1\"\n        end\n    end\n    return xor_result\nend", "    l = length(a)\n\
    \    xor = \"\"\n    for i = 1:l\n        xor = string(xor, (parse(Int,a[i]) +\
    \ parse(Int,b[i])) % 2)\n    end\n    return xor\nend", "    if a == b\n     \
    \   return \"0\"\n    else\n        return \"1\"\n    end\nend", "    c = String[]\n\
    \    for i in 1:length(a)\n        if a[i] != b[i]\n            push!(c, \"1\"\
    )\n        else\n            push!(c, \"0\")\n        end\n    end\n    return\
    \ join(c)\nend", "    if length(a) != length(b)\n        throw(ArgumentError(\"\
    Lengths of input strings not equal\"))\n    end\n    res = copy(a)\n    for i\
    \ in 1:length(a)\n        if a[i] == b[i]\n            res[i] = \"0\"\n      \
    \  else\n            res[i] = \"1\"\n        end\n    end\n    return res\nend",
  "    s = String[]\n    for i in 1:length(a)\n        if a[i] != b[i]\n         \
    \   push!(s, \"1\")\n        else\n            push!(s, \"0\")\n        end\n\
    \    end\n    return join(s)\nend", "    if length(a) != length(b)\n        error(\"\
    the string must be the same length\")\n    end\n    output = \"\"\n    for i in\
    \ 1:length(a)\n        if a[i] == b[i]\n            output = output * \"0\"\n\
    \        else\n            output = output * \"1\"\n        end\n    end\n   \
    \ return output\nend", "    # Convert strings to integers\n    A = int(a,2)\n\
    \    B = int(b,2)\n    # Compute XOR, convert to string, pad with zeros to len(a)\
    \ if necessary\n    # Return\n    return string(a,\"\\n\",b,\"\\n\",string(Int64(A\
    \ \u22BB B,2),'0',length(a)))\nend", "    return 1 .== a .== b\nend", "    n =\
    \ minimum(length(a), length(b))\n    res = \"\"\n    for i in 1:n\n        res\
    \ *= a[i] == b[i] ? \"0\" : \"1\"\n    end\n    return res\nend", "    a, b =\
    \ convert_to_bitarray(a), convert_to_bitarray(b)\n    l = min(length(a), length(b))\n\
    \    a, b = a[1:l], b[1:l]\n    r = bitarray(l)\n    for i in 1:l\n        r[i]\
    \ = (a[i] != b[i]) ? 1 : 0\n    end\n    r = convert_to_string(r)\n    return\
    \ r\nend", "    result = \"\"\n    for i = 1:length(a)\n        if a[i] == b[i]\n\
    \            result *= \"0\"\n        else\n            result *= \"1\"\n    \
    \    end\n    end\n    return result\nend", "    if length(a) != length(b)\n \
    \       error(\"Strings must be of equal length\")\n    end\n    s = String(length(a))\n\
    \    for i in 1:length(a)\n        s[i] = (a[i] != b[i]) ? '1' : '0'\n    end\n\
    \    return s\nend", "    result = \"\"\n    length = min(length(a), length(b))\n\
    \    for i = 1:length\n        if a[i] == b[i]\n            result *= \"0\"\n\
    \        else\n            result *= \"1\"\n        end\n    end\n    return result\n\
    end", "    x = parse(Int, a, base=2)\n    y = parse(Int, b, base=2)\n    return\
    \ string(convert(UInt8, x \u22BB y), base=2)\nend", "    c = String(length(a))\n\
    \    for i = 1:length(a)\n        if a[i] == b[i]\n            c[i] = \"0\"\n\
    \        else\n            c[i] = \"1\"\n        end\n    end\n    return c\n\
    end", "    c = []\n    for i in 1:length(a)\n        pa = parse(Int, a[i])\n \
    \       pb = parse(Int, b[i])\n        push!(c, pa \u22BB pb)\n    end\n    return\
    \ join(string.(c))\nend", "    if length(a) != length(b)\n        return \"Strings\
    \ are not the same length.\"\n    end\n    result = \"\"\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            result = result * \"0\"\n        else\n\
    \            result = result * \"1\"\n        end\n    end\n    return result\n\
    end", "    l1 = length(a)\n    l2 = length(b)\n    if l1 < l2\n        a = string(\"\
    0\", l2-l1) * a\n    elseif l2 < l1\n        b = string(\"0\", l1-l2) * b\n  \
    \  end\n    c = \"\"\n    for i in 1:length(a)\n        c = string(c, xor(parse(Int,\
    \ a[i]), parse(Int, b[i])))\n    end\n    return c\nend", "    result::String\
    \ = \"\"\n    for i in eachindex(a)\n        if a[i] != b[i]\n            append!(result,\
    \ \"1\")\n        else\n            append!(result, \"0\")\n        end\n    end\n\
    \    return result\nend", "    c=String[]\n    if length(a)>length(b)\n      \
    \ pad=a[1:length(a)-length(b)]\n       b=pad*\"0\"*b\n    elseif length(a)<length(b)\n\
    \       pad=b[1:length(b)-length(a)]\n       a=pad*\"0\"*a\n    end\n    for i=1:length(a)\n\
    \        if a[i]==b[i]\n            push!(c,\"0\")\n        else\n           \
    \ push!(c,\"1\")\n        end\n    end\n    return(join(c))\nend", "    if length(a)\
    \ == length(b)\n        c = []\n        for i in 1:length(a)\n            if a[i]\
    \ == '0' && b[i] == '0'\n                push!(c, '0')\n            elseif a[i]\
    \ == '1' && b[i] == '1'\n                push!(c, '0')\n            else\n   \
    \             push!(c, '1')\n            end\n        end\n        return join(c,\
    \ \"\")\n    else\n        println(\"Binary strings are not of the same length.\"\
    )\n    end\nend", "    assert(length(a) == length(b))\n    a = [int(x) for x in\
    \ a]\n    b = [int(x) for x in b]\n    return string(xor.(a, b))\nend", "    \n\
    \    str = \"\"\n    for i = 1:length(a)\n        if a[i] == '0' && b[i] == '0'\n\
    \            str = str * \"0\"\n        elseif a[i] == '1' && b[i] == '1'\n  \
    \          str = str * \"0\"\n        else\n            str = str * \"1\"\n  \
    \      end\n    end\n    \n    return str\nend", "    if length(a) != length(b)\n\
    \        error(\"Input strings must be of equal length!\")\n    end\n    ret =\
    \ String(\"\")\n    for i in 1:length(a)\n        ret *= Int(a[i] != b[i])\n \
    \   end\n    return ret\nend", "    if length(a) != length(b)\n        throw(ArgumentError(\"\
    inputs must be same length\"))\n    end\n    return join([a[i] != b[i] ? \"1\"\
    \ : \"0\" for i in 1:length(a)])\nend", "    b1 = a .> \"0\"\n    b2 = b .> \"\
    0\"\n    return string(b1 \u22BB b2)\nend", "    result = \"\"\n    if length(a)\
    \ == length(b)\n        for i = 1:length(a)\n            if a[i] == b[i]\n   \
    \             result = result * \"0\"\n            else\n                result\
    \ = result * \"1\"\n            end\n        end\n    end\n    return result\n\
    end", "    res = \"\"\n    for i in 1:length(a)\n        res = res * (string((parse(Int,a[i])\
    \ + parse(Int,b[i])) % 2))\n    end\n    return res\nend", "    x = [parse(Int,\
    \ a[i]) for i = 1:length(a)]\n    y = [parse(Int, b[i]) for i = 1:length(b)]\n\
    \    z = xor(x, y)\n    return join(map(string, z))\nend", "    a = binary_to_decimal(a)\n\
    \    b = binary_to_decimal(b)\n    return decimal_to_binary(bitxor(a, b))\nend",
  "    out = \"\"\n    for i = 1:min(length(a), length(b))\n        if a[i] == b[i]\n\
    \            out *= \"0\"\n        else\n            out *= \"1\"\n        end\n\
    \    end\n    return out\nend", "    if length(a) == length(b)\n        res =\
    \ \"\"\n        for i in 1:length(a)\n            res *= xor(parse(Int, a[i]),\
    \ parse(Int, b[i]))\n        end\n        return res\n    else\n        error(\"\
    Input strings are not of the same length\")\n    end\nend", "    result = \"\"\
    \n    for i in 1:length(a)\n        if a[i] == b[i]\n            result *= \"\
    0\"\n        else\n            result *= \"1\"\n        end\n    end\n    return\
    \ result\nend", "    assert(length(a) == length(b))\n    (l, result) = (length(a),\
    \ \"\")\n    for i = 1:l\n        a_i = Int(a[i])\n        b_i = Int(b[i])\n \
    \       result *= string(Int(a_i != b_i))\n    end\n    return result\nend\n \
    \       \n@assert string_xor(\"0101\", \"0101\") == \"0000\"\n@assert string_xor(\"\
    0101\", \"0000\") == \"0101\"\n@assert string_xor(\"0101\", \"1111\") == \"1010\"\
    \n@assert string_xor(\"0101\", \"1010\") == \"1111\"\n@assert string_xor(\"0101\"\
    , \"0110\") == \"0011\"", "    c = \"\"\n    for i in 1:length(a)\n        x =\
    \ parse(Int, a[i])\n        y = parse(Int, b[i])\n        z = xor(x, y)\n    \
    \    append!(c, z)\n    end\n    return c\nend", "    c = String[]\n    for (i,\
    \ j) in zip(a, b)\n        append!(c, xor(i, j))\n    end\n    return join(c)\n\
    end", "    xored = \"\"\n    for i in 1:length(a)\n        # XOR bit by bit\n\
    \        xored = xored * string(xor(parse(Int,a[i]), parse(Int,b[i])))\n    end\n\
    \    return xored\nend", "    if length(a) != length(b)\n        throw(ArgumentError(\"\
    a and b must be the same length.\"))\n    end\n    return [a[i] == b[i] ? \"0\"\
    \ : \"1\" for i in 1:length(a)]\nend", "    if length(a) != length(b)\n      \
    \  error(\"Strings are not of equal length\")\n    end\n    string_result = String(length(a))\
    \ # a bit hacky ...\n    for i = 1:length(a)\n        if a[i] == b[i]\n      \
    \      string_result[i] = \"0\"\n        else\n            string_result[i] =\
    \ \"1\"\n        end\n    end\n    return string_result\nend", "    if length(a)\
    \ > length(b)\n        b = string(\"0\", b)\n    elseif length(a) < length(b)\n\
    \        a = string(\"0\", a)\n    end\n    r = String[]\n    for i in 1:length(a)\n\
    \        push!(r, xor(parse(Int, a[i]), parse(Int, b[i])))\n    end\n    join(map(string,\
    \ r))\nend\n#\n# # TODO: make these tests pass\n# using Test\n# @test string_xor(\"\
    010\", \"110\") == \"100\"\n# @test string_xor(\"011\", \"100\") == \"111\"\n\
    #\n\"\"\" Now we have a function that combines two bit strings with XOR.\n   \
    \ Write a function that XORs a number of strings together.\n    >>> xor_n([\"\
    101\", \"010\", \"011\"])\n    \"000\"\n    \"\"\"", "    if length(a) != length(b)\n\
    \        error(\"string_xor(): input strings are not of equal length\")\n    end\n\
    \    out = String(length(a))\n    for (i,x) in enumerate(a)\n        if x != b[i]\n\
    \            out[i] = '1'\n        else\n            out[i] = '0'\n        end\n\
    \    end\n    return out\nend", "    c = zeros(length(a))\n    for i = 1:length(a)\n\
    \        if a[i] == b[i]\n            c[i] = \"0\"\n        else\n           \
    \ c[i] = \"1\"\n        end\n    end\n    return join(c, \"\")\nend", "    len_a\
    \ = length(a)\n    len_b = length(b)\n    if len_a != len_b\n        throw(ArgumentError(\"\
    string_xor(): inputs must be the same length\"))\n    end\n    c = String(undef,\
    \ len_a)\n    for i in 1:len_a\n        c[i] = '0'\n        if a[i] != b[i]\n\
    \            c[i] = '1'\n        end\n    end\n    return c\nend", "    l = length(a)\n\
    \    z = zeros(Int, l)\n    @simd for i in 1:l\n        if a[i] == b[i]\n    \
    \        z[i] = 0\n        else\n            z[i] = 1\n        end\n    end\n\
    \    return join(z, \"\")\nend", "    \"\"\" Input are two strings a and b consisting\
    \ only of 1s and 0s.\n    Perform binary XOR on these inputs and return result\
    \ also as a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \"\
    \"\"\n    result = \"\"\n    for i in 1:length(a)\n        if a[i] == b[i]\n \
    \           result = result * \"0\"\n        else\n            result = result\
    \ * \"1\"\n        end\n    end\n    return result\nend", "    c = \"\"\n    @assert\
    \ length(a) == length(b) \"Error: input strings must be of equal length.\"\n \
    \   for i = 1:length(a)\n        a_i = parse(Int, a[i])\n        b_i = parse(Int,\
    \ b[i])\n        c = c * string(xor(a_i, b_i))\n    end\n    return c\nend", " \
    \   c = String[]\n    for i in 1:length(a)\n        push!(c, xor(a[i], b[i]))\n\
    \    end\n    return join(c)\nend", "    c = \"\"\n    for i in eachindex(a)\n\
    \        if a[i] == b[i]\n            push!(c, \"0\")\n        else\n        \
    \    push!(c, \"1\")\n        end\n    end\n    return c\nend", "    c = String[]\n\
    \    for (i, j) in zip(a, b)\n        push!(c, i \u22BB j)\n    end\n    return\
    \ join(c)\nend", "    result = \"\"\n    if length(a) != length(b)\n        throw(DomainError(\"\
    StringXOR: string lengths must be equal!\"))\n    end\n    for i = 1:length(a)\n\
    \        if a[i] == b[i]\n            result *= \"0\"\n        else\n        \
    \    result *= \"1\"\n        end\n    end\n    return result\nend", "    assert(length(a)\
    \ == length(b))\n    c = []\n    for i in 1:length(a)\n        if a[i] == '0'\n\
    \            if b[i] == '0'\n                push!(c, '0')\n            else\n\
    \                push!(c, '1')\n            end\n        else\n            if\
    \ b[i] == '0'\n                push!(c, '1')\n            else\n             \
    \   push!(c, '0')\n            end\n        end\n    end\n    return join(c)\n\
    end", "    result = \"\"\n    for i in 1:length(a)\n        result = string(parse(Int,\
    \ result), xor(parse(Int, a[i]), parse(Int, b[i])))\n    end\n    return result\n\
    end", "    aa = convert(Array{Int},a)\n    bb = convert(Array{Int},b)\n    if(length(aa)\
    \ > length(bb))\n        bb = vcat(bb, zeros(length(aa)-length(bb)))\n    elseif(length(aa)\
    \ < length(bb))\n        aa = vcat(aa, zeros(length(bb)-length(aa)))\n    end\n\
    \    return join(map(xor, aa, bb))\nend", "    a_b_pairs = collect(zip(a, b))\n\
    \    return join([xor(a, b) for (a, b) in a_b_pairs])\nend", "    @assert length(a)\
    \ == length(b)\n    out = \"\"\n    for i in 1:length(a)\n        if a[i] == b[i]\n\
    \            out = out * \"0\"\n        else\n            out = out * \"1\"\n\
    \        end\n    end\n    return out\nend", "    \"\"\"\n    >>> string_xor(\"\
    010\", \"110\")\n    \"100\"\n    \"\"\"\n    as_bytes = map(byte, a)\n    bs_bytes\
    \ = map(byte, b)\n    xord_bytes = map(xor, as_bytes, bs_bytes)\n    return string(xord_bytes)\n\
    end", "    result = \"\"\n    for (a_ch, b_ch) in zip(a, b)\n        result *=\
    \ string_xor(a_ch, b_ch)\n    end\n    return result\nend", "    if length(a)\
    \ != length(b)\n        throw(ArgumentError(\"Length of the two strings must be\
    \ equal\"))\n    end\n    n = length(a)\n    c = String(\" \"^n)\n    for i in\
    \ 1:n\n        c[i] = xor(Int(a[i]), Int(b[i]))\n    end\n    return c\nend",
  "    result = \"\"\n    for i in range(1, min(length(a), length(b)) + 1)\n     \
    \   result *= a[i] != b[i] ? \"1\" : \"0\"\n    end\n    return result\nend",
  "    c = \"\"\n    for i = 1:length(a)\n        if a[i] == b[i]\n            c =\
    \ c * \"0\"\n        else\n            c = c * \"1\"\n        end\n    end\n \
    \   return c\nend", "    if length(a) != length(b)\n        error(\"String length\
    \ not equal\")\n    end\n    result = Vector{Char}(undef, length(a))\n    for\
    \ i in 1:length(a)\n        if a[i] == b[i]\n            result[i] = '0'\n   \
    \     else\n            result[i] = '1'\n        end\n    end\n    return join(result)\n\
    end", "    lena = length(a)\n    lenb = length(b)\n    if lena > lenb\n      \
    \  b = \"0\"^(lena-lenb) * b\n    elseif lenb > lena\n        a = \"0\"^(lenb-lena)\
    \ * a\n    end\n    r = \"\"\n    for i in 1:length(a)\n        if a[i] == b[i]\n\
    \            r = r * \"0\"\n        else\n            r = r * \"1\"\n        end\n\
    \    end\n    return r\nend", "    a = string(a)\n    b = string(b)\n    x = []\n\
    \    for i in 1:length(a)\n        if a[i] == \"1\" && b[i] == \"1\"\n       \
    \     push!(x, \"0\")\n        elseif a[i] == \"0\" && b[i] == \"0\"\n       \
    \     push!(x, \"0\")\n        elseif a[i] == \"1\" && b[i] == \"0\"\n       \
    \     push!(x, \"1\")\n        else\n            push!(x, \"1\")\n        end\n\
    \    end\n    return join(x)\nend", "    if length(a) > length(b)\n        b =\
    \ string(zeros(Bool, length(a) - length(b))) * b\n    elseif length(a) < length(b)\n\
    \        a = string(zeros(Bool, length(b) - length(a))) * a\n    end\n    return(string(Int.(a)\
    \ .^ Int.(b)))\nend", "    l = length(a)\n    res = \"\"\n    for i = 1:l\n  \
    \      res *= (a[i] == b[i] ? \"0\" : \"1\")\n    end\n    return res\nend", " \
    \   if length(a) != length(b)\n        throw(ArgumentError(\"String lengths are\
    \ not equal\"))\n    end\n    r = \"\"\n    for i in 1:length(a)\n        a_i\
    \ = parse(Int, a[i])\n        b_i = parse(Int, b[i])\n        r = r * string(a_i\
    \ \u22BB b_i)\n    end\n    return r\nend", "    r = \"\"\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            r = r * \"0\"\n        else\n          \
    \  r = r * \"1\"\n        end\n    end\n    return r\nend", "    s = \"\"\n  \
    \  for i in 1:length(a)\n        if a[i] != b[i]\n            s = s * \"1\"\n\
    \        else\n            s = s * \"0\"\n        end\n    end\n    return s\n\
    end", "    xor = zip(str2bits(a), str2bits(b))\n    xor = map(xor, (x,y) -> xor(x,y))\n\
    \    return join(bits2str(xor))\nend", "    m, n = length(a), length(b)\n    if\
    \ m < n \n        a = \"0\" * (n - m) * a\n    elseif n < m\n        b = \"0\"\
    \ * (m - n) * b\n    end\n    res = \"\"\n    for i in 1:length(a)\n        res\
    \ *= (a[i] ^ b[i])\n    end\n    return res\nend", "    c = \"\"\n    for i in\
    \ 1:length(a)\n        c = c * string(parse(Int,a[i]) \u22BB parse(Int,b[i]))\n\
    \    end\n    return c\nend", "    result = \"\";\n    for i in collect(1:length(a))\n\
    \        if a[i] == b[i]\n            result = result * \"0\"\n        else\n\
    \            result = result * \"1\"\n        end\n    end\n    return result\n\
    end", "    n = length(a)\n    out = String(n)\n    for i in 1:n\n        if a[i]\
    \ == b[i]\n            out[i] = \"0\"\n        else\n            out[i] = \"1\"\
    \n        end\n    end\n    return out\nend", "    res = \"\"\n    for i in 1:length(a)\n\
    \        res *= xor(Int(a[i]), Int(b[i]))\n    end\n    return res\nend\n    ",
  "    binary_a = parse(Int, a, base=2)\n    binary_b = parse(Int, b, base=2)\n  \
    \  xor_result = xor(binary_a, binary_b)\n    binary_result = string(xor_result,\
    \ base=2)\n    return binary_result\nend", "    # Type assert\n    @assert length(a)\
    \ == length(b)", "    if length(a) != length(b)\n        error(\"Both strings\
    \ must be the same length.\")\n    end\n    result = \"\"\n    for i = 1:length(a)\n\
    \        if a[i] == b[i]\n            push!(result, \"0\")\n        else\n   \
    \         push!(result, \"1\")\n        end\n    end\n    return result\nend",
  "    if length(a) != length(b)\n        throw(ArgumentError(\"Inputs should be of\
    \ same length\"))\n    end\n    result = \"\"\n    for i = 1:length(a)\n     \
    \   if(a[i] == b[i])\n            result = result * \"0\"\n        else\n    \
    \        result = result * \"1\"\n        end\n    end\n    return result\nend",
  "    if length(a) != length(b)\n        error(\"Input strings must be of the same\
    \ length\")\n    end\n    result = \"\"\n    for i = 1:length(a)\n        if a[i]\
    \ == b[i]\n            push!(result, \"0\")\n        else\n            push!(result,\
    \ \"1\")\n        end\n    end\n    return result\nend", "    res = \"\"\n   \
    \ for i in 1:length(a)\n        res *= sum([parse(Int, a[i]), parse(Int, b[i])])\
    \ % 2\n    end\n    return res\nend", "    c = \"\"\n    for i in range(1, length(a))\n\
    \        if a[i] != b[i]\n            c = c * \"1\"\n        else\n          \
    \  c = c * \"0\"\n        end\n    end\n    return c\nend", "    c = String(eltype(a))\n\
    \    for (i, j) in zip(a, b)\n        push!(c, xor(i, j))\n    end\n    return\
    \ c\nend\n \nc1 = string_xor(ciphertext, \"0000\")", "    if length(a) != length(b)\n\
    \        println(\"Arguments should be of the same length. Returning first argument.\"\
    )\n        return a\n    end\n    c = \"\"\n    for i in 1:length(a)\n       \
    \ push!(c, xor(parse(Int, a[i]), parse(Int, b[i])))\n    end\n    return join(c)\n\
    end", "    n = max(length(a), length(b))\n    a = \"0\"*(n-length(a))*a\n    b\
    \ = \"0\"*(n-length(b))*b\n    return join([ a[i] \u2260 b[i] ? \"1\" : \"0\"\
    \ for i in 1:n])\nend", "    c = \"\"\n    for i in 1:length(a)\n        c = c\
    \ * XOR(a[i], b[i])\n    end\n    return c\nend", "    if length(a) != length(b)\n\
    \        error(\"Length of both strings must be the same.\")\n    end\n    output\
    \ = repeat('0', length(a))\n    for i in 1:length(a)\n        if a[i] == b[i]\n\
    \            output[i] = '0'\n        else\n            output[i] = '1'\n    \
    \    end\n    end\n    return output\nend", "    a_bin = parse(Int, a, base=2)\n\
    \    b_bin = parse(Int, b, base=2)\n    # print(a_bin)\n    # print(b_bin)\n \
    \   x = bitxor(a_bin, b_bin)\n    return dec2bin(x)\nend", "    bits = []\n  \
    \  for i in zip(a, b)\n        push!(bits, xor(Char(i[1]), Char(i[2])))\n    end\n\
    \    return reduce(*, bits)\nend", "    a = parse(Int, a, base=2)\n    b = parse(Int,\
    \ b, base=2)\n    c = xor(a, b)\n    c = bin(c, prefix=\"\")\n    c = replace(c,\
    \ \"0b\", \"\")\n    return c\nend", "    c = \"\"\n    for i in 1:length(a)\n\
    \        c = c * string( int(a[i]) \u22BB int(b[i]) )\n    end\n    return c\n\
    end", "    if length(a) != length(b)\n        throw(DimensionMismatch(\"Binary\
    \ strings must be same length.\"))\n    end\n    c = copy(a)\n    for i = 1:length(a)\n\
    \        c[i] = xor(a[i], b[i])\n    end\n    return c\nend", "    assert(length(a)\
    \ == length(b))\n    r = \"\"\n    for i in 1:length(a)\n        if a[i] == b[i]\n\
    \            r = r * \"0\"\n        else\n            r = r * \"1\"\n        end\n\
    \    end\n    return r\nend\n\"\"\" Input are two strings a and b consisting only\
    \ of 1s and 0s.\n    Perform modulo addition (XOR) on these inputs and return\
    \ result also as a string.\n    >>> string_add(\"010\", \"110\")\n    \"100\"\n\
    \    \"\"\"", "    c = \"\"\n    for i in zip(a, b)\n        push!(c, \"1\"^i[1]^i[2])\n\
    \    end\n    return c\nend", "    if length(a) != length(b)\n        error(\"\
    The two strings must have the same length.\")\n    end\n    result = \"\"\n  \
    \  for i in 1:length(a)\n        result *= string(Int(a[i]) != Int(b[i]))\n  \
    \  end\n    return result\nend", "    # c will be the result of the XOR\n    c\
    \ = String(a)\n    # check that the strings have the same length\n    if length(a)\
    \ != length(b)\n        error(\"Inputs must have the same length!\")\n    end\n\
    \    # compute the XOR for each digit in the string\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            c[i] = \"0\"\n        else\n           \
    \ c[i] = \"1\"\n        end\n    end\n    return c\nend", "    if length(a) !=\
    \ length(b)\n        error(\"Input strings need to be of equal length\")\n   \
    \ end\n    n = length(a)\n    result = \"\";\n    for i in 1:n\n        if a[i]\
    \ == '0'\n            if b[i] == '0'\n                result = result * \"0\"\n\
    \            elseif b[i] == '1'\n                result = result * \"1\"\n   \
    \         else\n                error(\"Input strings contain illegal characters\"\
    )\n            end\n        elseif a[i] == '1'\n            if b[i] == '0'\n \
    \               result = result * \"1\"\n            elseif b[i] == '1'\n    \
    \            result = result * \"0\"\n            else\n                error(\"\
    Input strings contain illegal characters\")\n            end\n        else\n \
    \           error(\"Input strings contain illegal characters\")\n        end\n\
    \    end\n    return result\nend", "    n = length(a)\n    ret = \"\"\n    for\
    \ i in range(n):\n        if a[i] != b[i]:\n            ret = ret * \"1\"\n  \
    \      else:\n            ret = ret * \"0\"\n    return ret\nend", "    if length(a)\
    \ != length(b)\n        return false\n    end\n    c = 0\n    for i in 1:length(a)\n\
    \        c += parse(Int,a[i])*(1-2*parse(Int,b[i]))\n    end\n    return \"1\"\
    *(c>0)\nend", "    if length(a) != length(b)\n        println(\"Error: lengths\
    \ do not match\")\n        return \"\"\n    end\n    result = \"\"\n    for i\
    \ in 1:length(a)\n        if a[i] == b[i]\n            result = result * \"0\"\
    \n        else\n            result = result * \"1\"\n        end\n    end\n  \
    \  return result\nend", "    # Your code here\nend", "    N = length(a)\n    assert(N\
    \ == length(b))\n    c = String(\"\")\n    for i = 1:N\n        c = string(c,\
    \ xor(parse(Int, a[i]), parse(Int, b[i])))\n    end\n    return c\nend", "   \
    \ c = \"\"\n    for k = 1:length(a)\n        if(a[k] == b[k])\n            c =\
    \ c * \"0\"\n        else\n            c = c * \"1\"\n        end\n    end\n \
    \   return c\nend", "    result = \"\"\n    for i in range(length(a))\n      \
    \  achar = a[i]\n        bchar = b[i]\n        if achar == bchar\n           \
    \ result *= \"0\"\n        else\n            result *= \"1\"\n        end\n  \
    \  end\n    return result\nend", "    tmp = \"\"\n    for i in 1:length(a)\n \
    \       x = parse(Int, a[i])\n        y = parse(Int, b[i])\n        tmp = tmp\
    \ * string(bitxor(x, y))\n    end\n    return tmp\nend", "    aa = [parse(Int,\
    \ x) for x in a]\n    bb = [parse(Int, x) for x in b]\n    return \"\".join([string(1-integer(int_xor(aa[i],\
    \ bb[i]))) for i in 1:length(aa)])\nend", "    c = \"\"\n    for i in eachindex(a)\n\
    \        c *= xor(a[i], b[i])\n    end\n    return c\nend", "    \"\"\" The strings\
    \ should be of the same length, or else error is thrown. \"\"\"\n    if length(a)\
    \ != length(b)\n        error(\"The input strings should be of the same length.\"\
    )\n    end\n    \"\"\" Convert both strings to bitarrays. \"\"\"\n    bitarray_a\
    \ = bitarray(a)\n    bitarray_b = bitarray(b)\n    \"\"\" Apply XOR and convert\
    \ back to string. \"\"\"\n    bitarray_xor = bitarray_a .^ bitarray_b\n    xor_string\
    \ = string(bitarray_xor)\n    return xor_string\nend", "    ch = \"\"\n    for\
    \ i in 1:length(a)\n        if (a[i] == '0' && b[i] == '0') || (a[i] == '1' &&\
    \ b[i] == '1')\n            ch = ch * \"0\"\n        else\n            ch = ch\
    \ * \"1\"\n        end\n    end\n    return ch\nend", "    return string(Int.(a.=='1')\
    \ .\u22BB Int.(b.=='1'))\nend", "    if length(a) != length(b)\n        throw(ArgumentError(\"\
    Length of inputs must be the same.\"))\n    end\n    c = \"\"\n    for i = 1:length(a)\n\
    \        if a[i] == b[i]\n            c *= \"0\"\n        else\n            c\
    \ *= \"1\"\n        end\n    end\n    return c\nend", "    c = zero(Bool)\n  \
    \  for i in range(1,length(a))\n        c = c \u22BB (a[i]=='1') \u22BB (b[i]=='1')\n\
    \        push!(a, c ? '1' : '0')\n    end\n    return a\nend", "    # If the two\
    \ strings are not of the same length, \n    # raise an exception\n    if length(a)\
    \ != length(b)\n        throw(ArgumentError(\"The strings are not of equal length.\"\
    ))\n    end\n    \n    # Convert the two strings to vectors of bits\n    a_bits\
    \ = string_to_bits(a)\n    b_bits = string_to_bits(b)\n    \n    # Compute the\
    \ XOR between the two inputs\n    xor_result = xor_bits(a_bits, b_bits)\n    \n\
    \    # Convert the vector of bits to a string and return it\n    return bits_to_string(xor_result)\n\
    end", "    result = \"\"\n    for i in 1:length(a)\n        if a[i] == b[i]\n\
    \            result *= \"0\"\n        else\n            result *= \"1\"\n    \
    \    end\n    end\n    return result\nend", "    result = \"\"\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            result *= \"0\"\n        else\n        \
    \    result *= \"1\"\n        end\n    end\n    return result\nend", "    # todo\n\
    \    return \"\"\nend", "    c = \"\"\n    for i in 1:length(a)\n        c *=\
    \ ((parse(Int, a[i]) + parse(Int, b[i])) % 2)\n    end\n    return c\nend", " \
    \   \n    if (length(a) != length(b))\n        error(\"Input strings must be of\
    \ the same length.\")\n    end\n    a = convert(Int,a)\n    b = convert(Int,b)\n\
    \    s = []\n    for i in 1:length(a)\n        push!(s, mod(a[i] + b[i], 2))\n\
    \    end\n    s = convert(String, s)\n    return s\nend", "    res = string(length(a))\n\
    \    for i in 1:length(a)\n        res[i] = XOR(a[i], b[i])\n    end\n    return\
    \ res\nend", "    #find min length between string a and b\n    if length(a) <\
    \ length(b)\n        short = a\n        long = b\n    else\n        short = b\n\
    \        long = a\n    end\n    #create the output string\n    output = \"\"\n\
    \    #iterate over short string\n    for i in 1:length(short)\n        #xor the\
    \ numbers in a and b\n        if short[i] == long[i]\n            output = output\
    \ * \"0\"\n        else\n            output = output * \"1\"\n        end\n  \
    \  end\n    #add the rest of the long string\n    output = output * long[length(short)+1:end]\n\
    \    return output\nend\n# Problem 3\n\"\"\" Input is a string of 1s and 0s.\n\
    \    Return the hamming weight, i.e. the number of 1s, in the string.\n    >>>\
    \ hamming_weight(\"10010011\")\n    5\n    \"\"\"", "    a = parse(Int, a, base=2)\n\
    \    b = parse(Int, b, base=2)\n    c = a\u22BBb\n    return string(c, base=2)\n\
    end", "    #convert both strings to arrays of integers\n    A = str2array(a)\n\
    \    B = str2array(b)\n    #XOR A and B\n    C = xor(A,B)\n    return array2str(C)\n\
    end", "    if length(a) != length(b)\n        throw(ArgumentError(\"Arguments\
    \ must be of the same length\"))\n    end\n    c = String[]\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            push!(c, \"0\")\n        else\n        \
    \    push!(c, \"1\")\n        end\n    end\n    join(c)\nend", "    if length(a)\
    \ != length(b)\n        error(\"length of inputs must be equal\")\n    end\n \
    \   c = []\n    for i in 1:length(a)\n        c = append!(c, xor(parse(Int, a[i]),\
    \ parse(Int, b[i])))\n    end\n    string(c)\nend", "    result = String(a)\n\
    \    for i in 1:length(a)\n        result[i] = a[i] ^ b[i]\n    end\n    return\
    \ result\nend\nstring_xor(\"010\", \"110\")", "    c = \"\"\n    for i = 1:length(a)\n\
    \        if (a[i] == b[i])\n            c = c * \"0\"\n        else\n        \
    \    c = c * \"1\"\n        end\n    end\n    return c\nend", "    s = \"\"\n\
    \    for i in 1:length(a)\n        if (a[i] == '0' && b[i] == '0') || (a[i] ==\
    \ '1' && b[i] == '1')\n            s = s * \"0\"\n        else\n            s\
    \ = s * \"1\"\n        end\n    end\n    return s\nend", "    c = String[]\n \
    \   for (x, y) in zip(a, b)\n        push!(c, string(int(x) \u22BB int(y)))\n\
    \    end\n    return join(c, \"\")\nend", "    \"\"\" Performs XOR on two strings.\n\
    \        >>> string_xor(\"10010011\", \"0101\")\n        \"10010110\"\n      \
    \  \"\"\"\n    return string(z for (x, y, z) in zip(a, b, ' ' * max(length(a),\
    \ length(b))) if x \u2260 y)\nend ", "    z = \"\"\n    for i = 1:length(a)\n\
    \        if a[i] == b[i]\n            z = z * \"0\"\n        else\n          \
    \  z = z * \"1\"\n        end\n    end\n    return z\nend", "    c = \"\"\n  \
    \  for i = 1:length(a)\n        c = c * (a[i]==b[i] ? \"0\" : \"1\")\n    end\n\
    \    return c\nend", "    \"your code goes here\"\nend\n \n\"\"\" Input is a string\
    \ a consisting only of 1s and 0s.\n    Flip all the bits in a and return result\
    \ also as a string.\n    >>> flip_all_bits(\"101\")\n    \"010\"\n    \"\"\"",
  "    c = Array{UInt8}(length(a))\n    for i = 1:length(a)\n        c[i] = convert(UInt8,\
    \ parse(Int, a[i]) \u22BB parse(Int, b[i]))\n    end\n    return string(c)\nend\n\
    \ \nstring_xor(\"010\", \"110\")", "    c = \"\"\n    for (ai, bi) in zip(a, b)\n\
    \        if ai == bi\n            c = c * \"0\"\n        else\n            c =\
    \ c * \"1\"\n        end\n    end\n    return c\nend", "    L = length(a)\n  \
    \  c = \"\"\n    for i = 1:L\n        if a[i] == b[i]\n            append!(c,\
    \ \"0\")\n        else\n            append!(c, \"1\")\n        end\n    end\n\
    \    return c\nend", "    c = Array{Int}(length(a))\n    for i = 1:length(a)\n\
    \        c[i] = bitxor(Int(a[i]), Int(b[i]))\n    end\n    return join(c, \"\"\
    )\nend", "    \"\"\" 2.1.1.1 \"\"\"\n    # Error checking:\n    if length(a) !=\
    \ length(b)\n        println(\"Strings should be the same length\")\n        return\
    \ \"\"\n    end\n    # Convert strings to unsigned integers:\n    a_int = UInt(parse(Int,\
    \ a, base=2))\n    b_int = UInt(parse(Int, b, base=2))\n    # Binary XOR:\n  \
    \  a_xor_b = bitxor(a_int, b_int)\n    # Convert back to string:\n    return string(a_xor_b,\
    \ base=2)\nend", "    x, y = 0, 0\n    for i in a\n        x = 2*x + parse(Int,\
    \ i)\n    end\n    for i in b\n        y = 2*y + parse(Int, i)\n    end\n    return\
    \ dec2bin(xor(x, y))\nend", "    out = \"\"\n    for i in 1:length(a)\n      \
    \  if a[i] == b[i]\n            out = out * \"0\"\n        else\n            out\
    \ = out * \"1\"\n        end\n    end\n    return out\nend", "    c = \"\"\n \
    \   for i in 1:length(a)\n        if a[i] == b[i]\n            c = c * \"0\"\n\
    \        else\n            c = c * \"1\"\n        end\n    end\n    return c\n\
    end", "    \"\"\"\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \"\"\
    \"\n    if length(a) != length(b)\n        error(\"string_xor: invalid input length.\"\
    )\n    end\n    n = length(a)\n    result = \"\"\n    for i in 1:n\n        result\
    \ = result * Int(xor(parse(Char, a[i]), parse(Char, b[i])))\n    end\n    return\
    \ result\nend", "    \"\"\"\n    v = Vector{Int64}(a)\n    y = Vector{Int64}(b)\n\
    \    x = v .^ y\n    return join(x, \"\")\n    \"\"\"\n    return join(parse.(Int,\
    \ (a .== b)).*2 .- 1, \"\")\n    # return join(map(parse, (a .== b)).*2 .- 1,\
    \ \"\")\nend", "    n = length(a)\n    a = Bits(a)\n    b = Bits(b)\n    result\
    \ = 0\n    for i = 0:n-1\n        if (a[i]==1 && b[i]==0) || (a[i]==0 && b[i]==1)\n\
    \            result += 2^(n-i-1)\n        end\n    end\n    return Int(result)\n\
    end\n ", "    # convert binary strings to array of integers (e.g. \"101\" -> [1,\
    \ 0, 1])\n    a_int = int(a, base=2)\n    b_int = int(b, base=2)\n    xor_int\
    \ = bitxor(a_int, b_int)\n    # convert back to binary string\n    return \"{0:b}\"\
    .format(xor_int)\nend\n\"\"\"", "    output = \"\"\n    for i in 1:length(a)\n\
    \        if (a[i] == b[i])\n            output = output * \"0\"\n        else\n\
    \            output = output * \"1\"\n        end\n    end\n    return output\n\
    end", "    a = Int(a, base=2)\n    b = Int(b, base=2)\n    c = a \u22BB b\n  \
    \  return string(Base.digits(c, 2))\nend\n \n \n ", "    c = \"\"\n    for i in\
    \ eachindex(a)\n        if a[i] == b[i]\n            push!(c, \"0\")\n       \
    \ else\n            push!(c, \"1\")\n        end\n    end\n    return c\nend",
  "    # make sure that the two input strings are the same length\n    maxlen = max(length(a),\
    \ length(b))\n    a = string(zeros(Int8, maxlen - length(a))) * a\n    b = string(zeros(Int8,\
    \ maxlen - length(b))) * b\n    new_string = \"\"\n    for i in range(1, maxlen\
    \ + 1)\n        if(a[i] == b[i])\n            new_string = new_string * \"0\"\n\
    \        else\n            new_string = new_string * \"1\"\n        end\n    end\n\
    \    return new_string\nend", "    return join([a[i] == b[i] ? \"0\" : \"1\" for\
    \ i in eachindex(a)])\nend", "    c = \"\"\n    for i in 1:length(a)\n       \
    \ c = c * string(int(a[i]) \u22BB int(b[i]))\n    end\n    return c\nend\n   \
    \ \n\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform\
    \ binary AND on these inputs and return result also as a string.\n    >>> string_and(\"\
    011\", \"101\")\n    \"001\"\n    \"\"\"", "    \"\"\" Input are two strings a\
    \ and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs\
    \ and return result also as a string.\n    >>> string_xor(\"010\", \"110\")\n\
    \    \"100\"\n    \"\"\"\n    xor_val = zeros(Int8, length(a))\n    for i = 1:length(a)\n\
    \        if a[i] == '1' && b[i] == '0' || a[i] == '0' && b[i] == '1'\n       \
    \     xor_val[i] = 1\n        end\n    end\n    return string(xor_val)\nend",
  "    if length(a) != length(b)\n        error(\"Input strings must be of equal length.\"\
    )\n    end\n    return [a[i] == b[i] ? \"0\" : \"1\" for i in 1:length(a)] |>\
    \ join\nend", "    n = length(a)\n    @assert n == length(b)\n    result = \"\"\
    \n    for i in 1:n\n        if a[i] == b[i]\n            result *= \"0\"\n   \
    \     else\n            result *= \"1\"\n        end\n    end\n    return result\n\
    end", "    pass\nend", "    al = length(a)\n    bl = length(b)\n    ml = max(al,\
    \ bl)\n    res = \"\"\n    for i in 1:ml\n        c = todigit(a[i])\n        d\
    \ = todigit(b[i])\n        if isempty(c)\n            c = 0\n        end\n   \
    \     if isempty(d)\n            d = 0\n        end\n        if c == d\n     \
    \       res = res * \"0\"\n        else\n            res = res * \"1\"\n     \
    \   end\n    end\n    return res\nend", "    if a == b\n        return \"0\" *\
    \ length(a)\n    elseif length(a) == length(b)\n        res = String(\"0\") *\
    \ length(a)\n        for i = 1:length(a)\n            res[i] = \"0\" + a[i] *\
    \ b[i]\n        end\n        return res\n    else\n        return -1\n    end\n\
    end", "    c = \"\"\n    for i in 1:length(a)\n        if a[i] == b[i]\n     \
    \       c = c * \"0\"\n        else\n            c = c * \"1\"\n        end\n\
    \    end\n    return c\nend", "    c = \"\"\n    for i = 1:length(a)\n       \
    \ if a[i] == b[i]\n            push!(c, \"0\")\n        else\n            push!(c,\
    \ \"1\")\n        end\n    end\n    return c\nend", "    n = min(length(a), length(b))\n\
    \    p = Array{Int8}(n)\n    for i in 1:n\n        p[i] = a[i] == b[i] ? 0 : 1\n\
    \    end\n    return reduce(*, p)\nend", "    # convert to vectors of bits\n \
    \   a = parse(a,2)\n    b = parse(b,2)\n    # perform xor on each bit and assemble\
    \ result\n    return join( xor(a[i],b[i]) for i in eachindex(a) )\nend", "   \
    \ # Input strings are both binary\n    a_dec = Int(a, base=2)\n    b_dec = Int(b,\
    \ base=2)\n    xor_dec = xor(a_dec, b_dec)\n    xor_bin = string(xor_dec, base=2)\n\
    \    return xor_bin\nend\n ", "    c = \"\"\n    for i = 1:length(a)\n       \
    \ c = c * xor(a[i], b[i])\n    end\n    return c\nend", "    if length(a) == length(b)\n\
    \        res = String[]\n        for i in 1:length(a)\n            push!(res,\
    \ xor(a[i], b[i]))\n        end\n        return join(res)\n    else\n        error(\"\
    a and b are not of the same length\")\n    end\nend\nstring_xor(\"010\", \"110\"\
    )", "    s = \"\"\n    for i in 1:length(a)\n        if a[i] == b[i]\n       \
    \     s = s * \"0\"\n        else\n            s = s * \"1\"\n        end\n  \
    \  end\n    return s\nend", "    if length(a) != length(b)\n        error(\"Strings\
    \ must be the same length\")\n    end\n    c = \"\"\n    for i = 1:length(a)\n\
    \        c *= xor(a[i], b[i])\n    end\n    return c\nend", "    c = String(undef,\
    \ length(a))\n    for i = 1:length(a)\n        c[i] = \"0\"\n        if a[i] !=\
    \ b[i]\n            c[i] = \"1\"\n        end\n    end\n    return c\nend", " \
    \   if length(a) != length(b)\n        println(\"Lengths of the two input strings\
    \ do not match\")\n        return \"Error\"\n    end\n    result = \"\"\n    for\
    \ i in eachindex(a)\n        if a[i] == b[i]\n            push!(result, \"0\"\
    )\n        else\n            push!(result, \"1\")\n        end\n    end\n    return\
    \ result\nend", "    n = length(a)\n    xor_result = Array{Int64}(n)\n    for\
    \ i in 1:n\n        xor_result[i] = parse(Int64, a[i]) + parse(Int64, b[i])\n\
    \    end\n    return join(convert(Array{String},xor_result-1), \"\")\nend", " \
    \   \"\"\"This function takes two strings as input and returns another string\
    \ after performing XOR\"\"\"\n    c = \"\";\n    if (length(a) != length(b))\n\
    \        return \"Inputs have to be of same length\"\n    end\n    for i in eachindex(a)\n\
    \        if (a[i] == b[i])\n            push!(c, \"0\")\n        else\n      \
    \      push!(c, \"1\")\n        end\n    end\n    return c\nend", "    c = \"\"\
    \n    for i in 1:length(a)\n        c = c * string_xor(a[i], b[i])\n    end\n\
    \    return c\nend", "    c = \"\"\n    for i in 1:minimum(length(a), length(b))\n\
    \        bit1 = parse(Int, a[i])\n        bit2 = parse(Int, b[i])\n        c =\
    \ c * string(bit1 \u22BB bit2)\n    end\n    return c\nend", "    length = length(a)\n\
    \    if length != length(b)\n        println(\"Inputs must be of same length\"\
    )\n        return \"\"\n    end\n    result = \"\"\n    for i = 1:length\n   \
    \     if a[i] == b[i]\n            result = result * \"0\"\n        else\n   \
    \         result = result * \"1\"\n        end\n    end\n    return result\nend",
  "    if length(a) != length(b)\n        throw(ArgumentError(\"Input strings must\
    \ be of equal length.\"))\n    end\n    # We know a, b are of equal length, and\
    \ that length(a) == length(b)\n    out = \"\"\n    for i in 1:length(a)\n    \
    \    if a[i] == '0' && b[i] == '0'\n            push!(out, '0')\n        elseif\
    \ a[i] == '1' && b[i] == '1'\n            push!(out, '0')\n        else\n    \
    \        push!(out, '1')\n        end\n    end\n    return out\nend\nstring_xor(\"\
    010\", \"110\")", "    xor = 0\n    c = \"\"\n    for i in 1:length(a)\n     \
    \   xor = str2int(a[i]) \u22BB str2int(b[i])\n        push!(c, Int(xor))\n   \
    \ end\n    return join(c)\nend", "    \n    assert(length(a) == length(b))\n \
    \   \n    result = Vector{Char}(undef, length(a))\n    \n    for i in 1:length(a)\n\
    \        result[i] = xor(a[i], b[i])\n    end\n    \n    return join(result)\n\
    end", "    c = String[]\n    for i in 1:length(a)\n        if a[i] == b[i]\n \
    \           push!(c, \"0\")\n        else\n            push!(c, \"1\")\n     \
    \   end\n    end\n    join(c)\nend", "    c = []\n    for (i, v) in enumerate(a)\n\
    \        if b[i] == v\n            push!(c, \"0\")\n        else\n           \
    \ push!(c, \"1\")\n        end\n    end\n    return(join(c))\nend", "    if length(a)\
    \ != length(b)\n        error(\"Lengths must be equal\")\n    end\n    c = copy(a)\n\
    \    for i in 1:length(a)\n        c[i] = bitxor(a[i], b[i])\n    end\n    return\
    \ c\nend", "    c = String(length(a))\n    @inbounds for i in 1:length(a)\n  \
    \      c[i] = a[i] ^ b[i]\n    end\n    return c\nend", "    # Start with the\
    \ empty string\n    result = \"\"\n    for (x, y) in zip(a, b)\n        result\
    \ *= xor(parse(Int, x), parse(Int, y))\n    end\n    return result\nend\na = \"\
    101010101\"\nb = \"010010010\"\nstring_xor(a, b)", "    res = String(zeros(String,\
    \ length(a)))\n    for i = 1:length(a)\n        c = int(a[i]) ^ int(b[i])\n  \
    \      res[i] = string(c)\n    end\n    return res\nend", "    c = \"\"\n    for\
    \ (i, j) in zip(a, b)\n        c *= (i == j) ? \"0\" : \"1\"\n    end\n    return\
    \ c\nend", "    # Convert to Int\n    a = parse(Int, a, base=2)\n    b = parse(Int,\
    \ b, base=2)\n    # xor\n    c = a \u22BB b\n    # Convert back to String\n  \
    \  return pad(string(c, base=2), length(a))\nend", "    out = \"\"\n    for i\
    \ in 1:length(a)\n        if a[i] == b[i]\n            out = out * \"0\"\n   \
    \     else\n            out = out * \"1\"\n        end\n    end\n    return out\n\
    end", "    res = \"\"\n    for i = 1:length(a)\n        res *= string(parse(Int,\
    \ a[i]) \u22BB parse(Int, b[i]))\n    end\n    return res\nend", "    a = parse(Int,\
    \ a, base=2)\n    b = parse(Int, b, base=2)\n    return string(a \u22BB b, base=2)\n\
    end", "    out = String(undef, length(a))\n    for i in 1:length(a)\n        out[i]\
    \ = a[i] == b[i] ? '0' : '1'\n    end\n    return out\nend", "    function xor(a::Bool,\
    \ b::Bool)::Bool\n        if a == b\n            return false\n        else\n\
    \            return true\n        end\n    end\n    if length(a) != length(b)\n\
    \        throw(ArgumentError(\"inputs must be of same length\"))\n    end\n  \
    \  result = \"\"\n    for i = 1:length(a)\n        result = result * string(xor(a[i]\
    \ == '1', b[i] == '1'))\n    end\n    return result\nend", "    c = String[]\n\
    \    if length(a) == length(b)\n        for i in eachindex(a)\n            if\
    \ a[i] == '0' && b[i] == '0'\n                push!(c, '0')\n            elseif\
    \ a[i] == '1' && b[i] == '1'\n                push!(c, '0')\n            else\n\
    \                push!(c, '1')\n            end\n        end\n    end\n    join(c)\n\
    end"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
