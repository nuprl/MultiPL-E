name: HumanEval_87_get_row
language: jl
results:
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    (result::Vector{Tuple{Int64, Int64}})\
    \ = Vector{Tuple{Int64, Int64}}(undef, 0)\n    row = 0\n    for row_lst in lst\n\
    \        if x in row_lst\n            column = count(row_lst .== x)\n        \
    \    for j in findall(row_lst .== x)\n                push!(result, (row, column\
    \ - j))\n            end\n        end\n        row += 1\n    end\n    sort!(result,\
    \ by = t -> t[1])\n    for i in 1:length(result)\n        result[i] = sort(result[i],\
    \ by = t -> t[2], rev = true)\n    end\n    return result\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp05yy0et0.jl:42\\n  Test threw\
    \ exception\\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\\n  MethodError:\
    \ no method matching sort(::Tuple{Int64, Int64}; by=var\"#2#4\"(), rev=true)\\\
    n  Closest candidates are:\\n    sort(!Matched::AbstractUnitRange) at /shared/centos7/julia/1.7.3/share/julia/base/range.jl:1304\
    \ got unsupported keyword arguments \"by\", \"rev\"\\n    sort(!Matched::AbstractRange)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/range.jl:1307 got unsupported\
    \ keyword arguments \"by\", \"rev\"\\n    sort(!Matched::SparseArrays.SparseVector{Tv,\
    \ Ti}; kws...) where {Tv, Ti} at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/SparseArrays/src/sparsevector.jl:1968\\\
    n    ...\\n  Stacktrace:\\n   [1] get_row(lst::Vector{Vector{Int64}}, x::Int64)\\\
    n     @ Main /tmp/tmp05yy0et0.jl:33\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp05yy0et0.jl:42 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp05yy0et0.jl:41\\ntest set:\
    \ Error During Test at /tmp/tmp05yy0et0.jl:43\\n  Test threw exception\\n  Expression:\
    \ candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1),\
    \ (2, 1), (3, 1), (4, 1), (5, 1)]\\n  MethodError: no method matching sort(::Tuple{Int64,\
    \ Int64}; by=var\"#2#4\"(), rev=true)\\n  Closest candidates are:\\n    sort(!Matched::AbstractUnitRange)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/range.jl:1304 got unsupported\
    \ keyword arguments \"by\", \"rev\"\\n    sort(!Matched::AbstractRange) at /shared/centos7/julia/1.7.3/share/julia/base/range.jl:1307\
    \ got unsupported keyword arguments \"by\", \"rev\"\\n    sort(!Matched::SparseArrays.SparseVector{Tv,\
    \ Ti}; kws...) where {Tv, Ti} at /shared/centos7/julia/1."
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    @assert length(lst) > 0 \"Length\
    \ of the list is 0!\"\n    coords = []\n    for i in eachindex(lst)\n        for\
    \ j in eachindex(lst[i])\n            if lst[i][j] == x\n                push!(coords,\
    \ (i, j))\n            end\n        end\n    end\n    sorted_coords = sort(coords,\
    \ by = x -> x[1])\n    sorted_coords_by_col = sort(sorted_coords, by = x -> x[2],\
    \ rev = true)\n    return sorted_coords_by_col\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1,\
    \ 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t\
    @test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpo943lf1r.jl:38\\n  Expression: candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\\n   Evaluated: [(3, 6), (2, 5), (1, 1), (2, 1),\
    \ (3, 1)] == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\\nStacktrace:\\n [1] macro\
    \ expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmpo943lf1r.jl:38 [inlined]\\n\
    \ [3] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n [4] top-level scope\\n   @ /tmp/tmpo943lf1r.jl:37\\ntest set: Test\
    \ Failed at /tmp/tmpo943lf1r.jl:39\\n  Expression: candidate([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5,\
    \ 1)]\\n   Evaluated: [(1, 2), (2, 2), (3, 2), (4, 2), (5, 2), (6, 2)] == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\\nStacktrace:\\n [1] macro expansion\\\
    n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmpo943lf1r.jl:39 [inlined]\\n\
    \ [3] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n [4] top-level scope\\n   @ /tmp/tmpo943lf1r.jl:37\\ntest set: Test\
    \ Failed at /tmp/tmpo943lf1r.jl:40\\n  Expression: candidate([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1,\
    \ 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\\n \
    \  Evaluated: [(7, 6), (6, 5), (5, 4), (4, 3), (3, 2), (1, 1), (2, 1), (3, 1),\
    \ (4, 1), (5, 1), (6, 1), (7, 1)] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),\
    \ (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\\nStacktrace:\\n [1]\
    \ macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmpo943lf1r.j"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    res = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(res, (i-1, j-1))\n            end\n        end\n    end\n    sort!(res,\
    \ by = x -> x[1])\n    sort!(res, by = x -> x[2], rev = true)\n    return res\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp2zlk93as.jl:37\\n  Expression: candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0),\
    \ (2, 0)] == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\\nStacktrace:\\n [1] macro\
    \ expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmp2zlk93as.jl:37 [inlined]\\n\
    \ [3] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n [4] top-level scope\\n   @ /tmp/tmp2zlk93as.jl:36\\ntest set: Test\
    \ Failed at /tmp/tmp2zlk93as.jl:39\\n  Expression: candidate([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1,\
    \ 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\\n \
    \  Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0), (1, 0), (2, 0),\
    \ (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),\
    \ (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\\nStacktrace:\\n [1]\
    \ macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmp2zlk93as.jl:39 [inlined]\\n\
    \ [3] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n [4] top-level scope\\n   @ /tmp/tmp2zlk93as.jl:36\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    index_list = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(index_list, (i, j))\n            end\n        end\n    end\n    sort!(index_list,\
    \ by = x -> (x[1], -x[2]))\n    return index_list\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2,\
    \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
    \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp3yxs796q.jl:36\\n  Expression: candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\\n   Evaluated: [(1, 1), (2, 5), (2, 1), (3, 6),\
    \ (3, 1)] == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\\nStacktrace:\\n [1] macro\
    \ expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmp3yxs796q.jl:36 [inlined]\\n\
    \ [3] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n [4] top-level scope\\n   @ /tmp/tmp3yxs796q.jl:35\\ntest set: Test\
    \ Failed at /tmp/tmp3yxs796q.jl:37\\n  Expression: candidate([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5,\
    \ 1)]\\n   Evaluated: [(1, 2), (2, 2), (3, 2), (4, 2), (5, 2), (6, 2)] == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\\nStacktrace:\\n [1] macro expansion\\\
    n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmp3yxs796q.jl:37 [inlined]\\n\
    \ [3] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n [4] top-level scope\\n   @ /tmp/tmp3yxs796q.jl:35\\ntest set: Test\
    \ Failed at /tmp/tmp3yxs796q.jl:38\\n  Expression: candidate([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1,\
    \ 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\\n \
    \  Evaluated: [(1, 1), (2, 1), (3, 2), (3, 1), (4, 3), (4, 1), (5, 4), (5, 1),\
    \ (6, 5), (6, 1), (7, 6), (7, 1)] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),\
    \ (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\\nStacktrace:\\n [1]\
    \ macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmp3yxs796q.j"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    res = Vector{Tuple{Int64, Int64}}()\n\
    \    for (r, v) in enumerate(lst)\n        for (c, n) in enumerate(v)\n      \
    \      if n == x\n                push!(res, (r, c))\n            end\n      \
    \  end\n    end\n    sort!(res, by=x->x[1])\n    res2 = Vector{Tuple{Int64, Int64}}()\n\
    \    for (r, v) in enumerate(res)\n        push!(res2, (v[1], -v[2]))\n    end\n\
    \    sort!(res2, by=x->x[2])\n    for (r, v) in enumerate(res2)\n        res2[r]\
    \ = (v[1], -v[2])\n    end\n    return res2\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1,\
    \ 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t\
    @test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpzi24fjmq.jl:44\\n  Expression: candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\\n   Evaluated: [(3, 6), (2, 5), (1, 1), (2, 1),\
    \ (3, 1)] == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\\nStacktrace:\\n [1] macro\
    \ expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmpzi24fjmq.jl:44 [inlined]\\n\
    \ [3] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n [4] top-level scope\\n   @ /tmp/tmpzi24fjmq.jl:43\\ntest set: Test\
    \ Failed at /tmp/tmpzi24fjmq.jl:45\\n  Expression: candidate([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5,\
    \ 1)]\\n   Evaluated: [(1, 2), (2, 2), (3, 2), (4, 2), (5, 2), (6, 2)] == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\\nStacktrace:\\n [1] macro expansion\\\
    n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmpzi24fjmq.jl:45 [inlined]\\n\
    \ [3] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n [4] top-level scope\\n   @ /tmp/tmpzi24fjmq.jl:43\\ntest set: Test\
    \ Failed at /tmp/tmpzi24fjmq.jl:46\\n  Expression: candidate([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1,\
    \ 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\\n \
    \  Evaluated: [(7, 6), (6, 5), (5, 4), (4, 3), (3, 2), (1, 1), (2, 1), (3, 1),\
    \ (4, 1), (5, 1), (6, 1), (7, 1)] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),\
    \ (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\\nStacktrace:\\n [1]\
    \ macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmpzi24fjmq.j"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n  vector_aux = []\n  for i in 1:length(lst)\n\
    \    for j in 1:length(lst[i])\n      if lst[i][j] == x\n        push!(vector_aux,\
    \ (i-1, j-1))\n      end\n    end\n  end\n  sort!(vector_aux, by=x->x[1])\n  return\
    \ sort!(vector_aux, by=x->x[2], rev=true)\nend\nget_row([[1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpth1wi30m.jl:37\\n  Expression: candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0),\
    \ (2, 0)] == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\\nStacktrace:\\n [1] macro\
    \ expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmpth1wi30m.jl:37 [inlined]\\n\
    \ [3] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n [4] top-level scope\\n   @ /tmp/tmpth1wi30m.jl:36\\ntest set: Test\
    \ Failed at /tmp/tmpth1wi30m.jl:39\\n  Expression: candidate([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1,\
    \ 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\\n \
    \  Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0), (1, 0), (2, 0),\
    \ (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),\
    \ (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\\nStacktrace:\\n [1]\
    \ macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmpth1wi30m.jl:39 [inlined]\\n\
    \ [3] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n [4] top-level scope\\n   @ /tmp/tmpth1wi30m.jl:36\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    (row_index, column_index) = findall(x\
    \ -> x == x, lst)\n    coordinate = Tuple{Int64, Int64}[(row_index[i], column_index[i])\
    \ for i in 1:length(row_index)]\n    sort!(coordinate, by = tuple(i -> i[1], i\
    \ -> -i[2]))\n    return coordinate\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpvi6u29ak.jl:30\\n  Expression: candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\\n   Evaluated: [(1, 2)] == [(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]\\nStacktrace:\\n [1] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmpvi6u29ak.jl:30 [inlined]\\n\
    \ [3] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n [4] top-level scope\\n   @ /tmp/tmpvi6u29ak.jl:29\\ntest set: Test\
    \ Failed at /tmp/tmpvi6u29ak.jl:31\\n  Expression: candidate([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5,\
    \ 1)]\\n   Evaluated: [(1, 2)] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5,\
    \ 1)]\\nStacktrace:\\n [1] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmpvi6u29ak.jl:31 [inlined]\\n\
    \ [3] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n [4] top-level scope\\n   @ /tmp/tmpvi6u29ak.jl:29\\ntest set: Test\
    \ Failed at /tmp/tmpvi6u29ak.jl:32\\n  Expression: candidate([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1,\
    \ 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\\n \
    \  Evaluated: [(1, 2)] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4,\
    \ 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\\nStacktrace:\\n [1] macro expansion\\\
    n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmpvi6u29ak.jl:32 [inlined]\\n\
    \ [3] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n [4] top-level scope\\n   @ /tmp/"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \"\"\"\n    get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}}\n    \"\"\"\n    result = Vector{Tuple{Int64,\
    \ Int64}}()\n    for i in 1:length(lst)\n        for j in 1:length(lst[i])\n \
    \           if lst[i][j] == x\n                push!(result, (i-1, j-1))\n   \
    \         end\n        end\n    end\n    sort!(result, by = x -> x[1])\n    for\
    \ i in 1:length(result)\n        if i > 1 && result[i][1] == result[i-1][1]\n\
    \            result[i-1:i] = sort(result[i-1:i], by = x -> x[2], rev = true)\n\
    \        end\n    end\n    return result\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpklljzunt.jl:49\\n  Test threw\
    \ exception\\n  Expression: candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\\n\
    \  MethodError: no method matching get_row(::Vector{Vector{Any}}, ::Int64)\\n\
    \  Closest candidates are:\\n    get_row(!Matched::Vector{Vector{Int64}}, ::Int64)\
    \ at /tmp/tmpklljzunt.jl:19\\n  Stacktrace:\\n   [1] macro expansion\\n     @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\\\
    n   [2] macro expansion\\n     @ /tmp/tmpklljzunt.jl:49 [inlined]\\n   [3] macro\
    \ expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpklljzunt.jl:43\\nTest Summary:\
    \ | Pass  Error  Total\\ntest set      |    5      1      6\\n'"
  stderr: "b'ERROR: LoadError: Some tests did not pass: 5 passed, 0 failed, 1 errored,\
    \ 0 broken.\\nin expression starting at /tmp/tmpklljzunt.jl:41\\n'"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if lst == []\n        return []\n\
    \    end\n    nrows = length(lst)\n    ncols = length(lst[1])\n    idx = [j for\
    \ i in 1:nrows, j in 1:ncols if lst[i][j] == x]\n    idx = sort(idx, by = y ->\
    \ ((x -> floor(x / ncols))(y), (x -> mod(x, ncols))(y)))\n    return [(x -> floor(x\
    \ / ncols))(y), (x -> mod(x, ncols))(y)] for y in idx]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2,\
    \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
    \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"function\" at /tmp/tmpbpuh7xy5.jl:19 expected\
    \ \"end\", got \"for\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpbpuh7xy5.jl:27\n\
    in expression starting at /tmp/tmpbpuh7xy5.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    coordinate_lst = []\n    for i\
    \ = 1:length(lst)\n        for j = 1:length(lst[i])\n            if lst[i][j]\
    \ == x\n                coord = (i-1, j-1)\n                push!(coordinate_lst,\
    \ coord)\n            end\n        end\n    end\n    sorted_rows = sort(coordinate_lst,\
    \ by = (x -> x[1]))\n    sorted_cols = sort(sorted_rows, by = (x -> x[2]), rev\
    \ = true)\n    return sorted_cols\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpygwnqs17.jl:38\\n  Expression: candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0),\
    \ (2, 0)] == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\\nStacktrace:\\n [1] macro\
    \ expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmpygwnqs17.jl:38 [inlined]\\n\
    \ [3] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n [4] top-level scope\\n   @ /tmp/tmpygwnqs17.jl:37\\ntest set: Test\
    \ Failed at /tmp/tmpygwnqs17.jl:40\\n  Expression: candidate([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1,\
    \ 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\\n \
    \  Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0), (1, 0), (2, 0),\
    \ (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),\
    \ (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\\nStacktrace:\\n [1]\
    \ macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmpygwnqs17.jl:40 [inlined]\\n\
    \ [3] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n [4] top-level scope\\n   @ /tmp/tmpygwnqs17.jl:37\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    ret = Tuple{Int64, Int64}[]\n \
    \   n = length(lst)\n    for i = 1:n\n        m = length(lst[i])\n        for\
    \ j = 1:m\n            if lst[i][j] == x\n                push!(ret, (i - 1, j\
    \ - 1))\n            end\n        end\n    end\n    sort!(ret, by=x->(x[1], -x[2]))\n\
    \    return ret\nend\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpujjguqy1.jl:43\\n  Test threw\
    \ exception\\n  Expression: candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\\n\
    \  MethodError: no method matching get_row(::Vector{Vector{Any}}, ::Int64)\\n\
    \  Closest candidates are:\\n    get_row(!Matched::Vector{Vector{Int64}}, ::Int64)\
    \ at /tmp/tmpujjguqy1.jl:19\\n  Stacktrace:\\n   [1] macro expansion\\n     @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\\\
    n   [2] macro expansion\\n     @ /tmp/tmpujjguqy1.jl:43 [inlined]\\n   [3] macro\
    \ expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpujjguqy1.jl:37\\nTest Summary:\
    \ | Pass  Error  Total\\ntest set      |    5      1      6\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by=x->(x[1], -x[2]))\n    return result\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1,\
    \ 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t\
    @test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp8y8hihpn.jl:41\\n  Test threw\
    \ exception\\n  Expression: candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\\n\
    \  MethodError: no method matching get_row(::Vector{Vector{Any}}, ::Int64)\\n\
    \  Closest candidates are:\\n    get_row(!Matched::Vector{Vector{Int64}}, ::Int64)\
    \ at /tmp/tmp8y8hihpn.jl:19\\n  Stacktrace:\\n   [1] macro expansion\\n     @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\\\
    n   [2] macro expansion\\n     @ /tmp/tmp8y8hihpn.jl:41 [inlined]\\n   [3] macro\
    \ expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp8y8hihpn.jl:35\\nTest Summary:\
    \ | Pass  Error  Total\\ntest set      |    5      1      6\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if lst == []\n        return []\n\
    \    end\n    tuple_list = []\n    for i in 1:length(lst)\n        vector = lst[i]\n\
    \        for j in 1:length(vector)\n            if vector[j] == x\n          \
    \      tuple_list = append!(tuple_list, (i-1, j-1))\n            end\n       \
    \ end\n    end\n    tuple_list = sort(tuple_list, (row, column) -> (row, -column))\n\
    \    return tuple_list\nend\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpi1w4sk41.jl:40\\n  Test threw\
    \ exception\\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\\n  MethodError:\
    \ no method matching sort(::Vector{Any}, ::var\"#1#2\")\\n  Closest candidates\
    \ are:\\n    sort(::AbstractVector; kws...) at /shared/centos7/julia/1.7.3/share/julia/base/sort.jl:772\\\
    n    sort(::AbstractArray; dims, alg, lt, by, rev, order) at /shared/centos7/julia/1.7.3/share/julia/base/sort.jl:1030\\\
    n  Stacktrace:\\n   [1] get_row(lst::Vector{Vector{Int64}}, x::Int64)\\n     @\
    \ Main /tmp/tmpi1w4sk41.jl:32\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpi1w4sk41.jl:40 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpi1w4sk41.jl:39\\ntest set:\
    \ Error During Test at /tmp/tmpi1w4sk41.jl:41\\n  Test threw exception\\n  Expression:\
    \ candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1),\
    \ (2, 1), (3, 1), (4, 1), (5, 1)]\\n  MethodError: no method matching sort(::Vector{Any},\
    \ ::var\"#1#2\")\\n  Closest candidates are:\\n    sort(::AbstractVector; kws...)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/sort.jl:772\\n    sort(::AbstractArray;\
    \ dims, alg, lt, by, rev, order) at /shared/centos7/julia/1.7.3/share/julia/base/sort.jl:1030\\\
    n  Stacktrace:\\n   [1] get_row(lst::Vector{Vector{Int64}}, x::Int64)\\n     @\
    \ Main /tmp/tmpi1w4sk41.jl:32\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpi1w4sk41.jl:41 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpi1w4sk41.jl:39\\ntest set:\
    \ Error Duri"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # Get the length of the vector\n\
    \    rows = length(lst)\n    result = Vector{Tuple{Int64, Int64}}()\n    # Cycle\
    \ through the rows\n    for row in 1:rows\n        # Cycle through the rows\n\
    \        cols = length(lst[row])\n        for col in 1:cols\n            # Check\
    \ if x == element\n            if x == lst[row][col]\n                # If it\
    \ is, add the row, col tuple to the result\n                push!(result, (row-1,\
    \ col-1))\n            end\n        end\n    end\n    return sort(result, by =\
    \ [x -> x[1], x -> -x[2]])\nend\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmppwijo0ik.jl:42\\n  Test threw\
    \ exception\\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\\n  MethodError:\
    \ objects of type Vector{Function} are not callable\\n  Use square brackets []\
    \ for indexing an Array.\\n  Stacktrace:\\n    [1] lt(o::Base.Order.By{Vector{Function},\
    \ Base.Order.ForwardOrdering}, a::Tuple{Int64, Int64}, b::Tuple{Int64, Int64})\\\
    n      @ Base.Order ./ordering.jl:111\\n    [2] sort!\\n      @ ./sort.jl:507\
    \ [inlined]\\n    [3] sort!(v::Vector{Tuple{Int64, Int64}}, lo::Int64, hi::Int64,\
    \ a::Base.Sort.MergeSortAlg, o::Base.Order.By{Vector{Function}, Base.Order.ForwardOrdering},\
    \ t::Vector{Tuple{Int64, Int64}})\\n      @ Base.Sort ./sort.jl:592\\n    [4]\
    \ sort!\\n      @ ./sort.jl:591 [inlined]\\n    [5] sort!\\n      @ ./sort.jl:664\
    \ [inlined]\\n    [6] #sort!#8\\n      @ ./sort.jl:725 [inlined]\\n    [7] #sort#9\\\
    n      @ ./sort.jl:772 [inlined]\\n    [8] get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)\\n      @ Main /tmp/tmppwijo0ik.jl:35\\n    [9] macro expansion\\\
    n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [10] macro expansion\\n      @ /tmp/tmppwijo0ik.jl:42 [inlined]\\\
    n   [11] macro expansion\\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [12] top-level scope\\n      @ /tmp/tmppwijo0ik.jl:41\\ntest\
    \ set: Error During Test at /tmp/tmppwijo0ik.jl:43\\n  Test threw exception\\\
    n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\\n  MethodError: objects of type\
    \ Vector{Function} are not callable\\n  Use square brackets [] for indexing an\
    \ Array.\\n  Stacktrace:\\n    [1] lt(o::Base.Order.By{Vector{Function}, Base.Order.ForwardOrdering},\
    \ a::Tuple{Int64, Int64}, b::Tuple{Int64, Int64})\\n      @ Base.Order ./ordering.jl:111\\\
    n    [2] sort!\\n      @ ./sort.jl:507 [inlined]\\"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    row = size(lst, 1)\n    vector\
    \ = Tuple{Int64, Int64}[]\n    if row == 0\n        return vector\n    end\n \
    \   for i in 1:row\n        col = size(lst[i], 1)\n        for j in 1:col\n  \
    \          if lst[i][j] == x\n                push!(vector, (i-1, j-1))\n    \
    \        end\n        end\n    end\n    sorted = sort(vector, by = [(x[1], x[2])\
    \ for x in vector])\n    return sorted\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp_p8dqhqt.jl:41\\n  Test threw\
    \ exception\\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\\n  MethodError:\
    \ objects of type Vector{Tuple{Int64, Int64}} are not callable\\n  Use square\
    \ brackets [] for indexing an Array.\\n  Stacktrace:\\n    [1] lt(o::Base.Order.By{Vector{Tuple{Int64,\
    \ Int64}}, Base.Order.ForwardOrdering}, a::Tuple{Int64, Int64}, b::Tuple{Int64,\
    \ Int64})\\n      @ Base.Order ./ordering.jl:111\\n    [2] sort!\\n      @ ./sort.jl:507\
    \ [inlined]\\n    [3] sort!(v::Vector{Tuple{Int64, Int64}}, lo::Int64, hi::Int64,\
    \ a::Base.Sort.MergeSortAlg, o::Base.Order.By{Vector{Tuple{Int64, Int64}}, Base.Order.ForwardOrdering},\
    \ t::Vector{Tuple{Int64, Int64}})\\n      @ Base.Sort ./sort.jl:592\\n    [4]\
    \ sort!\\n      @ ./sort.jl:591 [inlined]\\n    [5] sort!\\n      @ ./sort.jl:664\
    \ [inlined]\\n    [6] #sort!#8\\n      @ ./sort.jl:725 [inlined]\\n    [7] #sort#9\\\
    n      @ ./sort.jl:772 [inlined]\\n    [8] get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)\\n      @ Main /tmp/tmp_p8dqhqt.jl:33\\n    [9] macro expansion\\\
    n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [10] macro expansion\\n      @ /tmp/tmp_p8dqhqt.jl:41 [inlined]\\\
    n   [11] macro expansion\\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [12] top-level scope\\n      @ /tmp/tmp_p8dqhqt.jl:40\\ntest\
    \ set: Error During Test at /tmp/tmp_p8dqhqt.jl:42\\n  Test threw exception\\\
    n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\\n  MethodError: objects of type\
    \ Vector{Tuple{Int64, Int64}} are not callable\\n  Use square brackets [] for\
    \ indexing an Array.\\n  Stacktrace:\\n    [1] lt(o::Base.Order.By{Vector{Tuple{Int64,\
    \ Int64}}, Base.Order.ForwardOrdering}, a::Tuple{Int64, Int64}, b::Tuple{Int64,\
    \ Int64})\\n      @ Base.Order ./ordering."
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # initialize result vector\n  \
    \  result = []\n    if lst == []\n        return result\n    end\n    # iterate\
    \ through each nested vector\n    for i in 1:length(lst)\n        # iterate through\
    \ each element of the nested vector\n        for j in 1:length(lst[i])\n     \
    \       # If the element is equal to x, push the tuple to result\n           \
    \ if lst[i][j] == x\n                push!(result, (i-1, j-1))\n            end\n\
    \        end\n    end\n    # sort based on rows in ascending order and columns\
    \ in descending order\n    sort!(result, by = (x -> x[1]), rev = false)\n    sort!(result,\
    \ by = (x -> x[2]), rev = true)\n    return result\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2,\
    \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
    \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpbwqhlwu7.jl:45\\n  Expression: candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0),\
    \ (2, 0)] == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\\nStacktrace:\\n [1] macro\
    \ expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmpbwqhlwu7.jl:45 [inlined]\\n\
    \ [3] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n [4] top-level scope\\n   @ /tmp/tmpbwqhlwu7.jl:44\\ntest set: Test\
    \ Failed at /tmp/tmpbwqhlwu7.jl:47\\n  Expression: candidate([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1,\
    \ 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\\n \
    \  Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0), (1, 0), (2, 0),\
    \ (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),\
    \ (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\\nStacktrace:\\n [1]\
    \ macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmpbwqhlwu7.jl:47 [inlined]\\n\
    \ [3] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n [4] top-level scope\\n   @ /tmp/tmpbwqhlwu7.jl:44\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for (index_row,\
    \ row) in enumerate(lst)\n        for (index_column, value) in enumerate(row)\n\
    \            if x == value\n                push!(result, (index_row, index_column))\n\
    \            end\n        end\n    end\n    return sort(result, by = x -> (x[1],\
    \ -x[2]))\nend\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp8j5_vvef.jl:35\\n  Expression: candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\\n   Evaluated: [(1, 1), (2, 5), (2, 1), (3, 6),\
    \ (3, 1)] == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\\nStacktrace:\\n [1] macro\
    \ expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmp8j5_vvef.jl:35 [inlined]\\n\
    \ [3] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n [4] top-level scope\\n   @ /tmp/tmp8j5_vvef.jl:34\\ntest set: Test\
    \ Failed at /tmp/tmp8j5_vvef.jl:36\\n  Expression: candidate([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5,\
    \ 1)]\\n   Evaluated: [(1, 2), (2, 2), (3, 2), (4, 2), (5, 2), (6, 2)] == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\\nStacktrace:\\n [1] macro expansion\\\
    n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmp8j5_vvef.jl:36 [inlined]\\n\
    \ [3] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n [4] top-level scope\\n   @ /tmp/tmp8j5_vvef.jl:34\\ntest set: Test\
    \ Failed at /tmp/tmp8j5_vvef.jl:37\\n  Expression: candidate([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1,\
    \ 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\\n \
    \  Evaluated: [(1, 1), (2, 1), (3, 2), (3, 1), (4, 3), (4, 1), (5, 4), (5, 1),\
    \ (6, 5), (6, 1), (7, 6), (7, 1)] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),\
    \ (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\\nStacktrace:\\n [1]\
    \ macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmp8j5_vvef.j"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n  row_vec = Vector{Tuple{Int64, Int64}}()\n\
    \  for i in eachindex(lst)\n    row = lst[i]\n    for j in eachindex(row)\n  \
    \    if row[j] == x\n        push!(row_vec, (i, j))\n      end\n    end\n  end\n\
    \  row_vec\nend\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp60kupz7l.jl:36\\n  Expression: candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\\n   Evaluated: [(1, 1), (2, 1), (2, 5), (3, 1),\
    \ (3, 6)] == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\\nStacktrace:\\n [1] macro\
    \ expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmp60kupz7l.jl:36 [inlined]\\n\
    \ [3] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n [4] top-level scope\\n   @ /tmp/tmp60kupz7l.jl:35\\ntest set: Test\
    \ Failed at /tmp/tmp60kupz7l.jl:37\\n  Expression: candidate([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5,\
    \ 1)]\\n   Evaluated: [(1, 2), (2, 2), (3, 2), (4, 2), (5, 2), (6, 2)] == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\\nStacktrace:\\n [1] macro expansion\\\
    n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmp60kupz7l.jl:37 [inlined]\\n\
    \ [3] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n [4] top-level scope\\n   @ /tmp/tmp60kupz7l.jl:35\\ntest set: Test\
    \ Failed at /tmp/tmp60kupz7l.jl:38\\n  Expression: candidate([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1,\
    \ 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\\n \
    \  Evaluated: [(1, 1), (2, 1), (3, 1), (3, 2), (4, 1), (4, 3), (5, 1), (5, 4),\
    \ (6, 1), (6, 5), (7, 1), (7, 6)] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),\
    \ (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\\nStacktrace:\\n [1]\
    \ macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmp60kupz7l.j"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = Tuple{Int64, Int64}[]\n\
    \    for i = 1:length(lst)\n        for j = 1:length(lst[i])\n            if lst[i][j]\
    \ == x\n                push!(result, (i-1, j-1))\n            end\n        end\n\
    \    end\n    sort!(result, by=x->(x[1], -x[2]))\n    return result\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmptcrub5l8.jl:41\\n  Test threw\
    \ exception\\n  Expression: candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\\n\
    \  MethodError: no method matching get_row(::Vector{Vector{Any}}, ::Int64)\\n\
    \  Closest candidates are:\\n    get_row(!Matched::Vector{Vector{Int64}}, ::Int64)\
    \ at /tmp/tmptcrub5l8.jl:19\\n  Stacktrace:\\n   [1] macro expansion\\n     @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\\\
    n   [2] macro expansion\\n     @ /tmp/tmptcrub5l8.jl:41 [inlined]\\n   [3] macro\
    \ expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmptcrub5l8.jl:35\\nTest Summary:\
    \ | Pass  Error  Total\\ntest set      |    5      1      6\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = Vector{Tuple{Int64, Int64}}(undef,\
    \ 0)\n    for i = 1:length(lst)\n        j = 1\n        while j <= length(lst[i])\n\
    \            if lst[i][j] == x\n                push!(result, (i - 1, j - 1))\n\
    \            end\n            j += 1\n        end\n    end\n    return sort(result,\
    \ by = (a, b) -> (a[1] <=> b[1], b[2] <=> a[2]))\nend\n \nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2,\
    \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
    \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \">\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpd8nphus8.jl:30\nin expression starting at\
    \ /tmp/tmpd8nphus8.jl:30\n"
  exit_code: 1
  status: SyntaxError
