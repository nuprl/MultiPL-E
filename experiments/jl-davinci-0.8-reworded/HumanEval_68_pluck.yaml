name: HumanEval_68_pluck
language: jl
prompt: "\"\"\"\n    \"Given a vector representing a branch of a tree that has non-negative\
  \ integer nodes\n    your task is to pluck one of the nodes and return it.\n   \
  \ The plucked node should be the node with the smallest even value.\n    If multiple\
  \ nodes with the same smallest even value are found return the node that has smallest\
  \ index.\n\n    The plucked node should be returned in a vector, [ smalest_value,\
  \ its index ],\n    If there are no even values or the given vector is empty, return\
  \ [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n    [2, 1]\n    Explanation:\
  \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n\
  \    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation: 2 has the smallest even\
  \ value, and 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n  \
  \  []\n    \n    Example 4:\n    >>> pluck([5, 0, 3, 0, 4, 2])\n    [0, 1]\n   \
  \ Explanation: 0 is the smallest value, but  there are two zeros,\n            \
  \     so we will choose the first zero, which has the smallest index.\n\n    Constraints:\n\
  \        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction\
  \ pluck(arr::Vector{Int64})::Vector{Int64} \n"
tests: "using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
  \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
  \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1,\
  \ 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t\
  @test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
  end\n"
completions: ["    if isempty(arr)\n        return []\n    end\n    min_val = Int64(typemax(Int64))\n\
    \    min_pos = 0\n    for i = 1:length(arr)\n        if iseven(arr[i]) && arr[i]\
    \ < min_val\n            min_val = arr[i]\n            min_pos = i\n        end\n\
    \    end\n    if min_val == typemax(Int64)\n        return []\n    end\n    return\
    \ [min_val, min_pos]\nend", "    if length(arr) == 0\n        return Int64[]\n\
    \    end\n    idx_min_even = 0\n    min_even = 0\n    i = 1\n    for x in arr\n\
    \        if x % 2 == 0 && (min_even == 0 || x < min_even)\n            min_even\
    \ = x\n            idx_min_even = i\n        end\n        i += 1\n    end\n  \
    \  if min_even != 0\n        return [min_even, idx_min_even]\n    else\n     \
    \   return Int64[]\n    end\nend\npluck([4, 2, 3])", "    if arr == Vector{Int64}()\n\
    \        return []\n    end\n    evens = []\n    for i = 1:length(arr)\n     \
    \   if iseven(arr[i])\n            push!(evens, [arr[i], i])\n        end\n  \
    \  end\n    if evens == []\n        return []\n    end\n    evens = sort(evens,\
    \ by = x -> x[1])\n    return evens[1]\nend", "    result = Vector{Int64}()\n\
    \    for (index, item) in enumerate(arr)\n        if item % 2 == 0\n         \
    \   if isempty(result) || item < result[1]\n                result = [item, index]\n\
    \            end\n        end\n    end\n    return result\nend", "    #Remove\
    \ all odd numbers\n    arr = arr[arr % 2 .== 0]\n    #If none are even, return\
    \ []\n    if isempty(arr)\n        return []\n    end\n    #Otherwise, index the\
    \ first even number and return\n    return [arr[1], findfirst(arr, arr[1])[1]]\n\
    end", "  evens = [ x for x in arr if iseven(x) ]\n  if length(evens) == 0\n  \
    \  return []\n  end\n  min_even = minimum(evens)\n  for i in 1:length(arr)\n \
    \   if arr[i] == min_even\n      return [min_even, i]\n    end\n  end\nend", " \
    \   if length(arr) > 0\n        first_even_index = findfirst(x -> x % 2 == 0,\
    \ arr)\n        if !isnothing(first_even_index)\n            minimum_even_value\
    \ = minimum(arr[first_even_index:end])\n            minimum_even_index = findall(arr\
    \ .== minimum_even_value)[1]\n            return [minimum_even_value, minimum_even_index]\n\
    \        end\n    end\n    return []\nend", "    min_index = 0\n    min_value\
    \ = 0\n    for index in 1:length(arr)\n        if (arr[index] % 2 == 0) && (arr[index]\
    \ != 0) && (arr[index] < min_value)\n            min_value = arr[index]\n    \
    \        min_index = index\n        end\n    end\n    return [min_value, min_index]\n\
    end", "    index_vector = Vector{Int64}()\n    for (index, value) in enumerate(arr)\n\
    \        if value % 2 == 0\n            push!(index_vector, index)\n        end\n\
    \    end\n    if isempty(index_vector)\n        return Vector{Int64}()\n    end\n\
    \    return arr[index_vector[1]]\nend", "    # We iterate through all values in\
    \ the array\n    # and save even values and their indexes\n    # The even value\
    \ with the smallest index\n    # will be our solution\n    min_idx = -1\n    min_val\
    \ = 0\n    for (i, node) in enumerate(arr)\n        if node % 2 == 0 && (min_idx\
    \ == -1 || node < min_val)\n            min_idx = i\n            min_val = node\n\
    \        end\n    end\n    if min_idx == -1 \n        return []\n    else\n  \
    \      return [min_val, min_idx]\n    end\nend\n```", "    evens = findall(a ->\
    \ iseven(a), arr)\n    n = length(evens)\n    if n == 0\n        return []\n \
    \   end\n    first_even = arr[evens[1]]\n    index = evens[1]\n    for i in 2:n\n\
    \        if arr[evens[i]] < first_even\n            first_even = arr[evens[i]]\n\
    \            index = evens[i]\n        end\n    end\n    return [first_even, index]\n\
    end\n    ", "    # if arr is empty, return empty vector\n    # else, continue\n\
    \    if isempty(arr)\n        return []\n    end\n    \n    # initialize a few\
    \ values\n    # index of lowest even value\n    min_idx = -1\n    # lowest even\
    \ value\n    min_val = 2147483647 # biggest possible int\n    \n    # for each\
    \ item in array\n    for i in 1:length(arr)\n        # if item is even and less\
    \ than the minimum even value\n        if rem(arr[i], 2) == 0 && arr[i] < min_val\n\
    \            # set the new minimum even value and the index at which it can be\
    \ found\n            min_val = arr[i]\n            min_idx = i\n        end\n\
    \    end\n    \n    # if there was no even value, return empty vector\n    # else,\
    \ return the minimum even value and its index\n    if min_idx == -1\n        return\
    \ []\n    else\n        return [min_val, min_idx]\n    end\nend", "    evens =\
    \ arr[isodd.(arr)]\n    if length(evens) == 0\n        return []\n    else\n \
    \       idx = findfirst(arr .== minimum(evens))\n        return [arr[idx], idx]\n\
    \    end\nend", "    # check for empty array\n    if length(arr) == 0\n      \
    \  return []\n    end\n    \n    # convert to Array for indexing\n    arr_idx\
    \ = Array(arr)\n    \n    # check if there are even numbers\n    even_nums = isempty(findall(!isodd,\
    \ arr))\n    \n    # return empty list if no even numbers\n    if even_nums ==\
    \ true\n        return []\n    end\n    \n    # get the minimum even number and\
    \ its index\n    min_even = findall(==minimum(arr[findall(!isodd, arr)]), arr_idx)\n\
    \    \n    # return minimum even value and its index\n    return [arr[min_even[1]],\
    \ min_even[1]]\nend", "    # julia doesn't have a min function, \n    # so I'm\
    \ creating a lambda that returns the minimum of an array\n    get_min = (arr)\
    \ -> (reduce(min, arr))\n    # create a new array to store only the even values\n\
    \    evens = filter(x -> x % 2 == 0, arr)\n    # return an empty array if there\
    \ are no even values\n    if length(evens) == 0\n        return []\n    end\n\
    \    # return the minimum even value and its index\n    return [get_min(evens),\
    \ findfirst(x -> x == get_min(evens), arr)]\nend\nprintln(pluck([4, 2, 3]))\n\
    println(pluck([1, 2, 3]))\nprintln(pluck([]))\nprintln(pluck([5, 0, 3, 0, 4, 2]))",
  "    if arr == []\n        return []\n    end\n    evens = []\n    for i in 1:length(arr)\n\
    \        if rem(arr[i], 2) == 0\n            push!(evens, arr[i])\n        end\n\
    \    end\n    if evens == []\n        return []\n    end\n    min_index = indmin(evens)\n\
    \    val = evens[min_index]\n    return [val, indmin(findall(arr.==val))]\nend\n\
    \"\"\"\n    \"Given a vector of integers find the n-th smallest integer in the\
    \ vector.\n    Your method should not modify the vector.\n    The input vector\
    \ will be of size at least 1 and at most 10000,\n    and the n-th smallest integer\
    \ will be of size at least 1 and at most 10000.", "    # find even numbers\n \
    \   evens = [v for v in arr if v % 2 == 0]\n    # find min of even numbers\n \
    \   min_even = minimum(evens)\n    # find index of min_even\n    idx = findall(i\
    \ -> i == min_even, arr)[1]\n    return [min_even, idx]\nend", "    # Your code\
    \ goes here!\nend", "    min_even_val = Inf\n    min_even_idx = -1\n    for (idx,\
    \ n) in enumerate(arr)\n        if n % 2 == 0 && n < min_even_val\n          \
    \  min_even_val = n\n            min_even_idx = idx\n        end\n    end\n  \
    \  if min_even_idx == -1\n        return []\n    else\n        return [min_even_val,\
    \ min_even_idx]\n    end\nend\n\"\"\"\n    \"Given an array of integers arr, write\
    \ a function that returns true if and only if the number of occurrences of each\
    \ value in the array is unique.", "    # special case: empty array\n    if length(arr)\
    \ == 0\n        return []\n    end\n    \n    # First pass, find the smallest\
    \ even element\n    minValue::Int64 = typemax(Int64)\n    minIndex::Int64 = 0\n\
    \    for i in 1:length(arr)\n        if mod(arr[i], 2) == 0 && arr[i] < minValue\n\
    \            minValue = arr[i]\n            minIndex = i\n        end\n    end\n\
    \    \n    # Second pass, find the first smallest even element\n    minIndex::Int64\
    \ = 0\n    for i in 1:length(arr)\n        if mod(arr[i], 2) == 0 && arr[i] ==\
    \ minValue\n            minIndex = i\n            break\n        end\n    end\n\
    \    \n    return [minValue, minIndex]\nend", "    if isempty(arr) || all(x ->\
    \ x % 2 != 0, arr)\n        return Vector{Int64}()\n    end\n    min_index = -1\n\
    \    min_value = -1\n    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n\
    \            if min_index == -1 || arr[i] < min_value\n                min_index\
    \ = i\n                min_value = arr[i]\n            end\n        end\n    end\n\
    \    return [min_value, min_index]\nend", "    # If the array is empty, return\
    \ []\n    if length(arr) == 0 \n        return []\n    # If all of the values\
    \ are odd, return []\n    if all(arr .% 2 .!= 0)\n        return []\n    end\n\
    \    # Find the smallest even value, \n    smallest_even = minimum(arr[arr .%\
    \ 2 .== 0])\n    # Find the index of the smallest even value,\n    smallest_even_index\
    \ = findall(arr .== smallest_even)[1]\n    # Return the smallest even value and\
    \ its index\n    return [smallest_even, smallest_even_index]\nend", "    # your\
    \ code here\nend", "    smallest::Int64 = maximum(Int64)\n    index::Int64 = maximum(Int64)\n\
    \    for i in 1:length(arr)\n        if mod(arr[i], 2) == 0\n            if arr[i]\
    \ < smallest\n                smallest = arr[i]\n                index = i\n \
    \           end\n        end\n    end\n    return [smallest, index]\nend", " \
    \   if isempty(arr) || all(arr .% 2 .!= 0) return Int64[] end\n    evens = arr[arr\
    \ .% 2 .== 0]\n    if length(evens) == 1 return [evens[1], findfirst(arr, evens[1])[1]]\
    \ end\n    idx = findfirst(evens, minimum(evens))[1]\n    [evens[idx], findfirst(arr,\
    \ evens[idx])[1]]\nend", "    if isempty(arr)\n        return []\n    end\n  \
    \  min_even = Inf\n    min_index = -1\n    for i in 1:length(arr)\n        val\
    \ = arr[i]\n        if (val % 2 == 0) && (val < min_even)\n            min_even\
    \ = val\n            min_index = i\n        end\n    end\n    if min_even == Inf\n\
    \        return []\n    end\n    return [min_even, min_index]\nend", "    # this\
    \ vector stores the [smallest value, index]\n    smallestEven = [0, 0]\n    #\
    \ base case, if the vector is empty we return an empty vector\n    if isempty(arr)\n\
    \        return []\n    end\n    # iterate through the vector\n    for i in 1:length(arr)\n\
    \        # if the current value is even and it is the first even value or it is\
    \ smaller than the current smallest value\n        if (arr[i] % 2 == 0) && (smallestEven[1]\
    \ == 0 || arr[i] < smallestEven[1])\n            # update the smallestEven vector\n\
    \            smallestEven = [arr[i], i]\n        end\n    end\n    # return the\
    \ smallestEven vector\n    return smallestEven\nend", "    if length(arr) < 1\n\
    \        return []\n    end\n    even_nodes = Array{Int64}[]\n    for node in\
    \ arr\n        if node % 2 == 0\n            push!(even_nodes, node)\n       \
    \ end\n    end\n    if length(even_nodes) < 1\n        return []\n    end\n  \
    \  min_node = minimum(even_nodes)\n    min_index = find(arr .== min_node)[1]\n\
    \    return [min_node, min_index]\nend", "    if length(arr) == 0\n        return\
    \ []\n    end\n    evenVals = []\n    evenValsIndx = []\n    for i in 1:length(arr)\n\
    \        if arr[i] % 2 == 0\n            push!(evenVals, arr[i])\n           \
    \ push!(evenValsIndx, i)\n        end\n    end\n    if length(evenVals) == 0\n\
    \        return []\n    end\n    evenValsMin = findmin(evenVals)[1]\n    evenValsMinIndx\
    \ = findall(evenVals .== evenValsMin)[1]\n    return [evenValsMin, evenValsMinIndx]\n\
    end", "    # Step 1: Check if empty array\n    if isempty(arr)\n        return\
    \ []\n    end\n    \n    # Step 2: Initialise variables\n    idx = nothing\n \
    \   smallest = 1e12\n    \n    # Step 3: Loop over elements, checking if it's\
    \ even\n    for i in 1:length(arr)\n        if arr[i] % 2 == 0 && arr[i] < smallest\n\
    \            smallest = arr[i]\n            idx = i\n        end\n    end\n  \
    \  \n    # Step 4: Check if there are no even values\n    if idx == nothing\n\
    \        return []\n    end\n    \n    # Step 5: Return result\n    return [smallest,\
    \ idx]\nend", "    filtered = sort(arr[mod.(arr, 2) .== 0]);\n    if isempty(filtered)\n\
    \        return []\n    else\n        index = findfirst(arr, filtered[1]);\n \
    \       return [filtered[1], index];\n    end\nend", "    even_idx = findall(arr\
    \ .% 2 .== 0)\n    if isempty(even_idx)\n        return []\n    end\n    v = sort(arr[even_idx])\n\
    \    return [v[1], even_idx[1]]\nend", "    smallestEvenValue = Inf\n    smallestEvenIndex\
    \ = NaN\n    for i in 1:length(arr)\n        arrValue = arr[i]\n        if (isEven(arrValue)\
    \ && arrValue < smallestEvenValue)\n            smallestEvenValue = arrValue\n\
    \            smallestEvenIndex = i\n        end\n    end\n    if (smallestEvenValue\
    \ != Inf)\n        [smallestEvenValue, smallestEvenIndex]\n    else\n        []\n\
    \    end\nend", "    evens = []\n    for (index,value) in enumerate(arr)\n   \
    \     if value % 2 == 0\n            push!(evens, [value, index])\n        end\n\
    \    end\n    if length(evens) == 0\n        return []\n    end\n    min_index\
    \ = 1\n    min_value = evens[1][1]\n    for (index,even) in enumerate(evens)\n\
    \        if even[1] < min_value\n            min_value = even[1]\n           \
    \ min_index = index\n        end\n    end\n    return evens[min_index]\nend",
  "    to_return = []\n    if length(arr) == 0\n        return to_return\n    end\n\
    \    small_value = \"inf\"\n    for (i, value) in enumerate(arr)\n        if value\
    \ % 2 == 0 && value < small_value\n            small_value = value\n         \
    \   to_return = [value, i]\n        end\n    end\n    if small_value == \"inf\"\
    \n        return []\n    end\n    return to_return\nend", "    if length(arr)\
    \ == 0\n        return []\n    end\n    smallest_index = 1\n    smallest_value\
    \ = minimum(filter(x -> x != 0 && iseven(x), arr))\n    for i = 1:length(arr)\n\
    \        if arr[i] == smallest_value\n            smallest_index = i\n       \
    \     break\n        end\n    end\n    return [smallest_value, smallest_index]\n\
    end\n\"\"\"\n    \"Given a string with many words,\n    your task is to return\
    \ the word with the highest frequency,\n    along with the number of times that\
    \ it occurs.\n    If there are multiple words that appear the same maximum number\
    \ of times,\n    return the word with the smallest index in the given string.",
  "    if isempty(arr)\n        return Vector{Int64}()\n    end\n    even_nodes =\
    \ arr[arr .% 2 .== 0]\n    if isempty(even_nodes)\n        return Vector{Int64}()\n\
    \    end\n    even_nodes_smallest = minimum(even_nodes)\n    idx = findfirst(arr,\
    \ even_nodes_smallest)\n    return [even_nodes_smallest, idx]\nend", "    \n \
    \   if size(arr, 1) == 0\n        return []\n    end\n    \n    index = size(arr,\
    \ 1)\n    for i in 1:size(arr, 1)\n        if arr[i] % 2 == 0 && arr[i] < arr[index]\n\
    \            index = i\n        end\n    end\n    \n    if arr[index] % 2 == 0\n\
    \        return [arr[index], index]\n    else\n        return []\n    end\nend",
  "    indexes_evens = findall(isodd, arr)\n    if !isempty(indexes_evens)\n     \
    \   return arr[indexes_evens[1]]\n    else\n        return []\n    end\nend",
  "    # TODO: write your code here\n    return []\nend", "    \"\"\"\n    Given a\
    \ vector representing a branch of a tree that has non-negative integer nodes\n\
    \    your task is to pluck one of the nodes and return it.\n    The plucked node\
    \ should be the node with the smallest even value.\n    If multiple nodes with\
    \ the same smallest even value are found return the node that has smallest index.",
  "    # your code here\n    even_arr = [i for i in arr if i % 2 == 0]\n    sorted_even_arr\
    \ = sort(even_arr)\n    if length(sorted_even_arr) != 0\n        smallest_even\
    \ = sorted_even_arr[1]\n        for i = 1:length(arr)\n            if arr[i] ==\
    \ smallest_even\n                return [smallest_even, i]\n            end\n\
    \        end\n    else\n        return []\n    end\nend", "    # check if the\
    \ array is empty\n    if isempty(arr) \n        return []\n    end\n    # get\
    \ the even numbers\n    evens = arr[ arr .% 2 .== 0 ]\n    # check if the array\
    \ has no even numbers\n    if isempty(evens)\n        return []\n    end\n   \
    \ # the smallest even number\n    min_even = minimum(evens)\n    # find the index\
    \ of the first occurrence of the smallest even number\n    index = findfirst(arr\
    \ .== min_even)\n    # return the smallest even number and its index\n    return\
    \ [min_even, index]\nend", "    return [e for e in arr if e % 2 == 0 ? first(sort(e)),\
    \ findfirst(arr, e)[1] : nothing]\nend\n    ", "    if length(arr) == 0\n    \
    \    return []\n    end\n    min_index = 1\n    min_value = arr[1]\n    for index\
    \ in 2:length(arr)\n        if iseven(arr[index]) && min_value > arr[index]\n\
    \            min_index = index\n            min_value = arr[index]\n        end\n\
    \    end\n    if iseven(min_value)\n        return [min_value, min_index]\n  \
    \  else\n        return []\n    end\nend\n# iseven()\n\"\"\"\n    \"Given a number\
    \ your task is to determine if it is even or not.", "    \"\"\"\n    pluck the\
    \ node with the smallest even value, return an array\n    \"\"\"\n    #an empty\
    \ array\n    if isempty(arr)\n        return []\n    end\n    #find the smallest\
    \ even value in the array\n    min_even = min(setdiff(arr, range(1, stop=maximum(arr),\
    \ step=2)))\n    #find the index of the min_even\n    index = findall(arr .==\
    \ min_even)[1]\n    return [min_even, index]\nend\nprintln(pluck([5, 0, 3, 0,\
    \ 4, 2]))", "    arr = arr[findall(x -> iseven(x), arr)]\n    n = length(arr)\n\
    \    if n != 0\n        return [minimum(arr), findfirst(arr, minimum(arr))]\n\
    \    else\n        return []\n    end\nend", "    arr = filter(x -> iseven(x),\
    \ arr)\n    if length(arr) == 0\n        return []\n    end\n    arr = sort(arr)\n\
    \    arr = [arr[1], findfirst(arr, arr[1])]\n    return arr\nend", "    res =\
    \ [0,0]\n    # your code here\n    return res\nend\n    ", "    #TODO: finish\
    \ this\nend", "    arr = [i for i in arr if iseven(i)]\n    isempty(arr) && return\
    \ []\n    v = minimum(arr)\n    return [v, findfirst(arr, v)]\nend", "    smallest_even_value::Int64\
    \ = nothing\n    even_value_index::Int64 = nothing\n    for (index, value) in\
    \ enumerate(arr)\n        if rem(value, 2) == 0\n            if smallest_even_value\
    \ == nothing\n                smallest_even_value = value\n                even_value_index\
    \ = index\n            elseif value < smallest_even_value\n                smallest_even_value\
    \ = value\n                even_value_index = index\n            end\n       \
    \ end\n    end\n    return [smallest_even_value, even_value_index]\nend", "  \
    \  if arr == [] return [] end\n    if even(arr[1])\n        return [arr[1], 1]\n\
    \    end\n    even_arr = pluck(filter(x -> even(x), arr))\n    if even_arr ==\
    \ [] return [] end\n    tmp = searchsortedfirst(arr, even_arr[1])\n    return\
    \ [even_arr[1], tmp]\nend", "    # Your code goes here...\n    lenght = length(arr)\n\
    \    index = 1\n    min_value = maximum(arr)\n    min_index = 1\n    while index\
    \ <= lenght\n        if (arr[index] <= min_value) & (arr[index] % 2 == 0)\n  \
    \          min_value = arr[index]\n            min_index = index\n        end\n\
    \        index += 1\n    end\n    if min_value == maximum(arr)\n        return\
    \ []\n    else\n        return [min_value, min_index]\n    end\nend\npluck([4,\
    \ 2, 3])", "    # The first element that is even and then smaller than the next\
    \ even element or\n    # the last even element if there is no such.\n    return\
    \ [arr[i] for i in 1:length(arr) if iseven(arr[i])][1]\nend", "    # Verify edge\
    \ case\n    if isempty(arr)\n        return []\n    end\n    \n    # Create a\
    \ container to store even value and index\n    evenArr = Vector{Int64}()\n   \
    \ \n    # Search through array\n    for i in 1:length(arr)\n        if arr[i]\
    \ % 2 == 0\n            push!(evenArr, [arr[i], i])\n        end\n    end\n  \
    \  \n    # If there is no even values in array\n    if isempty(evenArr)\n    \
    \    return []\n    end\n    \n    # Sort array by even values ascendingly\n \
    \   # In case if even values are same, sort by its index ascendingly\n    sort!(evenArr,\
    \ by = x -> (x[1], x[2]))\n    \n    # Return the first element in evenArr\n \
    \   return evenArr[1]\nend", "    # Check if array is empty\n    if isempty(arr)\n\
    \        return []\n    end\n    \n    # Find even values and their indices\n\
    \    even_values = []\n    even_indices = []\n    for (index, value) in enumerate(arr)\n\
    \        if value % 2 == 0\n            push!(even_values, value)\n          \
    \  push!(even_indices, index)\n        end\n    end\n    \n    # Check if there\
    \ are even values\n    if isempty(even_values)\n        return []\n    end\n \
    \   \n    # Find lowest value\n    low_value = minimum(even_values)\n    \n  \
    \  # Get indices of the lowest value\n    low_indices = []\n    for (index, value)\
    \ in enumerate(even_values)\n        if value == low_value\n            push!(low_indices,\
    \ even_indices[index])\n        end\n    end\n    \n    # Find lowest index\n\
    \    low_index = minimum(low_indices)\n    \n    # Return plucked value\n    return\
    \ [low_value, low_index]\nend", "    return pluck(arr, Int64[])\nend", "    smallestIndex\
    \ = 0\n    smallestEvenVal = 1\n    for (index, val) in enumerate(arr)\n     \
    \   if (val % 2 == 0) && (val < smallestEvenVal)\n            smallestEvenVal\
    \ = val\n            smallestIndex = index\n        end\n    end\n    if smallestEvenVal\
    \ == 1\n        return []\n    end\n    return [smallestEvenVal, smallestIndex]\n\
    end", "    return arr[findfirst(x -> iseven(x), arr)]\nend", "    even = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(even) == 0\n        return []\n    end\n\
    \    even_min = minimum(even)\n    idx = findall(x -> x == even_min, arr)[1]\n\
    \    return [even_min, idx]\nend", "    return []\nend", "    if isempty(arr)\n\
    \        return []\n    end\n    if isempty(filter(i -> i%2 == 0, arr))\n    \
    \    return []\n    end\n    min_even = minimum(filter(i -> i%2 == 0, arr))\n\
    \    min_index = find(arr.==min_even)[1]\n    return [min_even, min_index]\nend",
  "    even_pos = findall(x -> x % 2 == 0, arr)\n    if length(even_pos) == 0\n  \
    \      return Vector{Int64}()\n    end\n    even_smallest_value = findfirst(x\
    \ -> x % 2 == 0, arr)\n    even_smallest_index = findfirst(even_pos .== even_smallest_value)\n\
    \    return [even_smallest_value, even_smallest_index]\nend", "    if isempty(arr)\n\
    \        return []\n    end\n    even_values = []\n    for (i, a) in enumerate(arr)\n\
    \        if iseven(a)\n            push!(even_values, (a, i))\n        end\n \
    \   end\n    if isempty(even_values)\n        return []\n    end\n    return minimum(even_values)[:]\n\
    end\npluck([4, 2, 3])", "    # function to check if an integer is even or not\n\
    \    even(x::Int64) = (x % 2 == 0 ? true : false)", "    dtype = Vector{Int64}\n\
    \    indices = []\n    even = []\n    for i in 1:length(arr)\n        if iseven(arr[i])\n\
    \            push!(even, arr[i])\n            push!(indices, i)\n        end\n\
    \    end\n    if length(even) > 0\n        minimum = minimum(even)\n        indx\
    \ = findall(even .== minimum)[1]\n        return [minimum, indices[indx]]\n  \
    \  else\n        return []\n    end\nend", "    if length(arr) > 0\n        if\
    \ length(arr[arr .% 2 .== 0]) > 0\n            index = findfirst(arr, minimum(arr[arr\
    \ .% 2 .== 0]))\n            return [arr[index], index]\n        else\n      \
    \      return []\n        end\n    else\n        return []\n    end\nend", " \
    \   candidates = []\n    idx = []\n    for (i, n) in enumerate(arr)\n        if\
    \ n % 2 == 0\n            push!(candidates, n)\n            push!(idx, i)\n  \
    \      end\n    end\n    if length(candidates) == 0\n        return []\n    end\n\
    \    min_candidate = minimum(candidates)\n    min_idx = findmin(candidates)[2]\n\
    \    return [min_candidate, idx[min_idx]]\nend", "    evens = arr[mod.(arr, 2)\
    \ .== 0] # Get all values that are even\n    if isempty(evens)\n        return\
    \ []\n    end\n    min = minimum(evens)\n    min_i = findfirst(arr, min) # Find\
    \ the index of the smallest value \n    return [min, min_i]\nend", "    \n   \
    \ if length(arr) == 0\n        return []\n    end\n    \n    smallest_even = Inf\n\
    \    smallest_index = Inf\n    \n    for node in 1:length(arr)\n        if mod(arr[node],\
    \ 2) == 0\n            if arr[node] < smallest_even\n                smallest_even\
    \ = arr[node]\n                smallest_index = node\n            end\n      \
    \  end\n    end\n    \n    if smallest_even == Inf\n        return []\n    end\n\
    \    \n    return [smallest_even, smallest_index]\nend", "    # Check if there\
    \ is any even numbers\n    evens = [n for n in arr if iseven(n)]", "    evens\
    \ = [ x for x in arr if x % 2 == 0 ]\n    if length(evens) == 0\n        return\
    \ []\n    end\n    return [ minimum(evens), findfirst(arr, minimum(evens)) ]\n\
    end", "    if length(arr) == 0\n        return []\n    end\n    evens = []\n \
    \   for i = 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens,\
    \ arr[i])\n        end\n    end\n    if length(evens) == 0\n        return []\n\
    \    end\n    minindex = indmin(evens)\n    minvalue = evens[minindex]\n    indices\
    \ = findall(arr .== minvalue)\n    return [minvalue, minimum(indices)]\nend",
  "    \n    even_index_arr = [i for i in 1:length(arr) if iseven(arr[i])]\n    even_val_arr\
    \ = [arr[i] for i in even_index_arr]\n    \n    # If there are no even values\
    \ or the given vector is empty\n    if length(even_val_arr) == 0\n        return\
    \ []\n    end\n    \n    min_even_val = findmin(even_val_arr)[1]\n    min_even_index\
    \ = findmin(even_index_arr)[1]\n    \n    return [min_even_val, min_even_index]\n\
    end", "    if isempty(arr) || (reduce(max, arr) < 2)\n        return Int64[]\n\
    \    end\n    filtered_even_array = Array{Int64}(filter(x -> x%2 == 0, arr))\n\
    \    min_even_value = reduce(min, filtered_even_array)\n    min_even_value_index\
    \ = findfirst(arr, min_even_value)\n    return [min_even_value, min_even_value_index]\n\
    end", "    even_idx = findall(i -> i % 2 == 0, arr)\n    if length(even_idx) ==\
    \ 0\n        return []\n    end\n    min_idx = even_idx[argmin(arr[even_idx])]\n\
    \    return [arr[min_idx], min_idx]\nend\n \n```", "    if isempty(arr)\n    \
    \    return []\n    end\n    idx = 1\n    min = Inf\n    for i = 1:length(arr)\n\
    \        if mod(arr[i], 2) == 0\n            if arr[i] < min\n               \
    \ min = arr[i]\n                idx = i\n            end\n        end\n    end\n\
    \    if min == Inf\n        return []\n    end\n    return [min, idx]\nend\n@testset\
    \ \"can handle an empty vector\" begin\n    @test pluck([]) == []\nend\n@testset\
    \ \"can handle a vector with only odd values\" begin\n    @test pluck([1, 3, 5])\
    \ == []\nend\n@testset \"can handle a vector with only even values\" begin\n \
    \   @test pluck([2, 4, 6]) == [2, 1]\nend\n@testset \"can handle a vector with\
    \ only one even value\" begin\n    @test pluck([5, 7, 1, 2]) == [2, 4]\nend\n\
    @testset \"can handle a vector with multiple even values\" begin\n    @test pluck([5,\
    \ 6, 7, 3, 8, 4]) == [4, 6]\nend\n@testset \"can handle a vector with multiple\
    \ even values of the same value\" begin\n    @test pluck([5, 0, 3, 0, 4, 2]) ==\
    \ [0, 1]\nend", "    ans = [0, 0]\n    for i in eachindex(arr)\n        if (arr[i]\
    \ % 2 == 0) & (ans[1] == 0)\n            ans[1] = arr[i]\n            ans[2] =\
    \ i\n        elseif (arr[i] % 2 == 0) & (arr[i] < ans[1])\n            ans[1]\
    \ = arr[i]\n            ans[2] = i\n        end\n    end\n    return ans\nend",
  "    \"\"\"\n    This function takes a vector of ints and returns a vector of the\
    \ smallest even value and its index.\n    If there are no even values or the given\
    \ vector is empty, return [].\n    \"\"\"\n    if isempty(arr) || length(arr)\
    \ > 10000 || !all(isinteger, arr) || !all(x->x >= 0, arr)\n        return []\n\
    \    end\n    evens = filter(!isodd, arr)\n    if !isempty(evens)\n        return\
    \ [minimum(evens), findfirst(arr, minimum(evens))]\n    else\n        return []\n\
    \    end\nend", "    # If the array has no even values or the given vector is\
    \ empty, return nothing.\n    if isempty(arr) || all(x->x%2 != 0, arr)\n     \
    \   return []\n    end\n    \n    # Find the minimum even value in the array.\n\
    \    smallest_value = minimum(arr[arr .% 2 .== 0])\n    \n    # Find the index\
    \ of the minimum even value in the array.\n    smallest_index = findfirst(arr,\
    \ smallest_value)\n    \n    # Return the minimum even value and its index.\n\
    \    return [smallest_value, smallest_index]\nend", "    evens = findall(x ->\
    \ (x % 2 == 0), arr)\n    if !isempty(evens)\n        return [minimum(evens),\
    \ findfirst(arr, minimum(evens))]\n    else\n        return []\n    end\nend",
  "    # first check the length of the array to \n    #   1) avoid the error of calling\
    \ an empty array\n    #   2) stop the function if the array is empty\n    if length(arr)\
    \ == 0\n        return []\n    end\n    @assert length(arr) <= 10000", "    evens\
    \ = filter(x -> (x == 0) || (x % 2 == 0), arr)\n    min_even = minimum(evens)\n\
    \    min_index = minimum(findall(x -> x == min_even, arr))\n    return [min_even,\
    \ min_index]\nend", "    min_even_value = 2\n    min_even_value_pos = 0\n    for\
    \ i in 1:length(arr)\n        if (arr[i] < min_even_value) && (arr[i] % 2 == 0)\n\
    \            min_even_value = arr[i]\n            min_even_value_pos = i\n   \
    \     end\n    end\n    if min_even_value_pos != 0\n        return [min_even_value,\
    \ min_even_value_pos]\n    else\n        return []\n    end\nend", "  even_idx\
    \ = findall(x -> x % 2 == 0, arr)\n  if length(even_idx) == 0\n    return []\n\
    \  end\n  smallest_value = minimum(arr[even_idx])\n  smallest_idx = minimum(even_idx)\n\
    \  return [smallest_value, smallest_idx]\nend", "    # your code goes here\n \
    \   min_even = get_min_even(arr)\n    if min_even == -1 \n        return []\n\
    \    end\n    return [min_even, minimum(findall(x -> x == min_even, arr))]\nend",
  "    smallest_value = -1\n    smallest_index = -1\n    for i in 1:length(arr)\n\
    \        if (arr[i] % 2 == 0) & (smallest_value == -1)\n            smallest_value\
    \ = arr[i]\n            smallest_index = i\n        elseif (arr[i] % 2 == 0) &\
    \ (arr[i] < smallest_value)\n            smallest_value = arr[i]\n           \
    \ smallest_index = i\n        end\n    end\n    if smallest_value == -1\n    \
    \    return []\n    else\n        return [smallest_value, smallest_index]\n  \
    \  end\nend", "    # If the array is empty return empty vector\n    if isempty(arr)\n\
    \        return [Int64[]]\n    end\n    min = arr[1]\n    # Find the minimum value\
    \ in the array\n    for i in arr\n        if i < min\n            min = i\n  \
    \      end\n    end\n    # Find the index of the minimum value and return the\
    \ the smallest value and its index\n    return [min, findfirst(x -> x == min,\
    \ arr)]\nend", "    small_index = 0\n    small_value = 0\n    for (index, value)\
    \ in enumerate(arr)\n        if value % 2 == 0\n            if small_value ==\
    \ 0\n                small_value = value\n                small_index = index\n\
    \            elseif value < small_value\n                small_value = value\n\
    \                small_index = index\n            end\n        end\n    end\n\
    \    if small_value == 0\n        return []\n    else\n        return [small_value,\
    \ small_index]\n    end\nend", "    # checks if the vector is empty\n    if isempty(arr)\n\
    \        return Vector{Int64}()\n    end\n    # gets all even values of the vector\n\
    \    even_vals = arr[arr .% 2 .== 0]\n    # checks if there is an even values\
    \ in the vector\n    if isempty(even_vals)\n        return Vector{Int64}()\n \
    \   end\n    # gets the min of the even values\n    min_val = minimum(even_vals)\n\
    \    # gets the index of the min value\n    ind = find(arr .== min_val, 1)\n \
    \   # returns the two values in a vector\n    return [min_val, ind]\nend", " \
    \   \"\"\"\n    Function that plucks the smallest even element from the array\n\
    \    \"\"\"\n    if isempty(arr) #check if the array is empty\n        return\
    \ []\n    end\n    arr_evens = filter(x -> x % 2 == 0, arr) #filter for even values\n\
    \    if isempty(arr_evens) #if no even values are present, return an empty array\n\
    \        return []\n    end\n    min_even = minimum(arr_evens) #get the smallest\
    \ even value\n    index_min_even = findall(arr .== min_even)[1] #find the index\
    \ of the smallest even value\n    return [min_even, index_min_even]\nend", " \
    \   even_indices = findall(x -> rem(x, 2) == 0, arr)\n    even_indices = sort(even_indices)\n\
    \    if isempty(even_indices)\n        return []\n    else\n        even_arr =\
    \ arr[even_indices]\n        index = findfirst(even_arr .== minimum(even_arr))\n\
    \        return [even_arr[index], even_indices[index]]\n    end\nend", "    if\
    \ length(arr) == 0\n        return []\n    end\n    arr = arr[arr .% 2 .== 0]\
    \ # filter odd numbers\n    if length(arr) == 0\n        return []\n    end\n\
    \    i = findfirst(arr, minimum(arr))\n    return [arr[i], i]\nend", "    \n \
    \   if isempty(arr)\n        return []\n    end\n    \n    min_even_value = Inf\n\
    \    min_even_index = -1\n    \n    for (i, el) in enumerate(arr)\n        if\
    \ iseven(el) && el < min_even_value\n            min_even_value = el\n       \
    \     min_even_index = i\n        end\n    end\n    \n    if min_even_index ==\
    \ -1\n        return []\n    end\n    \n    return [min_even_value, min_even_index]\n\
    end", "    n = size(arr)[1]\n    if n == 0\n        return []\n    end\n    min_index\
    \ = 0\n    min_value = 10^8\n    for i = 1:n\n        if arr[i] != 0 && arr[i]\
    \ % 2 == 0 && arr[i] < min_value\n            min_value = arr[i]\n           \
    \ min_index = i\n        end\n    end\n    if min_value == 10^8\n        return\
    \ []\n    end\n    return [min_value, min_index]\nend", "    sorted_evens = sort(filter(node\
    \ -> node % 2 == 0, arr))\n    head(sorted_evens) == 0 ? [0, findfirst(arr, 0)]\
    \ : [head(sorted_evens), findfirst(arr, head(sorted_evens))]\nend", "    if length(arr)\
    \ == 0\n        return []\n    end\n    idx = findfirst(iseven, arr)\n    if isempty(idx)\n\
    \        return []\n    end\n    smallest = arr[idx]\n    for i in findnext(iseven,\
    \ arr, idx)\n        if arr[i] < smallest\n            smallest = arr[i]\n   \
    \         idx = i\n        end\n    end\n    return [smallest, idx]\nend\n\"\"\
    \"\n    Given a list of strings \"words\" and a letter \"letter\",\n    return\
    \ a list of all the words that contain at least one of the letter, \n    and the\
    \ letter itself is \n    at the beginning of the word.\n    In addition, the words\
    \ should be sorted by their length.\n    If no words have the given letter at\
    \ the beginning return an empty list [].", "    if length(arr) == 0\n        return\
    \ []\n    end\n    small = nothing\n    place = nothing\n    for i in 1:length(arr)\n\
    \        if iseven(arr[i]) && isnothing(small)\n            small = arr[i]\n \
    \           place = i\n        elseif iseven(arr[i]) && arr[i] < small\n     \
    \       small = arr[i]\n            place = i\n        end\n    end\n    if isnothing(small)\n\
    \        return []\n    end\n    return [small, place]\nend", "    # Write your\
    \ code here!\n    @assert length(arr) <= 10000\n    is_even(x) = x % 2 == 0\n\
    \    smalest_value = 10001\n    for value in arr\n        @assert value >= 0\n\
    \        if is_even(value) && value < smalest_value\n            smalest_value\
    \ = value\n        end\n    end\n    isempty(smalest_value) && return []\n   \
    \ index = findall(arr .== smalest_value)[1]\n    return [smalest_value, index]\n\
    end\n```", "   \n    min_value = 1e9\n    min_index = 1e9\n    for (index,value)\
    \ in enumerate(arr)\n        if mod(value,2) == 0\n            if value < min_value\n\
    \                min_value = value\n                min_index = index\n      \
    \      end\n        end\n    end\n    \n    if min_value == 1e9 || min_index ==\
    \ 1e9\n        return []\n    else\n        return [min_value, min_index]\n  \
    \  end\nend", "    v = filter(x -> x%2 == 0, arr)\n    [minimum(v), argmin(arr,\
    \ x -> x%2 == 0)]\nend", "    if isempty(arr)\n        return []\n    end\n  \
    \  even_arr = filter(x -> x % 2 == 0, arr)\n    if isempty(even_arr)\n       \
    \ return []\n    end\n    value = minimum(even_arr)\n    idx = argmin(even_arr)\n\
    \    return [value, idx]\nend", "    # setup\n    min_index = 10000\n    min_value\
    \ = 10000\n    # iterate through the array\n    for index in 1:length(arr)\n \
    \       # check if the element is even and less than the current smallest values\n\
    \        if mod(arr[index], 2) == 0 && arr[index] < min_value\n            # update\
    \ the smallest values\n            min_value = arr[index]\n            min_index\
    \ = index\n        end\n    end\n    # return empty vector if no even values\n\
    \    if min_value == 10000 && min_index == 10000\n        return []\n    else\n\
    \        return [min_value, min_index]\n    end\nend\n```\n### Problem 3\n```julia\n\
    \"\"\"\n    \"Given a matrix that has non-negative integer values. Your task is\
    \ to find the smallest value in the matrix and return its index.\n    If multiple\
    \ of the same smallest values are found return the index of the one with the smallest\
    \ row index.", "    if isempty(arr)\n        return []\n    end\n    start_index\
    \ = 1\n    end_index = length(arr)\n    mid_index = Int64(ceil(start_index + (end_index\
    \ - start_index)/2))\n    even_index = find_even_index(arr, start_index, end_index,\
    \ mid_index)\n    if even_index == -1\n        return []\n    end\n    even_value\
    \ = arr[even_index]\n    even_index = even_index\n    for i in 1:length(arr)\n\
    \        if arr[i] == even_value && i < even_index\n            even_index = i\n\
    \        end\n    end\n    return [even_value, even_index]\nend", "    # This\
    \ function will only work on vectors of length 2 or less.\n    if isempty(arr)\n\
    \        return []\n    elseif length(arr) == 1 && iseven(arr[1])\n        return\
    \ [arr[1], 1]\n    elseif length(arr) == 1 && isodd(arr[1])\n        return []\n\
    \    elseif length(arr) == 2\n        if iseven(arr[1])\n            return [arr[1],\
    \ 1]\n        elseif iseven(arr[2])\n            return [arr[2], 2]\n        else\n\
    \            return []\n        end\n    end\n    \n    # This function will work\
    \ on vectors of any length.\n    if isempty(arr)\n        return []\n    elseif\
    \ length(arr) == 1 && iseven(arr[1])\n        return [arr[1], 1]\n    elseif length(arr)\
    \ == 1 && isodd(arr[1])\n        return []\n    else\n        even_nums = []\n\
    \        for num in arr\n            if iseven(num)\n                push!(even_nums,\
    \ num)\n            end\n        end\n        # If there are no even numbers,\
    \ return [].\n        if isempty(even_nums)\n            return []\n        else\n\
    \            even_nums = sort(even_nums)\n            position = findfirst(x ->\
    \ x == even_nums[1], arr)\n            return [even_nums[1], position]\n     \
    \   end\n    end\nend", "    if isempty(arr) || !any(isodd, arr)\n        return\
    \ []\n    end\n    # Find smallest even value and its index.\n    i, even_min\
    \ = findmin(arr)\n    if isodd(even_min)\n        even_min = findnext(arr, i,\
    \ true)\n    end\n    # Find smallest odd value and its index.\n    i, odd_min\
    \ = findmin(arr)\n    if iseven(odd_min)\n        odd_min = findnext(arr, i, false)\n\
    \    end\n    # Return the smallest even value and its index.\n    # If there\
    \ is no even value, the function will return the odd_min and its index.\n    return\
    \ [even_min, i]\nend", "    if isempty(arr) || all(x->x%2!=0, arr)\n        return\
    \ []\n    end\n    evens = [evens(x, arr) for x in 1:length(arr)]\n    smallest_even\
    \ = minimum(evens)\n    ind = findfirst(eq(smallest_even), evens)\n    return\
    \ [smallest_even, ind]\nend", "    empty!(result)\n    if arr == []\n        return\
    \ []\n    end\n    n = size(arr, 1)\n    result = [NaN, NaN]\n    for i in 1:n\n\
    \        if iseven(arr[i]) && (isnan(result[1]) || arr[i] < result[1])\n     \
    \       result = [arr[i], i]\n        end\n    end\n    if isnan(result[1])\n\
    \        empty!(result)\n    end\n    return result\nend", "    filtered = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(filtered)\n        return []\n    end\n\
    \    minimum_value = minimum(filtered)\n    index = findfirst(arr, minimum_value)\n\
    \    return [minimum_value, index]\nend", "    smalest_even_value, its_index =\
    \ nothing, nothing\n    for index in 1:length(arr)\n        if arr[index] % 2\
    \ == 0 && arr[index] < smalest_even_value\n            smalest_even_value, its_index\
    \ = arr[index], index\n        end\n    end\n    if smalest_even_value == nothing\n\
    \        return []\n    else\n        return [smalest_even_value, its_index]\n\
    \    end\nend\nprintln(pluck([4, 2, 3]))\nprintln(pluck([1, 2, 3]))\nprintln(pluck([]))\n\
    println(pluck([5, 0, 3, 0, 4, 2]))", "    # check if arr is empty, then return\
    \ empty vector\n    if isempty(arr)\n        return []\n    end\n    # loop over\
    \ arr to check if there is an even number\n    for i in 1:length(arr)\n      \
    \  # if there is an even number, check if it is even\n        if i % 2 == 0\n\
    \            return [i, findfirst(arr, i)]\n        end\n    end\n    # else return\
    \ empty vector\n    return []\nend", "    if isempty(arr)\n        return []\n\
    \    end\n    min_even_value = 999999\n    min_even_index = -1\n    for (i, x)\
    \ in enumerate(arr)\n        if x % 2 == 0\n            if x < min_even_value\n\
    \                min_even_value = x\n                min_even_index = i\n    \
    \        end\n        end\n    end\n    if min_even_index == -1\n        return\
    \ []\n    end\n    return [min_even_value, min_even_index]\nend", "    \n    #\
    \ if the array is empty, return an empty array\n    if length(arr) == 0\n    \
    \    return []\n    end\n    \n    # find the first even number \n    for i in\
    \ eachindex(arr)\n        if arr[i] % 2 == 0\n            return [arr[i], i]\n\
    \        end\n    end\n    \n    # there were no even numbers, return an empty\
    \ array\n    return []\nend", "    vals = [x for x in arr if x % 2 == 0]\n   \
    \ if isempty(vals) return [] end\n    minval = minimum(vals)\n    minindex = findfirst(arr,\
    \ minval)\n    return [minval, minindex]\nend", "    if isempty(arr)\n       \
    \ return Int64[]\n    end\n    smallest_even = 0\n    for i in arr\n        if\
    \ i % 2 == 0\n            smallest_even = i\n            break\n        end\n\
    \    end\n    if smallest_even == 0\n        return Int64[]\n    end\n    idx\
    \ = findfirst(arr, smallest_even)\n    return [smallest_even, idx]\nend", "  evens\
    \ = filter(arr) do x\n    x % 2 == 0\n  end\n  indices = findall(arr .== minimum(evens))\n\
    \  if (length(indices) == 0)\n    return []\n  end\n  minimum(indices)\n  return\
    \ [arr[minimum(indices)], minimum(indices)]\nend", "    p = []\n    for (ind,x)\
    \ in enumerate(arr)\n        if x % 2 == 0\n            push!(p, [x, ind])\n \
    \       end\n    end\n    if !isempty(p)\n        min_arr = p[1]\n        for\
    \ i in 2:length(p)\n            if p[i][1] < min_arr[1]\n                min_arr\
    \ = p[i]\n            end\n        end\n        return min_arr\n    else\n   \
    \     return []\n    end\nend", "  evens = [x for x in arr if x % 2 == 0]\n  if\
    \ (isempty(evens))\n    return []\n  end\n  idx = findfirst(arr .== minimum(evens))\n\
    \  return [arr[idx], idx]\nend", "    # ========\n    # 1. PREAMBLE:\n    # ========\n\
    \    if isempty(arr)\n        return []\n    end\n    # ========\n    # 2. MAIN:\n\
    \    # ========\n    evenArr = arr[isodd.(arr).==false] # all even nodes\n   \
    \ if isempty(evenArr)\n        return []\n    end\n    idx = findmin(evenArr)[2]\n\
    \    return [evenArr[idx], idx]\nend", "    \"\"\"\n    The function should take\
    \ an array of non-negative integers and return a vector with two elements,\n \
    \   The first element is the smallest even value in the vector, if there is no\
    \ even values return 0\n    The second element is the index of the smallest even\
    \ value in the vector, if there is no even values return 0\n    \"\"\"\n    #\
    \ First, we initialize a tuple with a 0 as the first element and a 0 as the second\
    \ element\n    minimum_even_value_and_index = (0, 0)\n    # Then we loop through\
    \ the array, checking if each element is even, \n    # and if it is we see if\
    \ the element is smaller than the one in the tuple,\n    # if it is we change\
    \ the tuple to contain the new minimum and index\n    for (index, element) in\
    \ enumerate(arr)\n        if iseven(element)\n            if element < minimum_even_value_and_index[1]\n\
    \                minimum_even_value_and_index = (element, index)\n           \
    \ end\n        end\n    end\n    # Finally, we return a vector with the elements\
    \ of the tuple,\n    # but we subtract one from the index, since it is a vector\
    \ index\n    return [minimum_even_value_and_index[1], minimum_even_value_and_index[2]\
    \ - 1]\nend", "    if isempty(arr)\n        return [0, 0]\n    end\n    s = sort(arr,\
    \ rev=true)\n    pos = -1\n    for i in eachindex(s)\n        if rem(s[i], 2)\
    \ == 0\n            pos = i\n            break\n        end\n    end\n    if pos\
    \ == -1\n        return [0, 0]\n    end\n    for j in pos:length(s)\n        if\
    \ s[j] < s[pos]\n            pos = j\n        end\n    end\n    res = [s[pos],\
    \ search(arr, s[pos])]\n    return res\nend", "  \"\"\"\n  This function takes\
    \ in a vector of integers and returns the smallest even number in the vector and\
    \ its index in a new vector.\n  \"\"\"\n  if length(arr) == 0\n    return Vector{Int64}()\n\
    \  end\n  sorted_arr = sort(arr)\n  for x in sorted_arr\n    if x % 2 == 0\n \
    \     return [x, indmax(arr .== x)]\n    end\n  end\n  return []\nend", "    sm_idx,\
    \ sm_val = 0, 0\n    if !isempty(arr)\n        if length(arr) == 1\n         \
    \   if arr[1] % 2 == 0\n                sm_idx, sm_val = 1, arr[1]\n         \
    \   end\n        else\n            sm_idx, sm_val = findmin(arr)\n           \
    \ for i in 1:length(arr)\n                if arr[i] % 2 == 0 && arr[i] < sm_val\n\
    \                    sm_idx, sm_val = i, arr[i]\n                end\n       \
    \     end\n        end\n    end\n    return [sm_val, sm_idx]\nend", "    \"\"\"\
    \n    Use the filter function to filter out the even numbers and store them in\
    \ a variable.\n    If the variable is empty, return an empty vector.\n    If the\
    \ variable is not empty, call min(evens) to get the smallest even number.\n  \
    \  Use the findfirst function to get the index of the smallest even number\n \
    \   and return [smallest even number, index]\n    \"\"\"\n    # your code here\n\
    \    nothing\nend\n \n \n@test pluck([4, 2, 3]) == [2, 1]\n@test pluck([1, 2,\
    \ 3]) == [2, 1]\n@test pluck([]) == []\n@test pluck([5, 0, 3, 0, 4, 2]) == [0,\
    \ 1]\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n\"\"\"\n\U0001F989 Sabrina\n\"\"\"", "    even = []\n    for i in 1:length(arr)\n\
    \        if rem(arr[i], 2) == 0\n            push!(even, [arr[i], i])\n      \
    \  end\n    end\n    if length(even) == 0\n        return []\n    else\n     \
    \   least = even[1][1]\n        least_index = 1\n        for i in 2:length(even)\n\
    \            if even[i][1] < least\n                least = even[i][1]\n     \
    \           least_index = i\n            end\n        end\n        return even[least_index]\n\
    \    end\nend", "    min = 10000\n    for i in arr\n        if mod(i, 2) == 0\
    \ && i <= min\n            min = i\n        end\n    end\n    [min, findall(arr\
    \ .== min)[1]]\nend", "    if (length(arr) == 0)\n        return []\n    end\n\
    \    min_val = 10001\n    min_idx = 10001\n    for (index, val) in enumerate(arr)\n\
    \        if (val < min_val && val % 2 == 0)\n            min_val = val\n     \
    \       min_idx = index\n        end\n    end\n    if (min_val < 10001)\n    \
    \    return [min_val, min_idx + 1]\n    else\n        return []\n    end\nend",
  "    evens = findall(x -> x % 2 == 0, arr)\n    if isempty(evens)\n        return\
    \ Vector{Int64}()\n    end\n    min_index = findfirst(evens .== minimum(evens))\n\
    \    return [minimum(evens), min_index]\nend", "    # filter out even values\n\
    \    evens = [x for x in arr if iseven(x)]\n    # sort the even values\n    sort!(evens)\n\
    \    # return the smallest even value with the smallest index\n    if evens ==\
    \ []\n        return []\n    else\n        sorted_arr = sort(arr)\n        return\
    \ [evens[1], findfirst(x -> x == evens[1], sorted_arr)]\n    end\nend", "    #\
    \ If the vector is empty, return empty array\n    if size(arr, 1) == 0\n     \
    \   return []\n    end\n    \n    # Find the min value of even values\n    min_val\
    \ = minimum(filter(x -> x % 2 == 0, arr))\n    \n    # Find the indices of the\
    \ even values\n    even_indices = findall(arr .% 2 .== 0)\n    \n    # Find the\
    \ index of the minimum value\n    min_index = findfirst(arr[even_indices] .==\
    \ min_val)\n    \n    # Return the min value and min index\n    return [min_val,\
    \ even_indices[min_index]]\nend", "    # your code here\n    if length(arr) ==\
    \ 0\n        return []\n    end\n    min_even = 10^9\n    min_index = 10^9\n \
    \   for i = 1:length(arr)\n        if mod(arr[i], 2) == 0\n            if arr[i]\
    \ < min_even\n                min_even = arr[i]\n                min_index = i\n\
    \            end\n        end\n    end\n    if min_even == 10^9\n        return\
    \ []\n    end\n    return [min_even, min_index]\nend\n \n@testset \"Test Cases\"\
    \ begin\n    @test pluck([4, 2, 3]) == [2, 1]\n    @test pluck([1, 2, 3]) == [2,\
    \ 1]\n    @test pluck([]) == []\n    @test pluck([5, 0, 3, 0, 4, 2]) == [0, 1]\n\
    end", "    \"\"\"\n    This function returns the node in the arr (the tree) with\
    \ the smallest even value.\n    If there are two nodes with the same smallest\
    \ even value, it will choose the one \n    with the smallest index.\n    \"\"\"\
    \n    if length(arr) == 0 || all(elem % 2 != 0 for elem in arr)\n        return\
    \ []\n    end\n    evens = Int64[]\n    for i in 1:length(arr)\n        if arr[i]\
    \ % 2 == 0\n            push!(evens, arr[i])\n        end\n    end\n    min_index\
    \ = findfirst(arr, minimum(evens))\n    return [arr[min_index], min_index]\nend",
  "    smallest_value = Int64[]\n    for i in 1:length(arr)\n        if rem(arr[i],\
    \ 2) == 0\n            push!(smallest_value, i)\n        end\n    end\n    if\
    \ smallest_value == Int64[]\n        return []\n    else\n        smallest_value_index\
    \ = findmin(arr[smallest_value])[2]\n        smallest_value_index = smallest_value[smallest_value_index]\n\
    \        return [arr[smallest_value_index], smallest_value_index]\n    end\nend",
  "    smallest = 0 \n    index = 0\n    is_empty = true\n    for i in eachindex(arr)\n\
    \        if iseven(arr[i]) && (arr[i] < smallest || is_empty)\n            is_empty\
    \ = false\n            smallest = arr[i]\n            index = i\n        end\n\
    \    end\n    if is_empty\n        return []\n    else\n        return [smallest,\
    \ index]\n    end\nend", "    # get min of even elements in arr\n    eve = nothing\n\
    \    for el in arr\n        if el % 2 == 0\n            if isnothing(eve) || el\
    \ < eve\n                eve = el\n            end\n        end\n    end\n   \
    \ if isnothing(eve)\n        return []\n    end\n    # get index of eve\n    eve_idx\
    \ = 0\n    for i in eachindex(arr)\n        if arr[i] == eve\n            eve_idx\
    \ = i\n            break\n        end\n    end\n    return [eve, eve_idx]\nend\n\
    \ \n@testset \"Example\" begin\n    @test pluck([4, 2, 3]) == [2, 1]\n    @test\
    \ pluck([1, 2, 3]) == [2, 1]\n    @test pluck([]) == []\n    @test pluck([5, 0,\
    \ 3, 0, 4, 2]) == [0, 1]\nend", "    if(length(arr) == 0)\n        return []\n\
    \    end\n    min_even = 0\n    min_even_idx = 0\n    for(i, x) in enumerate(arr)\n\
    \        if(x % 2 == 0)\n            if(x <= min_even)\n                min_even\
    \ = x\n                min_even_idx = i\n            end\n        end\n    end\n\
    \    if(min_even == 0)\n        return []\n    end\n    return [min_even, min_even_idx]\n\
    end", "    if length(arr) == 0 return [] end\n    idx = 0\n    for i in eachindex(arr)\n\
    \        if arr[i] % 2 == 0\n            if (idx == 0) || (arr[i] < arr[idx])\n\
    \                idx = i\n            end\n        end\n    end\n    if idx ==\
    \ 0 return [] end\n    return [arr[idx], idx]\nend\n ", "    # set of odd values\
    \ in the arr (to avoid duplicate computation)\n    odds = Set()\n    even_idx\
    \ = 0", "    if length(arr) == 0\n        return []\n    end\n    evens = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens,\
    \ [arr[i], i])\n        end\n    end\n    if length(evens) == 0\n        return\
    \ []\n    end\n    minimum = evens[1]\n    for i in 1:length(evens)\n        if\
    \ evens[i][1] < minimum[1]\n            minimum = evens[i]\n        end\n    end\n\
    \    return minimum\nend", "    evens_idx = findall(isodd, arr)\n    evens = arr[evens_idx]\n\
    \    evens = sort(evens)\n    if isempty(evens)\n        return []\n    else\n\
    \        return [evens[1], evens_idx[1]]\n    end\nend", "    # TODO\nend\n \n\
    \ \n \n\"\"\"\"\n    You are given an array of strings words and a string chars.\n\
    \    A string is good if it can be formed by characters from chars (each character\
    \ can only be used once).\n    Return the sum of lengths of all good strings in\
    \ words.", "    if isempty(arr)\n        return Int64[]\n    end\n    min_even\
    \ = minimum(filter(x -> x % 2 == 0, arr))\n    if isempty(min_even)\n        return\
    \ Int64[]\n    end\n    return [arr[i] for i in eachindex(arr) if arr[i] == min_even][1]\n\
    end\npluck([4, 2, 3])\npluck([1, 2, 3])\npluck([])\npluck([5, 0, 3, 0, 4, 2])",
  "    if length(arr) == 0 return [] end\n    even_indices = Vector{Int64}()\n   \
    \ for i = 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_indices,\
    \ i)\n        end\n    end\n    if length(even_indices) == 0 return [] end\n \
    \   min_index = even_indices[1]\n    for i = 2:length(even_indices)\n        if\
    \ arr[even_indices[i]] < arr[min_index]\n            min_index = even_indices[i]\n\
    \        end\n    end\n    return [arr[min_index], min_index]\nend", "    # Start\
    \ your code here\n    for idx in 1:length(arr)\n        if arr[idx] % 2 == 0\n\
    \            return [arr[idx], idx]\n        end\n    end\n    return []\nend\n\
    ```", "    if all(x -> x % 2 != 0, arr) || isempty(arr)\n        return []\n \
    \   end\n    smallest_even_value = minimum(filter(x -> x % 2 == 0, arr))\n   \
    \ smallest_even_index = findfirst(arr, smallest_even_value)\n    return [smallest_even_value,\
    \ smallest_even_index]\nend", "    min_even = minimum(arr[arr .% 2 .== 0]) # The\
    \ smallest even value.\n    min_even_idx = findall(arr .== min_even)[1] # The\
    \ smallest index for the smallest even value.\n    return [min_even, min_even_idx]\
    \ # Return the values.\nend", "    min_val = Inf\n    min_idx = Inf\n    for (i,\
    \ v) in enumerate(arr)\n        if rem(v, 2) == 0\n            if v < min_val\n\
    \                min_val = v\n                min_idx = i\n            end\n \
    \       end\n    end\n    return [min_val, min_idx]\nend", "    min_value = minimum(arr[arr\
    \ .% 2 .== 0])\n    index = findfirst(arr .== min_value)\n    return [min_value,\
    \ index]\nend", "    min_val = nothing\n    min_idx = nothing\n    for i in eachindex(arr)\n\
    \        if iseven(arr[i])\n            if min_val == nothing || arr[i] < min_val\n\
    \                min_val = arr[i]\n                min_idx = i\n            end\n\
    \        end\n    end\n    if min_val == nothing\n        return []\n    else\n\
    \        return [min_val, min_idx]\n    end\nend", "    if length(arr) == 0\n\
    \        return []\n    end\n    min, idx = arr[1], 1\n    for (i, val) in enumerate(arr)\n\
    \        if val % 2 == 0 && val < min\n            min, idx = val, i\n       \
    \ end\n    end\n    if min % 2 == 0\n        return [min, idx]\n    else\n   \
    \     return []\n    end\nend", "    # First, we'll find the smallest even value\
    \ in the array.\n    # Find all evens\n    all_evens = filter(x -> x % 2 == 0,\
    \ arr)\n    # Find minimum of the evens\n    smallest_even = minimum(all_evens)\n\
    \    # Then, we'll find the indices of the elements that have that value.\n  \
    \  idx = findall(arr .== smallest_even)\n    # Return the index of the minimum\
    \ element in that array\n    smallest_idx = minimum(idx)\n    # Return the index\
    \ with the element in a new array\n    return [arr[smallest_idx], smallest_idx]\n\
    end", "    if isempty(arr)\n        return []\n    end\n    evens = filter(x ->\
    \ x % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    inds = [i for i in 1:length(arr) if arr[i] == min_even]\n\
    \    min_ind = minimum(inds)\n    return [min_even, min_ind]\nend", "    return\
    \ []\nend", "    if isempty(arr)\n        return []\n    end\n    indices = findall(isodd,\
    \ arr)\n    if isempty(indices)\n        return []\n    end\n    min_even = minimum(arr[indices])\n\
    \    return [min_even, findmin(arr[indices])]\nend", "    a = 0\n    i = 0\n \
    \   idx = 10001\n    e = []\n    if length(arr) == 0\n        return e\n    end\n\
    \    for j in 1:length(arr)\n        if arr[j] % 2 == 0\n            if a == 0\n\
    \                a = arr[j]\n                idx = j\n            elseif arr[j]\
    \ < a\n                a = arr[j]\n                idx = j\n            end\n\
    \        end\n    end\n    if a == 0\n        return e\n    end\n    push!(e,a)\n\
    \    push!(e,idx)\n    return e\nend", "    min_even_value = 10001\n    min_index\
    \ = -1\n    for (index, value) in enumerate(arr)\n        if(value%2 == 0 && value\
    \ < min_even_value)\n            min_even_value = value\n            min_index\
    \ = index\n        end\n    end\n    if(min_index == -1)\n        return []\n\
    \    end\n    return [min_even_value, min_index]\nend", "    # special case: empty\
    \ array\n    if length(arr) == 0\n        return []\n    end\n    \n    # special\
    \ case: only one element, and it is even\n    if length(arr) == 1 && iseven(arr[1])\n\
    \        return [arr[1], 1]\n    end\n    \n    # special case: only one element,\
    \ and it is odd\n    if length(arr) == 1 && !iseven(arr[1])\n        return []\n\
    \    end\n    \n    # filter out the even numbers\n    evens = arr[iseven.(arr)]\n\
    \    \n    # special case: no even numbers\n    if length(evens) == 0\n      \
    \  return []\n    end\n    \n    # find the minimum even number, and find the\
    \ index of that number\n    minimum = minimum(evens)\n    index = findfirst(minimum,\
    \ arr)\n    \n    # special case: there are multiple minimums\n    # if there\
    \ are multiple minimums, find the first one, then find the index of that minimum\n\
    \    while length(findall(minimum, arr)) > 1\n        minimum = findall(minimum,\
    \ arr)[1]\n        index = findfirst(minimum, arr)\n    end\n    \n    return\
    \ [minimum, index]\nend", "    #create a new array to store only even numbers\n\
    \    even_arr = []\n    #create a new array to store indexes of the even number\n\
    \    even_index_arr = []\n    # loop over the array to store all even numbers\
    \ and their indexes\n    for i in 1:length(arr)\n        if (arr[i] % 2 == 0)\n\
    \            # push the element to the even number array\n            push!(even_arr,\
    \ arr[i])\n            # push the element index to the even number index array\n\
    \            push!(even_index_arr, i)\n        end\n    end\n    # if there is\
    \ no even number, return empty array\n    if (length(even_arr) == 0)\n       \
    \ return []\n    end\n    # sort the array of even numbers\n    sort!(even_arr)\n\
    \    # sort the array of even number indexes\n    sort!(even_index_arr)\n    #\
    \ get the first element in both of the arrays, since they are sorted\n    # the\
    \ first elements are the smallest even number and its index\n    return [even_arr[1],\
    \ even_index_arr[1]]\nend", "    # Complete this function\nend\n```", "    # YOUR\
    \ CODE HERE\n    return []\nend", "    if length(arr) == 0\n        return []\n\
    \    end\n    plucked_node = [-1, -1]\n    for (node_index, node_value) in enumerate(arr)\n\
    \        if node_value % 2 == 0\n            if plucked_node[1] == -1\n      \
    \          plucked_node = [node_value, node_index]\n            elseif node_value\
    \ < plucked_node[1]\n                plucked_node = [node_value, node_index]\n\
    \            end\n        end\n    end\n    return plucked_node\nend", "    if\
    \ length(arr) == 0\n        return []\n    end\n    evens = arr[rem.(arr, 2) .==\
    \ 0]\n    if length(evens) == 0\n        return []\n    end\n    even_min = minimum(evens)\n\
    \    return [even_min, findfirst(arr, even_min)[1]]\nend\n \n```", "    if isempty(arr)\n\
    \        return []\n    end\n    candidates = []\n    for i in 1:length(arr)\n\
    \        if iseven(arr[i])\n            push!(candidates, [arr[i], i])\n     \
    \   end\n    end\n    if isempty(candidates)\n        return []\n    end\n   \
    \ sort!(candidates, by = x -> x[1])\n    return candidates[1]\nend", "    even_positions\
    \ = findall(x -> (x % 2 == 0), arr)\n    if isempty(even_positions)\n        return\
    \ []\n    end\n    smallest_even_value = minimum(arr[even_positions])\n    node_index\
    \ = findfirst(arr, smallest_even_value)\n    return [smallest_even_value, node_index]\n\
    end", "    return []\nend\n ", "    # We first find the min even value\n    min_even_val\
    \ = 0 # even if there is no even number at the end of the function,\n        \
    \             # the output will be a vector of 0, empty.\n    for (i, e) in enumerate(arr)\n\
    \        if iseven(e) && (e < min_even_val || min_even_val == 0)\n           \
    \ min_even_val = e\n        end\n    end\n    # Next we find the index at which\
    \ that number appears.\n    # Since we are looking for the first index of the\
    \ number, the loop starts at i = 1.\n    # We could have also started at i = 1\
    \ in the above loop.\n    for (i, e) in enumerate(arr)\n        if e == min_even_val\n\
    \            return [e, i]\n        end\n    end\nend", "    even_indices = findall(x\
    \ -> (x % 2 == 0), arr)\n    if isempty(even_indices)\n        return []\n   \
    \ end\n    even_values = arr[even_indices]\n    smallest_value = minimum(even_values)\n\
    \    smallest_value_index = findfirst(arr, smallest_value)\n    return [smallest_value,\
    \ smallest_value_index]\nend", "    \n    i::Int64 = 1\n    minEven::Int64 = 10001\n\
    \    index::Int64 = 0\n    \n    if length(arr) == 0\n        return []\n    end\n\
    \    \n    while i <= length(arr)\n        if arr[i] == 0\n            index =\
    \ i\n            minEven = 0\n            break\n        elseif arr[i] % 2 ==\
    \ 0 && arr[i] < minEven\n            minEven = arr[i]\n            index = i\n\
    \        end\n        i += 1\n    end\n    \n    if minEven == 10001\n       \
    \ return []\n    else\n        return [minEven, index]\n    end\nend", "    #\
    \ first we need to find the minimal even value in the array\n    # we need to\
    \ filter out all the odd integers first\n    min_even_val = find_min_even(arr)\n\
    \    # then we need to find the index of the first occurence of min_even_val\n\
    \    min_even_val_idx = find_min_even_idx(arr, min_even_val)\n    # if there is\
    \ no even number, return empty array\n    if min_even_val == Inf\n        return\
    \ []\n    else\n        return [min_even_val, min_even_val_idx]\n    end\nend",
  "    \n    # Base cases\n    if isempty(arr) || !any(iseven, arr)\n        return\
    \ []\n    end\n    \n    # Get the smallest even value\n    evens = getevens(arr)\n\
    \    if length(evens) == 1\n        return evens[1]\n    end\n    smallest_even\
    \ = minimum(evens)\n    \n    # get the index of the smallest even value\n   \
    \ indexes = getindexes(arr, smallest_even)\n    smallest_index = minimum(indexes)\n\
    \    \n    return [smallest_even, smallest_index]\nend", "    # If the vector\
    \ is empty, return empty\n    if length(arr) == 0\n        return []\n    end\n\
    \    \n    # create an empty array to hold the indices of the even numbers\n \
    \   even_nums = Int64[]\n    \n    # iterate through the input array\n    for\
    \ i in 1:length(arr)\n        # if the current value is even, push it to the empty\
    \ array\n        if arr[i] % 2 == 0\n            push!(even_nums, arr[i])\n  \
    \      end\n    end\n    \n    # if there are no even numbers, return empty\n\
    \    if length(even_nums) == 0\n        return []\n    end\n    \n    # get the\
    \ min value of the even numbers\n    min_val = minimum(even_nums)\n    \n    #\
    \ get the index of the min value\n    min_index = findfirst(arr .== min_val)\n\
    \    \n    # return the smallest even value and its index\n    return [min_val,\
    \ min_index]\nend", "    #check for empty vector\n    if isempty(arr)\n      \
    \  return []\n    end\n    #find the smallest even value\n    evens = filter(x\
    \ -> mod(x, 2) == 0, arr)\n    #check for no evens\n    if isempty(evens)\n  \
    \      return []\n    end\n    #find its index\n    index = findall(arr .== minimum(evens))[1]\n\
    \    #return the value and its index\n    return [minimum(evens), index]\nend",
  "    #Check that the vector has at least one element\n    if length(arr) == 0\n\
    \        return []\n    end\n    #Get the min even value in the vector\n    minEven\
    \ = minimum(filter(isEven, arr))\n    if minEven == Inf\n        return []\n \
    \   end\n    #return the indices of the min even value\n    indices = findall(arr\
    \ .== minEven)\n    return [minEven, minimum(indices)]\nend", "    if isempty(arr)\n\
    \        return []\n    end\n    arr_even = arr[isodd.(arr)]\n    if isempty(arr_even)\n\
    \        return []\n    end\n    ind = minimum(findall(arr_even, minimum(arr_even)))\n\
    \    return [arr_even[ind], ind]\nend", "    even_arr = [x for x in arr if iseven(x)]\
    \ \n    if isempty(even_arr) \n        return []\n    else\n        even_arr =\
    \ sort(even_arr)\n        smallest_even = even_arr[1]\n        index = findfirst(arr,\
    \ smallest_even)\n        return [smallest_even, index]\n    end\nend", "    return\
    \ arr\nend", "    if isempty(arr)\n        return []\n    end\n    min_even, min_idx\
    \ = first(arr), 1\n    for i in 2:length(arr)\n        val = arr[i]\n        if\
    \ iseven(val) && val < min_even\n            min_even, min_idx = val, i\n    \
    \    end\n    end\n    return [min_even, min_idx]\nend", "    smallest = nothing\n\
    \    smallest_index = nothing\n    for (index, item) in enumerate(arr)\n     \
    \   if iseven(item)\n            if isnothing(smallest)\n                smallest\
    \ = item\n                smallest_index = index\n            elseif item < smallest\n\
    \                smallest = item\n                smallest_index = index\n   \
    \         end\n        end\n    end\n    return isnothing(smallest) ? Vector{Int64}()\
    \ : [smallest, smallest_index + 1]\nend", "    return []\nend", "    small_even_index\
    \ = 0 \n    small_even_val = 0\n    found_even = false\n    for i = 1:length(arr)\n\
    \        if !found_even && rem(arr[i], 2) == 0\n            small_even_index =\
    \ i\n            small_even_val = arr[i]\n            found_even = true\n    \
    \    elseif found_even && rem(arr[i], 2) == 0 && arr[i] < small_even_val\n   \
    \         small_even_index = i\n            small_even_val = arr[i]\n        end\n\
    \    end\n    if found_even\n        return [small_even_val, small_even_index]\n\
    \    else\n        return []\n    end\nend", "    vals = [arr[i] for i in 1:length(arr)\
    \ if arr[i] % 2 == 0]\n    if isempty(vals)\n        return []\n    else\n   \
    \     val = minimum(vals)\n        return [val, findfirst(arr, val)[1]]\n    end\n\
    end\n \n \n\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest odd value.\n\
    \    If multiple nodes with the same smallest odd value are found return the node\
    \ that has smallest index.", "    # Find the smallest even number \n    min_even\
    \ = zero(Int64)\n    min_index = zero(Int64)\n    is_empty = true\n    for i in\
    \ 1:length(arr)\n        if arr[i] % 2 == 0 && (is_empty || arr[i] < min_even)\n\
    \            min_even = arr[i]\n            min_index = i\n            is_empty\
    \ = false\n        end\n    end\n    if is_empty\n        return []\n    else\n\
    \        return [min_even, min_index]\n    end\nend", "    # your code here\n\
    end\n ", "    arr_sorted = sort(arr)\n    for i in 1:length(arr_sorted)\n    \
    \    if arr_sorted[i] % 2 == 0\n            return [arr_sorted[i], findall(arr\
    \ .== arr_sorted[i])[1]]\n        end\n    end\n    return []\nend", "    # TODO:\
    \ implement\nend\n \n ", "    return find_even(arr) == 0 ? [] : find_even(arr)\n\
    end", "    if length(arr) == 0 return [] end\n    evens = []\n    for (n, x) in\
    \ enumerate(arr)\n        if x % 2 == 0 push!(evens, [x, n]) end\n    end\n  \
    \  if length(evens) == 0 return [] end\n    sort!(evens, by = x -> (x[1], x[2]))\n\
    \    return evens[1]\nend", "    if length(arr) == 0\n        return []\n    end\n\
    \    if any(x -> x % 2 == 0, arr)\n        nums = [y[1] for y in enumerate(arr)\
    \ if y[2] % 2 == 0]\n        values = sort(nums, by = x -> x[2])\n        return\
    \ values[1]\n    else\n        return []\n    end\nend", "    if length(arr) ==\
    \ 0\n        return []\n    end\n    v = []\n    i = 0\n    for (j,val) in enumerate(arr)\n\
    \        if val % 2 == 0\n            if length(v) == 0\n                v = [val,\
    \ j]\n            elseif val < v[1]\n                v = [val, j]\n          \
    \  end\n        end\n    end\n    return v\nend", "    #1. For every element in\
    \ arr, check if it is even.\n    #2. If even, add to new array of evens.\n   \
    \ #3. Select the minimum value of evens.\n    #4. Return the minimum value, and\
    \ its index in the original array.\n    evens = filter(x -> x % 2 == 0, arr) #step\
    \ 1 and 2\n    min_index = findmin(evens)[2]\n    min_value = evens[min_index]\n\
    \    return [min_value, findfirst(x -> x == min_value, arr)] #step 3 and 4\nend",
  "    min_even = nothing\n    min_index = nothing\n    for (i, v) in enumerate(arr)\n\
    \        if v % 2 == 0\n            if min_even == nothing || v < min_even\n \
    \               min_even = v\n                min_index = i\n            end\n\
    \        end\n    end\n    return (min_even == nothing) ? Vector{Int64}() : [min_even,\
    \ min_index + 1]\nend", "    # Write your code here\n    return zeros(2)\nend\n\
    \ ", "    empty = Vector{Int64}()\n    index = 1\n    min = 10001\n    if isempty(arr)\n\
    \        return empty\n    end\n    for i in 1:length(arr)\n        if arr[i]%2\
    \ == 0\n            if min > arr[i]\n                min = arr[i]\n          \
    \      index = i\n            end\n        end\n    end\n    if min != 10001\n\
    \        return [min, index]\n    else\n        return empty\n    end\nend\n\"\
    \"\"\n    \"Given a string s and an integer k.\n    Return the maximum number\
    \ of vowel letters in any substring of s with length k.\n    Vowel letters in\
    \ English are (a, e, i, o, u).", "    if isempty(arr)\n        return []\n   \
    \ end\n    @inbounds for i in 1:length(arr)\n        if arr[i] % 2 == 0\n    \
    \        return [arr[i], i]\n        end\n    end\n    return []\nend", "    #\
    \ TODO: write the pluck function\nend\n```", "    \n    if length(arr) == 0\n\
    \        return []\n    end\n    \n    evens = filter(x -> x % 2 == 0, arr)\n\
    \    \n    if length(evens) == 0\n        return []\n    end\n    \n    value\
    \ = minimum(evens)\n    idx = findfirst(arr .== value)\n    \n    return [value,\
    \ idx]\nend", "    # If vector is empty return [], else continue on.\n    if isempty(arr)\n\
    \        return []\n    end\n    \n    # Get all even values from the vector and\
    \ store them in a new vector:\n    evens = [i for i in arr if i % 2 == 0]\n  \
    \  \n    # Find the minimum value in the evens vector,\n    # if all the values\
    \ in the evens vector are greater than 0 return the minimum,\n    # else return\
    \ [].\n    min_even = (minimum(evens) > 0) ? minimum(evens) : []\n    \n    #\
    \ If min_even is not an empty array return the minimum of the evens vector and\
    \ its index,\n    # else return an empty array.\n    if !isempty(min_even)\n \
    \       return [min_even, findfirst(arr, min_even)]\n    else\n        return\
    \ []\n    end\nend", "    \"\"\"\n    Returns the smallest even node in a vector,\
    \ if no even nodes are found returns [].\n    \"\"\"\n    plucked_index = 0\n\
    \    plucked_value = 0\n    for i in enumerate(arr)\n        if i % 2 == 0\n \
    \           plucked_index = i[1]\n            plucked_value = i[2]\n         \
    \   break\n        end\n    end\n    return [plucked_value, plucked_index]\nend",
  "    i = 0\n    small = arr[1]\n    while i < length(arr)\n        if arr[i] % 2\
    \ == 0\n            if small > arr[i]\n                small = arr[i]\n      \
    \      end\n        end\n        i += 1\n    end\n    if small % 2 == 0\n    \
    \    return [small, findfirst(arr, small)]\n    else\n        return []\n    end\n\
    end"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
