name: HumanEval_128_prod_signs
language: jl
results:
- program: "\"\"\"\n    You are given a vector arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the vector, represented by 1, -1 or 0.\n    Note: return nothing\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4])\n    9\n \
    \   >>> prod_signs([0, 1])\n    0\n    >>> prod_signs([])\n    nothing\n    \"\
    \"\"\nfunction prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if\
    \ isempty(arr)\n        return nothing\n    end\n    prod = 1\n    sum = 0\n \
    \   for x in arr\n        if x < 0\n            prod *= -1\n        elseif x ==\
    \ 0\n            prod *= 0\n        end\n        sum += abs(x)\n    end\n    sum\
    \ * prod\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given a vector arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the vector, represented by 1, -1 or 0.\n    Note: return nothing\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4])\n    9\n \
    \   >>> prod_signs([0, 1])\n    0\n    >>> prod_signs([])\n    nothing\n    \"\
    \"\"\nfunction prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if\
    \ isempty(arr)\n        return nothing\n    end\n    return sum(abs.(arr)) * prod(sign.(arr))\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given a vector arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the vector, represented by 1, -1 or 0.\n    Note: return nothing\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4])\n    9\n \
    \   >>> prod_signs([0, 1])\n    0\n    >>> prod_signs([])\n    nothing\n    \"\
    \"\"\nfunction prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if\
    \ length(arr) == 0\n        return nothing\n    end\n    signs = ones(Int64, length(arr))\n\
    \    for i in 1:length(arr)\n        if arr[i] > 0\n            signs[i] = 1\n\
    \        elseif arr[i] < 0\n            signs[i] = -1\n        else\n        \
    \    signs[i] = 0\n        end\n    end\n    return sum(abs.(arr)) * prod(signs)\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given a vector arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the vector, represented by 1, -1 or 0.\n    Note: return nothing\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4])\n    9\n \
    \   >>> prod_signs([0, 1])\n    0\n    >>> prod_signs([])\n    nothing\n    \"\
    \"\"\nfunction prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    res\
    \ = 1\n    m = 0\n    for x in arr\n        m += abs(x)\n        if x == 0\n \
    \           continue\n        end\n        if x > 0\n            res *= 1\n  \
    \      else\n            res *= -1\n        end\n    end\n    return m * res\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmps3ydrmzw.jl:37\n  Expression: candidate([0,\
    \ 1]) == 0\n   Evaluated: 1 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmps3ydrmzw.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmps3ydrmzw.jl:35\ntest set: Test\
    \ Failed at /tmp/tmps3ydrmzw.jl:39\n  Expression: candidate(Vector{Int64}([]))\
    \ == nothing\n   Evaluated: 0 == nothing\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmps3ydrmzw.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmps3ydrmzw.jl:35\ntest set: Test\
    \ Failed at /tmp/tmps3ydrmzw.jl:43\n  Expression: candidate([-1, 1, 1, 0]) ==\
    \ 0\n   Evaluated: -3 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmps3ydrmzw.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmps3ydrmzw.jl:35\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    5     3      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 5 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmps3ydrmzw.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a vector arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the vector, represented by 1, -1 or 0.\n    Note: return nothing\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4])\n    9\n \
    \   >>> prod_signs([0, 1])\n    0\n    >>> prod_signs([])\n    nothing\n    \"\
    \"\"\nfunction prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    s,\
    \ p = 0, 1\n    for el in arr\n        if el == 0\n            s += 0\n      \
    \  elseif el > 0\n            s += el\n            p *= 1\n        else\n    \
    \        s += -el\n            p *= -1\n        end\n    end\n    if s == 0\n\
    \        return nothing\n    else\n        return s * p\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4])\
    \ == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpuipia76t.jl:40\n  Expression: candidate([0,\
    \ 1]) == 0\n   Evaluated: 1 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpuipia76t.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpuipia76t.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpuipia76t.jl:46\n  Expression: candidate([-1, 1, 1, 0]) ==\
    \ 0\n   Evaluated: -3 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpuipia76t.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpuipia76t.jl:38\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    6     2      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpuipia76t.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a vector arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the vector, represented by 1, -1 or 0.\n    Note: return nothing\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4])\n    9\n \
    \   >>> prod_signs([0, 1])\n    0\n    >>> prod_signs([])\n    nothing\n    \"\
    \"\"\nfunction prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    n,\
    \ s = size(arr)\n    if n == 0\n        return nothing\n    end\n    p = ones(Int64,\
    \ n)\n    for i in 1:n\n        if arr[i] < 0\n            p[i] = -1\n       \
    \ elseif arr[i] == 0\n            p[i] = 0\n        end\n    end\n    return sum(abs.(arr))\
    \ * prod(p)\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t\
    @test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmprpdsv5o9.jl:35\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 2, -4]) == -9\n  BoundsError: attempt to access\
    \ Tuple{Int64} at index [2]\n  Stacktrace:\n   [1] indexed_iterate\n     @ ./tuple.jl:89\
    \ [inlined]\n   [2] prod_signs(arr::Vector{Int64})\n     @ Main /tmp/tmprpdsv5o9.jl:16\n\
    \   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmprpdsv5o9.jl:35 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmprpdsv5o9.jl:34\ntest set:\
    \ Error During Test at /tmp/tmprpdsv5o9.jl:36\n  Test threw exception\n  Expression:\
    \ candidate([0, 1]) == 0\n  BoundsError: attempt to access Tuple{Int64} at index\
    \ [2]\n  Stacktrace:\n   [1] indexed_iterate\n     @ ./tuple.jl:89 [inlined]\n\
    \   [2] prod_signs(arr::Vector{Int64})\n     @ Main /tmp/tmprpdsv5o9.jl:16\n \
    \  [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmprpdsv5o9.jl:36 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmprpdsv5o9.jl:34\ntest set:\
    \ Error During Test at /tmp/tmprpdsv5o9.jl:37\n  Test threw exception\n  Expression:\
    \ candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n  BoundsError: attempt to access Tuple{Int64}\
    \ at index [2]\n  Stacktrace:\n   [1] indexed_iterate\n     @ ./tuple.jl:89 [inlined]\n\
    \   [2] prod_signs(arr::Vector{Int64})\n     @ Main /tmp/tmprpdsv5o9.jl:16\n \
    \  [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmprpdsv5o9.jl:37 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmprpdsv5o9.jl:34\ntest set:\
    \ Error During Test at /tmp/tmprpdsv5o9.jl:"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprpdsv5o9.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a vector arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the vector, represented by 1, -1 or 0.\n    Note: return nothing\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4])\n    9\n \
    \   >>> prod_signs([0, 1])\n    0\n    >>> prod_signs([])\n    nothing\n    \"\
    \"\"\nfunction prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if\
    \ isempty(arr)\n        return nothing\n    end\n    product = 1\n    sum_of_magnitudes\
    \ = 0\n    for number in arr\n        if number > 0\n            product *= 1\n\
    \        elseif number < 0\n            product *= -1\n        else\n        \
    \    product *= 0\n        end\n        sum_of_magnitudes += abs(number)\n   \
    \ end\n    return product * sum_of_magnitudes\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given a vector arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the vector, represented by 1, -1 or 0.\n    Note: return nothing\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4])\n    9\n \
    \   >>> prod_signs([0, 1])\n    0\n    >>> prod_signs([])\n    nothing\n    \"\
    \"\"\nfunction prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if\
    \ length(arr) > 0\n        sum(abs.(arr)) * prod(sign.(arr))\n    else\n     \
    \   nothing\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given a vector arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the vector, represented by 1, -1 or 0.\n    Note: return nothing\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4])\n    9\n \
    \   >>> prod_signs([0, 1])\n    0\n    >>> prod_signs([])\n    nothing\n    \"\
    \"\"\nfunction prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if\
    \ arr == []\n        return nothing\n    end\n    sgns = [sign(x) for x in arr]\n\
    \    prodsgns = prod(sgns)\n    summagns = sum([abs(x) for x in arr])\n    return\
    \ summagns * prodsgns\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given a vector arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the vector, represented by 1, -1 or 0.\n    Note: return nothing\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4])\n    9\n \
    \   >>> prod_signs([0, 1])\n    0\n    >>> prod_signs([])\n    nothing\n    \"\
    \"\"\nfunction prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if\
    \ length(arr) == 0\n        return nothing\n    end\n    res::Int64 = 1\n    for\
    \ i in arr\n        res *= (i == 0 ? 0 : sign(i))\n    end\n    return sum(abs.(arr))\
    \ * res\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given a vector arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the vector, represented by 1, -1 or 0.\n    Note: return nothing\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4])\n    9\n \
    \   >>> prod_signs([0, 1])\n    0\n    >>> prod_signs([])\n    nothing\n    \"\
    \"\"\nfunction prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    @show\
    \ arr\n    if isempty(arr)\n        return nothing\n    end\n    arr = arr .*\
    \ [sign(x) for x in arr]\n    @show arr\n    return reduce(*, arr) * sum(abs.(arr))\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "arr = [1, 2, 2, -4]\narr = [1, 2, 2, 4]\ntest set: Test Failed at /tmp/tmp5liyj5q8.jl:29\n\
    \  Expression: candidate([1, 2, 2, -4]) == -9\n   Evaluated: 144 == -9\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5liyj5q8.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5liyj5q8.jl:28\narr = [0, 1]\n\
    arr = [0, 1]\narr = [1, 1, 1, 2, 3, -1, 1]\narr = [1, 1, 1, 2, 3, 1, 1]\ntest\
    \ set: Test Failed at /tmp/tmp5liyj5q8.jl:31\n  Expression: candidate([1, 1, 1,\
    \ 2, 3, -1, 1]) == -10\n   Evaluated: 60 == -10\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5liyj5q8.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5liyj5q8.jl:28\narr = Int64[]\n\
    arr = [2, 4, 1, 2, -1, -1, 9]\narr = [2, 4, 1, 2, 1, 1, 9]\ntest set: Test Failed\
    \ at /tmp/tmp5liyj5q8.jl:33\n  Expression: candidate([2, 4, 1, 2, -1, -1, 9])\
    \ == 20\n   Evaluated: 2880 == 20\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5liyj5q8.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5liyj5q8.jl:28\narr = [-1, 1,\
    \ -1, 1]\narr = [1, 1, 1, 1]\narr = [-1, 1, 1, 1]\narr = [1, 1, 1, 1]\ntest set:\
    \ Test Failed at /tmp/tmp5liyj5q8.jl:35\n  Expression: candidate([-1, 1, 1, 1])\
    \ == -4\n   Evaluated: 4 == -4\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5liyj5q8.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5liyj5q8.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a vector arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the vector, represented by 1, -1 or 0.\n    Note: return nothing\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4])\n    9\n \
    \   >>> prod_signs([0, 1])\n    0\n    >>> prod_signs([])\n    nothing\n    \"\
    \"\"\nfunction prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n  if isempty(arr)\n\
    \    return nothing\n  end\n  total = 0\n  sign = 1\n  for elem in arr\n    if\
    \ elem != 0\n      sign *= sign(elem)\n      total += abs(elem)\n    end\n  end\n\
    \  total * sign\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpxc1d2p2q.jl:34\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 2, -4]) == -9\n  MethodError: objects of type\
    \ Int64 are not callable\n  Maybe you forgot to use an operator such as *, ^,\
    \ %, / etc. ?\n  Stacktrace:\n   [1] prod_signs(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpxc1d2p2q.jl:23\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxc1d2p2q.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpxc1d2p2q.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpxc1d2p2q.jl:35\n  Test threw exception\n  Expression:\
    \ candidate([0, 1]) == 0\n  MethodError: objects of type Int64 are not callable\n\
    \  Maybe you forgot to use an operator such as *, ^, %, / etc. ?\n  Stacktrace:\n\
    \   [1] prod_signs(arr::Vector{Int64})\n     @ Main /tmp/tmpxc1d2p2q.jl:23\n \
    \  [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxc1d2p2q.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpxc1d2p2q.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpxc1d2p2q.jl:36\n  Test threw exception\n  Expression:\
    \ candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n  MethodError: objects of type Int64\
    \ are not callable\n  Maybe you forgot to use an operator such as *, ^, %, / etc.\
    \ ?\n  Stacktrace:\n   [1] prod_signs(arr::Vector{Int64})\n     @ Main /tmp/tmpxc1d2p2q.jl:23\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxc1d2p2q.jl:36 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpxc1d2p2q.jl:33\ntest set:\
    \ Error During Test at /tmp/"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxc1d2p2q.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a vector arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the vector, represented by 1, -1 or 0.\n    Note: return nothing\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4])\n    9\n \
    \   >>> prod_signs([0, 1])\n    0\n    >>> prod_signs([])\n    nothing\n    \"\
    \"\"\nfunction prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if\
    \ length(arr) == 0\n        return nothing\n    end\n    s = sum(abs.(arr))\n\
    \    p = prod(sign.(arr))\n    return s * p\nend\nprintln(prod_signs([1, 2, 2,\
    \ -4]))\nprintln(prod_signs([0, 1]))\nprintln(prod_signs([]))\nusing Test\n\n\
    @testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) ==\
    \ -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: "-9\n0\n"
  stderr: "ERROR: LoadError: MethodError: no method matching prod_signs(::Vector{Any})\n\
    Closest candidates are:\n  prod_signs(!Matched::Vector{Int64}) at /tmp/tmpdhh3a4sf.jl:15\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpdhh3a4sf.jl:25\nin expression\
    \ starting at /tmp/tmpdhh3a4sf.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a vector arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the vector, represented by 1, -1 or 0.\n    Note: return nothing\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4])\n    9\n \
    \   >>> prod_signs([0, 1])\n    0\n    >>> prod_signs([])\n    nothing\n    \"\
    \"\"\nfunction prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if\
    \ isempty(arr)\n        return nothing\n    end\n    signs = [sign(x) for x in\
    \ arr]\n    return sum(abs.(arr)) * prod(signs)\nend\n\"\"\"\n    You are given\
    \ a vector of integers and you need to return the\n    number of elements in the\
    \ vector that are less than the number\n    on their right side. Note: return\
    \ nothing for empty arr.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpiomvc70n.jl:22\nin expression starting at\
    \ /tmp/tmpiomvc70n.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a vector arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the vector, represented by 1, -1 or 0.\n    Note: return nothing\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4])\n    9\n \
    \   >>> prod_signs([0, 1])\n    0\n    >>> prod_signs([])\n    nothing\n    \"\
    \"\"\nfunction prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    # your\
    \ code here\nend\n@testset \"Testing prod_signs\" begin\n    @test prod_signs([1,\
    \ 2, 2, -4]) == 9\n    @test prod_signs([0, 1]) == 0\n    @test prod_signs([])\
    \ == nothing\nend\n \n \nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: UndefVarError: @testset not defined\nin expression starting\
    \ at /tmp/tmpxyiaeptw.jl:18\nin expression starting at /tmp/tmpxyiaeptw.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a vector arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the vector, represented by 1, -1 or 0.\n    Note: return nothing\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4])\n    9\n \
    \   >>> prod_signs([0, 1])\n    0\n    >>> prod_signs([])\n    nothing\n    \"\
    \"\"\nfunction prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    sign::Int64\
    \ = 1\n    magn::Int64 = 0\n    for x in arr\n        if x == 0\n            return\
    \ nothing\n        elseif x > 0\n            magn += x\n        else\n       \
    \     magn += -x\n            sign *= -1\n        end\n    end\n    sign * magn\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpu7xh9la4.jl:36\n  Expression: candidate([0,\
    \ 1]) == 0\n   Evaluated: nothing == 0\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpu7xh9la4.jl:36 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpu7xh9la4.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpu7xh9la4.jl:38\n  Expression: candidate(Vector{Int64}([]))\
    \ == nothing\n   Evaluated: 0 == nothing\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpu7xh9la4.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpu7xh9la4.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpu7xh9la4.jl:42\n  Expression: candidate([-1, 1, 1, 0]) ==\
    \ 0\n   Evaluated: nothing == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpu7xh9la4.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpu7xh9la4.jl:34\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    5     3      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 5 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpu7xh9la4.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a vector arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the vector, represented by 1, -1 or 0.\n    Note: return nothing\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4])\n    9\n \
    \   >>> prod_signs([0, 1])\n    0\n    >>> prod_signs([])\n    nothing\n    \"\
    \"\"\nfunction prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    return\
    \ (sum(abs.(arr))) * prod(sign.(arr))\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpls222hgs.jl:26\n  Expression: candidate(Vector{Int64}([]))\
    \ == nothing\n   Evaluated: 0 == nothing\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpls222hgs.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpls222hgs.jl:22\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    7     1      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 7 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpls222hgs.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a vector arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the vector, represented by 1, -1 or 0.\n    Note: return nothing\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4])\n    9\n \
    \   >>> prod_signs([0, 1])\n    0\n    >>> prod_signs([])\n    nothing\n    \"\
    \"\"\nfunction prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    sign\
    \ = 1\n    magnitude = 0\n    if length(arr) == 0\n        return nothing\n  \
    \  end\n    for i in arr\n        if i > 0\n            sign *= 1\n          \
    \  magnitude += i\n        elseif i < 0\n            sign *= -1\n            magnitude\
    \ += abs(i)\n        else\n            sign *= 0\n        end\n    end\n    return\
    \ sign * magnitude\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given a vector arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the vector, represented by 1, -1 or 0.\n    Note: return nothing\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4])\n    9\n \
    \   >>> prod_signs([0, 1])\n    0\n    >>> prod_signs([])\n    nothing\n    \"\
    \"\"\nfunction prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if\
    \ isempty(arr)\n        return nothing\n    end\n    product = 1\n    for n in\
    \ arr\n        product *= sign(n)\n    end\n    sum = 0\n    for n in arr\n  \
    \      sum += abs(n)\n    end\n    return sum * product\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given a vector arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the vector, represented by 1, -1 or 0.\n    Note: return nothing\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4])\n    9\n \
    \   >>> prod_signs([0, 1])\n    0\n    >>> prod_signs([])\n    nothing\n    \"\
    \"\"\nfunction prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if\
    \ isempty(arr)\n        return nothing\n    end\n    s = 1\n    for a in arr\n\
    \        s *= sign(a)\n    end\n    sum(abs, arr) * s\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
