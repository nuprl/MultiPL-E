name: HumanEval_21_rescale_to_unit
language: jl
prompt: "\"\"\" Given vector of numbers (of at least two elements), apply a linear\
  \ transform to that vector,\n    such that the smallest number will become 0 and\
  \ the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
  \    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\nfunction rescale_to_unit(numbers::Vector{Float64})::Vector{Float64}\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = rescale_to_unit;\n\t@test(candidate([2.0,\
  \ 49.9]) == [0.0, 1.0])\n\t@test(candidate([100.0, 49.9]) == [1.0, 0.0])\n\t@test(candidate([1.0,\
  \ 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\n\t@test(candidate([2.0,\
  \ 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\n\t@test(candidate([12.0,\
  \ 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nend\n"
completions: ["    number_max = maximum(numbers)\n    number_min = minimum(numbers)\n\
    \    numerator = numbers .- number_min\n    denominator = number_max - number_min\n\
    \    return numerator ./ denominator\nend", "    minimum, maximum = extrema(numbers)\n\
    \    length = maximum - minimum\n    if length == 0 \n        return fill(0.5,\
    \ length(numbers))\n    end\n    if minimum == maximum \n        return fill(minimum,\
    \ length(numbers))\n    end\n    return (numbers .- minimum) ./ length\nend",
  "    if length(numbers) < 2\n        return numbers\n    end\n    minimum = numbers[1]\n\
    \    maximum = numbers[1]\n    for n in numbers\n        if n < minimum\n    \
    \        minimum = n\n        end\n        if n > maximum\n            maximum\
    \ = n\n        end\n    end\n    return [(n - minimum) / (maximum - minimum) for\
    \ n in numbers]\nend", "    vmin = minimum(numbers)\n    vmax = maximum(numbers)\n\
    \    return (numbers - vmin)/(vmax - vmin)\nend", "    # Make copy\n    numbers_unit\
    \ = copy(numbers)\n    # Find min and max\n    min_number = minimum(numbers_unit)\n\
    \    max_number = maximum(numbers_unit)\n    # Subtract the minimum\n    numbers_unit\
    \ .-= min_number\n    # Divide by the max - min\n    numbers_unit ./= (max_number\
    \ - min_number)\n    # Return\n    return numbers_unit\nend", "    minimum = minimum(numbers)\n\
    \    maximum = maximum(numbers)\n    range = maximum - minimum\n    return (numbers\
    \ .- minimum) ./ range\nend", "    numbers = numbers .- minimum(numbers) # shift\
    \ to positive numbers\n    numbers = numbers ./ maximum(numbers) # stretch to\
    \ max==1\n    return numbers\nend", "    min_number = minimum(numbers)\n    max_number\
    \ = maximum(numbers)\n    return (numbers - min_number) / (max_number - min_number)\n\
    end", "    _min = minimum(numbers)\n    _max = maximum(numbers)\n    if _min ==\
    \ _max\n        return ones(length(numbers))\n    end\n    (numbers .- _min) ./\
    \ (_max - _min)\nend", "    \"\"\"\n    Given vector of numbers (of at least two\
    \ elements), apply a linear transform to that vector,\n    such that the smallest\
    \ number will become 0 and the largest will become 1\n    \"\"\"\n    min = minimum(numbers)\n\
    \    max = maximum(numbers)\n    return [\n        (x - min) / (max - min)\n \
    \       for x in numbers\n    ]\nend", "    if length(numbers) < 2 \n        error(\"\
    must have at least two elements to rescale a vector\")\n    end\n    minimum,\
    \ maximum = extrema(numbers)\n    new_numbers = []\n    for number in numbers\n\
    \        if minimum == maximum\n            new_numbers = push!(new_numbers, 0.0)\n\
    \        else\n            new_numbers = push!(new_numbers, (number - minimum)\
    \ / (maximum - minimum))\n        end\n    end\n    return new_numbers\nend",
  "   \n    smallest = minimum(numbers)\n    largest = maximum(numbers)\n    distance\
    \ = largest - smallest\n    return (numbers - smallest) / distance\nend", "  \
    \  @assert length(numbers) > 1\n    @assert !any(isnan.(numbers))\n    minimum\
    \ = minimum(numbers)\n    maximum = maximum(numbers)\n    return (numbers .- minimum)\
    \ ./ (maximum - minimum)\nend\n ", "    minimum = minimum(numbers)\n    maximum\
    \ = maximum(numbers)\n    return (numbers .- minimum) ./ (maximum - minimum)\n\
    end", "    return (numbers .- minimum(numbers)) ./ (maximum(numbers) - minimum(numbers))\n\
    end", "    numbers_max = maximum(numbers)\n    numbers_min = minimum(numbers)\n\
    \    return map( (n) -> (n - numbers_min) / (numbers_max - numbers_min), numbers)\n\
    end", "    min, max = minimum(numbers), maximum(numbers)\n    # ( x - min ) /\
    \ ( max - min )\n    return (numbers .- min) ./ (max - min)\nend", "    min_value\
    \ = minimum(numbers)\n    max_value = maximum(numbers)\n    return [(number -\
    \ min_value) / (max_value - min_value) for number in numbers]\nend", "    return\
    \ (numbers .- minimum(numbers)) ./ (maximum(numbers) - minimum(numbers))\nend",
  "    sorted_numbers = sort(numbers)\n    max_number = sorted_numbers[end]\n    min_number\
    \ = sorted_numbers[1]\n    difference = max_number - min_number\n    return [(number\
    \ - min_number) / difference for number in numbers]\nend", "    min_number = minimum(numbers)\n\
    \    max_number = maximum(numbers)\n    return (numbers .- min_number) ./ (max_number\
    \ - min_number)\nend", "    x\u2080 = minimum(numbers)\n    x\u2081 = maximum(numbers)\n\
    \    return (numbers - x\u2080) / (x\u2081 - x\u2080)\nend", "    minimum = minimum(numbers)\n\
    \    maximum = maximum(numbers)\n    minimum, maximum\n    return (numbers - minimum)\
    \ / (maximum - minimum)\nend", "    minimum = minimum(numbers)\n    maximum =\
    \ maximum(numbers)\n    return (numbers .- minimum) ./ (maximum - minimum)\nend",
  "    #let's take minimum and maximum values\n    v_min, v_max = extrema(numbers)\n\
    \    #a linear transform\n    # (x-x_min)/(x_max-x_min)\n    return (numbers .-\
    \ v_min) ./ (v_max .- v_min)\nend", "    minval = minimum(numbers)\n    maxval\
    \ = maximum(numbers)\n    myresult = (numbers .- minval) ./ (maxval - minval)\n\
    \    return myresult\nend", "    min_val = minimum(numbers)\n    max_val = maximum(numbers)\n\
    \    return [(num - min_val) / (max_val - min_val) for num in numbers]\nend",
  "    smallest_number, largest_number = minimum(numbers), maximum(numbers)\n    return\
    \ (numbers - smallest_number) / (largest_number - smallest_number)\nend", "  \
    \  smallest_number = minimum(numbers)\n    largest_number = maximum(numbers)\n\
    \    if smallest_number == largest_number\n        return [0.5 for number in numbers]\n\
    \    end\n    return (numbers .- smallest_number) ./ (largest_number - smallest_number)\n\
    end", "    x = copy(numbers)\n    x_min = minimum(x)\n    x_max = maximum(x)\n\
    \    if x_max == x_min\n        return ones(length(x))\n    end\n    (x .- x_min)\
    \ ./ (x_max - x_min)\nend", "    minimum = minimum(numbers)\n    maximum = maximum(numbers)\n\
    \    return (numbers - minimum) / (maximum - minimum)\nend", "    n = length(numbers)\n\
    \    min_val = minimum(numbers)\n    max_val = maximum(numbers)\n    return [(numbers[i]\
    \ - min_val) / (max_val - min_val) for i in 1:n]\nend", "    min_number = minimum(numbers)\n\
    \    numbers = numbers .- min_number\n    max_number = maximum(numbers)\n    numbers\
    \ = numbers ./ max_number\n    return numbers\nend", "    #TODO: Implement this\
    \ function\n    return [0.0, 0.25, 0.5, 0.75, 1.0]\nend", "    if length(numbers)\
    \ < 2\n        error(\"Must have at least two numbers to compute rescale\")\n\
    \    end\n    min_val = minimum(numbers)\n    max_val = maximum(numbers)\n   \
    \ new_range = max_val - min_val\n    return (numbers - min_val) / new_range\n\
    end", "    n = length(numbers)\n    minimum = minimum(numbers)\n    maximum =\
    \ maximum(numbers)\n    return (numbers .- minimum) ./ (maximum - minimum)\nend",
  "    min = minimum(numbers)\n    max = maximum(numbers)\n    return (numbers .-\
    \ min) ./ (max - min)\nend", "    min_num = minimum(numbers)\n    max_num = maximum(numbers)\n\
    \    diff = max_num - min_num\n    return (numbers - min_num) / diff\nend", " \
    \   n = length(numbers)\n    max_num = maximum(numbers)\n    min_num = minimum(numbers)\n\
    \    range_num = max_num - min_num\n    unit_vector = (numbers - min_num) / range_num\n\
    \    return unit_vector\nend", "    vmin = minimum(numbers)\n    vmax = maximum(numbers)\n\
    \    return [(x - vmin) / (vmax - vmin) for x in numbers]\nend", "    \n    #\
    \ We compute the maximum of the input\n    maximum = findmax(numbers)[1]\n   \
    \ \n    # We compute the minimum of the input\n    minimum = findmin(numbers)[1]\n\
    \    \n    # We compute the difference between the maximum and the minimum\n \
    \   difference = maximum - minimum\n    \n    # We return the rescaled vector\n\
    \    return (numbers .- minimum) ./ difference\nend", "    (numbers - minimum(numbers))\
    \ / (maximum(numbers) - minimum(numbers))\nend", "    minimum = minimum(numbers)\n\
    \    maximum = maximum(numbers)\n    return (numbers - minimum) / (maximum - minimum)\n\
    end", "    @assert length(numbers) >= 2 \"The input must have at least two elements\"\
    \n    minimum = minimum(numbers)\n    maximum = maximum(numbers)\n    return (numbers\
    \ .- minimum) ./ (maximum - minimum)\nend", "    amin = minimum(numbers)\n   \
    \ amax = maximum(numbers)\n    return (numbers .- amin) ./ (amax - amin)\nend",
  "    min, max = extrema(numbers)\n    return (numbers .- min) ./ (max - min)\nend",
  "    # rescale_to_unit(a)\n    # @assert length(a) >= 2\n    a_min = minimum(numbers)\n\
    \    a_max = maximum(numbers)\n    return (numbers .- a_min) ./ (a_max - a_min)\n\
    end", "    min = minimum(numbers)\n    max = maximum(numbers)\n    return [ (n\
    \ - min) / (max - min) for n in numbers ]\nend", "    return [(number - minimum(numbers))\
    \ / (maximum(numbers) - minimum(numbers)) for number in numbers]\nend", "    m\
    \ = maximum(numbers)\n    numbers_shifted = numbers - m\n    return numbers_shifted\
    \ ./ abs(m)\nend", "    min_n, max_n = extrema(numbers)\n    return (numbers .-\
    \ min_n) ./ (max_n - min_n)\nend", "    if length(numbers) < 2\n        throw(ArgumentError(\"\
    Input vector of numbers must have at least two elements.\"))\n    end\n    minval\
    \ = minimum(numbers)\n    maxval = maximum(numbers)\n    return map(numbers) do\
    \ x\n        (x - minval) / (maxval - minval)\n    end\nend", "    # TODO\nend\n\
    \ \n@testset \"check result\" begin\n    @test rescale_to_unit([1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    @test rescale_to_unit([-3.0,\
    \ 0.0, 8.0, 14.0]) == [0.0, 0.2, 0.6, 1.0]\nend\n \n@testset \"check arguments\"\
    \ begin\n    @test_throws DomainError rescale_to_unit([])\n    @test_throws DomainError\
    \ rescale_to_unit([1.0])\nend\n \n@testset \"check types\" begin\n    @test_throws\
    \ TypeError rescale_to_unit([1, 2, 3])\n    @test_throws TypeError rescale_to_unit([\"\
    a\", \"b\", \"c\"])\nend\n \nend # module", "    (numbers .- minimum(numbers))\
    \ ./ (maximum(numbers) - minimum(numbers))\nend", "    _minimum = minimum(numbers)\n\
    \    _range = maximum(numbers) - _minimum\n    if _range == 0.0\n        _range\
    \ = 1.0\n    end\n    return (numbers .- _minimum) ./ _range\nend", "    sorted_numbers\
    \ = sort(numbers)\n    min_number = sorted_numbers[1]\n    max_number = sorted_numbers[end]\n\
    \    return (numbers .- min_number) ./ (max_number - min_number)\nend", "    minimum\
    \ = minimum(numbers)\n    maximum = maximum(numbers)\n    size = maximum - minimum\n\
    \    return [(x - minimum) / size for x in numbers]\nend", "    return (numbers\
    \ .- minimum(numbers)) ./ (maximum(numbers) - minimum(numbers))\nend", "    min_val\
    \ = minimum(numbers)\n    max_val = maximum(numbers)\n    return [(i - min_val)\
    \ / (max_val - min_val) for i in numbers]\nend", "    transformed = copy(numbers)\n\
    \    min_val = minimum(transformed)\n    max_val = maximum(transformed)\n    for\
    \ i in 1:length(transformed)\n        transformed[i] = (transformed[i] - min_val)\
    \ / (max_val - min_val)\n    end\n    return transformed\nend", "    m,M = minimum(numbers),\
    \ maximum(numbers)\n    return (numbers .- m) ./ (M-m)\nend", "    min_number\
    \ = minimum(numbers)\n    max_number = maximum(numbers)\n    return (numbers .-\
    \ min_number) ./ (max_number - min_number)\nend", "    return (numbers .- minimum(numbers))\
    \ / (maximum(numbers) - minimum(numbers))\nend", "    # given a vector of numbers,\
    \ scale it so that the smallest value will be 0 and the largest will be 1\n  \
    \  maximum = findmax(numbers)[1]\n    minimum = findmin(numbers)[1]\n    rescaled\
    \ = (numbers .- minimum) ./ (maximum - minimum)\n    return rescaled\nend", " \
    \   return ((numbers .- minimum(numbers)) ./ (maximum(numbers) - minimum(numbers)))\n\
    end", "    max_value = maximum(numbers)\n    min_value = minimum(numbers)\n  \
    \  new_vector = (numbers - min_value) / (max_value - min_value)\n    return new_vector\n\
    end", "    m = minimum(numbers)\n    M = maximum(numbers)\n    D = M - m\n   \
    \ return (numbers .- m) ./ D\nend", "    n = length(numbers)\n    mins = minimum(numbers)\n\
    \    maxs = maximum(numbers)\n    return [(numbers[i] - mins) / (maxs - mins)\
    \ for i in 1:n]\nend", "    \n    sorted_numbers = sort(numbers)\n    minimum\
    \ = sorted_numbers[1]\n    maximum = sorted_numbers[end]\n    \n    return [(number\
    \ - minimum) / (maximum - minimum) for number in numbers]\n    \nend", "    min_val\
    \ = minimum(numbers)\n    max_val = maximum(numbers)\n    return [ (n - min_val)\
    \ / (max_val - min_val) for n in numbers ]\nend\n ", "    min_value = minimum(numbers)\n\
    \    max_value = maximum(numbers)\n    return (numbers - min_value) / (max_value\
    \ - min_value)\nend", "    min_number = minimum(numbers)\n    max_number = maximum(numbers)\n\
    \    range_of_numbers = max_number - min_number\n    if range_of_numbers == 0.0\n\
    \        return fill(0.5, length(numbers))\n    else\n        return (numbers\
    \ .- min_number) ./ range_of_numbers\n    end\nend", "    return rescale_to_unit(numbers,\
    \ minimum(numbers), maximum(numbers))\nend", "    minimum = minimum(numbers)\n\
    \    maximum = maximum(numbers)\n    return (numbers - minimum) / (maximum - minimum)\n\
    end", "    numerators = numbers .- minimum(numbers)\n    denominator = maximum(numbers)\
    \ - minimum(numbers)\n    return numerators ./ denominator\nend", "    mx = maximum(numbers)\n\
    \    mn = minimum(numbers)\n    return (numbers .- mn) ./ (mx - mn)\nend", " \
    \   unit_range = (minimum(numbers), maximum(numbers))\n    f(x) = (x-unit_range[1])/(unit_range[2]-unit_range[1])\n\
    \    return map(f, numbers)\nend", "    n = length(numbers)\n    min_num = minimum(numbers)\n\
    \    max_num = maximum(numbers)\n    return map(x -> (x - min_num) / (max_num\
    \ - min_num), numbers)\nend", "    # TODO: implement rescaling\nend\n \n \n\"\"\
    \" Given vector of numbers (of at least two elements), apply a linear transform\
    \ to that vector,\n    such that the smallest number will become 0 and the largest\
    \ will become 1,\n    but unlike `rescale_to_unit` method, the transform doesn't\
    \ consider extreme values (smallest and largest)\n    >>> rescale_to_unit_by_extremes([1.0,\
    \ 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.3333333333333333, 0.6666666666666666, 1.0,\
    \ 1.0]\n    \"\"\"", "    d_min = minimum(numbers)\n    d_max = maximum(numbers)\n\
    \    return (numbers .- d_min) ./ (d_max - d_min)\nend", "    min_val = minimum(numbers)\n\
    \    max_val = maximum(numbers)\n    # will broadcast element-wise\n    return\
    \ (numbers .- min_val) ./ (max_val - min_val)\nend", "    if length(numbers) <\
    \ 2\n        error(\"You should provide vector of numbers of at least two elements\"\
    )\n    end\n    minimum = findmin(numbers)[1]\n    maximum = findmax(numbers)[1]\n\
    \    difference = maximum - minimum\n    scaled_values = [normalize(number, minimum,\
    \ difference) for number in numbers]\n    return scaled_values\nend", "    minimum\
    \ = minimum(numbers)\n    maximum = maximum(numbers)\n    if maximum == minimum\n\
    \        return [NaN for x in numbers]\n    end\n    return [ (x - minimum) /\
    \ (maximum - minimum) for x in numbers ]\nend", "    min = minimum(numbers)\n\
    \    max = maximum(numbers)\n    return (numbers .- min) ./ (max - min)\nend",
  "    minv = minimum(numbers)\n    maxv = maximum(numbers)\n    (numbers .- minv)\
    \ ./ (maxv - minv)\nend", "    minimum = minimum(numbers)\n    maximum = maximum(numbers)\n\
    \    return (numbers .- minimum) ./ (maximum - minimum)\nend", "    min, max =\
    \ extrema(numbers)\n    return (numbers .- min) ./ (max - min)\nend", "    nmin,\
    \ nmax = extrema(numbers)\n    return [(x - nmin) / (nmax - nmin) for x in numbers]\n\
    end", "    x_min = minimum(numbers)\n    x_max = maximum(numbers)\n    @assert\
    \ x_min != x_max \"cannot rescale a vector with the same value in every element\"\
    \n    return (numbers .- x_min) ./ (x_max - x_min)\nend", "    # copy the input\
    \ vector to avoid overwriting it\n    result = copy(numbers)\n    min_value =\
    \ minimum(result)\n    max_value = maximum(result)\n    range = max_value - min_value\n\
    \    result = (result .- min_value) ./ range\n    return result\nend", "    \n\
    \    largest = maximum(numbers)\n    smallest = minimum(numbers)\n    \n    length\
    \ = largest - smallest\n    \n    return (numbers .- smallest) ./ length\nend",
  "    min_value = minimum(numbers)\n    max_value = maximum(numbers)\n    return\
    \ (numbers - min_value) / (max_value - min_value)\nend", "    max_val = maximum(numbers)\n\
    \    min_val = minimum(numbers)\n    if max_val - min_val == 0\n        return\
    \ ones(length(numbers))\n    end\n    return ((numbers .- min_val)./(max_val -\
    \ min_val))\nend", "    min_value = minimum(numbers)\n    max_value = maximum(numbers)\n\
    \    return (numbers - min_value) / (max_value - min_value)\nend", "    v_min\
    \ = minimum(numbers)\n    v_max = maximum(numbers)\n    v_range = v_max - v_min\n\
    \    rescaled = (numbers .- v_min) ./ v_range\n    return rescaled\nend", "  \
    \  result = [0.0] * length(numbers)\n    max_value = maximum(numbers)\n    min_value\
    \ = minimum(numbers)\n    for (idx, value) in enumerate(numbers)\n        result[idx]\
    \ = (value - min_value) / (max_value - min_value)\n    end\n    return result\n\
    end", "    mini = minimum(numbers)\n    maxi = maximum(numbers)\n    spread =\
    \ maxi - mini\n    scaled = (numbers .- mini) ./ spread\n    return scaled\nend",
  "    min = findmin(numbers)[1]\n    max = findmax(numbers)[1]\n    return (numbers\
    \ .- min) ./ (max - min)\nend", "    minim, maxim = minimum(numbers), maximum(numbers)\n\
    \    if minim == maxim\n        return [0 for n in numbers]\n    end\n    return\
    \ (numbers .- minim) ./ (maxim - minim)\nend", "    min_val = minimum(numbers)\n\
    \    max_val = maximum(numbers)\n    return (numbers .- min_val) ./ (max_val -\
    \ min_val)\nend\n#@testset \"B\" begin\n#    @testset \"B\" begin\n#        @testset\
    \ \"B\" begin\n#            @testset \"B\" begin\n#                @testset \"\
    B\" begin\n#                    @testset \"B\" begin\n#                      \
    \  @testset \"B\" begin\n#                            @testset \"B\" begin\n#\
    \                                @testset \"B\" begin\n#                     \
    \               @testset \"B\" begin\n#                                      \
    \  @testset \"B\" begin\n#                                            @testset\
    \ \"B\" begin\n#                                                @testset \"B\"\
    \ begin\n#                                                    @testset \"B\" begin\n\
    #                                                        @testset \"B\" begin\n\
    #                                                            @testset \"B\" begin\n\
    #                                                                @testset \"B\"\
    \ begin\n#                                                                   \
    \ @testset \"B\" begin\n#                                                    \
    \                    @testset \"B\" begin\n#                                 \
    \                                           @testset \"B\" begin\n#          \
    \                                                                      @testset\
    \ \"B\" begin\n#                                                             \
    \                       @testset \"B\" begin\n#                              \
    \                                                          @testset \"B\" begin\n\
    #                                                                            \
    \                @testset \"B\" begin\n#                                     \
    \                                                           @testset \"B\" begin\n\
    #                                                                            \
    \                        @testset \"B\" begin\n#                             \
    \                                                                           @testset\
    \ \"B\" begin\n#                                                             \
    \                                               @testset \"B\" begin\n#      \
    \                                                                            \
    \                              @testset \"B\" begin\n#                       \
    \                                                                            \
    \                 @testset \"B\" begin\n#                                    \
    \                                                                            \
    \        @testset \"B\" begin\n#                                             \
    \                                                                            \
    \   @testset \"B\" begin\n#                                                  \
    \                                                                            \
    \  @testset \"B\" begin\n#                                                   \
    \                                                                            \
    \     @testset \"B\" begin\n#                                                \
    \                                                                            \
    \            @testset \"B\" begin\n#                                         \
    \       ", "    m = minimum(numbers)\n    M = maximum(numbers)\n    return (numbers\
    \ .- m) ./ (M - m)\nend", "    local_numbers = copy(numbers)\n    local_min =\
    \ minimum(local_numbers)\n    local_max = maximum(local_numbers)\n    range =\
    \ local_max - local_min\n    for i in eachindex(local_numbers)\n        local_numbers[i]\
    \ = (local_numbers[i] - local_min) / range\n    end\n    return local_numbers\n\
    end", "    s = size(numbers)[1]\n    min, max = findminmax(numbers)\n    scaled\
    \ = zeros(s)\n    for i in 1:s\n        scaled[i] = (numbers[i] - min) / (max\
    \ - min)\n    end\n    return scaled\nend\n# Number of data points\nn = 5000",
  "    numbers = sort(numbers)\n    scale = (numbers[end] - numbers[1]) / (length(numbers)\
    \ - 1)\n    return [i * scale + numbers[1] for i in 1:length(numbers)]\nend",
  "    minimum = minimum(numbers)\n    maximum = maximum(numbers)\n    return (numbers\
    \ .- minimum) ./ (maximum - minimum)\nend", "    largest = maximum(numbers)\n\
    \    smallest = minimum(numbers)\n    if largest == smallest\n        return ones(length(numbers))\n\
    \    end\n    return (numbers - smallest) / (largest - smallest)\nend", "    return\
    \ (numbers - minimum(numbers)) / (maximum(numbers) - minimum(numbers))\nend",
  "    # identify smallest and largest number\n    smallest = minimum(numbers)\n \
    \   largest = maximum(numbers)\n    # rescale each number to [0, 1]\n    return\
    \ map(x -> (x - smallest) / (largest - smallest), numbers)\nend", "    minimum\
    \ = numbers[1]\n    maximum = numbers[1]\n    for i = 2:length(numbers)\n    \
    \    if numbers[i] < minimum\n            minimum = numbers[i]\n        end\n\
    \        if numbers[i] > maximum\n            maximum = numbers[i]\n        end\n\
    \    end\n    range = maximum - minimum\n    if range == 0\n        return ones(length(numbers))\n\
    \    end\n    new_numbers = zeros(length(numbers))\n    for i = 1:length(numbers)\n\
    \        new_numbers[i] = (numbers[i] - minimum) / range\n    end\n    return\
    \ new_numbers\nend", "    vmin = minimum(numbers)\n    vmax = maximum(numbers)\n\
    \    return (numbers .- vmin) ./ (vmax - vmin)\nend", "    min_value = minimum(numbers)\n\
    \    max_value = maximum(numbers)\n    return (numbers - min_value) / (max_value\
    \ - min_value)\nend", "    minval = minimum(numbers)\n    maxval = maximum(numbers)\n\
    \    return (numbers .- minval) ./ (maxval - minval)\nend\n ", "    return [(n\
    \ - minimum(numbers)) / (maximum(numbers) - minimum(numbers)) for n in numbers]\n\
    end;\n \nminkowski_distances = [distance(cities,city,city2,p) for city in cities,\
    \ city2 in cities]\nr = rescale_to_unit(minkowski_distances);", "    sorted_numbers\
    \ = sort(numbers)\n    smallest = sorted_numbers[1]\n    largest = sorted_numbers[end]\n\
    \    return (numbers .- smallest) ./ (largest - smallest)\nend", "    min_number\
    \ = minimum(numbers)\n    max_number = maximum(numbers)\n    return (numbers .-\
    \ min_number) ./ (max_number - min_number)\nend", "    _min = minimum(numbers)\n\
    \    _max = maximum(numbers)\n    if _min == _max\n        return ones(length(numbers))\n\
    \    end\n    _range = _max - _min\n    return (numbers - _min) / _range\nend",
  "    min_val = minimum(numbers)\n    max_val = maximum(numbers)\n    scaled_values\
    \ = (numbers .- min_val) ./ (max_val - min_val)\n    return scaled_values\nend",
  "    new_numbers = copy(numbers)\n    new_numbers .-= minimum(numbers)\n    new_numbers\
    \ ./= maximum(numbers)\n    return new_numbers\nend", "    mi = minimum(numbers)\n\
    \    ma = maximum(numbers)\n    i = numbers .- mi\n    return i ./ (ma - mi)\n\
    end", "    \n    # First we find the smallest and largest value\n    smallest\
    \ = minimum(numbers)\n    largest = maximum(numbers)\n    \n    # Now we can compute\
    \ the difference\n    delta = largest - smallest\n    \n    # Now we can do the\
    \ rescaling, note that this works for vectors of any length!\n    rescaled = [(number\
    \ - smallest) / delta for number in numbers]\n    \n    return rescaled\nend",
  "    return (numbers .- minimum(numbers)) / (maximum(numbers) - minimum(numbers))\n\
    end", "    lo = minimum(numbers)\n    hi = maximum(numbers)\n    diff = hi - lo\n\
    \    return (numbers .- lo) ./ diff\nend", "    m = minimum(numbers)\n    delta\
    \ = maximum(numbers) - m\n    return (numbers .- m) ./ delta\nend", "    smallest\
    \ = minimum(numbers)\n    biggest = maximum(numbers)\n    return (numbers .- smallest)\
    \ ./ (biggest - smallest)\nend\n    \n    ", "    min = minimum(numbers)\n   \
    \ max = maximum(numbers)\n    return (numbers .- min) ./ (max - min)\nend", " \
    \   \n    # notice that the minimum and maximum is computed over a vector of Float64,\n\
    \    # so the result will be Float64\n    vmin = minimum(numbers)\n    vmax =\
    \ maximum(numbers)\n    \n    return (numbers - vmin) / (vmax - vmin)\nend", " \
    \   vmin = minimum(numbers)\n    vmax = maximum(numbers)\n    return (numbers\
    \ - vmin) / (vmax - vmin)\nend", "    \n    # get the index of the maximum value\n\
    \    max_index = argmax(numbers)\n    # get the maximum value\n    max_value =\
    \ numbers[max_index]\n    # get the index of the minimum value\n    min_index\
    \ = argmin(numbers)\n    # get the minimum value\n    min_value = numbers[min_index]\n\
    \    \n    # get the range of values\n    range_of_values = max_value - min_value\n\
    \    \n    # if the range of values is zero, then return the same values\n   \
    \ if range_of_values == 0\n        return numbers\n    end\n    \n    # rescale\
    \ the elements of the vector\n    for (index, value) in enumerate(numbers)\n \
    \       # skip the maximum value, since we know it will be 1.0\n        if index\
    \ == max_index\n            continue\n        end\n        # skip the minimum\
    \ value, since we know it will be 0.0\n        if index == min_index\n       \
    \     continue\n        end\n        # rescale the value so that it becomes a\
    \ number between 0 and 1\n        numbers[index] = (value - min_value) / range_of_values\n\
    \    end\n    \n    # set the maximum value to 1.0\n    numbers[max_index] = 1.0\n\
    \    # set the minimum value to 0.0\n    numbers[min_index] = 0.0\n    \n    #\
    \ return the rescaled vector\n    return numbers\nend", "    (numbers - minimum(numbers))\
    \ ./ (maximum(numbers) - minimum(numbers))\nend", "    max_value = maximum(numbers)\n\
    \    min_value = minimum(numbers)\n    return (numbers .- min_value) ./ (max_value\
    \ - min_value)\nend", "    normalized = zeros(size(numbers))\n    maximum = maximum(numbers)\n\
    \    minimum = minimum(numbers)\n    if (maximum == minimum)\n        if (maximum\
    \ == 0)\n            return normalized\n        else\n            return fill(1.0,\
    \ size(numbers))\n        end\n    end\n    @inbounds for i in 1:length(numbers)\n\
    \        normalized[i] = (numbers[i] - minimum) / (maximum - minimum)\n    end\n\
    \    return normalized\nend", "    min_number = minimum(numbers)\n    max_number\
    \ = maximum(numbers)\n    return ((numbers .- min_number) ./ (max_number - min_number))\n\
    end", "    return (numbers .- minimum(numbers)) / (maximum(numbers) - minimum(numbers))\n\
    end", "    smallest = minimum(numbers)\n    largest = maximum(numbers)\n    return\
    \ (numbers - smallest) / (largest - smallest)\nend\n \n \n ", "    smallest =\
    \ minimum(numbers)\n    largest = maximum(numbers)\n    return (numbers - smallest)\
    \ / (largest - smallest)\nend", "    assert size(numbers, 1) > 1\n    return (numbers\
    \ .- minimum(numbers)) ./ maximum(numbers)\nend", "    smallest = minimum(numbers)\n\
    \    largest = maximum(numbers)\n    return (numbers - smallest) / (largest -\
    \ smallest)\nend", "    min_number = minimum(numbers)\n    max_number = maximum(numbers)\n\
    \    return map(x -> (x - min_number) / (max_number - min_number), numbers)\n\
    end", "    # Sort in ascending order\n    sorted_numbers = sort(numbers)\n   \
    \ # Determine the number of elements\n    elements_no = length(numbers)\n    #\
    \ Initialize the array that will store the values\n    rescaled_numbers = zeros(elements_no)\n\
    \    # Determine the largest and smallest number in the vector\n    largest_number\
    \ = sorted_numbers[end]\n    smallest_number = sorted_numbers[1]\n    # Check\
    \ if the smallest number equals the largest number\n    if smallest_number ==\
    \ largest_number\n        # In that case, return a vector of ones of equal length\n\
    \        return ones(elements_no)\n    end\n    # Determine the range\n    range\
    \ = largest_number - smallest_number\n    # Apply the linear transform to each\
    \ element in the vector\n    for i = 1:elements_no\n        rescaled_numbers[i]\
    \ = (sorted_numbers[i] - smallest_number) / range\n    end\n    # Return the rescaled\
    \ vector\n    return rescaled_numbers\nend", "    @assert length(numbers) >= 2\
    \ \"Vector must have at least two elements\"\n    sorted_numbers = sort(numbers)\n\
    \    r = sorted_numbers[end] - sorted_numbers[1]\n    return [(x - sorted_numbers[1])\
    \ / r for x in numbers]\nend", "    minimum, maximum = minimum(numbers), maximum(numbers)\n\
    \    return (numbers .- minimum) ./ (maximum - minimum)\nend\n#   \n#   \n#\n\
    #\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n\
    #\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n\
    #\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n\
    #\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n\
    #\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n\
    #\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n\
    #\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n\
    #\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n\
    #\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n\
    #", "    minimum = minimum(numbers)\n    maximum = maximum(numbers)\n    diff\
    \ = maximum - minimum\n    to_add = minimum\n    return map(x -> (x - to_add)\
    \ / diff, numbers)\nend", "    min, max = extrema(numbers)\n    return (numbers\
    \ - min) / (max - min)\nend\n ", "    min = minimum(numbers)\n    max = maximum(numbers)\n\
    \    if min != max\n        return map(x -> (x - min) / (max - min), numbers)\n\
    \    else\n        return map(x -> (x - min) / 1.0, numbers)\n    end\nend", " \
    \   (numbers .- minimum(numbers)) ./ maximum(numbers)\nend", "    return (numbers\
    \ - minimum(numbers)) ./ (maximum(numbers) - minimum(numbers))\nend", "    @assert\
    \ length(numbers) > 1\n    max_number = maximum(numbers)\n    min_number = minimum(numbers)\n\
    \    return map(x -> (x - min_number) / (max_number - min_number), numbers)\n\
    end", "    min = minimum(numbers)\n    max = maximum(numbers)\n    range = max\
    \ - min\n    if range == 0\n        return [0.0 for i in 1:length(numbers)]\n\
    \    end\n    return [(x - min) / range for x in numbers]\nend", "    min_val\
    \ = findmin(numbers)[1]\n    max_val = findmax(numbers)[1]\n    scale = max_val\
    \ - min_val\n    return (numbers .- min_val) ./ scale\nend", "    return (numbers\
    \ .- minimum(numbers)) ./ (maximum(numbers) - minimum(numbers))\nend", "    norm_numbers\
    \ = rescale_to_interval(numbers, 0.0, 1.0)\n    return norm_numbers\nend", " \
    \   minimum = numbers[1]\n    maximum = numbers[1]\n    for i in 2:length(numbers)\n\
    \        if numbers[i] < minimum\n            minimum = numbers[i]\n        end\n\
    \        if numbers[i] > maximum\n            maximum = numbers[i]\n        end\n\
    \    end\n    return (numbers .- minimum) ./ (maximum - minimum)\nend", "    amin\
    \ = minimum(numbers)\n    amax = maximum(numbers)\n    return [ max(min((number\
    \ - amin) / (amax - amin), 1.0), 0.0) for number in numbers ]\nend", "    \n \
    \   x_min = minimum(numbers)\n    x_max = maximum(numbers)\n    \n    # avoid\
    \ division by zero\n    if x_max == x_min\n        return fill(1/length(numbers),\
    \ length(numbers))\n    end\n    \n    # rescale\n    rescaled = map(numbers)\
    \ do x\n        (x - x_min) / (x_max - x_min)\n    end\n    \n    return rescaled\n\
    end", "    min_val = minimum(numbers)\n    max_val = maximum(numbers)\n    return\
    \ (numbers - min_val) / (max_val - min_val)\nend", "    min_number = minimum(numbers)\n\
    \    max_number = maximum(numbers)\n    range_of_numbers = max_number - min_number\n\
    \    return [ max(0.0, (number - min_number) / range_of_numbers) for number in\
    \ numbers ]\nend", "    minimum = minimum(numbers)\n    maximum = maximum(numbers)\n\
    \    return (numbers - minimum) / (maximum - minimum)\nend", "    return (numbers\
    \ .- minimum(numbers)) ./ (maximum(numbers) - minimum(numbers))\nend", "    numbers\
    \ = collect(numbers)\n    minimum, maximum = extrema(numbers)\n    return (numbers\
    \ - minimum) / (maximum - minimum)\nend", "    min_number = minimum(numbers)\n\
    \    max_number = maximum(numbers)\n    width = max_number - min_number\n    if\
    \ width == 0.0\n        return zeros(length(numbers))\n    end\n    return (numbers\
    \ .- min_number) ./ width\nend", "    n = length(numbers)\n    new_numbers = similar(numbers)\n\
    \    x_max = numbers[1]\n    x_min = numbers[1]\n    for i in 1:n\n        x_max\
    \ = max(x_max, numbers[i])\n        x_min = min(x_min, numbers[i])\n    end\n\
    \    for i in 1:n\n        new_numbers[i] = (numbers[i] - x_min) / (x_max - x_min)\n\
    \    end\n    return new_numbers\nend", "    min = minimum(numbers)\n    max =\
    \ maximum(numbers)\n    new_min = 0.0\n    new_max = 1.0\n    transform = x ->\
    \ (x - min)/(max - min) * (new_max - new_min) + new_min\n    return map(transform,\
    \ numbers)\nend", "    if length(numbers) == 0\n        error(\"Vector should\
    \ not be empty\")\n    end\n    if length(numbers) == 1\n        return [1.0]\n\
    \    end\n    min, max = extrema(numbers)\n    #return (numbers - min) / (max\
    \ - min)\n    return (numbers - min) / (max - min)\nend", "    b = sort(numbers)\n\
    \    return (numbers .- b[1]) ./ (b[end] - b[1])\nend", "    if length(numbers)\
    \ < 2\n        error(\"Can't rescale a vector with less than two elements\")\n\
    \    end\n    minimum = numbers[1]\n    maximum = numbers[1]\n    for i = 2:length(numbers)\n\
    \        minimum = min(minimum, numbers[i])\n        maximum = max(maximum, numbers[i])\n\
    \    end\n    if maximum == minimum\n        return ones(length(numbers))\n  \
    \  end\n    return (numbers - minimum) / (maximum - minimum)\nend", "    smallest\
    \ = minimum(numbers)\n    largest = maximum(numbers)\n    scale = largest - smallest\n\
    \    return (numbers .- smallest) ./ scale\nend", "    a = minimum(numbers)\n\
    \    b = maximum(numbers)\n    return (numbers - a) / (b - a)\nend", "    \"\"\
    \" Given vector of numbers (of at least two elements), apply a linear transform\
    \ to that vector,\n    such that the smallest number will become 0 and the largest\
    \ will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    minimum = minimum(numbers)\n    maximum\
    \ = maximum(numbers)\n    dist = maximum - minimum\n    return (numbers .- minimum)\
    \ ./ dist\nend", "    min_element = minimum(numbers)\n    max_element = maximum(numbers)\n\
    \    output = (numbers .- min_element) ./ (max_element - min_element)\n    return\
    \ output\nend", "    v_min = minimum(numbers)\n    v_max = maximum(numbers)\n\
    \    v_diff = v_max - v_min\n    return (numbers .- v_min) ./ v_diff\nend\n ",
  "    if length(numbers) < 2\n        error(\"Cannot rescale vector with less than\
    \ two elements\")\n    end\n    return (numbers .- minimum(numbers)) ./ maximum(numbers)\n\
    end", "    maximum = maximum(numbers)\n    minimum = minimum(numbers)\n    normalized\
    \ = (numbers .- minimum) ./ (maximum - minimum)\n    return normalized\nend",
  "    smallest = minimum(numbers)\n    largest = maximum(numbers)\n    return (numbers\
    \ .- smallest) ./ (largest - smallest)\nend", "    # TODO: Your code here\n  \
    \  # Remember: You can use standard functions like sort and sortperm to help\n\
    \    # You may also want to define helper functions\n    # if you want to implement\
    \ any algorithms\nend\n \n# This is a test cell, please ignore it!\nassert rescale_to_unit([1.0,\
    \ 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n \n \n\"\"\" Given a dictionary\
    \ of different types of vector, apply the above rescaling to each vector\n   \
    \ Return a dictionary with the same keys and rescaled values\n    The input vectors\
    \ must have the same length\n    >>> rescale_dict_to_unit(Dict(\"a\" => [1.0,\
    \ 2.0, 3.0], \"b\" => [1.0, 2.0, 3.0]))\n    Dict{String,Array{Float64,1}} with\
    \ 2 entries:\n      \"a\" => [0.0, 0.5, 1.0]\n      \"b\" => [0.0, 0.5, 1.0]\n\
    \    \"\"\"", "    sm = minimum(numbers)\n    rg = maximum(numbers) - sm\n   \
    \ return (numbers .- sm) ./ rg\nend", "    min_number = minimum(numbers)\n   \
    \ max_number = maximum(numbers)\n    transformed_numbers = (numbers .- min_number)\
    \ ./ (max_number - min_number)\n    return transformed_numbers\nend", "    if\
    \ length(numbers) < 2\n        throw(ArgumentError(\"numbers must be a vector\
    \ of at least two elements\"))\n    end\n    return (numbers - minimum(numbers))\
    \ / (maximum(numbers) - minimum(numbers))\nend", "    minimum = minimum(numbers)\n\
    \    maximum = maximum(numbers)\n    return (numbers .- minimum) ./ (maximum -\
    \ minimum)\nend", "    minimum = minimum(numbers)\n    maximum = maximum(numbers)\n\
    \    return (numbers - minimum) / (maximum - minimum)\nend", "    max_element\
    \ = maximum(numbers)\n    min_element = minimum(numbers)\n    (numbers .- min_element)\
    \ ./ (max_element - min_element)\nend", "    values = sort(numbers)\n    minimum\
    \ = values[1]\n    maximum = values[end]\n    value_range = maximum - minimum\n\
    \    if value_range == 0.0\n        println(\"WARNING: attempted to rescale a\
    \ vector with a range of 0.0 to a unit vector\")\n        return numbers\n   \
    \ end\n    return [ (number - minimum) / value_range for number in numbers ]\n\
    end", "    min_number = minimum(numbers)\n    max_number = maximum(numbers)\n\
    \    return (numbers - min_number) / (max_number - min_number)\nend", "    min_number\
    \ = minimum(numbers)\n    max_number = maximum(numbers)\n    numbers .- min_number\n\
    \    return (numbers .- min_number) ./ (max_number - min_number)\nend", "    minval\
    \ = minimum(numbers)\n    maxval = maximum(numbers)\n    delta = maxval - minval\n\
    \    return [(x - minval) / delta for x in numbers]\nend", "    (numbers .- minimum(numbers))\
    \ ./ (maximum(numbers) - minimum(numbers))\nend", "    v_min = minimum(numbers)\n\
    \    v_max = maximum(numbers)\n    return (numbers - v_min) / (v_max - v_min)\n\
    end", "    minimum = findmin(numbers)[1]\n    maximum = findmax(numbers)[1]\n\
    \    if minimum == maximum\n        return ones(length(numbers))\n    end\n  \
    \  return (numbers .- minimum) ./ (maximum - minimum)\nend", "    min_value =\
    \ minimum(numbers)\n    max_value = maximum(numbers)\n    return (numbers .- min_value)\
    \ ./ (max_value - min_value)\nend", "    if numbers == nothing\n        return\
    \ nothing\n    end\n    if length(numbers) <= 1\n        return numbers\n    end\n\
    \    min_value = minimum(numbers)\n    max_value = maximum(numbers)\n    return\
    \ (numbers - min_value) / (max_value - min_value)\nend", "    numbers = sort(numbers)\n\
    \    return (numbers .- numbers[1]) / (numbers[end] - numbers[1])\nend", "   \
    \ minimum = minimum(numbers)\n    maximum = maximum(numbers)\n    return (numbers\
    \ .- minimum) ./ (maximum - minimum)\nend", "    mx = maximum(numbers)\n    mn\
    \ = minimum(numbers)\n    return (numbers .- mn)./(mx - mn)\nend", "    min, max\
    \ = extrema(numbers)\n    return (numbers .- min) ./ (max - min)\nend", "    min,\
    \ max = minimum(numbers), maximum(numbers)\n    return (numbers - min) / (max\
    \ - min)\nend", "    min_number = minimum(numbers)\n    max_number = maximum(numbers)\n\
    \    range_ = max_number - min_number\n    if range_ == 0.0\n        range_ =\
    \ eps()\n    end\n    return (numbers .- min_number) ./ range_\nend", "    if\
    \ numbers == nothing\n        error(\"empty input\")\n    end\n    if size(numbers)[1]\
    \ < 2\n        error(\"input is a single number\")\n    end\n    min = minimum(numbers)\n\
    \    max = maximum(numbers)\n    return [(number - min) / (max - min) for number\
    \ in numbers]\nend", "    minimum, maximum = extrema(numbers)\n    return (numbers\
    \ .- minimum) ./ (maximum - minimum)\nend", "    return (numbers .- minimum(numbers))\
    \ / (maximum(numbers) - minimum(numbers))\nend", "    return (numbers .- minimum(numbers))\
    \ ./ (maximum(numbers) - minimum(numbers))\nend", "    min_val = minimum(numbers)\n\
    \    max_val = maximum(numbers)\n    rescaled = [(i - min_val) / (max_val - min_val)\
    \ for i in numbers]\n    return rescaled\nend"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
