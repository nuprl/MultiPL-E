name: HumanEval_21_rescale_to_unit
language: jl
prompt: "\"\"\" Given vector of numbers (of at least two elements), apply a linear\
  \ transform to that vector,\n    such that the smallest number will become 0 and\
  \ the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
  \    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\nfunction rescale_to_unit(numbers::Vector{Float64})::Vector{Float64}\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = rescale_to_unit;\n\t@test(candidate([2.0,\
  \ 49.9]) == [0.0, 1.0])\n\t@test(candidate([100.0, 49.9]) == [1.0, 0.0])\n\t@test(candidate([1.0,\
  \ 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\n\t@test(candidate([2.0,\
  \ 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\n\t@test(candidate([12.0,\
  \ 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nend\n"
completions: ["    number_max = maximum(numbers)\n    number_min = minimum(numbers)\n\
    \    numerator = numbers .- number_min\n    denominator = number_max - number_min\n\
    \    return numerator ./ denominator\nend", "    minimum, maximum = extrema(numbers)\n\
    \    length = maximum - minimum\n    if length == 0 \n        return fill(0.5,\
    \ length(numbers))\n    end\n    if minimum == maximum \n        return fill(minimum,\
    \ length(numbers))\n    end\n    return (numbers .- minimum) ./ length\nend",
  "    if length(numbers) < 2\n        return numbers\n    end\n    minimum = numbers[1]\n\
    \    maximum = numbers[1]\n    for n in numbers\n        if n < minimum\n    \
    \        minimum = n\n        end\n        if n > maximum\n            maximum\
    \ = n\n        end\n    end\n    return [(n - minimum) / (maximum - minimum) for\
    \ n in numbers]\nend", "    vmin = minimum(numbers)\n    vmax = maximum(numbers)\n\
    \    return (numbers - vmin)/(vmax - vmin)\nend", "    # Make copy\n    numbers_unit\
    \ = copy(numbers)\n    # Find min and max\n    min_number = minimum(numbers_unit)\n\
    \    max_number = maximum(numbers_unit)\n    # Subtract the minimum\n    numbers_unit\
    \ .-= min_number\n    # Divide by the max - min\n    numbers_unit ./= (max_number\
    \ - min_number)\n    # Return\n    return numbers_unit\nend", "    minimum = minimum(numbers)\n\
    \    maximum = maximum(numbers)\n    range = maximum - minimum\n    return (numbers\
    \ .- minimum) ./ range\nend", "    numbers = numbers .- minimum(numbers) # shift\
    \ to positive numbers\n    numbers = numbers ./ maximum(numbers) # stretch to\
    \ max==1\n    return numbers\nend", "    min_number = minimum(numbers)\n    max_number\
    \ = maximum(numbers)\n    return (numbers - min_number) / (max_number - min_number)\n\
    end", "    _min = minimum(numbers)\n    _max = maximum(numbers)\n    if _min ==\
    \ _max\n        return ones(length(numbers))\n    end\n    (numbers .- _min) ./\
    \ (_max - _min)\nend", "    \"\"\"\n    Given vector of numbers (of at least two\
    \ elements), apply a linear transform to that vector,\n    such that the smallest\
    \ number will become 0 and the largest will become 1\n    \"\"\"\n    min = minimum(numbers)\n\
    \    max = maximum(numbers)\n    return [\n        (x - min) / (max - min)\n \
    \       for x in numbers\n    ]\nend", "    if length(numbers) < 2 \n        error(\"\
    must have at least two elements to rescale a vector\")\n    end\n    minimum,\
    \ maximum = extrema(numbers)\n    new_numbers = []\n    for number in numbers\n\
    \        if minimum == maximum\n            new_numbers = push!(new_numbers, 0.0)\n\
    \        else\n            new_numbers = push!(new_numbers, (number - minimum)\
    \ / (maximum - minimum))\n        end\n    end\n    return new_numbers\nend",
  "   \n    smallest = minimum(numbers)\n    largest = maximum(numbers)\n    distance\
    \ = largest - smallest\n    return (numbers - smallest) / distance\nend", "  \
    \  @assert length(numbers) > 1\n    @assert !any(isnan.(numbers))\n    minimum\
    \ = minimum(numbers)\n    maximum = maximum(numbers)\n    return (numbers .- minimum)\
    \ ./ (maximum - minimum)\nend\n ", "    minimum = minimum(numbers)\n    maximum\
    \ = maximum(numbers)\n    return (numbers .- minimum) ./ (maximum - minimum)\n\
    end", "    return (numbers .- minimum(numbers)) ./ (maximum(numbers) - minimum(numbers))\n\
    end", "    numbers_max = maximum(numbers)\n    numbers_min = minimum(numbers)\n\
    \    return map( (n) -> (n - numbers_min) / (numbers_max - numbers_min), numbers)\n\
    end", "    min, max = minimum(numbers), maximum(numbers)\n    # ( x - min ) /\
    \ ( max - min )\n    return (numbers .- min) ./ (max - min)\nend", "    min_value\
    \ = minimum(numbers)\n    max_value = maximum(numbers)\n    return [(number -\
    \ min_value) / (max_value - min_value) for number in numbers]\nend", "    return\
    \ (numbers .- minimum(numbers)) ./ (maximum(numbers) - minimum(numbers))\nend",
  "    sorted_numbers = sort(numbers)\n    max_number = sorted_numbers[end]\n    min_number\
    \ = sorted_numbers[1]\n    difference = max_number - min_number\n    return [(number\
    \ - min_number) / difference for number in numbers]\nend"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
