name: HumanEval_68_pluck
language: jl
results:
- program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    min_val = Int64(typemax(Int64))\n\
    \    min_pos = 0\n    for i = 1:length(arr)\n        if iseven(arr[i]) && arr[i]\
    \ < min_val\n            min_val = arr[i]\n            min_pos = i\n        end\n\
    \    end\n    if min_val == typemax(Int64)\n        return []\n    end\n    return\
    \ [min_val, min_pos]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpk46a29x9.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpk46a29x9.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpk46a29x9.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpk46a29x9.jl:57\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpk46a29x9.jl:57 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpk46a29x9.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpk46a29x9.jl:59\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpk46a29x9.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpk46a29x9.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpk46a29x9.jl:60\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpk46a29x9.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpk46a29x9.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpk46a29x9.jl:61\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpk46a29x9.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return Int64[]\n    end\n    idx_min_even\
    \ = 0\n    min_even = 0\n    i = 1\n    for x in arr\n        if x % 2 == 0 &&\
    \ (min_even == 0 || x < min_even)\n            min_even = x\n            idx_min_even\
    \ = i\n        end\n        i += 1\n    end\n    if min_even != 0\n        return\
    \ [min_even, idx_min_even]\n    else\n        return Int64[]\n    end\nend\npluck([4,\
    \ 2, 3])\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpczsjt4c9.jl:60\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpczsjt4c9.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpczsjt4c9.jl:59\ntest set: Test\
    \ Failed at /tmp/tmpczsjt4c9.jl:61\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpczsjt4c9.jl:61 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpczsjt4c9.jl:59\ntest set: Test\
    \ Failed at /tmp/tmpczsjt4c9.jl:63\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [2, 6] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpczsjt4c9.jl:63 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpczsjt4c9.jl:59\ntest set: Test\
    \ Failed at /tmp/tmpczsjt4c9.jl:64\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: Int64[] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpczsjt4c9.jl:64 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpczsjt4c9.jl:59\ntest set: Test\
    \ Failed at /tmp/tmpczsjt4c9.jl:65\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/c"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpczsjt4c9.jl:57\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if arr == Vector{Int64}()\n        return []\n    end\n    evens = []\n\
    \    for i = 1:length(arr)\n        if iseven(arr[i])\n            push!(evens,\
    \ [arr[i], i])\n        end\n    end\n    if evens == []\n        return []\n\
    \    end\n    evens = sort(evens, by = x -> x[1])\n    return evens[1]\nend\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpax9z5b51.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpax9z5b51.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpax9z5b51.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpax9z5b51.jl:56\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpax9z5b51.jl:56 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpax9z5b51.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpax9z5b51.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpax9z5b51.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpax9z5b51.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpax9z5b51.jl:59\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpax9z5b51.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpax9z5b51.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpax9z5b51.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpax9z5b51.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    result = Vector{Int64}()\n    for (index, item) in enumerate(arr)\n  \
    \      if item % 2 == 0\n            if isempty(result) || item < result[1]\n\
    \                result = [item, index]\n            end\n        end\n    end\n\
    \    return result\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpybfn9dpr.jl:50\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpybfn9dpr.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpybfn9dpr.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpybfn9dpr.jl:51\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpybfn9dpr.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpybfn9dpr.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpybfn9dpr.jl:53\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpybfn9dpr.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpybfn9dpr.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpybfn9dpr.jl:54\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpybfn9dpr.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpybfn9dpr.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpybfn9dpr.jl:55\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpybfn9dpr.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    #Remove all odd numbers\n    arr = arr[arr % 2 .== 0]\n    #If none are\
    \ even, return []\n    if isempty(arr)\n        return []\n    end\n    #Otherwise,\
    \ index the first even number and return\n    return [arr[1], findfirst(arr, arr[1])[1]]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp7hfa5zyz.jl:49\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ rem(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    rem(::Any, ::Any,\
    \ !Matched::RoundingMode{:ToZero}) at /shared/centos7/julia/1.7.3/share/julia/base/div.jl:80\n\
    \    rem(::Any, ::Any, !Matched::RoundingMode{:Down}) at /shared/centos7/julia/1.7.3/share/julia/base/div.jl:81\n\
    \    rem(::Any, ::Any, !Matched::RoundingMode{:Up}) at /shared/centos7/julia/1.7.3/share/julia/base/div.jl:82\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp7hfa5zyz.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp7hfa5zyz.jl:49 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp7hfa5zyz.jl:48\ntest set:\
    \ Error During Test at /tmp/tmp7hfa5zyz.jl:50\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching rem(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    rem(::Any, ::Any, !Matched::RoundingMode{:ToZero})\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/div.jl:80\n    rem(::Any, ::Any,\
    \ !Matched::RoundingMode{:Down}) at /shared/centos7/julia/1.7.3/share/julia/base/div.jl:81\n\
    \    rem(::Any, ::Any, !Matched::RoundingMode{:Up}) at /shared/centos7/julia/1.7.3/share/julia/base/div.jl:82\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp7hfa5zyz.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp7hfa5zyz.jl:50 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp7hfa5zyz.jl:48\ntest set:\
    \ Error During Test at /tmp/tmp7hfa5zyz.jl:51\n  Test threw exception\n  Expression:\
    \ c"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7hfa5zyz.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n  evens = [ x for x in arr if iseven(x) ]\n  if length(evens) == 0\n    return\
    \ []\n  end\n  min_even = minimum(evens)\n  for i in 1:length(arr)\n    if arr[i]\
    \ == min_even\n      return [min_even, i]\n    end\n  end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpc2ft4p_d.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpc2ft4p_d.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpc2ft4p_d.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpc2ft4p_d.jl:52\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpc2ft4p_d.jl:52 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpc2ft4p_d.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpc2ft4p_d.jl:54\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpc2ft4p_d.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpc2ft4p_d.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpc2ft4p_d.jl:55\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpc2ft4p_d.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpc2ft4p_d.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpc2ft4p_d.jl:56\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpc2ft4p_d.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) > 0\n        first_even_index = findfirst(x -> x % 2 ==\
    \ 0, arr)\n        if !isnothing(first_even_index)\n            minimum_even_value\
    \ = minimum(arr[first_even_index:end])\n            minimum_even_index = findall(arr\
    \ .== minimum_even_value)[1]\n            return [minimum_even_value, minimum_even_index]\n\
    \        end\n    end\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpouk7zsx4.jl:50\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpouk7zsx4.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpouk7zsx4.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpouk7zsx4.jl:51\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpouk7zsx4.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpouk7zsx4.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpouk7zsx4.jl:53\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpouk7zsx4.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpouk7zsx4.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpouk7zsx4.jl:54\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpouk7zsx4.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpouk7zsx4.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpouk7zsx4.jl:55\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpouk7zsx4.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    min_index = 0\n    min_value = 0\n    for index in 1:length(arr)\n   \
    \     if (arr[index] % 2 == 0) && (arr[index] != 0) && (arr[index] < min_value)\n\
    \            min_value = arr[index]\n            min_index = index\n        end\n\
    \    end\n    return [min_value, min_index]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpulbsnqdj.jl:50\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [0, 0] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpulbsnqdj.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpulbsnqdj.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpulbsnqdj.jl:51\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [0, 0] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpulbsnqdj.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpulbsnqdj.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpulbsnqdj.jl:52\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [0, 0] == Int64[]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpulbsnqdj.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpulbsnqdj.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpulbsnqdj.jl:53\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 0] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpulbsnqdj.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpulbsnqdj.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpulbsnqdj.jl:54\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 0] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \ "
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 8 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpulbsnqdj.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    index_vector = Vector{Int64}()\n    for (index, value) in enumerate(arr)\n\
    \        if value % 2 == 0\n            push!(index_vector, index)\n        end\n\
    \    end\n    if isempty(index_vector)\n        return Vector{Int64}()\n    end\n\
    \    return arr[index_vector[1]]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpqavx0jrx.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpqavx0jrx.jl:44\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpqavx0jrx.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpqavx0jrx.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpqavx0jrx.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n \
    \   convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpqavx0jrx.jl:44\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpqavx0jrx.jl:52 [inlined]\n\
    \   [4] macro "
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqavx0jrx.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # We iterate through all values in the array\n    # and save even values\
    \ and their indexes\n    # The even value with the smallest index\n    # will\
    \ be our solution\n    min_idx = -1\n    min_val = 0\n    for (i, node) in enumerate(arr)\n\
    \        if node % 2 == 0 && (min_idx == -1 || node < min_val)\n            min_idx\
    \ = i\n            min_val = node\n        end\n    end\n    if min_idx == -1\
    \ \n        return []\n    else\n        return [min_val, min_idx]\n    end\n\
    end\n```\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid \"`\" syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpyycfdlms.jl:53\nin expression starting at\
    \ /tmp/tmpyycfdlms.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = findall(a -> iseven(a), arr)\n    n = length(evens)\n    if n\
    \ == 0\n        return []\n    end\n    first_even = arr[evens[1]]\n    index\
    \ = evens[1]\n    for i in 2:n\n        if arr[evens[i]] < first_even\n      \
    \      first_even = arr[evens[i]]\n            index = evens[i]\n        end\n\
    \    end\n    return [first_even, index]\nend\n    \nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp86snrrj7.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp86snrrj7.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp86snrrj7.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp86snrrj7.jl:57\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp86snrrj7.jl:57 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp86snrrj7.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp86snrrj7.jl:59\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp86snrrj7.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp86snrrj7.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp86snrrj7.jl:60\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp86snrrj7.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp86snrrj7.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp86snrrj7.jl:61\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp86snrrj7.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # if arr is empty, return empty vector\n    # else, continue\n    if isempty(arr)\n\
    \        return []\n    end\n    \n    # initialize a few values\n    # index\
    \ of lowest even value\n    min_idx = -1\n    # lowest even value\n    min_val\
    \ = 2147483647 # biggest possible int\n    \n    # for each item in array\n  \
    \  for i in 1:length(arr)\n        # if item is even and less than the minimum\
    \ even value\n        if rem(arr[i], 2) == 0 && arr[i] < min_val\n           \
    \ # set the new minimum even value and the index at which it can be found\n  \
    \          min_val = arr[i]\n            min_idx = i\n        end\n    end\n \
    \   \n    # if there was no even value, return empty vector\n    # else, return\
    \ the minimum even value and its index\n    if min_idx == -1\n        return []\n\
    \    else\n        return [min_val, min_idx]\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp6mjz6v72.jl:70\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6mjz6v72.jl:70 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6mjz6v72.jl:69\ntest set: Test\
    \ Failed at /tmp/tmp6mjz6v72.jl:71\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp6mjz6v72.jl:71 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6mjz6v72.jl:69\ntest set: Test\
    \ Failed at /tmp/tmp6mjz6v72.jl:73\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6mjz6v72.jl:73 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6mjz6v72.jl:69\ntest set: Test\
    \ Failed at /tmp/tmp6mjz6v72.jl:74\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6mjz6v72.jl:74 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6mjz6v72.jl:69\ntest set: Test\
    \ Failed at /tmp/tmp6mjz6v72.jl:75\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6mjz6v72.jl:67\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = arr[isodd.(arr)]\n    if length(evens) == 0\n        return []\n\
    \    else\n        idx = findfirst(arr .== minimum(evens))\n        return [arr[idx],\
    \ idx]\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpqie7y8x2.jl:48\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [3, 3] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqie7y8x2.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqie7y8x2.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpqie7y8x2.jl:49\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [1, 1] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqie7y8x2.jl:49 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqie7y8x2.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpqie7y8x2.jl:51\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [3, 3] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqie7y8x2.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqie7y8x2.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpqie7y8x2.jl:52\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [1, 1] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqie7y8x2.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqie7y8x2.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpqie7y8x2.jl:53\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [5, 1] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 7 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqie7y8x2.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # check for empty array\n    if length(arr) == 0\n        return []\n\
    \    end\n    \n    # convert to Array for indexing\n    arr_idx = Array(arr)\n\
    \    \n    # check if there are even numbers\n    even_nums = isempty(findall(!isodd,\
    \ arr))\n    \n    # return empty list if no even numbers\n    if even_nums ==\
    \ true\n        return []\n    end\n    \n    # get the minimum even number and\
    \ its index\n    min_even = findall(==minimum(arr[findall(!isodd, arr)]), arr_idx)\n\
    \    \n    # return minimum even value and its index\n    return [arr[min_even[1]],\
    \ min_even[1]]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"==\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcoxu6ylb.jl:52\nin expression starting at\
    \ /tmp/tmpcoxu6ylb.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # julia doesn't have a min function, \n    # so I'm creating a lambda\
    \ that returns the minimum of an array\n    get_min = (arr) -> (reduce(min, arr))\n\
    \    # create a new array to store only the even values\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    # return an empty array if there are no even values\n\
    \    if length(evens) == 0\n        return []\n    end\n    # return the minimum\
    \ even value and its index\n    return [get_min(evens), findfirst(x -> x == get_min(evens),\
    \ arr)]\nend\nprintln(pluck([4, 2, 3]))\nprintln(pluck([1, 2, 3]))\nprintln(pluck([]))\n\
    println(pluck([5, 0, 3, 0, 4, 2]))\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "[2, 2]\n[2, 2]\n"
  stderr: "ERROR: LoadError: MethodError: no method matching pluck(::Vector{Any})\n\
    Closest candidates are:\n  pluck(!Matched::Vector{Int64}) at /tmp/tmpin27kczv.jl:34\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpin27kczv.jl:49\nin expression\
    \ starting at /tmp/tmpin27kczv.jl:49\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if arr == []\n        return []\n    end\n    evens = []\n    for i in\
    \ 1:length(arr)\n        if rem(arr[i], 2) == 0\n            push!(evens, arr[i])\n\
    \        end\n    end\n    if evens == []\n        return []\n    end\n    min_index\
    \ = indmin(evens)\n    val = evens[min_index]\n    return [val, indmin(findall(arr.==val))]\n\
    end\n\"\"\"\n    \"Given a vector of integers find the n-th smallest integer in\
    \ the vector.\n    Your method should not modify the vector.\n    The input vector\
    \ will be of size at least 1 and at most 10000,\n    and the n-th smallest integer\
    \ will be of size at least 1 and at most 10000.\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpsnh66wo4.jl:51\nin expression starting at\
    \ /tmp/tmpsnh66wo4.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # find even numbers\n    evens = [v for v in arr if v % 2 == 0]\n    #\
    \ find min of even numbers\n    min_even = minimum(evens)\n    # find index of\
    \ min_even\n    idx = findall(i -> i == min_even, arr)[1]\n    return [min_even,\
    \ idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_vnodx8t.jl:48\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_vnodx8t.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_vnodx8t.jl:47\ntest set: Test\
    \ Failed at /tmp/tmp_vnodx8t.jl:49\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp_vnodx8t.jl:49 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_vnodx8t.jl:47\ntest set: Error\
    \ During Test at /tmp/tmp_vnodx8t.jl:50\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  ArgumentError: reducing\
    \ over an empty collection is not allowed\n  Stacktrace:\n    [1] _empty_reduce_error()\n\
    \      @ Base ./reduce.jl:301\n    [2] reduce_empty(op::Function, #unused#::Type{Int64})\n\
    \      @ Base ./reduce.jl:311\n    [3] mapreduce_empty(#unused#::typeof(identity),\
    \ op::Function, T::Type)\n      @ Base ./reduce.jl:345\n    [4] reduce_empty(op::Base.MappingRF{typeof(identity),\
    \ typeof(min)}, #unused#::Type{Int64})\n      @ Base ./reduce.jl:331\n    [5]\
    \ reduce_empty_iter\n      @ ./reduce.jl:357 [inlined]\n    [6] mapreduce_empty_iter(f::Function,\
    \ op::Function, itr::Vector{Int64}, ItrEltype::Base.HasEltype)\n      @ Base ./reduce.jl:353\n\
    \    [7] _mapreduce\n      @ ./reduce.jl:402 [inlined]\n    [8] _mapreduce_dim\n\
    \      @ ./reducedim.jl:330 [inlined]\n    [9] #mapreduce#731\n      @ ./reducedim.jl:322\
    \ [inlined]\n   [10] mapreduce\n      @ ./reducedim.jl:322 [inlined]\n   [11]\
    \ #_minimum#753\n      @ ./reducedim.jl:894 [inlined]\n   [12] _minimum\n    \
    \  @ ./reducedim.jl:894 [inl"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 2 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_vnodx8t.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # Your code goes here!\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpi3ufqvly.jl:42\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpi3ufqvly.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpi3ufqvly.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpi3ufqvly.jl:41\ntest set:\
    \ Error During Test at /tmp/tmpi3ufqvly.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpi3ufqvly.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpi3ufqvly.jl:43 [inlined]\n\
    \   [4] ma"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpi3ufqvly.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    min_even_val = Inf\n    min_even_idx = -1\n    for (idx, n) in enumerate(arr)\n\
    \        if n % 2 == 0 && n < min_even_val\n            min_even_val = n\n   \
    \         min_even_idx = idx\n        end\n    end\n    if min_even_idx == -1\n\
    \        return []\n    else\n        return [min_even_val, min_even_idx]\n  \
    \  end\nend\n\"\"\"\n    \"Given an array of integers arr, write a function that\
    \ returns true if and only if the number of occurrences of each value in the array\
    \ is unique.\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4ch156nf.jl:49\nin expression starting at\
    \ /tmp/tmp4ch156nf.jl:49\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # special case: empty array\n    if length(arr) == 0\n        return []\n\
    \    end\n    \n    # First pass, find the smallest even element\n    minValue::Int64\
    \ = typemax(Int64)\n    minIndex::Int64 = 0\n    for i in 1:length(arr)\n    \
    \    if mod(arr[i], 2) == 0 && arr[i] < minValue\n            minValue = arr[i]\n\
    \            minIndex = i\n        end\n    end\n    \n    # Second pass, find\
    \ the first smallest even element\n    minIndex::Int64 = 0\n    for i in 1:length(arr)\n\
    \        if mod(arr[i], 2) == 0 && arr[i] == minValue\n            minIndex =\
    \ i\n            break\n        end\n    end\n    \n    return [minValue, minIndex]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: multiple type declarations for \"minIndex\"\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpby2s1kel.jl:1\nin expression starting\
    \ at /tmp/tmpby2s1kel.jl:1\n"
  exit_code: 1
  status: SyntaxError
