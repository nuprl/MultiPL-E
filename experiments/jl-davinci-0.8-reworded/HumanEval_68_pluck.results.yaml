language: jl
name: HumanEval_68_pluck
results:
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    min_val = Int64(typemax(Int64))\n\
    \    min_pos = 0\n    for i = 1:length(arr)\n        if iseven(arr[i]) && arr[i]\
    \ < min_val\n            min_val = arr[i]\n            min_pos = i\n        end\n\
    \    end\n    if min_val == typemax(Int64)\n        return []\n    end\n    return\
    \ [min_val, min_pos]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpk46a29x9.jl:53

    '
  stdout: "test set: Test Failed at /tmp/tmpk46a29x9.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpk46a29x9.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpk46a29x9.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpk46a29x9.jl:57\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpk46a29x9.jl:57 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpk46a29x9.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpk46a29x9.jl:59\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpk46a29x9.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpk46a29x9.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpk46a29x9.jl:60\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpk46a29x9.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpk46a29x9.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpk46a29x9.jl:61\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return Int64[]\n    end\n    idx_min_even\
    \ = 0\n    min_even = 0\n    i = 1\n    for x in arr\n        if x % 2 == 0 &&\
    \ (min_even == 0 || x < min_even)\n            min_even = x\n            idx_min_even\
    \ = i\n        end\n        i += 1\n    end\n    if min_even != 0\n        return\
    \ [min_even, idx_min_even]\n    else\n        return Int64[]\n    end\nend\npluck([4,\
    \ 2, 3])\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpczsjt4c9.jl:57

    '
  stdout: "test set: Test Failed at /tmp/tmpczsjt4c9.jl:60\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpczsjt4c9.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpczsjt4c9.jl:59\ntest set: Test\
    \ Failed at /tmp/tmpczsjt4c9.jl:61\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpczsjt4c9.jl:61 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpczsjt4c9.jl:59\ntest set: Test\
    \ Failed at /tmp/tmpczsjt4c9.jl:63\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [2, 6] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpczsjt4c9.jl:63 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpczsjt4c9.jl:59\ntest set: Test\
    \ Failed at /tmp/tmpczsjt4c9.jl:64\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: Int64[] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpczsjt4c9.jl:64 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpczsjt4c9.jl:59\ntest set: Test\
    \ Failed at /tmp/tmpczsjt4c9.jl:65\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/c"
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if arr == Vector{Int64}()\n        return []\n    end\n    evens = []\n\
    \    for i = 1:length(arr)\n        if iseven(arr[i])\n            push!(evens,\
    \ [arr[i], i])\n        end\n    end\n    if evens == []\n        return []\n\
    \    end\n    evens = sort(evens, by = x -> x[1])\n    return evens[1]\nend\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpax9z5b51.jl:52

    '
  stdout: "test set: Test Failed at /tmp/tmpax9z5b51.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpax9z5b51.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpax9z5b51.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpax9z5b51.jl:56\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpax9z5b51.jl:56 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpax9z5b51.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpax9z5b51.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpax9z5b51.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpax9z5b51.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpax9z5b51.jl:59\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpax9z5b51.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpax9z5b51.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpax9z5b51.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    result = Vector{Int64}()\n    for (index, item) in enumerate(arr)\n  \
    \      if item % 2 == 0\n            if isempty(result) || item < result[1]\n\
    \                result = [item, index]\n            end\n        end\n    end\n\
    \    return result\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpybfn9dpr.jl:47

    '
  stdout: "test set: Test Failed at /tmp/tmpybfn9dpr.jl:50\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpybfn9dpr.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpybfn9dpr.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpybfn9dpr.jl:51\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpybfn9dpr.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpybfn9dpr.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpybfn9dpr.jl:53\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpybfn9dpr.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpybfn9dpr.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpybfn9dpr.jl:54\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpybfn9dpr.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpybfn9dpr.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpybfn9dpr.jl:55\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    #Remove all odd numbers\n    arr = arr[arr % 2 .== 0]\n    #If none are\
    \ even, return []\n    if isempty(arr)\n        return []\n    end\n    #Otherwise,\
    \ index the first even number and return\n    return [arr[1], findfirst(arr, arr[1])[1]]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmp7hfa5zyz.jl:46

    '
  stdout: "test set: Error During Test at /tmp/tmp7hfa5zyz.jl:49\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ rem(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    rem(::Any, ::Any,\
    \ !Matched::RoundingMode{:ToZero}) at /shared/centos7/julia/1.7.3/share/julia/base/div.jl:80\n\
    \    rem(::Any, ::Any, !Matched::RoundingMode{:Down}) at /shared/centos7/julia/1.7.3/share/julia/base/div.jl:81\n\
    \    rem(::Any, ::Any, !Matched::RoundingMode{:Up}) at /shared/centos7/julia/1.7.3/share/julia/base/div.jl:82\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp7hfa5zyz.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp7hfa5zyz.jl:49 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp7hfa5zyz.jl:48\ntest set:\
    \ Error During Test at /tmp/tmp7hfa5zyz.jl:50\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching rem(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    rem(::Any, ::Any, !Matched::RoundingMode{:ToZero})\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/div.jl:80\n    rem(::Any, ::Any,\
    \ !Matched::RoundingMode{:Down}) at /shared/centos7/julia/1.7.3/share/julia/base/div.jl:81\n\
    \    rem(::Any, ::Any, !Matched::RoundingMode{:Up}) at /shared/centos7/julia/1.7.3/share/julia/base/div.jl:82\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp7hfa5zyz.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp7hfa5zyz.jl:50 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp7hfa5zyz.jl:48\ntest set:\
    \ Error During Test at /tmp/tmp7hfa5zyz.jl:51\n  Test threw exception\n  Expression:\
    \ c"
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n  evens = [ x for x in arr if iseven(x) ]\n  if length(evens) == 0\n    return\
    \ []\n  end\n  min_even = minimum(evens)\n  for i in 1:length(arr)\n    if arr[i]\
    \ == min_even\n      return [min_even, i]\n    end\n  end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpc2ft4p_d.jl:48

    '
  stdout: "test set: Test Failed at /tmp/tmpc2ft4p_d.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpc2ft4p_d.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpc2ft4p_d.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpc2ft4p_d.jl:52\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpc2ft4p_d.jl:52 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpc2ft4p_d.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpc2ft4p_d.jl:54\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpc2ft4p_d.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpc2ft4p_d.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpc2ft4p_d.jl:55\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpc2ft4p_d.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpc2ft4p_d.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpc2ft4p_d.jl:56\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) > 0\n        first_even_index = findfirst(x -> x % 2 ==\
    \ 0, arr)\n        if !isnothing(first_even_index)\n            minimum_even_value\
    \ = minimum(arr[first_even_index:end])\n            minimum_even_index = findall(arr\
    \ .== minimum_even_value)[1]\n            return [minimum_even_value, minimum_even_index]\n\
    \        end\n    end\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpouk7zsx4.jl:47

    '
  stdout: "test set: Test Failed at /tmp/tmpouk7zsx4.jl:50\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpouk7zsx4.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpouk7zsx4.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpouk7zsx4.jl:51\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpouk7zsx4.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpouk7zsx4.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpouk7zsx4.jl:53\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpouk7zsx4.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpouk7zsx4.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpouk7zsx4.jl:54\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpouk7zsx4.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpouk7zsx4.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpouk7zsx4.jl:55\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    min_index = 0\n    min_value = 0\n    for index in 1:length(arr)\n   \
    \     if (arr[index] % 2 == 0) && (arr[index] != 0) && (arr[index] < min_value)\n\
    \            min_value = arr[index]\n            min_index = index\n        end\n\
    \    end\n    return [min_value, min_index]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 8 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpulbsnqdj.jl:47

    '
  stdout: "test set: Test Failed at /tmp/tmpulbsnqdj.jl:50\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [0, 0] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpulbsnqdj.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpulbsnqdj.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpulbsnqdj.jl:51\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [0, 0] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpulbsnqdj.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpulbsnqdj.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpulbsnqdj.jl:52\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [0, 0] == Int64[]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpulbsnqdj.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpulbsnqdj.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpulbsnqdj.jl:53\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 0] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpulbsnqdj.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpulbsnqdj.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpulbsnqdj.jl:54\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 0] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \ "
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    index_vector = Vector{Int64}()\n    for (index, value) in enumerate(arr)\n\
    \        if value % 2 == 0\n            push!(index_vector, index)\n        end\n\
    \    end\n    if isempty(index_vector)\n        return Vector{Int64}()\n    end\n\
    \    return arr[index_vector[1]]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpqavx0jrx.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpqavx0jrx.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpqavx0jrx.jl:44\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpqavx0jrx.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpqavx0jrx.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpqavx0jrx.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n \
    \   convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpqavx0jrx.jl:44\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpqavx0jrx.jl:52 [inlined]\n\
    \   [4] macro "
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # We iterate through all values in the array\n    # and save even values\
    \ and their indexes\n    # The even value with the smallest index\n    # will\
    \ be our solution\n    min_idx = -1\n    min_val = 0\n    for (i, node) in enumerate(arr)\n\
    \        if node % 2 == 0 && (min_idx == -1 || node < min_val)\n            min_idx\
    \ = i\n            min_val = node\n        end\n    end\n    if min_idx == -1\
    \ \n        return []\n    else\n        return [min_val, min_idx]\n    end\n\
    end\n```\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: invalid \"`\" syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpyycfdlms.jl:53\nin expression starting at\
    \ /tmp/tmpyycfdlms.jl:53\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = findall(a -> iseven(a), arr)\n    n = length(evens)\n    if n\
    \ == 0\n        return []\n    end\n    first_even = arr[evens[1]]\n    index\
    \ = evens[1]\n    for i in 2:n\n        if arr[evens[i]] < first_even\n      \
    \      first_even = arr[evens[i]]\n            index = evens[i]\n        end\n\
    \    end\n    return [first_even, index]\nend\n    \nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp86snrrj7.jl:53

    '
  stdout: "test set: Test Failed at /tmp/tmp86snrrj7.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp86snrrj7.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp86snrrj7.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp86snrrj7.jl:57\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp86snrrj7.jl:57 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp86snrrj7.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp86snrrj7.jl:59\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp86snrrj7.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp86snrrj7.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp86snrrj7.jl:60\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp86snrrj7.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp86snrrj7.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp86snrrj7.jl:61\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # if arr is empty, return empty vector\n    # else, continue\n    if isempty(arr)\n\
    \        return []\n    end\n    \n    # initialize a few values\n    # index\
    \ of lowest even value\n    min_idx = -1\n    # lowest even value\n    min_val\
    \ = 2147483647 # biggest possible int\n    \n    # for each item in array\n  \
    \  for i in 1:length(arr)\n        # if item is even and less than the minimum\
    \ even value\n        if rem(arr[i], 2) == 0 && arr[i] < min_val\n           \
    \ # set the new minimum even value and the index at which it can be found\n  \
    \          min_val = arr[i]\n            min_idx = i\n        end\n    end\n \
    \   \n    # if there was no even value, return empty vector\n    # else, return\
    \ the minimum even value and its index\n    if min_idx == -1\n        return []\n\
    \    else\n        return [min_val, min_idx]\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp6mjz6v72.jl:67

    '
  stdout: "test set: Test Failed at /tmp/tmp6mjz6v72.jl:70\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6mjz6v72.jl:70 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6mjz6v72.jl:69\ntest set: Test\
    \ Failed at /tmp/tmp6mjz6v72.jl:71\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp6mjz6v72.jl:71 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6mjz6v72.jl:69\ntest set: Test\
    \ Failed at /tmp/tmp6mjz6v72.jl:73\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6mjz6v72.jl:73 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6mjz6v72.jl:69\ntest set: Test\
    \ Failed at /tmp/tmp6mjz6v72.jl:74\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6mjz6v72.jl:74 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6mjz6v72.jl:69\ntest set: Test\
    \ Failed at /tmp/tmp6mjz6v72.jl:75\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = arr[isodd.(arr)]\n    if length(evens) == 0\n        return []\n\
    \    else\n        idx = findfirst(arr .== minimum(evens))\n        return [arr[idx],\
    \ idx]\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 7 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqie7y8x2.jl:45

    '
  stdout: "test set: Test Failed at /tmp/tmpqie7y8x2.jl:48\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [3, 3] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqie7y8x2.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqie7y8x2.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpqie7y8x2.jl:49\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [1, 1] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqie7y8x2.jl:49 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqie7y8x2.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpqie7y8x2.jl:51\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [3, 3] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqie7y8x2.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqie7y8x2.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpqie7y8x2.jl:52\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [1, 1] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqie7y8x2.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqie7y8x2.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpqie7y8x2.jl:53\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [5, 1] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # check for empty array\n    if length(arr) == 0\n        return []\n\
    \    end\n    \n    # convert to Array for indexing\n    arr_idx = Array(arr)\n\
    \    \n    # check if there are even numbers\n    even_nums = isempty(findall(!isodd,\
    \ arr))\n    \n    # return empty list if no even numbers\n    if even_nums ==\
    \ true\n        return []\n    end\n    \n    # get the minimum even number and\
    \ its index\n    min_even = findall(==minimum(arr[findall(!isodd, arr)]), arr_idx)\n\
    \    \n    # return minimum even value and its index\n    return [arr[min_even[1]],\
    \ min_even[1]]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"==\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcoxu6ylb.jl:52\nin expression starting at\
    \ /tmp/tmpcoxu6ylb.jl:52\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # julia doesn't have a min function, \n    # so I'm creating a lambda\
    \ that returns the minimum of an array\n    get_min = (arr) -> (reduce(min, arr))\n\
    \    # create a new array to store only the even values\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    # return an empty array if there are no even values\n\
    \    if length(evens) == 0\n        return []\n    end\n    # return the minimum\
    \ even value and its index\n    return [get_min(evens), findfirst(x -> x == get_min(evens),\
    \ arr)]\nend\nprintln(pluck([4, 2, 3]))\nprintln(pluck([1, 2, 3]))\nprintln(pluck([]))\n\
    println(pluck([5, 0, 3, 0, 4, 2]))\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: MethodError: no method matching pluck(::Vector{Any})\n\
    Closest candidates are:\n  pluck(!Matched::Vector{Int64}) at /tmp/tmpin27kczv.jl:34\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpin27kczv.jl:49\nin expression\
    \ starting at /tmp/tmpin27kczv.jl:49\n"
  stdout: '[2, 2]

    [2, 2]

    '
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if arr == []\n        return []\n    end\n    evens = []\n    for i in\
    \ 1:length(arr)\n        if rem(arr[i], 2) == 0\n            push!(evens, arr[i])\n\
    \        end\n    end\n    if evens == []\n        return []\n    end\n    min_index\
    \ = indmin(evens)\n    val = evens[min_index]\n    return [val, indmin(findall(arr.==val))]\n\
    end\n\"\"\"\n    \"Given a vector of integers find the n-th smallest integer in\
    \ the vector.\n    Your method should not modify the vector.\n    The input vector\
    \ will be of size at least 1 and at most 10000,\n    and the n-th smallest integer\
    \ will be of size at least 1 and at most 10000.\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpsnh66wo4.jl:51\nin expression starting at\
    \ /tmp/tmpsnh66wo4.jl:51\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # find even numbers\n    evens = [v for v in arr if v % 2 == 0]\n    #\
    \ find min of even numbers\n    min_even = minimum(evens)\n    # find index of\
    \ min_even\n    idx = findall(i -> i == min_even, arr)[1]\n    return [min_even,\
    \ idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 2 errored,
    0 broken.

    in expression starting at /tmp/tmp_vnodx8t.jl:45

    '
  stdout: "test set: Test Failed at /tmp/tmp_vnodx8t.jl:48\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_vnodx8t.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_vnodx8t.jl:47\ntest set: Test\
    \ Failed at /tmp/tmp_vnodx8t.jl:49\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp_vnodx8t.jl:49 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_vnodx8t.jl:47\ntest set: Error\
    \ During Test at /tmp/tmp_vnodx8t.jl:50\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  ArgumentError: reducing\
    \ over an empty collection is not allowed\n  Stacktrace:\n    [1] _empty_reduce_error()\n\
    \      @ Base ./reduce.jl:301\n    [2] reduce_empty(op::Function, #unused#::Type{Int64})\n\
    \      @ Base ./reduce.jl:311\n    [3] mapreduce_empty(#unused#::typeof(identity),\
    \ op::Function, T::Type)\n      @ Base ./reduce.jl:345\n    [4] reduce_empty(op::Base.MappingRF{typeof(identity),\
    \ typeof(min)}, #unused#::Type{Int64})\n      @ Base ./reduce.jl:331\n    [5]\
    \ reduce_empty_iter\n      @ ./reduce.jl:357 [inlined]\n    [6] mapreduce_empty_iter(f::Function,\
    \ op::Function, itr::Vector{Int64}, ItrEltype::Base.HasEltype)\n      @ Base ./reduce.jl:353\n\
    \    [7] _mapreduce\n      @ ./reduce.jl:402 [inlined]\n    [8] _mapreduce_dim\n\
    \      @ ./reducedim.jl:330 [inlined]\n    [9] #mapreduce#731\n      @ ./reducedim.jl:322\
    \ [inlined]\n   [10] mapreduce\n      @ ./reducedim.jl:322 [inlined]\n   [11]\
    \ #_minimum#753\n      @ ./reducedim.jl:894 [inlined]\n   [12] _minimum\n    \
    \  @ ./reducedim.jl:894 [inl"
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # Your code goes here!\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpi3ufqvly.jl:39

    '
  stdout: "test set: Error During Test at /tmp/tmpi3ufqvly.jl:42\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpi3ufqvly.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpi3ufqvly.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpi3ufqvly.jl:41\ntest set:\
    \ Error During Test at /tmp/tmpi3ufqvly.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpi3ufqvly.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpi3ufqvly.jl:43 [inlined]\n\
    \   [4] ma"
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    min_even_val = Inf\n    min_even_idx = -1\n    for (idx, n) in enumerate(arr)\n\
    \        if n % 2 == 0 && n < min_even_val\n            min_even_val = n\n   \
    \         min_even_idx = idx\n        end\n    end\n    if min_even_idx == -1\n\
    \        return []\n    else\n        return [min_even_val, min_even_idx]\n  \
    \  end\nend\n\"\"\"\n    \"Given an array of integers arr, write a function that\
    \ returns true if and only if the number of occurrences of each value in the array\
    \ is unique.\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4ch156nf.jl:49\nin expression starting at\
    \ /tmp/tmp4ch156nf.jl:49\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # special case: empty array\n    if length(arr) == 0\n        return []\n\
    \    end\n    \n    # First pass, find the smallest even element\n    minValue::Int64\
    \ = typemax(Int64)\n    minIndex::Int64 = 0\n    for i in 1:length(arr)\n    \
    \    if mod(arr[i], 2) == 0 && arr[i] < minValue\n            minValue = arr[i]\n\
    \            minIndex = i\n        end\n    end\n    \n    # Second pass, find\
    \ the first smallest even element\n    minIndex::Int64 = 0\n    for i in 1:length(arr)\n\
    \        if mod(arr[i], 2) == 0 && arr[i] == minValue\n            minIndex =\
    \ i\n            break\n        end\n    end\n    \n    return [minValue, minIndex]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: multiple type declarations for \"minIndex\"\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpby2s1kel.jl:1\nin expression starting\
    \ at /tmp/tmpby2s1kel.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr) || all(x -> x % 2 != 0, arr)\n        return Vector{Int64}()\n\
    \    end\n    min_index = -1\n    min_value = -1\n    for i in 1:length(arr)\n\
    \        if arr[i] % 2 == 0\n            if min_index == -1 || arr[i] < min_value\n\
    \                min_index = i\n                min_value = arr[i]\n         \
    \   end\n        end\n    end\n    return [min_value, min_index]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpy8zat63c.jl:52

    '
  stdout: "test set: Test Failed at /tmp/tmpy8zat63c.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpy8zat63c.jl:55 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpy8zat63c.jl:54\ntest set: Test Failed at /tmp/tmpy8zat63c.jl:56\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpy8zat63c.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpy8zat63c.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpy8zat63c.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpy8zat63c.jl:58 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpy8zat63c.jl:54\ntest set: Test Failed at /tmp/tmpy8zat63c.jl:59\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpy8zat63c.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpy8zat63c.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpy8zat63c.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014679
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # If the array is empty, return []\n    if length(arr) == 0 \n       \
    \ return []\n    # If all of the values are odd, return []\n    if all(arr .%\
    \ 2 .!= 0)\n        return []\n    end\n    # Find the smallest even value, \n\
    \    smallest_even = minimum(arr[arr .% 2 .== 0])\n    # Find the index of the\
    \ smallest even value,\n    smallest_even_index = findall(arr .== smallest_even)[1]\n\
    \    # Return the smallest even value and its index\n    return [smallest_even,\
    \ smallest_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp7k8wuf97.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp7k8wuf97.jl:1\n\
    in expression starting at /tmp/tmp7k8wuf97.jl:1\n"
  stdout: ''
  timestamp: 1660014678
- exit_code: -1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: Timeout
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpy2u_1_vu.jl:39

    '
  stdout: "test set: Error During Test at /tmp/tmpy2u_1_vu.jl:42\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpy2u_1_vu.jl:36\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpy2u_1_vu.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpy2u_1_vu.jl:41\ntest set:\
    \ Error During Test at /tmp/tmpy2u_1_vu.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpy2u_1_vu.jl:36\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpy2u_1_vu.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/s"
  timestamp: 1660014681
- exit_code: -1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    smallest::Int64 = maximum(Int64)\n    index::Int64 = maximum(Int64)\n\
    \    for i in 1:length(arr)\n        if mod(arr[i], 2) == 0\n            if arr[i]\
    \ < smallest\n                smallest = arr[i]\n                index = i\n \
    \           end\n        end\n    end\n    return [smallest, index]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: Timeout
  stderr: 'ERROR: LoadError: '
  stdout: "test set: Error During Test at /tmp/tmp6mktif9l.jl:52\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ iterate(::Type{Int64})\n  Closest candidates are:\n    iterate(!Matched::Union{LinRange,\
    \ StepRangeLen}) at ~/.conda/envs/polyglot/share/julia/base/range.jl:826\n   \
    \ iterate(!Matched::Union{LinRange, StepRangeLen}, !Matched::Integer) at ~/.conda/envs/polyglot/share/julia/base/range.jl:826\n\
    \    iterate(!Matched::T) where T<:Union{Base.KeySet{<:Any, <:Dict}, Base.ValueIterator{<:Dict}}\
    \ at ~/.conda/envs/polyglot/share/julia/base/dict.jl:695\n    ...\n  Stacktrace:\n\
    \    [1] _foldl_impl(op::Base.BottomRF{typeof(max)}, init::Base._InitialValue,\
    \ itr::Type)\n      @ Base ./reduce.jl:56\n    [2] foldl_impl(op::Base.BottomRF{typeof(max)},\
    \ nt::Base._InitialValue, itr::Type)\n      @ Base ./reduce.jl:48\n    [3] mapfoldl_impl(f::typeof(identity),\
    \ op::typeof(max), nt::Base._InitialValue, itr::Type)\n      @ Base ./reduce.jl:44\n\
    \    [4] #mapfoldl#244\n      @ ./reduce.jl:162 [inlined]\n    [5] mapfoldl\n\
    \      @ ./reduce.jl:162 [inlined]\n    [6] #mapreduce#248\n      @ ./reduce.jl:289\
    \ [inlined]\n    [7] mapreduce\n      @ ./reduce.jl:289 [inlined]\n    [8] #maximum#258\n\
    \      @ ./reduce.jl:737 [inlined]\n    [9] maximum(a::Type)\n      @ Base ./reduce.jl:737\n\
    \   [10] pluck(arr::Vector{Int64})\n      @ Main /tmp/tmp6mktif9l.jl:35\n   [11]\
    \ macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [12] macro expansion\n      @ /tmp/tmp6mktif9l.jl:52 [inlined]\n\
    \   [13] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [14] top-level scope\n      @ /tmp/tmp6mktif9l.jl:51\ntest set:\
    \ Error During Test at /tmp/tmp6mktif9l.jl:53\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching iterate(::Type{Int64})\n\
    \  Closest candidates are:\n    iterate(!Matched::Union{LinRange, StepRangeLen})\
    \ at ~/.conda/envs/polyglot/share/julia/base/range.jl:826\n    iterate(!Matched::Union{L"
  timestamp: 1660014681
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr) || all(arr .% 2 .!= 0) return Int64[] end\n    evens =\
    \ arr[arr .% 2 .== 0]\n    if length(evens) == 1 return [evens[1], findfirst(arr,\
    \ evens[1])[1]] end\n    idx = findfirst(evens, minimum(evens))[1]\n    [evens[idx],\
    \ findfirst(arr, evens[idx])[1]]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp07_xlvxd.jl:43

    '
  stdout: "test set: Error During Test at /tmp/tmp07_xlvxd.jl:46\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp07_xlvxd.jl:38\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp07_xlvxd.jl:46 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp07_xlvxd.jl:45\ntest set:\
    \ Error During Test at /tmp/tmp07_xlvxd.jl:47\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp07_xlvxd.jl:37\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp07_xlvxd.jl:47 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp07_xlvxd.jl:45\ntest set:\
    \ Error During Test at /tmp/tmp07_xlvxd.jl:49\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014681
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    min_even = Inf\n    min_index\
    \ = -1\n    for i in 1:length(arr)\n        val = arr[i]\n        if (val % 2\
    \ == 0) && (val < min_even)\n            min_even = val\n            min_index\
    \ = i\n        end\n    end\n    if min_even == Inf\n        return []\n    end\n\
    \    return [min_even, min_index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpp47lshmy.jl:54

    '
  stdout: "test set: Test Failed at /tmp/tmpp47lshmy.jl:57\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpp47lshmy.jl:57 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpp47lshmy.jl:56\ntest set: Test Failed at /tmp/tmpp47lshmy.jl:58\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpp47lshmy.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpp47lshmy.jl:56\ntest set: Test\
    \ Failed at /tmp/tmpp47lshmy.jl:60\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpp47lshmy.jl:60 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpp47lshmy.jl:56\ntest set: Test Failed at /tmp/tmpp47lshmy.jl:61\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpp47lshmy.jl:61 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpp47lshmy.jl:56\ntest set: Test\
    \ Failed at /tmp/tmpp47lshmy.jl:62\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014679
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # this vector stores the [smallest value, index]\n    smallestEven = [0,\
    \ 0]\n    # base case, if the vector is empty we return an empty vector\n    if\
    \ isempty(arr)\n        return []\n    end\n    # iterate through the vector\n\
    \    for i in 1:length(arr)\n        # if the current value is even and it is\
    \ the first even value or it is smaller than the current smallest value\n    \
    \    if (arr[i] % 2 == 0) && (smallestEven[1] == 0 || arr[i] < smallestEven[1])\n\
    \            # update the smallestEven vector\n            smallestEven = [arr[i],\
    \ i]\n        end\n    end\n    # return the smallestEven vector\n    return smallestEven\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 7 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpnj4mns9m.jl:54

    '
  stdout: "test set: Test Failed at /tmp/tmpnj4mns9m.jl:57\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpnj4mns9m.jl:57 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpnj4mns9m.jl:56\ntest set: Test Failed at /tmp/tmpnj4mns9m.jl:58\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnj4mns9m.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnj4mns9m.jl:56\ntest set: Test\
    \ Failed at /tmp/tmpnj4mns9m.jl:60\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [2, 6] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpnj4mns9m.jl:60 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpnj4mns9m.jl:56\ntest set: Test Failed at /tmp/tmpnj4mns9m.jl:61\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnj4mns9m.jl:61 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnj4mns9m.jl:56\ntest set: Test\
    \ Failed at /tmp/tmpnj4mns9m.jl:62\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014678
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) < 1\n        return []\n    end\n    even_nodes = Array{Int64}[]\n\
    \    for node in arr\n        if node % 2 == 0\n            push!(even_nodes,\
    \ node)\n        end\n    end\n    if length(even_nodes) < 1\n        return []\n\
    \    end\n    min_node = minimum(even_nodes)\n    min_index = find(arr .== min_node)[1]\n\
    \    return [min_node, min_index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp1io37yk7.jl:53

    '
  stdout: "test set: Error During Test at /tmp/tmp1io37yk7.jl:56\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type \n    Int64 to an object of type \n    Array{Int64}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] push!(a::Vector{Array{Int64}}, item::Int64)\n\
    \     @ Base ./array.jl:994\n   [2] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp1io37yk7.jl:41\n\
    \   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp1io37yk7.jl:56 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp1io37yk7.jl:55\ntest set:\
    \ Error During Test at /tmp/tmp1io37yk7.jl:57\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type \n    Int64 to an object of type \n    Array{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] push!(a::Vector{Array{Int64}}, item::Int64)\n\
    \     @ Base ./array.jl:994\n   [2] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp1io37yk7.jl:41\n\
    \   [3] macro expansion\n     @ ~/.conda/envs/polyglot/sh"
  timestamp: 1660014681
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evenVals = []\n \
    \   evenValsIndx = []\n    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n\
    \            push!(evenVals, arr[i])\n            push!(evenValsIndx, i)\n   \
    \     end\n    end\n    if length(evenVals) == 0\n        return []\n    end\n\
    \    evenValsMin = findmin(evenVals)[1]\n    evenValsMinIndx = findall(evenVals\
    \ .== evenValsMin)[1]\n    return [evenValsMin, evenValsMinIndx]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 6 passed, 2 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpk9y38v9k.jl:55

    '
  stdout: "test set: Test Failed at /tmp/tmpk9y38v9k.jl:58\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpk9y38v9k.jl:58 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpk9y38v9k.jl:57\ntest set: Test Failed at /tmp/tmpk9y38v9k.jl:62\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 2] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpk9y38v9k.jl:62 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpk9y38v9k.jl:57\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    6     2      8\n"
  timestamp: 1660014679
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # Step 1: Check if empty array\n    if isempty(arr)\n        return []\n\
    \    end\n    \n    # Step 2: Initialise variables\n    idx = nothing\n    smallest\
    \ = 1e12\n    \n    # Step 3: Loop over elements, checking if it's even\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0 && arr[i] < smallest\n      \
    \      smallest = arr[i]\n            idx = i\n        end\n    end\n    \n  \
    \  # Step 4: Check if there are no even values\n    if idx == nothing\n      \
    \  return []\n    end\n    \n    # Step 5: Return result\n    return [smallest,\
    \ idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp4kwsyned.jl:62

    '
  stdout: "test set: Test Failed at /tmp/tmp4kwsyned.jl:65\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp4kwsyned.jl:65 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp4kwsyned.jl:64\ntest set: Test Failed at /tmp/tmp4kwsyned.jl:66\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp4kwsyned.jl:66 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp4kwsyned.jl:64\ntest set: Test\
    \ Failed at /tmp/tmp4kwsyned.jl:68\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp4kwsyned.jl:68 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp4kwsyned.jl:64\ntest set: Test Failed at /tmp/tmp4kwsyned.jl:69\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp4kwsyned.jl:69 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp4kwsyned.jl:64\ntest set: Test\
    \ Failed at /tmp/tmp4kwsyned.jl:70\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014679
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    filtered = sort(arr[mod.(arr, 2) .== 0]);\n    if isempty(filtered)\n\
    \        return []\n    else\n        index = findfirst(arr, filtered[1]);\n \
    \       return [filtered[1], index];\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmprfvg9uu5.jl:45

    '
  stdout: "test set: Error During Test at /tmp/tmprfvg9uu5.jl:48\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmprfvg9uu5.jl:39\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmprfvg9uu5.jl:48 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmprfvg9uu5.jl:47\ntest set:\
    \ Error During Test at /tmp/tmprfvg9uu5.jl:49\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmprfvg9uu5.jl:39\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmprfvg9uu5.jl:49 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmprfvg9uu5.jl:47\ntest set:\
    \ Error During Test at /tmp/tmprfvg9uu5.jl:51\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014681
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_idx = findall(arr .% 2 .== 0)\n    if isempty(even_idx)\n       \
    \ return []\n    end\n    v = sort(arr[even_idx])\n    return [v[1], even_idx[1]]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpt567xkj_.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmpt567xkj_.jl:48\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpt567xkj_.jl:48 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpt567xkj_.jl:46\ntest set: Test Failed at /tmp/tmpt567xkj_.jl:50\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpt567xkj_.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpt567xkj_.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpt567xkj_.jl:51\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 2] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpt567xkj_.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpt567xkj_.jl:46\ntest set: Test Failed at /tmp/tmpt567xkj_.jl:52\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpt567xkj_.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpt567xkj_.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpt567xkj_.jl:53\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/"
  timestamp: 1660014679
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    smallestEvenValue = Inf\n    smallestEvenIndex = NaN\n    for i in 1:length(arr)\n\
    \        arrValue = arr[i]\n        if (isEven(arrValue) && arrValue < smallestEvenValue)\n\
    \            smallestEvenValue = arrValue\n            smallestEvenIndex = i\n\
    \        end\n    end\n    if (smallestEvenValue != Inf)\n        [smallestEvenValue,\
    \ smallestEvenIndex]\n    else\n        []\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 7 errored,
    0 broken.

    in expression starting at /tmp/tmpbb79u3h6.jl:52

    '
  stdout: "test set: Error During Test at /tmp/tmpbb79u3h6.jl:55\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  UndefVarError: isEven not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpbb79u3h6.jl:39\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbb79u3h6.jl:55 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbb79u3h6.jl:54\ntest set:\
    \ Error During Test at /tmp/tmpbb79u3h6.jl:56\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  UndefVarError: isEven not defined\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpbb79u3h6.jl:39\n   [2]\
    \ macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbb79u3h6.jl:56 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbb79u3h6.jl:54\ntest set:\
    \ Error During Test at /tmp/tmpbb79u3h6.jl:58\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  UndefVarError: isEven not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpbb79u3h6.jl:39\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbb79u3h6.jl:58 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbb79u3h6.jl:54\ntest set:\
    \ Error During Test at /tmp/tmpbb79u3h6.jl:59\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n  UndefVarError: isEven not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpbb79u3h6.jl:39\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib"
  timestamp: 1660014680
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = []\n    for (index,value) in enumerate(arr)\n        if value\
    \ % 2 == 0\n            push!(evens, [value, index])\n        end\n    end\n \
    \   if length(evens) == 0\n        return []\n    end\n    min_index = 1\n   \
    \ min_value = evens[1][1]\n    for (index,even) in enumerate(evens)\n        if\
    \ even[1] < min_value\n            min_value = even[1]\n            min_index\
    \ = index\n        end\n    end\n    return evens[min_index]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpigts0h1v.jl:56

    '
  stdout: "test set: Test Failed at /tmp/tmpigts0h1v.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpigts0h1v.jl:59 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpigts0h1v.jl:58\ntest set: Test Failed at /tmp/tmpigts0h1v.jl:60\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpigts0h1v.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpigts0h1v.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpigts0h1v.jl:62\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpigts0h1v.jl:62 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpigts0h1v.jl:58\ntest set: Test Failed at /tmp/tmpigts0h1v.jl:63\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpigts0h1v.jl:63 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpigts0h1v.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpigts0h1v.jl:64\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014679
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    to_return = []\n    if length(arr) == 0\n        return to_return\n  \
    \  end\n    small_value = \"inf\"\n    for (i, value) in enumerate(arr)\n    \
    \    if value % 2 == 0 && value < small_value\n            small_value = value\n\
    \            to_return = [value, i]\n        end\n    end\n    if small_value\
    \ == \"inf\"\n        return []\n    end\n    return to_return\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpjbmvkgbp.jl:53

    '
  stdout: "test set: Error During Test at /tmp/tmpjbmvkgbp.jl:56\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ isless(::Int64, ::String)\n  Closest candidates are:\n    isless(!Matched::AbstractString,\
    \ ::AbstractString) at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:344\n\
    \    isless(::Real, !Matched::AbstractFloat) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:185\n\
    \    isless(::Real, !Matched::Real) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:430\n\
    \    ...\n  Stacktrace:\n   [1] <(x::Int64, y::String)\n     @ Base ./operators.jl:352\n\
    \   [2] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpjbmvkgbp.jl:41\n   [3]\
    \ macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpjbmvkgbp.jl:56 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpjbmvkgbp.jl:55\ntest set:\
    \ Error During Test at /tmp/tmpjbmvkgbp.jl:57\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching isless(::Int64,\
    \ ::String)\n  Closest candidates are:\n    isless(!Matched::AbstractString, ::AbstractString)\
    \ at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:344\n    isless(::Real,\
    \ !Matched::AbstractFloat) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:185\n\
    \    isless(::Real, !Matched::Real) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:430\n\
    \    ...\n  Stacktrace:\n   [1] <(x::Int64, y::String)\n     @ Base ./operators.jl:352\n\
    \   [2] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpjbmvkgbp.jl:41\n   [3]\
    \ macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpjbmvkgbp.jl:57 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpjbmvkgbp.jl:55\ntest set:\
    \ Error During Test "
  timestamp: 1660014680
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    smallest_index =\
    \ 1\n    smallest_value = minimum(filter(x -> x != 0 && iseven(x), arr))\n   \
    \ for i = 1:length(arr)\n        if arr[i] == smallest_value\n            smallest_index\
    \ = i\n            break\n        end\n    end\n    return [smallest_value, smallest_index]\n\
    end\n\"\"\"\n    \"Given a string with many words,\n    your task is to return\
    \ the word with the highest frequency,\n    along with the number of times that\
    \ it occurs.\n    If there are multiple words that appear the same maximum number\
    \ of times,\n    return the word with the smallest index in the given string.\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2jq7y6c9.jl:48\nin expression starting at\
    \ /tmp/tmp2jq7y6c9.jl:48\n"
  stdout: ''
  timestamp: 1660014678
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return Vector{Int64}()\n    end\n    even_nodes\
    \ = arr[arr .% 2 .== 0]\n    if isempty(even_nodes)\n        return Vector{Int64}()\n\
    \    end\n    even_nodes_smallest = minimum(even_nodes)\n    idx = findfirst(arr,\
    \ even_nodes_smallest)\n    return [even_nodes_smallest, idx]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp_8744936.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmp_8744936.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_8744936.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_8744936.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_8744936.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_8744936.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_8744936.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_8744936.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_8744936.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_8744936.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014680
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    if size(arr, 1) == 0\n        return []\n    end\n    \n    index\
    \ = size(arr, 1)\n    for i in 1:size(arr, 1)\n        if arr[i] % 2 == 0 && arr[i]\
    \ < arr[index]\n            index = i\n        end\n    end\n    \n    if arr[index]\
    \ % 2 == 0\n        return [arr[index], index]\n    else\n        return []\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3pgmxx44.jl:55

    '
  stdout: "test set: Test Failed at /tmp/tmp3pgmxx44.jl:58\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp3pgmxx44.jl:58 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp3pgmxx44.jl:57\ntest set: Test Failed at /tmp/tmp3pgmxx44.jl:59\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3pgmxx44.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3pgmxx44.jl:57\ntest set: Test\
    \ Failed at /tmp/tmp3pgmxx44.jl:61\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp3pgmxx44.jl:61 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp3pgmxx44.jl:57\ntest set: Test Failed at /tmp/tmp3pgmxx44.jl:62\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3pgmxx44.jl:62 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3pgmxx44.jl:57\ntest set: Test\
    \ Failed at /tmp/tmp3pgmxx44.jl:63\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014678
- exit_code: -1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    indexes_evens = findall(isodd, arr)\n    if !isempty(indexes_evens)\n\
    \        return arr[indexes_evens[1]]\n    else\n        return []\n    end\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: Timeout
  stderr: 'ERROR: LoadError: '
  stdout: "test set: Error During Test at /tmp/tmp4tldoebr.jl:47\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp4tldoebr.jl:37\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp4tldoebr.jl:47 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp4tldoebr.jl:46\ntest set:\
    \ Error During Test at /tmp/tmp4tldoebr.jl:48\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n \
    \   convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp4tldoebr.jl:37\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp4tldoebr.jl:48 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share"
  timestamp: 1660014681
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # TODO: write your code here\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpepph582d.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmpepph582d.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpepph582d.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpepph582d.jl:42\ntest set: Test Failed at /tmp/tmpepph582d.jl:44\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpepph582d.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpepph582d.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpepph582d.jl:46\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: Int64[] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpepph582d.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpepph582d.jl:42\ntest set: Test Failed at /tmp/tmpepph582d.jl:47\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: Int64[]\
    \ == [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpepph582d.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpepph582d.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpepph582d.jl:48\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: Int64[] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1."
  timestamp: 1660014679
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \"\"\"\n    Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n    your task is to pluck one of the nodes and return it.\n \
    \   The plucked node should be the node with the smallest even value.\n    If\
    \ multiple nodes with the same smallest even value are found return the node that\
    \ has smallest index.\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2q_rdxfl.jl:1\nin expression starting at /tmp/tmp2q_rdxfl.jl:1\n"
  stdout: ''
  timestamp: 1660014678
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\n    even_arr = [i for i in arr if i % 2 == 0]\n    sorted_even_arr\
    \ = sort(even_arr)\n    if length(sorted_even_arr) != 0\n        smallest_even\
    \ = sorted_even_arr[1]\n        for i = 1:length(arr)\n            if arr[i] ==\
    \ smallest_even\n                return [smallest_even, i]\n            end\n\
    \        end\n    else\n        return []\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpvoepx2u2.jl:51

    '
  stdout: "test set: Test Failed at /tmp/tmpvoepx2u2.jl:54\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpvoepx2u2.jl:54 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpvoepx2u2.jl:53\ntest set: Test Failed at /tmp/tmpvoepx2u2.jl:55\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvoepx2u2.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvoepx2u2.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpvoepx2u2.jl:57\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpvoepx2u2.jl:57 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpvoepx2u2.jl:53\ntest set: Test Failed at /tmp/tmpvoepx2u2.jl:58\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvoepx2u2.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvoepx2u2.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpvoepx2u2.jl:59\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014679
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # check if the array is empty\n    if isempty(arr) \n        return []\n\
    \    end\n    # get the even numbers\n    evens = arr[ arr .% 2 .== 0 ]\n    #\
    \ check if the array has no even numbers\n    if isempty(evens)\n        return\
    \ []\n    end\n    # the smallest even number\n    min_even = minimum(evens)\n\
    \    # find the index of the first occurrence of the smallest even number\n  \
    \  index = findfirst(arr .== min_even)\n    # return the smallest even number\
    \ and its index\n    return [min_even, index]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp1t8ih68p.jl:54

    '
  stdout: "test set: Test Failed at /tmp/tmp1t8ih68p.jl:57\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp1t8ih68p.jl:57 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp1t8ih68p.jl:56\ntest set: Test Failed at /tmp/tmp1t8ih68p.jl:58\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1t8ih68p.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1t8ih68p.jl:56\ntest set: Test\
    \ Failed at /tmp/tmp1t8ih68p.jl:60\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp1t8ih68p.jl:60 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp1t8ih68p.jl:56\ntest set: Test Failed at /tmp/tmp1t8ih68p.jl:61\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1t8ih68p.jl:61 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1t8ih68p.jl:56\ntest set: Test\
    \ Failed at /tmp/tmp1t8ih68p.jl:62\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014679
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    return [e for e in arr if e % 2 == 0 ? first(sort(e)), findfirst(arr,\
    \ e)[1] : nothing]\nend\n    \nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: colon expected in \"?\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpup6gjhf3.jl:35\nin expression starting at\
    \ /tmp/tmpup6gjhf3.jl:35\n"
  stdout: ''
  timestamp: 1660014679
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    min_index = 1\n \
    \   min_value = arr[1]\n    for index in 2:length(arr)\n        if iseven(arr[index])\
    \ && min_value > arr[index]\n            min_index = index\n            min_value\
    \ = arr[index]\n        end\n    end\n    if iseven(min_value)\n        return\
    \ [min_value, min_index]\n    else\n        return []\n    end\nend\n# iseven()\n\
    \"\"\"\n    \"Given a number your task is to determine if it is even or not.\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpq461aikf.jl:53\nin expression starting at\
    \ /tmp/tmpq461aikf.jl:53\n"
  stdout: ''
  timestamp: 1660014679
- exit_code: -1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \"\"\"\n    pluck the node with the smallest even value, return an array\n\
    \    \"\"\"\n    #an empty array\n    if isempty(arr)\n        return []\n   \
    \ end\n    #find the smallest even value in the array\n    min_even = min(setdiff(arr,\
    \ range(1, stop=maximum(arr), step=2)))\n    #find the index of the min_even\n\
    \    index = findall(arr .== min_even)[1]\n    return [min_even, index]\nend\n\
    println(pluck([5, 0, 3, 0, 4, 2]))\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: Timeout
  stderr: "ERROR: LoadError: MethodError: no method matching min(::Vector{Int64})\n\
    Closest candidates are:\n  min(::Any, !Matched::Missing) at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n\
    \  min(::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n\
    \  min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \  ...\nStacktrace:\n [1] pluck("
  stdout: ''
  timestamp: 1660014683
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    arr = arr[findall(x -> iseven(x), arr)]\n    n = length(arr)\n    if n\
    \ != 0\n        return [minimum(arr), findfirst(arr, minimum(arr))]\n    else\n\
    \        return []\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpnekldleg.jl:45

    '
  stdout: "test set: Error During Test at /tmp/tmpnekldleg.jl:48\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpnekldleg.jl:38\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnekldleg.jl:48 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnekldleg.jl:47\ntest set:\
    \ Error During Test at /tmp/tmpnekldleg.jl:49\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpnekldleg.jl:38\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnekldleg.jl:49 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnekldleg.jl:47\ntest set:\
    \ Error During Test at /tmp/tmpnekldleg.jl:51\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014683
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    arr = filter(x -> iseven(x), arr)\n    if length(arr) == 0\n        return\
    \ []\n    end\n    arr = sort(arr)\n    arr = [arr[1], findfirst(arr, arr[1])]\n\
    \    return arr\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmps02_76zd.jl:45

    '
  stdout: "test set: Error During Test at /tmp/tmps02_76zd.jl:48\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmps02_76zd.jl:40\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmps02_76zd.jl:48 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmps02_76zd.jl:47\ntest set:\
    \ Error During Test at /tmp/tmps02_76zd.jl:49\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmps02_76zd.jl:40\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmps02_76zd.jl:49 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmps02_76zd.jl:47\ntest set:\
    \ Error During Test at /tmp/tmps02_76zd.jl:51\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014683
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    res = [0,0]\n    # your code here\n    return res\nend\n    \nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 8 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmprujs5ok0.jl:42

    '
  stdout: "test set: Test Failed at /tmp/tmprujs5ok0.jl:45\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [0, 0] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmprujs5ok0.jl:45 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmprujs5ok0.jl:44\ntest set: Test Failed at /tmp/tmprujs5ok0.jl:46\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [0, 0] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmprujs5ok0.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprujs5ok0.jl:44\ntest set: Test\
    \ Failed at /tmp/tmprujs5ok0.jl:47\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [0, 0] == Int64[]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmprujs5ok0.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprujs5ok0.jl:44\ntest set: Test\
    \ Failed at /tmp/tmprujs5ok0.jl:48\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 0] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmprujs5ok0.jl:48 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmprujs5ok0.jl:44\ntest set: Test Failed at /tmp/tmprujs5ok0.jl:49\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 0] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/s"
  timestamp: 1660014681
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    #TODO: finish this\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpnotu9b3d.jl:39

    '
  stdout: "test set: Error During Test at /tmp/tmpnotu9b3d.jl:42\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpnotu9b3d.jl:36\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnotu9b3d.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnotu9b3d.jl:41\ntest set:\
    \ Error During Test at /tmp/tmpnotu9b3d.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpnotu9b3d.jl:36\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnotu9b3d.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/s"
  timestamp: 1660014684
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    arr = [i for i in arr if iseven(i)]\n    isempty(arr) && return []\n \
    \   v = minimum(arr)\n    return [v, findfirst(arr, v)]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp5663mvw1.jl:42

    '
  stdout: "test set: Error During Test at /tmp/tmp5663mvw1.jl:45\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp5663mvw1.jl:38\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp5663mvw1.jl:45 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp5663mvw1.jl:44\ntest set:\
    \ Error During Test at /tmp/tmp5663mvw1.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp5663mvw1.jl:38\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp5663mvw1.jl:46 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp5663mvw1.jl:44\ntest set:\
    \ Error During Test at /tmp/tmp5663mvw1.jl:48\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014683
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    smallest_even_value::Int64 = nothing\n    even_value_index::Int64 = nothing\n\
    \    for (index, value) in enumerate(arr)\n        if rem(value, 2) == 0\n   \
    \         if smallest_even_value == nothing\n                smallest_even_value\
    \ = value\n                even_value_index = index\n            elseif value\
    \ < smallest_even_value\n                smallest_even_value = value\n       \
    \         even_value_index = index\n            end\n        end\n    end\n  \
    \  return [smallest_even_value, even_value_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmp7y86jife.jl:52

    '
  stdout: "test set: Error During Test at /tmp/tmp7y86jife.jl:55\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::Ptr) where T<:Integer at ~/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at ~/.conda/envs/polyglot/share/julia/base/number.jl:6\n\
    \    convert(::Type{T}, !Matched::Number) where T<:Number at ~/.conda/envs/polyglot/share/julia/base/number.jl:7\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp7y86jife.jl:35\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp7y86jife.jl:55 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp7y86jife.jl:54\ntest set:\
    \ Error During Test at /tmp/tmp7y86jife.jl:56\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at ~/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at ~/.conda/envs/polyglot/share/julia/base/number.jl:6\n\
    \    convert(::Type{T}, !Matched::Number) where T<:Number at ~/.conda/envs/polyglot/share/julia/base/number.jl:7\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp7y86jife.jl:35\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp7y86jife.jl:56 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp7y86jife.jl:54\ntest set:\
    \ Error During Test at /tmp/tmp7y86jife.jl:57\n  Test threw excepti"
  timestamp: 1660014683
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if arr == [] return [] end\n    if even(arr[1])\n        return [arr[1],\
    \ 1]\n    end\n    even_arr = pluck(filter(x -> even(x), arr))\n    if even_arr\
    \ == [] return [] end\n    tmp = searchsortedfirst(arr, even_arr[1])\n    return\
    \ [even_arr[1], tmp]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 7 errored,
    0 broken.

    in expression starting at /tmp/tmpapo782vq.jl:46

    '
  stdout: "test set: Error During Test at /tmp/tmpapo782vq.jl:49\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  UndefVarError: even not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpapo782vq.jl:36\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpapo782vq.jl:49 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpapo782vq.jl:48\ntest set:\
    \ Error During Test at /tmp/tmpapo782vq.jl:50\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  UndefVarError: even not defined\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpapo782vq.jl:36\n   [2]\
    \ macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpapo782vq.jl:50 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpapo782vq.jl:48\ntest set:\
    \ Error During Test at /tmp/tmpapo782vq.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  UndefVarError: even not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpapo782vq.jl:36\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpapo782vq.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpapo782vq.jl:48\ntest set:\
    \ Error During Test at /tmp/tmpapo782vq.jl:53\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n  UndefVarError: even not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpapo782vq.jl:36\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Te"
  timestamp: 1660014682
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # Your code goes here...\n    lenght = length(arr)\n    index = 1\n  \
    \  min_value = maximum(arr)\n    min_index = 1\n    while index <= lenght\n  \
    \      if (arr[index] <= min_value) & (arr[index] % 2 == 0)\n            min_value\
    \ = arr[index]\n            min_index = index\n        end\n        index += 1\n\
    \    end\n    if min_value == maximum(arr)\n        return []\n    else\n    \
    \    return [min_value, min_index]\n    end\nend\npluck([4, 2, 3])\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 6 failed, 1 errored,
    0 broken.

    in expression starting at /tmp/tmphh_sd3x4.jl:56

    '
  stdout: "test set: Test Failed at /tmp/tmphh_sd3x4.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmphh_sd3x4.jl:59 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmphh_sd3x4.jl:58\ntest set: Test Failed at /tmp/tmphh_sd3x4.jl:60\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphh_sd3x4.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphh_sd3x4.jl:58\ntest set: Error\
    \ During Test at /tmp/tmphh_sd3x4.jl:61\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  ArgumentError: reducing\
    \ over an empty collection is not allowed\n  Stacktrace:\n    [1] _empty_reduce_error()\n\
    \      @ Base ./reduce.jl:301\n    [2] reduce_empty(op::Function, #unused#::Type{Int64})\n\
    \      @ Base ./reduce.jl:311\n    [3] mapreduce_empty(#unused#::typeof(identity),\
    \ op::Function, T::Type)\n      @ Base ./reduce.jl:345\n    [4] reduce_empty(op::Base.MappingRF{typeof(identity),\
    \ typeof(max)}, #unused#::Type{Int64})\n      @ Base ./reduce.jl:331\n    [5]\
    \ reduce_empty_iter\n      @ ./reduce.jl:357 [inlined]\n    [6] mapreduce_empty_iter(f::Function,\
    \ op::Function, itr::Vector{Int64}, ItrEltype::Base.HasEltype)\n      @ Base ./reduce.jl:353\n\
    \    [7] _mapreduce\n      @ ./reduce.jl:402 [inlined]\n    [8] _mapreduce_dim\n\
    \      @ ./reducedim.jl:330 [inlined]\n    [9] #mapreduce#731\n      @ ./reducedim.jl:322\
    \ [inlined]\n   [10] mapreduce\n      @ ./reducedim.jl:322 [inlined]\n   [11]\
    \ #_maximum#749\n      @ ./reducedim.jl:894 [inlined]\n   [12] _maximum\n    \
    \  @ ./reducedim.jl:894 [inlined]\n   [13] #_maxi"
  timestamp: 1660014683
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # The first element that is even and then smaller than the next even element\
    \ or\n    # the last even element if there is no such.\n    return [arr[i] for\
    \ i in 1:length(arr) if iseven(arr[i])][1]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmp_yfwtle8.jl:41

    '
  stdout: "test set: Error During Test at /tmp/tmp_yfwtle8.jl:44\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_yfwtle8.jl:37\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_yfwtle8.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_yfwtle8.jl:43\ntest set:\
    \ Error During Test at /tmp/tmp_yfwtle8.jl:45\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n \
    \   convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_yfwtle8.jl:37\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_yfwtle8.jl:45 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share"
  timestamp: 1660014684
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # Verify edge case\n    if isempty(arr)\n        return []\n    end\n\
    \    \n    # Create a container to store even value and index\n    evenArr = Vector{Int64}()\n\
    \    \n    # Search through array\n    for i in 1:length(arr)\n        if arr[i]\
    \ % 2 == 0\n            push!(evenArr, [arr[i], i])\n        end\n    end\n  \
    \  \n    # If there is no even values in array\n    if isempty(evenArr)\n    \
    \    return []\n    end\n    \n    # Sort array by even values ascendingly\n \
    \   # In case if even values are same, sort by its index ascendingly\n    sort!(evenArr,\
    \ by = x -> (x[1], x[2]))\n    \n    # Return the first element in evenArr\n \
    \   return evenArr[1]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp4h1vw5f_.jl:64

    '
  stdout: "test set: Error During Test at /tmp/tmp4h1vw5f_.jl:67\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Vector{Int64} to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at ~/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at ~/.conda/envs/polyglot/share/julia/base/number.jl:6\n\
    \    convert(::Type{T}, !Matched::Number) where T<:Number at ~/.conda/envs/polyglot/share/julia/base/number.jl:7\n\
    \    ...\n  Stacktrace:\n   [1] push!(a::Vector{Int64}, item::Vector{Int64})\n\
    \     @ Base ./array.jl:994\n   [2] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp4h1vw5f_.jl:46\n\
    \   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp4h1vw5f_.jl:67 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp4h1vw5f_.jl:66\ntest set:\
    \ Error During Test at /tmp/tmp4h1vw5f_.jl:68\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n \
    \   convert(::Type{T}, !Matched::Ptr) where T<:Integer at ~/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at ~/.conda/envs/polyglot/share/julia/base/number.jl:6\n\
    \    convert(::Type{T}, !Matched::Number) where T<:Number at ~/.conda/envs/polyglot/share/julia/base/number.jl:7\n\
    \    ...\n  Stacktrace:\n   [1] push!(a::Vector{Int64}, item::Vector{Int64})\n\
    \     @ Base ./array.jl:994\n   [2] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp4h1vw5f_.jl:46\n\
    \   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp4h1vw5f_.jl:68 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/s"
  timestamp: 1660014683
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # Check if array is empty\n    if isempty(arr)\n        return []\n  \
    \  end\n    \n    # Find even values and their indices\n    even_values = []\n\
    \    even_indices = []\n    for (index, value) in enumerate(arr)\n        if value\
    \ % 2 == 0\n            push!(even_values, value)\n            push!(even_indices,\
    \ index)\n        end\n    end\n    \n    # Check if there are even values\n \
    \   if isempty(even_values)\n        return []\n    end\n    \n    # Find lowest\
    \ value\n    low_value = minimum(even_values)\n    \n    # Get indices of the\
    \ lowest value\n    low_indices = []\n    for (index, value) in enumerate(even_values)\n\
    \        if value == low_value\n            push!(low_indices, even_indices[index])\n\
    \        end\n    end\n    \n    # Find lowest index\n    low_index = minimum(low_indices)\n\
    \    \n    # Return plucked value\n    return [low_value, low_index]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp6nwd9eu5.jl:74

    '
  stdout: "test set: Test Failed at /tmp/tmp6nwd9eu5.jl:77\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp6nwd9eu5.jl:77 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp6nwd9eu5.jl:76\ntest set: Test Failed at /tmp/tmp6nwd9eu5.jl:78\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6nwd9eu5.jl:78 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6nwd9eu5.jl:76\ntest set: Test\
    \ Failed at /tmp/tmp6nwd9eu5.jl:80\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp6nwd9eu5.jl:80 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp6nwd9eu5.jl:76\ntest set: Test Failed at /tmp/tmp6nwd9eu5.jl:81\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6nwd9eu5.jl:81 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6nwd9eu5.jl:76\ntest set: Test\
    \ Failed at /tmp/tmp6nwd9eu5.jl:82\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014682
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    return pluck(arr, Int64[])\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpoarrzab9.jl:39

    '
  stdout: "test set: Error During Test at /tmp/tmpoarrzab9.jl:42\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ pluck(::Vector{Int64}, ::Vector{Int64})\n  Closest candidates are:\n    pluck(::Vector{Int64})\
    \ at /tmp/tmpoarrzab9.jl:34\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpoarrzab9.jl:35\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpoarrzab9.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpoarrzab9.jl:41\ntest set:\
    \ Error During Test at /tmp/tmpoarrzab9.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching pluck(::Vector{Int64},\
    \ ::Vector{Int64})\n  Closest candidates are:\n    pluck(::Vector{Int64}) at /tmp/tmpoarrzab9.jl:34\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpoarrzab9.jl:35\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpoarrzab9.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpoarrzab9.jl:41\ntest set:\
    \ Error During Test at /tmp/tmpoarrzab9.jl:44\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: no method\
    \ matching pluck(::Vector{Int64}, ::Vector{Int64})\n  Closest candidates are:\n\
    \    pluck(::Vector{Int64}) at /tmp/tmpoarrzab9.jl:34\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpoarrzab9.jl:35\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpoarrzab9.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-l"
  timestamp: 1660014683
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    smallestIndex = 0\n    smallestEvenVal = 1\n    for (index, val) in enumerate(arr)\n\
    \        if (val % 2 == 0) && (val < smallestEvenVal)\n            smallestEvenVal\
    \ = val\n            smallestIndex = index\n        end\n    end\n    if smallestEvenVal\
    \ == 1\n        return []\n    end\n    return [smallestEvenVal, smallestIndex]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpulxjkgj4.jl:50

    '
  stdout: "test set: Test Failed at /tmp/tmpulxjkgj4.jl:53\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpulxjkgj4.jl:53 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpulxjkgj4.jl:52\ntest set: Test Failed at /tmp/tmpulxjkgj4.jl:54\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpulxjkgj4.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpulxjkgj4.jl:52\ntest set: Test\
    \ Failed at /tmp/tmpulxjkgj4.jl:56\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpulxjkgj4.jl:56 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpulxjkgj4.jl:52\ntest set: Test Failed at /tmp/tmpulxjkgj4.jl:57\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpulxjkgj4.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpulxjkgj4.jl:52\ntest set: Test\
    \ Failed at /tmp/tmpulxjkgj4.jl:58\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: Int64[] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/"
  timestamp: 1660014682
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    return arr[findfirst(x -> iseven(x), arr)]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmp6fe_5e1_.jl:39

    '
  stdout: "test set: Error During Test at /tmp/tmp6fe_5e1_.jl:42\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp6fe_5e1_.jl:35\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6fe_5e1_.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6fe_5e1_.jl:41\ntest set:\
    \ Error During Test at /tmp/tmp6fe_5e1_.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n \
    \   convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp6fe_5e1_.jl:35\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6fe_5e1_.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share"
  timestamp: 1660014685
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even = filter(x -> x % 2 == 0, arr)\n    if length(even) == 0\n      \
    \  return []\n    end\n    even_min = minimum(even)\n    idx = findall(x -> x\
    \ == even_min, arr)[1]\n    return [even_min, idx]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp54xvza4z.jl:45

    '
  stdout: "test set: Test Failed at /tmp/tmp54xvza4z.jl:48\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp54xvza4z.jl:48 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp54xvza4z.jl:47\ntest set: Test Failed at /tmp/tmp54xvza4z.jl:49\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp54xvza4z.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp54xvza4z.jl:47\ntest set: Test\
    \ Failed at /tmp/tmp54xvza4z.jl:51\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp54xvza4z.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp54xvza4z.jl:47\ntest set: Test Failed at /tmp/tmp54xvza4z.jl:52\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp54xvza4z.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp54xvza4z.jl:47\ntest set: Test\
    \ Failed at /tmp/tmp54xvza4z.jl:53\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014683
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpzehx0k64.jl:39

    '
  stdout: "test set: Test Failed at /tmp/tmpzehx0k64.jl:42\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpzehx0k64.jl:42 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpzehx0k64.jl:41\ntest set: Test Failed at /tmp/tmpzehx0k64.jl:43\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzehx0k64.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzehx0k64.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpzehx0k64.jl:45\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: Int64[] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpzehx0k64.jl:45 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpzehx0k64.jl:41\ntest set: Test Failed at /tmp/tmpzehx0k64.jl:46\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: Int64[]\
    \ == [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzehx0k64.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzehx0k64.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpzehx0k64.jl:47\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: Int64[] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1."
  timestamp: 1660014683
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    if isempty(filter(i ->\
    \ i%2 == 0, arr))\n        return []\n    end\n    min_even = minimum(filter(i\
    \ -> i%2 == 0, arr))\n    min_index = find(arr.==min_even)[1]\n    return [min_even,\
    \ min_index]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpou7e91ja.jl:47

    '
  stdout: "test set: Error During Test at /tmp/tmpou7e91ja.jl:50\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  UndefVarError: find not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpou7e91ja.jl:42\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpou7e91ja.jl:50 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpou7e91ja.jl:49\ntest set:\
    \ Error During Test at /tmp/tmpou7e91ja.jl:51\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  UndefVarError: find not defined\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpou7e91ja.jl:42\n   [2]\
    \ macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpou7e91ja.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpou7e91ja.jl:49\ntest set:\
    \ Error During Test at /tmp/tmpou7e91ja.jl:53\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  UndefVarError: find not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpou7e91ja.jl:42\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpou7e91ja.jl:53 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpou7e91ja.jl:49\ntest set:\
    \ Error During Test at /tmp/tmpou7e91ja.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n  UndefVarError: find not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpou7e91ja.jl:42\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Te"
  timestamp: 1660014684
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_pos = findall(x -> x % 2 == 0, arr)\n    if length(even_pos) == 0\n\
    \        return Vector{Int64}()\n    end\n    even_smallest_value = findfirst(x\
    \ -> x % 2 == 0, arr)\n    even_smallest_index = findfirst(even_pos .== even_smallest_value)\n\
    \    return [even_smallest_value, even_smallest_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpnqt_kzrf.jl:45

    '
  stdout: "test set: Test Failed at /tmp/tmpnqt_kzrf.jl:48\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [1, 1] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpnqt_kzrf.jl:48 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpnqt_kzrf.jl:47\ntest set: Test Failed at /tmp/tmpnqt_kzrf.jl:51\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [2, 1] ==\
    \ [0, 1]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnqt_kzrf.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnqt_kzrf.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpnqt_kzrf.jl:52\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [2, 1] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpnqt_kzrf.jl:52 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpnqt_kzrf.jl:47\ntest set: Test Failed at /tmp/tmpnqt_kzrf.jl:53\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [2, 1] == [4,\
    \ 1]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnqt_kzrf.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnqt_kzrf.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpnqt_kzrf.jl:54\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [2, 1] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/"
  timestamp: 1660014684
- exit_code: -1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_values = []\n  \
    \  for (i, a) in enumerate(arr)\n        if iseven(a)\n            push!(even_values,\
    \ (a, i))\n        end\n    end\n    if isempty(even_values)\n        return []\n\
    \    end\n    return minimum(even_values)[:]\nend\npluck([4, 2, 3])\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: Timeout
  stderr: "ERROR: LoadError: MethodError: Cannot `convert` an object of type Tuple{Int64,\
    \ Int64} to an object of type Vector{Int64}\nClosest candidates are:\n  convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \  convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \  convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \  ...\nStacktrace:\n [1] pluck(arr::"
  stdout: ''
  timestamp: 1660014686
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # function to check if an integer is even or not\n    even(x::Int64) =\
    \ (x % 2 == 0 ? true : false)\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpsdhgf7t2.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpsdhgf7t2.jl:1\n\
    in expression starting at /tmp/tmpsdhgf7t2.jl:1\n"
  stdout: ''
  timestamp: 1660014682
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    dtype = Vector{Int64}\n    indices = []\n    even = []\n    for i in 1:length(arr)\n\
    \        if iseven(arr[i])\n            push!(even, arr[i])\n            push!(indices,\
    \ i)\n        end\n    end\n    if length(even) > 0\n        minimum = minimum(even)\n\
    \        indx = findall(even .== minimum)[1]\n        return [minimum, indices[indx]]\n\
    \    else\n        return []\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpxd4ixeqa.jl:54

    '
  stdout: "test set: Error During Test at /tmp/tmpxd4ixeqa.jl:57\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  UndefVarError: minimum not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpxd4ixeqa.jl:45\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxd4ixeqa.jl:57 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpxd4ixeqa.jl:56\ntest set:\
    \ Error During Test at /tmp/tmpxd4ixeqa.jl:58\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  UndefVarError: minimum not defined\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpxd4ixeqa.jl:45\n   [2]\
    \ macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxd4ixeqa.jl:58 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpxd4ixeqa.jl:56\ntest set:\
    \ Error During Test at /tmp/tmpxd4ixeqa.jl:60\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  UndefVarError: minimum not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpxd4ixeqa.jl:45\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxd4ixeqa.jl:60 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpxd4ixeqa.jl:56\ntest set:\
    \ Error During Test at /tmp/tmpxd4ixeqa.jl:61\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n  UndefVarError: minimum not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpxd4ixeqa.jl:45\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/st"
  timestamp: 1660014684
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) > 0\n        if length(arr[arr .% 2 .== 0]) > 0\n     \
    \       index = findfirst(arr, minimum(arr[arr .% 2 .== 0]))\n            return\
    \ [arr[index], index]\n        else\n            return []\n        end\n    else\n\
    \        return []\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpeljmo_k8.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpeljmo_k8.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpeljmo_k8.jl:37\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpeljmo_k8.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpeljmo_k8.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpeljmo_k8.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpeljmo_k8.jl:37\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpeljmo_k8.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpeljmo_k8.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpeljmo_k8.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014686
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    candidates = []\n    idx = []\n    for (i, n) in enumerate(arr)\n    \
    \    if n % 2 == 0\n            push!(candidates, n)\n            push!(idx, i)\n\
    \        end\n    end\n    if length(candidates) == 0\n        return []\n   \
    \ end\n    min_candidate = minimum(candidates)\n    min_idx = findmin(candidates)[2]\n\
    \    return [min_candidate, idx[min_idx]]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp07dx091u.jl:52

    '
  stdout: "test set: Test Failed at /tmp/tmp07dx091u.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp07dx091u.jl:55 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp07dx091u.jl:54\ntest set: Test Failed at /tmp/tmp07dx091u.jl:56\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp07dx091u.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp07dx091u.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp07dx091u.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp07dx091u.jl:58 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp07dx091u.jl:54\ntest set: Test Failed at /tmp/tmp07dx091u.jl:59\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp07dx091u.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp07dx091u.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp07dx091u.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014684
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = arr[mod.(arr, 2) .== 0] # Get all values that are even\n    if\
    \ isempty(evens)\n        return []\n    end\n    min = minimum(evens)\n    min_i\
    \ = findfirst(arr, min) # Find the index of the smallest value \n    return [min,\
    \ min_i]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpqcc9n0w8.jl:45

    '
  stdout: "test set: Error During Test at /tmp/tmpqcc9n0w8.jl:48\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpqcc9n0w8.jl:40\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpqcc9n0w8.jl:48 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpqcc9n0w8.jl:47\ntest set:\
    \ Error During Test at /tmp/tmpqcc9n0w8.jl:49\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpqcc9n0w8.jl:40\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpqcc9n0w8.jl:49 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpqcc9n0w8.jl:47\ntest set:\
    \ Error During Test at /tmp/tmpqcc9n0w8.jl:51\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014686
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    if length(arr) == 0\n        return []\n    end\n    \n    smallest_even\
    \ = Inf\n    smallest_index = Inf\n    \n    for node in 1:length(arr)\n     \
    \   if mod(arr[node], 2) == 0\n            if arr[node] < smallest_even\n    \
    \            smallest_even = arr[node]\n                smallest_index = node\n\
    \            end\n        end\n    end\n    \n    if smallest_even == Inf\n  \
    \      return []\n    end\n    \n    return [smallest_even, smallest_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpfjg81409.jl:60

    '
  stdout: "test set: Test Failed at /tmp/tmpfjg81409.jl:63\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpfjg81409.jl:63 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpfjg81409.jl:62\ntest set: Test Failed at /tmp/tmpfjg81409.jl:64\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpfjg81409.jl:64 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpfjg81409.jl:62\ntest set: Test\
    \ Failed at /tmp/tmpfjg81409.jl:66\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpfjg81409.jl:66 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpfjg81409.jl:62\ntest set: Test Failed at /tmp/tmpfjg81409.jl:67\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpfjg81409.jl:67 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpfjg81409.jl:62\ntest set: Test\
    \ Failed at /tmp/tmpfjg81409.jl:68\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014685
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # Check if there is any even numbers\n    evens = [n for n in arr if iseven(n)]\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpqd5cz9lj.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpqd5cz9lj.jl:1\n\
    in expression starting at /tmp/tmpqd5cz9lj.jl:1\n"
  stdout: ''
  timestamp: 1660014684
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = [ x for x in arr if x % 2 == 0 ]\n    if length(evens) == 0\n\
    \        return []\n    end\n    return [ minimum(evens), findfirst(arr, minimum(evens))\
    \ ]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpkygexov5.jl:43

    '
  stdout: "test set: Error During Test at /tmp/tmpkygexov5.jl:46\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpkygexov5.jl:39\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpkygexov5.jl:46 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpkygexov5.jl:45\ntest set:\
    \ Error During Test at /tmp/tmpkygexov5.jl:47\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpkygexov5.jl:39\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpkygexov5.jl:47 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpkygexov5.jl:45\ntest set:\
    \ Error During Test at /tmp/tmpkygexov5.jl:49\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014687
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i = 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, arr[i])\n\
    \        end\n    end\n    if length(evens) == 0\n        return []\n    end\n\
    \    minindex = indmin(evens)\n    minvalue = evens[minindex]\n    indices = findall(arr\
    \ .== minvalue)\n    return [minvalue, minimum(indices)]\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpt8sy1ht1.jl:54

    '
  stdout: "test set: Error During Test at /tmp/tmpt8sy1ht1.jl:57\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  UndefVarError: indmin not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpt8sy1ht1.jl:47\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpt8sy1ht1.jl:57 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpt8sy1ht1.jl:56\ntest set:\
    \ Error During Test at /tmp/tmpt8sy1ht1.jl:58\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  UndefVarError: indmin not defined\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpt8sy1ht1.jl:47\n   [2]\
    \ macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpt8sy1ht1.jl:58 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpt8sy1ht1.jl:56\ntest set:\
    \ Error During Test at /tmp/tmpt8sy1ht1.jl:60\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  UndefVarError: indmin not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpt8sy1ht1.jl:47\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpt8sy1ht1.jl:60 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpt8sy1ht1.jl:56\ntest set:\
    \ Error During Test at /tmp/tmpt8sy1ht1.jl:61\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n  UndefVarError: indmin not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpt8sy1ht1.jl:47\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib"
  timestamp: 1660014686
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_index_arr = [i for i in 1:length(arr) if iseven(arr[i])]\n\
    \    even_val_arr = [arr[i] for i in even_index_arr]\n    \n    # If there are\
    \ no even values or the given vector is empty\n    if length(even_val_arr) ==\
    \ 0\n        return []\n    end\n    \n    min_even_val = findmin(even_val_arr)[1]\n\
    \    min_even_index = findmin(even_index_arr)[1]\n    \n    return [min_even_val,\
    \ min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmplp51gh_0.jl:51

    '
  stdout: "test set: Test Failed at /tmp/tmplp51gh_0.jl:55\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmplp51gh_0.jl:55 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmplp51gh_0.jl:53\ntest set: Test Failed at /tmp/tmplp51gh_0.jl:57\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmplp51gh_0.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmplp51gh_0.jl:53\ntest set: Test\
    \ Failed at /tmp/tmplp51gh_0.jl:58\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 2] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmplp51gh_0.jl:58 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmplp51gh_0.jl:53\ntest set: Test Failed at /tmp/tmplp51gh_0.jl:59\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmplp51gh_0.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmplp51gh_0.jl:53\ntest set: Test\
    \ Failed at /tmp/tmplp51gh_0.jl:60\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/"
  timestamp: 1660014686
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr) || (reduce(max, arr) < 2)\n        return Int64[]\n  \
    \  end\n    filtered_even_array = Array{Int64}(filter(x -> x%2 == 0, arr))\n \
    \   min_even_value = reduce(min, filtered_even_array)\n    min_even_value_index\
    \ = findfirst(arr, min_even_value)\n    return [min_even_value, min_even_value_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 7 errored,
    0 broken.

    in expression starting at /tmp/tmps_t591h2.jl:45

    '
  stdout: "test set: Error During Test at /tmp/tmps_t591h2.jl:48\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmps_t591h2.jl:40\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmps_t591h2.jl:48 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmps_t591h2.jl:47\ntest set:\
    \ Error During Test at /tmp/tmps_t591h2.jl:49\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmps_t591h2.jl:40\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmps_t591h2.jl:49 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmps_t591h2.jl:47\ntest set:\
    \ Error During Test at /tmp/tmps_t591h2.jl:51\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014688
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_idx = findall(i -> i % 2 == 0, arr)\n    if length(even_idx) == 0\n\
    \        return []\n    end\n    min_idx = even_idx[argmin(arr[even_idx])]\n \
    \   return [arr[min_idx], min_idx]\nend\n \n```\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: invalid \"`\" syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptvfiuxwv.jl:43\nin expression starting at\
    \ /tmp/tmptvfiuxwv.jl:43\n"
  stdout: ''
  timestamp: 1660014685
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    idx = 1\n    min = Inf\n\
    \    for i = 1:length(arr)\n        if mod(arr[i], 2) == 0\n            if arr[i]\
    \ < min\n                min = arr[i]\n                idx = i\n            end\n\
    \        end\n    end\n    if min == Inf\n        return []\n    end\n    return\
    \ [min, idx]\nend\n@testset \"can handle an empty vector\" begin\n    @test pluck([])\
    \ == []\nend\n@testset \"can handle a vector with only odd values\" begin\n  \
    \  @test pluck([1, 3, 5]) == []\nend\n@testset \"can handle a vector with only\
    \ even values\" begin\n    @test pluck([2, 4, 6]) == [2, 1]\nend\n@testset \"\
    can handle a vector with only one even value\" begin\n    @test pluck([5, 7, 1,\
    \ 2]) == [2, 4]\nend\n@testset \"can handle a vector with multiple even values\"\
    \ begin\n    @test pluck([5, 6, 7, 3, 8, 4]) == [4, 6]\nend\n@testset \"can handle\
    \ a vector with multiple even values of the same value\" begin\n    @test pluck([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: UndefVarError: @testset not defined

    in expression starting at /tmp/tmpj76bi6k2.jl:53

    in expression starting at /tmp/tmpj76bi6k2.jl:53

    '
  stdout: ''
  timestamp: 1660014685
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    ans = [0, 0]\n    for i in eachindex(arr)\n        if (arr[i] % 2 == 0)\
    \ & (ans[1] == 0)\n            ans[1] = arr[i]\n            ans[2] = i\n     \
    \   elseif (arr[i] % 2 == 0) & (arr[i] < ans[1])\n            ans[1] = arr[i]\n\
    \            ans[2] = i\n        end\n    end\n    return ans\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 8 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp52uwpfr4.jl:49

    '
  stdout: "test set: Test Failed at /tmp/tmp52uwpfr4.jl:52\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp52uwpfr4.jl:52 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp52uwpfr4.jl:51\ntest set: Test Failed at /tmp/tmp52uwpfr4.jl:53\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp52uwpfr4.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp52uwpfr4.jl:51\ntest set: Test\
    \ Failed at /tmp/tmp52uwpfr4.jl:54\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [0, 0] == Int64[]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp52uwpfr4.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp52uwpfr4.jl:51\ntest set: Test\
    \ Failed at /tmp/tmp52uwpfr4.jl:55\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [2, 6] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp52uwpfr4.jl:55 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp52uwpfr4.jl:51\ntest set: Test Failed at /tmp/tmp52uwpfr4.jl:56\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/s"
  timestamp: 1660014686
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \"\"\"\n    This function takes a vector of ints and returns a vector\
    \ of the smallest even value and its index.\n    If there are no even values or\
    \ the given vector is empty, return [].\n    \"\"\"\n    if isempty(arr) || length(arr)\
    \ > 10000 || !all(isinteger, arr) || !all(x->x >= 0, arr)\n        return []\n\
    \    end\n    evens = filter(!isodd, arr)\n    if !isempty(evens)\n        return\
    \ [minimum(evens), findfirst(arr, minimum(evens))]\n    else\n        return []\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpnhsep_ms.jl:51

    '
  stdout: "test set: Error During Test at /tmp/tmpnhsep_ms.jl:54\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpnhsep_ms.jl:44\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnhsep_ms.jl:54 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnhsep_ms.jl:53\ntest set:\
    \ Error During Test at /tmp/tmpnhsep_ms.jl:55\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpnhsep_ms.jl:44\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnhsep_ms.jl:55 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnhsep_ms.jl:53\ntest set:\
    \ Error During Test at /tmp/tmpnhsep_ms.jl:57\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014688
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # If the array has no even values or the given vector is empty, return\
    \ nothing.\n    if isempty(arr) || all(x->x%2 != 0, arr)\n        return []\n\
    \    end\n    \n    # Find the minimum even value in the array.\n    smallest_value\
    \ = minimum(arr[arr .% 2 .== 0])\n    \n    # Find the index of the minimum even\
    \ value in the array.\n    smallest_index = findfirst(arr, smallest_value)\n \
    \   \n    # Return the minimum even value and its index.\n    return [smallest_value,\
    \ smallest_index]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpwo7k77b8.jl:51

    '
  stdout: "test set: Error During Test at /tmp/tmpwo7k77b8.jl:54\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpwo7k77b8.jl:44\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpwo7k77b8.jl:54 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpwo7k77b8.jl:53\ntest set:\
    \ Error During Test at /tmp/tmpwo7k77b8.jl:55\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpwo7k77b8.jl:44\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpwo7k77b8.jl:55 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpwo7k77b8.jl:53\ntest set:\
    \ Error During Test at /tmp/tmpwo7k77b8.jl:57\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014688
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = findall(x -> (x % 2 == 0), arr)\n    if !isempty(evens)\n    \
    \    return [minimum(evens), findfirst(arr, minimum(evens))]\n    else\n     \
    \   return []\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpgru2s1_a.jl:44

    '
  stdout: "test set: Error During Test at /tmp/tmpgru2s1_a.jl:47\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpgru2s1_a.jl:37\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpgru2s1_a.jl:47 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpgru2s1_a.jl:46\ntest set:\
    \ Error During Test at /tmp/tmpgru2s1_a.jl:48\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpgru2s1_a.jl:37\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpgru2s1_a.jl:48 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpgru2s1_a.jl:46\ntest set:\
    \ Error During Test at /tmp/tmpgru2s1_a.jl:50\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014688
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # first check the length of the array to \n    #   1) avoid the error\
    \ of calling an empty array\n    #   2) stop the function if the array is empty\n\
    \    if length(arr) == 0\n        return []\n    end\n    @assert length(arr)\
    \ <= 10000\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpbjr1wga5.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpbjr1wga5.jl:1\n\
    in expression starting at /tmp/tmpbjr1wga5.jl:1\n"
  stdout: ''
  timestamp: 1660014685
- exit_code: -1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = filter(x -> (x == 0) || (x % 2 == 0), arr)\n    min_even = minimum(evens)\n\
    \    min_index = minimum(findall(x -> x == min_even, arr))\n    return [min_even,\
    \ min_index]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: Timeout
  stderr: 'ERROR: LoadError: '
  stdout: "test set: Test Failed at /tmp/tmp1lq6k0ul.jl:45\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp1lq6k0ul.jl:45 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp1lq6k0ul.jl:44\ntest set: Test Failed at /tmp/tmp1lq6k0ul.jl:46\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1lq6k0ul.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1lq6k0ul.jl:44\ntest set: Error\
    \ During Test at /tmp/tmp1lq6k0ul.jl:47\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  ArgumentError: reducing\
    \ over an empty collection is not allowed\n  Stacktrace:\n    [1] _empty_reduce_error()\n\
    \      @ Base ./reduce.jl:301\n    [2] reduce_empty(op::Function, #unused#::Type{Int64})\n\
    \      @ Base ./reduce.jl:311\n    [3] mapreduce_empty(#unused#::typeof(identity),\
    \ op::Function, T::Type)\n      @ Base ./reduce.jl:345\n    [4] reduce_empty(op::Base.MappingRF{typeof(identity),\
    \ typeof(min)}, #unused#::Type{Int64})\n      @ Base ./reduce.jl:331\n    [5]\
    \ reduce_empty_iter\n      @ ./reduce.jl:357 [inlined]\n    [6] mapreduce_empty_iter(f::Function,\
    \ op::Function, itr::Vector{Int64}, ItrEltype::Base.HasEltype)\n      @ Base ./reduce.jl:353\n\
    \    [7] _mapreduce\n      @ ./reduce.jl:402 [inlined]\n    [8] _mapreduce_dim\n\
    \      @ ./reducedim.jl:330 [inlined]\n    [9] #mapreduce#731\n      @ ./reducedim.jl:322\
    \ [inlined]\n   [10] mapreduce\n      @ ./reducedim.jl:322 [inlined]\n   [11]\
    \ #_minimum#753\n      @ ./reducedim.jl:894 [inlined]\n   [12] _minimum\n    \
    \  @ ./reducedim.jl:894 [inlined]\n   [13] #_mini"
  timestamp: 1660014689
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    min_even_value = 2\n    min_even_value_pos = 0\n    for i in 1:length(arr)\n\
    \        if (arr[i] < min_even_value) && (arr[i] % 2 == 0)\n            min_even_value\
    \ = arr[i]\n            min_even_value_pos = i\n        end\n    end\n    if min_even_value_pos\
    \ != 0\n        return [min_even_value, min_even_value_pos]\n    else\n      \
    \  return []\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpvgv2zp8t.jl:51

    '
  stdout: "test set: Test Failed at /tmp/tmpvgv2zp8t.jl:54\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpvgv2zp8t.jl:54 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpvgv2zp8t.jl:53\ntest set: Test Failed at /tmp/tmpvgv2zp8t.jl:55\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvgv2zp8t.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvgv2zp8t.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpvgv2zp8t.jl:57\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpvgv2zp8t.jl:57 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpvgv2zp8t.jl:53\ntest set: Test Failed at /tmp/tmpvgv2zp8t.jl:58\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvgv2zp8t.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvgv2zp8t.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpvgv2zp8t.jl:59\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: Int64[] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/"
  timestamp: 1660014687
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n  even_idx = findall(x -> x % 2 == 0, arr)\n  if length(even_idx) == 0\n \
    \   return []\n  end\n  smallest_value = minimum(arr[even_idx])\n  smallest_idx\
    \ = minimum(even_idx)\n  return [smallest_value, smallest_idx]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpfmtf7wio.jl:45

    '
  stdout: "test set: Test Failed at /tmp/tmpfmtf7wio.jl:49\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpfmtf7wio.jl:49 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpfmtf7wio.jl:47\ntest set: Test Failed at /tmp/tmpfmtf7wio.jl:51\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpfmtf7wio.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpfmtf7wio.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpfmtf7wio.jl:52\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 2] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpfmtf7wio.jl:52 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpfmtf7wio.jl:47\ntest set: Test Failed at /tmp/tmpfmtf7wio.jl:53\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpfmtf7wio.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpfmtf7wio.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpfmtf7wio.jl:54\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/"
  timestamp: 1660014687
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code goes here\n    min_even = get_min_even(arr)\n    if min_even\
    \ == -1 \n        return []\n    end\n    return [min_even, minimum(findall(x\
    \ -> x == min_even, arr))]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpjy17eytq.jl:44

    '
  stdout: "test set: Error During Test at /tmp/tmpjy17eytq.jl:47\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  UndefVarError: get_min_even not\
    \ defined\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpjy17eytq.jl:36\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpjy17eytq.jl:47 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpjy17eytq.jl:46\ntest set:\
    \ Error During Test at /tmp/tmpjy17eytq.jl:48\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  UndefVarError: get_min_even not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpjy17eytq.jl:36\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpjy17eytq.jl:48 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpjy17eytq.jl:46\ntest set:\
    \ Error During Test at /tmp/tmpjy17eytq.jl:49\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  UndefVarError: get_min_even\
    \ not defined\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpjy17eytq.jl:36\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpjy17eytq.jl:49 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpjy17eytq.jl:46\ntest set:\
    \ Error During Test at /tmp/tmpjy17eytq.jl:50\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  UndefVarError: get_min_even not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpjy17eytq.jl:36\n\
    \   [2] macro expansion\n     @ ~/.cond"
  timestamp: 1660014688
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    smallest_value = -1\n    smallest_index = -1\n    for i in 1:length(arr)\n\
    \        if (arr[i] % 2 == 0) & (smallest_value == -1)\n            smallest_value\
    \ = arr[i]\n            smallest_index = i\n        elseif (arr[i] % 2 == 0) &\
    \ (arr[i] < smallest_value)\n            smallest_value = arr[i]\n           \
    \ smallest_index = i\n        end\n    end\n    if smallest_value == -1\n    \
    \    return []\n    else\n        return [smallest_value, smallest_index]\n  \
    \  end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpdu1yx0rj.jl:54

    '
  stdout: "test set: Test Failed at /tmp/tmpdu1yx0rj.jl:57\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpdu1yx0rj.jl:57 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpdu1yx0rj.jl:56\ntest set: Test Failed at /tmp/tmpdu1yx0rj.jl:58\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdu1yx0rj.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdu1yx0rj.jl:56\ntest set: Test\
    \ Failed at /tmp/tmpdu1yx0rj.jl:60\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpdu1yx0rj.jl:60 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpdu1yx0rj.jl:56\ntest set: Test Failed at /tmp/tmpdu1yx0rj.jl:61\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdu1yx0rj.jl:61 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdu1yx0rj.jl:56\ntest set: Test\
    \ Failed at /tmp/tmpdu1yx0rj.jl:62\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014687
- exit_code: -1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # If the array is empty return empty vector\n    if isempty(arr)\n   \
    \     return [Int64[]]\n    end\n    min = arr[1]\n    # Find the minimum value\
    \ in the array\n    for i in arr\n        if i < min\n            min = i\n  \
    \      end\n    end\n    # Find the index of the minimum value and return the\
    \ the smallest value and its index\n    return [min, findfirst(x -> x == min,\
    \ arr)]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: Timeout
  stderr: ''
  stdout: "test set: Test Failed at /tmp/tmp61fign4n.jl:54\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp61fign4n.jl:54 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp61fign4n.jl:53\ntest set: Test Failed at /tmp/tmp61fign4n.jl:55\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [1, 1] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp61fign4n.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp61fign4n.jl:53\ntest set: Error\
    \ During Test at /tmp/tmp61fign4n.jl:56\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: Cannot `convert`\
    \ an object of type Vector{Int64} to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at ~/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at ~/.conda/envs/polyglot/share/julia/base/number.jl:6\n\
    \    convert(::Type{T}, !Matched::Number) where T<:Number at ~/.conda/envs/polyglot/share/julia/base/number.jl:7\n\
    \    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64},\
    \ i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64},\
    \ doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base\
    \ ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n \
    \   [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n   \
    \   @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n\
    \    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x:"
  timestamp: 1660014689
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    small_index = 0\n    small_value = 0\n    for (index, value) in enumerate(arr)\n\
    \        if value % 2 == 0\n            if small_value == 0\n                small_value\
    \ = value\n                small_index = index\n            elseif value < small_value\n\
    \                small_value = value\n                small_index = index\n  \
    \          end\n        end\n    end\n    if small_value == 0\n        return\
    \ []\n    else\n        return [small_value, small_index]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpnw_1z9_e.jl:56

    '
  stdout: "test set: Test Failed at /tmp/tmpnw_1z9_e.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpnw_1z9_e.jl:59 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpnw_1z9_e.jl:58\ntest set: Test Failed at /tmp/tmpnw_1z9_e.jl:60\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnw_1z9_e.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnw_1z9_e.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpnw_1z9_e.jl:62\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [2, 6] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpnw_1z9_e.jl:62 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpnw_1z9_e.jl:58\ntest set: Test Failed at /tmp/tmpnw_1z9_e.jl:63\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: Int64[]\
    \ == [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnw_1z9_e.jl:63 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnw_1z9_e.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpnw_1z9_e.jl:64\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Te"
  timestamp: 1660014687
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # checks if the vector is empty\n    if isempty(arr)\n        return Vector{Int64}()\n\
    \    end\n    # gets all even values of the vector\n    even_vals = arr[arr .%\
    \ 2 .== 0]\n    # checks if there is an even values in the vector\n    if isempty(even_vals)\n\
    \        return Vector{Int64}()\n    end\n    # gets the min of the even values\n\
    \    min_val = minimum(even_vals)\n    # gets the index of the min value\n   \
    \ ind = find(arr .== min_val, 1)\n    # returns the two values in a vector\n \
    \   return [min_val, ind]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpfpcxbo_s.jl:54

    '
  stdout: "test set: Error During Test at /tmp/tmpfpcxbo_s.jl:57\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  UndefVarError: find not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpfpcxbo_s.jl:48\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpfpcxbo_s.jl:57 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpfpcxbo_s.jl:56\ntest set:\
    \ Error During Test at /tmp/tmpfpcxbo_s.jl:58\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  UndefVarError: find not defined\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpfpcxbo_s.jl:48\n   [2]\
    \ macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpfpcxbo_s.jl:58 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpfpcxbo_s.jl:56\ntest set:\
    \ Error During Test at /tmp/tmpfpcxbo_s.jl:60\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  UndefVarError: find not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpfpcxbo_s.jl:48\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpfpcxbo_s.jl:60 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpfpcxbo_s.jl:56\ntest set:\
    \ Error During Test at /tmp/tmpfpcxbo_s.jl:61\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n  UndefVarError: find not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpfpcxbo_s.jl:48\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Te"
  timestamp: 1660014688
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \"\"\"\n    Function that plucks the smallest even element from the array\n\
    \    \"\"\"\n    if isempty(arr) #check if the array is empty\n        return\
    \ []\n    end\n    arr_evens = filter(x -> x % 2 == 0, arr) #filter for even values\n\
    \    if isempty(arr_evens) #if no even values are present, return an empty array\n\
    \        return []\n    end\n    min_even = minimum(arr_evens) #get the smallest\
    \ even value\n    index_min_even = findall(arr .== min_even)[1] #find the index\
    \ of the smallest even value\n    return [min_even, index_min_even]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp62wn5btg.jl:51

    '
  stdout: "test set: Test Failed at /tmp/tmp62wn5btg.jl:54\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp62wn5btg.jl:54 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp62wn5btg.jl:53\ntest set: Test Failed at /tmp/tmp62wn5btg.jl:55\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp62wn5btg.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp62wn5btg.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp62wn5btg.jl:57\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp62wn5btg.jl:57 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp62wn5btg.jl:53\ntest set: Test Failed at /tmp/tmp62wn5btg.jl:58\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp62wn5btg.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp62wn5btg.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp62wn5btg.jl:59\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014688
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_indices = findall(x -> rem(x, 2) == 0, arr)\n    even_indices = sort(even_indices)\n\
    \    if isempty(even_indices)\n        return []\n    else\n        even_arr =\
    \ arr[even_indices]\n        index = findfirst(even_arr .== minimum(even_arr))\n\
    \        return [even_arr[index], even_indices[index]]\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpevcqapx0.jl:47

    '
  stdout: "test set: Test Failed at /tmp/tmpevcqapx0.jl:50\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpevcqapx0.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpevcqapx0.jl:49\ntest set: Test Failed at /tmp/tmpevcqapx0.jl:51\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpevcqapx0.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpevcqapx0.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpevcqapx0.jl:53\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpevcqapx0.jl:53 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpevcqapx0.jl:49\ntest set: Test Failed at /tmp/tmpevcqapx0.jl:54\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpevcqapx0.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpevcqapx0.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpevcqapx0.jl:55\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014688
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    arr = arr[arr .%\
    \ 2 .== 0] # filter odd numbers\n    if length(arr) == 0\n        return []\n\
    \    end\n    i = findfirst(arr, minimum(arr))\n    return [arr[i], i]\nend\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp7m5zm5ov.jl:47

    '
  stdout: "test set: Error During Test at /tmp/tmp7m5zm5ov.jl:50\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp7m5zm5ov.jl:42\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp7m5zm5ov.jl:50 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp7m5zm5ov.jl:49\ntest set:\
    \ Error During Test at /tmp/tmp7m5zm5ov.jl:51\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp7m5zm5ov.jl:42\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp7m5zm5ov.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp7m5zm5ov.jl:49\ntest set:\
    \ Error During Test at /tmp/tmp7m5zm5ov.jl:53\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014690
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    if isempty(arr)\n        return []\n    end\n    \n    min_even_value\
    \ = Inf\n    min_even_index = -1\n    \n    for (i, el) in enumerate(arr)\n  \
    \      if iseven(el) && el < min_even_value\n            min_even_value = el\n\
    \            min_even_index = i\n        end\n    end\n    \n    if min_even_index\
    \ == -1\n        return []\n    end\n    \n    return [min_even_value, min_even_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpt3gebrzc.jl:58

    '
  stdout: "test set: Test Failed at /tmp/tmpt3gebrzc.jl:61\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpt3gebrzc.jl:61 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpt3gebrzc.jl:60\ntest set: Test Failed at /tmp/tmpt3gebrzc.jl:62\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpt3gebrzc.jl:62 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpt3gebrzc.jl:60\ntest set: Test\
    \ Failed at /tmp/tmpt3gebrzc.jl:64\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpt3gebrzc.jl:64 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpt3gebrzc.jl:60\ntest set: Test Failed at /tmp/tmpt3gebrzc.jl:65\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpt3gebrzc.jl:65 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpt3gebrzc.jl:60\ntest set: Test\
    \ Failed at /tmp/tmpt3gebrzc.jl:66\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014688
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    n = size(arr)[1]\n    if n == 0\n        return []\n    end\n    min_index\
    \ = 0\n    min_value = 10^8\n    for i = 1:n\n        if arr[i] != 0 && arr[i]\
    \ % 2 == 0 && arr[i] < min_value\n            min_value = arr[i]\n           \
    \ min_index = i\n        end\n    end\n    if min_value == 10^8\n        return\
    \ []\n    end\n    return [min_value, min_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpx109gmh8.jl:54

    '
  stdout: "test set: Test Failed at /tmp/tmpx109gmh8.jl:57\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpx109gmh8.jl:57 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpx109gmh8.jl:56\ntest set: Test Failed at /tmp/tmpx109gmh8.jl:58\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpx109gmh8.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpx109gmh8.jl:56\ntest set: Test\
    \ Failed at /tmp/tmpx109gmh8.jl:60\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [2, 6] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpx109gmh8.jl:60 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpx109gmh8.jl:56\ntest set: Test Failed at /tmp/tmpx109gmh8.jl:61\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [2, 2] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpx109gmh8.jl:61 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpx109gmh8.jl:56\ntest set: Test\
    \ Failed at /tmp/tmpx109gmh8.jl:62\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014689
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    sorted_evens = sort(filter(node -> node % 2 == 0, arr))\n    head(sorted_evens)\
    \ == 0 ? [0, findfirst(arr, 0)] : [head(sorted_evens), findfirst(arr, head(sorted_evens))]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmps7wx5kcx.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmps7wx5kcx.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  UndefVarError: head not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmps7wx5kcx.jl:36\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmps7wx5kcx.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmps7wx5kcx.jl:42\ntest set:\
    \ Error During Test at /tmp/tmps7wx5kcx.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  UndefVarError: head not defined\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmps7wx5kcx.jl:36\n   [2]\
    \ macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmps7wx5kcx.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmps7wx5kcx.jl:42\ntest set:\
    \ Error During Test at /tmp/tmps7wx5kcx.jl:45\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  UndefVarError: head not\
    \ defined\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmps7wx5kcx.jl:36\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmps7wx5kcx.jl:45 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmps7wx5kcx.jl:42\ntest set:\
    \ Error During Test at /tmp/tmps7wx5kcx.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  UndefVarError: head not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmps7wx5kcx.jl:36\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdl"
  timestamp: 1660014690
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    idx = findfirst(iseven,\
    \ arr)\n    if isempty(idx)\n        return []\n    end\n    smallest = arr[idx]\n\
    \    for i in findnext(iseven, arr, idx)\n        if arr[i] < smallest\n     \
    \       smallest = arr[i]\n            idx = i\n        end\n    end\n    return\
    \ [smallest, idx]\nend\n\"\"\"\n    Given a list of strings \"words\" and a letter\
    \ \"letter\",\n    return a list of all the words that contain at least one of\
    \ the letter, \n    and the letter itself is \n    at the beginning of the word.\n\
    \    In addition, the words should be sorted by their length.\n    If no words\
    \ have the given letter at the beginning return an empty list [].\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplilvnj5o.jl:51\nin expression starting at\
    \ /tmp/tmplilvnj5o.jl:51\n"
  stdout: ''
  timestamp: 1660014688
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    small = nothing\n\
    \    place = nothing\n    for i in 1:length(arr)\n        if iseven(arr[i]) &&\
    \ isnothing(small)\n            small = arr[i]\n            place = i\n      \
    \  elseif iseven(arr[i]) && arr[i] < small\n            small = arr[i]\n     \
    \       place = i\n        end\n    end\n    if isnothing(small)\n        return\
    \ []\n    end\n    return [small, place]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpogy_f5rc.jl:56

    '
  stdout: "test set: Test Failed at /tmp/tmpogy_f5rc.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpogy_f5rc.jl:59 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpogy_f5rc.jl:58\ntest set: Test Failed at /tmp/tmpogy_f5rc.jl:60\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpogy_f5rc.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpogy_f5rc.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpogy_f5rc.jl:62\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpogy_f5rc.jl:62 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpogy_f5rc.jl:58\ntest set: Test Failed at /tmp/tmpogy_f5rc.jl:63\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpogy_f5rc.jl:63 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpogy_f5rc.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpogy_f5rc.jl:64\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014689
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # Write your code here!\n    @assert length(arr) <= 10000\n    is_even(x)\
    \ = x % 2 == 0\n    smalest_value = 10001\n    for value in arr\n        @assert\
    \ value >= 0\n        if is_even(value) && value < smalest_value\n           \
    \ smalest_value = value\n        end\n    end\n    isempty(smalest_value) && return\
    \ []\n    index = findall(arr .== smalest_value)[1]\n    return [smalest_value,\
    \ index]\nend\n```\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: invalid \"`\" syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpz3tq50lt.jl:49\nin expression starting at\
    \ /tmp/tmpz3tq50lt.jl:49\n"
  stdout: ''
  timestamp: 1660014688
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n   \n    min_value = 1e9\n    min_index = 1e9\n    for (index,value) in enumerate(arr)\n\
    \        if mod(value,2) == 0\n            if value < min_value\n            \
    \    min_value = value\n                min_index = index\n            end\n \
    \       end\n    end\n    \n    if min_value == 1e9 || min_index == 1e9\n    \
    \    return []\n    else\n        return [min_value, min_index]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpbfegl2mb.jl:55

    '
  stdout: "test set: Test Failed at /tmp/tmpbfegl2mb.jl:58\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpbfegl2mb.jl:58 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpbfegl2mb.jl:57\ntest set: Test Failed at /tmp/tmpbfegl2mb.jl:59\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbfegl2mb.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbfegl2mb.jl:57\ntest set: Test\
    \ Failed at /tmp/tmpbfegl2mb.jl:61\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpbfegl2mb.jl:61 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpbfegl2mb.jl:57\ntest set: Test Failed at /tmp/tmpbfegl2mb.jl:62\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbfegl2mb.jl:62 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbfegl2mb.jl:57\ntest set: Test\
    \ Failed at /tmp/tmpbfegl2mb.jl:63\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014689
- exit_code: -1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    v = filter(x -> x%2 == 0, arr)\n    [minimum(v), argmin(arr, x -> x%2\
    \ == 0)]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: Timeout
  stderr: ''
  stdout: "test set: Error During Test at /tmp/tmp697i0snb.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ iterate(::var\"#2#4\")\n  Closest candidates are:\n    iterate(!Matched::Union{LinRange,\
    \ StepRangeLen}) at ~/.conda/envs/polyglot/share/julia/base/range.jl:826\n   \
    \ iterate(!Matched::Union{LinRange, StepRangeLen}, !Matched::Integer) at ~/.conda/envs/polyglot/share/julia/base/range.jl:826\n\
    \    iterate(!Matched::T) where T<:Union{Base.KeySet{<:Any, <:Dict}, Base.ValueIterator{<:Dict}}\
    \ at ~/.conda/envs/polyglot/share/julia/base/dict.jl:695\n    ...\n  Stacktrace:\n\
    \    [1] _foldl_impl(op::Base.MappingRF{Base.var\"#266#267\"{Vector{Int64}}, Base.BottomRF{typeof(Base._rf_findmin)}},\
    \ init::Base._InitialValue, itr::Function)\n      @ Base ./reduce.jl:56\n    [2]\
    \ foldl_impl(op::Base.MappingRF{Base.var\"#266#267\"{Vector{Int64}}, Base.BottomRF{typeof(Base._rf_findmin)}},\
    \ nt::Base._InitialValue, itr::Function)\n      @ Base ./reduce.jl:48\n    [3]\
    \ mapfoldl_impl(f::Base.var\"#266#267\"{Vector{Int64}}, op::typeof(Base._rf_findmin),\
    \ nt::Base._InitialValue, itr::Function)\n      @ Base ./reduce.jl:44\n    [4]\
    \ #mapfoldl#244\n      @ ./reduce.jl:162 [inlined]\n    [5] mapfoldl\n      @\
    \ ./reduce.jl:162 [inlined]\n    [6] argmin(f::Vector{Int64}, domain::Function)\n\
    \      @ Base ./reduce.jl:965\n    [7] pluck(arr::Vector{Int64})\n      @ Main\
    \ /tmp/tmp697i0snb.jl:36\n    [8] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n    [9] macro expansion\n      @ /tmp/tmp697i0snb.jl:43 [inlined]\n\
    \   [10] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [11] top-level scope\n      @ /tmp/tmp697i0snb.jl:42\ntest set:\
    \ Error During Test at /tmp/tmp697i0snb.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching iterate(::var\"\
    #2#4\")\n  Closest candidates are:\n    iterate(!Matched::Union{LinRange, StepRangeLen})\
    \ at ~/.conda/envs/polyglot/share/julia/base/range.jl:826\n "
  timestamp: 1660014692
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = filter(x ->\
    \ x % 2 == 0, arr)\n    if isempty(even_arr)\n        return []\n    end\n   \
    \ value = minimum(even_arr)\n    idx = argmin(even_arr)\n    return [value, idx]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 6 passed, 2 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpcldn019x.jl:48

    '
  stdout: "test set: Test Failed at /tmp/tmpcldn019x.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpcldn019x.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpcldn019x.jl:50\ntest set: Test Failed at /tmp/tmpcldn019x.jl:55\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 2] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcldn019x.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcldn019x.jl:50\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    6     2      8\n"
  timestamp: 1660014690
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # setup\n    min_index = 10000\n    min_value = 10000\n    # iterate through\
    \ the array\n    for index in 1:length(arr)\n        # check if the element is\
    \ even and less than the current smallest values\n        if mod(arr[index], 2)\
    \ == 0 && arr[index] < min_value\n            # update the smallest values\n \
    \           min_value = arr[index]\n            min_index = index\n        end\n\
    \    end\n    # return empty vector if no even values\n    if min_value == 10000\
    \ && min_index == 10000\n        return []\n    else\n        return [min_value,\
    \ min_index]\n    end\nend\n```\n### Problem 3\n```julia\n\"\"\"\n    \"Given\
    \ a matrix that has non-negative integer values. Your task is to find the smallest\
    \ value in the matrix and return its index.\n    If multiple of the same smallest\
    \ values are found return the index of the one with the smallest row index.\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: parsing command `### Problem 3\n`: special characters\
    \ \"#{}()[]<>|&*?~;\" must be quoted in commands\nStacktrace:\n [1] error(s::String)\n\
    \   @ Base ./error.jl:33\n [2] shell_parse(str::String, interpolate::Bool; special::String,\
    \ filename::String)\n   @ Base ./shell.jl:114\n [3] var\"@cmd\"(__source__::LineNumberNode,\
    \ __module__::Module, str::Any)\n   @ Base ./cmd.jl:442\nin expression starting\
    \ at /tmp/tmpja5ajuyr.jl:54\nin expression starting at /tmp/tmpja5ajuyr.jl:54\n"
  stdout: ''
  timestamp: 1660014689
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    start_index = 1\n   \
    \ end_index = length(arr)\n    mid_index = Int64(ceil(start_index + (end_index\
    \ - start_index)/2))\n    even_index = find_even_index(arr, start_index, end_index,\
    \ mid_index)\n    if even_index == -1\n        return []\n    end\n    even_value\
    \ = arr[even_index]\n    even_index = even_index\n    for i in 1:length(arr)\n\
    \        if arr[i] == even_value && i < even_index\n            even_index = i\n\
    \        end\n    end\n    return [even_value, even_index]\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 7 errored,
    0 broken.

    in expression starting at /tmp/tmpw0ii0a9_.jl:56

    '
  stdout: "test set: Error During Test at /tmp/tmpw0ii0a9_.jl:59\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  UndefVarError: find_even_index\
    \ not defined\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpw0ii0a9_.jl:41\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpw0ii0a9_.jl:59 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpw0ii0a9_.jl:58\ntest set:\
    \ Error During Test at /tmp/tmpw0ii0a9_.jl:60\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  UndefVarError: find_even_index not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpw0ii0a9_.jl:41\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpw0ii0a9_.jl:60 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpw0ii0a9_.jl:58\ntest set:\
    \ Error During Test at /tmp/tmpw0ii0a9_.jl:62\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  UndefVarError: find_even_index not\
    \ defined\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpw0ii0a9_.jl:41\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpw0ii0a9_.jl:62 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpw0ii0a9_.jl:58\ntest set:\
    \ Error During Test at /tmp/tmpw0ii0a9_.jl:63\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n  UndefVarError: find_even_index not\
    \ defined\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpw0ii0a9_.jl:41\n\
    \   [2] macro expansion\n     @ ~/.co"
  timestamp: 1660014691
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # This function will only work on vectors of length 2 or less.\n    if\
    \ isempty(arr)\n        return []\n    elseif length(arr) == 1 && iseven(arr[1])\n\
    \        return [arr[1], 1]\n    elseif length(arr) == 1 && isodd(arr[1])\n  \
    \      return []\n    elseif length(arr) == 2\n        if iseven(arr[1])\n   \
    \         return [arr[1], 1]\n        elseif iseven(arr[2])\n            return\
    \ [arr[2], 2]\n        else\n            return []\n        end\n    end\n   \
    \ \n    # This function will work on vectors of any length.\n    if isempty(arr)\n\
    \        return []\n    elseif length(arr) == 1 && iseven(arr[1])\n        return\
    \ [arr[1], 1]\n    elseif length(arr) == 1 && isodd(arr[1])\n        return []\n\
    \    else\n        even_nums = []\n        for num in arr\n            if iseven(num)\n\
    \                push!(even_nums, num)\n            end\n        end\n       \
    \ # If there are no even numbers, return [].\n        if isempty(even_nums)\n\
    \            return []\n        else\n            even_nums = sort(even_nums)\n\
    \            position = findfirst(x -> x == even_nums[1], arr)\n            return\
    \ [even_nums[1], position]\n        end\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp8guedcey.jl:78

    '
  stdout: "test set: Test Failed at /tmp/tmp8guedcey.jl:81\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp8guedcey.jl:81 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp8guedcey.jl:80\ntest set: Test Failed at /tmp/tmp8guedcey.jl:82\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8guedcey.jl:82 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8guedcey.jl:80\ntest set: Test\
    \ Failed at /tmp/tmp8guedcey.jl:84\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp8guedcey.jl:84 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp8guedcey.jl:80\ntest set: Test Failed at /tmp/tmp8guedcey.jl:85\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8guedcey.jl:85 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8guedcey.jl:80\ntest set: Test\
    \ Failed at /tmp/tmp8guedcey.jl:86\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014690
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr) || !any(isodd, arr)\n        return []\n    end\n    #\
    \ Find smallest even value and its index.\n    i, even_min = findmin(arr)\n  \
    \  if isodd(even_min)\n        even_min = findnext(arr, i, true)\n    end\n  \
    \  # Find smallest odd value and its index.\n    i, odd_min = findmin(arr)\n \
    \   if iseven(odd_min)\n        odd_min = findnext(arr, i, false)\n    end\n \
    \   # Return the smallest even value and its index.\n    # If there is no even\
    \ value, the function will return the odd_min and its index.\n    return [even_min,\
    \ i]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 7 errored,
    0 broken.

    in expression starting at /tmp/tmpbo0uvwot.jl:54

    '
  stdout: "test set: Error During Test at /tmp/tmpbo0uvwot.jl:57\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findnext(::Vector{Int64}, ::Int64, ::Bool)\n  Closest candidates are:\n    findnext(!Matched::Function,\
    \ ::Any, ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1946\n   \
    \ findnext(!Matched::Base.RegexAndMatchData, ::Any, ::Any) at ~/.conda/envs/polyglot/share/julia/base/regex.jl:584\n\
    \    findnext(::Any, ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1862\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpbo0uvwot.jl:46\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbo0uvwot.jl:57 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbo0uvwot.jl:56\ntest set:\
    \ Error During Test at /tmp/tmpbo0uvwot.jl:58\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findnext(::Vector{Int64},\
    \ ::Int64, ::Bool)\n  Closest candidates are:\n    findnext(!Matched::Function,\
    \ ::Any, ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1946\n   \
    \ findnext(!Matched::Base.RegexAndMatchData, ::Any, ::Any) at ~/.conda/envs/polyglot/share/julia/base/regex.jl:584\n\
    \    findnext(::Any, ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1862\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpbo0uvwot.jl:41\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbo0uvwot.jl:58 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbo0uvwot.jl:56\ntest set:\
    \ Error During Test at /tmp/tmpbo0uvwot.jl:60\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodErr"
  timestamp: 1660014692
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr) || all(x->x%2!=0, arr)\n        return []\n    end\n \
    \   evens = [evens(x, arr) for x in 1:length(arr)]\n    smallest_even = minimum(evens)\n\
    \    ind = findfirst(eq(smallest_even), evens)\n    return [smallest_even, ind]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpym5_wsaw.jl:45

    '
  stdout: "test set: Error During Test at /tmp/tmpym5_wsaw.jl:48\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  UndefVarError: evens not defined\n\
    \  Stacktrace:\n   [1] (::var\"#2#4\"{Vector{Int64}})(x::Int64)\n     @ Main ./none:0\n\
    \   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3] collect(itr::Base.Generator{UnitRange{Int64},\
    \ var\"#2#4\"{Vector{Int64}}})\n     @ Base ./array.jl:724\n   [4] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpym5_wsaw.jl:38\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpym5_wsaw.jl:48 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpym5_wsaw.jl:47\ntest set:\
    \ Error During Test at /tmp/tmpym5_wsaw.jl:49\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  UndefVarError: evens not defined\n  Stacktrace:\n\
    \   [1] (::var\"#2#4\"{Vector{Int64}})(x::Int64)\n     @ Main ./none:0\n   [2]\
    \ iterate\n     @ ./generator.jl:47 [inlined]\n   [3] collect(itr::Base.Generator{UnitRange{Int64},\
    \ var\"#2#4\"{Vector{Int64}}})\n     @ Base ./array.jl:724\n   [4] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpym5_wsaw.jl:38\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpym5_wsaw.jl:49 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpym5_wsaw.jl:47\ntest set:\
    \ Error During Test at /tmp/tmpym5_wsaw.jl:51\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  UndefVarError: evens not defined\n\
    \  Stacktrace:\n   [1] (::var\"#2#4\"{Vector{Int64}})(x::Int64)\n     @ Main ./none:0\n\
    \   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3] collect(itr::Base.Generator{UnitRange{Int64},\
    \ var\"#2#4\"{Vector{Int64}}})\n     @ Base ./array.jl:724\n   [4] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tm"
  timestamp: 1660014691
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    empty!(result)\n    if arr == []\n        return []\n    end\n    n =\
    \ size(arr, 1)\n    result = [NaN, NaN]\n    for i in 1:n\n        if iseven(arr[i])\
    \ && (isnan(result[1]) || arr[i] < result[1])\n            result = [arr[i], i]\n\
    \        end\n    end\n    if isnan(result[1])\n        empty!(result)\n    end\n\
    \    return result\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpuv2zdal2.jl:53

    '
  stdout: "test set: Error During Test at /tmp/tmpuv2zdal2.jl:56\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  UndefVarError: result not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpuv2zdal2.jl:35\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpuv2zdal2.jl:56 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpuv2zdal2.jl:55\ntest set:\
    \ Error During Test at /tmp/tmpuv2zdal2.jl:57\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  UndefVarError: result not defined\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpuv2zdal2.jl:35\n   [2]\
    \ macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpuv2zdal2.jl:57 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpuv2zdal2.jl:55\ntest set:\
    \ Error During Test at /tmp/tmpuv2zdal2.jl:58\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  UndefVarError: result not\
    \ defined\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpuv2zdal2.jl:35\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpuv2zdal2.jl:58 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpuv2zdal2.jl:55\ntest set:\
    \ Error During Test at /tmp/tmpuv2zdal2.jl:59\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  UndefVarError: result not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpuv2zdal2.jl:35\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/ju"
  timestamp: 1660014691
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    filtered = filter(x -> x % 2 == 0, arr)\n    if isempty(filtered)\n  \
    \      return []\n    end\n    minimum_value = minimum(filtered)\n    index =\
    \ findfirst(arr, minimum_value)\n    return [minimum_value, index]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpp7ctoss4.jl:45

    '
  stdout: "test set: Error During Test at /tmp/tmpp7ctoss4.jl:48\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpp7ctoss4.jl:40\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpp7ctoss4.jl:48 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpp7ctoss4.jl:47\ntest set:\
    \ Error During Test at /tmp/tmpp7ctoss4.jl:49\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpp7ctoss4.jl:40\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpp7ctoss4.jl:49 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpp7ctoss4.jl:47\ntest set:\
    \ Error During Test at /tmp/tmpp7ctoss4.jl:51\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014692
- exit_code: -1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    smalest_even_value, its_index = nothing, nothing\n    for index in 1:length(arr)\n\
    \        if arr[index] % 2 == 0 && arr[index] < smalest_even_value\n         \
    \   smalest_even_value, its_index = arr[index], index\n        end\n    end\n\
    \    if smalest_even_value == nothing\n        return []\n    else\n        return\
    \ [smalest_even_value, its_index]\n    end\nend\nprintln(pluck([4, 2, 3]))\nprintln(pluck([1,\
    \ 2, 3]))\nprintln(pluck([]))\nprintln(pluck([5, 0, 3, 0, 4, 2]))\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: Timeout
  stderr: "ERROR: LoadError: MethodError: no method matching isless(::Int64, ::Nothing)\n\
    Closest candidates are:\n  isless(::Real, !Matched::AbstractFloat) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:185\n\
    \  isless(::Real, !Matched::Real) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:430\n\
    \  isless(::Any, !Matched::Missing) at ~/.conda/envs/polyglot/share/julia/base/missing.jl:88\n\
    \  ...\nStacktrace:\n [1] <("
  stdout: ''
  timestamp: 1660014693
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # check if arr is empty, then return empty vector\n    if isempty(arr)\n\
    \        return []\n    end\n    # loop over arr to check if there is an even\
    \ number\n    for i in 1:length(arr)\n        # if there is an even number, check\
    \ if it is even\n        if i % 2 == 0\n            return [i, findfirst(arr,\
    \ i)]\n        end\n    end\n    # else return empty vector\n    return []\nend\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 7 errored,
    0 broken.

    in expression starting at /tmp/tmpsx8_ijkd.jl:51

    '
  stdout: "test set: Error During Test at /tmp/tmpsx8_ijkd.jl:54\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpsx8_ijkd.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpsx8_ijkd.jl:54 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpsx8_ijkd.jl:53\ntest set:\
    \ Error During Test at /tmp/tmpsx8_ijkd.jl:55\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpsx8_ijkd.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpsx8_ijkd.jl:55 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpsx8_ijkd.jl:53\ntest set:\
    \ Error During Test at /tmp/tmpsx8_ijkd.jl:57\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014693
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    min_even_value = 999999\n\
    \    min_even_index = -1\n    for (i, x) in enumerate(arr)\n        if x % 2 ==\
    \ 0\n            if x < min_even_value\n                min_even_value = x\n \
    \               min_even_index = i\n            end\n        end\n    end\n  \
    \  if min_even_index == -1\n        return []\n    end\n    return [min_even_value,\
    \ min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp9_3xeaf9.jl:55

    '
  stdout: "test set: Test Failed at /tmp/tmp9_3xeaf9.jl:58\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp9_3xeaf9.jl:58 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp9_3xeaf9.jl:57\ntest set: Test Failed at /tmp/tmp9_3xeaf9.jl:59\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9_3xeaf9.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9_3xeaf9.jl:57\ntest set: Test\
    \ Failed at /tmp/tmp9_3xeaf9.jl:61\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp9_3xeaf9.jl:61 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp9_3xeaf9.jl:57\ntest set: Test Failed at /tmp/tmp9_3xeaf9.jl:62\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9_3xeaf9.jl:62 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9_3xeaf9.jl:57\ntest set: Test\
    \ Failed at /tmp/tmp9_3xeaf9.jl:63\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014691
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    # if the array is empty, return an empty array\n    if length(arr)\
    \ == 0\n        return []\n    end\n    \n    # find the first even number \n\
    \    for i in eachindex(arr)\n        if arr[i] % 2 == 0\n            return [arr[i],\
    \ i]\n        end\n    end\n    \n    # there were no even numbers, return an\
    \ empty array\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpjtsplnhp.jl:53

    '
  stdout: "test set: Test Failed at /tmp/tmpjtsplnhp.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [4, 1] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpjtsplnhp.jl:56 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpjtsplnhp.jl:55\ntest set: Test Failed at /tmp/tmpjtsplnhp.jl:57\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjtsplnhp.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjtsplnhp.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpjtsplnhp.jl:59\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpjtsplnhp.jl:59 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpjtsplnhp.jl:55\ntest set: Test Failed at /tmp/tmpjtsplnhp.jl:60\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [2, 2] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjtsplnhp.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjtsplnhp.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpjtsplnhp.jl:61\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014691
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    vals = [x for x in arr if x % 2 == 0]\n    if isempty(vals) return []\
    \ end\n    minval = minimum(vals)\n    minindex = findfirst(arr, minval)\n   \
    \ return [minval, minindex]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpncvkj4_e.jl:43

    '
  stdout: "test set: Error During Test at /tmp/tmpncvkj4_e.jl:46\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpncvkj4_e.jl:38\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpncvkj4_e.jl:46 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpncvkj4_e.jl:45\ntest set:\
    \ Error During Test at /tmp/tmpncvkj4_e.jl:47\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpncvkj4_e.jl:38\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpncvkj4_e.jl:47 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpncvkj4_e.jl:45\ntest set:\
    \ Error During Test at /tmp/tmpncvkj4_e.jl:49\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014693
- exit_code: -1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return Int64[]\n    end\n    smallest_even =\
    \ 0\n    for i in arr\n        if i % 2 == 0\n            smallest_even = i\n\
    \            break\n        end\n    end\n    if smallest_even == 0\n        return\
    \ Int64[]\n    end\n    idx = findfirst(arr, smallest_even)\n    return [smallest_even,\
    \ idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: Timeout
  stderr: ''
  stdout: "test set: Error During Test at /tmp/tmplg0a_u3n.jl:56\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmplg0a_u3n.jl:48\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmplg0a_u3n.jl:56 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmplg0a_u3n.jl:55\ntest set:\
    \ Error During Test at /tmp/tmplg0a_u3n.jl:57\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmplg0a_u3n.jl:48\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmplg0a_u3n.jl:57 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmplg0a_u3n.jl:55\ntest set:\
    \ Test Failed at /tmp/tmplg0a_u3n.jl:59\n  Expression: candidate([5, 0, 3, 0,\
    \ 4, 2]) == [0, 1]\n   Evaluated: Int64[] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2]"
  timestamp: 1660014693
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n  evens = filter(arr) do x\n    x % 2 == 0\n  end\n  indices = findall(arr\
    \ .== minimum(evens))\n  if (length(indices) == 0)\n    return []\n  end\n  minimum(indices)\n\
    \  return [arr[minimum(indices)], minimum(indices)]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 2 errored,
    0 broken.

    in expression starting at /tmp/tmpv06t8zm5.jl:47

    '
  stdout: "test set: Test Failed at /tmp/tmpv06t8zm5.jl:50\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpv06t8zm5.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpv06t8zm5.jl:49\ntest set: Test Failed at /tmp/tmpv06t8zm5.jl:51\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpv06t8zm5.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpv06t8zm5.jl:49\ntest set: Error\
    \ During Test at /tmp/tmpv06t8zm5.jl:52\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  ArgumentError: reducing\
    \ over an empty collection is not allowed\n  Stacktrace:\n    [1] _empty_reduce_error()\n\
    \      @ Base ./reduce.jl:301\n    [2] reduce_empty(op::Function, #unused#::Type{Int64})\n\
    \      @ Base ./reduce.jl:311\n    [3] mapreduce_empty(#unused#::typeof(identity),\
    \ op::Function, T::Type)\n      @ Base ./reduce.jl:345\n    [4] reduce_empty(op::Base.MappingRF{typeof(identity),\
    \ typeof(min)}, #unused#::Type{Int64})\n      @ Base ./reduce.jl:331\n    [5]\
    \ reduce_empty_iter\n      @ ./reduce.jl:357 [inlined]\n    [6] mapreduce_empty_iter(f::Function,\
    \ op::Function, itr::Vector{Int64}, ItrEltype::Base.HasEltype)\n      @ Base ./reduce.jl:353\n\
    \    [7] _mapreduce\n      @ ./reduce.jl:402 [inlined]\n    [8] _mapreduce_dim\n\
    \      @ ./reducedim.jl:330 [inlined]\n    [9] #mapreduce#731\n      @ ./reducedim.jl:322\
    \ [inlined]\n   [10] mapreduce\n      @ ./reducedim.jl:322 [inlined]\n   [11]\
    \ #_minimum#753\n      @ ./reducedim.jl:894 [inlined]\n   [12] _minimum\n    \
    \  @ ./reducedim.jl:894 [inlined]\n   [13] #_mini"
  timestamp: 1660014693
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    p = []\n    for (ind,x) in enumerate(arr)\n        if x % 2 == 0\n   \
    \         push!(p, [x, ind])\n        end\n    end\n    if !isempty(p)\n     \
    \   min_arr = p[1]\n        for i in 2:length(p)\n            if p[i][1] < min_arr[1]\n\
    \                min_arr = p[i]\n            end\n        end\n        return\
    \ min_arr\n    else\n        return []\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpvthe4lro.jl:55

    '
  stdout: "test set: Test Failed at /tmp/tmpvthe4lro.jl:58\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpvthe4lro.jl:58 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpvthe4lro.jl:57\ntest set: Test Failed at /tmp/tmpvthe4lro.jl:59\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvthe4lro.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvthe4lro.jl:57\ntest set: Test\
    \ Failed at /tmp/tmpvthe4lro.jl:61\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpvthe4lro.jl:61 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpvthe4lro.jl:57\ntest set: Test Failed at /tmp/tmpvthe4lro.jl:62\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvthe4lro.jl:62 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvthe4lro.jl:57\ntest set: Test\
    \ Failed at /tmp/tmpvthe4lro.jl:63\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014691
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n  evens = [x for x in arr if x % 2 == 0]\n  if (isempty(evens))\n    return\
    \ []\n  end\n  idx = findfirst(arr .== minimum(evens))\n  return [arr[idx], idx]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp_z2z7gfi.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmp_z2z7gfi.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp_z2z7gfi.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp_z2z7gfi.jl:46\ntest set: Test Failed at /tmp/tmp_z2z7gfi.jl:48\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_z2z7gfi.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_z2z7gfi.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp_z2z7gfi.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp_z2z7gfi.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp_z2z7gfi.jl:46\ntest set: Test Failed at /tmp/tmp_z2z7gfi.jl:51\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_z2z7gfi.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_z2z7gfi.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp_z2z7gfi.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014692
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # ========\n    # 1. PREAMBLE:\n    # ========\n    if isempty(arr)\n\
    \        return []\n    end\n    # ========\n    # 2. MAIN:\n    # ========\n\
    \    evenArr = arr[isodd.(arr).==false] # all even nodes\n    if isempty(evenArr)\n\
    \        return []\n    end\n    idx = findmin(evenArr)[2]\n    return [evenArr[idx],\
    \ idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 6 passed, 2 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp1gh6tfvl.jl:53

    '
  stdout: "test set: Test Failed at /tmp/tmp1gh6tfvl.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp1gh6tfvl.jl:56 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp1gh6tfvl.jl:55\ntest set: Test Failed at /tmp/tmp1gh6tfvl.jl:60\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 2] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1gh6tfvl.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1gh6tfvl.jl:55\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    6     2      8\n"
  timestamp: 1660014692
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \"\"\"\n    The function should take an array of non-negative integers\
    \ and return a vector with two elements,\n    The first element is the smallest\
    \ even value in the vector, if there is no even values return 0\n    The second\
    \ element is the index of the smallest even value in the vector, if there is no\
    \ even values return 0\n    \"\"\"\n    # First, we initialize a tuple with a\
    \ 0 as the first element and a 0 as the second element\n    minimum_even_value_and_index\
    \ = (0, 0)\n    # Then we loop through the array, checking if each element is\
    \ even, \n    # and if it is we see if the element is smaller than the one in\
    \ the tuple,\n    # if it is we change the tuple to contain the new minimum and\
    \ index\n    for (index, element) in enumerate(arr)\n        if iseven(element)\n\
    \            if element < minimum_even_value_and_index[1]\n                minimum_even_value_and_index\
    \ = (element, index)\n            end\n        end\n    end\n    # Finally, we\
    \ return a vector with the elements of the tuple,\n    # but we subtract one from\
    \ the index, since it is a vector index\n    return [minimum_even_value_and_index[1],\
    \ minimum_even_value_and_index[2] - 1]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 8 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpw2jnbipk.jl:58

    '
  stdout: "test set: Test Failed at /tmp/tmpw2jnbipk.jl:61\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [0, -1] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpw2jnbipk.jl:61 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpw2jnbipk.jl:60\ntest set: Test Failed at /tmp/tmpw2jnbipk.jl:62\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [0, -1] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpw2jnbipk.jl:62 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpw2jnbipk.jl:60\ntest set: Test\
    \ Failed at /tmp/tmpw2jnbipk.jl:63\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [0, -1] == Int64[]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpw2jnbipk.jl:63 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpw2jnbipk.jl:60\ntest set: Test\
    \ Failed at /tmp/tmpw2jnbipk.jl:64\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, -1] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpw2jnbipk.jl:64 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpw2jnbipk.jl:60\ntest set: Test Failed at /tmp/tmpw2jnbipk.jl:65\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, -1]\
    \ == [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/ju"
  timestamp: 1660014692
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return [0, 0]\n    end\n    s = sort(arr, rev=true)\n\
    \    pos = -1\n    for i in eachindex(s)\n        if rem(s[i], 2) == 0\n     \
    \       pos = i\n            break\n        end\n    end\n    if pos == -1\n \
    \       return [0, 0]\n    end\n    for j in pos:length(s)\n        if s[j] <\
    \ s[pos]\n            pos = j\n        end\n    end\n    res = [s[pos], search(arr,\
    \ s[pos])]\n    return res\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 2 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpdaazs7j1.jl:59

    '
  stdout: "test set: Error During Test at /tmp/tmpdaazs7j1.jl:62\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  UndefVarError: search not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpdaazs7j1.jl:54\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpdaazs7j1.jl:62 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpdaazs7j1.jl:61\ntest set:\
    \ Error During Test at /tmp/tmpdaazs7j1.jl:63\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  UndefVarError: search not defined\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpdaazs7j1.jl:54\n   [2]\
    \ macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpdaazs7j1.jl:63 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpdaazs7j1.jl:61\ntest set:\
    \ Test Failed at /tmp/tmpdaazs7j1.jl:64\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [0, 0] == Int64[]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdaazs7j1.jl:64 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdaazs7j1.jl:61\ntest set: Error\
    \ During Test at /tmp/tmpdaazs7j1.jl:65\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  UndefVarError: search not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpdaazs7j1.jl:54\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpdaazs7j1.jl:65 [inlined]\n\
    \   [4] ma"
  timestamp: 1660014694
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n  \"\"\"\n  This function takes in a vector of integers and returns the smallest\
    \ even number in the vector and its index in a new vector.\n  \"\"\"\n  if length(arr)\
    \ == 0\n    return Vector{Int64}()\n  end\n  sorted_arr = sort(arr)\n  for x in\
    \ sorted_arr\n    if x % 2 == 0\n      return [x, indmax(arr .== x)]\n    end\n\
    \  end\n  return []\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp8rflsns5.jl:51

    '
  stdout: "test set: Error During Test at /tmp/tmp8rflsns5.jl:54\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  UndefVarError: indmax not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp8rflsns5.jl:44\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp8rflsns5.jl:54 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp8rflsns5.jl:53\ntest set:\
    \ Error During Test at /tmp/tmp8rflsns5.jl:55\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  UndefVarError: indmax not defined\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp8rflsns5.jl:44\n   [2]\
    \ macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp8rflsns5.jl:55 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp8rflsns5.jl:53\ntest set:\
    \ Error During Test at /tmp/tmp8rflsns5.jl:57\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  UndefVarError: indmax not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp8rflsns5.jl:44\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp8rflsns5.jl:57 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp8rflsns5.jl:53\ntest set:\
    \ Error During Test at /tmp/tmp8rflsns5.jl:58\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n  UndefVarError: indmax not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp8rflsns5.jl:44\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib"
  timestamp: 1660014693
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    sm_idx, sm_val = 0, 0\n    if !isempty(arr)\n        if length(arr) ==\
    \ 1\n            if arr[1] % 2 == 0\n                sm_idx, sm_val = 1, arr[1]\n\
    \            end\n        else\n            sm_idx, sm_val = findmin(arr)\n  \
    \          for i in 1:length(arr)\n                if arr[i] % 2 == 0 && arr[i]\
    \ < sm_val\n                    sm_idx, sm_val = i, arr[i]\n                end\n\
    \            end\n        end\n    end\n    return [sm_val, sm_idx]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 8 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpyii3b_8l.jl:54

    '
  stdout: "test set: Test Failed at /tmp/tmpyii3b_8l.jl:57\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpyii3b_8l.jl:57 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpyii3b_8l.jl:56\ntest set: Test Failed at /tmp/tmpyii3b_8l.jl:58\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [1, 1] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyii3b_8l.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyii3b_8l.jl:56\ntest set: Test\
    \ Failed at /tmp/tmpyii3b_8l.jl:59\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [0, 0] == Int64[]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyii3b_8l.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyii3b_8l.jl:56\ntest set: Test\
    \ Failed at /tmp/tmpyii3b_8l.jl:60\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpyii3b_8l.jl:60 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpyii3b_8l.jl:56\ntest set: Test Failed at /tmp/tmpyii3b_8l.jl:61\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/s"
  timestamp: 1660014693
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \"\"\"\n    Use the filter function to filter out the even numbers and\
    \ store them in a variable.\n    If the variable is empty, return an empty vector.\n\
    \    If the variable is not empty, call min(evens) to get the smallest even number.\n\
    \    Use the findfirst function to get the index of the smallest even number\n\
    \    and return [smallest even number, index]\n    \"\"\"\n    # your code here\n\
    \    nothing\nend\n \n \n@test pluck([4, 2, 3]) == [2, 1]\n@test pluck([1, 2,\
    \ 3]) == [2, 1]\n@test pluck([]) == []\n@test pluck([5, 0, 3, 0, 4, 2]) == [0,\
    \ 1]\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n\"\"\"\n\U0001F989 Sabrina\n\"\"\"\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: UndefVarError: @test not defined

    in expression starting at /tmp/tmpcg__ovqf.jl:47

    in expression starting at /tmp/tmpcg__ovqf.jl:47

    '
  stdout: ''
  timestamp: 1660014691
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even = []\n    for i in 1:length(arr)\n        if rem(arr[i], 2) == 0\n\
    \            push!(even, [arr[i], i])\n        end\n    end\n    if length(even)\
    \ == 0\n        return []\n    else\n        least = even[1][1]\n        least_index\
    \ = 1\n        for i in 2:length(even)\n            if even[i][1] < least\n  \
    \              least = even[i][1]\n                least_index = i\n         \
    \   end\n        end\n        return even[least_index]\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmprmuth6zy.jl:57

    '
  stdout: "test set: Test Failed at /tmp/tmprmuth6zy.jl:60\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmprmuth6zy.jl:60 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmprmuth6zy.jl:59\ntest set: Test Failed at /tmp/tmprmuth6zy.jl:61\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmprmuth6zy.jl:61 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprmuth6zy.jl:59\ntest set: Test\
    \ Failed at /tmp/tmprmuth6zy.jl:63\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmprmuth6zy.jl:63 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmprmuth6zy.jl:59\ntest set: Test Failed at /tmp/tmprmuth6zy.jl:64\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmprmuth6zy.jl:64 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprmuth6zy.jl:59\ntest set: Test\
    \ Failed at /tmp/tmprmuth6zy.jl:65\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014693
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    min = 10000\n    for i in arr\n        if mod(i, 2) == 0 && i <= min\n\
    \            min = i\n        end\n    end\n    [min, findall(arr .== min)[1]]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 2 errored,
    0 broken.

    in expression starting at /tmp/tmp3equyc_m.jl:45

    '
  stdout: "test set: Test Failed at /tmp/tmp3equyc_m.jl:48\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp3equyc_m.jl:48 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp3equyc_m.jl:47\ntest set: Test Failed at /tmp/tmp3equyc_m.jl:49\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3equyc_m.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3equyc_m.jl:47\ntest set: Error\
    \ During Test at /tmp/tmp3equyc_m.jl:50\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError: attempt to\
    \ access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1] getindex\n\
    \     @ ./array.jl:861 [inlined]\n   [2] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmp3equyc_m.jl:41\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp3equyc_m.jl:50 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp3equyc_m.jl:47\ntest set:\
    \ Test Failed at /tmp/tmp3equyc_m.jl:51\n  Expression: candidate([5, 0, 3, 0,\
    \ 4, 2]) == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp3equyc_m.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp3equyc_m.jl:47\ntest s"
  timestamp: 1660014695
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if (length(arr) == 0)\n        return []\n    end\n    min_val = 10001\n\
    \    min_idx = 10001\n    for (index, val) in enumerate(arr)\n        if (val\
    \ < min_val && val % 2 == 0)\n            min_val = val\n            min_idx =\
    \ index\n        end\n    end\n    if (min_val < 10001)\n        return [min_val,\
    \ min_idx + 1]\n    else\n        return []\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp6tjdqdyz.jl:54

    '
  stdout: "test set: Test Failed at /tmp/tmp6tjdqdyz.jl:57\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 3] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp6tjdqdyz.jl:57 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp6tjdqdyz.jl:56\ntest set: Test Failed at /tmp/tmp6tjdqdyz.jl:58\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 3] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6tjdqdyz.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6tjdqdyz.jl:56\ntest set: Test\
    \ Failed at /tmp/tmp6tjdqdyz.jl:60\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 3] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp6tjdqdyz.jl:60 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp6tjdqdyz.jl:56\ntest set: Test Failed at /tmp/tmp6tjdqdyz.jl:61\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 5] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6tjdqdyz.jl:61 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6tjdqdyz.jl:56\ntest set: Test\
    \ Failed at /tmp/tmp6tjdqdyz.jl:62\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 3] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014694
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = findall(x -> x % 2 == 0, arr)\n    if isempty(evens)\n       \
    \ return Vector{Int64}()\n    end\n    min_index = findfirst(evens .== minimum(evens))\n\
    \    return [minimum(evens), min_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpvs1acfix.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmpvs1acfix.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [1, 1] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpvs1acfix.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpvs1acfix.jl:46\ntest set: Test Failed at /tmp/tmpvs1acfix.jl:50\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [2, 1] ==\
    \ [0, 1]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvs1acfix.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvs1acfix.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpvs1acfix.jl:51\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [2, 1] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpvs1acfix.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpvs1acfix.jl:46\ntest set: Test Failed at /tmp/tmpvs1acfix.jl:52\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [2, 1] == [4,\
    \ 1]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvs1acfix.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvs1acfix.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpvs1acfix.jl:53\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [2, 1] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/"
  timestamp: 1660014694
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # filter out even values\n    evens = [x for x in arr if iseven(x)]\n\
    \    # sort the even values\n    sort!(evens)\n    # return the smallest even\
    \ value with the smallest index\n    if evens == []\n        return []\n    else\n\
    \        sorted_arr = sort(arr)\n        return [evens[1], findfirst(x -> x ==\
    \ evens[1], sorted_arr)]\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 5 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp8lxrok6_.jl:49

    '
  stdout: "test set: Test Failed at /tmp/tmp8lxrok6_.jl:53\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp8lxrok6_.jl:53 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp8lxrok6_.jl:51\ntest set: Test Failed at /tmp/tmp8lxrok6_.jl:56\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 1] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8lxrok6_.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8lxrok6_.jl:51\ntest set: Test\
    \ Failed at /tmp/tmp8lxrok6_.jl:58\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp8lxrok6_.jl:58 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp8lxrok6_.jl:51\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    5     3      8\n"
  timestamp: 1660014694
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # If the vector is empty, return empty array\n    if size(arr, 1) == 0\n\
    \        return []\n    end\n    \n    # Find the min value of even values\n \
    \   min_val = minimum(filter(x -> x % 2 == 0, arr))\n    \n    # Find the indices\
    \ of the even values\n    even_indices = findall(arr .% 2 .== 0)\n    \n    #\
    \ Find the index of the minimum value\n    min_index = findfirst(arr[even_indices]\
    \ .== min_val)\n    \n    # Return the min value and min index\n    return [min_val,\
    \ even_indices[min_index]]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 6 failed, 1 errored,
    0 broken.

    in expression starting at /tmp/tmp6ifzhav_.jl:54

    '
  stdout: "test set: Test Failed at /tmp/tmp6ifzhav_.jl:57\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp6ifzhav_.jl:57 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp6ifzhav_.jl:56\ntest set: Test Failed at /tmp/tmp6ifzhav_.jl:58\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6ifzhav_.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6ifzhav_.jl:56\ntest set: Test\
    \ Failed at /tmp/tmp6ifzhav_.jl:60\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp6ifzhav_.jl:60 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp6ifzhav_.jl:56\ntest set: Test Failed at /tmp/tmp6ifzhav_.jl:61\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6ifzhav_.jl:61 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6ifzhav_.jl:56\ntest set: Test\
    \ Failed at /tmp/tmp6ifzhav_.jl:62\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014696
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\n    if length(arr) == 0\n        return []\n    end\n\
    \    min_even = 10^9\n    min_index = 10^9\n    for i = 1:length(arr)\n      \
    \  if mod(arr[i], 2) == 0\n            if arr[i] < min_even\n                min_even\
    \ = arr[i]\n                min_index = i\n            end\n        end\n    end\n\
    \    if min_even == 10^9\n        return []\n    end\n    return [min_even, min_index]\n\
    end\n \n@testset \"Test Cases\" begin\n    @test pluck([4, 2, 3]) == [2, 1]\n\
    \    @test pluck([1, 2, 3]) == [2, 1]\n    @test pluck([]) == []\n    @test pluck([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: UndefVarError: @testset not defined

    in expression starting at /tmp/tmps0j89azs.jl:55

    in expression starting at /tmp/tmps0j89azs.jl:55

    '
  stdout: ''
  timestamp: 1660014693
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \"\"\"\n    This function returns the node in the arr (the tree) with\
    \ the smallest even value.\n    If there are two nodes with the same smallest\
    \ even value, it will choose the one \n    with the smallest index.\n    \"\"\"\
    \n    if length(arr) == 0 || all(elem % 2 != 0 for elem in arr)\n        return\
    \ []\n    end\n    evens = Int64[]\n    for i in 1:length(arr)\n        if arr[i]\
    \ % 2 == 0\n            push!(evens, arr[i])\n        end\n    end\n    min_index\
    \ = findfirst(arr, minimum(evens))\n    return [arr[min_index], min_index]\nend\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpseuq74yq.jl:54

    '
  stdout: "test set: Error During Test at /tmp/tmpseuq74yq.jl:57\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpseuq74yq.jl:49\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpseuq74yq.jl:57 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpseuq74yq.jl:56\ntest set:\
    \ Error During Test at /tmp/tmpseuq74yq.jl:58\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpseuq74yq.jl:49\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpseuq74yq.jl:58 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpseuq74yq.jl:56\ntest set:\
    \ Error During Test at /tmp/tmpseuq74yq.jl:60\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014696
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    smallest_value = Int64[]\n    for i in 1:length(arr)\n        if rem(arr[i],\
    \ 2) == 0\n            push!(smallest_value, i)\n        end\n    end\n    if\
    \ smallest_value == Int64[]\n        return []\n    else\n        smallest_value_index\
    \ = findmin(arr[smallest_value])[2]\n        smallest_value_index = smallest_value[smallest_value_index]\n\
    \        return [arr[smallest_value_index], smallest_value_index]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp75b6pk4y.jl:51

    '
  stdout: "test set: Test Failed at /tmp/tmp75b6pk4y.jl:54\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp75b6pk4y.jl:54 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp75b6pk4y.jl:53\ntest set: Test Failed at /tmp/tmp75b6pk4y.jl:55\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp75b6pk4y.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp75b6pk4y.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp75b6pk4y.jl:57\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp75b6pk4y.jl:57 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp75b6pk4y.jl:53\ntest set: Test Failed at /tmp/tmp75b6pk4y.jl:58\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp75b6pk4y.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp75b6pk4y.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp75b6pk4y.jl:59\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014694
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    smallest = 0 \n    index = 0\n    is_empty = true\n    for i in eachindex(arr)\n\
    \        if iseven(arr[i]) && (arr[i] < smallest || is_empty)\n            is_empty\
    \ = false\n            smallest = arr[i]\n            index = i\n        end\n\
    \    end\n    if is_empty\n        return []\n    else\n        return [smallest,\
    \ index]\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp34gm0s8g.jl:53

    '
  stdout: "test set: Test Failed at /tmp/tmp34gm0s8g.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp34gm0s8g.jl:56 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp34gm0s8g.jl:55\ntest set: Test Failed at /tmp/tmp34gm0s8g.jl:57\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp34gm0s8g.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp34gm0s8g.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp34gm0s8g.jl:59\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp34gm0s8g.jl:59 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp34gm0s8g.jl:55\ntest set: Test Failed at /tmp/tmp34gm0s8g.jl:60\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp34gm0s8g.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp34gm0s8g.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp34gm0s8g.jl:61\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014695
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # get min of even elements in arr\n    eve = nothing\n    for el in arr\n\
    \        if el % 2 == 0\n            if isnothing(eve) || el < eve\n         \
    \       eve = el\n            end\n        end\n    end\n    if isnothing(eve)\n\
    \        return []\n    end\n    # get index of eve\n    eve_idx = 0\n    for\
    \ i in eachindex(arr)\n        if arr[i] == eve\n            eve_idx = i\n   \
    \         break\n        end\n    end\n    return [eve, eve_idx]\nend\n \n@testset\
    \ \"Example\" begin\n    @test pluck([4, 2, 3]) == [2, 1]\n    @test pluck([1,\
    \ 2, 3]) == [2, 1]\n    @test pluck([]) == []\n    @test pluck([5, 0, 3, 0, 4,\
    \ 2]) == [0, 1]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: UndefVarError: @testset not defined

    in expression starting at /tmp/tmpxndj0o0s.jl:58

    in expression starting at /tmp/tmpxndj0o0s.jl:58

    '
  stdout: ''
  timestamp: 1660014693
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if(length(arr) == 0)\n        return []\n    end\n    min_even = 0\n \
    \   min_even_idx = 0\n    for(i, x) in enumerate(arr)\n        if(x % 2 == 0)\n\
    \            if(x <= min_even)\n                min_even = x\n               \
    \ min_even_idx = i\n            end\n        end\n    end\n    if(min_even ==\
    \ 0)\n        return []\n    end\n    return [min_even, min_even_idx]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmptughsnsr.jl:55

    '
  stdout: "test set: Test Failed at /tmp/tmptughsnsr.jl:58\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmptughsnsr.jl:58 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmptughsnsr.jl:57\ntest set: Test Failed at /tmp/tmptughsnsr.jl:59\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmptughsnsr.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmptughsnsr.jl:57\ntest set: Test\
    \ Failed at /tmp/tmptughsnsr.jl:61\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: Int64[] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmptughsnsr.jl:61 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmptughsnsr.jl:57\ntest set: Test Failed at /tmp/tmptughsnsr.jl:62\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: Int64[]\
    \ == [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmptughsnsr.jl:62 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmptughsnsr.jl:57\ntest set: Test\
    \ Failed at /tmp/tmptughsnsr.jl:63\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: Int64[] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1."
  timestamp: 1660014694
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0 return [] end\n    idx = 0\n    for i in eachindex(arr)\n\
    \        if arr[i] % 2 == 0\n            if (idx == 0) || (arr[i] < arr[idx])\n\
    \                idx = i\n            end\n        end\n    end\n    if idx ==\
    \ 0 return [] end\n    return [arr[idx], idx]\nend\n \nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpl663woeq.jl:50

    '
  stdout: "test set: Test Failed at /tmp/tmpl663woeq.jl:53\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpl663woeq.jl:53 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpl663woeq.jl:52\ntest set: Test Failed at /tmp/tmpl663woeq.jl:54\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpl663woeq.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpl663woeq.jl:52\ntest set: Test\
    \ Failed at /tmp/tmpl663woeq.jl:56\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpl663woeq.jl:56 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpl663woeq.jl:52\ntest set: Test Failed at /tmp/tmpl663woeq.jl:57\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpl663woeq.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpl663woeq.jl:52\ntest set: Test\
    \ Failed at /tmp/tmpl663woeq.jl:58\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014695
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # set of odd values in the arr (to avoid duplicate computation)\n    odds\
    \ = Set()\n    even_idx = 0\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp8spknepx.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp8spknepx.jl:1\n\
    in expression starting at /tmp/tmp8spknepx.jl:1\n"
  stdout: ''
  timestamp: 1660014694
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, [arr[i],\
    \ i])\n        end\n    end\n    if length(evens) == 0\n        return []\n  \
    \  end\n    minimum = evens[1]\n    for i in 1:length(evens)\n        if evens[i][1]\
    \ < minimum[1]\n            minimum = evens[i]\n        end\n    end\n    return\
    \ minimum\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpugi5i0ok.jl:57

    '
  stdout: "test set: Test Failed at /tmp/tmpugi5i0ok.jl:60\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpugi5i0ok.jl:60 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpugi5i0ok.jl:59\ntest set: Test Failed at /tmp/tmpugi5i0ok.jl:61\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpugi5i0ok.jl:61 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpugi5i0ok.jl:59\ntest set: Test\
    \ Failed at /tmp/tmpugi5i0ok.jl:63\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpugi5i0ok.jl:63 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpugi5i0ok.jl:59\ntest set: Test Failed at /tmp/tmpugi5i0ok.jl:64\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpugi5i0ok.jl:64 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpugi5i0ok.jl:59\ntest set: Test\
    \ Failed at /tmp/tmpugi5i0ok.jl:65\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014695
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens_idx = findall(isodd, arr)\n    evens = arr[evens_idx]\n    evens\
    \ = sort(evens)\n    if isempty(evens)\n        return []\n    else\n        return\
    \ [evens[1], evens_idx[1]]\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 7 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpgkba5m4a.jl:46

    '
  stdout: "test set: Test Failed at /tmp/tmpgkba5m4a.jl:49\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [3, 3] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpgkba5m4a.jl:49 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpgkba5m4a.jl:48\ntest set: Test Failed at /tmp/tmpgkba5m4a.jl:50\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [1, 1] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgkba5m4a.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgkba5m4a.jl:48\ntest set: Test\
    \ Failed at /tmp/tmpgkba5m4a.jl:52\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [3, 1] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpgkba5m4a.jl:52 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpgkba5m4a.jl:48\ntest set: Test Failed at /tmp/tmpgkba5m4a.jl:53\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [1, 1] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgkba5m4a.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgkba5m4a.jl:48\ntest set: Test\
    \ Failed at /tmp/tmpgkba5m4a.jl:54\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [5, 1] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014696
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # TODO\nend\n \n \n \n\"\"\"\"\n    You are given an array of strings\
    \ words and a string chars.\n    A string is good if it can be formed by characters\
    \ from chars (each character can only be used once).\n    Return the sum of lengths\
    \ of all good strings in words.\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpu66lfphh.jl:40\nin expression starting at\
    \ /tmp/tmpu66lfphh.jl:40\n"
  stdout: ''
  timestamp: 1660014694
- exit_code: -1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return Int64[]\n    end\n    min_even = minimum(filter(x\
    \ -> x % 2 == 0, arr))\n    if isempty(min_even)\n        return Int64[]\n   \
    \ end\n    return [arr[i] for i in eachindex(arr) if arr[i] == min_even][1]\n\
    end\npluck([4, 2, 3])\npluck([1, 2, 3])\npluck([])\npluck([5, 0, 3, 0, 4, 2])\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: Timeout
  stderr: 'ERROR: LoadError: MethodError: Cannot `convert` an object of type Int64
    to an object of type Vector{Int64}'
  stdout: ''
  timestamp: 1660014698
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0 return [] end\n    even_indices = Vector{Int64}()\n\
    \    for i = 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_indices,\
    \ i)\n        end\n    end\n    if length(even_indices) == 0 return [] end\n \
    \   min_index = even_indices[1]\n    for i = 2:length(even_indices)\n        if\
    \ arr[even_indices[i]] < arr[min_index]\n            min_index = even_indices[i]\n\
    \        end\n    end\n    return [arr[min_index], min_index]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpeu_obhn9.jl:53

    '
  stdout: "test set: Test Failed at /tmp/tmpeu_obhn9.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpeu_obhn9.jl:56 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpeu_obhn9.jl:55\ntest set: Test Failed at /tmp/tmpeu_obhn9.jl:57\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpeu_obhn9.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeu_obhn9.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpeu_obhn9.jl:59\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpeu_obhn9.jl:59 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpeu_obhn9.jl:55\ntest set: Test Failed at /tmp/tmpeu_obhn9.jl:60\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpeu_obhn9.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeu_obhn9.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpeu_obhn9.jl:61\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014696
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # Start your code here\n    for idx in 1:length(arr)\n        if arr[idx]\
    \ % 2 == 0\n            return [arr[idx], idx]\n        end\n    end\n    return\
    \ []\nend\n```\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: invalid \"`\" syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphtvbz9ny.jl:43\nin expression starting at\
    \ /tmp/tmphtvbz9ny.jl:43\n"
  stdout: ''
  timestamp: 1660014694
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if all(x -> x % 2 != 0, arr) || isempty(arr)\n        return []\n    end\n\
    \    smallest_even_value = minimum(filter(x -> x % 2 == 0, arr))\n    smallest_even_index\
    \ = findfirst(arr, smallest_even_value)\n    return [smallest_even_value, smallest_even_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpnhcc9nk1.jl:44

    '
  stdout: "test set: Error During Test at /tmp/tmpnhcc9nk1.jl:47\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpnhcc9nk1.jl:39\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnhcc9nk1.jl:47 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnhcc9nk1.jl:46\ntest set:\
    \ Error During Test at /tmp/tmpnhcc9nk1.jl:48\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpnhcc9nk1.jl:39\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnhcc9nk1.jl:48 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnhcc9nk1.jl:46\ntest set:\
    \ Error During Test at /tmp/tmpnhcc9nk1.jl:50\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014698
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    min_even = minimum(arr[arr .% 2 .== 0]) # The smallest even value.\n \
    \   min_even_idx = findall(arr .== min_even)[1] # The smallest index for the smallest\
    \ even value.\n    return [min_even, min_even_idx] # Return the values.\nend\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 2 errored,
    0 broken.

    in expression starting at /tmp/tmpn95_p9zc.jl:41

    '
  stdout: "test set: Test Failed at /tmp/tmpn95_p9zc.jl:44\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpn95_p9zc.jl:44 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpn95_p9zc.jl:43\ntest set: Test Failed at /tmp/tmpn95_p9zc.jl:45\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpn95_p9zc.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpn95_p9zc.jl:43\ntest set: Error\
    \ During Test at /tmp/tmpn95_p9zc.jl:46\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  ArgumentError: reducing\
    \ over an empty collection is not allowed\n  Stacktrace:\n    [1] _empty_reduce_error()\n\
    \      @ Base ./reduce.jl:301\n    [2] reduce_empty(op::Function, #unused#::Type{Int64})\n\
    \      @ Base ./reduce.jl:311\n    [3] mapreduce_empty(#unused#::typeof(identity),\
    \ op::Function, T::Type)\n      @ Base ./reduce.jl:345\n    [4] reduce_empty(op::Base.MappingRF{typeof(identity),\
    \ typeof(min)}, #unused#::Type{Int64})\n      @ Base ./reduce.jl:331\n    [5]\
    \ reduce_empty_iter\n      @ ./reduce.jl:357 [inlined]\n    [6] mapreduce_empty_iter(f::Function,\
    \ op::Function, itr::Vector{Int64}, ItrEltype::Base.HasEltype)\n      @ Base ./reduce.jl:353\n\
    \    [7] _mapreduce\n      @ ./reduce.jl:402 [inlined]\n    [8] _mapreduce_dim\n\
    \      @ ./reducedim.jl:330 [inlined]\n    [9] #mapreduce#731\n      @ ./reducedim.jl:322\
    \ [inlined]\n   [10] mapreduce\n      @ ./reducedim.jl:322 [inlined]\n   [11]\
    \ #_minimum#753\n      @ ./reducedim.jl:894 [inlined]\n   [12] _minimum\n    \
    \  @ ./reducedim.jl:894 [inlined]\n   [13] #_mini"
  timestamp: 1660014698
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    min_val = Inf\n    min_idx = Inf\n    for (i, v) in enumerate(arr)\n \
    \       if rem(v, 2) == 0\n            if v < min_val\n                min_val\
    \ = v\n                min_idx = i\n            end\n        end\n    end\n  \
    \  return [min_val, min_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 2 errored,
    0 broken.

    in expression starting at /tmp/tmpnv4vm1vf.jl:49

    '
  stdout: "test set: Test Failed at /tmp/tmpnv4vm1vf.jl:52\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpnv4vm1vf.jl:52 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpnv4vm1vf.jl:51\ntest set: Test Failed at /tmp/tmpnv4vm1vf.jl:53\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnv4vm1vf.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnv4vm1vf.jl:51\ntest set: Error\
    \ During Test at /tmp/tmpnv4vm1vf.jl:54\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  InexactError: Int64(Inf)\n\
    \  Stacktrace:\n    [1] Int64\n      @ ./float.jl:812 [inlined]\n    [2] convert\n\
    \      @ ./number.jl:7 [inlined]\n    [3] setindex!\n      @ ./array.jl:903 [inlined]\n\
    \    [4] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Float64},\
    \ soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [5] unsafe_copyto!\n\
    \      @ ./array.jl:307 [inlined]\n    [6] _copyto_impl!\n      @ ./array.jl:331\
    \ [inlined]\n    [7] copyto!\n      @ ./array.jl:317 [inlined]\n    [8] copyto!\n\
    \      @ ./array.jl:343 [inlined]\n    [9] copyto_axcheck!\n      @ ./abstractarray.jl:1104\
    \ [inlined]\n   [10] Vector{Int64}(x::Vector{Float64})\n      @ Base ./array.jl:563\n\
    \   [11] convert\n      @ ./array.jl:554 [inlined]\n   [12] pluck(arr::Vector{Int64})\n\
    \      @ Main /tmp/tmpnv4vm1vf.jl:45\n   [13] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [14] macro expansion\n      @ /tmp/tmpnv4vm1vf.jl:54 [inlined]\n\
    \   [15] macro expansion\n      @ ~/.conda/e"
  timestamp: 1660014698
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    min_value = minimum(arr[arr .% 2 .== 0])\n    index = findfirst(arr .==\
    \ min_value)\n    return [min_value, index]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 2 errored,
    0 broken.

    in expression starting at /tmp/tmpc68nlgok.jl:41

    '
  stdout: "test set: Test Failed at /tmp/tmpc68nlgok.jl:44\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpc68nlgok.jl:44 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpc68nlgok.jl:43\ntest set: Test Failed at /tmp/tmpc68nlgok.jl:45\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpc68nlgok.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpc68nlgok.jl:43\ntest set: Error\
    \ During Test at /tmp/tmpc68nlgok.jl:46\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  ArgumentError: reducing\
    \ over an empty collection is not allowed\n  Stacktrace:\n    [1] _empty_reduce_error()\n\
    \      @ Base ./reduce.jl:301\n    [2] reduce_empty(op::Function, #unused#::Type{Int64})\n\
    \      @ Base ./reduce.jl:311\n    [3] mapreduce_empty(#unused#::typeof(identity),\
    \ op::Function, T::Type)\n      @ Base ./reduce.jl:345\n    [4] reduce_empty(op::Base.MappingRF{typeof(identity),\
    \ typeof(min)}, #unused#::Type{Int64})\n      @ Base ./reduce.jl:331\n    [5]\
    \ reduce_empty_iter\n      @ ./reduce.jl:357 [inlined]\n    [6] mapreduce_empty_iter(f::Function,\
    \ op::Function, itr::Vector{Int64}, ItrEltype::Base.HasEltype)\n      @ Base ./reduce.jl:353\n\
    \    [7] _mapreduce\n      @ ./reduce.jl:402 [inlined]\n    [8] _mapreduce_dim\n\
    \      @ ./reducedim.jl:330 [inlined]\n    [9] #mapreduce#731\n      @ ./reducedim.jl:322\
    \ [inlined]\n   [10] mapreduce\n      @ ./reducedim.jl:322 [inlined]\n   [11]\
    \ #_minimum#753\n      @ ./reducedim.jl:894 [inlined]\n   [12] _minimum\n    \
    \  @ ./reducedim.jl:894 [inlined]\n   [13] #_mini"
  timestamp: 1660014698
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    min_val = nothing\n    min_idx = nothing\n    for i in eachindex(arr)\n\
    \        if iseven(arr[i])\n            if min_val == nothing || arr[i] < min_val\n\
    \                min_val = arr[i]\n                min_idx = i\n            end\n\
    \        end\n    end\n    if min_val == nothing\n        return []\n    else\n\
    \        return [min_val, min_idx]\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpcaq8r3jq.jl:53

    '
  stdout: "test set: Test Failed at /tmp/tmpcaq8r3jq.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpcaq8r3jq.jl:56 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpcaq8r3jq.jl:55\ntest set: Test Failed at /tmp/tmpcaq8r3jq.jl:57\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcaq8r3jq.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcaq8r3jq.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpcaq8r3jq.jl:59\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpcaq8r3jq.jl:59 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpcaq8r3jq.jl:55\ntest set: Test Failed at /tmp/tmpcaq8r3jq.jl:60\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcaq8r3jq.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcaq8r3jq.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpcaq8r3jq.jl:61\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014696
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    min, idx = arr[1],\
    \ 1\n    for (i, val) in enumerate(arr)\n        if val % 2 == 0 && val < min\n\
    \            min, idx = val, i\n        end\n    end\n    if min % 2 == 0\n  \
    \      return [min, idx]\n    else\n        return []\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpkvt1_8qr.jl:52

    '
  stdout: "test set: Test Failed at /tmp/tmpkvt1_8qr.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpkvt1_8qr.jl:55 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpkvt1_8qr.jl:54\ntest set: Test Failed at /tmp/tmpkvt1_8qr.jl:56\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkvt1_8qr.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkvt1_8qr.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpkvt1_8qr.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpkvt1_8qr.jl:58 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpkvt1_8qr.jl:54\ntest set: Test Failed at /tmp/tmpkvt1_8qr.jl:59\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkvt1_8qr.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkvt1_8qr.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpkvt1_8qr.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Te"
  timestamp: 1660014697
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # First, we'll find the smallest even value in the array.\n    # Find\
    \ all evens\n    all_evens = filter(x -> x % 2 == 0, arr)\n    # Find minimum\
    \ of the evens\n    smallest_even = minimum(all_evens)\n    # Then, we'll find\
    \ the indices of the elements that have that value.\n    idx = findall(arr .==\
    \ smallest_even)\n    # Return the index of the minimum element in that array\n\
    \    smallest_idx = minimum(idx)\n    # Return the index with the element in a\
    \ new array\n    return [arr[smallest_idx], smallest_idx]\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 2 errored,
    0 broken.

    in expression starting at /tmp/tmphrd6lnvi.jl:49

    '
  stdout: "test set: Test Failed at /tmp/tmphrd6lnvi.jl:52\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmphrd6lnvi.jl:52 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmphrd6lnvi.jl:51\ntest set: Test Failed at /tmp/tmphrd6lnvi.jl:53\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphrd6lnvi.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphrd6lnvi.jl:51\ntest set: Error\
    \ During Test at /tmp/tmphrd6lnvi.jl:54\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  ArgumentError: reducing\
    \ over an empty collection is not allowed\n  Stacktrace:\n    [1] _empty_reduce_error()\n\
    \      @ Base ./reduce.jl:301\n    [2] reduce_empty(op::Function, #unused#::Type{Int64})\n\
    \      @ Base ./reduce.jl:311\n    [3] mapreduce_empty(#unused#::typeof(identity),\
    \ op::Function, T::Type)\n      @ Base ./reduce.jl:345\n    [4] reduce_empty(op::Base.MappingRF{typeof(identity),\
    \ typeof(min)}, #unused#::Type{Int64})\n      @ Base ./reduce.jl:331\n    [5]\
    \ reduce_empty_iter\n      @ ./reduce.jl:357 [inlined]\n    [6] mapreduce_empty_iter(f::Function,\
    \ op::Function, itr::Vector{Int64}, ItrEltype::Base.HasEltype)\n      @ Base ./reduce.jl:353\n\
    \    [7] _mapreduce\n      @ ./reduce.jl:402 [inlined]\n    [8] _mapreduce_dim\n\
    \      @ ./reducedim.jl:330 [inlined]\n    [9] #mapreduce#731\n      @ ./reducedim.jl:322\
    \ [inlined]\n   [10] mapreduce\n      @ ./reducedim.jl:322 [inlined]\n   [11]\
    \ #_minimum#753\n      @ ./reducedim.jl:894 [inlined]\n   [12] _minimum\n    \
    \  @ ./reducedim.jl:894 [inlined]\n   [13] #_mini"
  timestamp: 1660014698
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    inds = [i for i in 1:length(arr) if arr[i] == min_even]\n\
    \    min_ind = minimum(inds)\n    return [min_even, min_ind]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpkr0dxmn5.jl:49

    '
  stdout: "test set: Test Failed at /tmp/tmpkr0dxmn5.jl:52\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpkr0dxmn5.jl:52 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpkr0dxmn5.jl:51\ntest set: Test Failed at /tmp/tmpkr0dxmn5.jl:53\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkr0dxmn5.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkr0dxmn5.jl:51\ntest set: Test\
    \ Failed at /tmp/tmpkr0dxmn5.jl:55\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpkr0dxmn5.jl:55 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpkr0dxmn5.jl:51\ntest set: Test Failed at /tmp/tmpkr0dxmn5.jl:56\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkr0dxmn5.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkr0dxmn5.jl:51\ntest set: Test\
    \ Failed at /tmp/tmpkr0dxmn5.jl:57\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014697
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpzehx0k64.jl:39

    '
  stdout: "test set: Test Failed at /tmp/tmpzehx0k64.jl:42\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpzehx0k64.jl:42 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpzehx0k64.jl:41\ntest set: Test Failed at /tmp/tmpzehx0k64.jl:43\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzehx0k64.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzehx0k64.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpzehx0k64.jl:45\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: Int64[] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpzehx0k64.jl:45 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpzehx0k64.jl:41\ntest set: Test Failed at /tmp/tmpzehx0k64.jl:46\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: Int64[]\
    \ == [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzehx0k64.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzehx0k64.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpzehx0k64.jl:47\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: Int64[] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1."
  timestamp: 1660014683
- exit_code: -1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    indices = findall(isodd,\
    \ arr)\n    if isempty(indices)\n        return []\n    end\n    min_even = minimum(arr[indices])\n\
    \    return [min_even, findmin(arr[indices])]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: Timeout
  stderr: 'ERROR: '
  stdout: "test set: Error During Test at /tmp/tmp1ppa02q2.jl:50\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Tuple{Int64, Int64} to an object of type Int64\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at ~/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at ~/.conda/envs/polyglot/share/julia/base/number.jl:6\n\
    \    convert(::Type{T}, !Matched::Number) where T<:Number at ~/.conda/envs/polyglot/share/julia/base/number.jl:7\n\
    \    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Tuple{Int64, Int64},\
    \ i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64},\
    \ doffs::Int64, src::Vector{Any}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n\
    \    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n\
    \      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n\
    \    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n\
    \      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Any})\n\
    \      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n\
    \   [10] pluck(arr::Vector{Int64})\n      @ Main /tmp/tmp1ppa02q2.jl:43\n   [11]\
    \ macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [12] macro expansion\n      @ /tmp/tmp1ppa02q2.jl:50 [inlined]\n\
    \   [13] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [14] top-level scope\n      @ /tmp/tmp1ppa02q2.jl:49\ntest set:\
    \ Error During Test at /tmp/tmp1ppa02q2.jl:51\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Tuple{Int64, Int64} to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::Ptr) where T<:Integer at ~/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at ~/.conda/"
  timestamp: 1660014699
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    a = 0\n    i = 0\n    idx = 10001\n    e = []\n    if length(arr) == 0\n\
    \        return e\n    end\n    for j in 1:length(arr)\n        if arr[j] % 2\
    \ == 0\n            if a == 0\n                a = arr[j]\n                idx\
    \ = j\n            elseif arr[j] < a\n                a = arr[j]\n           \
    \     idx = j\n            end\n        end\n    end\n    if a == 0\n        return\
    \ e\n    end\n    push!(e,a)\n    push!(e,idx)\n    return e\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpvl1cxhi3.jl:62

    '
  stdout: "test set: Test Failed at /tmp/tmpvl1cxhi3.jl:65\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpvl1cxhi3.jl:65 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpvl1cxhi3.jl:64\ntest set: Test Failed at /tmp/tmpvl1cxhi3.jl:66\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvl1cxhi3.jl:66 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvl1cxhi3.jl:64\ntest set: Test\
    \ Failed at /tmp/tmpvl1cxhi3.jl:68\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [2, 6] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpvl1cxhi3.jl:68 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpvl1cxhi3.jl:64\ntest set: Test Failed at /tmp/tmpvl1cxhi3.jl:69\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: Int64[]\
    \ == [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvl1cxhi3.jl:69 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvl1cxhi3.jl:64\ntest set: Test\
    \ Failed at /tmp/tmpvl1cxhi3.jl:70\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Te"
  timestamp: 1660014697
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    min_even_value = 10001\n    min_index = -1\n    for (index, value) in\
    \ enumerate(arr)\n        if(value%2 == 0 && value < min_even_value)\n       \
    \     min_even_value = value\n            min_index = index\n        end\n   \
    \ end\n    if(min_index == -1)\n        return []\n    end\n    return [min_even_value,\
    \ min_index]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp9ght_n2_.jl:50

    '
  stdout: "test set: Test Failed at /tmp/tmp9ght_n2_.jl:53\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp9ght_n2_.jl:53 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp9ght_n2_.jl:52\ntest set: Test Failed at /tmp/tmp9ght_n2_.jl:54\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9ght_n2_.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9ght_n2_.jl:52\ntest set: Test\
    \ Failed at /tmp/tmp9ght_n2_.jl:56\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp9ght_n2_.jl:56 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp9ght_n2_.jl:52\ntest set: Test Failed at /tmp/tmp9ght_n2_.jl:57\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9ght_n2_.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9ght_n2_.jl:52\ntest set: Test\
    \ Failed at /tmp/tmp9ght_n2_.jl:58\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014697
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # special case: empty array\n    if length(arr) == 0\n        return []\n\
    \    end\n    \n    # special case: only one element, and it is even\n    if length(arr)\
    \ == 1 && iseven(arr[1])\n        return [arr[1], 1]\n    end\n    \n    # special\
    \ case: only one element, and it is odd\n    if length(arr) == 1 && !iseven(arr[1])\n\
    \        return []\n    end\n    \n    # filter out the even numbers\n    evens\
    \ = arr[iseven.(arr)]\n    \n    # special case: no even numbers\n    if length(evens)\
    \ == 0\n        return []\n    end\n    \n    # find the minimum even number,\
    \ and find the index of that number\n    minimum = minimum(evens)\n    index =\
    \ findfirst(minimum, arr)\n    \n    # special case: there are multiple minimums\n\
    \    # if there are multiple minimums, find the first one, then find the index\
    \ of that minimum\n    while length(findall(minimum, arr)) > 1\n        minimum\
    \ = findall(minimum, arr)[1]\n        index = findfirst(minimum, arr)\n    end\n\
    \    \n    return [minimum, index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp1nko2v5h.jl:73

    '
  stdout: "test set: Error During Test at /tmp/tmp1nko2v5h.jl:76\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  UndefVarError: minimum not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp1nko2v5h.jl:59\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp1nko2v5h.jl:76 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp1nko2v5h.jl:75\ntest set:\
    \ Error During Test at /tmp/tmp1nko2v5h.jl:77\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  UndefVarError: minimum not defined\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp1nko2v5h.jl:59\n   [2]\
    \ macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp1nko2v5h.jl:77 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp1nko2v5h.jl:75\ntest set:\
    \ Error During Test at /tmp/tmp1nko2v5h.jl:79\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  UndefVarError: minimum not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp1nko2v5h.jl:59\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp1nko2v5h.jl:79 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp1nko2v5h.jl:75\ntest set:\
    \ Error During Test at /tmp/tmp1nko2v5h.jl:80\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n  UndefVarError: minimum not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp1nko2v5h.jl:59\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/st"
  timestamp: 1660014698
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    #create a new array to store only even numbers\n    even_arr = []\n  \
    \  #create a new array to store indexes of the even number\n    even_index_arr\
    \ = []\n    # loop over the array to store all even numbers and their indexes\n\
    \    for i in 1:length(arr)\n        if (arr[i] % 2 == 0)\n            # push\
    \ the element to the even number array\n            push!(even_arr, arr[i])\n\
    \            # push the element index to the even number index array\n       \
    \     push!(even_index_arr, i)\n        end\n    end\n    # if there is no even\
    \ number, return empty array\n    if (length(even_arr) == 0)\n        return []\n\
    \    end\n    # sort the array of even numbers\n    sort!(even_arr)\n    # sort\
    \ the array of even number indexes\n    sort!(even_index_arr)\n    # get the first\
    \ element in both of the arrays, since they are sorted\n    # the first elements\
    \ are the smallest even number and its index\n    return [even_arr[1], even_index_arr[1]]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqigaa4ts.jl:62

    '
  stdout: "test set: Test Failed at /tmp/tmpqigaa4ts.jl:66\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqigaa4ts.jl:66 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpqigaa4ts.jl:64\ntest set: Test Failed at /tmp/tmpqigaa4ts.jl:68\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqigaa4ts.jl:68 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqigaa4ts.jl:64\ntest set: Test\
    \ Failed at /tmp/tmpqigaa4ts.jl:69\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 2] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqigaa4ts.jl:69 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpqigaa4ts.jl:64\ntest set: Test Failed at /tmp/tmpqigaa4ts.jl:70\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqigaa4ts.jl:70 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqigaa4ts.jl:64\ntest set: Test\
    \ Failed at /tmp/tmpqigaa4ts.jl:71\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/"
  timestamp: 1660014697
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # Complete this function\nend\n```\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: invalid \"`\" syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdw89l3d4.jl:37\nin expression starting at\
    \ /tmp/tmpdw89l3d4.jl:37\n"
  stdout: ''
  timestamp: 1660014696
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmplt8w0jxa.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmplt8w0jxa.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmplt8w0jxa.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmplt8w0jxa.jl:42\ntest set: Test Failed at /tmp/tmplt8w0jxa.jl:44\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmplt8w0jxa.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmplt8w0jxa.jl:42\ntest set: Test\
    \ Failed at /tmp/tmplt8w0jxa.jl:46\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: Int64[] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmplt8w0jxa.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmplt8w0jxa.jl:42\ntest set: Test Failed at /tmp/tmplt8w0jxa.jl:47\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: Int64[]\
    \ == [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmplt8w0jxa.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmplt8w0jxa.jl:42\ntest set: Test\
    \ Failed at /tmp/tmplt8w0jxa.jl:48\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: Int64[] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1."
  timestamp: 1660014697
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    plucked_node = [-1,\
    \ -1]\n    for (node_index, node_value) in enumerate(arr)\n        if node_value\
    \ % 2 == 0\n            if plucked_node[1] == -1\n                plucked_node\
    \ = [node_value, node_index]\n            elseif node_value < plucked_node[1]\n\
    \                plucked_node = [node_value, node_index]\n            end\n  \
    \      end\n    end\n    return plucked_node\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 7 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpgzbx6p0_.jl:52

    '
  stdout: "test set: Test Failed at /tmp/tmpgzbx6p0_.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpgzbx6p0_.jl:55 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpgzbx6p0_.jl:54\ntest set: Test Failed at /tmp/tmpgzbx6p0_.jl:56\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgzbx6p0_.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgzbx6p0_.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpgzbx6p0_.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpgzbx6p0_.jl:58 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpgzbx6p0_.jl:54\ntest set: Test Failed at /tmp/tmpgzbx6p0_.jl:59\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgzbx6p0_.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgzbx6p0_.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpgzbx6p0_.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014697
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = arr[rem.(arr,\
    \ 2) .== 0]\n    if length(evens) == 0\n        return []\n    end\n    even_min\
    \ = minimum(evens)\n    return [even_min, findfirst(arr, even_min)[1]]\nend\n\
    \ \n```\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: invalid \"`\" syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpad_hu8ba.jl:46\nin expression starting at\
    \ /tmp/tmpad_hu8ba.jl:46\n"
  stdout: ''
  timestamp: 1660014697
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    candidates = []\n   \
    \ for i in 1:length(arr)\n        if iseven(arr[i])\n            push!(candidates,\
    \ [arr[i], i])\n        end\n    end\n    if isempty(candidates)\n        return\
    \ []\n    end\n    sort!(candidates, by = x -> x[1])\n    return candidates[1]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpzr6f2lt4.jl:52

    '
  stdout: "test set: Test Failed at /tmp/tmpzr6f2lt4.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpzr6f2lt4.jl:55 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpzr6f2lt4.jl:54\ntest set: Test Failed at /tmp/tmpzr6f2lt4.jl:56\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzr6f2lt4.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzr6f2lt4.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpzr6f2lt4.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpzr6f2lt4.jl:58 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpzr6f2lt4.jl:54\ntest set: Test Failed at /tmp/tmpzr6f2lt4.jl:59\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzr6f2lt4.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzr6f2lt4.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpzr6f2lt4.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014698
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_positions = findall(x -> (x % 2 == 0), arr)\n    if isempty(even_positions)\n\
    \        return []\n    end\n    smallest_even_value = minimum(arr[even_positions])\n\
    \    node_index = findfirst(arr, smallest_even_value)\n    return [smallest_even_value,\
    \ node_index]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmphrt01553.jl:45

    '
  stdout: "test set: Error During Test at /tmp/tmphrt01553.jl:48\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmphrt01553.jl:40\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmphrt01553.jl:48 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmphrt01553.jl:47\ntest set:\
    \ Error During Test at /tmp/tmphrt01553.jl:49\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmphrt01553.jl:40\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmphrt01553.jl:49 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmphrt01553.jl:47\ntest set:\
    \ Error During Test at /tmp/tmphrt01553.jl:51\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014700
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    return []\nend\n \nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpotfxt4vz.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmpotfxt4vz.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpotfxt4vz.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpotfxt4vz.jl:42\ntest set: Test Failed at /tmp/tmpotfxt4vz.jl:44\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpotfxt4vz.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpotfxt4vz.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpotfxt4vz.jl:46\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: Int64[] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpotfxt4vz.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpotfxt4vz.jl:42\ntest set: Test Failed at /tmp/tmpotfxt4vz.jl:47\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: Int64[]\
    \ == [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpotfxt4vz.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpotfxt4vz.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpotfxt4vz.jl:48\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: Int64[] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1."
  timestamp: 1660014699
- exit_code: -1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # We first find the min even value\n    min_even_val = 0 # even if there\
    \ is no even number at the end of the function,\n                     # the output\
    \ will be a vector of 0, empty.\n    for (i, e) in enumerate(arr)\n        if\
    \ iseven(e) && (e < min_even_val || min_even_val == 0)\n            min_even_val\
    \ = e\n        end\n    end\n    # Next we find the index at which that number\
    \ appears.\n    # Since we are looking for the first index of the number, the\
    \ loop starts at i = 1.\n    # We could have also started at i = 1 in the above\
    \ loop.\n    for (i, e) in enumerate(arr)\n        if e == min_even_val\n    \
    \        return [e, i]\n        end\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: Timeout
  stderr: ''
  stdout: "test set: Test Failed at /tmp/tmpu48_g9s6.jl:57\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpu48_g9s6.jl:57 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpu48_g9s6.jl:56\ntest set: Test Failed at /tmp/tmpu48_g9s6.jl:58\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpu48_g9s6.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpu48_g9s6.jl:56\ntest set: Error\
    \ During Test at /tmp/tmpu48_g9s6.jl:59\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpu48_g9s6.jl:48\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpu48_g9s6.jl:59 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpu48_g9s6.jl:56\ntest set:\
    \ Test Failed at /tmp/tmpu48_g9s6.jl:"
  timestamp: 1660014701
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_indices = findall(x -> (x % 2 == 0), arr)\n    if isempty(even_indices)\n\
    \        return []\n    end\n    even_values = arr[even_indices]\n    smallest_value\
    \ = minimum(even_values)\n    smallest_value_index = findfirst(arr, smallest_value)\n\
    \    return [smallest_value, smallest_value_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmphf88ikm9.jl:46

    '
  stdout: "test set: Error During Test at /tmp/tmphf88ikm9.jl:49\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmphf88ikm9.jl:41\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmphf88ikm9.jl:49 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmphf88ikm9.jl:48\ntest set:\
    \ Error During Test at /tmp/tmphf88ikm9.jl:50\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmphf88ikm9.jl:41\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmphf88ikm9.jl:50 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmphf88ikm9.jl:48\ntest set:\
    \ Error During Test at /tmp/tmphf88ikm9.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014701
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    i::Int64 = 1\n    minEven::Int64 = 10001\n    index::Int64 = 0\n\
    \    \n    if length(arr) == 0\n        return []\n    end\n    \n    while i\
    \ <= length(arr)\n        if arr[i] == 0\n            index = i\n            minEven\
    \ = 0\n            break\n        elseif arr[i] % 2 == 0 && arr[i] < minEven\n\
    \            minEven = arr[i]\n            index = i\n        end\n        i +=\
    \ 1\n    end\n    \n    if minEven == 10001\n        return []\n    else\n   \
    \     return [minEven, index]\n    end\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpooz3viyk.jl:64

    '
  stdout: "test set: Test Failed at /tmp/tmpooz3viyk.jl:67\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpooz3viyk.jl:67 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpooz3viyk.jl:66\ntest set: Test Failed at /tmp/tmpooz3viyk.jl:68\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpooz3viyk.jl:68 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpooz3viyk.jl:66\ntest set: Test\
    \ Failed at /tmp/tmpooz3viyk.jl:70\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpooz3viyk.jl:70 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpooz3viyk.jl:66\ntest set: Test Failed at /tmp/tmpooz3viyk.jl:71\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpooz3viyk.jl:71 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpooz3viyk.jl:66\ntest set: Test\
    \ Failed at /tmp/tmpooz3viyk.jl:72\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014699
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # first we need to find the minimal even value in the array\n    # we\
    \ need to filter out all the odd integers first\n    min_even_val = find_min_even(arr)\n\
    \    # then we need to find the index of the first occurence of min_even_val\n\
    \    min_even_val_idx = find_min_even_idx(arr, min_even_val)\n    # if there is\
    \ no even number, return empty array\n    if min_even_val == Inf\n        return\
    \ []\n    else\n        return [min_even_val, min_even_val_idx]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmp5ddnmuxq.jl:49

    '
  stdout: "test set: Error During Test at /tmp/tmp5ddnmuxq.jl:52\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  UndefVarError: find_min_even\
    \ not defined\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp5ddnmuxq.jl:37\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp5ddnmuxq.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp5ddnmuxq.jl:51\ntest set:\
    \ Error During Test at /tmp/tmp5ddnmuxq.jl:53\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  UndefVarError: find_min_even not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp5ddnmuxq.jl:37\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp5ddnmuxq.jl:53 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp5ddnmuxq.jl:51\ntest set:\
    \ Error During Test at /tmp/tmp5ddnmuxq.jl:54\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  UndefVarError: find_min_even\
    \ not defined\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp5ddnmuxq.jl:37\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp5ddnmuxq.jl:54 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp5ddnmuxq.jl:51\ntest set:\
    \ Error During Test at /tmp/tmp5ddnmuxq.jl:55\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  UndefVarError: find_min_even not\
    \ defined\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp5ddnmuxq.jl:37\n\
    \   [2] macro expansion\n     @ ~/."
  timestamp: 1660014700
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    # Base cases\n    if isempty(arr) || !any(iseven, arr)\n       \
    \ return []\n    end\n    \n    # Get the smallest even value\n    evens = getevens(arr)\n\
    \    if length(evens) == 1\n        return evens[1]\n    end\n    smallest_even\
    \ = minimum(evens)\n    \n    # get the index of the smallest even value\n   \
    \ indexes = getindexes(arr, smallest_even)\n    smallest_index = minimum(indexes)\n\
    \    \n    return [smallest_even, smallest_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp0tzn6ba2.jl:56

    '
  stdout: "test set: Error During Test at /tmp/tmp0tzn6ba2.jl:59\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  UndefVarError: getevens not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp0tzn6ba2.jl:42\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0tzn6ba2.jl:59 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0tzn6ba2.jl:58\ntest set:\
    \ Error During Test at /tmp/tmp0tzn6ba2.jl:60\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  UndefVarError: getevens not defined\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp0tzn6ba2.jl:42\n   [2]\
    \ macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0tzn6ba2.jl:60 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0tzn6ba2.jl:58\ntest set:\
    \ Error During Test at /tmp/tmp0tzn6ba2.jl:62\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  UndefVarError: getevens not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp0tzn6ba2.jl:42\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0tzn6ba2.jl:62 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0tzn6ba2.jl:58\ntest set:\
    \ Error During Test at /tmp/tmp0tzn6ba2.jl:63\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n  UndefVarError: getevens not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp0tzn6ba2.jl:42\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/juli"
  timestamp: 1660014700
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # If the vector is empty, return empty\n    if length(arr) == 0\n    \
    \    return []\n    end\n    \n    # create an empty array to hold the indices\
    \ of the even numbers\n    even_nums = Int64[]\n    \n    # iterate through the\
    \ input array\n    for i in 1:length(arr)\n        # if the current value is even,\
    \ push it to the empty array\n        if arr[i] % 2 == 0\n            push!(even_nums,\
    \ arr[i])\n        end\n    end\n    \n    # if there are no even numbers, return\
    \ empty\n    if length(even_nums) == 0\n        return []\n    end\n    \n   \
    \ # get the min value of the even numbers\n    min_val = minimum(even_nums)\n\
    \    \n    # get the index of the min value\n    min_index = findfirst(arr .==\
    \ min_val)\n    \n    # return the smallest even value and its index\n    return\
    \ [min_val, min_index]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp6h5qa0y5.jl:67

    '
  stdout: "test set: Test Failed at /tmp/tmp6h5qa0y5.jl:70\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp6h5qa0y5.jl:70 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp6h5qa0y5.jl:69\ntest set: Test Failed at /tmp/tmp6h5qa0y5.jl:71\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6h5qa0y5.jl:71 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6h5qa0y5.jl:69\ntest set: Test\
    \ Failed at /tmp/tmp6h5qa0y5.jl:73\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp6h5qa0y5.jl:73 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp6h5qa0y5.jl:69\ntest set: Test Failed at /tmp/tmp6h5qa0y5.jl:74\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6h5qa0y5.jl:74 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6h5qa0y5.jl:69\ntest set: Test\
    \ Failed at /tmp/tmp6h5qa0y5.jl:75\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014700
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    #check for empty vector\n    if isempty(arr)\n        return []\n    end\n\
    \    #find the smallest even value\n    evens = filter(x -> mod(x, 2) == 0, arr)\n\
    \    #check for no evens\n    if isempty(evens)\n        return []\n    end\n\
    \    #find its index\n    index = findall(arr .== minimum(evens))[1]\n    #return\
    \ the value and its index\n    return [minimum(evens), index]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmprhuki3_3.jl:52

    '
  stdout: "test set: Test Failed at /tmp/tmprhuki3_3.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmprhuki3_3.jl:55 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmprhuki3_3.jl:54\ntest set: Test Failed at /tmp/tmprhuki3_3.jl:56\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmprhuki3_3.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprhuki3_3.jl:54\ntest set: Test\
    \ Failed at /tmp/tmprhuki3_3.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmprhuki3_3.jl:58 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmprhuki3_3.jl:54\ntest set: Test Failed at /tmp/tmprhuki3_3.jl:59\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmprhuki3_3.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprhuki3_3.jl:54\ntest set: Test\
    \ Failed at /tmp/tmprhuki3_3.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014700
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    #Check that the vector has at least one element\n    if length(arr) ==\
    \ 0\n        return []\n    end\n    #Get the min even value in the vector\n \
    \   minEven = minimum(filter(isEven, arr))\n    if minEven == Inf\n        return\
    \ []\n    end\n    #return the indices of the min even value\n    indices = findall(arr\
    \ .== minEven)\n    return [minEven, minimum(indices)]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 7 errored,
    0 broken.

    in expression starting at /tmp/tmp8j145sdi.jl:50

    '
  stdout: "test set: Error During Test at /tmp/tmp8j145sdi.jl:53\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  UndefVarError: isEven not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp8j145sdi.jl:40\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp8j145sdi.jl:53 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp8j145sdi.jl:52\ntest set:\
    \ Error During Test at /tmp/tmp8j145sdi.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  UndefVarError: isEven not defined\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp8j145sdi.jl:40\n   [2]\
    \ macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp8j145sdi.jl:54 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp8j145sdi.jl:52\ntest set:\
    \ Error During Test at /tmp/tmp8j145sdi.jl:56\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  UndefVarError: isEven not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp8j145sdi.jl:40\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp8j145sdi.jl:56 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp8j145sdi.jl:52\ntest set:\
    \ Error During Test at /tmp/tmp8j145sdi.jl:57\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n  UndefVarError: isEven not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp8j145sdi.jl:40\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib"
  timestamp: 1660014701
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    arr_even = arr[isodd.(arr)]\n\
    \    if isempty(arr_even)\n        return []\n    end\n    ind = minimum(findall(arr_even,\
    \ minimum(arr_even)))\n    return [arr_even[ind], ind]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 7 errored,
    0 broken.

    in expression starting at /tmp/tmptafenxrl.jl:47

    '
  stdout: "test set: Error During Test at /tmp/tmptafenxrl.jl:50\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findall(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findall(!Matched::Base.Fix2{typeof(in)},\
    \ ::Number) at ~/.conda/envs/polyglot/share/julia/base/array.jl:2318\n    findall(!Matched::Function,\
    \ ::Number) at ~/.conda/envs/polyglot/share/julia/base/array.jl:2317\n    findall(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:2253\n    ...\n \
    \ Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmptafenxrl.jl:42\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmptafenxrl.jl:50 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmptafenxrl.jl:49\ntest set:\
    \ Error During Test at /tmp/tmptafenxrl.jl:51\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findall(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findall(!Matched::Base.Fix2{typeof(in)},\
    \ ::Number) at ~/.conda/envs/polyglot/share/julia/base/array.jl:2318\n    findall(!Matched::Function,\
    \ ::Number) at ~/.conda/envs/polyglot/share/julia/base/array.jl:2317\n    findall(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:2253\n    ...\n \
    \ Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmptafenxrl.jl:42\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmptafenxrl.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmptafenxrl.jl:49\ntest set:\
    \ Error During Test at /tmp/tmptafenxrl.jl:53\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method "
  timestamp: 1660014702
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_arr = [x for x in arr if iseven(x)] \n    if isempty(even_arr) \n\
    \        return []\n    else\n        even_arr = sort(even_arr)\n        smallest_even\
    \ = even_arr[1]\n        index = findfirst(arr, smallest_even)\n        return\
    \ [smallest_even, index]\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp6ltsttgb.jl:47

    '
  stdout: "test set: Error During Test at /tmp/tmp6ltsttgb.jl:50\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp6ltsttgb.jl:41\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6ltsttgb.jl:50 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6ltsttgb.jl:49\ntest set:\
    \ Error During Test at /tmp/tmp6ltsttgb.jl:51\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp6ltsttgb.jl:41\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6ltsttgb.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6ltsttgb.jl:49\ntest set:\
    \ Error During Test at /tmp/tmp6ltsttgb.jl:53\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014701
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    return arr\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 7 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp5ez7iy1n.jl:39

    '
  stdout: "test set: Test Failed at /tmp/tmp5ez7iy1n.jl:42\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [4, 2, 3] == [2, 1]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5ez7iy1n.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5ez7iy1n.jl:41\ntest set: Test\
    \ Failed at /tmp/tmp5ez7iy1n.jl:43\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [1, 2, 3] == [2, 1]\nStacktrace:\n [1] macro expansion\n \
    \  @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp5ez7iy1n.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp5ez7iy1n.jl:41\ntest set: Test Failed at /tmp/tmp5ez7iy1n.jl:45\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [5, 0, 3,\
    \ 0, 4, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5ez7iy1n.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5ez7iy1n.jl:41\ntest set: Test\
    \ Failed at /tmp/tmp5ez7iy1n.jl:46\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [1, 2, 3, 0, 5, 3] == [0, 3]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5ez7iy1n.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5ez7iy1n.jl:41\ntest set: Test\
    \ Failed at /tmp/tmp5ez7iy1n.jl:47\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [5, 4, 8, 4, 8] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/en"
  timestamp: 1660014700
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    min_even, min_idx = first(arr),\
    \ 1\n    for i in 2:length(arr)\n        val = arr[i]\n        if iseven(val)\
    \ && val < min_even\n            min_even, min_idx = val, i\n        end\n   \
    \ end\n    return [min_even, min_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 7 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpw72karpb.jl:49

    '
  stdout: "test set: Test Failed at /tmp/tmpw72karpb.jl:52\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpw72karpb.jl:52 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpw72karpb.jl:51\ntest set: Test Failed at /tmp/tmpw72karpb.jl:53\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [1, 1] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpw72karpb.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpw72karpb.jl:51\ntest set: Test\
    \ Failed at /tmp/tmpw72karpb.jl:55\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpw72karpb.jl:55 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpw72karpb.jl:51\ntest set: Test Failed at /tmp/tmpw72karpb.jl:56\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpw72karpb.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpw72karpb.jl:51\ntest set: Test\
    \ Failed at /tmp/tmpw72karpb.jl:57\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014700
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    smallest = nothing\n    smallest_index = nothing\n    for (index, item)\
    \ in enumerate(arr)\n        if iseven(item)\n            if isnothing(smallest)\n\
    \                smallest = item\n                smallest_index = index\n   \
    \         elseif item < smallest\n                smallest = item\n          \
    \      smallest_index = index\n            end\n        end\n    end\n    return\
    \ isnothing(smallest) ? Vector{Int64}() : [smallest, smallest_index + 1]\nend\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3y0exqqx.jl:52

    '
  stdout: "test set: Test Failed at /tmp/tmp3y0exqqx.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 3] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp3y0exqqx.jl:55 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp3y0exqqx.jl:54\ntest set: Test Failed at /tmp/tmp3y0exqqx.jl:56\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 3] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3y0exqqx.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3y0exqqx.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp3y0exqqx.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 3] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp3y0exqqx.jl:58 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp3y0exqqx.jl:54\ntest set: Test Failed at /tmp/tmp3y0exqqx.jl:59\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 5] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3y0exqqx.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3y0exqqx.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp3y0exqqx.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 3] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014700
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpzehx0k64.jl:39

    '
  stdout: "test set: Test Failed at /tmp/tmpzehx0k64.jl:42\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpzehx0k64.jl:42 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpzehx0k64.jl:41\ntest set: Test Failed at /tmp/tmpzehx0k64.jl:43\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzehx0k64.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzehx0k64.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpzehx0k64.jl:45\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: Int64[] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpzehx0k64.jl:45 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpzehx0k64.jl:41\ntest set: Test Failed at /tmp/tmpzehx0k64.jl:46\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: Int64[]\
    \ == [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzehx0k64.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzehx0k64.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpzehx0k64.jl:47\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: Int64[] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1."
  timestamp: 1660014683
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    small_even_index = 0 \n    small_even_val = 0\n    found_even = false\n\
    \    for i = 1:length(arr)\n        if !found_even && rem(arr[i], 2) == 0\n  \
    \          small_even_index = i\n            small_even_val = arr[i]\n       \
    \     found_even = true\n        elseif found_even && rem(arr[i], 2) == 0 && arr[i]\
    \ < small_even_val\n            small_even_index = i\n            small_even_val\
    \ = arr[i]\n        end\n    end\n    if found_even\n        return [small_even_val,\
    \ small_even_index]\n    else\n        return []\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp0k3wrtq3.jl:56

    '
  stdout: "test set: Test Failed at /tmp/tmp0k3wrtq3.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp0k3wrtq3.jl:59 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp0k3wrtq3.jl:58\ntest set: Test Failed at /tmp/tmp0k3wrtq3.jl:60\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0k3wrtq3.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0k3wrtq3.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp0k3wrtq3.jl:62\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp0k3wrtq3.jl:62 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp0k3wrtq3.jl:58\ntest set: Test Failed at /tmp/tmp0k3wrtq3.jl:63\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0k3wrtq3.jl:63 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0k3wrtq3.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp0k3wrtq3.jl:64\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014701
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    vals = [arr[i] for i in 1:length(arr) if arr[i] % 2 == 0]\n    if isempty(vals)\n\
    \        return []\n    else\n        val = minimum(vals)\n        return [val,\
    \ findfirst(arr, val)[1]]\n    end\nend\n \n \n\"\"\"\n    \"Given a vector representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest odd value.\n    If multiple nodes with the same smallest odd\
    \ value are found return the node that has smallest index.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkxks4veh.jl:45\nin expression starting at\
    \ /tmp/tmpkxks4veh.jl:45\n"
  stdout: ''
  timestamp: 1660014699
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # Find the smallest even number \n    min_even = zero(Int64)\n    min_index\
    \ = zero(Int64)\n    is_empty = true\n    for i in 1:length(arr)\n        if arr[i]\
    \ % 2 == 0 && (is_empty || arr[i] < min_even)\n            min_even = arr[i]\n\
    \            min_index = i\n            is_empty = false\n        end\n    end\n\
    \    if is_empty\n        return []\n    else\n        return [min_even, min_index]\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp6vli9h6u.jl:54

    '
  stdout: "test set: Test Failed at /tmp/tmp6vli9h6u.jl:57\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp6vli9h6u.jl:57 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp6vli9h6u.jl:56\ntest set: Test Failed at /tmp/tmp6vli9h6u.jl:58\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6vli9h6u.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6vli9h6u.jl:56\ntest set: Test\
    \ Failed at /tmp/tmp6vli9h6u.jl:60\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp6vli9h6u.jl:60 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp6vli9h6u.jl:56\ntest set: Test Failed at /tmp/tmp6vli9h6u.jl:61\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6vli9h6u.jl:61 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6vli9h6u.jl:56\ntest set: Test\
    \ Failed at /tmp/tmp6vli9h6u.jl:62\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014701
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\n \nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmphcrxr6zb.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmphcrxr6zb.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmphcrxr6zb.jl:36\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmphcrxr6zb.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmphcrxr6zb.jl:42\ntest set:\
    \ Error During Test at /tmp/tmphcrxr6zb.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmphcrxr6zb.jl:36\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmphcrxr6zb.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/s"
  timestamp: 1660014703
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    arr_sorted = sort(arr)\n    for i in 1:length(arr_sorted)\n        if\
    \ arr_sorted[i] % 2 == 0\n            return [arr_sorted[i], findall(arr .== arr_sorted[i])[1]]\n\
    \        end\n    end\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpswm12q_x.jl:45

    '
  stdout: "test set: Test Failed at /tmp/tmpswm12q_x.jl:48\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpswm12q_x.jl:48 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpswm12q_x.jl:47\ntest set: Test Failed at /tmp/tmpswm12q_x.jl:49\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpswm12q_x.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpswm12q_x.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpswm12q_x.jl:51\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpswm12q_x.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpswm12q_x.jl:47\ntest set: Test Failed at /tmp/tmpswm12q_x.jl:52\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpswm12q_x.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpswm12q_x.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpswm12q_x.jl:53\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014701
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # TODO: implement\nend\n \n \nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpw_4uxu0o.jl:41

    '
  stdout: "test set: Error During Test at /tmp/tmpw_4uxu0o.jl:44\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpw_4uxu0o.jl:36\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpw_4uxu0o.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpw_4uxu0o.jl:43\ntest set:\
    \ Error During Test at /tmp/tmpw_4uxu0o.jl:45\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpw_4uxu0o.jl:36\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpw_4uxu0o.jl:45 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/s"
  timestamp: 1660014703
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    return find_even(arr) == 0 ? [] : find_even(arr)\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmptirc0et6.jl:39

    '
  stdout: "test set: Error During Test at /tmp/tmptirc0et6.jl:42\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  UndefVarError: find_even not\
    \ defined\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmptirc0et6.jl:35\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmptirc0et6.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmptirc0et6.jl:41\ntest set:\
    \ Error During Test at /tmp/tmptirc0et6.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  UndefVarError: find_even not defined\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmptirc0et6.jl:35\n   [2]\
    \ macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmptirc0et6.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmptirc0et6.jl:41\ntest set:\
    \ Error During Test at /tmp/tmptirc0et6.jl:44\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  UndefVarError: find_even\
    \ not defined\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmptirc0et6.jl:35\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmptirc0et6.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmptirc0et6.jl:41\ntest set:\
    \ Error During Test at /tmp/tmptirc0et6.jl:45\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  UndefVarError: find_even not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmptirc0et6.jl:35\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyg"
  timestamp: 1660014702
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0 return [] end\n    evens = []\n    for (n, x) in enumerate(arr)\n\
    \        if x % 2 == 0 push!(evens, [x, n]) end\n    end\n    if length(evens)\
    \ == 0 return [] end\n    sort!(evens, by = x -> (x[1], x[2]))\n    return evens[1]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpwbs7ao3x.jl:46

    '
  stdout: "test set: Test Failed at /tmp/tmpwbs7ao3x.jl:49\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpwbs7ao3x.jl:49 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpwbs7ao3x.jl:48\ntest set: Test Failed at /tmp/tmpwbs7ao3x.jl:50\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwbs7ao3x.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwbs7ao3x.jl:48\ntest set: Test\
    \ Failed at /tmp/tmpwbs7ao3x.jl:52\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpwbs7ao3x.jl:52 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpwbs7ao3x.jl:48\ntest set: Test Failed at /tmp/tmpwbs7ao3x.jl:53\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwbs7ao3x.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwbs7ao3x.jl:48\ntest set: Test\
    \ Failed at /tmp/tmpwbs7ao3x.jl:54\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014701
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    if any(x -> x % 2\
    \ == 0, arr)\n        nums = [y[1] for y in enumerate(arr) if y[2] % 2 == 0]\n\
    \        values = sort(nums, by = x -> x[2])\n        return values[1]\n    else\n\
    \        return []\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpxajwlfqi.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpxajwlfqi.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  BoundsError\n  Stacktrace:\n\
    \    [1] getindex\n      @ ./number.jl:98 [inlined]\n    [2] #4\n      @ /tmp/tmpxajwlfqi.jl:40\
    \ [inlined]\n    [3] lt\n      @ ./ordering.jl:111 [inlined]\n    [4] sort!(v::Vector{Int64},\
    \ lo::Int64, hi::Int64, #unused#::Base.Sort.InsertionSortAlg, o::Base.Order.By{var\"\
    #4#8\", Base.Order.ForwardOrdering})\n      @ Base.Sort ./sort.jl:507\n    [5]\
    \ sort!(v::Vector{Int64}, lo::Int64, hi::Int64, a::Base.Sort.QuickSortAlg, o::Base.Order.By{var\"\
    #4#8\", Base.Order.ForwardOrdering})\n      @ Base.Sort ./sort.jl:574\n    [6]\
    \ sort!\n      @ ./sort.jl:664 [inlined]\n    [7] #sort!#8\n      @ ./sort.jl:725\
    \ [inlined]\n    [8] #sort#9\n      @ ./sort.jl:772 [inlined]\n    [9] pluck(arr::Vector{Int64})\n\
    \      @ Main /tmp/tmpxajwlfqi.jl:40\n   [10] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [11] macro expansion\n      @ /tmp/tmpxajwlfqi.jl:51 [inlined]\n\
    \   [12] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [13] top-level scope\n      @ /tmp/tmpxajwlfqi.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpxajwlfqi.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n \
    \   convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpxajwlfqi.jl:41\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [in"
  timestamp: 1660014703
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    v = []\n    i = 0\n\
    \    for (j,val) in enumerate(arr)\n        if val % 2 == 0\n            if length(v)\
    \ == 0\n                v = [val, j]\n            elseif val < v[1]\n        \
    \        v = [val, j]\n            end\n        end\n    end\n    return v\nend\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpn0xd1qvl.jl:53

    '
  stdout: "test set: Test Failed at /tmp/tmpn0xd1qvl.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpn0xd1qvl.jl:56 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpn0xd1qvl.jl:55\ntest set: Test Failed at /tmp/tmpn0xd1qvl.jl:57\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpn0xd1qvl.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpn0xd1qvl.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpn0xd1qvl.jl:59\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpn0xd1qvl.jl:59 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpn0xd1qvl.jl:55\ntest set: Test Failed at /tmp/tmpn0xd1qvl.jl:60\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpn0xd1qvl.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpn0xd1qvl.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpn0xd1qvl.jl:61\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014702
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    #1. For every element in arr, check if it is even.\n    #2. If even, add\
    \ to new array of evens.\n    #3. Select the minimum value of evens.\n    #4.\
    \ Return the minimum value, and its index in the original array.\n    evens =\
    \ filter(x -> x % 2 == 0, arr) #step 1 and 2\n    min_index = findmin(evens)[2]\n\
    \    min_value = evens[min_index]\n    return [min_value, findfirst(x -> x ==\
    \ min_value, arr)] #step 3 and 4\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 2 errored,
    0 broken.

    in expression starting at /tmp/tmpud3kvivq.jl:46

    '
  stdout: "test set: Test Failed at /tmp/tmpud3kvivq.jl:49\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpud3kvivq.jl:49 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpud3kvivq.jl:48\ntest set: Test Failed at /tmp/tmpud3kvivq.jl:50\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpud3kvivq.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpud3kvivq.jl:48\ntest set: Error\
    \ During Test at /tmp/tmpud3kvivq.jl:51\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  ArgumentError: reducing\
    \ over an empty collection is not allowed\n  Stacktrace:\n    [1] _empty_reduce_error()\n\
    \      @ Base ./reduce.jl:301\n    [2] mapreduce_empty(f::Function, op::Base.BottomRF{typeof(Base._rf_findmin)},\
    \ T::Type)\n      @ Base ./reduce.jl:344\n    [3] reduce_empty(op::Base.MappingRF{Base.var\"\
    #262#263\"{typeof(identity)}, Base.BottomRF{typeof(Base._rf_findmin)}}, #unused#::Type{Pair{Int64,\
    \ Int64}})\n      @ Base ./reduce.jl:331\n    [4] reduce_empty_iter\n      @ ./reduce.jl:357\
    \ [inlined]\n    [5] reduce_empty_iter\n      @ ./reduce.jl:356 [inlined]\n  \
    \  [6] foldl_impl\n      @ ./reduce.jl:49 [inlined]\n    [7] mapfoldl_impl\n \
    \     @ ./reduce.jl:44 [inlined]\n    [8] #mapfoldl#244\n      @ ./reduce.jl:162\
    \ [inlined]\n    [9] mapfoldl\n      @ ./reduce.jl:162 [inlined]\n   [10] findmin\n\
    \      @ ./reduce.jl:862 [inlined]\n   [11] _findmin\n      @ ./reduce.jl:888\
    \ [inlined]\n   [12] #findmin#783\n      @ ./reducedim.jl:1005 [inlined]\n   [13]\
    \ findmin\n      @ ./reducedim.jl:1005 [inlined]\n   [14] p"
  timestamp: 1660014704
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    min_even = nothing\n    min_index = nothing\n    for (i, v) in enumerate(arr)\n\
    \        if v % 2 == 0\n            if min_even == nothing || v < min_even\n \
    \               min_even = v\n                min_index = i\n            end\n\
    \        end\n    end\n    return (min_even == nothing) ? Vector{Int64}() : [min_even,\
    \ min_index + 1]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp9fb61lyw.jl:49

    '
  stdout: "test set: Test Failed at /tmp/tmp9fb61lyw.jl:52\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 3] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp9fb61lyw.jl:52 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp9fb61lyw.jl:51\ntest set: Test Failed at /tmp/tmp9fb61lyw.jl:53\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 3] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9fb61lyw.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9fb61lyw.jl:51\ntest set: Test\
    \ Failed at /tmp/tmp9fb61lyw.jl:55\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 3] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp9fb61lyw.jl:55 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp9fb61lyw.jl:51\ntest set: Test Failed at /tmp/tmp9fb61lyw.jl:56\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 5] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9fb61lyw.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9fb61lyw.jl:51\ntest set: Test\
    \ Failed at /tmp/tmp9fb61lyw.jl:57\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 3] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014703
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # Write your code here\n    return zeros(2)\nend\n \nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 8 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3t61f48v.jl:41

    '
  stdout: "test set: Test Failed at /tmp/tmp3t61f48v.jl:44\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [0, 0] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp3t61f48v.jl:44 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp3t61f48v.jl:43\ntest set: Test Failed at /tmp/tmp3t61f48v.jl:45\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [0, 0] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3t61f48v.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3t61f48v.jl:43\ntest set: Test\
    \ Failed at /tmp/tmp3t61f48v.jl:46\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [0, 0] == Int64[]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3t61f48v.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3t61f48v.jl:43\ntest set: Test\
    \ Failed at /tmp/tmp3t61f48v.jl:47\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 0] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp3t61f48v.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp3t61f48v.jl:43\ntest set: Test Failed at /tmp/tmp3t61f48v.jl:48\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 0] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/s"
  timestamp: 1660014703
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    empty = Vector{Int64}()\n    index = 1\n    min = 10001\n    if isempty(arr)\n\
    \        return empty\n    end\n    for i in 1:length(arr)\n        if arr[i]%2\
    \ == 0\n            if min > arr[i]\n                min = arr[i]\n          \
    \      index = i\n            end\n        end\n    end\n    if min != 10001\n\
    \        return [min, index]\n    else\n        return empty\n    end\nend\n\"\
    \"\"\n    \"Given a string s and an integer k.\n    Return the maximum number\
    \ of vowel letters in any substring of s with length k.\n    Vowel letters in\
    \ English are (a, e, i, o, u).\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpuecylk8l.jl:55\nin expression starting at\
    \ /tmp/tmpuecylk8l.jl:55\n"
  stdout: ''
  timestamp: 1660014702
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    @inbounds for i in 1:length(arr)\n\
    \        if arr[i] % 2 == 0\n            return [arr[i], i]\n        end\n   \
    \ end\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmppd5a1doe.jl:47

    '
  stdout: "test set: Test Failed at /tmp/tmppd5a1doe.jl:50\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [4, 1] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmppd5a1doe.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmppd5a1doe.jl:49\ntest set: Test Failed at /tmp/tmppd5a1doe.jl:51\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppd5a1doe.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppd5a1doe.jl:49\ntest set: Test\
    \ Failed at /tmp/tmppd5a1doe.jl:53\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmppd5a1doe.jl:53 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmppd5a1doe.jl:49\ntest set: Test Failed at /tmp/tmppd5a1doe.jl:54\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [2, 2] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppd5a1doe.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppd5a1doe.jl:49\ntest set: Test\
    \ Failed at /tmp/tmppd5a1doe.jl:55\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014703
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # TODO: write the pluck function\nend\n```\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: invalid \"`\" syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqdfp5t4l.jl:37\nin expression starting at\
    \ /tmp/tmpqdfp5t4l.jl:37\n"
  stdout: ''
  timestamp: 1660014702
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    if length(arr) == 0\n        return []\n    end\n    \n    evens\
    \ = filter(x -> x % 2 == 0, arr)\n    \n    if length(evens) == 0\n        return\
    \ []\n    end\n    \n    value = minimum(evens)\n    idx = findfirst(arr .== value)\n\
    \    \n    return [value, idx]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp_o5ry_qs.jl:53

    '
  stdout: "test set: Test Failed at /tmp/tmp_o5ry_qs.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp_o5ry_qs.jl:56 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp_o5ry_qs.jl:55\ntest set: Test Failed at /tmp/tmp_o5ry_qs.jl:57\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_o5ry_qs.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_o5ry_qs.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp_o5ry_qs.jl:59\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp_o5ry_qs.jl:59 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp_o5ry_qs.jl:55\ntest set: Test Failed at /tmp/tmp_o5ry_qs.jl:60\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_o5ry_qs.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_o5ry_qs.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp_o5ry_qs.jl:61\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014703
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # If vector is empty return [], else continue on.\n    if isempty(arr)\n\
    \        return []\n    end\n    \n    # Get all even values from the vector and\
    \ store them in a new vector:\n    evens = [i for i in arr if i % 2 == 0]\n  \
    \  \n    # Find the minimum value in the evens vector,\n    # if all the values\
    \ in the evens vector are greater than 0 return the minimum,\n    # else return\
    \ [].\n    min_even = (minimum(evens) > 0) ? minimum(evens) : []\n    \n    #\
    \ If min_even is not an empty array return the minimum of the evens vector and\
    \ its index,\n    # else return an empty array.\n    if !isempty(min_even)\n \
    \       return [min_even, findfirst(arr, min_even)]\n    else\n        return\
    \ []\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 2 failed, 5 errored,
    0 broken.

    in expression starting at /tmp/tmph4ogzjy7.jl:58

    '
  stdout: "test set: Error During Test at /tmp/tmph4ogzjy7.jl:61\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmph4ogzjy7.jl:51\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmph4ogzjy7.jl:61 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmph4ogzjy7.jl:60\ntest set:\
    \ Error During Test at /tmp/tmph4ogzjy7.jl:62\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmph4ogzjy7.jl:51\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmph4ogzjy7.jl:62 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmph4ogzjy7.jl:60\ntest set:\
    \ Test Failed at /tmp/tmph4ogzjy7.jl:64\n  Expression: candidate([5, 0, 3, 0,\
    \ 4, 2]) == [0, 1]\n   Evaluated: Int64[] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2]"
  timestamp: 1660014705
- exit_code: -1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \"\"\"\n    Returns the smallest even node in a vector, if no even nodes\
    \ are found returns [].\n    \"\"\"\n    plucked_index = 0\n    plucked_value\
    \ = 0\n    for i in enumerate(arr)\n        if i % 2 == 0\n            plucked_index\
    \ = i[1]\n            plucked_value = i[2]\n            break\n        end\n \
    \   end\n    return [plucked_value, plucked_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: Timeout
  stderr: 'ERROR: LoadError: '
  stdout: "test set: Error During Test at /tmp/tmpeeulrjuc.jl:54\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ rem(::Tuple{Int64, Int64}, ::Int64)\n  Closest candidates are:\n    rem(::Any,\
    \ ::Any, !Matched::RoundingMode{:ToZero}) at ~/.conda/envs/polyglot/share/julia/base/div.jl:80\n\
    \    rem(::Any, ::Any, !Matched::RoundingMode{:Down}) at ~/.conda/envs/polyglot/share/julia/base/div.jl:81\n\
    \    rem(::Any, ::Any, !Matched::RoundingMode{:Up}) at ~/.conda/envs/polyglot/share/julia/base/div.jl:82\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpeeulrjuc.jl:41\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpeeulrjuc.jl:54 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpeeulrjuc.jl:53\ntest set:\
    \ Error During Test at /tmp/tmpeeulrjuc.jl:55\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching rem(::Tuple{Int64,\
    \ Int64}, ::Int64)\n  Closest candidates are:\n    rem(::Any, ::Any, !Matched::RoundingMode{:ToZero})\
    \ at ~/.conda/envs/polyglot/share/julia/base/div.jl:80\n    rem(::Any, ::Any,\
    \ !Matched::RoundingMode{:Down}) at ~/.conda/envs/polyglot/share/julia/base/div.jl:81\n\
    \    rem(::Any, ::Any, !Matched::RoundingMode{:Up}) at ~/.conda/envs/polyglot/share/julia/base/div.jl:82\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpeeulrjuc.jl:41\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpeeulrjuc.jl:55 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpeeulrjuc.jl:53\ntest set:\
    \ Test Failed at /tmp/tmpeeulrjuc.jl:56\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [0, "
  timestamp: 1660014705
- exit_code: 1
  program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    i = 0\n    small = arr[1]\n    while i < length(arr)\n        if arr[i]\
    \ % 2 == 0\n            if small > arr[i]\n                small = arr[i]\n  \
    \          end\n        end\n        i += 1\n    end\n    if small % 2 == 0\n\
    \        return [small, findfirst(arr, small)]\n    else\n        return []\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmp6eik3gf0.jl:53

    '
  stdout: "test set: Error During Test at /tmp/tmp6eik3gf0.jl:56\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  BoundsError: attempt to access\
    \ 3-element Vector{Int64} at index [0]\n  Stacktrace:\n   [1] getindex\n     @\
    \ ./array.jl:861 [inlined]\n   [2] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp6eik3gf0.jl:38\n\
    \   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp6eik3gf0.jl:56 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp6eik3gf0.jl:55\ntest set:\
    \ Error During Test at /tmp/tmp6eik3gf0.jl:57\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  BoundsError: attempt to access 3-element Vector{Int64}\
    \ at index [0]\n  Stacktrace:\n   [1] getindex\n     @ ./array.jl:861 [inlined]\n\
    \   [2] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp6eik3gf0.jl:38\n   [3]\
    \ macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp6eik3gf0.jl:57 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp6eik3gf0.jl:55\ntest set:\
    \ Error During Test at /tmp/tmp6eik3gf0.jl:58\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError: attempt to\
    \ access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1] getindex\n\
    \     @ ./array.jl:861 [inlined]\n   [2] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmp6eik3gf0.jl:36\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp6eik3gf0.jl:58 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp6eik3gf0.jl:55\ntest set:\
    \ Error During Test at /tmp/tmp6eik3gf0.jl:59\n  Test thr"
  timestamp: 1660014704
