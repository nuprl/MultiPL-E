name: HumanEval_6_parse_nested_parens
language: jl
prompt: "\"\"\" Input to this function is a string represented multiple groups for\
  \ nested parentheses separated by spaces.\n    For each of the group, output the\
  \ deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels\
  \ of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"(()()) ((()))\
  \ () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
  (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
  \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
  end\n"
completions: ["    level_vector = []\n    depth = 0\n    for paren in paren_string\n\
    \        if paren == '('\n            depth += 1\n        elseif paren == ')'\n\
    \            level_vector = [level_vector; depth]\n            depth -= 1\n  \
    \      end\n    end\n    return level_vector\nend", "    # Initialize a vector\
    \ of zeros.\n    levels = zeros(Int64, count(isspace, paren_string))\n    # Initialize\
    \ a counter for the group and a counter for the current level of nesting.\n  \
    \  group_count = 1\n    level_count = 0\n    # Loop through the string.\n    for\
    \ i = 1:length(paren_string)\n        if paren_string[i] == '('\n            #\
    \ If an open paren, increment the level.\n            level_count += 1\n     \
    \   elseif paren_string[i] == ')'\n            # If a closed paren, increment\
    \ the level.\n            level_count -= 1\n        elseif paren_string[i] ==\
    \ ' '\n            # If a space, store the level and reset it to zero.\n     \
    \       levels[group_count] = level_count\n            level_count = 0\n     \
    \       group_count += 1\n        end\n    end\n    return levels\nend\nlevels\
    \ = parse_nested_parens(\"(()()) ((())) () ((())()())\")", "    paren_strings\
    \ = split(paren_string, \" \")\n    return [find_max_paren_depth(paren_str) for\
    \ paren_str in paren_strings]\nend\n    \n# We loop through a string and keep\
    \ track of the current level of nesting and the max seen so far.\n# In the for\
    \ loop, we check the next parentheses and increment our level of nesting if the\
    \ current char is an open paren and the next char is a close paren.\n# Otherwise,\
    \ we increment the current level of nesting by 1 if we see an open paren, and\
    \ decrement it by 1 if we see a close paren.", "    paren_split = split(paren_string,\
    \ \" \")\n    max_paren_depth = Vector{Int64}(length(paren_split))\n    for i\
    \ in eachindex(paren_split)\n        parens = paren_split[i]\n        depth =\
    \ Int64(0)\n        max_depth = Int64(0)\n        for c in parens\n          \
    \  if c == '('\n                depth += 1\n            elseif c == ')'\n    \
    \            depth -= 1\n            end\n            if depth > max_depth\n \
    \               max_depth = depth\n            end\n        end\n        max_paren_depth[i]\
    \ = max_depth\n    end\n    return max_paren_depth\nend", "    stack = Int64[]\
    \ # a stack for storing the count of parens for each group\n    current_group_count\
    \ = 0 # the deepest level of parens for the current group\n    for c in paren_string\n\
    \        if c == '('\n            current_group_count += 1\n        elseif c ==\
    \ ')'\n            current_group_count -= 1\n        elseif c == ' '\n       \
    \     # we've reached the end of a group; save its count and start a new one\n\
    \            push!(stack, current_group_count)\n            current_group_count\
    \ = 0\n        end\n    end\n    return stack\nend", "    \n    parsed_nested_levels\
    \ = Vector{Int64}()\n    \n    for g in split(paren_string, \" \")\n        curr_level\
    \ = 0\n        max_level = 0\n        for p in g\n            if p == '('\n  \
    \              curr_level += 1\n            elseif p == ')'\n                curr_level\
    \ -= 1\n            end\n            if curr_level > max_level\n             \
    \   max_level = curr_level\n            end\n        end\n        push!(parsed_nested_levels,\
    \ max_level)\n    end\n    return parsed_nested_levels\nend", "    paren_groups\
    \ = split(paren_string)\n    max_nest_levels = zeros(length(paren_groups))\n \
    \   for (i, paren_group) in enumerate(paren_groups)\n        paren_group_len =\
    \ length(paren_group)\n        paren_stack = []\n        curr_max_nest_level =\
    \ 0\n        curr_nest_level = 0\n        for k = 1:paren_group_len\n        \
    \    curr_char = paren_group[k]\n            if curr_char == '('\n           \
    \     push!(paren_stack, curr_char)\n                curr_nest_level += 1\n  \
    \              if curr_nest_level > curr_max_nest_level\n                    curr_max_nest_level\
    \ = curr_nest_level\n                end\n            elseif curr_char == ')'\n\
    \                pop!(paren_stack)\n                curr_nest_level -= 1\n   \
    \         end\n        end\n        max_nest_levels[i] = curr_max_nest_level\n\
    \    end\n    return max_nest_levels\nend", "    # base case is empty string (no\
    \ input)\n    if paren_string == \"\"\n        return []\n    end\n    \n    #\
    \ remove space between groups and split using space\n    space_removed = replace(paren_string,\
    \ \" \" => \"\")\n    split_parens = split(space_removed, \"\")", "    n_parens_list\
    \ = []\n    for paren_group in split(paren_string, \" \")\n        n_parens =\
    \ 0\n        n_parens_list_len = length(n_parens_list)\n        for paren in paren_group\n\
    \            if paren == '('\n                push!(n_parens_list, n_parens)\n\
    \                n_parens += 1\n            elseif paren == ')'\n            \
    \    n_parens = pop!(n_parens_list)\n            end\n        end\n        push!(n_parens_list,\
    \ n_parens)\n    end\n    if length(n_parens_list) > n_parens_list_len\n     \
    \   return n_parens_list[(n_parens_list_len+1):end]\n    else\n        return\
    \ []\n    end\nend", "    paren_groups = split(paren_string, \" \")\n    output\
    \ = Vector{Int64}(undef, length(paren_groups))\n    for i in 1:length(paren_groups)\n\
    \        group = paren_groups[i]\n        depth = 0\n        max_depth = 0\n \
    \       for paren in group\n            if paren == '('\n                depth\
    \ += 1\n            elseif paren == ')'\n                depth -= 1\n        \
    \    end\n            max_depth = max(max_depth, depth)\n        end\n       \
    \ output[i] = max_depth\n    end\n    return output\nend", "    \n    # Create\
    \ an array of the splitted string\n    paren_groups = split(paren_string, \" \"\
    )\n    \n    # Array to hold the depth values\n    depth_values = []\n    \n \
    \   # Iterate over the groups to find the deepest level of nesting\n    for group\
    \ in paren_groups\n        depth = 0\n        depth_temp = 0\n        for character\
    \ in group\n            if character == '('\n                depth_temp += 1\n\
    \            elseif character == ')'\n                depth_temp -= 1\n      \
    \      end\n            if depth_temp > depth\n                depth = depth_temp\n\
    \            end\n        end\n        push!(depth_values, depth)\n    end\n \
    \   \n    return depth_values\nend", "    paren_list = split(paren_string, \"\
    \ \")\n    results = Vector{Int64}()\n    for paren in paren_list\n        level\
    \ = 0\n        max_level = 0\n        for i in 1:length(paren)\n            if\
    \ paren[i] == '('\n                level += 1\n            elseif paren[i] ==\
    \ ')'\n                level -= 1\n            end\n            if level > max_level\n\
    \                max_level = level\n            end\n        end\n        push!(results,\
    \ max_level)\n    end\n    return results\nend", "    parse_nested_parens(paren_string)\
    \ = map(group -> sum(map(paren -> paren == '(' ? 1 : -1, group)), \n         \
    \                                    split(paren_string, r\"[ ]+\"))\nend", " \
    \   max_levels = Vector{Int64}()\n    open_paren_positions = Stack{Int64}()\n\
    \    for i in 1:length(paren_string)\n        if paren_string[i] == '('\n    \
    \        push!(open_paren_positions, i)\n        elseif paren_string[i] == ')'\n\
    \            open_paren_index = pop!(open_paren_positions)\n            max_levels\
    \ = [max_levels; i - open_paren_index]\n        end\n    end\n    return max_levels\n\
    end", "    # Vector to hold the max depth for each group\n    depths = Int64[]\n\
    \    depth = 0  # intital depth\n    # Go through each character of the string\n\
    \    for i = 1:length(paren_string)\n        # If char is open paren, increase\
    \ depth \n        if paren_string[i] == '('\n            depth += 1\n        #\
    \ If char is close paren, decrease depth and append to the vector of depths\n\
    \        elseif paren_string[i] == ')'\n            depth -= 1\n            push!(depths,\
    \ depth)\n        # If char is space, reset depth to 0\n        else\n       \
    \     depth = 0\n        end\n    end\n    return depths\nend", "    paren_array\
    \ = split(paren_string, \" \")\n    depth_array = Vector{Int64}(length(paren_array))\n\
    \    for i in 1:length(paren_array)\n        depth_array[i] = max_depth(paren_array[i])\n\
    \    end\n    return depth_array\nend", "    # get the individual input string\
    \ for each of the group\n    input_groups = split(paren_string, \" \")", "   \
    \ groups = split(paren_string, \" \")\n    return [max_depth(g) for g in groups]\n\
    end", "    paren_string = strip(paren_string)\n    paren_arr = split(paren_string,\
    \ \" \")\n    result = zeros(Int64, length(paren_arr))\n    for i in 1:length(paren_arr)\n\
    \        paren_vec = collect(paren_arr[i])\n        if paren_vec[1] != '('\n \
    \           continue\n        end\n        depth = 0\n        max_depth = 0\n\
    \        for j in 1:length(paren_vec)\n            if paren_vec[j] == '('\n  \
    \              depth += 1\n            elseif paren_vec[j] == ')'\n          \
    \      depth -= 1\n            end\n            if depth > max_depth\n       \
    \         max_depth = depth\n            end\n        end\n        result[i] =\
    \ max_depth\n    end\n    return result\nend", "    # create a list of all the\
    \ parens\n    paren_list = split(paren_string, ' ')\n    # for each paren_group\
    \ in paren_list\n    paren_length = map(x -> length(x), paren_list)\n    vals\
    \ = map(x -> parse_one_paren(x), paren_list)\n    return vals\nend", "    return\
    \ paren_string\n        |> split\n        |> map(x -> max(1, find_nested_parens(x)))\n\
    end", "    return count_levels(split(paren_string, \" \"))\nend", "    paren_strs\
    \ = split(paren_string, \" \")\n    return [parse_single_parens(p) for p in paren_strs]\n\
    end", "    (max_depth = 0, depth = 0, max_depths = []) = (0, 0, [])\n    for paren\
    \ in paren_string\n        if paren == '('\n            depth += 1\n         \
    \   max_depth = max(max_depth, depth)\n        elseif paren == ')'\n         \
    \   depth -= 1\n        else\n            push!(max_depths, max_depth)\n     \
    \       (max_depth, depth) = (0, 0)\n        end\n    end\n    return max_depths\n\
    end", "    # Vector{Int64} to store the maximum level of nesting of parentheses\n\
    \    paren_levels = Int64[]", "    return [deepest_parens(i) for i in split(paren_string,\
    \ \" \")]\nend\n#Test\nparse_nested_parens(\"(()()) ((())) () ((())()())\")",
  "    paren_strings = split(paren_string, ' ')\n    return [depth_nested_parens(s)\
    \ for s in paren_strings]\nend", "    n = length(paren_string)\n    paren_count\
    \ = 0\n    max_nesting = 0\n    nesting_arr = zeros(Int64, length(paren_string))\n\
    \    paren_cnt = 0\n    for i = 1:n\n        if paren_string[i] == '('\n     \
    \       paren_cnt += 1\n            if paren_cnt > max_nesting\n             \
    \   max_nesting = paren_cnt\n            end\n        elseif paren_string[i] ==\
    \ ')'\n            paren_cnt -= 1\n        end\n        nesting_arr[i] = paren_cnt\n\
    \    end\n    #println(max_nesting)\n    #println(nesting_arr)\n    return nesting_arr\n\
    end", "    paren_groups = split(paren_string, \" \")\n    for paren_group in paren_groups\n\
    \        println(parse_nested_parens_helper(paren_group))\n    end\nend", "  \
    \  n = length(paren_string)\n    current_level = 0 # current level of nested parentheses\n\
    \    max_level = 0 # maximum level of nested parentheses so far\n    max_level_list\
    \ = Vector{Int64}() # to store the maximum level of nested parentheses for each\
    \ group\n    for i in 1:n\n        if paren_string[i] == '('\n            current_level\
    \ += 1\n            if current_level > max_level\n                max_level =\
    \ current_level\n            end\n        elseif paren_string[i] == ')'\n    \
    \        current_level -= 1\n        elseif paren_string[i] == ' '\n         \
    \   push!(max_level_list, max_level)\n            max_level = 0\n            current_level\
    \ = 0\n        end\n    end\n    push!(max_level_list, max_level)\n    return\
    \ max_level_list\nend", "    stack = Int64[] # stack to store the group number\n\
    \    res = Vector{Int64}() # contains the deepnest value for each group\n    level\
    \ = 0 # the depth of current group\n    for s in paren_string\n        if s ==\
    \ '('\n            push!(stack, level + 1)\n            level += 1\n        elseif\
    \ s == ')'\n            pop!(stack)\n            level -= 1\n        elseif s\
    \ == ' '\n            push!(res, level)\n            level = 0\n        end\n\
    \    end\n    push!(res, level)\n    return res\nend", "    depth = 0\n    max_depth\
    \ = 0\n    paren_depth = []\n    append!(paren_depth, 0)\n    for paren in paren_string\n\
    \        if paren == '('\n            depth += 1\n            if depth > max_depth\n\
    \                max_depth = depth\n            end\n        elseif paren == ')'\n\
    \            append!(paren_depth, max_depth)\n            depth -= 1\n       \
    \ end\n    end\n    paren_depth\nend", "    paren_groups = split(paren_string,\
    \ \" \")\n    max_nesting = 0\n    nesting_levels = zeros(Int64, length(paren_groups))\n\
    \    for i in 1:length(paren_groups)\n        group = paren_groups[i]\n      \
    \  group_max_nesting = 0\n        paren_stack = Array{Any}(0)\n        for c in\
    \ group\n            if c == '('\n                push!(paren_stack, '(')\n  \
    \              group_max_nesting += 1\n            elseif c == ')'\n         \
    \       pop!(paren_stack)\n                group_max_nesting -= 1\n          \
    \  end\n        end\n        nesting_levels[i] = group_max_nesting\n    end\n\
    \    return nesting_levels\nend", "    levels_vec = Int64[] #vector to store the\
    \ max nesting level of each group\n    paren_string = paren_string * \" \" #create\
    \ a space between groups\n    level = 0 #current level of nesting\n    for i =\
    \ 1:length(paren_string)\n        if paren_string[i] == '('\n            level\
    \ += 1\n        elseif paren_string[i] == ')'\n            level -= 1\n      \
    \  elseif paren_string[i] == ' '\n            push!(levels_vec, level)\n     \
    \       level = 0\n        end\n    end\n    return levels_vec\nend", "    # create\
    \ a stack\n    paren_stack = Stack()\n    nest_levels = Vector{Int64}()", "  \
    \  v = Vector{Int64}()\n    for p in split(paren_string)\n        v = push!(v,\
    \ parse_nested_parens_helper(p))\n    end\n    return v\nend", "    paren_array\
    \ = split(paren_string, \" \")\n    paren_levels = Vector{Int64}(undef, length(paren_array))\n\
    \    for (index, group) in enumerate(paren_array)\n        group_level = 0\n \
    \       for character in group\n            if character == '('\n            \
    \    group_level += 1\n            elseif character == ')'\n                group_level\
    \ -= 1\n            end\n        end\n        paren_levels[index] = group_level\n\
    \    end\n    return paren_levels\nend", "    matches = split(paren_string, \"\
    \ \")\n    return [find_max_nested_parens(match) for match in matches]\nend",
  "    paren_groups = split(paren_string, \" \")\n    max_nesting = Vector{Int64}(undef,\
    \ size(paren_groups, 1))\n    for (i, paren_group) in enumerate(paren_groups)\n\
    \        start_paren_idx = findfirst(isopen_paren, paren_group)\n        curr_nesting\
    \ = 1\n        for char in paren_group[start_paren_idx+1:end]\n            if\
    \ isopen_paren(char)\n                curr_nesting += 1\n            elseif isclose_paren(char)\n\
    \                curr_nesting -= 1\n            end\n        end\n        max_nesting[i]\
    \ = curr_nesting\n    end\n    return max_nesting\nend", "    paren_list = split(paren_string)\n\
    \    levels = Vector{Int64}(undef, length(paren_list))\n    for (i, item) in enumerate(paren_list)\n\
    \        paren_stack = Int64[]\n        for ch in item\n            if ch == '('\n\
    \                push!(paren_stack, ch)\n            elseif ch == ')'\n      \
    \          if isempty(paren_stack)\n                    push!(paren_stack, 0)\n\
    \                else\n                    pop!(paren_stack)\n               \
    \ end\n            end\n        end\n        levels[i] = length(paren_stack)\n\
    \    end\n    return levels\nend", "    n = length(paren_string)\n    max_level\
    \ = Vector{Int64}(undef, length(split(paren_string, \" \")))\n    level = 0\n\
    \    i = 1\n    j = 1\n    while i <= n \n        if paren_string[i] == '('\n\
    \            level += 1\n        elseif paren_string[i] == ')'\n            level\
    \ -= 1\n        end\n        if level > max_level[j]\n            max_level[j]\
    \ = level\n        end\n        if paren_string[i] == ' '\n            j += 1\n\
    \        end\n        i += 1\n    end\n    return max_level\nend", "    pairs\
    \ = split(paren_string) # Split the string into multiple groups separated by spaces\n\
    \    depth = zeros(Int64, length(pairs)) # Create an array with the same length\
    \ as the number of groups in the string", "    \"\"\"\n    Input: string\n   \
    \ Output: vector of integer\n    \"\"\"\n    processed_parens = [process_parens(paren_group)\
    \ for paren_group in split(paren_string, \" \")]\n    return [maximum([max(i)\
    \ for i in processed_parens[j]]) for j in 1:length(processed_parens)]\nend", " \
    \   depth_vector = []\n    paren_vector = split(paren_string)\n    for item in\
    \ paren_vector\n        depth = 0\n        max_depth = 0\n        for i in item\n\
    \            if i == '('\n                depth += 1\n            elseif i ==\
    \ ')'\n                depth -= 1\n            end\n            if depth > max_depth\n\
    \                max_depth = depth\n            end\n        end\n        push!(depth_vector,\
    \ max_depth)\n    end\n    return depth_vector\nend", "    # count the number\
    \ of opening parentheses we've encountered so far, but not yet closed\n    # keep\
    \ adding 1 to this count for each open paren encountered, and subtract 1 for each\
    \ close paren encountered\n    # the maximum of this count will be the maximum\
    \ nesting of parens encountered\n    curr_nest_count = 0\n    deepest_nest_count\
    \ = 0\n    deepest_nest_counts = []\n    for ch in paren_string\n        if ch\
    \ == '('\n            curr_nest_count += 1\n            if curr_nest_count > deepest_nest_count\n\
    \                deepest_nest_count = curr_nest_count\n            end\n     \
    \   elseif ch == ')'\n            curr_nest_count -= 1\n        elseif ch == '\
    \ '\n            deepest_nest_counts = vcat(deepest_nest_counts, deepest_nest_count)\n\
    \            deepest_nest_count = 0\n            curr_nest_count = 0\n       \
    \ end\n    end\n    # add the last group of parens\n    deepest_nest_counts =\
    \ vcat(deepest_nest_counts, deepest_nest_count)\n    return deepest_nest_counts\n\
    end", "    paren_levels = Vector{Int64}(undef, length(paren_string))\n    j =\
    \ 1\n    for i in 1:length(paren_string)\n        if paren_string[i] == '('\n\
    \            paren_levels[j] += 1\n        elseif paren_string[i] == ')'\n   \
    \         j += 1\n        end\n    end\n    paren_levels[1:j-1]\nend", "    groups\
    \ = split(paren_string, \" \")\n    depths = []\n    for i in 1:length(groups)\n\
    \        depths[i] = parse_nested_parens_helper(groups[i])\n    end\n    return\
    \ depths\nend", "    num_layers_per_group = []\n    for group in split(paren_string,\
    \ \" \")\n        num_layers = 0\n        open_parens = 0\n        for c in group\n\
    \            if c == '('\n                open_parens += 1\n                num_layers\
    \ = max(num_layers, open_parens)\n            elseif c == ')'\n              \
    \  open_parens -= 1\n            end\n        end\n        push!(num_layers_per_group,\
    \ num_layers)\n    end\n    return num_layers_per_group\nend", "    \"\"\" The\
    \ basic idea is to use the index of the first and last character of the string\
    \ to represent \n        the beginning and end of the string. The length of the\
    \ string is the level of nesting.\n    \"\"\"\n    if isempty(paren_string)\n\
    \        return Int64[]\n    end\n    levels = Vector{Int64}()\n    begin = 1\n\
    \    for i in 1:length(paren_string)\n        if paren_string[i] == ' '\n    \
    \        push!(levels, i - begin)\n            begin = i + 1\n        end\n  \
    \  end\n    push!(levels, length(paren_string) - begin + 1)\n    return levels\n\
    end", "    stack = Int64[]\n    max_depth = Int64[]\n    depth = 0\n    for paren\
    \ in paren_string\n        if paren == '('\n            push!(stack, 1)\n    \
    \        depth += 1\n        elseif paren == ')'\n            pop!(stack)\n  \
    \          if isempty(stack)\n                push!(max_depth, depth)\n      \
    \          depth = 0\n            end\n        end\n    end\n    return max_depth\n\
    end", "    n = length(paren_string)\n    paren_vec = zeros(Int64, n)\n    # Loop\
    \ through the string from left to right\n    # Keep track of the number of unclosed\
    \ parentheses \n    # Paren_vec is the deepest level of nesting\n    level = 0\n\
    \    for i = 1:n\n        ch = paren_string[i]\n        if ch == '('\n       \
    \     level += 1\n        elseif ch == ')'\n            level -= 1\n        end\n\
    \        if level > paren_vec[i]\n            paren_vec[i] = level\n        end\n\
    \    end\n    return paren_vec\nend", "    return map(s -> count_nested_parens(s),\
    \ split(paren_string, r\"\\s+\"))\nend", "    return map(find_nested_parens, split(paren_string,\
    \ \" \"))\nend", "    N = length(paren_string)\n    open_parens = [0]\n    levels\
    \ = Array{Int64}(length(paren_string))\n    levels[1] = 0\n    for (i, char) in\
    \ enumerate(paren_string)\n        if char == '('\n            push!(open_parens,\
    \ 0)\n            levels[i+1] = levels[i] + 1\n        elseif char == ')'\n  \
    \          pop!(open_parens)\n            levels[i+1] = levels[i] - 1\n      \
    \  elseif char == ' '\n            levels[i+1] = levels[i]\n        end\n    end\n\
    \    levels[N]\nend", "    # Vector for storing the parse\n    v = []\n    # levels\
    \ of parentheses\n    level = 0\n    for i = 1:length(paren_string)\n        if\
    \ paren_string[i] == '('\n            level += 1\n        elseif paren_string[i]\
    \ == ')'\n            push!(v, level)\n            level -= 1\n        end\n \
    \   end\n    v\nend", "    # split the string at spaces\n    group_arr = split(paren_string)\n\
    \    # initialize output\n    levels = Vector{Int64}(length(group_arr))\n    #\
    \ for each of the nested paren group in input, output the deepest level of nesting\n\
    \    for (index, group) in enumerate(group_arr)\n        level = 0\n        max_level\
    \ = 0\n        for (index, char) in enumerate(group)\n            if char == '('\n\
    \                level += 1\n            elseif char == ')'\n                level\
    \ -= 1\n            end\n            max_level = max(max_level, level)\n     \
    \   end\n        levels[index] = max_level\n    end\n    return levels\nend",
  "    return [get_depth(i) for i in split(paren_string)]\nend", "    depths = []\n\
    \    current_depth = 0\n    for paren in paren_string\n        if paren == '('\n\
    \            current_depth += 1\n        elseif paren == ')'\n            current_depth\
    \ -= 1\n        elseif paren == ' '\n            push!(depths, current_depth)\n\
    \            current_depth = 0\n        end\n    end\n    push!(depths, current_depth)\n\
    \    return depths\nend", "    num_parens = length(paren_string)\n    paren_stack\
    \ = Int64[]\n    curr_stack_size = 0\n    group_paren_level = Int64[]\n    for\
    \ i in 1:num_parens\n        # if the current character is a left paren, increment\
    \ the stack length and\n        # add to the end of stack.\n        if paren_string[i]\
    \ == '('\n            push!(paren_stack, 1)\n            curr_stack_size += 1\n\
    \        # else, if the current character is a right paren, decrement the stack\
    \ length.\n        # if the stack is empty, this was the end of a group, so append\
    \ the current\n        # stack length to the end of group_paren_level.\n     \
    \   elseif paren_string[i] == ')'\n            curr_stack_size -= 1\n        \
    \    if isempty(paren_stack)\n                push!(group_paren_level, curr_stack_size)\n\
    \            else\n                pop!(paren_stack)\n            end\n      \
    \  end\n    end\n    group_paren_level\nend", "    return [parse_nested_parens_single(p)\
    \ for p in split(paren_string)]\nend", "    # to store the max-depth for each\
    \ group\n    max_depth_vector = Int64[]\n    # to store the current depth for\
    \ each group\n    stack = Int64[]\n    for (i, c) in enumerate(paren_string)\n\
    \        if c == '('\n            push!(stack, 1)\n        elseif c == ')'\n \
    \           depth = pop!(stack)\n            while depth != 1\n              \
    \  depth = pop!(stack)\n            end\n            if !isempty(stack)\n    \
    \            depth = pop!(stack)\n                depth += 1\n               \
    \ push!(stack, depth)\n            end\n        elseif c == ' ' && !isempty(stack)\n\
    \            depth = pop!(stack)\n            push!(max_depth_vector, depth)\n\
    \        end\n    end\n    # in case there are no spaces after the last group\n\
    \    if !isempty(stack)\n        depth = pop!(stack)\n        push!(max_depth_vector,\
    \ depth)\n    end\n    return max_depth_vector\nend", "    counter_list = Int64[]\n\
    \    for paren in split(paren_string)\n        counter = Int64(0)\n        max_counter\
    \ = Int64(0)\n        for letter in paren\n            if letter == '('\n    \
    \            counter += 1\n            elseif letter == ')'\n                counter\
    \ -= 1\n            end\n            if counter > max_counter\n              \
    \  max_counter = counter\n            end\n        end\n        push!(counter_list,\
    \ max_counter)\n    end\n    return counter_list\nend", "    end\n \n@test parse_nested_parens(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n@test parse_nested_parens(\"(()((())))\"\
    ) == [4]\n@test parse_nested_parens(\"(())\") == [2]\n@test parse_nested_parens(\"\
    ()\") == [1]", "    paren_array = split(paren_string, \" \")\n    max_levels =\
    \ []\n    for group in paren_array\n        max_lvl = 0\n        for c in group\n\
    \            if c == '('\n                max_lvl += 1\n            elseif c ==\
    \ ')'\n                max_lvl -= 1\n            end\n        end\n        push!(max_levels,\
    \ max_lvl)\n    end\n    return max_levels\nend", "    paren_array = split(paren_string,\
    \ \" \")\n    return map(x -> _paren_depth(x), paren_array)\nend", "    # for\
    \ every group in paren_string\n    res = Int64[]\n    group_cnt = 0\n    for group\
    \ in split(paren_string, \" \")\n        max_depth = 0\n        depth = 0\n  \
    \      for c in group\n            if c == '('\n                depth += 1\n \
    \           elseif c == ')'\n                depth -= 1\n            end\n   \
    \         if depth > max_depth\n                max_depth = depth\n          \
    \  end\n        end\n        push!(res, max_depth)\n    end\n    return res\n\
    end", "    # Split the string into groups\n    groups = split(paren_string, \"\
    \ \")", "    lst = split(paren_string, \" \")\n    max_levels = Vector{Int64}(undef,\
    \ length(lst))\n    for i in 1:length(lst)\n        max_levels[i] = find_nested_parens(lst[i])\n\
    \    end\n    return max_levels\nend", "    # To solve this problem, I'll use\
    \ a stack to store all the levels that we encounter.\n    stack = Int64[]\n  \
    \  output = Int64[]\n    for i in 1:length(paren_string)\n        if paren_string[i]\
    \ == '('\n            push!(stack, 0)\n        elseif paren_string[i] == ')'\n\
    \            if length(stack) > 0\n                value = pop!(stack)\n     \
    \           push!(output, value)\n                for k in 1:length(stack)\n \
    \                   stack[k] += 1\n                end\n            else\n   \
    \             push!(output, 0)\n            end\n        end\n    end\n    return\
    \ output\nend", "    depth = 0\n    out = []\n    for p in paren_string\n    \
    \    if p == '('\n            depth += 1\n        elseif p == ')'\n          \
    \  push!(out, depth)\n            depth -= 1\n        end\n    end\n    return\
    \ out\nend", "    groups = split(paren_string)\n    return [max_paren_depth(group)\
    \ for group in groups]\nend", "    n = length(paren_string)\n    j = 1\n    k\
    \ = 1\n    result = Vector{Int64}()\n    while j <= n\n        for i in 1:n\n\
    \            if paren_string[i] == '('\n                k = k + 1\n          \
    \  elseif paren_string[i] == ')'\n                k = k - 1\n            end\n\
    \            if k == 0\n                push!(result, k)\n                j =\
    \ i\n                break\n            end\n        end\n        j = j + 1\n\
    \    end\n    return result\nend", "    results = []\n    for g in split(paren_string,\
    \ \" \")\n        result = 0\n        depth = 0\n        for c in g\n        \
    \    if c == '('\n                depth += 1\n            elseif c == ')'\n  \
    \              depth -= 1\n            end\n            result = max(result, depth)\n\
    \        end\n        push!(results, result)\n    end\n    return results\nend",
  "    group_string = split(paren_string, \" \") \n    n = length(group_string)\n\
    \    max_nest_level = Vector{Int64}(undef, n)\n    for i in 1:n\n        max_nest_level[i]\
    \ = 0\n        nest_level = 0\n        for j in 1:length(group_string[i])\n  \
    \          if group_string[i][j] == '('\n                nest_level += 1\n   \
    \         elseif group_string[i][j] == ')'\n                nest_level -= 1\n\
    \            end\n            if nest_level > max_nest_level[i]\n            \
    \    max_nest_level[i] = nest_level\n            end\n        end\n    end\n \
    \   return max_nest_level\nend", "    # our outputs will be integers representing\
    \ the deepest levels of nesting.\n    # these output levels will be stored in\
    \ a vector\n    level_vec = Int64[]\n    # now we will iterate through each element\
    \ of the string using a for loop\n    for paren_group in split(paren_string, \"\
    \ \")\n        # find the length of the string. We need to know this for our for\
    \ loop\n        n = length(paren_group)\n        # for each element in the string,\
    \ we need to keep track of how many levels of nesting we are at.\n        level\
    \ = 0\n        # now, our for loop. Remember, we need to use `for i in 1:n` to\
    \ iterate through the string\n        for i in 1:n\n            # now we need\
    \ to check if the i-th letter is a \"(\"\n            if paren_group[i] == \"\
    (\"\n                # If it is, we need to increase the level by 1\n        \
    \        level += 1\n            # now we need to check if the i-th letter is\
    \ a \")\"\n            elseif paren_group[i] == \")\"\n                # If it\
    \ is, we need to decrease the level by 1\n                level -= 1\n       \
    \     end\n        end\n        # if our level is not zero, we will get an error.\
    \ We need to handle this\n        if level != 0\n            # error(\"Our parens\
    \ are not balanced\")\n            # We can just ignore groups with unbalanced\
    \ parens\n            continue\n        end\n        # now we need to find the\
    \ maximum level\n        max_level = 0\n        # Keep track of the level as you\
    \ iterate\n        level = 0\n        # Now do the same for loop as before, but\
    \ also keep track of the maximum level we see.\n        for i in 1:n\n       \
    \     if paren_group[i] == \"(\"\n                level += 1\n               \
    \ # now we need to check if this is greater than the current max level\n     \
    \           if level > max_level\n                    # if it is, update the max\
    \ level\n                    max_level = level\n                end\n        \
    \    elseif paren_group[i] == \")\"\n                level -= 1\n            end\n\
    \        end\n        # now we need to add the max level to our vector\n     \
    \   push!(level_", "    \n    levels = []\n    level = 0\n    for ch in paren_string\n\
    \        if ch == '('\n            level += 1\n        elseif ch == ')'\n    \
    \        push!(levels, level)\n            level -= 1\n        end\n    end\n\
    \    return levels\nend", "    nested_parens = split(paren_string, \" \")\n  \
    \  levels = []\n    for nested_paren in nested_parens\n        max_nesting = 0\n\
    \        nesting = 0\n        for letter in nested_paren\n            if letter\
    \ == '('\n                nesting += 1\n            elseif letter == ')'\n   \
    \             nesting -= 1\n            end\n            if nesting > max_nesting\n\
    \                max_nesting = nesting\n            end\n        end\n       \
    \ push!(levels, max_nesting)\n    end\n    return levels\nend", "    paren_strings\
    \ = split(paren_string, \" \")\n    parsed_parens = []\n    for i in paren_strings\n\
    \        parsed_parens = [find_nested_parens(i)]\n    end\n    return parsed_parens\n\
    end", "    group_nested_parens = String[] # create a string array to save the\
    \ groups of parentheses\n    max_nested_parens = Int64[] # create an array to\
    \ save maximum level of nested parens for each group", "    final_vec = []\n \
    \   for paren in split(paren_string, \" \")\n        temp_paren = paren\n    \
    \    level = 0\n        max_level = 0\n        for i in 1:length(temp_paren)\n\
    \            if temp_paren[i] == '('\n                level += 1\n           \
    \ elseif temp_paren[i] == ')'\n                level -= 1\n            end\n \
    \           if level > max_level\n                max_level = level\n        \
    \    end\n        end\n        push!(final_vec, max_level)\n    end\n    return\
    \ final_vec\nend", "    # Initialize to appropriate output vector\n    depths\
    \ = zeros(Int64, length(split(paren_string, \" \")))\n    # Iterate through each\
    \ paren group in the string\n    for (ind, paren) in enumerate(split(paren_string,\
    \ \" \"))\n        # Initialize the stack\n        stack = []\n        max_depth\
    \ = 0\n        # Iterate through each character in the group\n        for c in\
    \ paren\n            # If the character is an open paren, add it to the stack\n\
    \            if c == '('\n                push!(stack, '(')\n            # If\
    \ the character is a close paren, pop a paren off the stack\n            elseif\
    \ c == ')'\n                pop!(stack)\n            end\n            # Update\
    \ the max depth\n            max_depth = max(max_depth, length(stack))\n     \
    \   end\n        # Update the depths\n        depths[ind] = max_depth\n    end\n\
    \    return depths\nend", "    paren_group = split(paren_string)\n    max_depth\
    \ = zeros(length(paren_group))\n    current_depth = 0\n    for (i, paren) in enumerate(paren_group)\n\
    \        for c in paren\n            if c == '('\n                current_depth\
    \ += 1\n            elseif c == ')'\n                current_depth -= 1\n    \
    \        end\n            max_depth[i] = max(max_depth[i], current_depth)\n  \
    \      end\n    end\n    return max_depth\nend", "    paren_string = replace(paren_string,\
    \ \" \", \"\")\n    groups = split(paren_string, \")\")\n    groups = filter(x\
    \ -> length(x) > 0, groups)\n    num_nest = []\n    for group in groups\n    \
    \    open = findfirst(i -> i == '(', group)\n        if open != nothing\n    \
    \        push!(num_nest, open)\n        else\n            push!(num_nest, 0)\n\
    \        end\n    end\n    return num_nest\nend", "    stack = []\n    results\
    \ = []\n    for paren in paren_string\n        if paren == '('\n            push!(stack,\
    \ 1)\n        elseif paren == ')'\n            push!(stack, -1)\n        elseif\
    \ paren == ' '\n            results = [sum(stack) |> abs |> max]\n           \
    \ stack = []\n        end\n    end\n    return results\nend", "    paren_string\
    \ = replace(paren_string, \" \", \"\")\n    n_groups = length(split(paren_string,\
    \ \"()\"))-1\n    paren_nest_levels = Vector{Int64}(undef, n_groups)\n    start_ind\
    \ = Int64[]\n    end_ind = Int64[]\n    for i in 1:length(paren_string)\n    \
    \    if paren_string[i] == '('\n            push!(start_ind, i)\n        elseif\
    \ paren_string[i] == ')'\n            push!(end_ind, i)\n        end\n    end\n\
    \    ind_str = 1\n    ind_end = 1\n    for i in 1:n_groups\n        count = 0\n\
    \        while ind_end <= length(end_ind) && end_ind[ind_end] < start_ind[ind_str+1]\n\
    \            ind_end += 1\n            count += 1\n        end\n        paren_nest_levels[i]\
    \ = count\n        ind_str += 1\n    end\n    return paren_nest_levels\nend",
  "    paren_groups = split(paren_string, \" \")\n    return [find_nested_parens(x)\
    \ for x in paren_groups]\nend", "    idx = 1\n    result = []\n    while idx <=\
    \ length(paren_string)\n        if paren_string[idx] == '('\n            close_idx\
    \ = find_closing_paren(paren_string, idx)\n            result = [result; parse_nested_parens(paren_string[idx+1:close_idx-1])]\n\
    \            idx = close_idx\n        elseif paren_string[idx] == ')'\n      \
    \      return result\n        else\n            idx += 1\n        end\n    end\n\
    \    return maximum(result)\nend", "    open_parens = 0\n    depth = 0\n    max_depth\
    \ = 0\n    output = zeros(Int64, length(split(paren_string)))\n    for i in 1:length(split(paren_string))\n\
    \        for letter in split(paren_string)[i]\n            if letter == '('\n\
    \                open_parens += 1\n                depth += 1\n              \
    \  if depth > max_depth\n                    max_depth = depth\n             \
    \   end\n            elseif letter == ')'\n                depth -= 1\n      \
    \      end\n        end\n        output[i] = max_depth\n        max_depth = 0\n\
    \        depth = 0\n    end\n    return output\nend", "    paren_list = split(paren_string,\
    \ \" \")\n    return [get_max_paren_depth(x) for x in paren_list]\nend", "   \
    \ max_nesting_level = zeros(Int64, length(split(paren_string, \" \")))\n    for\
    \ i in 1:length(max_nesting_level)\n        current_nesting_level = 0\n      \
    \  for c in split(paren_string, \" \")[i]\n            if c == '('\n         \
    \       current_nesting_level += 1\n            elseif c == ')'\n            \
    \    current_nesting_level -= 1\n            end\n        end\n        max_nesting_level[i]\
    \ = current_nesting_level\n    end\n    return max_nesting_level\nend", "    \"\
    \"\" to do this we are going to use a stack data structure. There are many implementations\
    \ but we are going to use a Vector.\n    We will push items onto the stack and\
    \ check if the last item on the stack is a matching paranthesis. If it is we \n\
    \    pop the stack, if it is not we push the new parentheses. We will maintain\
    \ a max variable that will store the deepest\n    level of nesting throughout\
    \ the process.\n    \"\"\"\n    max_level = 0\n    current_level = 0\n    levels\
    \ = Array{Int64}(undef, 0)\n    stack = Array{Char}(undef, 0)\n    for i in paren_string\n\
    \        if i == '('\n            push!(stack, i)\n            current_level +=\
    \ 1\n            if current_level > max_level\n                max_level = current_level\n\
    \            end\n        elseif i == ')'\n            if length(stack) == 0\n\
    \                push!(levels, 0)\n                max_level = 0\n           \
    \     current_level = 0\n            else\n                pop!(stack)\n     \
    \           current_level -= 1\n            end\n        elseif i == ' '\n   \
    \         push!(levels, max_level)\n            max_level = 0\n            current_level\
    \ = 0\n        end\n    end\n    return levels\nend", "    paren_chars = strip(paren_string)\n\
    \    paren_indices = findall(x -> x == '(' || x == ')', paren_chars)\n    max_nesting\
    \ = zeros(Int64, length(paren_indices))\n    current_nesting = 0\n    paren_idx\
    \ = 1\n    while paren_idx <= length(paren_indices)\n        if paren_chars[paren_indices[paren_idx]]\
    \ == '('\n            current_nesting += 1\n            max_nesting[paren_idx]\
    \ = current_nesting\n        else\n            max_nesting[paren_idx] = current_nesting\n\
    \            current_nesting -= 1\n        end\n        paren_idx += 1\n    end\n\
    \    return max_nesting\nend", "    result = Vector{Int64}()\n    for i in split(paren_string)\n\
    \        maximum = 0\n        temp = 0\n        for j in i\n            if j ==\
    \ '('\n                temp += 1\n            elseif j == ')'\n              \
    \  if temp > maximum\n                    maximum = temp\n                end\n\
    \                temp -= 1\n            end\n        end\n        push!(result,\
    \ maximum)\n    end\n    return result\nend", "    \"\"\" Initialize a vector\
    \ of zero integers to store the number of nested parentheses for each group.\n\
    \        The maximum level of nesting is the same as the number of opening parenthesis.\n\
    \    \"\"\"\n    max_level_nesting = zeros(Int64, length(paren_string))\n    \"\
    \"\" Initialize a counter for counting the number of opening parentheses and the\
    \ index for storing\n        the max level of nesting for the current group.\n\
    \    \"\"\"\n    opening_p = 0\n    index = 1\n    \"\"\" Loop through the string\
    \ and count the number of opening parentheses.\n        If current character is\
    \ a closing parenthesis, make sure that it is not the first character in the current\
    \ group.\n        If it is not the first character, decrease the number of opening\
    \ parentheses by 1 and check whether the number\n        of opening parentheses\
    \ so far is larger than the current max level of nesting. If so, update the max\
    \ level of \n        nesting.\n    \"\"\"\n    for p in paren_string\n       \
    \ if p == '('\n            opening_p += 1\n        elseif p == ')' && index !=\
    \ 1\n            opening_p -= 1\n            if opening_p > max_level_nesting[index]\n\
    \                max_level_nesting[index] = opening_p\n            end\n     \
    \   elseif p == ' '\n            index += 1\n        end\n    end\n    return\
    \ max_level_nesting\nend", '    paren_strings = split(paren_string, " ")', " \
    \   paren_grps = split(paren_string, \" \")\n    depth_of_nesting = zeros(Int64,\
    \ length(paren_grps))\n    for i = 1:length(paren_grps)\n        depth_of_nesting[i]\
    \ = parse_parens(paren_grps[i])\n    end\n    return depth_of_nesting\nend", " \
    \   start_parens = paren_string.count('(')\n    stop_parens = paren_string.count(')')\n\
    \    if start_parens != stop_parens\n        throw(DomainError(\"Input string\
    \ doesn't have the same number of open and closed parentheses.\"))\n    end\n\
    \    result = Int64[]\n    paren_pair = false\n    paren_count = 0\n    for char\
    \ in paren_string\n        if char == '('\n            paren_pair = true\n   \
    \         paren_count += 1\n        elseif char == ')'\n            paren_count\
    \ -= 1\n        elseif char == ' '\n            if paren_pair\n              \
    \  push!(result, paren_count)\n                paren_pair = false\n          \
    \      paren_count = 0\n            end\n        end\n    end\n    if paren_pair\n\
    \        push!(result, paren_count)\n    end\n    return result\nend", "    stack\
    \ = []\n    max_stack = []\n    for c in paren_string\n        if c == '('\n \
    \           push!(stack, c)\n        elseif c == ')'\n            pop!(stack)\n\
    \        end\n        if length(stack) > length(max_stack)\n            max_stack\
    \ = stack\n        end\n    end\n    [length(max_stack) for _ in eachindex(paren_string)\
    \ if paren_string[i] == ' ']\nend", "    depth_array = zeros(Int64,1) \n    max_nesting\
    \ = 0 \n    index = 1\n    for paren in paren_string \n        if paren == '('\
    \ \n            max_nesting += 1 \n            depth_array[index] = max_nesting\
    \ \n        elseif paren == ')'\n            max_nesting -= 1 \n            depth_array[index]\
    \ = max_nesting \n        elseif paren == ' '\n            index += 1 \n     \
    \       depth_array = push!(depth_array, 0) \n        end\n    end\n    depth_array\n\
    end", "    first_char = paren_string[1]\n    current_depth = 1\n    max_depth\
    \ = 1\n    depth_group = Vector{Int64}(1)\n    depth_group[1] = max_depth\n  \
    \  i = 2\n    while i < length(paren_string)\n        if paren_string[i] == '\
    \ '\n            push!(depth_group, max_depth)\n            max_depth = 1\n  \
    \          current_depth = 1\n        elseif paren_string[i] == first_char\n \
    \           current_depth += 1\n            if current_depth > max_depth\n   \
    \             max_depth = current_depth\n            end\n        elseif paren_string[i]\
    \ == opposite_paren(first_char)\n            current_depth -= 1\n        end\n\
    \        i += 1\n    end\n    return depth_group\nend", "    # create an empty\
    \ list\n    parsed_parens = Int64[]\n    # for each group\n    for group in split(paren_string)\n\
    \        # create a counter to store the maximum nested level \n        max_level\
    \ = 0\n        # create a counter to store the current nested level \n       \
    \ current_level = 0\n        # for each character in the group\n        for c\
    \ in group\n            # if it is an opening paren\n            if c == '('\n\
    \                # increase the current level\n                current_level +=\
    \ 1\n                # if the current level is greater than the max level\n  \
    \              if current_level > max_level\n                    # set the max\
    \ level to the current level\n                    max_level = current_level\n\
    \                end\n            # if it is a closing paren\n            elseif\
    \ c == ')'\n                # decrease the current level\n                current_level\
    \ -= 1\n            end\n        end\n        # add the max level to the list\n\
    \        push!(parsed_parens, max_level)\n    end\n    # return the list\n   \
    \ return parsed_parens\nend", "    paren_list = split(paren_string, \" \")\n \
    \   depths = []\n    for paren in paren_list\n        depth = 0\n        for c\
    \ in paren\n            if c == '('\n                depth += 1\n            elseif\
    \ c == ')'\n                depth -= 1\n            end\n        end\n       \
    \ push!(depths, depth)\n    end\n    return depths\nend", "    n_parens = length(paren_string)\n\
    \    depths = zeros(Int64, n_parens)\n    depth = 0\n    for (i, paren) in enumerate(paren_string)\n\
    \        if paren == '('\n            depth += 1\n        elseif paren == ')'\n\
    \            depth -= 1\n        end\n        depths[i] = depth\n    end\n   \
    \ return depths\nend", "    open_idx = findall(x -> x == '(', paren_string)\n\
    \    closed_idx = findall(x -> x == ')', paren_string)\n    open_idx = parse_idx(open_idx)\n\
    \    closed_idx = parse_idx(closed_idx)\n    max_depth = zeros(Int64, length(open_idx))\n\
    \    for i in eachindex(open_idx)\n        max_depth[i] = abs(open_idx[i] - closed_idx[i])\n\
    \    end\n    return max_depth\nend", "    paren_list = split(paren_string, \"\
    \ \")\n    n = length(paren_list)\n    max_nesting = zeros(Int64, n)\n    for\
    \ (i, paren) in enumerate(paren_list)\n        max_nesting[i] = sum(paren .==\
    \ \"(\") - sum(paren .== \")\")\n    end\n    return max_nesting\nend", "    levels\
    \ = Vector{Int64}()\n    level = 0\n    for c in paren_string\n        if c ==\
    \ '('\n            level += 1\n        elseif c == ')'\n            level -= 1\n\
    \        elseif c == ' '\n            push!(levels, level)\n            level\
    \ = 0\n        end\n    end\n    if level != 0\n        error(\"Malformed string\"\
    )\n    end\n    return levels\nend", "    paren_string = replace(paren_string,\
    \ \" \", \"\")\n    output = Vector{Int64}(length(paren_string))\n    for i in\
    \ 1:length(paren_string)\n        parse_nested_parens_helper(paren_string[i],\
    \ 0, output, i)\n    end\n    return output\nend", "    paren_arr = split(paren_string,\
    \ \" \")\n    paren_count = []\n    for paren_group in paren_arr\n        curr_count\
    \ = 0\n        max_count = 0\n        for paren in paren_group\n            if\
    \ paren == '('\n                curr_count += 1\n            elseif paren == ')'\n\
    \                curr_count -= 1\n            end\n            if curr_count >\
    \ max_count\n                max_count = curr_count\n            end\n       \
    \ end\n        push!(paren_count, max_count)\n    end\n    return paren_count\n\
    end", "    \n    stack = Int[]\n    max_depth = Int[]\n    current_depth = 0\n\
    \    \n    for paren in paren_string\n        if paren == '('\n            push!(stack,\
    \ paren)\n            current_depth += 1\n        elseif paren == ')'\n      \
    \      pop!(stack)\n            current_depth -= 1\n        end\n        \n  \
    \      if current_depth > length(max_depth)\n            push!(max_depth, current_depth)\n\
    \        end\n    end\n    return max_depth\nend", "    parse_nested_parens(s)\
    \ = map(x -> _nest_count(x), split(s, \" \"))\n    parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n    # TODO: implement this!\nend", "    paren_arr =\
    \ split(paren_string, \" \")\n    return [parse_nested_parens_helper(x) for x\
    \ in paren_arr]\nend", "    n = length(paren_string)\n    stack = Int64[]\n  \
    \  counter = 0\n    max_level = 0\n    open_bracket = \"(\"\n    close_bracket\
    \ = \")\"\n    result = Int64[]\n    for i in 1:n\n        c = paren_string[i]\n\
    \        if c == open_bracket\n            counter += 1\n            push!(stack,\
    \ counter)\n        elseif c == close_bracket\n            max_level = max(max_level,\
    \ counter)\n            counter -= 1\n            pop!(stack)\n        elseif\
    \ c == \" \"\n            if !isempty(stack)\n                push!(result, max_level)\n\
    \            end\n            max_level = 0\n        end\n    end\n    if !isempty(stack)\n\
    \        push!(result, max_level)\n    end\n    return result\nend", "    # Base\
    \ cases:\n    if paren_string == \"\"\n        return Int64[]\n    end\n    if\
    \ length(paren_string) == 1\n        error(\"String is not valid, only one character\
    \ given\")\n    end\n    if paren_string[1] != '('\n        error(\"String is\
    \ not valid, first character is not (\")\n    end\n    if paren_string[end] !=\
    \ ')'\n        error(\"String is not valid, last character is not )\")\n    end\n\
    \    \n    paren_levels = [0]\n    start_ind = 1\n    end_ind = length(paren_string)\n\
    \    max_level = 0\n    level = 0\n    for i in 1:length(paren_string)\n     \
    \   if paren_string[i] == '('\n            level += 1\n            if level >\
    \ max_level\n                max_level = level\n            end\n        elseif\
    \ paren_string[i] == ')'\n            level -= 1\n        end\n    end\n    level\
    \ = 0\n    if max_level > 1\n        while end_ind > start_ind\n            #\
    \ Left Paren\n            level += 1\n            if level == max_level - 1\n\
    \                start_ind = end_ind + 1\n                end_ind = length(paren_string)\n\
    \                level = 0\n            end\n            # Right Paren\n     \
    \       level -= 1\n            if level == 0\n                push!(paren_levels,\
    \ max_level)\n                end_ind -= 1\n            end\n        end\n   \
    \ end\n    push!(paren_levels, 1)\n    return paren_levels\nend", "    \n    levels\
    \ = Vector{Int64}()\n    current_level = 0\n    \n    for token in split(paren_string)\n\
    \        if token == \"(\"\n            current_level += 1\n        elseif token\
    \ == \")\"\n            push!(levels, current_level)\n            current_level\
    \ -= 1\n        end\n    end\n    return levels\nend", "    paren_groups = split(paren_string,\
    \ \" \")\n    # For each nested parentheses group, iterate through and count the\
    \ nesting levels\n    # of the parens\n    num_nested_parens = []\n    for paren_group\
    \ in paren_groups\n        level = 0\n        max_level = 0\n        for paren\
    \ in paren_group\n            if paren == '('\n                level += 1\n  \
    \          elseif paren == ')'\n                level -= 1\n            end\n\
    \            max_level = max(max_level, level)\n        end\n        push!(num_nested_parens,\
    \ max_level)\n    end\n    return num_nested_parens\nend", "    \n    # Vector\
    \ of max number of nested parentheses in each group\n    max_nested_parens = Vector{Int64}()\n\
    \    \n    # For each of the parenthesis groups in the input string\n    for i\
    \ in split(paren_string, \" \")\n        # Initialize a stack to keep track of\
    \ ( and )\n        stack = []\n        # Initialize counter and max counter of\
    \ each individual parenthesis group\n        counter = 0\n        max_counter\
    \ = 0\n        \n        # For each of the parentheses in i\n        for char\
    \ in i\n            # If we encounter an opening parentheses, push that value\
    \ to the stack and increase counter by 1\n            if char == '('\n       \
    \         push!(stack, char)\n                counter += 1\n            # If we\
    \ encounter a closing parentheses, pop the last value of the stack and decrease\
    \ counter by 1\n            elseif char == ')'\n                pop!(stack)\n\
    \                counter -= 1\n            end\n            \n            # Check\
    \ if current counter is greater than max counter\n            if counter > max_counter\n\
    \                # If so, update max counter to current counter\n            \
    \    max_counter = counter\n            end\n        end\n        \n        #\
    \ Once we finish iterating through each of the parentheses in i, push max counter\
    \ to max_nested_parens vector\n        push!(max_nested_parens, max_counter)\n\
    \    end\n    \n    # Return the vector of max number of nested parentheses in\
    \ each group\n    return max_nested_parens\nend", "    # Initialize output vector\n\
    \    levels = zeros(Int64, length(split(paren_string)))", "    if paren_string\
    \ == \"\"\n        return Vector{Int64}([])\n    end\n    paren_groups = split(paren_string,\
    \ \" \")\n    # First, we need to remove the outer parentheses in each string\n\
    \    nested_parens = map(s -> s[2:end-1], paren_groups)\n    # Now we will find\
    \ the maximum depth of nested parentheses\n    # Here we use the insight that\
    \ a nested parenthesis only adds to the depth when we see an open parenthesis\n\
    \    # and subtracts to the depth when we see a close parenthesis.\n    # This\
    \ way, we don't need to keep track of what pair we are nesting in.\n    max_depth\
    \ = map(s -> maximum(cumsum(parse.(Int64, s))), nested_parens)\n    return max_depth\n\
    end", "    \n    paren_list = split(paren_string, \" \")\n    max_nesting = []\n\
    \    \n    for s in paren_list\n        count = 0\n        max_nest = 0\n    \
    \    for i in 1:length(s)\n            if s[i] == '('\n                count +=\
    \ 1\n            elseif s[i] == ')'\n                count -= 1\n            end\n\
    \            if count > max_nest\n                max_nest = count\n         \
    \   end\n        end\n        push!(max_nesting, max_nest)\n    end\n    \n  \
    \  return max_nesting\nend", "    # initialize an output vector\n    level = Int64[]\n\
    \    # initialize a group of parentheses\n    group = String[]\n    # initialize\
    \ temporary variable to calculate the level\n    t_level = 0\n    # initialize\
    \ a group flag\n    group_flag = false\n    # loop over each character of the\
    \ string\n    for i = 1:length(paren_string)\n        if paren_string[i] == '('\n\
    \            push!(group, paren_string[i])\n            t_level += 1\n       \
    \     group_flag = true\n        elseif paren_string[i] == ')'\n            push!(group,\
    \ paren_string[i])\n            t_level -= 1\n        elseif paren_string[i] ==\
    \ ' ' && group_flag\n            group_flag = false\n            push!(level,\
    \ t_level)\n            t_level = 0\n            group = String[]\n        end\n\
    \    end\n    # if the level remains unchanged, we need to process the last group\
    \ of parentheses\n    if t_level != 0\n        push!(level, t_level)\n    end\n\
    \    return level\nend", "    max_depth = 0\n    max_depth_vec = Vector{Int64}(undef,\
    \ 0)\n    for i in 1:length(paren_string)\n        if paren_string[i] == '('\n\
    \            max_depth += 1\n        elseif paren_string[i] == ')'\n         \
    \   push!(max_depth_vec, max_depth)\n            max_depth -= 1\n        end\n\
    \    end\n    return max_depth_vec\nend", "    groups = split(paren_string, \"\
    \ \")\n    n_groups = length(groups)\n    result = Vector{Int64}(undef, n_groups)\n\
    \    for i = 1:n_groups\n        group = groups[i]\n        depth = 0\n      \
    \  max_depth = 0\n        for c in group\n            if c == '('\n          \
    \      depth += 1\n            elseif c == ')'\n                depth -= 1\n \
    \           end\n            max_depth = max(max_depth, depth)\n        end\n\
    \        result[i] = max_depth\n    end\n    return result\nend", "    paren_stack\
    \ = []\n    curr_max = 0\n    result = []\n    for char in paren_string\n    \
    \    if char == '('\n            # update maximum nesting depth\n            push!(paren_stack,char)\n\
    \            curr_max = max(curr_max, length(paren_stack))\n        elseif char\
    \ == ')'\n            pop!(paren_stack)\n        elseif char == ' '\n        \
    \    push!(result, curr_max)\n            curr_max = 0\n        end\n    end\n\
    \    push!(result, curr_max)\n    return result\nend", "    open_parens = 0\n\
    \    max_open_parens = 0\n    output = zeros(Int64, 0)\n    curr_index = 1\n \
    \   while curr_index <= length(paren_string)\n        curr_char = paren_string[curr_index]\n\
    \        if curr_char == '('\n            open_parens += 1\n            if open_parens\
    \ > max_open_parens\n                max_open_parens = open_parens\n         \
    \   end\n        elseif curr_char == ')'\n            open_parens -= 1\n     \
    \   else\n            # it is a space\n            push!(output, max_open_parens)\n\
    \            max_open_parens = 0\n            open_parens = 0\n        end\n \
    \       curr_index += 1\n    end\n    push!(output, max_open_parens)\n    return\
    \ output\nend", "    paren_list = split(paren_string, \" \")\n    paren_list =\
    \ [parse_nested_parens_helper(paren_group) for paren_group in paren_list]\n  \
    \  return paren_list\nend", "    paren_groups = split(paren_string)\n    N = length(paren_groups)\n\
    \    paren_levels = zeros(Int64, N)\n    for i = 1:N\n        current_level =\
    \ 0\n        paren_list = string(paren_groups[i])\n        for j = 1:length(paren_list)\n\
    \            if paren_list[j] == '('\n                current_level += 1\n   \
    \         elseif paren_list[j] == ')'\n                current_level -= 1\n  \
    \          end\n            paren_levels[i] = max(paren_levels[i], current_level)\n\
    \        end\n    end\n    return paren_levels\nend", "    str_arr = split(paren_string,\
    \ \" \")\n    count_arr = Vector{Int64}()\n    for i = 1:length(str_arr)\n   \
    \     paren_count = 0\n        max_paren_count = 0\n        for c in str_arr[i]\n\
    \            if c == '('\n                paren_count += 1\n            elseif\
    \ c == ')'\n                paren_count -= 1\n            end\n            if\
    \ paren_count > max_paren_count\n                max_paren_count = paren_count\n\
    \            end\n        end\n        push!(count_arr, max_paren_count)\n   \
    \ end\n    return count_arr\nend", "    open_parens = 0\n    max_open_parens =\
    \ 0\n    paren_string = filter(x -> x !=' ', paren_string)\n    depths = Int64[]\n\
    \    for i in 1:length(paren_string)\n        if paren_string[i] == '('\n    \
    \        open_parens += 1\n            max_open_parens = max(max_open_parens,\
    \ open_parens)\n        elseif paren_string[i] == ')'\n            open_parens\
    \ -= 1\n            if open_parens == 0\n                push!(depths, max_open_parens)\n\
    \                max_open_parens = 0\n            end\n        end\n    end\n\
    \    return depths\nend", "    max_levels = Int64[]\n    paren_split = split(paren_string,\
    \ \" \")\n    for paren in paren_split\n        level = 0\n        max_level =\
    \ 0\n        for c in paren\n            if c == '('\n                level +=\
    \ 1\n            elseif c == ')'\n                level -= 1\n            end\n\
    \            if level > max_level\n                max_level = level\n       \
    \     end\n        end\n        push!(max_levels, max_level)\n    end\n    return\
    \ max_levels\nend", "    result = Int64[]\n    paren_stack = Char[]\n    for c\
    \ in paren_string\n        if c in \"()\"\n            push!(paren_stack, c)\n\
    \        end\n    end\n    balanced_paren_stack = Char[]\n    for c in paren_stack\n\
    \        if c == '('\n            push!(balanced_paren_stack, c)\n        elseif\
    \ c == ')'\n            pop!(balanced_paren_stack)\n        end\n    end\n   \
    \ n = length(balanced_paren_stack)\n    if n > 0\n        println(\"WARNING: Unbalanced\
    \ parentheses\")\n    end\n    push!(result, n)\n    return result\nend", "  \
    \  paren_groups = split(paren_string, \" \")\n    return map(paren_groups) do\
    \ gp\n        pos_count, neg_count = 0, 0\n        max_count = 0\n        for\
    \ s in gp\n            if s == '('\n                pos_count += 1\n         \
    \   elseif s == ')'\n                neg_count += 1\n            end\n       \
    \     if pos_count < neg_count\n                return -1\n            end\n \
    \           max_count = max(max_count, pos_count - neg_count)\n        end\n \
    \       if pos_count != neg_count\n            return -1\n        end\n      \
    \  return max_count\n    end\nend", "    max_depth = 0\n    max_depth_vec = []\n\
    \    max_depth_vec = []\n    depth = 0\n    for i in 1:length(paren_string)\n\
    \        ch = paren_string[i]\n        if ch == '('\n            depth += 1\n\
    \        elseif ch == ')'\n            depth -= 1\n        end\n        if depth\
    \ > max_depth\n            max_depth = depth\n        end\n        if ch == '\
    \ '\n            push!(max_depth_vec, max_depth)\n            max_depth = 0\n\
    \        end\n    end\n    push!(max_depth_vec, max_depth)\n    return max_depth_vec\n\
    end", "    max_depth = 0\n    max_depth_start = 0\n    max_depth_end = 0\n   \
    \ start_idx = 0\n    end_idx = 0\n    counts = zeros(length(paren_string))\n \
    \   i = 1\n    for c in paren_string\n        if c == '('\n            counts[i]\
    \ = counts[i-1] + 1\n        elseif c == ')'\n            counts[i] = counts[i-1]\
    \ - 1\n        else\n            counts[i] = counts[i-1]\n        end\n      \
    \  if counts[i] > max_depth\n            max_depth = counts[i]\n            max_depth_start\
    \ = i\n        end\n        if counts[i] == max_depth_start - 1\n            max_depth_end\
    \ = i\n        end\n        i += 1\n    end\n    println(paren_string)\n    println(max_depth)\n\
    \    println(max_depth_start)\n    println(max_depth_end)\n    println(counts)\n\
    \    return counts\nend\nparse_nested_parens(\"(()()) ((())) () ((())()())\")",
  "    # assign the nested depth level to be 0 and a open bracket count to be 1\n\
    \    depth_level = 0\n    count = 1\n    # create a new array of nested_depth\
    \ to store the maximum depth level for each element\n    nested_depth = Array{Int64}(undef,\
    \ length(paren_string))\n    i = 1\n    # iterate through every character in the\
    \ given paren_string\n    for c = paren_string\n        # add 1 to count each\
    \ time you see a '('\n        if c == '('\n            count += 1\n        # subract\
    \ 1 from count each time you see a ')'\n        elseif c == ')'\n            count\
    \ -= 1\n        end\n        # if count is bigger than the current depth level,\
    \ change the current depth level to be the new count\n        if count > depth_level\n\
    \            depth_level = count\n        end\n        # change the value of nested_depth[i]\
    \ to be the depth level to store the max depth level for this group\n        nested_depth[i]\
    \ = depth_level\n        # increase i by 1\n        i += 1\n    end\n    # return\
    \ the nested_depth which store the max depth level for each group\n    return\
    \ nested_depth\nend", "    paren_blocks = split(paren_string)\n    paren_counts\
    \ = Vector{Int64}(undef, length(paren_blocks))\n    for i in 1:length(paren_blocks)\n\
    \        current_count = 0\n        current_max = 0\n        for j in 1:length(paren_blocks[i])\n\
    \            if paren_blocks[i][j] == '('\n                current_count += 1\n\
    \                if current_count > current_max\n                    current_max\
    \ = current_count\n                end\n            elseif paren_blocks[i][j]\
    \ == ')'\n                current_count -= 1\n            end\n        end\n \
    \       paren_counts[i] = current_max\n    end\n    return paren_counts\nend",
  "    l = length(paren_string)\n    current_level = Int64[]\n    max_levels = Int64[]\n\
    \    for i in 1:l\n        current_paren = paren_string[i]\n        if current_paren\
    \ == '('\n            push!(current_level, 1)\n        elseif current_paren ==\
    \ ')'\n            if !isempty(current_level)\n                push!(max_levels,\
    \ pop!(current_level))\n            else\n                push!(max_levels, 0)\n\
    \            end\n        end\n    end\n    return max_levels\nend", "    paren_vector\
    \ = split(paren_string)\n    max_levels = Vector{Int64}()\n    for group in paren_vector\n\
    \        open_count = 0\n        max_level = 0\n        for char in group\n  \
    \          if char == '('\n                open_count += 1\n                if\
    \ open_count > max_level\n                    max_level = open_count\n       \
    \         end\n            elseif char == ')'\n                open_count -= 1\n\
    \            end\n        end\n        push!(max_levels, max_level)\n    end\n\
    \    return max_levels\nend", "    str_vec = split(paren_string, \" \")\n    paren_vec\
    \ = []\n    for str in str_vec\n        level = 0\n        for ch in str\n   \
    \         if ch == '('\n                level += 1\n            elseif ch == ')'\n\
    \                level -= 1\n            end\n        end\n        push!(paren_vec,\
    \ level)\n    end\n    return paren_vec\nend", "    open_parens_stack = []\n \
    \   nesting_levels = []\n    for ch in paren_string\n        if ch == '('\n  \
    \          push!(open_parens_stack, ch)\n        elseif ch == ')'\n          \
    \  isempty(open_parens_stack) && continue\n            pop!(open_parens_stack)\n\
    \        elseif ch == ' '\n            if isempty(open_parens_stack)\n       \
    \         push!(nesting_levels, 0)\n            else\n                push!(nesting_levels,\
    \ length(open_parens_stack))\n            end\n        end\n    end\n    return\
    \ nesting_levels\nend", "    paren_arr = split(paren_string, \" \")\n    levels\
    \ = [0]\n    level = 0\n    for group in paren_arr\n        for char in group\n\
    \            if char == '('\n                level += 1\n            elseif char\
    \ == ')'\n                level -= 1\n            end\n        end\n        push!(levels,\
    \ level)\n        level = 0\n    end\n    return levels[2:end]\nend", "    paren_string\
    \ = replace(paren_string, \" \", \"\")\n    n = length(paren_string)\n    depth_vec\
    \ = zeros(Int64, n)\n    paren_stack = Stack{Char}()\n    for i in 1:n\n     \
    \   c = paren_string[i]\n        if c == '('\n            push!(paren_stack, c)\n\
    \        elseif c == ')'\n            pop!(paren_stack)\n        end\n       \
    \ depth_vec[i] = length(paren_stack)\n    end\n    return depth_vec\nend", " \
    \   paren_count = Vector{Int64}(undef, length(split(paren_string, \" \")))\n \
    \   for (index, paren_group) in enumerate(split(paren_string, \" \"))\n      \
    \  paren_count[index] = parse_nested_parens_indiv(paren_group)\n    end\n    return\
    \ paren_count\nend", "    # Replace all the whitespaces with \"|\"\n    paren_string\
    \ = replace(paren_string, r\"\\s+\" => \"|\")\n    # Split the string based on\
    \ \"|\" to get the various groups for nested parentheses\n    groups = split(paren_string,\
    \ \"|\")\n    # Initialize maximum nesting level as 0.\n    max_nest_level = 0\n\
    \    # Initialize current level of nesting as 0.\n    current_nest_level = 0\n\
    \    # Initialize a vector to hold the maximum level of nesting for each group.\n\
    \    vec = Vector{Int64}()\n    # Loop through the groups\n    for group in groups\n\
    \        # Loop through the characters in each group\n        for character in\
    \ group\n            # If the character is '(' then increment the current level\
    \ of nesting by 1.\n            if character == '('\n                current_nest_level\
    \ += 1\n            elseif character == ')'\n                # Else if the character\
    \ is ')' then decrement the current level of nesting by 1.\n                current_nest_level\
    \ -= 1\n            end\n            # Update the maximum level of nesting if\
    \ current level is greater than max.\n            if current_nest_level > max_nest_level\n\
    \                max_nest_level = current_nest_level\n            end\n      \
    \  end\n        # At the end of each group append the maximum level of nesting\
    \ to the vector.\n        push!(vec, max_nest_level)\n        # Reset the current\
    \ level of nesting for the next group.\n        current_nest_level = 0\n     \
    \   # Reset the maximum level of nesting for the next group.\n        max_nest_level\
    \ = 0\n    end\n    # Return the vector.\n    return vec\nend", "    # your code\
    \ here\nend\n \n# test\n@test parse_nested_parens(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3]\n@test parse_nested_parens(\"( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )\") == [24]\n \n \n\
    \ \n\"\"\" When working with lots of text data, it is helpful to look at the distribution\
    \ of words in the text.\n    Here, we'll use a histogram to describe the distribution\
    \ of words.\n    We have a text and a dictionary of stop words. Stop words are\
    \ words that we do not want to include in our histogram.\n    Please write a function\
    \ that takes this text and stop words, and returns a histogram, which is a Dictionary{String,Int64},\n\
    \    mapping a word to the count of its occurrence in the text.\n    Please ignore\
    \ the case of a word (use only lower-case) and ignore punctuation.\n    Please\
    \ do not use any external libraries to implement the histogram.\n \n    >>> histogram(\"\
    It is the east and Juliet is the sun.\", [\"is\", \"the\", \"and\"])\n    Dict(\"\
    it\" => 1, \"east\" => 1, \"juliet\" => 1, \"sun\" => 1)\n \n    >>> histogram(\"\
    The sky has given over \\n the stony rage that she \\n had when I first \\n looked\
    \ up lying on the grass \\n and the first star I \\n saw and the fact that I \\\
    n thought of tree-lined streets \\n dooryards and driveways \\n where children\
    \ buckled \\n in their car seats travel \\n home.  The sky goes black, \\n blank,\
    \ and the fields open \\n deep and brown.\", [\"i\", \"and\", \"that\", \"first\"\
    , \"sky\", \"looked\", \"had\", \"up\", \"black\", \"has\", \"travel\", \"been\"\
    , \"opened\", \"goes\", \"blank\", \"deep\", \"grass\", \"brown\", \"when\", \"\
    open\", \"stony\", \"the\", \"star\", \"home\", \"fields\", \"so\", \"you\", \"\
    streets", "    paren_groups = split(paren_string, \" \")\n    max_depth = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for (i, group) in enumerate(paren_groups)\n     \
    \   curr_depth = 0\n        max_depth[i] = 0\n        for paren in group\n   \
    \         if paren == '('\n                curr_depth += 1\n            elseif\
    \ paren == ')'\n                curr_depth -= 1\n            end\n           \
    \ max_depth[i] = max(max_depth[i], curr_depth)\n        end\n    end\n    return\
    \ max_depth\nend", "    paren_list = split(paren_string, \" \")\n    max_nesting\
    \ = Int64[]\n    for paren in paren_list\n        level = 0\n        max_level\
    \ = 0\n        for character in paren\n            if character == '('\n     \
    \           level += 1\n            elseif character == ')'\n                level\
    \ -= 1\n            end\n            if level > max_level\n                max_level\
    \ = level\n            end\n        end\n        push!(max_nesting, max_level)\n\
    \    end\n    return max_nesting\nend", "    # Initialize a vector to hold the\
    \ nested depths of all groups\n    depths = []", "    groups = split(paren_string,\
    \ \" \")\n    for group in groups\n        print(group)\n    end\n    return groups\n\
    end", "    paren_groups = split(paren_string, \" \")\n    depths = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for (i, group) in enumerate(paren_groups)\n     \
    \   depth = 0\n        max_depth = 0\n        for c in group\n            if c\
    \ == '('\n                depth += 1\n            elseif c == ')'\n          \
    \      depth -= 1\n            end\n            max_depth = max(max_depth, depth)\n\
    \        end\n        depths[i] = max_depth\n    end\n    return depths\nend",
  "    level_vec = Vector{Int64}()\n    start_paren_count = 0\n    end_paren_count\
    \ = 0\n    num_levels = 0\n    for i = 1:length(paren_string)\n        if paren_string[i]\
    \ == '('\n            start_paren_count += 1\n            if start_paren_count\
    \ > end_paren_count\n                num_levels += 1\n            end\n      \
    \  elseif paren_string[i] == ')'\n            end_paren_count += 1\n        elseif\
    \ paren_string[i] == ' '\n            if start_paren_count == end_paren_count\n\
    \                # Append num_levels for each group to level_vec\n           \
    \     push!(level_vec, num_levels)\n                num_levels = 0\n         \
    \       start_paren_count = 0\n                end_paren_count = 0\n         \
    \   end\n        end\n    end\n    return level_vec\nend", "    # Split the string\
    \ on space to get each group\n    groups = split(paren_string, \" \")\n    # To\
    \ store the maximum level of nesting for each group\n    nesting_levels = Vector{Int64}(undef,\
    \ length(groups))\n    # For each group, find the maximum level of nesting\n \
    \   for i in 1:length(groups)\n        # current level of nesting is 0\n     \
    \   level = 0\n        # To store the maximum level of nesting\n        max_level\
    \ = 0\n        # Iterate over all the characters in the group\n        for char\
    \ in groups[i]\n            # If the character is '(' then increase the level\
    \ by 1\n            if char == '('\n                level += 1\n            #\
    \ If the character is ')' then decrease the level by 1\n            elseif char\
    \ == ')'\n                level -= 1\n            end\n            # If the level\
    \ is greater than max_level, update the max_level\n            if level > max_level\n\
    \                max_level = level\n            end\n        end\n        # Store\
    \ the max_level for the current group in the output vector\n        nesting_levels[i]\
    \ = max_level\n    end\n    # Return the vector of maximum levels of nesting for\
    \ each group\n    return nesting_levels\nend", "    levels = split(paren_string,\
    \ \" \")\n    level_counts = []\n    for level in levels\n        level_count\
    \ = 0\n        curr_nesting = 0\n        for paren in level\n            if paren\
    \ == '('\n                curr_nesting += 1\n            elseif paren == ')'\n\
    \                curr_nesting -= 1\n            end\n            if curr_nesting\
    \ > level_count\n                level_count = curr_nesting\n            end\n\
    \        end\n        push!(level_counts, level_count)\n    end\n    return level_counts\n\
    end", "    strlist = split(paren_string, \" \")\n    output_list = zeros(length(strlist))\n\
    \    for i = 1:length(strlist)\n        output_list[i] = _parse_nested_parens(strlist[i])\n\
    \    end\n    return output_list\nend", "    paren_stack = Int64[]\n    nested_parens\
    \ = Int64[]\n    for paren in paren_string\n        if paren == '('\n        \
    \    push!(paren_stack, 1)\n        elseif paren == ')'\n            push!(nested_parens,\
    \ length(paren_stack))\n            pop!(paren_stack)\n        end\n    end\n\
    \    return nested_parens\nend", "    to_return = []\n    for s in split(paren_string,\
    \ \" \")\n        num_open_parens = 0\n        max_num_open_parens = 0\n     \
    \   for c in s\n            if c == '('\n                num_open_parens += 1\n\
    \                if num_open_parens > max_num_open_parens\n                  \
    \  max_num_open_parens = num_open_parens\n                end\n            elseif\
    \ c == ')'\n                num_open_parens -= 1\n            end\n        end\n\
    \        push!(to_return, max_num_open_parens)\n    end\n    return to_return\n\
    end", "    # Split to get the groups\n    groups = split(paren_string, \" \")\n\
    \    return [deepest_nesting(x) for x in groups]\nend", "    result = []\n   \
    \ groups = split(paren_string, \" \")\n    for group in groups\n        max_level\
    \ = 0\n        level = 0\n        for c in group\n            if c == '('\n  \
    \              level += 1\n            elseif c == ')'\n                level\
    \ -= 1\n            end\n            if level > max_level\n                max_level\
    \ = level\n            end\n        end\n        push!(result, max_level)\n  \
    \  end\n    return result\nend\n \nparse_nested_parens(\"(()()) ((())) () ((())()())\"\
    )\n ", "    paren_list = split(paren_string)\n    parse_list = [parse_parens(s)\
    \ for s in paren_list]\n    return parse_list\nend", "    open_counts = []\n \
    \   for paren_group in split(paren_string, \" \")\n        open_count = 0\n  \
    \      max_open_count = 0\n        for paren in paren_group\n            if paren\
    \ == '('\n                open_count += 1\n                max_open_count = max(max_open_count,\
    \ open_count)\n            elseif paren == ')'\n                open_count -=\
    \ 1\n            end\n        end\n        push!(open_counts, max_open_count)\n\
    \    end\n    return open_counts\nend", "    lvl = 0\n    lvls = []\n    for p\
    \ in paren_string\n        if p == '('\n            lvl += 1\n        elseif p\
    \ == ')'\n            lvl -= 1\n        elseif p == ' '\n            push!(lvls,\
    \ lvl)\n        end\n    end\n    return lvls\nend", "    nest_levels = Vector{Int64}()\n\
    \    count = 0\n    for paren in paren_string\n        if paren == '('\n     \
    \       count += 1\n        elseif paren == ')'\n            push!(nest_levels,\
    \ count)\n            count = 0\n        end\n    end\n    return nest_levels\n\
    end\nparse_nested_parens(\"(()()) ((())) () ((())()())\")", "    # Maintain a\
    \ stack to store the opening parenthesis for any\n    # open groups of parentheses.\n\
    \    stack = Stack{Int64}()\n    # Output will be a vector of maximum depth of\
    \ nesting\n    # for each group of parenthesis.\n    max_depth = zeros(Int64,\
    \ count(paren_string, ' ') + 1)\n    group_index = 1\n    group_depth = 0\n  \
    \  for c in paren_string\n        if c == '('\n            push!(stack, c)\n \
    \           group_depth += 1\n        elseif c == ')'\n            pop!(stack)\n\
    \            group_depth -= 1\n        elseif c == ' '\n            max_depth[group_index]\
    \ = group_depth\n            group_index += 1\n            group_depth = 0\n \
    \       end\n    end\n    max_depth[group_index] = group_depth\n    return max_depth\n\
    end", "    i = 1\n    max_depth = 0\n    depths = []\n    while i <= length(paren_string)\n\
    \        letter = paren_string[i]\n        if letter == '('\n            max_depth\
    \ += 1\n        elseif letter == ')'\n            depths = vcat(depths, max_depth)\n\
    \            max_depth -= 1\n        end\n        i += 1\n    end\n    return\
    \ depths\nend", "    paren_array = split(paren_string, \" \")\n    output = Int64[]\n\
    \    for paren in paren_array\n        count = 0\n        max_count = 0\n    \
    \    for char in paren\n            if char == '('\n                count += 1\n\
    \            elseif char == ')'\n                if count > max_count\n      \
    \              max_count = count\n                end\n                count -=\
    \ 1\n            end\n        end\n        push!(output, max_count)\n    end\n\
    \    return output\nend", "    stack = []\n    result = []\n    for c in paren_string\n\
    \        if c == '('\n            push!(stack, c)\n        elseif c == ')'\n \
    \           if isempty(stack)\n                push!(result, 0)\n            else\n\
    \                depth = 0\n                while peek(stack) == '('\n       \
    \             pop!(stack)\n                    depth += 1\n                end\n\
    \                push!(result, depth)\n            end\n        end\n    end\n\
    \    return result\nend", "    return map(c -> parse_nested_parens_1(c), split(paren_string,\
    \ \" \"))\nend", "    groups = split(paren_string, \" \")\n    n_groups = length(groups)\n\
    \    deepest_levels = zeros(Int64, n_groups)\n    for i in 1:n_groups\n      \
    \  group = groups[i]\n        max_deep = 0\n        current_deep = 0\n       \
    \ for paren in group\n            if paren == '('\n                current_deep\
    \ += 1\n            elseif paren == ')'\n                if current_deep > max_deep\n\
    \                    max_deep = current_deep\n                end\n          \
    \      current_deep -= 1\n            end\n        end\n        deepest_levels[i]\
    \ = max_deep\n    end\n    return deepest_levels\nend", "    return [count_nesting(s)\
    \ for s in split(paren_string, \" \")]\nend", "    paren_depth = zeros(Int64,\
    \ length(split(paren_string)))\n    counter = 0\n    for (i, g) in enumerate(split(paren_string))\n\
    \        if g == \"(\"\n            counter += 1\n        elseif g == \")\"\n\
    \            counter -= 1\n        end\n        paren_depth[i] = counter\n   \
    \ end\n    return paren_depth\nend", "    paren_string = replace(paren_string,\
    \ ' ' => '')\n    group_nums = findall(r\"\\(+\\)+\", paren_string)\n    max_levels\
    \ = [Int(length(findall(r\"\\(\", i))/2) for i in group_nums]\n    return max_levels\n\
    end", "    paren_list = split(paren_string, \" \")\n    return [find_max_level(x)\
    \ for x in paren_list]\nend", "    open = 0\n    max_depth = 0\n    max_depth_list\
    \ = Vector{Int64}()\n    for p in paren_string\n        if p == '('\n        \
    \    open += 1\n            if open > max_depth\n                max_depth = open\n\
    \            end\n        elseif p == ')'\n            open -= 1\n        elseif\
    \ p == ' '\n            push!(max_depth_list, max_depth)\n            max_depth\
    \ = 0\n        end\n    end\n    max_depth_list\nend", "    \n    # Store the\
    \ indices and levels of the parentheses\n    ind::Vector{Int64} = []\n    lev::Vector{Int64}\
    \ = []\n    \n    # Iterate over each string of parentheses\n    for paren_group\
    \ in split(paren_string, \" \")\n        \n        # Initialize variables\n  \
    \      max_lev = 0\n        cur_lev = 0\n        \n        # Iterate over the\
    \ characters of the string\n        for i in 1:length(paren_group)\n         \
    \   \n            # Increment the level if we find a ( and decrement if we find\
    \ a )\n            if paren_group[i] == '('\n                cur_lev += 1\n  \
    \          elseif paren_group[i] == ')'\n                cur_lev -= 1\n      \
    \      end\n            \n            # Update the current maximum level\n   \
    \         if cur_lev > max_lev\n                max_lev = cur_lev\n          \
    \  end\n        end\n        \n        # Append the maximum level to the vector\
    \ of max levels\n        push!(lev, max_lev)\n    end\n    \n    # Return the\
    \ vector of max levels\n    return lev\nend", "    # Using a stack to track all\
    \ parentheses in string,\n    # and another vector to track the nesting level\
    \ for each parens\n    paren_stack = [] # Vector{Char}()\n    paren_level = []\
    \ # Vector{Int64}()\n    result = [] # Vector{Int64}()\n    for char_idx in 1:length(paren_string)\n\
    \        c = paren_string[char_idx]\n        if c == '('\n            push!(paren_stack,\
    \ c)\n            push!(paren_level, 1)\n        elseif c == ')'\n           \
    \ if length(paren_stack) > 0\n                # Remove the most recent \"(\" from\
    \ the stack and add one to level\n                # of the current \")\"\n   \
    \             pop!(paren_stack)\n                paren_level[end] += 1\n     \
    \       else\n                # Current \")\" matches no \"(\" in the stack\n\
    \                # This is considered as an invalid input to this function\n \
    \               println(\"Invalid input string: \", paren_string)\n          \
    \      return []\n            end\n        elseif c == ' '\n            # If the\
    \ most recent paren is \")\", push it to the result\n            if length(paren_stack)\
    \ == 0\n                push!(result, paren_level[end])\n                pop!(paren_level)\n\
    \            end\n        else\n            # This is considered as an invalid\
    \ input to this function\n            println(\"Invalid input string: \", paren_string)\n\
    \            return []\n        end\n    end\n    # Handle the last part of the\
    \ string that is not separated by space\n    if length(paren_stack) == 0\n   \
    \     push!(result, paren_level[end])\n    else\n        println(\"Invalid input\
    \ string: \", paren_string)\n        return []\n    end\n    return result\nend",
  "    paren_vec = map(x -> length(x), split(paren_string, \" \"))\n    return paren_vec\n\
    end", "    groups = split(paren_string, \" \")\n    depths = [count_depth(x) for\
    \ x in groups]\n    return depths\nend", "    count_levels(p) = maximum(cumsum(map(d\
    \ -> 1 - 2*(d == ')'), p)))\n    return map(count_levels, split(paren_string,\
    \ \" \"))\nend", "    # Extract the individual groups of parens separated by spaces\n\
    \    paren_str_arr = split(paren_string, \" \")\n    # Create empty array to store\
    \ the levels of nesting for each group\n    levels = Int64[]\n    # Loop through\
    \ each group\n    for paren_str in paren_str_arr\n        num_open = 0\n     \
    \   level = 0\n        # Loop through each character in the group\n        for\
    \ char in paren_str\n            # Increment level of nesting for every open bracket\n\
    \            if char == '('\n                num_open += 1\n                level\
    \ = max(level, num_open)\n            # Decrement level of nesting for every close\
    \ bracket\n            elseif char == ')'\n                num_open -= 1\n   \
    \         end\n        end\n        # Append the level of nesting for that group\n\
    \        push!(levels, level)\n    end\n    return levels\nend", "    num_parens\
    \ = length(paren_string)\n    # Initialize a vector of zeros representing the\
    \ deepest nesting\n    # for each group of parentheses\n    max_nesting = zeros(Int64,\
    \ num_parens)\n    # Iterate through every character in the string\n    for i\
    \ in 1:num_parens\n        # Check if the current character is an opening parenthesis\n\
    \        if paren_string[i] == '('\n            # If so, increase the nesting\
    \ depth by 1\n            max_nesting[i] += 1\n            # Record the maximum\
    \ value\n            max_nesting[i+1] = max(max_nesting[i+1], max_nesting[i])\n\
    \        # Check if the current character is a closing parenthesis\n        elseif\
    \ paren_string[i] == ')'\n            # If so, decrease the nesting depth by 1\n\
    \            max_nesting[i] -= 1\n            # Record the maximum value\n   \
    \         max_nesting[i+1] = max(max_nesting[i+1], max_nesting[i])\n        #\
    \ If the current character is not a parenthesis,\n        # do nothing\n     \
    \   end\n    end\n    # Return the maximum nested value for each group of parentheses\n\
    \    return max_nesting[1:num_parens]\nend;\n \nparen_string = \"(()()) ((()))\
    \ () ((())()())\";\nparse_nested_parens(paren_string)", "    open_parens = 0\n\
    \    max_open_parens = 0\n    result = zeros(Int64, length(paren_string))\n  \
    \  current_word = 1\n    # parse each character and update the depth\n    for\
    \ i in 1:length(paren_string)\n        current_char = paren_string[i]\n      \
    \  if current_char == '('\n            open_parens += 1\n            max_open_parens\
    \ = max(max_open_parens, open_parens)\n        elseif current_char == ')'\n  \
    \          open_parens -= 1\n        elseif current_char == ' '\n            result[current_word]\
    \ = max_open_parens\n            current_word += 1\n            max_open_parens\
    \ = 0\n        end\n    end\n    # don't forget to parse the last word as well!\n\
    \    result[current_word] = max_open_parens\n    return result\nend", "    \"\"\
    \" get list of positions of each pair of parentheses in the string\n    \"\"\"\
    \n    paren_list = positions(paren_string, r\"\\(|\\)\")", "    nested_count =\
    \ []\n    for group in split(paren_string, ' ')\n        current_count = 0\n \
    \       max_count = 0\n        for letter in group\n            if letter == '('\n\
    \                current_count += 1\n            elseif letter == ')'\n      \
    \          current_count -= 1\n            end\n            if current_count >\
    \ max_count\n                max_count = current_count\n            end\n    \
    \    end\n        push!(nested_count, max_count)\n    end\n    return nested_count\n\
    end", "    paren_levels = Array{Int64}(undef, length(split(paren_string)))\n \
    \   for (i, group) in enumerate(split(paren_string))\n        paren_levels[i]\
    \ = compute_nested_parens(group)\n    end\n    return paren_levels\nend", "  \
    \  groups = split(paren_string, \" \")\n    depth = Vector{Int64}(undef, length(groups))\n\
    \    for (i,g) in enumerate(groups)\n        open_parens = 0\n        max_open_parens\
    \ = 0\n        for p in g\n            if p == '('\n                open_parens\
    \ += 1\n                max_open_parens = max(max_open_parens, open_parens)\n\
    \            elseif p == ')'\n                open_parens -= 1\n            end\n\
    \        end\n        depth[i] = max_open_parens\n    end\n    return depth\n\
    end", "    # For each group, the deepest level of nesting of parentheses.\n  \
    \  levels = Vector{Int64}()\n    paren_groups = split(paren_string, \" \")\n \
    \   for paren_group in paren_groups\n        # Open parenthesis add 1 to the counter\n\
    \        # Close parenthesis subtract 1 from the counter\n        level = 0 \n\
    \        max_level = 0\n        for letter in paren_group\n            level +=\
    \ (letter == '(') ? 1 : -1\n            if max_level < level\n               \
    \ max_level = level\n            end\n        end\n        push!(levels, max_level)\n\
    \    end\n    return levels\nend", "    paren_list = split(paren_string, ' ')\n\
    \    for paren in paren_list\n        depth = 0\n        max_depth = 0\n     \
    \   for char in paren\n            if char == '('\n                depth += 1\n\
    \            elseif char == ')'\n                depth -= 1\n            end\n\
    \            if depth > max_depth\n                max_depth = depth\n       \
    \     end\n        end\n        push!(return_vector, max_depth)\n    end\n   \
    \ return return_vector\nend", "    return map(x -> find_max_level(x), split(paren_string,\
    \ \" \"))\nend", "    groups = split(paren_string)\n    max_nesting = Array{Int64}(undef,\
    \ length(groups))\n    for i in 1:length(groups)\n        g = groups[i]\n    \
    \    n = 0\n        m = 0\n        for c in g\n            if c == '('\n     \
    \           n += 1\n                m = max(m, n)\n            elseif c == ')'\n\
    \                n -= 1\n            end\n        end\n        max_nesting[i]\
    \ = m\n    end\n    return max_nesting\nend;", "    stack = Int64[]\n    max_level\
    \ = Int64[]\n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string\
    \ = replace(paren_string, \"(\", \"( \")\n    paren_string = replace(paren_string,\
    \ \")\", \" )\")\n    temp = split(paren_string)\n    i = 0\n    while i < length(temp)\n\
    \        if temp[i] == \"(\"\n            push!(stack, 1)\n        elseif temp[i]\
    \ == \")\"\n            push!(max_level, length(stack))\n            pop!(stack)\n\
    \        end\n        i += 1\n    end\n    return max_level\nend", "    paren_list\
    \ = split(paren_string, \" \")\n    counter = [0 for i in 1:length(paren_list)]\n\
    \    for (i, s) in enumerate(paren_list)\n        level = 0\n        for c in\
    \ s\n            if c == '('\n                level += 1\n            elseif c\
    \ == ')'\n                counter[i] = max(counter[i], level)\n              \
    \  level -= 1\n            end\n        end\n    end\n    return counter\nend",
  "    inner_parens = split(paren_string, \" \")\n    inner_parens = map(x -> x[2:end-1],\
    \ inner_parens)\n    paren_depth = []\n    for n in inner_parens\n        paren_depth\
    \ = push!(paren_depth, parser(n))\n    end\n    return paren_depth\nend", "  \
    \  # output vector of max level of nesting of each group\n    depth = Vector{Int64}(undef,\
    \ length(split(paren_string, \" \")))\n    # depth of current group\n    depth_current\
    \ = 0\n    # index of current group\n    group_num = 1\n    # iterate through\
    \ groups\n    for group in split(paren_string, \" \")\n        # iterate through\
    \ parentheses of current group\n        for paren in group\n            if paren\
    \ == '('\n                depth_current += 1\n            elseif paren == ')'\n\
    \                depth_current -= 1\n            end\n        end\n        depth[group_num]\
    \ = depth_current\n        depth_current = 0\n        group_num += 1\n    end\n\
    \    return depth\nend", "    # remove spaces from the string\n    paren_string\
    \ = replace(paren_string, \" \" => \"\")\n    n_groups = length(split(paren_string,\
    \ \")\"))\n    max_nest = Vector{Int64}(undef, n_groups)\n    paren_level = 0\n\
    \    current_group = 1\n    # we iterate over each character in the string\n \
    \   for i in 1:length(paren_string)\n        # if we encounter an opening bracket,\
    \ the level increases by 1\n        if paren_string[i] == '('\n            paren_level\
    \ += 1\n        # if we encounter a closing bracket, the level decreases by 1\n\
    \        elseif paren_string[i] == ')'\n            paren_level -= 1\n       \
    \ # if we encounter a closing bracket, we assign the parenthesis level to the\
    \ corresponding group\n        if paren_string[i] == ')'\n            max_nest[current_group]\
    \ = paren_level\n            current_group += 1\n        end\n    end\n    return\
    \ max_nest\nend", "    paren_string = replace(paren_string, \" \", \"\")\n   \
    \ nest_counts = zeros(Int64, length(paren_string))\n    current_nest_count = 0\n\
    \    for i in 1:length(paren_string)\n        if paren_string[i] == '('\n    \
    \        current_nest_count += 1\n        elseif paren_string[i] == ')'\n    \
    \        current_nest_count -= 1\n        end\n        nest_counts[i] = current_nest_count\n\
    \    end\n    out = []\n    for i in 1:length(paren_string)\n        if paren_string[i]\
    \ == '('\n            for j in i:length(paren_string)\n                if paren_string[j]\
    \ == ')'\n                    push!(out, max(nest_counts[i:j]))\n            \
    \        break\n                end\n            end\n        end\n    end\n \
    \   return out\nend\n \nparse_nested_parens(\"(()()) ((())) () ((())()())\")",
  "    count_array = Vector{Int64}(undef, length(paren_string))\n    open_paren_count\
    \ = 0\n    close_paren_count = 0\n    index = 1\n    for paren in paren_string\n\
    \        if paren == '('\n            open_paren_count += 1\n        elseif paren\
    \ == ')'\n            close_paren_count += 1\n        else\n            count_array[index]\
    \ = open_paren_count - close_paren_count\n            index += 1\n           \
    \ open_paren_count = 0\n            close_paren_count = 0\n        end\n    end\n\
    \    return count_array\nend", "    # String -> Vector{Int64}\n    # Function\
    \ to count maximum level of nesting of parentheses\n    # Input is a string of\
    \ multiple groups of parenthesis\n    # Output is a vector of the level of the\
    \ deepest nesting of each group\n    paren_string = split(paren_string, \" \"\
    )\n    max_depth = Vector{Int64}(length(paren_string))\n    @inbounds for i in\
    \ 1:length(paren_string)\n        level = 0\n        max_level = 0\n        for\
    \ j in 1:length(paren_string[i])\n            if paren_string[i][j] == '('\n \
    \               level += 1\n            elseif paren_string[i][j] == ')'\n   \
    \             level -= 1\n            end\n            if level > max_level\n\
    \                max_level = level\n            end\n        end\n        max_depth[i]\
    \ = max_level\n    end\n    return max_depth\nend", "    paren_list = split(paren_string,\
    \ \" \")\n    n_paren_list = length(paren_list)\n    max_nest_list = zeros(Int64,\
    \ n_paren_list)\n    for i in 1:n_paren_list\n        max_nest_list[i] = calculate_max_nest(paren_list[i])\n\
    \    end\n    return max_nest_list\nend", "    res = Vector{Int64}(undef, length(split(paren_string)))\n\
    \    for (i, group) in enumerate(split(paren_string))\n        depth = 0\n   \
    \     for char in group\n            if char == '('\n                depth +=\
    \ 1\n            elseif char == ')'\n                depth -= 1\n            end\n\
    \        end\n        res[i] = depth\n    end\n    return res\nend", "    group_list\
    \ = split(paren_string, \" \")\n    max_depth_list = Int64[]\n    for group in\
    \ group_list\n        group_stack = Int64[]\n        max_depth = 0\n        for\
    \ i in 1:length(group)\n            if group[i] == '('\n                push!(group_stack,\
    \ 1)\n                if length(group_stack) > max_depth\n                   \
    \ max_depth = length(group_stack)\n                end\n            elseif group[i]\
    \ == ')'\n                pop!(group_stack)\n            end\n        end\n  \
    \      push!(max_depth_list, max_depth)\n    end\n    return max_depth_list\n\
    end", "    paren_groups = paren_string |> split\n    paren_counts = zeros(Int64,\
    \ length(paren_groups))\n    for (i, paren_group) in enumerate(paren_groups)\n\
    \        paren_counts[i] = count_parens(paren_group)\n    end\n    return paren_counts\n\
    end"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
